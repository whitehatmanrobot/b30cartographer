       if (NameCount == 0)
        {
            MitRealm->Flags |= KERB_MIT_REALM_KPWD_LOOKUP;
        }

        KerbInsertListEntry(
            &MitRealm->Next,
            &KerbMitRealmList
            );
        MitRealm = NULL;
    }
    

Cleanup:

    if (fListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }

    if( DomainKey != NULL )
    {
        RegCloseKey( DomainKey );
    }

    if (KdcNames != NULL)
    {
        KerbFree(KdcNames);
    }
    if (KpasswdNames != NULL)
    {
        KerbFree(KpasswdNames);
    }
    if (AlternateRealmNames != NULL)
    {
        KerbFree(AlternateRealmNames);
    }
    if (MitRealm != NULL)
    {
        if (MitRealm->AlternateRealmNames != NULL)
        {
#if 0   // note: embededded buffers are all enclosed within AlternateRealmNames[0]
            for(Index = 0 ; Index < MitRealm->RealmNameCount ; Index++)
            {
                if (MitRealm->AlternateRealmNames[Index].Buffer != NULL)
                {
                    KerbFree(MitRealm->AlternateRealmNames[Index].Buffer);
                }
            }
#else
            if (MitRealm->AlternateRealmNames[0].Buffer != NULL)
            {
                KerbFree(MitRealm->AlternateRealmNames[0].Buffer);
            }
#endif

            KerbFree(MitRealm->AlternateRealmNames);
        }
        if (MitRealm->KdcNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KdcNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KdcNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KdcNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KdcNames.ServerNames);
        }
        if (MitRealm->KpasswdNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KpasswdNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KpasswdNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KpasswdNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KpasswdNames.ServerNames);
        }
        KerbFree(MitRealm);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupMitRealmList
//
//  Synopsis:   Frees the list of MIT realms
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupMitRealmList(
    )
{
    PKERB_MIT_REALM MitRealm;

    KerbLockList(&KerbMitRealmList);

    if (KerbMitRealmList.List.Flink == NULL)
    {
        goto Cleanup;
    }

    while (!IsListEmpty(&KerbMitRealmList.List))
    {
        MitRealm = CONTAINING_RECORD(
                        KerbMitRealmList.List.Flink,
                        KERB_MIT_REALM,
                        Next
                            );

        KerbReferenceListEntry(
            &KerbMitRealmList,
            &MitRealm->Next,
            TRUE
            );

        if (MitRealm->AlternateRealmNames != NULL)
        {
            if (MitRealm->AlternateRealmNames[0].Buffer != NULL)
            {
                KerbFree(MitRealm->AlternateRealmNames[0].Buffer);
            }
            KerbFree(MitRealm->AlternateRealmNames);
        }

        if (MitRealm->KdcNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KdcNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KdcNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KdcNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KdcNames.ServerNames);
        }
        if (MitRealm->KpasswdNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KpasswdNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KpasswdNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KpasswdNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KpasswdNames.ServerNames);
        }

        if (MitRealm->RealmName.Buffer != NULL)
        {
           MIDL_user_free(MitRealm->RealmName.Buffer);        

        }
                                              
        KerbFree(MitRealm);
    }

Cleanup:

    KerbUnlockList(&KerbMitRealmList);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitRealm
//
//  Synopsis:   Looks up an MIT realm name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbLookupMitRealm(
    IN PUNICODE_STRING RealmName,
    OUT PKERB_MIT_REALM * MitRealm,
    OUT PBOOLEAN UsedAlternateName
    )                                                                                                                     
{
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PKERB_MIT_REALM CurrentRealm;
    BOOLEAN fReturn = FALSE;
    BOOLEAN fListLocked = FALSE;

    *UsedAlternateName = FALSE;
    *MitRealm = NULL;

    if (RealmName->Length == 0)
    {
        goto Cleanup;
    }

    KerbLockList(&KerbMitRealmList);
    fListLocked = TRUE;


    for (ListEntry = KerbMitRealmList.List.Flink ;
         ListEntry != &KerbMitRealmList.List ;
         ListEntry = ListEntry->Flink )
    {
        CurrentRealm = CONTAINING_RECORD(ListEntry, KERB_MIT_REALM, Next);

        if (RtlEqualUnicodeString(
                RealmName,
                &CurrentRealm->RealmName,
                TRUE))
        {
            *MitRealm = CurrentRealm;
            fReturn = TRUE;
            goto Cleanup;
        }

        //
        // Check for an alternate name for the realm
        //

        for (Index = 0; Index < CurrentRealm->RealmNameCount ; Index++ )
        {
            if (RtlEqualUnicodeString(
                    RealmName,
                    &CurrentRealm->AlternateRealmNames[Index],
                    TRUE))
            {
                *UsedAlternateName = TRUE;
                *MitRealm = CurrentRealm;
                fReturn = TRUE;
                goto Cleanup;
            }

        }

    }
Cleanup:
    if (fListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }
    return(fReturn);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchMITKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on MIT key and
//              utilizes thread pool to wait on changes to this
//              registry key.  Enables dynamic changing of MIT
//              realms as this function will also be callback
//              if the registry key is modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//

void
KerbWatchMITKey(PVOID    pCtxt,
                BOOLEAN  fWaitStatus)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Error;
   

    KerbCleanupMitRealmList();
    Status = KerbReadMitRealmList();
    if (!NT_SUCCESS(Status)) 
    {
        D_DebugLog((DEB_ERROR,"Debug reading MIT realm list failed: 0x%x\n", Status));
    }

    if (NULL != hKerbMITRealmWaitEvent)
    {
        Error = RegNotifyChangeKeyValue(
                    KerbMITRealmRootKey,
                    TRUE,
                    REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                    hKerbMITRealmWaitEvent,
                    TRUE);

        if (ERROR_SUCCESS != Error) 
        {
            D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", Status));
            // we're tanked now. No further notifications, so get this one
        }
    }

    return; 
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitializeMitRealmList(
    )
{
    ULONG Disposition;
    ULONG Error;
    HKEY RootKey = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Open the domains root key - if it is not there, so be it.
    //

    Error = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                KERB_DOMAINS_KEY,
                0,
                NULL,
                0,
                KEY_READ,
                NULL,
                &RootKey,
                &Disposition);

    if (ERROR_SUCCESS != Error)
    {
        D_DebugLog((DEB_WARN,"Failed to open MIT realm key: 0x%x\n", Status));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Initialize the list
    //
    Status = KerbInitializeList( &KerbMitRealmList );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Intialization of MIT realm list failed - 0x%x\n", Status));
        goto Cleanup;
    }

    hKerbMITRealmWaitEvent = CreateEventW( NULL, FALSE, FALSE, NULL );

    if (NULL == hKerbMITRealmWaitEvent) 
    {
        D_DebugLog((DEB_ERROR, "CreateEvent for MIT realm list wait failed - 0x%x\n", GetLastError()));
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    KerbMITRealmRootKey = RootKey;
    RootKey = NULL;

    //
    // read in the list and setup the RegNotify
    //
    KerbWatchMITKey(NULL, FALSE);

    hKerbMITRealmWaitObject = RegisterWaitForSingleObjectEx(
                                    hKerbMITRealmWaitEvent,
                                    KerbWatchMITKey,
                                    NULL,
                                    INFINITE,
                                    0 // dwFlags
                                    );

Cleanup:

    if( RootKey != NULL )
    {
        RegCloseKey( RootKey );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUninitializeMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbUninitializeMitRealmList(
    )
{
    if( hKerbMITRealmWaitObject )
        UnregisterWait( hKerbMITRealmWaitObject );

    if( hKerbMITRealmWaitEvent )
        CloseHandle( hKerbMITRealmWaitEvent );

    KerbCleanupMitRealmList();

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitSrvRecords
//
//  Synopsis:   Looks up MIT KDCs / Kpassword in DNS
//
//  Effects:    Builds MIT_SERVER_LIST for specified realm, and adds it to
//              MIT REALM LIST
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbLookupMitSrvRecords(IN PKERB_MIT_REALM RealmEntry,
                        IN BOOLEAN Kpasswd,
                        IN BOOLEAN UseTcp
                        )
{
   
   ANSI_STRING DnsRecordName; 
   ANSI_STRING AnsiRealmName;
   HANDLE SrvContext = NULL;
   BOOLEAN UsedAlternateName, ListLocked = FALSE;
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG AddressCount = 0, SrvCount = 0;
   ULONG Index = 0, uBuff = 0;
   LPSOCKET_ADDRESS Addresses = NULL;
   NET_API_STATUS NetApiStatus = NERR_Success;
   LPSTR pDnsName[MAX_SRV_RECORDS];
   
   PKERB_MIT_SERVER_LIST ServerList = NULL;
   PUNICODE_STRING       ServerNames = NULL, ptr = NULL;

   TimeStamp CurrentTime, Timeout;
   
   
   //
   // Test to see if we need to do a lookup, or if its time to try again
   //
   if (RealmEntry->LastLookup.QuadPart != 0 )
   {  
       GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );  
       KerbSetTimeInMinutes(&Timeout, DNS_LOOKUP_TIMEOUT);
      
       if (KerbGetTime(RealmEntry->LastLookup) + KerbGetTime(Timeout) < KerbGetTime(CurrentTime))
       {
          return STATUS_SUCCESS;
       }
   }
   // Kpasswd only uses UDP
   if (Kpasswd)
   {
      UseTcp = FALSE;
   } 
                           
   
   RtlInitAnsiString(&DnsRecordName,NULL);
   RtlInitAnsiString(&AnsiRealmName,NULL);
   DnsRecordName.Length = (RealmEntry->RealmName.Length / sizeof(WCHAR)) + DNS_MAX_PREFIX + 1;
   DnsRecordName.MaximumLength = DnsRecordName.Length;
   DnsRecordName.Buffer = (PCHAR) KerbAllocate(DnsRecordName.Length);
   if (NULL == DnsRecordName.Buffer)
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlUnicodeStringToAnsiString(
         &AnsiRealmName,
         &RealmEntry->RealmName,
         TRUE
         );


   sprintf(DnsRecordName.Buffer,
           "%s%s%s",
           (Kpasswd ? DNS_KPASSWD : DNS_KERBEROS),
           (UseTcp ? DNS_TCP : DNS_UDP),
           AnsiRealmName.Buffer
           );

   NetApiStatus = NetpSrvOpen(
                     DnsRecordName.Buffer,
                     0,
                     &SrvContext
                     );

   if (NERR_Success != NetApiStatus)
   {
      D_DebugLog((DEB_WARN, 
                "No SRV records for MIT Realm %wZ - %x\n", 
                RealmEntry->RealmName, 
                NetApiStatus
                ));
      
      Status = STATUS_SUCCESS;
      goto Cleanup;
   }  

   // Loop and update server list for realm 
   for (SrvCount = 0; SrvCount < MAX_SRV_RECORDS; SrvCount++)
   {

      NetApiStatus = NetpSrvNext(
                        SrvContext,
                        &AddressCount,
                        &Addresses,
                        &pDnsName[SrvCount]
                        );

      if (NERR_Success != NetApiStatus)
      {
        if( ERROR_NO_MORE_ITEMS == NetApiStatus) // we're through
        {
           NetApiStatus = NERR_Success;
           break;
        }

        D_DebugLog((DEB_ERROR, "NetpSrvNext failed: %s - %x\n",DnsRecordName.Buffer, NetApiStatus));
        Status = NetApiStatus;
        goto Cleanup;
      }
      
   }

   
   KerbLockList(&KerbMitRealmList);
   ListLocked = TRUE;
   // Loop through available server names, and copy
   if (Kpasswd)
   {
      ServerList = &RealmEntry->KpasswdNames;
   }
   else 
   {
      ServerList = &RealmEntry->KdcNames;
   }
   
   // reg entries are always at beginning of server list.
   uBuff = ( SrvCount  * sizeof(UNICODE_STRING));
      
   ServerNames = (PUNICODE_STRING) KerbAllocate(uBuff);
   if (NULL == ServerNames)
   {
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Cleanup;
   }
   
                                              
   for (Index = 0; Index < SrvCount;Index++)
   {
      if (!KerbMbStringToUnicodeString(
                        &ServerNames[Index ],
                        pDnsName[Index]
                        )) 
      {
         D_DebugLog((DEB_ERROR,"KerbConvertMbStringToUnicodeString failed!\n"));
         continue; // let's keep going.  Maybe we're not hosed.
      }
      
   }
   
   KerbFreeServerNames(ServerList);
   ServerList->ServerCount = SrvCount;
   ServerList->ServerNames = ServerNames;

   RealmEntry->Flags 
       &= ~( Kpasswd ? KERB_MIT_REALM_KPWD_LOOKUP : KERB_MIT_REALM_KDC_LOOKUP );

Cleanup:
   
    // always update realm entry, even on failure
    if (!ListLocked)
    {   
        KerbLockList(&KerbMitRealmList);
        ListLocked = TRUE;
    }                    
    
    GetSystemTimeAsFileTime((PFILETIME)  &RealmEntry->LastLookup);
   
    if (ListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }
   
    if (AnsiRealmName.Buffer != NULL)
    {                                    
        RtlFreeAnsiString(&AnsiRealmName);
    }

    if (DnsRecordName.Buffer != NULL)
    {
        KerbFree(DnsRecordName.Buffer);
    }

    if (SrvContext != NULL)
    {
        NetpSrvClose(SrvContext);
    }             

    return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeServerNames
//
//  Synopsis:   Frees server names PUNICODE_STRING array
//
//  Effects:    
//              
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
void
KerbFreeServerNames(PKERB_MIT_SERVER_LIST ServerList)
{
   LONG Index = 0;

   for (Index = 0; Index < ServerList->ServerCount; Index++)
   {
      if (ServerList->ServerNames[Index].Buffer != NULL)
      {
         KerbFree(ServerList->ServerNames[Index].Buffer);
      }                                  
   }

   KerbFree(ServerList->ServerNames); // free UNICODE_STRING array
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitRealmWithSrvLookup
//
//  Synopsis:   Frees server names PUNICODE_STRING array
//
//  Effects:    
//              
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbLookupMitRealmWithSrvLookup(PUNICODE_STRING RealmName,
                                PKERB_MIT_REALM* MitRealm,
                                BOOLEAN   Kpasswd,
                                BOOLEAN   UseTcp)
{
   BOOLEAN  UsedAlternateName, fRet = FALSE;
   NTSTATUS Status;

   fRet = KerbLookupMitRealm(
            RealmName,
            MitRealm,
            &UsedAlternateName
            );
   
   //
   // Found an MIT realm.  See if its time to check on SRV records
   //
   if ( fRet )
   {    

       if ((((*MitRealm)->Flags & KERB_MIT_REALM_KDC_LOOKUP) && !Kpasswd ) ||
           (((*MitRealm)->Flags & KERB_MIT_REALM_KPWD_LOOKUP) && Kpasswd ))
       {              
          Status = KerbLookupMitSrvRecords(
                        (*MitRealm), 
                        Kpasswd,
                        UseTcp
                        );
       
          if (Status != STATUS_SUCCESS)
          {
              D_DebugLog((DEB_TRACE, "KerbLookupMitRealmWIthSrvLookup failed - %x\n", Status));
          }
       }
   }
                                                                                     
   return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\miscapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        miscapi.cxx
//
// Contents:    Code for miscellaneous lsa mode Kerberos entrypoints
//
//
// History:     16-April-1996   MikeSw  Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <crypt.h>      // NT_OWF_PASSWORD_LENGTH
#include <kerbpass.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//
// LsaApCallPackage() function dispatch table
//

NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

PLSA_AP_CALL_PACKAGE
KerbCallPackageDispatch[] = {
#if DBG
    KerbDebugRequest,
#else
    NULL,
#endif
    KerbQueryTicketCache,
    KerbChangeMachinePassword,
    KerbVerifyPac,
    KerbRetrieveTicket,
    KerbSetIpAddresses,
    KerbPurgeTicket,
    KerbChangePassword,
    KerbRetrieveEncodedTicket,
#if DBG
    KerbDecryptMessage,
#else
    NULL,    
#endif
    KerbAddBindingCacheEntry,
    KerbSetPassword,
    KerbSetPassword,
    KerbVerifyCredentials,
    KerbQueryTicketCacheEx,
    KerbPurgeTicketEx,
//  KerbRetrieveEncodedTicketEx,
    };



//+-------------------------------------------------------------------------
//
//  Function:   SpGetUserInfo
//
//  Synopsis:   Gets information about a user
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    return(STATUS_NOT_SUPPORTED);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApCallPackage
//
//  Synopsis:   Kerberos entrypoint for LsaCallAuthenticationPackage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG MessageType;
    PLSA_AP_CALL_PACKAGE TempFn = NULL;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ((MessageType >=
         (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0]))) ||
         (KerbCallPackageDispatch[MessageType] == NULL))
    {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    TempFn = KerbCallPackageDispatch[MessageType];
    if (!TempFn)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    Status = (*TempFn)(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus );

//    RtlCheckForOrphanedCriticalSections(NtCurrentThread());

Cleanup:
    return(Status);

}


NTSTATUS NTAPI
LsaApCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Untrusted clients are not allowed to call the ChangeMachinePassword function
    //

    if (MessageType == KerbChangeMachinePasswordMessage)
    {
        return STATUS_ACCESS_DENIED;
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //
                                                        
    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}


NTSTATUS NTAPI
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // only allow passthrough related requests.
    //

    if (MessageType != KerbVerifyPacMessage)
    {
        return STATUS_ACCESS_DENIED;
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDebugRequest
//
//  Synopsis:   CallPackage entrypoint for debugging
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    PVOID Handle = NULL;
    PBYTE AuthData = NULL;
    UNICODE_STRING AccountName = {0};

    BYTE Buffer[sizeof(KERB_DEBUG_REPLY) + sizeof(KERB_DEBUG_STATS) - sizeof(UCHAR) * ANYSIZE_ARRAY];
    PKERB_DEBUG_REQUEST DebugRequest;
    PKERB_DEBUG_REPLY   DebugReply = (PKERB_DEBUG_REPLY) Buffer;
    PKERB_DEBUG_STATS   DebugStats = (PKERB_DEBUG_STATS) DebugReply->Data;

    if (SubmitBufferLength < sizeof(*DebugRequest)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DebugRequest = (PKERB_DEBUG_REQUEST) ProtocolSubmitBuffer;
    switch(DebugRequest->DebugRequest) {
    case KERB_DEBUG_REQ_BREAKPOINT:
        DbgBreakPoint();
        break;

    case KERB_DEBUG_REQ_STATISTICS:
        DebugReply->MessageType = KerbDebugRequestMessage;
        DebugStats->CacheHits = KerbTicketCacheHits;
        DebugStats->CacheMisses = KerbTicketCacheMisses;
        DebugStats->SkewedRequests = KerbSkewState.SkewedRequests;
        DebugStats->SuccessRequests = KerbSkewState.SuccessRequests;
        DebugStats->LastSync = KerbSkewState.LastSync;
        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    ProtocolReturnBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    *ProtocolReturnBuffer,
                    DebugReply
                    );
        if (!NT_SUCCESS(Status))
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                *ProtocolReturnBuffer
                );
            *ProtocolReturnBuffer = NULL;
        }
        else
        {
            *ReturnBufferLength = sizeof(Buffer);
        }

        break;

    case KERB_DEBUG_CREATE_TOKEN:
    {
        UNICODE_STRING String, String2;
        ULONG AuthDataSize = 0;
        HANDLE TokenHandle = NULL;
        LUID LogonId;
        NTSTATUS SubStatus;

        RtlInitUnicodeString(
            &String,
            L"Administrator"
            );
        RtlInitUnicodeString(
            &String2,
            NULL
            );

        Status = LsaFunctions->OpenSamUser(
                    &String,
                    SecNameSamCompatible,
                    &String2,
                    TRUE,               // allow guest
                    0,                  // reserved
                    &Handle
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to open sam user: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        Status = LsaFunctions->GetUserAuthData(
                    Handle,
                    &AuthData,
                    &AuthDataSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to get auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Now create that token
        //

        Status = LsaFunctions->ConvertAuthDataToToken(
                    AuthData,
                    AuthDataSize,
                    SecurityImpersonation,
                    &KerberosSource,
                    Network,
                    &String,
                    &TokenHandle,
                    &LogonId,
                    &AccountName,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to create token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        NtClose(TokenHandle);
        DebugLog((DEB_ERROR,"Logged on account is %wZ. %ws, line %d\n",&AccountName, THIS_FILE, __LINE__));
        break;

    }

    default:
        Status = STATUS_INVALID_PARAMETER;
    }

Cleanup:

    if( Handle != NULL )
    {
        LsaFunctions->CloseSamUser( Handle );
    }

    if( AuthData != NULL )
    {
        LsaFunctions->FreeLsaHeap( AuthData );
    }

    if( AccountName.Buffer != NULL )
    {
        LsaFunctions->FreeLsaHeap( AccountName.Buffer );
    }

#else
    Status = STATUS_INVALID_PARAMETER;
#endif
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbChangeMachinePassword
//
//  Synopsis:   Notifies Kerberos when the machine password has changed
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS                      Status = STATUS_SUCCESS;
    LUID                          SystemLogonId = SYSTEM_LUID;
    PKERB_LOGON_SESSION           SystemLogonSession = NULL;
    PKERB_CHANGE_MACH_PWD_REQUEST ChangeRequest;
    ULONG                         StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST);

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }

#if _WIN64

    SECPKG_CALL_INFO              CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST_WOW64);
    }

#endif  // _WIN64

    if (SubmitBufferLength < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    ChangeRequest = (PKERB_CHANGE_MACH_PWD_REQUEST) ProtocolSubmitBuffer;

#if _WIN64

    KERB_CHANGE_MACH_PWD_REQUEST LocalChangeRequest;

    //
    // Thunk 32-bit pointers if this is a WOW caller
    //

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PKERB_CHANGE_MACH_PWD_REQUEST_WOW64 ChangeRequestWOW =
            (PKERB_CHANGE_MACH_PWD_REQUEST_WOW64) ChangeRequest;

        LocalChangeRequest.MessageType = ChangeRequest->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.NewPassword,
                                       &ChangeRequestWOW->NewPassword);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.OldPassword,
                                       &ChangeRequestWOW->OldPassword);

        ChangeRequest = &LocalChangeRequest;
    }

#endif  // _WIN64


    //
    // Find the system logon session.
    //

    SystemLogonSession = KerbReferenceLogonSession(
                            &SystemLogonId,
                            FALSE               // don't unlink
                            );

    DsysAssert(SystemLogonSession != NULL);
    if (SystemLogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }



    //
    // Calculate the new password list
    //

    if (ChangeRequest->NewPassword.Buffer != NULL)
    {
        //
        // If there is an old password, update with that one first so it
        // will later get moved to the old password field.
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        if (ChangeRequest->OldPassword.Buffer != NULL)
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->OldPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }
        if (NT_SUCCESS(Status))
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->NewPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }

        KerbUnlockLogonSessions(SystemLogonSession);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Update the flags to indicate that we have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags &= ~(KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }
    else
    {
        //
        // Update the flags to indicate that we do not have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags |= (KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }


    Status = STATUS_SUCCESS;
Cleanup:
    if (SystemLogonSession != NULL)
    {
        KerbDereferenceLogonSession(SystemLogonSession);
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbNameLength
//
//  Synopsis:   returns length in bytes of variable portion of KERB_INTERNAL_NAME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbWOWNameLength.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------


ULONG
KerbNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    if (!ARGUMENT_PRESENT(Name))
    {
        return(0);
    }
    Length = sizeof(KERB_INTERNAL_NAME)
                - sizeof(UNICODE_STRING)
                + Name->NameCount * sizeof(UNICODE_STRING) ;
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    Length = ROUND_UP_COUNT(Length, sizeof(LPWSTR));
    return(Length);
}

ULONG
KerbStringNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    Length = Name->NameCount * sizeof(WCHAR);   // for separators & null terminator
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    return(Length);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcName
//
//  Synopsis:   Copies a Kdc name to a buffer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWKdcName.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcName(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PKERB_EXTERNAL_NAME * OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    ULONG Index;
    PKERB_INTERNAL_NAME LocalName = (PKERB_INTERNAL_NAME) *Where;

    if (!ARGUMENT_PRESENT(InputName))
    {
        *OutputName = NULL;
        return;
    }
    *Where += sizeof(KERB_INTERNAL_NAME) - sizeof(UNICODE_STRING) +
                InputName->NameCount * sizeof(UNICODE_STRING);
    LocalName->NameType = InputName->NameType;
    LocalName->NameCount = InputName->NameCount;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        LocalName->Names[Index].Length =
            LocalName->Names[Index].MaximumLength =
            InputName->Names[Index].Length;
        LocalName->Names[Index].Buffer = (LPWSTR) (*Where + Offset);
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
    }
    *Where = (PBYTE) ROUND_UP_POINTER(*Where,sizeof(LPWSTR));
    *OutputName = (PKERB_EXTERNAL_NAME) ((PBYTE) LocalName + Offset);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcNameAsString
//
//  Synopsis:   Copies a KERB_INTERNAL_NAME into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcNameAsWOWString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcNameAsString(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PUNICODE_STRING OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    USHORT Index;

    OutputName->Buffer = (LPWSTR) (*Where + Offset);
    OutputName->Length = 0;
    OutputName->MaximumLength = 0;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
        OutputName->Length += InputName->Names[Index].Length;
        if (Index == (InputName->NameCount - 1))
        {
            *((LPWSTR) *Where) = L'\0';
            OutputName->MaximumLength = OutputName->Length + sizeof(WCHAR);
        }
        else
        {
            *((LPWSTR) *Where) = L'/';
            OutputName->Length += sizeof(WCHAR);
        }
        *Where += sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutString(
    IN PUNICODE_STRING InputString,
    OUT PUNICODE_STRING OutputString,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = (LPWSTR) (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSize
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client? (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSize(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[2] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 2 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponse(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[2] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 2 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = (LONG) CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponse->Tickets[*Index].ServerName.Buffer = (LPWSTR) (*Where + *Offset);
                CacheResponse->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponse->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

#if _WIN64

            }
            else
            {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponseWOW64->Tickets[*Index].ServerName.Buffer = PtrToUlong (*Where + *Offset);
                CacheResponseWOW64->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponseWOW64->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }    
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCache
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN LockHeld = FALSE;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    KerbReadLockLogonSessions(LogonSession);
    KerbReadLockTicketCache();
    LockHeld = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSize(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    CacheResponse = ( PKERB_QUERY_TKT_CACHE_RESPONSE )KerbAllocate( CacheSize );

    if ( CacheResponse == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponse(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if (LockHeld)
    {
        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    KerbFree( CacheResponse );

    if (ClientCacheResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSizeEx
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSizeEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[2] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_EX_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 2 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         // client name
                         PrimaryCredentials->UserName.Length +
                         // client realm
                         PrimaryCredentials->DomainName.Length +
                         // server name
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         // server realm
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponseEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[2] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 2 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutString(
                    &PrimaryCredentials->UserName,
                    &CacheResponse->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponse->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );

#if _WIN64

            } else {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutWOWString(
                    &PrimaryCredentials->UserName,
                    &CacheResponseWOW64->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }    
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCacheEx
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN CredmanLocked = FALSE;
    PLIST_ENTRY ListEntry;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    KerbReadLockLogonSessions( LogonSession );
    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSizeEx(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    KerbLockList( &LogonSession->CredmanCredentials );
    CredmanLocked = TRUE;

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbComputeTicketCacheSizeEx(
            CredmanCred->SuppliedCredentials,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &CacheSize,
            &CacheEntries
            );
    }

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    CacheResponse = ( PKERB_QUERY_TKT_CACHE_EX_RESPONSE )KerbAllocate( CacheSize );

    if ( CacheResponse == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheExMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponseEx(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbBuildQueryTicketCacheResponseEx(
            CredmanCred->SuppliedCredentials,
            CacheResponse,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &Offset,
            &Where,
            &Index
            );
    }

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if ( CredmanLocked ) {

        KerbUnlockList( &LogonSession->CredmanCredentials );
    }

    if ( TicketCacheLocked ) {

        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    KerbFree( CacheResponse );

    if ( ClientCacheResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackExternalTicket
//
//  Synopsis:   Marshalls a ticket cache entry for return to the caller
//
//  Effects:    Allocates memory in client's address space
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPackExternalTicket(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOL RetrieveTicketAsKerbCred,
    OUT PULONG ClientTicketSize,
    OUT PUCHAR * ClientTicket
    )
{
    ULONG TicketSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_EXTERNAL_TICKET TicketResponse = NULL;
    PBYTE ClientTicketResponse = NULL;
    KERB_MESSAGE_BUFFER EncodedTicket = {0};
    LONG_PTR Offset;
    PBYTE Where;

    *ClientTicket = NULL;
    *ClientTicketSize = 0;


#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

    //
    // Return a 32-bit external ticket if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64


    //
    // Encode the ticket
    //

    if ( RetrieveTicketAsKerbCred )
    {
        Status = KerbBuildKerbCred(
                     NULL,         // service ticket
                     CacheEntry,
                     &EncodedTicket.Buffer,
                     &EncodedTicket.BufferSize
                     );

        if ( !NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERBERR KerbErr;

        KerbErr = KerbPackData(
                    &CacheEntry->Ticket,
                    KERB_TICKET_PDU,
                    &EncodedTicket.BufferSize,
                    &EncodedTicket.Buffer
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }

    //
    // NOTE:  The 64-bit code below is (effectively) duplicated in
    //        the WOW helper routine.  If modifying one, make sure
    //        to apply the change(s) to the other as well.
    //

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = KerbPackExternalWOWTicket(CacheEntry,
                                           &EncodedTicket,
                                           &TicketResponse,
                                           &ClientTicketResponse,
                                           &TicketSize);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {

#endif  // _WIN64

        TicketSize = sizeof(KERB_EXTERNAL_TICKET) +
                        CacheEntry->DomainName.Length +
                        CacheEntry->TargetDomainName.Length +
                        CacheEntry->AltTargetDomainName.Length +
                        CacheEntry->SessionKey.keyvalue.length +
                        KerbNameLength(CacheEntry->ServiceName) +
                        KerbNameLength(CacheEntry->TargetName) +
                        KerbNameLength(CacheEntry->ClientName) +
                        EncodedTicket.BufferSize
                        ;

        //
        // Now allocate two copies of the structure - one in our process,
        // one in the client's process. We then build the structure in our
        // process but with pointer valid in the client's process
        //

        TicketResponse = (PKERB_EXTERNAL_TICKET) KerbAllocate(TicketSize);
        if (TicketResponse == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    TicketSize,
                    (PVOID *) &ClientTicketResponse
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Offset = (LONG_PTR) (ClientTicketResponse - (PBYTE) TicketResponse);

        Where = ((PUCHAR) (TicketResponse + 1));

        //
        // Copy the non-pointer fields
        //

        TicketResponse->TicketFlags = CacheEntry->TicketFlags;
        TicketResponse->Flags = 0;
        TicketResponse->KeyExpirationTime = CacheEntry->KeyExpirationTime;
        TicketResponse->StartTime = CacheEntry->StartTime;
        TicketResponse->EndTime = CacheEntry->EndTime;
        TicketResponse->RenewUntil = CacheEntry->RenewUntil;
        TicketResponse->TimeSkew = CacheEntry->TimeSkew;
        TicketResponse->SessionKey.KeyType = CacheEntry->SessionKey.keytype;


        //
        // Copy the structure to the client's address space
        //

        //
        // These are PVOID aligned
        //

        //
        // Make sure the two name types are the same
        //

        DsysAssert(sizeof(KERB_INTERNAL_NAME) == sizeof(KERB_EXTERNAL_NAME));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameType) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameType));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameCount) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameCount));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,Names) == FIELD_OFFSET(KERB_EXTERNAL_NAME,Names));

        KerbPutKdcName(
            CacheEntry->ServiceName,
            &TicketResponse->ServiceName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->TargetName,
            &TicketResponse->TargetName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->ClientName,
            &TicketResponse->ClientName,
            Offset,
            &Where
            );


        //
        // From here on, they are WCHAR aligned
        //

        KerbPutString(
            &CacheEntry->DomainName,
            &TicketResponse->DomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->TargetDomainName,
            &TicketResponse->TargetDomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->AltTargetDomainName,
            &TicketResponse->AltTargetDomainName,
            Offset,
            &Where
            );


        //
        // And from here they are BYTE aligned
        //

        TicketResponse->SessionKey.Value = (PBYTE) (Where + Offset);
        RtlCopyMemory(
            Where,
            CacheEntry->SessionKey.keyvalue.value,
            CacheEntry->SessionKey.keyvalue.length
            );
        Where += CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->SessionKey.Length = CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->EncodedTicketSize = EncodedTicket.BufferSize;
        TicketResponse->EncodedTicket = Where + Offset;

        RtlCopyMemory(
            Where,
            EncodedTicket.Buffer,
            EncodedTicket.BufferSize
            );

        Where += EncodedTicket.BufferSize;

        DsysAssert(Where - ((PUCHAR) TicketResponse) == (LONG_PTR) TicketSize);

#if _WIN64

    }

#endif  // _WIN64

    //
    // Copy the mess to the client
    //


    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                TicketSize,
                ClientTicketResponse,
                TicketResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ClientTicket = ClientTicketResponse;
    *ClientTicketSize = TicketSize;

    ClientTicketResponse = NULL;

Cleanup:

    if (EncodedTicket.Buffer != NULL)
    {
        MIDL_user_free(EncodedTicket.Buffer);
    }

    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    if (TicketResponse != NULL)
    {
        KerbFree(TicketResponse);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveTicket
//
//  Synopsis:   Retrieves the initial ticket cache entry.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PBYTE ClientTicketResponse = NULL;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    ULONG TicketSize = 0;

    //
    // Verify the request.
    //
    if (SubmitBufferLength < sizeof(KERB_QUERY_TKT_CACHE_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    CacheRequest = (PKERB_QUERY_TKT_CACHE_REQUEST) ProtocolSubmitBuffer;


    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId ) )
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // elses ticket cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                    LogonId,
                    FALSE               // don't unlink
                    );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now find the TGT from the authentication ticket cache.
    //


    KerbReadLockLogonSessions(LogonSession);


    CacheEntry = KerbLocateTicketCacheEntryByRealm(
                    &LogonSession->PrimaryCredentials.AuthenticationTicketCache,
                    NULL,               // get initial ticket
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );

    KerbUnlockLogonSessions(LogonSession);

    if (CacheEntry == NULL)
    {
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                CacheEntry,
                FALSE,
                &TicketSize,
                &ClientTicketResponse
                );

    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    *ProtocolReturnBuffer = ClientTicketResponse;
    ClientTicketResponse = NULL;
    *ReturnBufferLength = TicketSize;

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }
    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetIpAddresses
//
//  Synopsis:   Saves the IP addresses passed in by netlogon
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_UPDATE_ADDRESSES_REQUEST UpdateRequest;

    //
    // This can only be called internally.
    //

    if (ClientRequest != NULL)
    {
        DebugLog((DEB_ERROR,"Can't update addresses from outside process. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Verify the request.
    //

    if (SubmitBufferLength < FIELD_OFFSET(KERB_UPDATE_ADDRESSES_REQUEST, Addresses))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    UpdateRequest = (PKERB_UPDATE_ADDRESSES_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the input
    //


    if (SubmitBufferLength < (sizeof(KERB_UPDATE_ADDRESSES_REQUEST)
                                + UpdateRequest->AddressCount * (sizeof(SOCKET_ADDRESS) + sizeof(struct sockaddr_in))
                                - ANYSIZE_ARRAY * sizeof(ULONG)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status= KerbUpdateGlobalAddresses(
                (PSOCKET_ADDRESS) UpdateRequest->Addresses,
                UpdateRequest->AddressCount
                );


    //
    // Copy them into the global for others to use
    //


Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPac
//
//  Synopsis:   Verifies that a PAC was signed by a valid KDC
//
//  Effects:
//
//  Arguments:  Same as for LsaApCallAuthenticationPackage. The submit
//              buffer must contain a KERB_VERIFY_PAC_REQUEST message.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS. The real error is in the protocol status.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_VERIFY_PAC_REQUEST VerifyRequest;
    DWORD MaxBufferSize;

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }
    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }
    if (SubmitBufferLength < sizeof(*VerifyRequest)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_PAC_REQUEST) ProtocolSubmitBuffer;

    MaxBufferSize = SubmitBufferLength -
                    FIELD_OFFSET(KERB_VERIFY_PAC_REQUEST, ChecksumAndSignature);
    if ((VerifyRequest->ChecksumLength > MaxBufferSize) ||
        (VerifyRequest->SignatureLength > MaxBufferSize) ||
        ((VerifyRequest->ChecksumLength + VerifyRequest->SignatureLength) >
         MaxBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (KerbKdcHandle == NULL)
    {
        Status = STATUS_MUST_BE_KDC;
        goto Cleanup;
    }

    DsysAssert(KerbKdcVerifyPac != NULL);

    Status = (*KerbKdcVerifyPac)(
                    VerifyRequest->ChecksumLength,
                    VerifyRequest->ChecksumAndSignature,
                    VerifyRequest->SignatureType,
                    VerifyRequest->SignatureLength,
                    VerifyRequest->ChecksumAndSignature + VerifyRequest->ChecksumLength
                    );
Cleanup:
    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


NTSTATUS
KerbPurgePrimaryCredentialsTickets(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN OPTIONAL PUNICODE_STRING ServerRealm
    )
{
    NTSTATUS Status;

    DsysAssert( PrimaryCredentials );

    if ( ServerName == NULL && ServerRealm == NULL ) {

        Status = STATUS_SUCCESS;

        KerbPurgeTicketCache( &PrimaryCredentials->AuthenticationTicketCache );
        KerbPurgeTicketCache( &PrimaryCredentials->ServerTicketCache );

    } else if ( ServerName != NULL && ServerRealm != NULL ) {

        KERB_TICKET_CACHE * TicketCaches[2] = {
            &PrimaryCredentials->AuthenticationTicketCache,
            &PrimaryCredentials->ServerTicketCache
        };

        //
        // Prowl through the caches and remove all the matching tickets
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        KerbWriteLockTicketCache();

        for ( ULONG i = 0 ; i < 2 ; i++ ) {

            KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

            for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
                  ListEntry !=  &TicketCache->CacheEntries ;
                  ListEntry = ListEntry->Flink ) {

                KERB_TICKET_CACHE_ENTRY * CacheEntry;
                UNICODE_STRING SearchName = {0};

                CacheEntry= CONTAINING_RECORD(
                                ListEntry,
                                KERB_TICKET_CACHE_ENTRY,
                                ListEntry.Next
                                );

                if ( !KERB_SUCCESS( KerbConvertKdcNameToString(
                                        &SearchName,
                                        CacheEntry->ServiceName,
                                        NULL ))) { // no realm

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }

                //
                // Check to see if the server & realm name matches
                //

                if ( RtlEqualUnicodeString(
                         &SearchName,
                         ServerName,
                         TRUE ) &&
                     RtlEqualUnicodeString(
                         &CacheEntry->DomainName,
                         ServerRealm,
                         TRUE )) {

                    D_DebugLog((DEB_TRACE,"Purging a ticket!\n"));

                    Status = STATUS_SUCCESS;

                    //
                    // Move back one entry so that Remove() does not
                    // trash the iteration
                    //

                    ListEntry = ListEntry->Blink;

                    KerbRemoveTicketCacheEntry( CacheEntry );
                }

                KerbFreeString(&SearchName);
            }
        }

        KerbUnlockTicketCache();

    } else {

        //
        // ServerName and ServerRealm need to be either both specified or
        // both NULL.  Getting here means that only one of them is NULL,
        // and the assert below will specify which one it is.
        //

        DsysAssert( ServerName != NULL );
        DsysAssert( ServerRealm != NULL );

        Status = STATUS_SUCCESS;
    }

Cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicket
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST );
    PKERB_PURGE_TKT_CACHE_REQUEST PurgeRequest  = ( PKERB_PURGE_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Purging ticket cache\n"));

    KerbCleanupSpnCache();

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_REQUEST LocalPurgeRequest;

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId     = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.ServerName,
            &PurgeRequestWOW->ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.RealmName,
            &PurgeRequestWOW->RealmName );

        PurgeRequest = &LocalPurgeRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->RealmName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // If no servername / realm name were supplied, purge all tickets
    //

    if ((PurgeRequest->ServerName.Length) == 0 && (PurgeRequest->RealmName.Length == 0))
    {
        D_DebugLog((DEB_TRACE, "Purging all tickets\n"));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

    } else {

        D_DebugLog(( DEB_TRACE, "Purging tickets %wZ\\%wZ\n",
            &PurgeRequest->RealmName,
            &PurgeRequest->ServerName ));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     &PurgeRequest->ServerName,
                     &PurgeRequest->RealmName
                     );
    }

Cleanup:

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicketEx
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST );
    PKERB_PURGE_TKT_CACHE_EX_REQUEST PurgeRequest = ( PKERB_PURGE_TKT_CACHE_EX_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    KerbCleanupSpnCache();

    D_DebugLog((DEB_TRACE, "Puring ticket cache Ex\n"));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 );
    }

#endif

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_EX_REQUEST LocalPurgeRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientName,
            &PurgeRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientRealm,
            &PurgeRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerName,
            &PurgeRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerRealm,
            &PurgeRequestWOW->TicketTemplate.ServerRealm );

        LocalPurgeRequest.TicketTemplate.StartTime = PurgeRequestWOW->TicketTemplate.StartTime;
        LocalPurgeRequest.TicketTemplate.EndTime = PurgeRequestWOW->TicketTemplate.EndTime;
        LocalPurgeRequest.TicketTemplate.RenewTime = PurgeRequestWOW->TicketTemplate.RenewTime;
        LocalPurgeRequest.TicketTemplate.EncryptionType = PurgeRequestWOW->TicketTemplate.EncryptionType;
        LocalPurgeRequest.TicketTemplate.TicketFlags = PurgeRequestWOW->TicketTemplate.TicketFlags;

        PurgeRequest = &LocalPurgeRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerRealm );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller is required to have the TCB privilege
        // in order to access someone else's ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Purge the entire ticket cache?
    //

    if ( PurgeRequest->Flags & KERB_PURGE_ALL_TICKETS ) {

        D_DebugLog(( DEB_TRACE, "Purging all tickets\n" ));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

        DsysAssert( NT_SUCCESS( Status ));

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL) {

                continue;
            }

            Status = KerbPurgePrimaryCredentialsTickets(
                         CredmanCred->SuppliedCredentials,
                         NULL,
                         NULL
                         );

            DsysAssert( NT_SUCCESS( Status ));
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

    } else {

        BOOLEAN MatchClient = (
                    PurgeRequest->TicketTemplate.ClientName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ClientRealm.Length > 0 );

        BOOLEAN MatchServer = (
                    PurgeRequest->TicketTemplate.ServerName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ServerRealm.Length > 0 );

        BOOLEAN Found = FALSE;

        if ( !MatchServer ) {

            //
            // Nothing will match these constraints
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Take a look at the primary credentials and see if they need cleaning
        //

        if ( !MatchClient ||
             ( RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.UserName,
                   &PurgeRequest->TicketTemplate.ClientName,
                   TRUE ) &&
               RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.DomainName,
                   &PurgeRequest->TicketTemplate.ClientRealm,
                   TRUE ))) {

            Status = KerbPurgePrimaryCredentialsTickets(
                         &LogonSession->PrimaryCredentials,
                         &PurgeRequest->TicketTemplate.ServerName,
                         &PurgeRequest->TicketTemplate.ServerRealm
                         );

            if ( NT_SUCCESS( Status )) {

                Found = TRUE;

            } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                goto Cleanup;
            }
        }

        //
        // Now look at the credman credentials and purge those
        //

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL ) {

                continue;
            }

            if ( !MatchClient ||
                 ( RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->UserName,
                       &PurgeRequest->TicketTemplate.ClientName,
                       TRUE ) &&
                   RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->DomainName,
                       &PurgeRequest->TicketTemplate.ClientRealm,
                       TRUE ))) {

                Status = KerbPurgePrimaryCredentialsTickets(
                             CredmanCred->SuppliedCredentials,
                             &PurgeRequest->TicketTemplate.ServerName,
                             &PurgeRequest->TicketTemplate.ServerRealm
                             );

                if ( NT_SUCCESS( Status )) {

                    Found = TRUE;

                } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                    KerbUnlockList( &LogonSession->CredmanCredentials );
                    goto Cleanup;
                }
            }
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

        if ( Found ) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

Cleanup:

    if ( LogonSession ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = NULL;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicket
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    KERB_PRIMARY_CREDENTIAL * PrimaryCreds = NULL;
    PKERB_RETRIEVE_TKT_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_RESPONSE RetrieveResponse = NULL;
    KERB_TICKET_CACHE_ENTRY * CacheEntry = NULL;
    PKERB_SPN_CACHE_ENTRY SpnCacheEntry = NULL;
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    ULONG Flags = 0;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TargetName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( (RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE) != 0)
    {
        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential);

        if (!NT_SUCCESS(Status))
        {
            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the
        // logon session.
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    }
    else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId ) )
    {

        LogonId = &ClientInfo.LogonId;

    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        //
        // The caller must have TCB privilege in order to access someone
        // elses ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Process the target names
    //

    Status = KerbProcessTargetNames(
                 &RetrieveRequest->TargetName,
                 NULL,                           // no supp target name
                 0,                              // no flags
                 &Flags,
                 &TargetName,
                 &TargetRealm,
                 &SpnCacheEntry
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check the TGT cache, as KerbGetServiceTicket doesn't look there
    //

    if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_DONT_USE_CACHE) == 0)
    {
        KerbReadLockLogonSessions(LogonSession);

        //
        // Pick which ticket cache to use
        //

        if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
        {
            PrimaryCreds = Credential->SuppliedCredentials;
        }
        else
        {
            PrimaryCreds = &LogonSession->PrimaryCredentials;
        }

        CacheEntry = KerbLocateTicketCacheEntry(
                         &PrimaryCreds->AuthenticationTicketCache,
                         TargetName,
                         &TargetRealm
                         );

        if (CacheEntry == NULL)
        {
            //
            // If the tgt cache failed, check the normal cache
            //

            CacheEntry = KerbLocateTicketCacheEntry(
                             &PrimaryCreds->ServerTicketCache,
                             TargetName,
                             &TargetRealm
                             );
        }

        //
        // Check if this is a TGT
        //

        if (CacheEntry == NULL)
        {
            if ((TargetName->NameCount == 2) &&
                 RtlEqualUnicodeString(
                     &TargetName->Names[0],
                     &KerbGlobalKdcServiceName,
                     TRUE                        // case insensitive
                     ))
            {

                //
                // If the tgt cache failed, check the normal cache
                //

                CacheEntry = KerbLocateTicketCacheEntryByRealm(
                                 &PrimaryCreds->AuthenticationTicketCache,
                                 &TargetRealm,
                                 KERB_TICKET_CACHE_PRIMARY_TGT
                                 );

                if (CacheEntry != NULL)
                {
                    //
                    // Make sure the name matches
                    //

                    KerbReadLockTicketCache();

                    if ( !KerbEqualKdcNames(
                              TargetName,
                              CacheEntry->ServiceName
                              ))
                    {
                        //
                        // We must unlock the ticket cache before dereferencing
                        //

                        KerbUnlockTicketCache();
                        KerbDereferenceTicketCacheEntry( CacheEntry );
                        CacheEntry = NULL;

                    }
                    else
                    {
                        KerbUnlockTicketCache();
                    }
                }
            }
        }

        //
        // If we found a ticket, make sure it has the right flags &
        // encryption type
        //

        if (CacheEntry != NULL)
        {
            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            LONG CacheEncryptionType;

            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = CacheEntry->TicketFlags;
            CacheEncryptionType = CacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags( RetrieveRequest->TicketFlags );

            //
            // Verify the flags
            //

            if ((( CacheTicketFlags & TicketFlags ) != TicketFlags) ||
                ((RetrieveRequest->EncryptionType != KERB_ETYPE_DEFAULT) && (CacheEncryptionType != RetrieveRequest->EncryptionType)))
            {
                //
                // Something doesn't match, so throw away the entry
                //

                KerbDereferenceTicketCacheEntry( CacheEntry );
                CacheEntry = NULL;
            }
        }

        KerbUnlockLogonSessions(LogonSession);
    }
    else
    {
        Flags |= KERB_GET_TICKET_NO_CACHE;
    }

    if (CacheEntry == NULL)
    {
        //
        // If we aren't supposed to get a new ticket, return a failure now.
        //

        if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CACHE_ONLY) != 0)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Now get a ticket
        //

        Status = KerbGetServiceTicket(
                    LogonSession,
                    Credential,
                    NULL,
                    TargetName,
                    &TargetRealm,
                    SpnCacheEntry,
                    Flags,
                    RetrieveRequest->TicketFlags,
                    RetrieveRequest->EncryptionType,
                    NULL,                       // no error message
                    NULL,                       // no authorization data
                    NULL,                       // no tgt reply
                    &CacheEntry,
                    NULL                        // don't return logon guid
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get outbound ticket: 0x%x\n",Status));
            goto Cleanup;
        }
    }

    //
    // Encode the ticket or kerb_cred
    //

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                 CacheEntry,
                 RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_AS_KERB_CRED,
                 &ResponseSize,
                 &ClientResponse
                 );
    
    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry( CacheEntry );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    if ( SpnCacheEntry )
    {
        KerbDereferenceSpnCacheEntry( SpnCacheEntry );
    }

    KerbFreeString( &TargetRealm );
    KerbFreeKdcName( &TargetName );

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


#if 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicketEx
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST );
    PKERB_RETRIEVE_TKT_EX_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_EX_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_EX_RESPONSE RetrieveResponse = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    ULONG Flags = 0;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;

    //
    // Verify the request
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket ex\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_RETRIEVE_TKT_EX_REQUEST LocalRetrieveRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 RetrieveRequestWOW =
            ( PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 )RetrieveRequest;

        LocalRetrieveRequest.MessageType = RetrieveRequestWOW->MessageType;
        LocalRetrieveRequest.LogonId = RetrieveRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientName,
            &RetrieveRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientRealm,
            &RetrieveRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerName,
            &RetrieveRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerRealm,
            &RetrieveRequestWOW->TicketTemplate.ServerRealm );

        LocalRetrieveRequest.TicketTemplate.StartTime = RetrieveRequestWOW->TicketTemplate.StartTime;
        LocalRetrieveRequest.TicketTemplate.EndTime = RetrieveRequestWOW->TicketTemplate.EndTime;
        LocalRetrieveRequest.TicketTemplate.RenewTime = RetrieveRequestWOW->TicketTemplate.RenewTime;
        LocalRetrieveRequest.TicketTemplate.EncryptionType = RetrieveRequestWOW->TicketTemplate.EncryptionType;
        LocalRetrieveRequest.TicketTemplate.TicketFlags = RetrieveRequestWOW->TicketTemplate.TicketFlags;

        LocalRetrieveRequest.CacheOptions = RetrieveRequestWOW->CacheOptions;
        LocalRetrieveRequest.CredentialsHandle = RetrieveRequestWOW->CredentialsHandle;

        //
        // TODO: take care of SecondTicket, UserAuthData and Addresses
        //

        LocalRetrieveRequest.SecondTicket = NULL;
        LocalRetrieveRequest.UserAuthData = NULL;
        LocalRetrieveRequest.Addresses = NULL;

        RetrieveRequest = &LocalRetrieveRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerRealm );

    //
    // TODO: take care of SecondTicket, UserAuthData and Addresses
    //

    if ( RetrieveRequest->SecondTicket != NULL ||
         RetrieveRequest->UserAuthData != NULL ||
         RetrieveRequest->Addresses != NULL ) {

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, user the caller's logon id
    //

    if ( RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE ) {

        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential
                     );

        if ( !NT_SUCCESS( Status )) {

            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the logon session
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    } else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone else's
        // ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    if ( Credential != NULL ) {

        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if ( ClientResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}

#endif // 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptMessage
//
//  Synopsis:   Decrypts a buffer with either the specified key or the d
//              primary key from the specified logon session.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_DECRYPT_REQUEST DecryptRequest;
    PBYTE DecryptResponse = NULL;
    ULONG ResponseLength = 0;

    PBYTE ClientResponse = NULL;
    PKERB_ENCRYPTION_KEY KeyToUse = NULL;
    KERB_ENCRYPTION_KEY SuppliedKey = {0};
    BOOLEAN FreeKey = FALSE;
    PCRYPTO_SYSTEM CryptoSystem = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Decrypting Message\n"));

    if (SubmitBufferSize < sizeof(KERB_DECRYPT_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DecryptRequest = (PKERB_DECRYPT_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the pointers
    //

    if (DecryptRequest->InitialVector != NULL)
    {
        if (DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + DecryptRequest->InitialVectorSize > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"InitialVector end pass end of buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->InitialVector < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"InitialVector begin before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->InitialVector = DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
    }
    else
    {
        if (DecryptRequest->InitialVectorSize != 0)
        {
            DebugLog((DEB_ERROR,"Non-zero vector size with null vector\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + DecryptRequest->EncryptedDataSize > SubmitBufferSize)
    {
        DebugLog((DEB_ERROR,"EncryptedData end past end of request buffer\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (DecryptRequest->EncryptedData < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
    {
        DebugLog((DEB_ERROR,"EncryptedData begin before end of DECRYPT_REQUEST\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    DecryptRequest->EncryptedData = DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;

    //
    // If the caller wants the default key, then open the specified logon
    // session and get out the key.
    //

    if (DecryptRequest->Flags & KERB_DECRYPT_FLAG_DEFAULT_KEY)
    {
        //
        // Find the callers logon id & TCB status
        //

        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If the caller did not provide a logon id, use the caller's logon id.
        //

        if ( RtlIsZeroLuid( &DecryptRequest->LogonId ) )
        {
            LogonId = &ClientInfo.LogonId;
        }
        else
        {
            //
            // Verify the caller has TCB privilege if they want access to someone
            // elses ticket cache.
            //

            if (!ClientInfo.HasTcbPrivilege)
            {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

            LogonId = &DecryptRequest->LogonId;
        }

        LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        FALSE               // don't unlink
                        );

        if (LogonSession == NULL)
        {
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        //
        // Get the key from the logon session
        //

        KerbReadLockLogonSessions(LogonSession);
        if (LogonSession->PrimaryCredentials.Passwords != NULL)
        {
            KeyToUse = KerbGetKeyFromList(
                        LogonSession->PrimaryCredentials.Passwords,
                        DecryptRequest->CryptoType
                        );
            if (KeyToUse != NULL)
            {
                KERBERR KerbErr;

                KerbErr = KerbDuplicateKey(
                            &SuppliedKey,
                            KeyToUse
                            );
                KeyToUse = NULL;
                Status = KerbMapKerbError(KerbErr);
            }
            else
            {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        }
        else
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        KerbUnlockLogonSessions(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KeyToUse = &SuppliedKey;
        FreeKey = TRUE;
    }
    else
    {
        if (DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + DecryptRequest->Key.Length > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"End of supplied key past end of request buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->Key.Value < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"Begin of supplied key before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->Key.Value = DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
        SuppliedKey.keytype = DecryptRequest->Key.KeyType;
        SuppliedKey.keyvalue.value = DecryptRequest->Key.Value;
        SuppliedKey.keyvalue.length = DecryptRequest->Key.Length;
        KeyToUse = &SuppliedKey;
    }



    //
    // Now do the decryption
    //

    DecryptResponse = (PBYTE) KerbAllocate(DecryptRequest->EncryptedDataSize);
    if (DecryptResponse == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ResponseLength = DecryptRequest->EncryptedDataSize;

    Status = CDLocateCSystem(
                DecryptRequest->CryptoType,
                &CryptoSystem
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The crypt system must be integrity protected - otherwise it may be
    // used as a general purpose encryption/decryption technique.
    //

    if ((CryptoSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) == 0)
    {
        DebugLog((DEB_ERROR,"Trying to decrypt with non-integrity protected crypt system (%d)\n",
            CryptoSystem->EncryptionType));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = CryptoSystem->Initialize(
                KeyToUse->keyvalue.value,
                KeyToUse->keyvalue.length,
                DecryptRequest->KeyUsage,
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If there was an initial vector, use it now
    //

    if (DecryptRequest->InitialVectorSize != 0)
    {
        Status = CryptoSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    DecryptRequest->InitialVector,
                    DecryptRequest->InitialVectorSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Decrypt
    //

    Status = CryptoSystem->Decrypt(
                CryptBuffer,
                DecryptRequest->EncryptedData,
                DecryptRequest->EncryptedDataSize,
                DecryptResponse,
                &ResponseLength
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Return the decrypted data to the client
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                ResponseLength,
                (PVOID *) &ClientResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                ResponseLength,
                ClientResponse,
                DecryptResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseLength;

Cleanup:

    if ((CryptoSystem != NULL) && (CryptBuffer != NULL))
    {
        CryptoSystem->Discard(&CryptBuffer);
    }
    if (FreeKey)
    {
        KerbFreeKey(&SuppliedKey);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    if (DecryptResponse != NULL)
    {
        KerbFree(DecryptResponse);
    }
    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }
    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddBindingCacheEntry
//
//  Synopsis:   Adds an entry to the binding cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST BindingRequest = ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST )ProtocolSubmitBuffer;
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    ULONG StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Addding binding cache entry\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_ADD_BINDING_CACHE_ENTRY_REQUEST LocalBindingRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 BindingRequestWOW =
            ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 )BindingRequest;

        LocalBindingRequest.MessageType = BindingRequestWOW->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.RealmName,
            &BindingRequestWOW->RealmName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.KdcAddress,
            &BindingRequestWOW->KdcAddress );

        LocalBindingRequest.AddressType = BindingRequestWOW->AddressType;

        BindingRequest = &LocalBindingRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &BindingRequest->RealmName );
    NULL_RELOCATE_ONE( &BindingRequest->KdcAddress );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // Require the caller to have TCB.
    //

    if ( !ClientInfo.HasTcbPrivilege ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }

    Status = KerbCacheBinding(
                 &BindingRequest->RealmName,
                 &BindingRequest->KdcAddress,
                 BindingRequest->AddressType,
                 0,
                 0,
                 0,
                 &CacheEntry
                 );

Cleanup:

    if ( CacheEntry != NULL ) {

        KerbDereferenceBindingCacheEntry( CacheEntry );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;
    *ProtocolStatus = Status;

    return STATUS_SUCCESS;
}


NTSTATUS
VerifyCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password
    )
{
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll;
    SID_AND_ATTRIBUTES_LIST GroupMembership;

    NT_OWF_PASSWORD NtOwfPassword;
    NTSTATUS Status = STATUS_LOGON_FAILURE;

    GroupMembership.SidAndAttributes = NULL;


    //
    // lazy initialization of SAM handles.
    //

    if( KerbGlobalDomainHandle == NULL )
    {
        SAMPR_HANDLE SamHandle = NULL;
        SAMPR_HANDLE DomainHandle = NULL;
        PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;

        //
        // Open SAM to get the account information
        //

        Status = SamIConnect(
                    NULL,                   // no server name
                    &SamHandle,
                    0,                      // no desired access
                    TRUE                    // trusted caller
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalSamHandle,
                        SamHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &SamHandle );
        }


        Status = LsaIQueryInformationPolicyTrusted(
                        PolicyAccountDomainInformation,
                        &PolicyInfo
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SamrOpenDomain(
                        KerbGlobalSamHandle,
                        0,                  // no desired access
                        (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                        &DomainHandle
                        );

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            PolicyInfo
            );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalDomainHandle,
                        DomainHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &DomainHandle );
        }
    }



    Status = SamIGetUserLogonInformationEx(
                KerbGlobalDomainHandle,
                SAM_OPEN_BY_UPN_OR_ACCOUNTNAME | SAM_NO_MEMBERSHIPS,
                UserName,
                USER_ALL_OWFPASSWORD |          // OWFs
                USER_ALL_NTPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_LMPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_USERACCOUNTCONTROL,    // UserAccountControl - account disabled/etc.
                &UserAllInfo,
                &GroupMembership,
                &UserHandle
                );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    UserAll = &UserAllInfo->All;


    Status = RtlCalculateNtOwfPassword(
                Password,
                &NtOwfPassword
                );

    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }


    Status = STATUS_LOGON_FAILURE;

    if (UserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
    {
        goto Cleanup;
    }

    if (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        goto Cleanup;
    }

    if ( !UserAll->NtPasswordPresent )
    {
        if( UserAll->LmPasswordPresent )
        {
            goto Cleanup;
        }

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            &KerbGlobalNullNtOwfPassword,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            goto Cleanup;
        }

    } else {

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            UserAll->NtOwfPassword.Buffer,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    ZeroMemory( &NtOwfPassword, sizeof(NtOwfPassword) );

    if( UserAllInfo != NULL )
    {
        //
        // SamIFree now zeroes the sensitive fields.
        //

        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if (UserHandle != NULL)
    {
        SamrCloseHandle( &UserHandle );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        SamIFreeSidAndAttributesList(&GroupMembership);
    }

    return Status;
}

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest = NULL;
    NTSTATUS Status = STATUS_LOGON_FAILURE;


    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "KerbVerifyCredentials\n"));

    //
    // only support in proc use of this interface.
    //

    if( ClientRequest != NULL )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    if (SubmitBufferSize < sizeof(KERB_VERIFY_CREDENTIALS_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_CREDENTIALS_REQUEST) ProtocolSubmitBuffer;


#if 0   // only needed if out-proc supported.
    //
    // Normalize the strings
    //

    if( ClientRequest != NULL )
    {
        NULL_RELOCATE_ONE(&VerifyRequest->UserName);
        NULL_RELOCATE_ONE(&VerifyRequest->DomainName);
        NULL_RELOCATE_ONE(&VerifyRequest->Password);
    }
#endif


    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    Status = VerifyCredentials(
                    &VerifyRequest->UserName,
                    &VerifyRequest->DomainName,
                    &VerifyRequest->Password
                    );

Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\logonses.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonses.cxx
//
// Contents:    Code for managing the global list of logon sessions
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define LOGONSES_ALLOCATE
#include <kerbp.h>


#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitLogonSessionList
//
//  Synopsis:   Initializes logon session list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitLogonSessionList(
    VOID
    )
{
    NTSTATUS Status;


    Status = KerbInitializeList( &KerbLogonSessionList );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    KerberosLogonSessionsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbLogonSessionList);

    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//
//  Function: KerbInitNetworkServiceLoopbackDetection
//
//  Synopsis: Initialize the network service session loopback detection
//
//  Effects: Allocates a resources
//
//  Arguments: none
//
//  Requires:
//
//  Returns: STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitNetworkServiceLoopbackDetection(
    VOID
    )
{
   NTSTATUS Status = STATUS_SUCCESS;

   InitializeListHead(&KerbNetworkServiceSKeyList);

#if DBG

   KerbcSKeyEntries = 0;

#endif

   KerbhSKeyTimerQueue = NULL;

   __try
   {
       RtlInitializeResource(&KerbNetworkServiceSKeyLock);
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeNetworkServiceSKeyListAndLock
//
//  Synopsis: Free the network service session key list and its lock
//
//  Effects: Frees a resources
//
//  Arguments: none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
KerbFreeNetworkServiceSKeyListAndLock(
    VOID
    )
{
   if (RtlAcquireResourceExclusive(&KerbNetworkServiceSKeyLock, TRUE))
   {
        for (LIST_ENTRY* pListEntry = KerbNetworkServiceSKeyList.Flink;
             pListEntry != &KerbNetworkServiceSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           KerbFreeSKeyEntry(pSKeyEntry);
        }
        RtlReleaseResource(&KerbNetworkServiceSKeyLock);
   }

   RtlDeleteResource(&KerbNetworkServiceSKeyLock);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeLogonSessionList
//
//  Synopsis:   Frees the logon session list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeLogonSessionList(
    VOID
    )
{
    PKERB_LOGON_SESSION LogonSession;


    if (KerberosLogonSessionsInitialized)
    {

        KerbLockList(&KerbLogonSessionList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbLogonSessionList.List))
        {
            LogonSession = CONTAINING_RECORD(
                            KerbLogonSessionList.List.Flink,
                            KERB_LOGON_SESSION,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbLogonSessionList,
                &LogonSession->ListEntry,
                TRUE
                );

            KerbDereferenceLogonSession(LogonSession);

        }

        KerbFreeList(&KerbLogonSessionList);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateLogonSession
//
//  Synopsis:   Allocates a logon session structure
//
//  Effects:    Allocates a logon session, but does not add it to the
//              list of logon sessions
//
//  Arguments:  NewLogonSession - receives a new logon session allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateLogonSession(
    PKERB_LOGON_SESSION * NewLogonSession
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession;

    LogonSession = (PKERB_LOGON_SESSION) KerbAllocate(
                        sizeof(KERB_LOGON_SESSION)
                        );
    if (LogonSession == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    KerbInitializeListEntry(
        &LogonSession->ListEntry
        );

    InitializeListHead(&LogonSession->SspCredentials);

    //
    // Initialize the ticket caches
    //

    KerbInitTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);
    KerbInitTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
    KerbInitTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);

    Status = RtlInitializeCriticalSection(&LogonSession->Lock);
    if (!NT_SUCCESS(Status))
    {
        KerbFree(LogonSession);
    }
    else
    {
        *NewLogonSession = LogonSession;
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertLogonSession
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  LogonSession - LogonSession to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    KerbInsertListEntry(
        &LogonSession->ListEntry,
        &KerbLogonSessionList
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceLogonSession
//
//  Synopsis:   Locates a logon session from the logon ID and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonId - LogonId of logon session to locate
//              RemoveFromList - If TRUE, logon session will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_LOGON_SESSION
KerbReferenceLogonSession(
    IN PLUID LogonId,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_LOGON_SESSION LogonSession = NULL;
    BOOLEAN Found = FALSE;

    KerbLockList(&KerbLogonSessionList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    for (ListEntry = KerbLogonSessionList.List.Flink ;
         ListEntry !=  &KerbLogonSessionList.List ;
         ListEntry = ListEntry->Flink )
    {
        LogonSession = CONTAINING_RECORD(ListEntry, KERB_LOGON_SESSION, ListEntry.Next);
        if (RtlEqualLuid(
                &LogonSession->LogonId,
                LogonId
                ) )
        {
            D_DebugLog((DEB_TRACE_LSESS,"Referencing session 0x%x:0x%x, Remove=%d\n",
                LogonSession->LogonId.HighPart,
                LogonSession->LogonId.LowPart,
                RemoveFromList
                ));

            KerbReferenceListEntry(
                &KerbLogonSessionList,
                &LogonSession->ListEntry,
                RemoveFromList
                );
            Found = TRUE;
            break;
        }

    }
    if (!Found)
    {
        LogonSession = NULL;
    }
    KerbUnlockList(&KerbLogonSessionList);
    return(LogonSession);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeLogonSession
//
//  Synopsis:   Frees a logon session and all associated data
//
//  Effects:
//
//  Arguments:  LogonSession
//
//  Requires:   the logon session must already be unlinked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    DsysAssert((LogonSession->ListEntry.Next.Flink == NULL) &&
           (LogonSession->ListEntry.Next.Blink == NULL));

    // Don't purge creds, as there isn't a ref-count for the credential in
    // the logon session list,and there might be outstanding handles to your
    // credentials in a local system process.
    //KerbPurgeCredentials(&LogonSession->SspCredentials);
    KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);
    KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);

    if (LogonSession->PrimaryCredentials.Passwords != NULL)
    {
        KerbFreeStoredCred(LogonSession->PrimaryCredentials.Passwords);
    }

    if (LogonSession->PrimaryCredentials.OldPasswords != NULL)
    {
        KerbFreeStoredCred(LogonSession->PrimaryCredentials.OldPasswords);
    }

    KerbFreeString(&LogonSession->PrimaryCredentials.UserName);
    KerbFreeString(&LogonSession->PrimaryCredentials.DomainName);

    if (LogonSession->PrimaryCredentials.ClearPassword.Buffer != NULL)
    {
        RtlZeroMemory(
            LogonSession->PrimaryCredentials.ClearPassword.Buffer,
            LogonSession->PrimaryCredentials.ClearPassword.Length
            );
        KerbFreeString(&LogonSession->PrimaryCredentials.ClearPassword);
    }

    if (LogonSession->PrimaryCredentials.PublicKeyCreds != NULL)
    {

#ifndef WIN32_CHICAGO
        KerbReleasePkCreds(
            LogonSession,
            NULL
            );
#endif // WIN32_CHICAGO
    }

    if ((LogonSession->LogonSessionFlags & KERB_LOGON_CREDMAN_INITIALIZED) != 0)
    {
        RtlDeleteCriticalSection(&LogonSession->CredmanCredentials.Lock);
    }


    RtlDeleteCriticalSection(&LogonSession->Lock);
    KerbFree(LogonSession);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceLogonSession
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  LogonSession - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    if (KerbDereferenceListEntry(
            &LogonSession->ListEntry,
            &KerbLogonSessionList
            ) )
    {
        D_DebugLog((DEB_TRACE_LSESS,"Dereferencing and freeing logon session 0x%x:0x%x\n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.HighPart
            ));
        KerbFreeLogonSession( LogonSession );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceLogonSessionByPointer
//
//  Synopsis:   References a LogonSession by the LogonSession pointer itself.
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonSession - The LogonSession to reference.
//              RemoveFromList - If TRUE, LogonSession will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceLogonSessionByPointer(
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN RemoveFromList
    )
{

    KerbLockList(&KerbLogonSessionList);

    KerbReferenceListEntry(
        &KerbLogonSessionList,
        &LogonSession->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbLogonSessionList);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSaltForEtype
//
//  Synopsis:   Looks in the list of salt for an etype & returns it if found
//
//  Effects:    Allocate the output string
//
//  Arguments:  EncryptionType - etype searched for
//              EtypeInfo - List of etypes
//              DefaultSalt - salt to use if none provided
//              Salt - receives the salt to use. On error, no key should be
//                      generated.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSaltForEtype(
    IN ULONG EncryptionType,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN OPTIONAL PKERB_STORED_CREDENTIAL PasswordList,
    IN PUNICODE_STRING DefaultSalt,
    OUT PUNICODE_STRING SaltToUse
    )
{
    PKERB_ETYPE_INFO ListEntry;
    STRING TempString;

    //
    // If there is no etype, just use the default
    //

    if (EtypeInfo == NULL)
    {
        //
        // If we have a password list, get the salt from that.
        //

        if (ARGUMENT_PRESENT(PasswordList))
        {
            ULONG Index;
            for (Index = 0; Index < PasswordList->CredentialCount ; Index++ )
            {
                if (PasswordList->Credentials[Index].Key.keytype == (int) EncryptionType)
                {
                    if (PasswordList->Credentials[Index].Salt.Buffer != NULL)
                    {
                        return(KerbDuplicateString(
                                SaltToUse,
                                &PasswordList->Credentials[Index].Salt
                                ));
                    }
                    else if (PasswordList->DefaultSalt.Buffer != NULL)
                    {
                        return(KerbDuplicateString(
                                SaltToUse,
                                &PasswordList->DefaultSalt
                                ));
                    }
                    break;
                }
            }
        }

        //
        // otherise return the default
        //

        return(KerbDuplicateString(
                    SaltToUse,
                    DefaultSalt
                    ));
    }

    //
    // Otherwise, only return salt if the etype is in the list.
    //

    for (ListEntry = EtypeInfo; ListEntry != NULL ; ListEntry = ListEntry->next )
    {
        //
        // First check for the encryption type we want.
        //

        if (ListEntry->value.encryption_type == (int) EncryptionType)
        {

            //
            // if it has salt, return that.
            //

            if ((ListEntry->value.bit_mask & salt_present) != 0)
            {
                KERBERR KerbErr;
                TempString.Buffer = (PCHAR) ListEntry->value.salt.value;
                TempString.Length = (USHORT) ListEntry->value.salt.length;
                TempString.MaximumLength = (USHORT) ListEntry->value.salt.length;

                KerbErr = KerbStringToUnicodeString(
                            SaltToUse,
                            &TempString
                            );
                return(KerbMapKerbError(KerbErr));
            }
            else
            {
                //
                // Otherwise return the default
                //

                return(KerbDuplicateString(
                        SaltToUse,
                        DefaultSalt
                        ));
            }
        }
    }
    return(STATUS_OBJECT_NAME_NOT_FOUND);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeStoredCred
//
//  Synopsis:   Frees a KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeStoredCred(
    IN PKERB_STORED_CREDENTIAL StoredCred
    )
{
    USHORT Index;
    for (Index = 0; Index < StoredCred->CredentialCount + StoredCred->OldCredentialCount ; Index++ )
    {
        if (StoredCred->Credentials[Index].Salt.Buffer != NULL)
        {
            KerbFreeString(&StoredCred->Credentials[Index].Salt);
        }
    }
    KerbFree(StoredCred);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPasswordList
//
//  Synopsis:   Builds a list of passwords for a logged on user
//
//  Effects:    allocates memory
//
//  Arguments:  Password - clear or OWF password
//              PasswordFlags - Indicates whether the password is clear or OWF
//              PasswordList - Receives new password list
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PKERB_ETYPE_INFO SuppliedSalt,
    IN PKERB_STORED_CREDENTIAL OldPasswords,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags,
    OUT PKERB_STORED_CREDENTIAL * PasswordList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptCount = 0 ;
    PKERB_STORED_CREDENTIAL Credentials = NULL;
    UNICODE_STRING KeySalt = {0};
    UNICODE_STRING DefaultSalt = {0};
    ULONG CredentialSize = 0;
    ULONG CredentialCount = 0;
    PCRYPTO_SYSTEM CryptoSystem;
    ULONG Index, CredentialIndex = 0;
    PUCHAR Base;
    ULONG Offset;
    KERBERR KerbErr;

    *PasswordList = NULL;

    //
    // If we were passed an OWF, then there is just one password
    //

    if ((PasswordFlags & PRIMARY_CRED_OWF_PASSWORD) != 0)
    {
        CredentialSize += Password->Length + sizeof(KERB_KEY_DATA);
        CredentialCount++;
#ifndef DONT_SUPPORT_OLD_TYPES
        CredentialSize += Password->Length + sizeof(KERB_KEY_DATA);
        CredentialCount++;
#endif
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {

        //
        // Build the key salt.
        //

        KerbErr = KerbBuildKeySalt(
                    DomainName,
                    (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Length != 0) ? PrincipalName : UserName,
                    (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Length != 0) ? UnknownAccount : AccountType,
                    &DefaultSalt
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"Can't build salt. Might as well fail here\n"));
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        //
        // For a cleartext password, build a list of encryption types and
        // create a key for each one
        //

        Status = CDBuildIntegrityVect(
                    &CryptCount,
                    CryptTypes
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Can't build a list of encryption types: 0x%x.\n",Status));
            goto Cleanup;
        }
        DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            Status = CDLocateCSystem(
                        CryptTypes[Index],
                        &CryptoSystem
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",CryptTypes[Index],Status));
                goto Cleanup;
            }

            if (((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) == 0) ||
                (DefaultSalt.Buffer != NULL ))
            {
                CredentialSize += sizeof(KERB_KEY_DATA) + CryptoSystem->KeySize;
                CredentialCount++;
            }
        }

    }
    else
    {
        //
        // No flags set, so nothing we can do.
        //
        D_DebugLog((DEB_WARN,"Password passed but no flags set\n"));
        return(STATUS_SUCCESS);
    }

#ifdef notdef
    //
    // Add the space for the salt
    //

    CredentialSize += DefaultSalt.Length;

#endif

    //
    // Add in the size of the base structure
    //

    CredentialSize += FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials);
    Credentials = (PKERB_STORED_CREDENTIAL) KerbAllocate(CredentialSize);
    if (Credentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the base structure
    //

    Credentials->Revision = KERB_PRIMARY_CRED_REVISION;
    Credentials->Flags = 0;
    Credentials->OldCredentialCount = 0;


    //
    // Now fill in the individual keys
    //

    Base = (PUCHAR) Credentials;
    Offset = FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials) +
                CredentialCount * sizeof(KERB_KEY_DATA);

#ifdef notdef
    //
    // Add the default salt
    //

    Credentials->DefaultSalt = DefaultSalt;
    Credentials->DefaultSalt.Buffer = (LPWSTR) Base+Offset;

    RtlCopyMemory(
        Base + Offset,
        DefaultSalt.Buffer,
        DefaultSalt.Length
        );
    Offset += Credentials->DefaultSalt.Length;

#endif

    if ((PasswordFlags & PRIMARY_CRED_OWF_PASSWORD) != 0)
    {
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_NT
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Base += Password->Length;
        CredentialIndex++;
#ifndef DONT_SUPPORT_OLD_TYPES

        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_OLD
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Base += Password->Length;
        CredentialIndex++;
#endif
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {
        KERB_ENCRYPTION_KEY TempKey = {0};

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            CryptoSystem = NULL;
            Status = CDLocateCSystem(
                         CryptTypes[Index],
                         &CryptoSystem
                         );

            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_SUCCESS;
                continue;
            }

            Status = KerbGetSaltForEtype(
                        CryptTypes[Index],
                        SuppliedSalt,
                        OldPasswords,
                        &DefaultSalt,
                        &KeySalt
                        );

            if (!NT_SUCCESS(Status))
            {
                //
                // This probably means that the etype wasn't supported by
                // the kdc
                //

                Status = STATUS_SUCCESS;
                continue;
            }

            //
            // If we don't have salt, skip this crypt system
            //

            if (((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) != 0) &&
                (KeySalt.Buffer == NULL ))
            {
                continue;
            }

            KerbErr = KerbHashPasswordEx(
                        Password,
                        &KeySalt,
                        CryptTypes[Index],
                        &TempKey
                        );


            if (!KERB_SUCCESS(KerbErr))
            {
                //
                // It is possible that the password can't be used for every
                // encryption scheme, so skip failures
                //

                D_DebugLog((DEB_WARN, "Failed to hash pasword %wZ with type 0x%x\n",
                    Password,CryptTypes[Index] ));
                KerbFreeString(&KeySalt);
                continue;
            }


            DsysAssert(CryptoSystem->KeySize >= TempKey.keyvalue.length);


            //
            // Copy the salt and key data into the credentials
            //

            Credentials->Credentials[CredentialIndex].Salt = KeySalt;

            RtlInitUnicodeString(
                &KeySalt,
                0
                );
            Credentials->Credentials[CredentialIndex].Key = TempKey;
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;

            RtlCopyMemory(
                Base + Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            KerbFreeKey(
                &TempKey
                );


            CredentialIndex++;
        }

    }
    Credentials->CredentialCount = (USHORT) CredentialIndex;
    *PasswordList = Credentials;
    Credentials = NULL;

Cleanup:
    if (Credentials != NULL)
    {
         KerbFreeStoredCred(Credentials);
    }
    KerbFreeString(&KeySalt);
    KerbFreeString(&DefaultSalt);

    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCreatePrimaryCredentials
//
//  Synopsis:   Fills in a new primary credentials structure
//
//  Effects:    allocates space for the user name and domain name
//
//  Arguments:  AccountName - Account name of this user
//              DomainName - domain name of this user
//              Password - Optionally contains a kereros hash of the password
//                      Note: if present, it is used and zeroed out.
//              PrimaryCredentials - contains structure to fill in.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreatePrimaryCredentials(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN PLUID LogonId,
    OUT PKERB_PRIMARY_CREDENTIAL PrimaryCredentials
    )
{
    NTSTATUS Status;
    LUID SystemLogonId = SYSTEM_LUID;
    BOOLEAN IsSystemLogon = FALSE;
    BOOLEAN IsPersonal = KerbRunningPersonal();


    //
    // We can only accept account name / service name / pwds of max_unicode_length
    // -1, because we NULL terminate these for later DES derivation, and the
    // input buffers from LogonUser may not be NULL terminated.
    //
    if ((AccountName->Length > KERB_MAX_UNICODE_STRING) ||
        (DomainName->Length > KERB_MAX_UNICODE_STRING))

    {
        return (STATUS_NAME_TOO_LONG);
    }

    if ((ARGUMENT_PRESENT(Password) && (Password->Length > KERB_MAX_UNICODE_STRING)) ||
        (ARGUMENT_PRESENT(OldPassword) && (OldPassword->Length > KERB_MAX_UNICODE_STRING)))
    {
        return (STATUS_NAME_TOO_LONG);
    }

    if (RtlEqualLuid(
            &SystemLogonId,
            LogonId))
    {
        IsSystemLogon = TRUE;
    }

    Status = KerbDuplicateString(
                &PrimaryCredentials->UserName,
                AccountName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The system logon always comes in uppercase, so lowercase it.
    //

    if (IsSystemLogon)
    {
        RtlDowncaseUnicodeString(
            &PrimaryCredentials->UserName,
            &PrimaryCredentials->UserName,
            FALSE
            );

    }
    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    //  Neuter personal so it can't act as a server,
    //  even if someone has hacked in a machine pwd.
    //
    if (IsSystemLogon && IsPersonal)
    {
        PrimaryCredentials->Passwords = NULL;
        PrimaryCredentials->OldPasswords = NULL;
        D_DebugLog((DEB_WARN, "Running personal - No kerberos for SYSTEM LUID\n"));
    }
    else
    {

        Status = KerbBuildPasswordList(
                        Password,
                        &PrimaryCredentials->UserName,
                        &PrimaryCredentials->DomainName,
                        NULL,                                   // no supplied salt
                        NULL,                                   // no old paswords
                        NULL,                                   // no principal name
                        IsSystemLogon ? MachineAccount : UserAccount,
                        PasswordFlags,
                        &PrimaryCredentials->Passwords
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (ARGUMENT_PRESENT(OldPassword) && (OldPassword->Buffer != NULL))
        {
            Status = KerbBuildPasswordList(
                        OldPassword,
                        &PrimaryCredentials->UserName,
                        &PrimaryCredentials->DomainName,
                        NULL,                           // no supplied salt
                        PrimaryCredentials->Passwords,
                        NULL,                           // no principal name
                        IsSystemLogon ? MachineAccount : UserAccount,
                        PasswordFlags,
                        &PrimaryCredentials->OldPasswords
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        //
        // Store the clear password if necessary
        //

        if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
        {
            Status = KerbDuplicatePassword(
                        &PrimaryCredentials->ClearPassword,
                        Password
                        );
            if (NT_SUCCESS(Status))
            {
                KerbHidePassword(
                    &PrimaryCredentials->ClearPassword
                    );
            }
        }
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(&PrimaryCredentials->UserName);
        KerbFreeString(&PrimaryCredentials->DomainName);
        if (PrimaryCredentials->ClearPassword.Buffer != NULL)
        {
            RtlZeroMemory(
                PrimaryCredentials->ClearPassword.Buffer,
                PrimaryCredentials->ClearPassword.Length
                );
            KerbFreeString(&PrimaryCredentials->ClearPassword);
        }

    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbChangeCredentialsPassword
//
//  Synopsis:   Changes the password for a KERB_PRIMARY_CREDENTIALS -
//              copies the current password into the old password field
//              and then sets the new pasword as the primary password.
//              If no new password is provided, it just fixes up the salt.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbChangeCredentialsPassword(
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING NewPassword,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_STORED_CREDENTIAL Passwords = NULL;


    //
    // LogonSession no password was supplied, use the cleartext password
    //

    if (!ARGUMENT_PRESENT(NewPassword) && (PrimaryCredentials->ClearPassword.Buffer == NULL))
    {
        D_DebugLog((DEB_ERROR,"Can't change password without new password\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    if (PrimaryCredentials->ClearPassword.Buffer != NULL)
    {
        KerbRevealPassword(&PrimaryCredentials->ClearPassword);
    }

    Status = KerbBuildPasswordList(
                (ARGUMENT_PRESENT(NewPassword) ? NewPassword : &PrimaryCredentials->ClearPassword),
                &PrimaryCredentials->UserName,
                &PrimaryCredentials->DomainName,
                EtypeInfo,
                PrimaryCredentials->Passwords,
                NULL,                   // no principal name
                AccountType,
                PasswordFlags,
                &Passwords
                );
    if (!NT_SUCCESS(Status))
    {
        if (PrimaryCredentials->ClearPassword.Buffer != NULL)
        {
            KerbHidePassword(&PrimaryCredentials->ClearPassword);
        }
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {
        KerbFreeString(&PrimaryCredentials->ClearPassword);

        Status = KerbDuplicatePassword(
                    &PrimaryCredentials->ClearPassword,
                    NewPassword
                    );
        if (NT_SUCCESS(Status))
        {
            KerbHidePassword(
                &PrimaryCredentials->ClearPassword
                );
        }
    }
    else
    {
        KerbHidePassword(
            &PrimaryCredentials->ClearPassword
            );
    }


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Move the current password to the old password
    //

    if (ARGUMENT_PRESENT(NewPassword))
    {
        if (PrimaryCredentials->OldPasswords != NULL)
        {
            KerbFreeStoredCred(PrimaryCredentials->OldPasswords);
        }
        PrimaryCredentials->OldPasswords = PrimaryCredentials->Passwords;
    }
    else
    {
        KerbFreeStoredCred(PrimaryCredentials->Passwords);
    }

    PrimaryCredentials->Passwords = Passwords;
    Passwords = NULL;

Cleanup:
    if (Passwords != NULL)
    {
        MIDL_user_free(Passwords);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateLogonSession
//
//  Synopsis:   Allocates a logon session, fills in the various fields,
//              and inserts it on the logon session list
//
//  Effects:
//
//  Arguments:  LogonId - LogonId for new logon session
//              AccountName - Account name of user
//              Domain Name - Domain name of user
//              Password - password for user
//              OldPassword - Old password for user, if present
//              LogonType - Type of logon
//              NewLogonSession - Receives new logon session (referenced)
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateLogonSession(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    NTSTATUS Status;

    D_DebugLog((DEB_TRACE_LSESS,"Creating logon session for 0x%x:0x%x\n",
        LogonId->HighPart,LogonId->LowPart));


    //
    // Check for a logon session with the same id
    //

    LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        FALSE           // don't unlink
                        );
    if (LogonSession != NULL)
    {
        //
        // We already have this logon session, so don't create another one.
        //
        KerbDereferenceLogonSession(LogonSession);

        return(STATUS_OBJECT_NAME_EXISTS);
    }
    //
    // Allocate the new logon session
    //

    Status = KerbAllocateLogonSession( &LogonSession );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Fill in the logon session components
    //

    LogonSession->LogonId = *LogonId;
    LogonSession->Lifetime = KerbGlobalWillNeverTime;

    //
    // All logons are deferred until proven otherwise
    //

    LogonSession->LogonSessionFlags = KERB_LOGON_DEFERRED;

    //
    // If the domain name is equal to the computer name then the logon was
    //  local.
    //

#ifndef WIN32_CHICAGO
    KerbGlobalReadLock();

    if (RtlEqualDomainName(
            DomainName,
            &KerbGlobalMachineName
            ))
    {
        LogonSession->LogonSessionFlags |= KERB_LOGON_LOCAL_ONLY;
    }

    KerbGlobalReleaseLock();
#endif // WIN32_CHICAGO

    Status = KerbCreatePrimaryCredentials(
                AccountName,
                DomainName,
                Password,
                OldPassword,
                PasswordFlags,
                LogonId,
                &LogonSession->PrimaryCredentials
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbInitializeList(
                &LogonSession->CredmanCredentials
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonSession->LogonSessionFlags |= KERB_LOGON_CREDMAN_INITIALIZED;



    if ((LogonSession->PrimaryCredentials.Passwords == NULL) ||
        (LogonSession->PrimaryCredentials.Passwords->CredentialCount == 0))
    {
        LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
    }

    //
    // S4ULogon (any reason to keep this??? maybe for debug..)
    //
    if ((PasswordFlags & KERB_LOGON_S4U_SESSION) != 0)
    {
        LogonSession->LogonSessionFlags |= KERB_LOGON_S4U_SESSION;
    }




    //
    // Now that the logon session structure is filled out insert it
    // into the list. After this you need to hold the logon session lock
    // to read or write this logon session.
    //

    Status = KerbInsertLogonSession(LogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *NewLogonSession = LogonSession;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != LogonSession)
        {
            KerbFreeLogonSession(LogonSession);
            LogonSession = NULL;
        }
    }
    return(Status);

}


#ifndef WIN32_CHICAGO



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateLogonSessionFromKerbCred
//
//  Synopsis:   Creates a logon session from the delegation information
//              in a KERB_CRED structure. If a logon session is supplied,
//              it is updated with the supplied information.
//
//  Effects:
//
//  Arguments:  LogonId - Logon id for the logon session
//              Ticket - Ticket from the AP request containing the client's
//                      name and realm.
//              KerbCred - KERB_CRED containing the delegation tickets
//              EncryptedCred - Structure containing information about the
//                      tickets, such as session keys, flags, etc.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateLogonSessionFromKerbCred(
    IN OPTIONAL PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_CRED KerbCred,
    IN PKERB_ENCRYPTED_CRED EncryptedCred,
    IN OUT PKERB_LOGON_SESSION *OldLogonSession
    )
{

    PKERB_LOGON_SESSION LogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING AccountName;
    UNICODE_STRING ShortAccountName;
    UNICODE_STRING DomainName;
    KERB_ENCRYPTED_KDC_REPLY FakeReplyBody;
    KERB_KDC_REPLY FakeReply;
    PKERB_CRED_INFO CredInfo;
    PKERB_CRED_TICKET_LIST TicketList;
    PKERB_CRED_INFO_LIST CredInfoList;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry;
    ULONG NameType;
    LPWSTR LastSlash;
    BOOLEAN LogonSessionLocked = FALSE;
    BOOLEAN CreatedLogonSession = TRUE;
    PKERB_TICKET_CACHE TicketCache = NULL;
    ULONG TgtFlags = KERB_TICKET_CACHE_PRIMARY_TGT;
    ULONG CacheFlags = 0;

    AccountName.Buffer = NULL;
    DomainName.Buffer = NULL;
    if (ARGUMENT_PRESENT(LogonId))
    {
        D_DebugLog((DEB_TRACE_LSESS,"Creating logon session for 0x%x:0x%x\n",
            LogonId->HighPart,LogonId->LowPart));
    }


    if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
            &AccountName,
            &NameType,
            &Ticket->client_name
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // We need to strip off everything before the last '\' in case there
    // was a domain name.
    //

    LastSlash = wcsrchr(AccountName.Buffer, L'\\');
    if (LastSlash != NULL)
    {
        ShortAccountName.Buffer = LastSlash+1;
        RtlInitUnicodeString(
            &ShortAccountName,
            ShortAccountName.Buffer
            );
    }
    else
    {
        ShortAccountName = AccountName;
    }
    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
            &DomainName,
            &Ticket->client_realm
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Creating delegation logon session for %wZ \\ %wZ\n",
        &DomainName, &ShortAccountName ));

    if ((*OldLogonSession) == NULL)
    {
        //
        // Allocate the new logon session
        //

        Status = KerbAllocateLogonSession( &LogonSession );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Fill in the logon session components
        //

        LogonSession->LogonId = *LogonId;
        LogonSession->Lifetime = KerbGlobalWillNeverTime;


        Status = KerbCreatePrimaryCredentials(
                    &ShortAccountName,
                    &DomainName,
                    NULL,   // no password
                    NULL,   // no old password
                    0,      // no flags
                    LogonId,
                    &LogonSession->PrimaryCredentials
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
    }
    else
    {
        CreatedLogonSession = FALSE;
        KerbWriteLockLogonSessions(*OldLogonSession);
        LogonSessionLocked = TRUE;
        LogonSession = *OldLogonSession;

        //
        // If the user name & domain name are blank, update them from the
        // ticket.
        //

        if (LogonSession->PrimaryCredentials.UserName.Length == 0)
        {
            KerbFreeString(&LogonSession->PrimaryCredentials.UserName);
            LogonSession->PrimaryCredentials.UserName = AccountName;
            AccountName.Buffer = NULL;
        }
        if (LogonSession->PrimaryCredentials.DomainName.Length == 0)
        {
            KerbFreeString(&LogonSession->PrimaryCredentials.DomainName);
            LogonSession->PrimaryCredentials.DomainName = DomainName;
            DomainName.Buffer = NULL;
        }
    }

    //
    // Now stick the ticket into the ticket cache. First build up a fake
    // KDC reply message from the encryped cred info.
    //

    TicketList = KerbCred->tickets;
    CredInfoList = EncryptedCred->ticket_info;

    while (TicketList != NULL)
    {
        TimeStamp Endtime = {0};

        if (CredInfoList == NULL)
        {

            D_DebugLog((DEB_ERROR, "No ticket info in encrypted cred. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        CredInfo = &CredInfoList->value;

        //
        // Set the lifetime to the end or renew_until of the longest lived ticket
        //

        if ((CredInfo->bit_mask & KERB_CRED_INFO_renew_until_present) != 0)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Endtime,
                &CredInfo->KERB_CRED_INFO_renew_until,
                0                                   // no usec
                );
        }
        else if ((CredInfo->bit_mask & endtime_present) != 0)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Endtime,
                &CredInfo->endtime,
                0                                   // no usec
                );
        }

        if (Endtime.QuadPart != 0)
        {
            if (LogonSession->Lifetime.QuadPart == KerbGlobalWillNeverTime.QuadPart)
            {
                LogonSession->Lifetime.QuadPart = Endtime.QuadPart;
            }
            else
            {
                LogonSession->Lifetime.QuadPart = max(LogonSession->Lifetime.QuadPart,Endtime.QuadPart);
            }
        }



        RtlZeroMemory(
            &FakeReplyBody,
            sizeof(KERB_ENCRYPTED_KDC_REPLY)
            );

        FakeReplyBody.session_key = CredInfo->key;
        FakeReplyBody.nonce = 0;

        //
        // Set the ticket flags
        //

        if (CredInfo->bit_mask & flags_present)
        {
            FakeReplyBody.flags = CredInfo->flags;
        }
        else
        {
            FakeReplyBody.flags.length = 0;
            FakeReplyBody.flags.value = NULL;
        }

        FakeReplyBody.authtime = Ticket->authtime;

        if (CredInfo->bit_mask & KERB_CRED_INFO_starttime_present)
        {
            FakeReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
                CredInfo->KERB_CRED_INFO_starttime;
            FakeReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;
        }

        //
        // If an end time was sent, use it, otherwise assume the ticket
        // lasts forever
        //

        if (CredInfo->bit_mask & endtime_present)
        {
            FakeReplyBody.endtime =
                CredInfo->endtime;
        }
        else
        {
            KerbConvertLargeIntToGeneralizedTime(
                &FakeReplyBody.endtime,
                NULL,
                &KerbGlobalWillNeverTime
                );
        }

        if (CredInfo->bit_mask & KERB_CRED_INFO_renew_until_present)
        {
            FakeReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
                CredInfo->KERB_CRED_INFO_renew_until;
            FakeReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
        }

        FakeReplyBody.server_name = TicketList->value.server_name;
        FakeReplyBody.server_realm = TicketList->value.realm;

        //
        // Determine which ticket cache to use
        //

        if ((FakeReplyBody.server_name.name_string != NULL) &&
            _stricmp(
                FakeReplyBody.server_name.name_string->value,
                KDC_PRINCIPAL_NAME_A) == 0)
        {
            TicketCache = &LogonSession->PrimaryCredentials.AuthenticationTicketCache;
            //
            // We only want to use the primary_tgt flag the first time through
            //

            CacheFlags = TgtFlags;
            TgtFlags = 0;
            D_DebugLog((DEB_TRACE,"Adding ticket from kerb_cred to authentication ticket cache\n"));
        }
        else
        {
            TicketCache = &LogonSession->PrimaryCredentials.ServerTicketCache;
            CacheFlags = 0;
            D_DebugLog((DEB_TRACE,"Adding ticket from kerb_cred to server ticket cache\n"));
        }


        FakeReply.client_name = Ticket->client_name;
        FakeReply.ticket = TicketList->value;
        FakeReply.client_realm = Ticket->client_realm;
        Status = KerbCacheTicket(
                    TicketCache,
                    &FakeReply,
                    &FakeReplyBody,
                    NULL,               // no target name
                    NULL,
                    CacheFlags,
                    TRUE,               // link
                    &TicketCacheEntry
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "Failed to cache ticket: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;

        KerbDereferenceTicketCacheEntry(TicketCacheEntry);

        CredInfoList = CredInfoList->next;
        TicketList = TicketList->next;
    }

    //
    // Now that the logon session structure is filled out insert it
    // into the list. After this you need to hold the logon session lock
    // to read or write this logon session.
    //

    if (*OldLogonSession == NULL)
    {
        Status = KerbInsertLogonSession(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        *OldLogonSession = LogonSession;
    }

Cleanup:


    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (CreatedLogonSession)
    {
        if (!NT_SUCCESS(Status))
        {
            if (LogonSession != NULL)
            {
                KerbFreeLogonSession(LogonSession);
            }
        }
    }
    KerbFreeString(&AccountName);
    KerbFreeString(&DomainName);
    return(Status);

}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\pkauth.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        pkauth.h
//
// Contents:    Structures and prototypes for public key kerberos
//
//
// History:     14-October-1997     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __PKAUTH_H__
#define __PKAUTH_H__

VOID
KerbFreePKCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );


BOOL
KerbComparePublicKeyCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds1,
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds2
    );


NTSTATUS
KerbBuildPkinitPreauthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RealmName,
    IN ULONG Nonce,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    );

NTSTATUS
KerbCreateSmartCardLogonSessionFromCertContext(
    IN PCERT_CONTEXT *ppCertContext,
    IN PLUID pLogonId,
    IN PUNICODE_STRING pAuthorityName,
    IN PUNICODE_STRING pPin,
    IN PUCHAR pCspData,
    IN ULONG CspDataLength,
    OUT PKERB_LOGON_SESSION *ppLogonSession,
    OUT PUNICODE_STRING pAccountName
    );

NTSTATUS
KerbCreateSmartCardLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION *ReturnedLogonSession,
    OUT PLUID ReturnedLogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );


NTSTATUS
KerbDoLocalSmartCardLogon(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    IN  OUT PNETLOGON_VALIDATION_SAM_INFO4 * Validation4
    );

VOID
KerbCacheSmartCardLogon(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN PUNICODE_STRING DnsDomain,
    IN OPTIONAL PUNICODE_STRING UPN,
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY CachedCredentials
    );

NTSTATUS
KerbInitializePkinit(
    VOID
    );

NTSTATUS
KerbInitializePkCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );

VOID
KerbReleasePkCreds(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );

NTSTATUS
KerbMapClientCertChainError(ULONG ChainStatus);

#endif // __PKAUTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\pkauth.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        pkauth.cxx
//
// Contents:    Routines for supporting public-key authentication
//
//
// History:     14-October-1997         Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#include <kerbp.h>

//#ifndef WIN32_CHICAGO
extern "C"
{
#include <stdlib.h>
#include <cryptdll.h>
}
//#endif // WIN32_CHICAGO


#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

KERB_OBJECT_ID KerbSignatureAlg[10];
#define KERB_SCLOGON_DOMAIN_SUFFIX L"-sclogon"
#define KERB_SCLOGON_DOMAIN_SUFFIX_SIZE (sizeof(KERB_SCLOGON_DOMAIN_SUFFIX) - sizeof(WCHAR))

#ifndef SHA1DIGESTLEN
#define SHA1DIGESTLEN 20
#endif

NTSTATUS
KerbInitializeHProvFromCert(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );


//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePublicKeyCreds
//
//  Synopsis:   Verfies a certificate is valid for the specified usage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOL
KerbComparePublicKeyCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds1,
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds2
    )
{

    return CertCompareCertificate(
                X509_ASN_ENCODING,                                                            
                PkCreds1->CertContext->pCertInfo,
                PkCreds2->CertContext->pCertInfo
                );

    // more later?

    //return (fRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckCertificate
//
//  Synopsis:   Verfies a certificate is valid for the specified usage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    IN LPSTR Usage,
    IN BOOLEAN LocalLogon // AllowRevocationCheckFailure
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CERT_CHAIN_PARA ChainParameters = {0};
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;



    if (!CertGetCertificateChain(
                                HCCE_LOCAL_MACHINE,
                                CertContext,
                                NULL,                 // evaluate at current time
                                NULL,                 // no additional stores
                                &ChainParameters,
                                (LocalLogon?
                                CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY|CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT:
                                CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT),
                                NULL,                 // reserved
                                &ChainContext
                                ))
    {
        DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        Status = STATUS_PKINIT_FAILURE; 
    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        CERT_CHAIN_POLICY_STATUS PolicyStatus;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);
        if (LocalLogon)
        {
            ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
        }

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;

        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_BASE,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {
            DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
            Status = STATUS_PKINIT_FAILURE;
        }

        if(PolicyStatus.dwError != S_OK)
        {
            DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbReportPkinitError(
                PolicyStatus.dwError,
                CertContext
                );
            
            Status = STATUS_PKINIT_FAILURE;
        }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPkAsReply
//
//  Synopsis:   Verifies the reply from the KDC and retrieves the
//              ticket encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyPkAsReply(
    IN PKERB_PA_DATA_LIST InputPaData,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN ULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PBOOLEAN Done
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_PK_AS_REP Reply = NULL;
    PCCERT_CONTEXT KdcCertContext = NULL;
    PBYTE EncodedKeyPackage = NULL;
    ULONG KeyPackageSize = 0;
    PKERB_SIGNED_REPLY_KEY_PACKAGE KeyPackage = NULL;
    PKERB_REPLY_KEY_PACKAGE ReplyKeyPackage = NULL;
    PBYTE PackedKeyPack = NULL;
    ULONG PackedKeyPackSize = 0;
    HCRYPTKEY PrivateKey = NULL;
    PKERB_ENCRYPTION_KEY TempKey = NULL;
    HCRYPTPROV KdcProvider = NULL;
    BOOLEAN InitializedPkCreds = FALSE;

    NTSTATUS TokenStatus = STATUS_SUCCESS;
    HANDLE ImpersonationToken = NULL;


    *Done = TRUE;

    //
    // Unpack the request
    //

    KerbErr = KerbUnpackData(
                InputPaData->value.preauth_data.value,
                InputPaData->value.preauth_data.length,
                KERB_PA_PK_AS_REP_PDU,
                (PVOID *) &Reply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (Reply->choice != key_package_chosen)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Now we need to verify the signature on the message
    //
    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        InitializedPkCreds = TRUE;

    }
    else if ((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) != 0)
    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Decode the contents as an encrypted data buffer
    //


    Status = __ScHelperDecryptMessage(
                &Credentials->PublicKeyCreds->Pin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->hProv,
                Credentials->PublicKeyCreds->CertContext,
                Reply->u.key_package.value,
                Reply->u.key_package.length,
                EncodedKeyPackage,
                &KeyPackageSize
                );


    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt pkcs message: %x\n",Status));
        goto Cleanup;
    }

    EncodedKeyPackage = (PBYTE) KerbAllocate(KeyPackageSize);
    if (EncodedKeyPackage == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = __ScHelperDecryptMessage(
                &Credentials->PublicKeyCreds->Pin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->hProv,
                Credentials->PublicKeyCreds->CertContext,
                Reply->u.key_package.value,
                Reply->u.key_package.length,
                EncodedKeyPackage,
                &KeyPackageSize
                );


    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to decrypt pkcs message: %x\n",Status));
        goto Cleanup;
    }

    //
    // Verify the signature
    //

    Status = ScHelperVerifyPkcsMessage(
                Credentials->PublicKeyCreds->CspData,
                NULL,                                   // we don't care which CSP is used for the verification
                EncodedKeyPackage,
                KeyPackageSize,
                PackedKeyPack,
                &PackedKeyPackSize,
                NULL        // don't return certificate context
                );
    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
        goto Cleanup;
    }

    PackedKeyPack = (PBYTE) MIDL_user_allocate(PackedKeyPackSize);
    if (PackedKeyPack == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = ScHelperVerifyPkcsMessage(
                Credentials->PublicKeyCreds->CspData,
                NULL,                                   // we don't care which CSP is used for the verification
                EncodedKeyPackage,
                KeyPackageSize,
                PackedKeyPack,
                &PackedKeyPackSize,
                &KdcCertContext
                );
    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                PackedKeyPack,
                PackedKeyPackSize,
                KERB_REPLY_KEY_PACKAGE_PDU,
                (PVOID *) &ReplyKeyPackage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack reply key package\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    if (Nonce != (ULONG) ReplyKeyPackage->nonce)
    {
        D_DebugLog((DEB_ERROR,"Returned nonce is not correct: 0x%x instead of 0x%x. %ws, line %d\n",
            ReplyKeyPackage->nonce, Nonce, THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Finally, copy the encryption key out and return it.
    //

    if (!KERB_SUCCESS(KerbDuplicateKey(
            EncryptionKey,
            &ReplyKeyPackage->reply_key
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Verify the certificate
    //
    // If we're impersonating, revert, and save off old token.  This keeps us from
    // going recursive.
    //
    // Are we impersonating?
    //
    TokenStatus = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE,
                    TRUE,
                    &ImpersonationToken
                    );

    if( NT_SUCCESS(TokenStatus) )
    {   
        RevertToSelf();
    } 
    else if (TokenStatus != STATUS_NO_TOKEN)
    {
        Status = TokenStatus;
        goto Cleanup;
    }

    Status = KerbCheckCertificate(
                KdcCertContext,
                KERB_PKINIT_KDC_CERT_TYPE,
                FALSE                           // don't allow revocation failures
                );

    //
    // re-impersonate
    //
    if( ImpersonationToken != NULL ) {

        //
        // put the thread token back if we were impersonating.
        //
        SetThreadToken( NULL, ImpersonationToken );
        NtClose( ImpersonationToken );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to verify KDC certificate: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:

    //
    // If we initialized these, reset them
    //
    if (InitializedPkCreds)
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds
            );
    }

    if (Reply != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REP_PDU,
            Reply
            );
    }

    if (KdcCertContext != NULL)
    {
        CertFreeCertificateContext(KdcCertContext);
    }
    if (KeyPackage != NULL)
    {
        KerbFreeData(
            KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
            KeyPackage
            );
    }
    if (ReplyKeyPackage != NULL)
    {
        KerbFreeData(
            KERB_REPLY_KEY_PACKAGE_PDU,
            ReplyKeyPackage
            );
    }
    if (PackedKeyPack != NULL)
    {
        MIDL_user_free(PackedKeyPack);
    }
    if (PrivateKey != NULL)
    {
        CryptDestroyKey(PrivateKey);
    }
    if (TempKey != NULL)
    {
        KerbFreeData(
            KERB_ENCRYPTION_KEY_PDU,
            TempKey
            );
    }
    if (KdcProvider != NULL)
    {
        CryptReleaseContext(
            KdcProvider,
            0   // no flags
            );
    }
    if (EncodedKeyPackage != NULL)
    {
        KerbFree(EncodedKeyPackage);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetUserCertificates
//
//  Synopsis:   Gets a list of the user certificates
//
//  Effects:
//
//  Arguments:  Credentials - client's credentials containing certificate
//              Certficates - receives list of certificates.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetUserCertificates(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_CERTIFICATE_LIST * Certificates
    )
{
    NTSTATUS Status = STATUS_SUCCESS;


    if (!KERB_SUCCESS(KerbCreateCertificateList(
                        Certificates,
                        Credentials->PublicKeyCreds->CertContext
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:
    return(Status);

}

#if 0 // could not find any users - markpu - 04/19/2001 - will remove later

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTrustedCertifiers
//
//  Synopsis:   Gets the list of trusted certifiers for this machine
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetTrustedCertifiers(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_CERTIFIER_LIST * Certifiers
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CERTIFIER_LIST ListEntry = NULL;

    //
    // Build a dummy list entry
    //

    ListEntry = (PKERB_CERTIFIER_LIST) KerbAllocate(sizeof(KERB_CERTIFIER_LIST));
    if (ListEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertStringToPrincipalName(
                &ListEntry->value,
                &KerbGlobalKdcServiceName,
                KRB_NT_PRINCIPAL
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    *Certifiers = ListEntry;
    ListEntry = NULL;
Cleanup:
    if (ListEntry != NULL)
    {
        KerbFreePrincipalName( &ListEntry->value );
        KerbFree(ListEntry);
    }
    return(Status);
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePKCreds
//
//  Synopsis:   Frees the public key creds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePKCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{
    if (NULL != PkCreds)
    {
        if (((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) != 0) &&
            ((PkCreds->InitializationInfo & (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) == 0))
        {
            __ScHelperRelease(
                PkCreds->CspData
                );

            PkCreds->InitializationInfo &= ~CSP_DATA_INITIALIZED;
        }
        if (PkCreds->hProv != NULL)
        {
            CryptReleaseContext(PkCreds->hProv, 0);
            PkCreds->hProv = NULL;
        }
        if (PkCreds->CertContext != NULL)
        {
            CertFreeCertificateContext(PkCreds->CertContext);
            PkCreds->CertContext = NULL;
        }
        KerbFreeString(&PkCreds->Pin);
        KerbFree(PkCreds);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeHProvFromCert
//
//  Synopsis:   Initializes the out parameter phProv by getting the key
//              prov info from the cert context and acquiring a CSP context
//              given this information.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeHProvFromCert(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{
    
    ULONG cPin;
    LPWSTR pwszPin = NULL;
    LPSTR pszPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
        

    if (!CryptAcquireCertificatePrivateKey(
                PkCreds->CertContext,
                CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_SILENT,
                NULL,
                &PkCreds->hProv,
                NULL,
                NULL
                ))
    {
        DebugLog((DEB_ERROR, 
                  "CryptAcquireCertificatePrivateKey failed - %x\n",
                  GetLastError()));
        Status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Cleanup;
    }  
    

    //
    // Convert the pin to ANSI, but only for creds acquired by ACH, as the 
    // credman isn't "allowed" to cache pins anymore..
    //
    if (( PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_ACH ) != 0)
    {

        if (0 == PkCreds->Pin.Length)
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
        pwszPin = (LPWSTR)KerbAllocate(PkCreds->Pin.Length + sizeof(WCHAR));
        if (NULL == pwszPin)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(pwszPin, PkCreds->Pin.Buffer, PkCreds->Pin.Length);
        pwszPin[PkCreds->Pin.Length / sizeof(WCHAR)] = L'\0';

        cPin = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwszPin,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        pszPin = (LPSTR)KerbAllocate((cPin + 1) * sizeof(CHAR));
        if (NULL == pszPin)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        cPin = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwszPin,
                    -1,
                    pszPin,
                    cPin,
                    NULL,
                    NULL);

        if (!CryptSetProvParam(
                    PkCreds->hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)pszPin,
                    0
                    ))
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }



Cleanup:
    
    if (NULL != pwszPin)
    {
        KerbFree(pwszPin);
    }
    if (NULL != pszPin)
    {
        KerbFree(pszPin);
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializePkCreds
//
//  Synopsis:   Initializes or re-initailizes the smart card data in
//              the public key creds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializePkCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {

        //
        // check if we are using cred man creds (already have a cert context)
        //

        if (((PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
            ((PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_ACH) == 0))
        {
            Status  = __ScHelperInitializeContext(
                            PkCreds->CspData,
                            PkCreds->CspDataLength
                            );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"ScHelperInitializeContext failed- %x\n", Status));
                goto Cleanup;
            }
            PkCreds->InitializationInfo |= CSP_DATA_INITIALIZED;
        }
        else
        {
            if (PkCreds->CertContext == NULL)
            {
                D_DebugLog((DEB_ERROR,"Using cred man creds but cert context is NULL.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            PkCreds->InitializationInfo |= CSP_DATA_INITIALIZED;
        }

    }

    if (PkCreds->CertContext == NULL)
    {
        Status = __ScHelperGetCertFromLogonInfo(
                    PkCreds->CspData,
                    &PkCreds->Pin,
                    &PkCreds->CertContext
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to get cert from logon info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            if (NT_SUCCESS(Status))
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto Cleanup;
        }

    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) != 0) &&
            ((PkCreds->InitializationInfo & ( CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) == 0))
        {
            __ScHelperRelease(
                PkCreds->CspData
                );

                PkCreds->InitializationInfo &= ~CSP_DATA_INITIALIZED;
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReleasePkCreds
//
//  Synopsis:   Releaes smart-card resources in the public key creds.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReleasePkCreds(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{

    if (ARGUMENT_PRESENT(LogonSession))
    {
        KerbWriteLockLogonSessions(
            LogonSession
            );
        PkCreds = LogonSession->PrimaryCredentials.PublicKeyCreds;
    }

    KerbFreePKCreds(PkCreds);

    if (ARGUMENT_PRESENT(LogonSession))
    {
        LogonSession->PrimaryCredentials.PublicKeyCreds = NULL;
        KerbUnlockLogonSessions(
            LogonSession
            );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComputePkAuthenticatorSignature
//
//  Synopsis:   Computes the signature of the PK authenticator by
//              marshalling the authenticator, checksumming it, then
//              encrypting the checksum with the public key, more or less
//
//  Effects:
//
//  Arguments:  AuthPackage - authenticator to sign
//              Credentials - Client's credentials (containing keys)
//              Signature - receives signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbComputePkAuthenticatorSignature(
    IN PKERB_AUTH_PACKAGE AuthPackage,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_SIGNATURE Signature
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PBYTE PackedAuthenticator = NULL;
    ULONG PackedAuthenticatorSize;
    BOOLEAN InitializedPkCreds = FALSE;
    PUNICODE_STRING TmpPin = NULL;

#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE PkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG PkSignatureLength = KERB_PK_MAX_SIGNATURE_SIZE;


    RtlZeroMemory(
        Signature,
        sizeof(KERB_SIGNATURE)
        );

    //
    // First marshall the auth package
    //

    KerbErr = KerbPackData(
                AuthPackage,
                KERB_AUTH_PACKAGE_PDU,
                &PackedAuthenticatorSize,
                &PackedAuthenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        InitializedPkCreds = TRUE;

    }
    else if (((Credentials->PublicKeyCreds->InitializationInfo 
               & (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) != 0)) 

    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }



    // Initialize the PIN for ScHelperSignPkcs routines.
    if (((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
        (Credentials->PublicKeyCreds->Pin.Buffer != NULL))
    {
        TmpPin = &Credentials->PublicKeyCreds->Pin;
    }




    //
    // Now generate the checksum
    //


    Status = __ScHelperSignMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->hProv,
                KERB_PKINIT_SIGNATURE_ALG,
                PackedAuthenticator,
                PackedAuthenticatorSize,
                PkSignature,
                &PkSignatureLength
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to sign message with card: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Build the signature
    //


    Signature->signature_algorithm.algorithm = KerbSignatureAlg;

    //
    // Copy the temporary signature into the return structure
    //

    Signature->pkcs_signature.length = PkSignatureLength * 8; // because it is a bit string
    Signature->pkcs_signature.value = (PBYTE) KerbAllocate( PkSignatureLength );
    if (Signature->pkcs_signature.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        Signature->pkcs_signature.value,
        PkSignature,
        PkSignatureLength
        );


    Status = STATUS_SUCCESS;



Cleanup:
    if (InitializedPkCreds)
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds
            );

    }



    if (PackedAuthenticator != NULL)
    {
        MIDL_user_free(PackedAuthenticator);
    }
    return(Status);

}

NTSTATUS
KerbGetProvParamWrapper(
    IN PUNICODE_STRING pPin,
    IN PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (NULL != hProv)
    {
        if (!CryptGetProvParam(
                hProv,
                dwParam,
                pbData,
                pdwDataLen,
                dwFlags
                ))
        {
            DebugLog((DEB_ERROR, "Failure in SC subsytem - %x\n",GetLastError()));
            Status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Cleanup;
        }
    }
    else
    {
        Status = __ScHelperGetProvParam(
                    pPin,
                    pbLogonInfo,
                    dwParam,
                    pbData,
                    pdwDataLen,
                    dwFlags
                    );
        
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failure in SC subsytem - %x\n",Status));
        }

    }
Cleanup:
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSmartCardAlgorithms
//
//  Synopsis:   Gets the supported encryption types from the
//              smart card provider
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSmartCardAlgorithms(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_CRYPT_LIST * CryptList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PROV_ENUMALGS Data;
    ULONG DataSize;
    ULONG Flags = CRYPT_FIRST;
#define KERB_SUPPORTED_PK_CRYPT_COUNT 2

    ULONG CryptTypes[KERB_SUPPORTED_PK_CRYPT_COUNT];
    ULONG CryptCount = 0;

    //
    // Enumerate through to get the encrypt types
    //

    while (1)
    {
        DataSize = sizeof(Data);
        Status = KerbGetProvParamWrapper(
                    &Credentials->PublicKeyCreds->Pin,
                    Credentials->PublicKeyCreds->CspData,
                    Credentials->PublicKeyCreds->hProv,
                    PP_ENUMALGS,
                    (BYTE *) &Data,
                    &DataSize,
                    Flags
                    );

        if (Status == STATUS_NO_MORE_ENTRIES)
        {
            Status = STATUS_SUCCESS;
            break;
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"GetProvPram failed: 0x%x\n", Status));
            return(Status);
        }

        //
        // Reset the flags to enumerate though
        //

        Flags = 0;    // CRYPT_NEXT

        //
        // Check if it is an encryption algorithm. We only want
        // to know about 3des and RC4
        //


        if (GET_ALG_CLASS(Data.aiAlgid) == ALG_CLASS_DATA_ENCRYPT)
        {
            //
            // Check the type
            //

            if (GET_ALG_TYPE(Data.aiAlgid) == ALG_TYPE_BLOCK)
            {
                //
                // Check for 3des
                //

                if (GET_ALG_SID(Data.aiAlgid) == ALG_SID_3DES)
                {
                    //
                    // Add it to the list.
                    //
                    CryptTypes[CryptCount++] = KERB_ETYPE_DES_EDE3_CBC_ENV;
                }
                else if (GET_ALG_SID(Data.aiAlgid) == ALG_SID_RC2)
                {
                    //
                    // Add it to the list.
                    //
                    CryptTypes[CryptCount++] = KERB_ETYPE_RC2_CBC_ENV;
                }

            }
        }
        if (CryptCount == KERB_SUPPORTED_PK_CRYPT_COUNT)
        {
            break;
        }

    }

    //
    // Now, if there are any crypt types, convert them.
    //

    if (CryptCount != 0)
    {
        KERBERR KerbErr;

        KerbErr = KerbConvertArrayToCryptList(
                    CryptList,
                    CryptTypes,
                    CryptCount
                    );
        return(KerbMapKerbError(KerbErr));
    }
    else
    {
        //
        // We needed one of these, so bail now.
        //

        DebugLog((DEB_ERROR,"Smart card doesn't support rc2 or 3des for logon - failing out.\n"));

        return(STATUS_CRYPTO_SYSTEM_INVALID);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPkinitPreAuthData
//
//  Synopsis:   Builds the pre-auth data for a PK-INIT AS request
//
//  Effects:
//
//  Arguments:  Credentials - Credentials to use for this request
//              InputPaData - Any PA data returned from DC on previous
//                      call
//              TimeSkew - Known time skew with KDC
//              ServiceName - Name for which we are requesting a ticket
//              RealmName - name of realm in which we are requesting a ticket
//              PreAuthData - receives new PA data
//              Done - if returned as TRUE, then routine need not be called
//                      again
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildPkinitPreauthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RealmName,
    IN ULONG Nonce,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_PA_PK_AS_REQ Request = {0};
    KERB_AUTH_PACKAGE AuthPack = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    ULONG PackedRequestSize = 0;
    PBYTE PackedRequest = NULL;
    PBYTE PackedAuthPack = NULL;
    ULONG PackedAuthPackSize = 0;
    PBYTE SignedAuthPack = NULL;
    ULONG SignedAuthPackSize = 0;
    TimeStamp TimeNow;
    KERBERR KerbErr;
    BOOLEAN InitializedPkCreds = FALSE;
    CRYPT_ALGORITHM_IDENTIFIER CryptAlg = {0};
    PUNICODE_STRING TmpPin = NULL;
    HANDLE          ClientTokenHandle = NULL;
    BOOLEAN         Impersonating = FALSE;

    
    //
    // If we're using credman, we'll need to impersonate any time we make these calls.
    //
    if ( Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS )
    {                         
        Status = LsaFunctions->OpenTokenByLogonId(
                                       &Credentials->PublicKeyCreds->LogonId,
                                       &ClientTokenHandle
                                       );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
            goto Cleanup;
        }

        if(!SetThreadToken(NULL, ClientTokenHandle))
        {
            D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto Cleanup;
        }

        Impersonating = TRUE;
    }
    

    //
    // If there is any input, check to see if we succeeded the last time
    // around
    //

    if (ARGUMENT_PRESENT(InputPaData))
    {
        Status = KerbVerifyPkAsReply(
                    InputPaData,
                    Credentials,
                    Nonce,
                    EncryptionKey,
                    Done
                    );
        goto Cleanup;
    }

    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        InitializedPkCreds = TRUE;

    }
    else if (((Credentials->PublicKeyCreds->InitializationInfo 
               & (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) != 0)) 
    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    // Initialize the PIN for ScHelperSignPkcs routines.
    if (((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
        (Credentials->PublicKeyCreds->Pin.Buffer != NULL))
    {
        TmpPin = &Credentials->PublicKeyCreds->Pin;
    }          


    Status = KerbGetSmartCardAlgorithms(
                Credentials,
                CryptList
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get crypt list for smart card: 0x%x\n",
            Status));
        goto Cleanup;
    }

    //
    // Do the new pa-pk-as-req
    //


    //
    // Now comes the hard part - the PK authenticator
    //

    //
    // First the KDC name
    //

    if (!KERB_SUCCESS(
            KerbConvertKdcNameToPrincipalName(
                &AuthPack.pk_authenticator.kdc_name,
                ServiceName
                )))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Then the realm
    //

    if (!KERB_SUCCESS(
            KerbConvertUnicodeStringToRealm(
                &AuthPack.pk_authenticator.kdc_realm,
                RealmName)))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Now the time
    //

    GetSystemTimeAsFileTime((PFILETIME) &TimeNow);

#ifndef WIN32_CHICAGO
    TimeNow.QuadPart += TimeSkew->QuadPart;
#else // !WIN32_CHICAGO
    TimeNow += *TimeSkew;
#endif // WIN32_CHICAGO

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &AuthPack.pk_authenticator.client_time,
        &AuthPack.pk_authenticator.cusec,
        &TimeNow);

    //
    // And finally the nonce
    //

    AuthPack.pk_authenticator.nonce = Nonce;


    //
    // Pack up the auth pack so we can sign it
    //

    KerbErr = KerbPackData(
                &AuthPack,
                KERB_AUTH_PACKAGE_PDU,
                &PackedAuthPackSize,
                &PackedAuthPack
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack auth package\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now sign it.
    //


    //
    // Now generate the checksum
    //


    CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;


    Status = __ScHelperSignPkcsMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->hProv,
                Credentials->PublicKeyCreds->CertContext,
                &CryptAlg,
                CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                PackedAuthPack,
                PackedAuthPackSize,
                SignedAuthPack,
                &SignedAuthPackSize
                );



    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to sign message: %x\n",Status));
        goto Cleanup;
    }

    SignedAuthPack = (PBYTE) MIDL_user_allocate(SignedAuthPackSize);
    if (SignedAuthPack == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Status = __ScHelperSignPkcsMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->hProv,
                Credentials->PublicKeyCreds->CertContext,
                &CryptAlg,
                CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                PackedAuthPack,
                PackedAuthPackSize,
                SignedAuthPack,
                &SignedAuthPackSize
                );

    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
        goto Cleanup;
    }

    Request.signed_auth_pack.value = SignedAuthPack;
    Request.signed_auth_pack.length = SignedAuthPackSize;

    //
    // Marshall the request
    //

    if (!KERB_SUCCESS(KerbPackData(
                        &Request,
                        KERB_PA_PK_AS_REQ_PDU,
                        &PackedRequestSize,
                        &PackedRequest)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;
    ListElement->value.preauth_data.value = PackedRequest;
    ListElement->value.preauth_data.length = PackedRequestSize;
    PackedRequest = NULL;

    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;
    ListElement = NULL;

Cleanup:
    KerbFreeRealm(
        &AuthPack.pk_authenticator.kdc_realm
        );
    KerbFreePrincipalName(
        &AuthPack.pk_authenticator.kdc_name
        );

    if (ListElement != NULL)
    {
        KerbFree(ListElement);
    }
    if (PackedRequest != NULL)
    {
        MIDL_user_free(PackedRequest);
    }
    if (PackedAuthPack != NULL)
    {
        MIDL_user_free(PackedAuthPack);
    }
    if (SignedAuthPack != NULL)
    {
        MIDL_user_free(SignedAuthPack);
    }

    if ( Impersonating )
    {
        RevertToSelf();
        CloseHandle(ClientTokenHandle);
    }                                  


    if (InitializedPkCreds)
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds
            );
    }


    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateSmartCardLogonSessionFromCertContext
//
//  Synopsis:   Creats a logon session from the cert context and passed in
//              data.  Retrieves the email name from the certificate.
//
//              This function is for use with LogonUser when a marshalled
//              smart card cert is passed in the user name and the PIN is
//              passed as the password.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSmartCardLogonSessionFromCertContext(
    IN PCERT_CONTEXT *ppCertContext,
    IN PLUID pLogonId,
    IN PUNICODE_STRING pAuthorityName,
    IN PUNICODE_STRING pPin,
    IN PUCHAR pCspData,
    IN ULONG CspDataLength,
    OUT PKERB_LOGON_SESSION *ppLogonSession,
    OUT PUNICODE_STRING pAccountName
    )
{
    PKERB_LOGON_SESSION pLogonSession = NULL;
    PKERB_PUBLIC_KEY_CREDENTIALS PkCredentials = NULL;
    ULONG cbPkCreds = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the client name from the cert.
    // Place it in the return location
    //
    Status = KerbGetPrincipalNameFromCertificate(*ppCertContext, pAccountName);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Create a normal logon session. We willa add the public-key information
    // later
    //

    Status = KerbCreateLogonSession(
                pLogonId,
                pAccountName,
                pAuthorityName,
                NULL,           // no password
                NULL,           // no old password
                0,              // no flags
                Interactive,    // logon type
                &pLogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now create the public key credentials to be put in the logon
    // session.
    //

    cbPkCreds = sizeof(KERB_PUBLIC_KEY_CREDENTIALS);
    if ((NULL != pCspData) && (0 != CspDataLength))
    {
        cbPkCreds += CspDataLength;
    }

    PkCredentials = (PKERB_PUBLIC_KEY_CREDENTIALS) KerbAllocate(cbPkCreds);
    if (PkCredentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    
    PkCredentials->CertContext = *ppCertContext;
    *ppCertContext = NULL;

    Status = KerbDuplicateString(
                &PkCredentials->Pin,
                pPin
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy in the CSP data for later use
    //

    if ((NULL != pCspData) && (0 != CspDataLength))
    {
        PkCredentials->CspDataLength = CspDataLength;
        RtlCopyMemory(
            PkCredentials->CspData,
            pCspData,
            CspDataLength
            );
        PkCredentials->InitializationInfo |= CSP_DATA_INITIALIZED;
    }
    else
    {
        PkCredentials->InitializationInfo |= CSP_DATA_INITIALIZED | CONTEXT_INITIALIZED_WITH_ACH;
    }

    KerbWriteLockLogonSessions(pLogonSession);
    pLogonSession->PrimaryCredentials.PublicKeyCreds = PkCredentials;
    pLogonSession->LogonSessionFlags |= KERB_LOGON_SMARTCARD;
    PkCredentials = NULL;
    KerbUnlockLogonSessions(pLogonSession);

    *ppLogonSession = pLogonSession;
    pLogonSession = NULL;
Cleanup:
    if (*ppCertContext != NULL)
    {
        CertFreeCertificateContext(*ppCertContext);
    }

    KerbFreePKCreds(PkCredentials);


    if (pLogonSession != NULL)
    {
        KerbReferenceLogonSessionByPointer(pLogonSession, TRUE);
        KerbDereferenceLogonSession(pLogonSession);
        KerbDereferenceLogonSession(pLogonSession);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapCertChainError
//
//  Synopsis:   We don't have good winerrors for chaining //
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapClientCertChainError(ULONG ChainStatus)
{

    NTSTATUS Status;

    switch(ChainStatus)
    {

    case CRYPT_E_REVOKED:
        Status = STATUS_SMARTCARD_CERT_REVOKED;
        break;
    case CERT_E_EXPIRED:
        Status = STATUS_SMARTCARD_CERT_EXPIRED;
        break;
    case CERT_E_UNTRUSTEDCA:
    case CERT_E_UNTRUSTEDROOT:
        Status = STATUS_ISSUING_CA_UNTRUSTED;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        Status = STATUS_REVOCATION_OFFLINE_C;
        break;

    // W2k or old whistler DC
    case ERROR_NOT_SUPPORTED:
    default:
        Status = STATUS_PKINIT_CLIENT_FAILURE;
    }             

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateSmardCardLogonSession
//
//  Synopsis:   Creats a logon session from the smart card logon info. It
//              creates a certificate context from the logon information,
//              retrieves the email name from the certificate, and then
//              uses that to create a context.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSmartCardLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION *ReturnedLogonSession,
    OUT PLUID ReturnedLogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )
{
    PCERT_CONTEXT CertContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_SMART_CARD_LOGON LogonInfo = (PKERB_SMART_CARD_LOGON) ProtocolSubmitBuffer;
    LUID LogonId = {0};
    BOOLEAN InitializedContext = FALSE;


    //
    // We were passed a blob of data. First we need to update the pointers
    // to be in this address space
    //

    RELOCATE_ONE(&LogonInfo->Pin);

    LogonInfo->CspData = LogonInfo->CspData - (ULONG_PTR) ClientBufferBase + (ULONG_PTR) LogonInfo;

    //
    // Make sure it all fits in our address space
    //

    if ((LogonInfo->CspDataLength + LogonInfo->CspData) >
        ((PUCHAR) ProtocolSubmitBuffer + SubmitBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // First, initialize the crypt context
    //

    Status = __ScHelperInitializeContext(
                LogonInfo->CspData,
                LogonInfo->CspDataLength
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to initialize context from csp data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    InitializedContext = TRUE;

    //
    // The first thing to do is to convert the CSP data into a certificate
    // context
    //

    Status = __ScHelperGetCertFromLogonInfo(
                LogonInfo->CspData,
                &LogonInfo->Pin,
                (PCCERT_CONTEXT*)&CertContext
                );
    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to get cert from logon info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        if (NT_SUCCESS(Status))
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    RtlInitUnicodeString(
        AuthorityName,
        NULL
        );

    //
    // Now we have just about everything to create a logon session
    //

    Status = NtAllocateLocallyUniqueId( &LogonId );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // For win95, if there is a logon session in our list, remove it.
    // This is generated from the logon session dumped in the registry.
    // But, we are about to do a new logon. Get rid of the old logon.
    // If the new one does not succeed, too bad. But, that's by design.
    //

#ifdef WIN32_CHICAGO
    LsaApLogonTerminated(&LogonId);
#endif // WIN32_CHICAGO

    Status = KerbCreateSmartCardLogonSessionFromCertContext(
                &CertContext,
                &LogonId,
                AuthorityName,
                &LogonInfo->Pin,
                LogonInfo->CspData,
                LogonInfo->CspDataLength,
                ReturnedLogonSession,
                AccountName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonInfo->CspDataLength = 0;

    *ReturnedLogonId = LogonId;
Cleanup:
    if (InitializedContext && LogonInfo->CspDataLength != 0)
    {
        __ScHelperRelease(
            LogonInfo->CspData
            );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateName
//
//  Synopsis:   Gets a name from a certificate name blob. The name is:
//              subject@issuer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetCertificateName(
    OUT PUNICODE_STRING Name,
    IN PCERT_INFO Certificate
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG IssuerLength;
    ULONG SubjectLength;

    RtlInitUnicodeString(
        Name,
        NULL
        );

    //
    // First find the size of the name. The lengths include the
    // null terminators.
    //


    SubjectLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Subject,
                    CERT_X500_NAME_STR,
                    NULL,
                    0
                    );
    if (SubjectLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    IssuerLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Issuer,
                    CERT_X500_NAME_STR,
                    NULL,
                    0
                    );
    if (IssuerLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }


    //
    // Remove the null terminator from one name, but leave space for a
    // ":" in the middle
    //

    Name->Buffer = (LPWSTR) KerbAllocate((SubjectLength + IssuerLength) * sizeof(WCHAR));
    if (Name->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now get the name itself
    //

    SubjectLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Subject,
                    CERT_X500_NAME_STR,
                    Name->Buffer,
                    SubjectLength
                    );
    if (SubjectLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        KerbFree(Name->Buffer);
        Name->Buffer = NULL;
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    //
    // Put an "@" in the middle so it is recognized by MSV as a UPN (just in case)
    //

    Name->Buffer[SubjectLength-1] = L'@';


    IssuerLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Issuer,
                    CERT_X500_NAME_STR,
                    Name->Buffer + SubjectLength,
                    IssuerLength
                    );
    if (IssuerLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        KerbFree(Name->Buffer);
        Name->Buffer = NULL;
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        Name,
        Name->Buffer
        );

Cleanup:
    return(Status);

}

NTSTATUS
KerbGetCertificateHash(
    OUT LPBYTE pCertHash,
    IN ULONG cbCertHash,
    IN PCCERT_CONTEXT pCertContext
    )
{
    ULONG cbHash = cbCertHash;

    if ( CertGetCertificateContextProperty(
             pCertContext,
             CERT_SHA1_HASH_PROP_ID,
             pCertHash,
             &cbHash
             ) == FALSE )
    {
        return( STATUS_PKINIT_FAILURE );
    }

    return( STATUS_SUCCESS );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupSmartCardCachedLogon
//
//  Synopsis:   Looks up a cached smart card logon in the MSV cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Free ValidationInfor with LocalFree
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbLookupSmartCardCachedLogon(
    IN PCCERT_CONTEXT Certificate,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ValidationInfo,
    OUT PKERB_MESSAGE_BUFFER SupplementalCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING IssuerName = {0};
    PMSV1_0_CACHE_LOOKUP_REQUEST CacheRequest = NULL;
    PMSV1_0_CACHE_LOOKUP_RESPONSE CacheResponse = NULL;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG OutputBufferSize = 0;
    ULONG RequestSize = 0;
    BOOLEAN Result = FALSE;

    SupplementalCreds->BufferSize = 0;
    SupplementalCreds->Buffer = NULL;

    RequestSize = sizeof( MSV1_0_CACHE_LOOKUP_REQUEST ) +
                    SHA1DIGESTLEN -
                    sizeof( UCHAR );

    CacheRequest = (PMSV1_0_CACHE_LOOKUP_REQUEST) KerbAllocate( RequestSize );

    if ( CacheRequest == NULL )
    {
        return( FALSE );
    }

    *ValidationInfo = NULL;

    //
    // Get the issuer & subject name from the cert. These will be used as
    // user name & domain name for the lookup
    //


    Status = KerbGetCertificateName(
                &IssuerName,
                Certificate->pCertInfo
                );

    if (NT_SUCCESS(Status))
    {
        Status = KerbGetCertificateHash(
                     CacheRequest->CredentialSubmitBuffer,
                     SHA1DIGESTLEN,
                     Certificate
                     );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CacheRequest->MessageType = MsV1_0CacheLookup;
    CacheRequest->UserName = IssuerName;
    CacheRequest->CredentialType = MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW;
    CacheRequest->CredentialInfoLength = SHA1DIGESTLEN;

    //
    // Leave the domain name portion blank.
    //

    //
    // Call MSV1_0 to do the work
    //
    Status = LsaFunctions->CallPackage(
                    &MsvPackageName,
                    CacheRequest,
                    RequestSize,
                    (PVOID *) &CacheResponse,
                    &OutputBufferSize,
                    &SubStatus
                    );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        DebugLog((DEB_ERROR,"Failed to lookup cache credentials: 0x%x, 0x%x. %ws, line %d\n",Status, SubStatus, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    if (OutputBufferSize < sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE))
    {
        DebugLog((DEB_ERROR,"Invalid response from cache lookup - return too small: %d bytes. %ws, line %d\n",
            OutputBufferSize, THIS_FILE, __LINE__ ));
        //
        // Free it here so we don't do too much freeing in the cleanup portion
        //

        //
        // BUG 455634: Do we need to free the internals as well (we do in cleanup)?
        //
        LsaFunctions->FreeReturnBuffer(CacheResponse);
        CacheResponse = NULL;
        goto Cleanup;
    }
    if (CacheResponse->MessageType != MsV1_0CacheLookup)
    {
        DebugLog((DEB_ERROR,"Wrong message type from cache lookup: %d. %ws, line %d\n",
            CacheResponse->MessageType, THIS_FILE, __LINE__ ));
        //
        // Free it here so we don't do too much freeing in the cleanup portion
        //

        //
        // BUG 455634: Do we need to free the internals as well (we do in cleanup)?
        //
        LsaFunctions->FreeReturnBuffer(CacheResponse);
        CacheResponse = NULL;
        goto Cleanup;
    }

    *ValidationInfo = (PNETLOGON_VALIDATION_SAM_INFO4) CacheResponse->ValidationInformation;
    CacheResponse->ValidationInformation = NULL;

    SupplementalCreds->Buffer = (PBYTE) CacheResponse->SupplementalCacheData;
    SupplementalCreds->BufferSize = CacheResponse->SupplementalCacheDataLength;
    CacheResponse->SupplementalCacheData = NULL;
    Result = TRUE;

Cleanup:
    if (CacheRequest != NULL)
    {
        KerbFree(CacheRequest);
    }

    if (CacheResponse != NULL)
    {

        //
        // At this point we know it was a valid cache response, so we can
        // free the validation info if it is present.
        //

        //
        // BUG 455634: Why do we use LocalFree for the internal stuff?
        //
        if (CacheResponse->ValidationInformation != NULL)
        {
            LocalFree(CacheResponse->ValidationInformation);
        }
        if (CacheResponse->SupplementalCacheData != NULL)
        {
            LocalFree(CacheResponse->SupplementalCacheData);
        }

        LsaFunctions->FreeReturnBuffer(CacheResponse);
    }
    KerbFreeString(&IssuerName);

    return(Result);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDoLocalSmartCardLogon
//
//  Synopsis:   Performs a local logon with the smart card by validating the
//              card and PIN & then trying to map the name locally
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDoLocalSmartCardLogon(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    IN  OUT PNETLOGON_VALIDATION_SAM_INFO4 * Validation4
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
#ifndef WIN32_CHICAGO
    PPACTYPE Pac = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 MsvValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 PacValidationInfo = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    KERB_MESSAGE_BUFFER SupplementalCreds = {0};
#endif // !WIN32_CHICAGO
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_PUBLIC_KEY_CREDENTIALS PkCreds;
    PBYTE DecryptedCreds = NULL;
    ULONG DecryptedCredSize = 0;


    *Validation4 = NULL;

    PkCreds = LogonSession->PrimaryCredentials.PublicKeyCreds;

    //
    // First, verify the card. This will verify the certificate as well
    // as verify the PIN & that the ceritifcate matches the private key on
    // the card.
    //

    if ((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status = KerbInitializePkCreds(
                    PkCreds
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    //
    // Now build a PAC for the user
    //

    if (!KERB_SUCCESS(KerbConvertStringToKdcName(
            &ClientName,
            &LogonSession->PrimaryCredentials.UserName
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    //
    // First check for a cached logon entry
    //

    if (KerbLookupSmartCardCachedLogon(
            PkCreds->CertContext,
            &MsvValidationInfo,
            &SupplementalCreds))
    {
        ValidationInfo = (PNETLOGON_VALIDATION_SAM_INFO3) MsvValidationInfo;
        ValidationInfo->UserFlags |= LOGON_CACHED_ACCOUNT;

        //
        // Strip the domain postfix
        //

        if (ValidationInfo->LogonDomainName.Length >= KERB_SCLOGON_DOMAIN_SUFFIX_SIZE)
        {
            ValidationInfo->LogonDomainName.Length -= KERB_SCLOGON_DOMAIN_SUFFIX_SIZE;
        }

        if ((SupplementalCreds.Buffer != NULL) &&
            (SupplementalCreds.BufferSize != 0))
        {
            DecryptedCredSize = SupplementalCreds.BufferSize;
            DecryptedCreds = (PBYTE) MIDL_user_allocate(DecryptedCredSize);
            if (DecryptedCreds == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
    }
    else
    {
        //
        // Look for a name mapping
        //

        Status = KerbCreatePacForKerbClient(
                    &Pac,
                    ClientName,
                    &LogonSession->PrimaryCredentials.DomainName,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Find the SAM validation info
        //

        LogonInfo = PAC_Find(
                        Pac,
                        PAC_LOGON_INFO,
                        NULL
                        );
        if (LogonInfo == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Now unmarshall the validation info
        //


        Status = PAC_UnmarshallValidationInfo(
                    &PacValidationInfo,
                    LogonInfo->Data,
                    LogonInfo->cbBufferSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        ValidationInfo = PacValidationInfo;
    }


    Status = __ScHelperVerifyCardAndCreds(
                &PkCreds->Pin,
                PkCreds->CertContext,
                PkCreds->CspData,
                SupplementalCreds.Buffer,
                SupplementalCreds.BufferSize,
                DecryptedCreds,
                &DecryptedCredSize
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to verify card: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // If we have any encrypted credentials, decode them here for return.
    //

    if (DecryptedCredSize != 0)
    {
        Status = PAC_UnmarshallCredentials(
                    CachedCredentials,
                    DecryptedCreds,
                    DecryptedCredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Check to see if this is a non-user account. If so, don't allow the logon
    //

    if ((ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] & USER_MACHINE_ACCOUNT_MASK) != 0)
    {
        DebugLog((DEB_ERROR,"Logons to non-user accounts not allowed. UserAccountControl = 0x%x\n",
            ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] ));
        Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        goto Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
    // information
    //

    Status = KerbMakeTokenInformationV2(
                ValidationInfo,
                FALSE,                  // not local system
                &TokenInformation
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v2: 0x%x\n",
            Status));
        goto Cleanup;
    }


    //
    // Allocate the client profile
    //

    Status = KerbAllocateInteractiveProfile(
                (PKERB_INTERACTIVE_PROFILE *) ProfileBuffer,
                ProfileBufferLength,
                ValidationInfo,
                LogonSession,
                NULL,
                NULL
                );
    if (!KERB_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Build the primary credential. We let someone else fill in the
    // password.
    //

    PrimaryCredentials->LogonId = LogonSession->LogonId;
    Status = KerbDuplicateString(
                &PrimaryCredentials->DownlevelName,
                &ValidationInfo->EffectiveName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                &ValidationInfo->LogonDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateSid(
                &PrimaryCredentials->UserSid,
                TokenInformation->User.User.Sid
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    PrimaryCredentials->Flags = 0;
    
    *Validation4 = MsvValidationInfo;
    MsvValidationInfo = NULL;

    *NewTokenInformation = TokenInformation;
    *TokenInformationType = LsaTokenInformationV2;

#endif // !WIN32_CHICAGO

Cleanup:

    if (PacValidationInfo != NULL)
    {
        MIDL_user_free(PacValidationInfo);
    }
    KerbFreeKdcName(
        &ClientName
        );


    if (MsvValidationInfo != NULL)
    {   
        LocalFree(MsvValidationInfo);
    }


    if (SupplementalCreds.Buffer != NULL)
    {
        //
        // BUG 455634: this should be freed a better way
        //

        LocalFree(SupplementalCreds.Buffer);
    }
#ifndef WIN32_CHICAGO

    if (Pac != NULL)
    {
        MIDL_user_free(Pac);
    }
    if (!NT_SUCCESS(Status))
    {
        if (TokenInformation != NULL)
        {
            KerbFree( TokenInformation );
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
    }
#endif // WIN32_CHICAGO

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheSmartCardLogon
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbCacheSmartCardLogon(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING UPN,
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY CachedCredentials
    )
{
    NTSTATUS Status;
    UNICODE_STRING IssuerName = {0};
    UNICODE_STRING DomainName = {0};
    UNICODE_STRING TempLogonDomainName = {0};
    UNICODE_STRING LogonDomainName = {0};
    BYTE CertificateHash[ SHA1DIGESTLEN ];
    UNICODE_STRING CertificateHashString;
    ULONG EncodedCredSize = 0;
    PBYTE EncodedCreds = NULL;
    ULONG EncryptedCredSize = 0;
    PBYTE EncryptedCreds = NULL;
    BOOLEAN LogonSessionLocked = FALSE;
    BOOLEAN InitializedPkCreds = FALSE;

    //
    // Build the temporary logon domain name that indicates this is a
    // smart card logon.
    //


    TempLogonDomainName.MaximumLength =
        TempLogonDomainName.Length =
            ValidationInfo->LogonDomainName.Length + KERB_SCLOGON_DOMAIN_SUFFIX_SIZE;

    TempLogonDomainName.Buffer = (LPWSTR) MIDL_user_allocate(TempLogonDomainName.Length);
    if (TempLogonDomainName.Buffer == NULL)
    {
        goto Cleanup;
    }

    //
    // Create the new name
    //

    RtlCopyMemory(
        TempLogonDomainName.Buffer,
        ValidationInfo->LogonDomainName.Buffer,
        ValidationInfo->LogonDomainName.Length
        );

    RtlCopyMemory(
        ((PUCHAR) TempLogonDomainName.Buffer) + ValidationInfo->LogonDomainName.Length,
        KERB_SCLOGON_DOMAIN_SUFFIX,
        KERB_SCLOGON_DOMAIN_SUFFIX_SIZE
        );

    LogonDomainName = ValidationInfo->LogonDomainName;
    ValidationInfo->LogonDomainName = TempLogonDomainName;


    //
    // Get the name under which to store this.
    //

    KerbReadLockLogonSessions(LogonSession);

    LogonSessionLocked = TRUE;

    Status = KerbGetCertificateName(
                &IssuerName,
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pCertInfo
                );

    if ( Status == STATUS_SUCCESS )
    {
        Status = KerbGetCertificateHash(
                     CertificateHash,
                     SHA1DIGESTLEN,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext
                     );
    }


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CertificateHashString.Length = SHA1DIGESTLEN;
    CertificateHashString.Buffer = (LPWSTR)CertificateHash;
    CertificateHashString.MaximumLength = SHA1DIGESTLEN;



    if (ARGUMENT_PRESENT(CachedCredentials))
    {
        ScHelper_RandomCredBits RandomBits;

        Status = PAC_EncodeCredentialData(
                    CachedCredentials,
                    &EncodedCreds,
                    &EncodedCredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        if ((LogonSession->PrimaryCredentials.PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
        {
            Status  = KerbInitializePkCreds(
                            LogonSession->PrimaryCredentials.PublicKeyCreds
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            InitializedPkCreds = TRUE;

        }


        Status = __ScHelperGenRandBits(
                    LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                    &RandomBits
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to generate random bits: 0x%x\n",Status));
            goto Cleanup;
        }

        Status = __ScHelperEncryptCredentials(
                     &LogonSession->PrimaryCredentials.PublicKeyCreds->Pin,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext,
                     &RandomBits,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                     EncodedCreds,
                     EncodedCredSize,
                     NULL,
                     &EncryptedCredSize
                     );
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt creds: 0x%x\n",Status));
            goto Cleanup;
        }

        EncryptedCreds = (PBYTE) KerbAllocate(EncryptedCredSize);
        if (EncryptedCreds == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Do the real encryption
        //

        Status = __ScHelperEncryptCredentials(
                     &LogonSession->PrimaryCredentials.PublicKeyCreds->Pin,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext,
                     &RandomBits,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                     EncodedCreds,
                     EncodedCredSize,
                     EncryptedCreds,
                     &EncryptedCredSize
                     );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to encrypt creds: 0x%x\n",Status));
            goto Cleanup;
        }
    }
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    KerbCacheLogonInformation(
        &IssuerName,            // used as username
        &DomainName,            // blank - no domain
        &CertificateHashString, // password is certificate hash,
        DnsDomainName,
        NULL, //UPN,
        FALSE,
        0,                      // no flags
        ValidationInfo,
        EncryptedCreds,
        EncryptedCredSize
        );

Cleanup:

    if (InitializedPkCreds)
    {
        KerbFreePKCreds(
            LogonSession->PrimaryCredentials.PublicKeyCreds
            );


    }

    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }
    KerbFreeString(&IssuerName);
    KerbFreeString(&TempLogonDomainName);

    //
    // Restore the original logon domain name
    //

    if (LogonDomainName.Buffer != NULL)
    {
        ValidationInfo->LogonDomainName = LogonDomainName;
    }
    if (EncodedCreds != NULL)
    {
        MIDL_user_free(EncodedCreds);
    }


}



//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializePkinit
//
//  Synopsis:   Inializes structures needed for PKINIT
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitializePkinit(
    VOID
    )
{
    ULONG Index;
    LPSTR StringCopy = NULL, TempString = NULL,EndPtr = NULL;

    //
    // Initialize the object IDs
    //

    Index = 0;

    StringCopy = (LPSTR) KerbAllocate((ULONG) strlen(KERB_PKINIT_SIGNATURE_OID)+1);
    if (StringCopy == NULL)
    {
        return( STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Scan the string for every '.' separated number
    //

    strcpy(
        StringCopy,
        KERB_PKINIT_SIGNATURE_OID
        );

    TempString = StringCopy;
    EndPtr = TempString;

    while (TempString != NULL)
    {
        ULONG Temp;

        while (*EndPtr != '\0' && *EndPtr != '.')
        {
            EndPtr++;
        }
        if (*EndPtr == '.')
        {
            *EndPtr = '\0';
            EndPtr++;
        }
        else
        {
            EndPtr = NULL;
        }

        if (0 == sscanf(TempString,"%u",&Temp))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbSignatureAlg[Index].value = (USHORT) Temp;
        KerbSignatureAlg[Index].next = &KerbSignatureAlg[Index+1];
        Index++;


        TempString = EndPtr;


    }
    DsysAssert(Index != 0);
    KerbSignatureAlg[Index-1].next = NULL;
    KerbFree(StringCopy);
    TempString = NULL;



    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\rpcutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcutil.h
//
// Contents:    prototypes and structures for RPC utilities
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCUTIL_H__
#define __RPCUTIL_H__

#define KERB_LOCATOR_FLAGS (DS_KDC_REQUIRED | DS_IP_REQUIRED)
NTSTATUS
KerbGetKdcBinding(
    IN PUNICODE_STRING Realm,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG DesiredFlags,
    IN BOOLEAN FindKpasswd,
    IN BOOLEAN UseTcp,
    OUT PKERB_BINDING_CACHE_ENTRY * BindingCacheEntry
    );

BOOLEAN
ReadInitialDcRecord(PUNICODE_STRING uString,
                    PULONG RegAddressType,
                    PULONG RegFlags);


#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitKdcData();

VOID
KerbFreeKdcData();

NTSTATUS
KerbInitNetworkChangeEvent();

VOID
KerbSetKdcData(BOOLEAN fNewDomain, BOOLEAN fRebooted);

#endif // WIN32_CHICAGO

#endif // __RPCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\proxyapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        proxyapi.cxx
//
// Contents:    Code for Proxy support in Kerberos
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>


NTSTATUS NTAPI
SpGrantProxy(
    IN ULONG CredentialHandle,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    IN PROXY_CLASS ProxyClass,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ACCESS_MASK ContainerMask,
    IN ACCESS_MASK ObjectMask,
    IN PTimeStamp ExpirationTime,
    IN PSecBuffer AccessInformation,
    OUT PPROXY_REFERENCE ProxyReference
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpRevokeProxy(
    IN ULONG CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpInvokeProxy(
    IN ULONG CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    OUT PULONG ContextHandle,
    OUT PLUID LogonId,
    OUT PULONG CachedCredentialCount,
    OUT PSECPKG_SUPPLEMENTAL_CRED * CachedCredentials,
    OUT PSecBuffer ContextData
    )
{
    return(STATUS_NOT_SUPPORTED);
}


NTSTATUS NTAPI
SpRenewProxy(
    IN ULONG CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    IN PTimeStamp ExpirationTime
    )
{
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\sidcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        sidcache.cxx
//
// Contents:    routines to cache username->sid translations to speed up
//              logon performance
//
//
// History:     27-May-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>


#define KERB_LOGON_SID_CACHE_KEY L"SidCache"
#define KERB_LOGON_SID_CACHE_ENTRIES L"CacheEntries"
#define KERB_LOGON_SID_CACHE_ENTRY_NAME L"Entry%d"
#define KERB_MACHINE_SID_CACHE_NAME L"MachineSid"
#define KERB_LOGON_SID_CACHE_MAX_ENTRIES 1000
#define KERB_LOGON_SID_CACHE_DEFAULT_ENTRIES 10
#define KERB_LOGON_SID_CACHE_ENTRY_NAME_SIZE (sizeof(L"Entry") * 4*sizeof(WCHAR))
#define KERB_LOGON_SID_CACHE_VERSION 0


KERBEROS_LIST KerbSidCache;
HKEY KerbSidCacheKey;
ULONG KerbSidCacheMaxEntries = KERB_LOGON_SID_CACHE_DEFAULT_ENTRIES;
ULONG KerbSidCacheEntries;



#define VALIDATE_POINTER(Ptr,Size,Base,Bound,NewBase,Type) \
    if (((PUCHAR)(Ptr) < (PUCHAR)(Base)) || (((PUCHAR)(Ptr) + (Size)) > (PUCHAR)(Bound))) \
    { \
        Status = STATUS_INVALID_PARAMETER; \
        goto Cleanup; \
    } \
    else \
    { \
        (Ptr) = (Type) ((PUCHAR) (Ptr) - (ULONG_PTR) Base + (ULONG_PTR) NewBase); \
    } \



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyUnpackAndLinkSidCacheEntry
//
//  Synopsis:   Unmarshalls the entry & verifies that the pointers all
//              match up within the buffer. If this is the case, it
//              inserts the entry into the list & zeroes out the pointer
//              so the caller won't free it.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbVerifyUnpackAndLinkSidCacheEntry(
    IN PKERB_SID_CACHE_ENTRY * SidCacheEntry,
    IN ULONG CacheEntrySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_SID_CACHE_ENTRY CacheEntry = *SidCacheEntry;
    PUCHAR Bound;

    //
    // First check the base structure size
    //

    if (CacheEntrySize < sizeof(KERB_SID_CACHE_ENTRY))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Now check the version
    //

    if (CacheEntry->Version != KERB_LOGON_SID_CACHE_VERSION)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (CacheEntry->Size != CacheEntrySize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    //
    // Now check all the pointers
    //

    Bound = (PUCHAR) CacheEntry->Base + CacheEntrySize;

    VALIDATE_POINTER(
        CacheEntry->Sid,
        RtlLengthRequiredSid(5),                // space for 5 sub authorities
        CacheEntry->Base,
        Bound,
        CacheEntry,
        PSID
        );

    VALIDATE_POINTER(
        CacheEntry->LogonUserName.Buffer,
        CacheEntry->LogonUserName.MaximumLength,
        CacheEntry->Base,
        Bound,
        CacheEntry,
        PWSTR
        );

    VALIDATE_POINTER(
        CacheEntry->LogonDomainName.Buffer,
        CacheEntry->LogonDomainName.MaximumLength,
        CacheEntry->Base,
        Bound,
        CacheEntry,
        PWSTR
        );

    VALIDATE_POINTER(
        CacheEntry->LogonRealm.Buffer,
        CacheEntry->LogonRealm.MaximumLength,
        CacheEntry->Base,
        Bound,
        CacheEntry,
        PWSTR
        );

    KerbInitializeListEntry(
        &CacheEntry->Next
        );

    //
    // This inserts at the head, not the tail
    //

    KerbInsertListEntryTail(
        &CacheEntry->Next,
        &KerbSidCache
        );

    *SidCacheEntry = NULL;

Cleanup:

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeLogonSidCache
//
//  Synopsis:   Initializes the list of cached logon sids
//
//  Effects:    Reads data from the registry
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitializeLogonSidCache(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD RegErr = ERROR_SUCCESS;
    DWORD Disposition = 0;
    PKERB_SID_CACHE_ENTRY NextEntry = NULL;
    ULONG NextEntrySize = 0;
    ULONG ValueType;
    ULONG Index;
    HKEY KerbParamKey = NULL;
    WCHAR EntryName[KERB_LOGON_SID_CACHE_ENTRY_NAME_SIZE];

    //
    // Initialize the list
    //

    Status = KerbInitializeList(&KerbSidCache);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Create the sid cache key
    //

    RegErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                KERB_PARAMETER_PATH,
                0,
                NULL,
                0,
                KEY_ALL_ACCESS,
                0,
                &KerbParamKey,
                &Disposition
                );
    if (RegErr != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to create %ws key: %d\n",KERB_PARAMETER_PATH, RegErr));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    RegErr = RegCreateKeyEx(
                KerbParamKey,
                KERB_LOGON_SID_CACHE_KEY,
                0,                              // reserved
                NULL,                           // no class
                0,                              // no options
                KEY_ALL_ACCESS,
                NULL,                           // no security attributes
                &KerbSidCacheKey,
                &Disposition
                );
    if (RegErr != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to create key %ws: %d\n",KERB_LOGON_SID_CACHE_KEY, RegErr));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Read out the size of the cache
    //

    NextEntrySize = sizeof(ULONG);

    RegErr = RegQueryValueEx(
                KerbSidCacheKey,
                KERB_LOGON_SID_CACHE_ENTRIES,
                NULL,                           // reserved,
                &ValueType,
                (PUCHAR) &KerbSidCacheMaxEntries,
                &NextEntrySize
                );
    if (RegErr == ERROR_SUCCESS)
    {
        //
        // Make sure the value is within the range & is of the correc type
        //

        if ( (ValueType != REG_DWORD) ||
             (KerbSidCacheMaxEntries > KERB_LOGON_SID_CACHE_MAX_ENTRIES) ||
             (KerbSidCacheMaxEntries == 0) )

        {
            KerbSidCacheMaxEntries = KERB_LOGON_SID_CACHE_DEFAULT_ENTRIES;
        }
    }

    //
    // Now read in all the entries. Loop through up to the max number of
    // entries, reading the entry, and inserting at the tail of the list.
    //

    for (Index = 0; Index < KerbSidCacheMaxEntries ; Index++ )
    {
        swprintf(EntryName,KERB_LOGON_SID_CACHE_ENTRY_NAME, Index);

        //
        // Query the size of the entry
        //

        NextEntrySize = NULL;
        RegErr = RegQueryValueEx(
                    KerbSidCacheKey,
                    EntryName,
                    NULL,
                    &ValueType,
                    (PUCHAR) NextEntry,
                    &NextEntrySize
                    );
        if ((RegErr == ERROR_SUCCESS) && (ValueType == REG_BINARY))
        {
            //
            // Allocate space for the entry and re-query to get the real
            // value.
            //

            NextEntry = (PKERB_SID_CACHE_ENTRY) KerbAllocate(NextEntrySize);
            if (NextEntry == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RegErr = RegQueryValueEx(
                        KerbSidCacheKey,
                        EntryName,
                        NULL,
                        &ValueType,
                        (PUCHAR) NextEntry,
                        &NextEntrySize
                        );
            if (RegErr != ERROR_SUCCESS)
            {
                DebugLog((DEB_ERROR,"Failed to query for sid cache value: %d\n",
                    RegErr ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

            //
            // Call a helper routine to unpack,verify, and insert

            Status = KerbVerifyUnpackAndLinkSidCacheEntry(
                        &NextEntry,
                        NextEntrySize
                        );
            //
            // If the entry was invalid, remove it now
            //
            if (!NT_SUCCESS(Status))
            {
                (VOID) RegDeleteValue(
                            KerbSidCacheKey,
                            EntryName
                            );
                Status = STATUS_SUCCESS;
            }

            if (NextEntry != NULL)
            {
                KerbFree(NextEntry);
                NextEntry = NULL;
            }
            NextEntrySize = 0;



        }
    }

Cleanup:
    if (KerbParamKey != NULL)
    {
        RegCloseKey(KerbParamKey);
    }
    if (NextEntry != NULL)
    {
        KerbFree(NextEntry);
    }
    if (!NT_SUCCESS(Status))
    {
        if (KerbSidCacheKey != NULL)
        {
            RegCloseKey(KerbSidCacheKey);
            KerbSidCacheKey = NULL;
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbScavengeSidCache
//
//  Synopsis:   removes any stale entries from the sid cache to make it fit
//              within bounds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbScavengeSidCache(
    VOID
    )
{
    PKERB_SID_CACHE_ENTRY CacheEntry;
    while (KerbSidCacheEntries > KerbSidCacheMaxEntries)
    {
        //
        // Pickup the last entry and remove it
        //

        CacheEntry = CONTAINING_RECORD(KerbSidCache.List.Blink, KERB_SID_CACHE_ENTRY, Next.Next);

        KerbReferenceListEntry(
            &KerbSidCache,
            &CacheEntry->Next,
            TRUE
            );
        KerbDereferenceSidCacheEntry(
            CacheEntry
            );
        KerbSidCacheEntries--;

    }

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbWriteSidCache
//
//  Synopsis:   Writes the sid cache back to the registry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS
KerbWriteSidCache(
    VOID
    )
{
    ULONG Index = 0;
    WCHAR EntryName[KERB_LOGON_SID_CACHE_ENTRY_NAME_SIZE];
    PLIST_ENTRY ListEntry;
    PKERB_SID_CACHE_ENTRY CacheEntry;

    for (ListEntry = KerbSidCache.List.Flink ;
         ListEntry !=  &KerbSidCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SID_CACHE_ENTRY, Next.Next);
        swprintf(EntryName,KERB_LOGON_SID_CACHE_ENTRY_NAME, Index++);

        (VOID) RegSetValueEx(
                    KerbSidCacheKey,
                    EntryName,
                    0,                  // reserved
                    REG_BINARY,
                    (PUCHAR) CacheEntry,
                    CacheEntry->Size
                    );
    }

    return(STATUS_SUCCESS);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPromoteSidCacheEntry
//
//  Synopsis:   Moves a cache entry to the front of the list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbPromoteSidCacheEntry(
    IN PKERB_SID_CACHE_ENTRY CacheEntry
    )
{
    KerbLockList(&KerbSidCache);
    RemoveEntryList(&CacheEntry->Next.Next);
    InsertHeadList(&KerbSidCache.List, &CacheEntry->Next.Next);
    KerbUnlockList(&KerbSidCache);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateLogonSidCacheEntry
//
//  Synopsis:   Locates a logon sid cache entry by user name and domain name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    returns a referenced cache entry, if available
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_SID_CACHE_ENTRY
KerbLocateLogonSidCacheEntry(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName
    )
{
    PKERB_SID_CACHE_ENTRY CacheEntry = NULL;
    PLIST_ENTRY ListEntry;

    if (!KerbGlobalUseSidCache)
    {
        return(NULL);
    }
    KerbLockList(&KerbSidCache);

    for (ListEntry = KerbSidCache.List.Flink ;
         ListEntry !=  &KerbSidCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SID_CACHE_ENTRY, Next.Next);

        if (RtlEqualUnicodeString(
                &CacheEntry->LogonUserName,
                LogonUserName,
                TRUE
                ) &&
            RtlEqualUnicodeString(
                &CacheEntry->LogonDomainName,
                LogonDomainName,
                TRUE
                ) )
        {
            //
            // We found it
            //

            KerbReferenceListEntry(
                &KerbSidCache,
                &CacheEntry->Next,
                FALSE                   // don't remove
                );

            break;
        }
        CacheEntry = NULL;
    }


    KerbUnlockList(&KerbSidCache);
    return(CacheEntry);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceSidCacheEntry
//
//  Synopsis:   Dereferences the entry, possibly freeing it
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceSidCacheEntry(
    IN PKERB_SID_CACHE_ENTRY CacheEntry
    )
{
    KerbLockList(&KerbSidCache);
    if (KerbDereferenceListEntry(
            &CacheEntry->Next,
            &KerbSidCache
            ))
    {
        KerbFree(CacheEntry);
    }
    KerbUnlockList(&KerbSidCache);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheLogonSid
//
//  Synopsis:   Caches a username/domainname & Sid combination for logon
//
//  Effects:    caches the user name/domainname/sid in the registry
//
//  Arguments:  LogonUserName - user name supplied to LogonUser
//              LogonDomainName - domain name supplied to LogonUser
//              LogonRealm - Realm actually containing the account
//              UserSid - Sid of user who just logged on
//
//  Requires:
//
//  Returns:    none - this is just a cache
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCacheLogonSid(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING LogonRealm,
    IN PSID UserSid
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_SID_CACHE_ENTRY CacheEntry;
    ULONG CacheEntrySize = 0;
    PUCHAR Where;

    if (!KerbGlobalUseSidCache)
    {
        return;
    }

    CacheEntry = KerbLocateLogonSidCacheEntry(
                        LogonUserName,
                        LogonDomainName
                        );

    //
    // If we found the entry & it is the same as this one, move it up in
    // the list
    //


    if (CacheEntry != NULL)
    {
        if (RtlEqualUnicodeString(
                &CacheEntry->LogonRealm,
                LogonRealm,
                TRUE
                ) &&
            RtlEqualSid(
                CacheEntry->Sid,
                UserSid
                ) )

        {
            KerbPromoteSidCacheEntry(
                CacheEntry
                );
            goto Cleanup;
        }
        else
        {
            //
            // Remove it from the list
            //

            KerbLockList(&KerbSidCache);
            KerbReferenceListEntry(
                &KerbSidCache,
                &CacheEntry->Next,
                TRUE                        // remove
                );

            KerbDereferenceSidCacheEntry(
                CacheEntry
                );
            KerbDereferenceSidCacheEntry(
                CacheEntry
                );
            KerbUnlockList(&KerbSidCache);
            CacheEntry = NULL;
        }
    }

    //
    // Now build a new entry
    //

    CacheEntrySize = sizeof(KERB_SID_CACHE_ENTRY) +
                    RtlLengthSid(UserSid) +
                    LogonUserName->Length + sizeof(WCHAR) +
                    LogonDomainName->Length + sizeof(WCHAR) +
                    LogonRealm->Length + sizeof(WCHAR);

    CacheEntry = (PKERB_SID_CACHE_ENTRY) KerbAllocate(CacheEntrySize);
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in all the fixed fields.
    //

    KerbInitializeListEntry(
        &CacheEntry->Next
        );
    CacheEntry->Base = (ULONG_PTR) CacheEntry;
    CacheEntry->Version = KERB_LOGON_SID_CACHE_VERSION;
    CacheEntry->Size = CacheEntrySize;
    Where = (PUCHAR) (CacheEntry + 1);

    //
    // Copy in the sid
    //
    CacheEntry->Sid = (PSID) Where;
    Where += RtlLengthSid( UserSid );

    RtlCopyMemory(
        CacheEntry->Sid,
        UserSid,
        Where - (PUCHAR) CacheEntry->Sid
        );

    //
    // Put the various strings
    //

    KerbPutString(
        LogonUserName,
        &CacheEntry->LogonUserName,
        0,                              // no offset
        &Where
        );

    KerbPutString(
        LogonDomainName,
        &CacheEntry->LogonDomainName,
        0,                              // no offset
        &Where
        );

    KerbPutString(
        LogonRealm,
        &CacheEntry->LogonRealm,
        0,                              // no offset
        &Where
        );

    //
    // Insert it into the list
    //

    KerbLockList( &KerbSidCache );
    KerbInsertListEntry(
        &CacheEntry->Next,
        &KerbSidCache
        );
    //
    // Dereference it because we aren't returning the cache entry
    //

    KerbDereferenceListEntry(
        &CacheEntry->Next,
        &KerbSidCache
        );

    KerbSidCacheEntries++;

    //
    // Remove any extra entries
    //

    KerbScavengeSidCache();

    KerbUnlockList ( &KerbSidCache );

Cleanup:
    if (NT_SUCCESS(Status))
    {
        KerbWriteSidCache();
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbWriteMachineSid
//
//  Synopsis:   Writes the machine account sid to the registry
//
//  Effects:
//
//  Arguments:  MachineSid - If present, is stored. If not present,
//                  is deleted from registry
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbWriteMachineSid(
    IN OPTIONAL PSID MachineSid
    )
{
    if (ARGUMENT_PRESENT(MachineSid))
    {
        (VOID) RegSetValueEx(
                    KerbSidCacheKey,
                    KERB_MACHINE_SID_CACHE_NAME,
                    0,                  // reserved
                    REG_BINARY,
                    (PUCHAR) MachineSid,
                    RtlLengthSid(MachineSid)
                    );
    }
    else
    {
        (VOID) RegDeleteValue(
                    KerbSidCacheKey,
                    KERB_MACHINE_SID_CACHE_NAME
                    );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   Reads the machine sid from the registry
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetMachineSid(
    OUT PSID * MachineSid
    )
{
    BYTE Buffer[sizeof(SID) + SID_MAX_SUB_AUTHORITIES * sizeof(ULONG)];
    ULONG BufferSize = sizeof(Buffer);
    PSID Sid = (PSID) Buffer;
    DWORD RegErr;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ValueType;

    *MachineSid = NULL;
    RegErr = RegQueryValueEx(
                KerbSidCacheKey,
                KERB_MACHINE_SID_CACHE_NAME,
                NULL,
                &ValueType,
                Buffer,
                &BufferSize
                );
    if (RegErr != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to query for machine sid value: %d\n",
            RegErr ));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

    //
    // If it isn't valid, delete it now
    //

    if (!RtlValidSid(Sid))
    {
        (VOID) RegDeleteValue(
                    KerbSidCacheKey,
                    KERB_MACHINE_SID_CACHE_NAME
                    );
    }

    *MachineSid = (PSID) KerbAllocate(RtlLengthSid(Buffer));

    if (*MachineSid == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlCopyMemory(
        *MachineSid,
        Sid,
        RtlLengthSid(Sid)
        );

Cleanup:
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\sidcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        sidcache.h
//
// Contents:    public types & functions used for logon sid caching
//
//
// History:     27-May-1998     MikeSw          Created
//
//------------------------------------------------------------------------


#ifndef __SIDCACHE_H__
#define __SIDCACHE_H__


//
// This structure is marshalled
//

typedef struct _KERB_SID_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY Next;
    ULONG_PTR Base;
    ULONG Size;
    ULONG Version;
    PSID Sid;
    UNICODE_STRING LogonUserName;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING LogonRealm;
} KERB_SID_CACHE_ENTRY, *PKERB_SID_CACHE_ENTRY;

#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitializeLogonSidCache(
    VOID
    );

PKERB_SID_CACHE_ENTRY
KerbLocateLogonSidCacheEntry(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName
    );

VOID
KerbDereferenceSidCacheEntry(
    IN PKERB_SID_CACHE_ENTRY CacheEntry
    );

VOID
KerbCacheLogonSid(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING LogonRealm,
    IN PSID UserSid
    );


VOID
KerbPutString(
    IN PUNICODE_STRING InputString,
    OUT PUNICODE_STRING OutputString,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    );




NTSTATUS
KerbGetMachineSid(
    OUT PSID * MachineSid
    );

VOID
KerbWriteMachineSid(
    IN OPTIONAL PSID MachineSid
    );
#else // WIN32_CHICAGO

//
// define these to do nothing
//

#define KerbInitializeLogonSidCache() STATUS_SUCCESS
#define KerbLocateLogonSidCacheEntry(x,y) NULL
#define KerbDereferenceSidCacheEntry( x)

#endif // WIN32_CHICAGO

#endif // __SIDCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\rpcutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcutil.cxx
//
// Contents:    Utilities for RPC for Kerberos package
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#ifndef WIN32_CHICAGO
#include <netlibnt.h>
#endif // WIN32_CHICAGO
}


SOCKET KerbPNPSocket;
HANDLE KerbPNPSocketEvent = NULL;
HANDLE KerbPNPSocketWaitHandle = NULL;


#ifndef WIN32_CHICAGO
// The problem here is that  we need to read the domain info once after
// joining domain. (for rebootless join) and once after the reboot
// (if there was one). We can only delete the data after a reboot.

// This one controls whether I read the domain info that JoinDomain dumps
// in the registry.
BOOLEAN fNewDataAboutDomain = TRUE;

// This one controls when I should delete the domain info that JoinDomain
// dumps in the registry
BOOLEAN fRebootedSinceJoin = TRUE;

RTL_CRITICAL_SECTION KerbCallKdcDataLock;
BOOLEAN KerbCallKdcDataInitialized = FALSE;

#define KerbLockKdcData() (RtlEnterCriticalSection(&KerbCallKdcDataLock))
#define KerbUnlockKdcData() (RtlLeaveCriticalSection(&KerbCallKdcDataLock))
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitKdcData()
{
    NTSTATUS Status = STATUS_SUCCESS;
    if (!KerbCallKdcDataInitialized)
    {
        Status = RtlInitializeCriticalSection(&KerbCallKdcDataLock);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KerbCallKdcDataInitialized = TRUE;
    }
Cleanup:
    return Status;
}

VOID
KerbFreeKdcData()
{
    if (KerbCallKdcDataInitialized)
    {
        RtlDeleteCriticalSection(&KerbCallKdcDataLock);
        KerbCallKdcDataInitialized = FALSE;
    }
}

VOID
KerbSetKdcData(BOOLEAN fNewDomain, BOOLEAN fRebooted)
{
    KerbLockKdcData();

    fNewDataAboutDomain = fNewDomain;
    fRebootedSinceJoin  = fRebooted;

    KerbUnlockKdcData();
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocation routine for use by RPC client stubs
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  BufferSize - size of buffer, in bytes, to allocate
//
//  Requires:
//
//  Returns:    Buffer pointer or NULL on allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return(KerbAllocate( ROUND_UP_COUNT(BufferSize, 8) ) );
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Memory free routine for RPC client stubs
//
//  Effects:    frees the buffer with LsaFunctions.FreeLsaHeap
//
//  Arguments:  Buffer - Buffer to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    KerbFree( Buffer );
}

#ifndef WIN32_CHICAGO
#define NETSETUPP_NETLOGON_PARAMETERS                                     \
        L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
#define NETSETUPP_NETLOGON_KERB_JD\
        L"KerbIsDoneWithJoinDomainEntry"
#define NETSETUPP_NETLOGON_JD \
        L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\JoinDomain"
#define NETSETUPP_NETLOGON_JD_DCA   L"DomainControllerAddress"
#define NETSETUPP_NETLOGON_JD_DCAT  L"DomainControllerAddressType"
#define NETSETUPP_NETLOGON_JD_F     L"Flags"

BOOLEAN
ReadInitialDcRecord(PUNICODE_STRING uString,
                    PULONG RegAddressType,
                    PULONG RegFlags)
{
    ULONG WinError = ERROR_SUCCESS;
    HKEY hJoinKey = NULL, hParametersKey = NULL;
    ULONG Flags = 0, AddressType = 0, KdcNameSize = 0, dwTRUE = 1, Type =0;
    LPWSTR KdcName = NULL;
    BOOLEAN fReadCache = FALSE;
    ULONG dwsize = sizeof(ULONG);
    USHORT TempLen = 0;

    RtlInitUnicodeString(
            uString,
            NULL
            );

    *RegAddressType = 0;
    *RegFlags = 0;

    WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                            NETSETUPP_NETLOGON_JD,
                            &hJoinKey);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DCA,
                           0,
                           &Type,
                           NULL,
                           &KdcNameSize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    KdcName = (LPWSTR) KerbAllocate(KdcNameSize);

    if (KdcName == NULL)
    {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DCA,
                           0,
                           &Type,
                           (PUCHAR) KdcName,
                           &KdcNameSize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                               NETSETUPP_NETLOGON_JD_DCAT,
                               0,
                               &Type,
                               (PUCHAR)&AddressType,
                               &dwsize );

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                               NETSETUPP_NETLOGON_JD_F,
                               0,
                               &Type,
                               (PUCHAR)&Flags,
                               &dwsize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    TempLen = (USHORT)wcslen(KdcName+2);

    uString->Buffer = (PWSTR) KerbAllocate ((TempLen + 1) *sizeof(WCHAR));

    if (uString->Buffer == NULL)
    {
        goto Cleanup;
    }

    wcscpy(uString->Buffer,
          KdcName+2);

    uString->Length = TempLen * sizeof(WCHAR);
    uString->MaximumLength = uString->Length + sizeof(WCHAR);
    uString->Buffer[TempLen] = L'\0';

    *RegAddressType = AddressType;
    *RegFlags = Flags;

    // Now set the reg entry so that netlogon knows that we've read it.

    if (fRebootedSinceJoin)
    {
        WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                                NETSETUPP_NETLOGON_PARAMETERS,
                                &hParametersKey);

        if ( WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }

        WinError = RegSetValueEx( hParametersKey,
                               NETSETUPP_NETLOGON_KERB_JD,
                               0,
                               REG_DWORD,
                               (PUCHAR)&dwTRUE,
                               sizeof(DWORD));

        if ( WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }

        DebugLog((DEB_ERROR, "Setting DoneWJoin key!\n"));
    }

    fReadCache = TRUE;


Cleanup:

    KerbSetKdcData(FALSE, fRebootedSinceJoin);

    if (hJoinKey)
    {
        RegCloseKey( hJoinKey );
    }

    if (hParametersKey)
    {
        RegCloseKey( hParametersKey );
    }

    if (KdcName)
    {
        KerbFree(KdcName);
    }
    return (fReadCache);
}
#endif // WIN32_CHICAGO






//+-------------------------------------------------------------------------
//
//  Function:   KerbSocketChangeHandler
//
//  Synopsis:   Simply setups up a WSA Pnp event, so that we catch network
//              changes.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbSocketChangeHandler(
              VOID* Context,
              BOOLEAN WaitStatus
              )
{
        
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
    NTSTATUS Status;
    NET_API_STATUS  NetStatus;

    //
    // Determine if TCP is installed.
    //
    protocols[0] = IPPROTO_TCP;                                             
    protocols[1] = NULL;   

    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);           
    
    KerbGlobalWriteLock();
    if (nRet == 0)                                                          
    {                                                                       
        D_DebugLog((DEB_TRACE, "Turning OFF! TCP %x\n", nRet));
        KerbGlobalNoTcpUdp = TRUE;                                             
    }
    else
    { 
        KerbGlobalNoTcpUdp = FALSE;
        if (nRet == SOCKET_ERROR) 
        {
            nRet = WSAGetLastError();
        }

        D_DebugLog((DEB_TRACE, "Turning on TCP %x\n", nRet));
    }  
    KerbGlobalReleaseLock(); 

    //
    // Re-Register the wait - but make sure the values are init'd / correct.
    //
    KerbLockKdcData();

    if ( KerbPNPSocketWaitHandle && KerbPNPSocketEvent )
    {
        NetStatus = WSAEventSelect( 
                    KerbPNPSocket,
                    KerbPNPSocketEvent,
                    FD_ADDRESS_LIST_CHANGE
                    );

        if ( NetStatus != 0 ) 
        {
            NetStatus = WSAGetLastError();
            DebugLog(( DEB_ERROR, "Can't WSAEventSelect %ld\n", NetStatus ));
        }



        Status = RtlRegisterWait(
                        &KerbPNPSocketWaitHandle,
                        KerbPNPSocketEvent,
                        KerbSocketChangeHandler,
                        NULL,
                        INFINITE,
                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                        );
    
        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "RtlRegisterWait failed %x\n", Status));
        }  


        //
        // Issue the IOCTL, so we'll get notified.
        //
        NetStatus = WSAIoctl( 
                        KerbPNPSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL, // No input buffer
                        0,    // No input buffer
                        NULL, // No output buffer
                        0,    // No output buffer
                        &dwBufLen,
                        NULL, // No overlapped,
                        NULL  // Not async
                        );   

        if ( NetStatus != 0 ) 
        {   
            NetStatus = WSAGetLastError();
            if ( NetStatus != WSAEWOULDBLOCK) 
            {
                DebugLog((DEB_ERROR, "WSAIOCTL failed %x\n", NetStatus));
                Status = STATUS_INTERNAL_ERROR;
            }
        } 

    }

    KerbUnlockKdcData();           
    KerbCleanupBindingCache(FALSE);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbInitNetworkChangeEvent
//
//  Synopsis:   Simply setups up a WSA Pnp event, so that we catch network
//              changes.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitNetworkChangeEvent()
{

    NET_API_STATUS  NetStatus;
    NTSTATUS        Status = STATUS_INTERNAL_ERROR;
    DWORD           BytesReturned;

    KerbLockKdcData();

    if ( KerbPNPSocket != NULL )
    {   
        goto Cleanup;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //
    KerbPNPSocket = WSASocket( 
                        AF_INET,
                        SOCK_DGRAM,
                        0, // PF_INET,
                        NULL,
                        0,
                        0 
                        );  

    if ( KerbPNPSocket == INVALID_SOCKET ) 
    {  
        NetStatus = WSAGetLastError();

        DebugLog(( DEB_ERROR, "Can't WSASocket %ld\n", NetStatus ));

        if ( NetStatus == WSAEAFNOSUPPORT ) 
        {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        goto Cleanup;
    }  

    //
    // Open an event to wait on.
    //
    KerbPNPSocketEvent = CreateEvent(
                            NULL,     // No security ettibutes
                            FALSE,    // Auto reset
                            FALSE,    // Initially not signaled
                            NULL
                            );    
    if ( KerbPNPSocketEvent == NULL ) 
    {   
        DebugLog(( DEB_ERROR,"Cannot create Winsock PNP event %ld\n", GetLastError() ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }


    NetStatus = WSAEventSelect( 
                        KerbPNPSocket,
                        KerbPNPSocketEvent,
                        FD_ADDRESS_LIST_CHANGE
                        );

    if ( NetStatus != 0 ) 
    {
        NetStatus = WSAGetLastError();
        DebugLog(( DEB_ERROR, "Can't WSAEventSelect %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Register a wait.
    //
    Status = RtlRegisterWait(
                    &KerbPNPSocketWaitHandle,
                    KerbPNPSocketEvent,
                    KerbSocketChangeHandler,
                    NULL,
                    INFINITE,
                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                    );


    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "RtlRegisterWait failed %x\n", Status));
        goto Cleanup;
    }  

    //
    // Issue the IOCTL, so we'll get notified.
    //
    NetStatus = WSAIoctl( 
                    KerbPNPSocket,
                    SIO_ADDRESS_LIST_CHANGE,
                    NULL, // No input buffer
                    0,    // No input buffer
                    NULL, // No output buffer
                    0,    // No output buffer
                    &BytesReturned,
                    NULL, // No overlapped,
                    NULL  // Not async
                    );   

    if ( NetStatus != 0 ) 
    {   
        NetStatus = WSAGetLastError();
        if ( NetStatus != WSAEWOULDBLOCK) {
            DebugLog((DEB_ERROR, "WSAIOCTL failed %x\n", NetStatus));
            Status = STATUS_INTERNAL_ERROR;
        }
    }



Cleanup: 

    if (!NT_SUCCESS( Status ))
    {        
        if ( KerbPNPSocketWaitHandle  )
        {
            RtlDeregisterWait(KerbPNPSocketWaitHandle);
            KerbPNPSocketWaitHandle = NULL;
        }

        if ( KerbPNPSocketEvent )
        {
            CloseHandle( KerbPNPSocketEvent );
            KerbPNPSocketEvent = NULL;
        }    

        if ( KerbPNPSocket )
        {
            closesocket( KerbPNPSocket );
            KerbPNPSocket = NULL;
        }    
    } 

    KerbUnlockKdcData();

    return Status;
}



//
// This address type is used for talking to MIT KDCs
//

#define DS_UNKNOWN_ADDRESS_TYPE 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKdcBinding
//
//  Synopsis:   Gets a binding to the KDC in the specified domain
//
//  Effects:
//
//  Arguments:  Realm - Domain in which to find KDC
//              PrincipalName - name of a principal that must be on the KDC
//              DesiredFlags - Flags to pass to the locator.
//              FindKpasswd - if domain is an MIT realm, then returns Kpasswd
//                      addresses instead of KDC addresses KDC
//              BindingCacheEntry - receives binding handle cache entry for
//                      TCP to the KDC
//
//  Requires:
//
//  Returns:    RPC errors, NET API errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetKdcBinding(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG DesiredFlags,
    IN BOOLEAN FindKpasswd,
    IN BOOLEAN UseTcp,
    OUT PKERB_BINDING_CACHE_ENTRY * BindingCacheEntry
    )
{
    NTSTATUS Status = STATUS_NETLOGON_NOT_STARTED;
    NTSTATUS TempStatus = STATUS_SUCCESS;
    LPWSTR DomainName = NULL;
    LPWSTR AccountName = NULL;
    ULONG NetStatus = 0;
    ULONG AddressType = DS_INET_ADDRESS;
    UNICODE_STRING KdcNameString = {0};
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName;
    BOOLEAN CacheDc = FALSE;
    BOOLEAN CalledNetlogonDirectly = FALSE;
    KERBEROS_MACHINE_ROLE Role;
    ULONG ActualFlags = 0;
    ULONG CacheFlags = 0, DcFlags = 0;
#ifndef WIN32_CHICAGO
    ULONG CachedAddressType = DS_INET_ADDRESS;
    ULONG CachedFlags = 0;
    UNICODE_STRING CachedKdcNameString = {0};
    UNICODE_STRING LocalMachineName;
#endif // WIN32_CHICAGO

    Role = KerbGetGlobalRole();
#ifndef WIN32_CHICAGO

    LocalMachineName.Buffer = NULL;

    KerbGlobalReadLock();

    //
    // use TempStatus to retain initial Status value.
    //

    TempStatus = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    KerbGlobalReleaseLock();

    
    if(!NT_SUCCESS(TempStatus))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        Status = TempStatus;
        goto Cleanup;
    }

    if ((Role != KerbRoleDomainController) &&
         (RtlEqualDomainName(
            RealmName,
            &LocalMachineName
            )))
    {
        //
        // This is an attempt at a local logon on a workstation. We don't do that.
        //

        DebugLog((DEB_WARN, "Attempting to locate a KDC for the workstation - failing\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // If we are logging on for the first time after join domain, the
    // following registry entry should exist.
    // Cache that entry, we should try to get to that dc.
    // Don't cache the entry if we are a dc
    // Don't cache the entry if this is not for our domain
    //

    if ( fNewDataAboutDomain &&
         KerbGlobalRole != KerbRoleDomainController)
    {
      if (ReadInitialDcRecord(&CachedKdcNameString, &CachedAddressType, &CachedFlags))
      {
          KerbFreeString(&KerbGlobalInitialDcRecord);
          RtlInitUnicodeString(
             &KerbGlobalInitialDcRecord,
             CachedKdcNameString.Buffer
             );

          KerbGlobalInitialDcAddressType = CachedAddressType;
          KerbGlobalInitialDcFlags = CachedFlags;

          CacheDc = TRUE;
      }
      else if (KerbGlobalInitialDcRecord.Buffer != NULL)
      { 
          CacheDc = TRUE;
      }

      if (CacheDc && KerbIsThisOurDomain( RealmName))
      {
            PKERB_BINDING_CACHE_ENTRY TempBindingCacheEntry = NULL;

            TempStatus = KerbCacheBinding(
                               RealmName,
                               &KerbGlobalInitialDcRecord,
                               KerbGlobalInitialDcAddressType,
                               DesiredFlags,
                               KerbGlobalInitialDcFlags,
                               0,
                               &TempBindingCacheEntry
                               );

            if ( TempBindingCacheEntry ) {

                KerbDereferenceBindingCacheEntry( TempBindingCacheEntry );
            }

            KerbFreeString(&KerbGlobalInitialDcRecord);
       }
    }
#endif // WIN32_CHICAGO

    //
    // Check the cache if we don't want to force rediscovery
    //

    if ((DesiredFlags & DS_FORCE_REDISCOVERY) == 0)
    {
        *BindingCacheEntry = KerbLocateBindingCacheEntry(
                                RealmName,
                                DesiredFlags,
                                FALSE
                                );
                                        
        
        if (NULL != *BindingCacheEntry)
        {
            //
            // For realmless workstations, we add negative cache entries.
            // This is because the netlogon service doesn't run on non-joined
            // machines, so we don't have the benefit of its negative caching.
            // The end result is that we need to do that ourselves.
            // 
            if (( Role == KerbRoleRealmlessWksta ) && 
               (( (*BindingCacheEntry)->CacheFlags & KERB_BINDING_NEGATIVE_ENTRY ) != 0))
            {
                DebugLog((DEB_TRACE, "Found negative entry for %wZ\n", RealmName));
                Status = STATUS_NO_LOGON_SERVERS;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }                           

            goto Cleanup;
        }
    }


    //
    // If we are a domain controller, then we can simply use our global
    // computer name.
    //

#ifndef WIN32_CHICAGO
    if ((Role == KerbRoleDomainController) &&
        ((DesiredFlags & DS_PDC_REQUIRED) == 0) &&
        KerbIsThisOurDomain(
            RealmName
            ))
    {
        DsysAssert(LocalMachineName.Buffer[LocalMachineName.Length/sizeof(WCHAR)] == L'\0');


        if (!KerbKdcStarted)
        {
            Status = KerbWaitForKdc( KerbGlobalKdcWaitTime );      // wait for KerbGlobalKdcWaitTime seconds
            if (NT_SUCCESS(Status))
            {
                KerbKdcStarted = TRUE;
            }
            else
            {
                DebugLog((DEB_WARN, "Failed to wait for KDC to start: 0x%x\n",Status));
            }
        }

        if (KerbKdcStarted)
        {
            Status = STATUS_SUCCESS;
            KdcNameString = LocalMachineName;
            AddressType = DS_NETBIOS_ADDRESS;
            CacheFlags |=  KERB_BINDING_LOCAL;
            DcFlags |= DS_CLOSEST_FLAG; 
        }
    }
#endif // WIN32_CHICAGO

    //
    // Check to see if this is an MIT realm
    //
    
    if (!NT_SUCCESS(Status) &&
        KerbLookupMitRealmWithSrvLookup(
            RealmName,
            &MitRealm,
            FindKpasswd,
            UseTcp
            ))
    {
        LONG ServerIndex;
        PKERB_MIT_SERVER_LIST ServerList;

        if ((MitRealm->Flags & KERB_MIT_REALM_TCP_SUPPORTED) == 0)
        {
            CacheFlags |= KERB_BINDING_NO_TCP;
        }

        //
        // Pick which of the servers we want to use.
        //

        if (FindKpasswd)
        {
            ServerList = &MitRealm->KpasswdNames;
        }
        else
        {
            ServerList = &MitRealm->KdcNames;
        }

        //
        // If we aren't forcing rediscovery, use the last known KDC
        //
        if (ServerList->ServerCount <= 0)
        {
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        if ((DesiredFlags & DS_FORCE_REDISCOVERY) == 0)
        {
            ServerIndex = ServerList->LastServerUsed;
        }
        else
        {
            //
            // If we are forcing rediscovery, try the next realm in the list
            //

#ifndef WIN32_CHICAGO // Implement using a global & cs
            ServerIndex = InterlockedExchangeAdd(&ServerList->LastServerUsed, 1) + 1;
#else // WIN32_CHICAGO
            ServerIndex = ServerList->LastServerUsed + 1;
            (ServerList->LastServerUsed) ++;
#endif // WIN32_CHICAGO // Implement using a global & cs
            if (ServerIndex >= ServerList->ServerCount)
            {
                InterlockedExchange(&ServerList->LastServerUsed, 0);
            }
        }
        ServerIndex = ServerIndex % ServerList->ServerCount;

        KdcNameString = ServerList->ServerNames[ServerIndex];
        AddressType = DS_UNKNOWN_ADDRESS_TYPE;
        Status = STATUS_SUCCESS;
    }
    //
    // If we haven't yet found a KDC try DsGetDcName
    //
    
    if (!NT_SUCCESS(Status))
    {
        //
        // We are dependent on AFD, so wait for it to start
        //

#ifndef WIN32_CHICAGO
        if (!KerbAfdStarted)
        {
            Status = KerbWaitForService(L"LanmanWorkstation", NULL, KerbGlobalKdcWaitTime);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to wait forAFD: 0x%x\n",Status));
                goto Cleanup;
            }
            KerbAfdStarted = TRUE;

            //
            // Setup for network change initialization.
            //
            KerbInitNetworkChangeEvent();  
        }
#endif // WIN32_CHICAGO

        //
        // Build the null-terminated domain name.
        //

        DomainName = (LPWSTR) KerbAllocate(RealmName->Length + sizeof(WCHAR));
        if (DomainName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            DomainName,
            RealmName->Buffer,
            RealmName->Length
            );
        DomainName[RealmName->Length/sizeof(WCHAR)] = L'\0';


        //
        // If a principal name was provided, pass it to Netlogon
        //

        if ((PrincipalName != NULL) && (PrincipalName->Length != 0))
        {
            AccountName = (LPWSTR) KerbAllocate(PrincipalName->Length + sizeof(WCHAR));
            if (AccountName == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                AccountName,
                PrincipalName->Buffer,
                PrincipalName->Length
                );
            AccountName[PrincipalName->Length/sizeof(WCHAR)] = L'\0';
        }

        //
        // Actual flags that will be used.
        //

        if (DesiredFlags & DS_PDC_REQUIRED)
        {
            ActualFlags =  (DesiredFlags | KERB_LOCATOR_FLAGS) & ~DS_KDC_REQUIRED;
        }
        else
        {
            ActualFlags =  DesiredFlags | KERB_LOCATOR_FLAGS;
        }

        //
        // Find the name of a DC in this domain:
        //

#ifndef WIN32_CHICAGO
        
        //
        // Note:  Watch out for changes in the enumeration below.
        //
        
        if ( !KerbNetlogonStarted && 
           ( Role > KerbRoleStandalone ) &&
           ( fRebootedSinceJoin ))
        {
            
            Status = KerbWaitForService(
                        SERVICE_NETLOGON,
                        NETLOGON_STARTED_EVENT,
                        KerbGlobalKdcWaitTime
                        );
            if (NT_SUCCESS(Status))
            {
                KerbNetlogonStarted = TRUE;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }


        if (KerbNetlogonStarted)
        {
            CalledNetlogonDirectly = TRUE;

            NetStatus = DsrGetDcNameEx2(
                            NULL,
                            AccountName,            // no account name
                            UF_ACCOUNT_TYPE_MASK,   // any account type
                            DomainName,
                            NULL,                   // no domain GUID
                            NULL,                   // no site GUID,
                            ActualFlags,
                            &DcInfo
                            );

        }
        else
#endif // WIN32_CHICAGO
        {
TryNetapi:
            NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain GUID
                            NULL,           // no site GUID,
                            ActualFlags,
                            &DcInfo
                            );
        }

        if (NetStatus != NO_ERROR)
        {
            if (NetStatus == STATUS_NETLOGON_NOT_STARTED)
            {
                KerbNetlogonStarted = FALSE;
                if (CalledNetlogonDirectly)
                {
                    CalledNetlogonDirectly = FALSE;
                    goto TryNetapi;
                }

            }

            DebugLog((
                DEB_WARN,
                "No MS DC for domain %ws, account name %ws, locator flags 0x%x: %d. %ws, line %d\n",
                DomainName, 
                (AccountName ? AccountName :L"NULL"), 
                ActualFlags, 
                NetStatus, 
                THIS_FILE, 
                __LINE__
                ));

            if (NetStatus == ERROR_NETWORK_UNREACHABLE)
            {
                Status = STATUS_NETWORK_UNREACHABLE;
            }
            else
            {
                if ( Role == KerbRoleRealmlessWksta )
                {
                    DebugLog((DEB_TRACE, "NEG Caching realm %wZ\n", RealmName));
                    KerbCacheBinding(
                        RealmName,
                        &KdcNameString,
                        AddressType,
                        DesiredFlags,  
                        DcFlags,      
                        ( CacheFlags | KERB_BINDING_NEGATIVE_ENTRY ),   
                        BindingCacheEntry
                        );  
                }

                Status = STATUS_NO_LOGON_SERVERS;
            }
            
        }
        else  // no error
        {

           RtlInitUnicodeString(
               &KdcNameString,
               DcInfo->DomainControllerAddress+2
               );
   
           AddressType = DcInfo->DomainControllerAddressType;
           DcFlags |= DcInfo->Flags;
           Status = STATUS_SUCCESS;
        }

    }
    

    if (!NT_SUCCESS(Status))
    {
       DebugLog((
          DEB_ERROR,
          "No DC for domain %ws, account name %ws, locator flags 0x%x: %d. %ws, line %d\n",
          DomainName, 
          (AccountName ? AccountName :L"NULL"), 
          ActualFlags, 
          NetStatus,                                                                      
          THIS_FILE, 
          __LINE__
          ));

       goto Cleanup;
    }
                    
    //
    // Make a binding
    //

    //
    // If this is a local call so don't bother with the socket
    //
    
    Status = KerbCacheBinding(
                RealmName,
                &KdcNameString,
                AddressType,
                DesiredFlags,  // Flags that we would like to have
                DcFlags,      // This is what the dc has
                CacheFlags,   // Special kerberos flags so we don't use
                              // locator's bit space
                BindingCacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if (DomainName != NULL)
    {
        KerbFree(DomainName);
    }

    if (AccountName != NULL)
    {
        KerbFree(AccountName);
    }
#ifndef WIN32_CHICAGO
    if (DcInfo != NULL)
    {
        if (CalledNetlogonDirectly)
        {
            I_NetLogonFree(DcInfo);
        }
        else
        {
            NetApiBufferFree(DcInfo);
        }
    }

    KerbFreeString( &LocalMachineName );
#endif // WIN32_CHICAGO

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\spncache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    spn cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <spncache.h>


//
// TBD:  Switch this to a table & resource, or entries for 
// each SPN prefix.
//
BOOLEAN         KerberosSpnCacheInitialized = FALSE;
KERBEROS_LIST   KerbSpnCache;
LONG            SpnCount;

#define KerbWriteLockSpnCache()                         KerbLockList(&KerbSpnCache);
#define KerbReadLockSpnCache()                          KerbLockList(&KerbSpnCache);
#define KerbUnlockSpnCache()                            KerbUnlockList(&KerbSpnCache);
#define KerbWriteLockSpnCacheEntry(_x_)                 RtlAcquireResourceExclusive( &_x_->ResultLock, TRUE)
#define KerbReadLockSpnCacheEntry(_x_)                  RtlAcquireResourceShared( &_x_->ResultLock, TRUE)
#define KerbUnlockSpnCacheEntry(_x_)                    RtlReleaseResource( &_x_->ResultLock)
#define KerbConvertSpnCacheEntryReadToWriteLock(_x_)    RtlConvertSharedToExclusive( &_x_->ResultLock )


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitSpnCache
//
//  Synopsis:   Initializes the SPN cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitSpnCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = KerbInitializeList( &KerbSpnCache );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerberosSpnCacheInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbSpnCache );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupSpnCache
//
//  Synopsis:   Frees the Spn cache
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupSpnCache(
    VOID
    )
{
    PKERB_SPN_CACHE_ENTRY CacheEntry;

    DebugLog((DEB_TRACE_SPN_CACHE, "Cleaning up SPN cache\n"));

    if (KerberosSpnCacheInitialized)
    {
        KerbWriteLockSpnCache();
        while (!IsListEmpty(&KerbSpnCache.List))
        {
            CacheEntry = CONTAINING_RECORD(
                            KerbSpnCache.List.Flink,
                            KERB_SPN_CACHE_ENTRY,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbSpnCache,
                &CacheEntry->ListEntry,
                TRUE
                );

            KerbDereferenceSpnCacheEntry(CacheEntry);
        }

        KerbUnlockSpnCache();

     }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupResult
//
//  Synopsis:   Cleans up result entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------

VOID
KerbCleanupResult(
    IN PSPN_CACHE_RESULT Result
    )
{
    KerbFreeString(&Result->AccountRealm);
    KerbFreeString(&Result->TargetRealm);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeResultByIndex
//
//  Synopsis:   Removes 
//
//  Effects:    Dereferences the spn cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------
VOID
KerbPurgeResultByIndex(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN ULONG IndexToPurge
    )
{

    ULONG i;  
    DebugLog((DEB_ERROR, "Purging %p, %i\n", CacheEntry, IndexToPurge));
    
    KerbCleanupResult(&CacheEntry->Results[IndexToPurge]);

    CacheEntry->ResultCount--; 

    for (i = IndexToPurge; i < CacheEntry->ResultCount; i++)
    {   
        CacheEntry->Results[i] = CacheEntry->Results[i+1];
    } 

    //
    // Zero out fields in last entry so we don't leak on an error path (or free
    // bogus info) if we reuse the entry...
    //
    RtlZeroMemory(
            &CacheEntry->Results[i],
            sizeof(SPN_CACHE_RESULT)
            );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceSpnCacheEntry
//
//  Synopsis:   Dereferences a spn cache entry
//
//  Effects:    Dereferences the spn cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbDereferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    )
{
    
    if (KerbDereferenceListEntry(
            &SpnCacheEntry->ListEntry,
            &KerbSpnCache
            ) )
    {
        KerbFreeSpnCacheEntry(SpnCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceSpnCacheEntry
//
//  Synopsis:   References a spn cache entry
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbWriteLockSpnCache();

    KerbReferenceListEntry(
        &KerbSpnCache,
        &SpnCacheEntry->ListEntry,
        RemoveFromList
        );

    KerbUnlockSpnCache();
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbAgeResults
//
//  Synopsis:   Ages out a given cache entry's result list.  Used
//              to reduce the result list to a manageable size, and
//              as a scavenger to cleanup orphaned / unused entries.
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------
       
VOID
KerbAgeResults(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
    
{
    TimeStamp CurrentTime, BackoffTime;                            
    ULONG i;
    LONG Interval;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

    //
    // Age out everything older than GlobalSpnCacheTimeout first.
    //
    for ( i = 0; i < CacheEntry->ResultCount; i++ )
    { 
        if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
        {   
            D_DebugLog((DEB_TRACE_SPN_CACHE, "removing %x %p\n"));
            KerbPurgeResultByIndex(CacheEntry, i);
        }   
    }

    if ( CacheEntry->ResultCount < MAX_RESULTS )
    {   
        return; 
    }

    
    for ( Interval = 13; Interval > 0; Interval -= 4)
    {
       KerbSetTimeInMinutes(&BackoffTime, Interval);
       for ( i=0; i < CacheEntry->ResultCount ; i++ )
       { 
           if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(BackoffTime) < KerbGetTime(CurrentTime))
           {   
               D_DebugLog((DEB_TRACE_SPN_CACHE, "removing %x %p\n"));
               KerbPurgeResultByIndex(CacheEntry, i);
           }   
       }

       if ( CacheEntry->ResultCount < MAX_RESULTS )
       {    
            return; 
       }
    }

    //
    // Still have MAX_RESULTS after all that geezzz..  
    //
    DebugLog((DEB_ERROR, "Can't get below MAX_RESULTS (%p) \n", CacheEntry ));
    DsysAssert(FALSE);                                                     

    for ( i=0; i < CacheEntry->ResultCount ; i++ )                         
    {   
        KerbPurgeResultByIndex(CacheEntry, i);                
    } 

    return;           
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbTaskSpnCacheScavenger
//
//  Synopsis:   Cleans up any old SPN cache entries.  Triggered by 30 minute
//              task.
//
//  Effects:    
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache entry must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//
VOID
KerbSpnCacheScavenger()
{

    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN     FreeMe = FALSE;  

    KerbWriteLockSpnCache();

    for (ListEntry = KerbSpnCache.List.Flink ;
         ListEntry !=  &KerbSpnCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SPN_CACHE_ENTRY, ListEntry.Next);

        KerbWriteLockSpnCacheEntry( CacheEntry );
        KerbAgeResults(CacheEntry);

        //
        // Time to pull this one from list.
        //
        if ( CacheEntry->ResultCount == 0 )
        {
            ListEntry = ListEntry->Blink;

            KerbReferenceSpnCacheEntry(
                    CacheEntry,
                    TRUE
                    );
            
            FreeMe = TRUE;
        }             
        
        KerbUnlockSpnCacheEntry( CacheEntry );  
 
        //
        // Pull the list reference.
        //
        if ( FreeMe )
        { 
            KerbDereferenceSpnCacheEntry( CacheEntry );        
            FreeMe = FALSE;
        }
    }

    KerbUnlockSpnCache();

}





//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCacheResult
//
//  Synopsis:   Uses registry to create 
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache resource must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddCacheResult(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    )
{

    NTSTATUS          Status = STATUS_SUCCESS;
    PSPN_CACHE_RESULT Result = NULL;
    
    D_DebugLog((DEB_TRACE_SPN_CACHE, "KerbAddCacheResult add domain %wZ to _KERB_SPN_CACHE_ENTRY %p (UpdateFlags %#x), NewRealm %wZ for ", &AccountCredential->DomainName, CacheEntry, UpdateFlags, NewRealm));
    D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, CacheEntry->Spn);

    //
    // If we don't have an account realm w/ this credential (e.g someone 
    // supplied you a UPN to acquirecredentialshandle, don't use the
    // spn cache.
    //
    if ( AccountCredential->DomainName.Length == 0 )
    {   
        return STATUS_NOT_SUPPORTED;
    }    


    //
    // First off, see if we're hitting the limits for our array.
    // We shouldn't ever get close to MAX_RESULTS, but if we do,
    // age out the least current CacheResult.
    //
    if ( (CacheEntry->ResultCount + 1) == MAX_RESULTS )
    {
        KerbAgeResults(CacheEntry);
    }

    Result = &CacheEntry->Results[CacheEntry->ResultCount];

    Status = KerbDuplicateStringEx( 
                &Result->AccountRealm,
                &AccountCredential->DomainName,
                FALSE
                );

    if (!NT_SUCCESS( Status ))
    {  
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT( NewRealm ))
    {  
        D_DebugLog((DEB_TRACE_SPN_CACHE, "Known - realm %wZ\n", NewRealm));
        DsysAssert(UpdateFlags != KERB_SPN_UNKNOWN);

        Status = KerbDuplicateStringEx( 
                    &Result->TargetRealm,
                    NewRealm,
                    FALSE
                    );
    
        if (!NT_SUCCESS( Status ))
        {  
            goto Cleanup;
        }
    }

#if DBG

    else
    {
        DsysAssert(UpdateFlags != KERB_SPN_KNOWN);
    }

#endif

    Result->CacheFlags = UpdateFlags;
    GetSystemTimeAsFileTime((PFILETIME) &Result->CacheStartTime);
    CacheEntry->ResultCount++;


Cleanup:

    if (!NT_SUCCESS( Status ) )
    {   
        if ( Result != NULL )
        {
            KerbCleanupResult( Result );
        }
    }             

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildSpnCacheEntry
//
//  Synopsis:   Builds a spn cache entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm,
    IN OUT PKERB_SPN_CACHE_ENTRY* NewCacheEntry
    )
{

    NTSTATUS Status;          
    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN               FreeResource = FALSE;

    *NewCacheEntry = NULL;    

    CacheEntry = (PKERB_SPN_CACHE_ENTRY) KerbAllocate( sizeof(KERB_SPN_CACHE_ENTRY) );
    if ( CacheEntry == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }                                              

    Status = KerbDuplicateKdcName(
                &CacheEntry->Spn,
                Spn
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbAddCacheResult(
                CacheEntry,
                AccountCredential,
                UpdateFlags,
                NewRealm
                );

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }                

    KerbInitializeListEntry( &CacheEntry->ListEntry );

    __try
    {
        RtlInitializeResource( &CacheEntry->ResultLock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    } 

    FreeResource = TRUE;

    KerbInsertSpnCacheEntry(CacheEntry);

    *NewCacheEntry = CacheEntry; 
    CacheEntry = NULL;

    InterlockedIncrement( &SpnCount );

Cleanup:

    if (!NT_SUCCESS(Status) && ( CacheEntry ))
    {
       KerbCleanupResult(&CacheEntry->Results[0]);
       KerbFreeKdcName( &CacheEntry->Spn );
       
       if ( FreeResource )
       {
           RtlDeleteResource( &CacheEntry->ResultLock );
       }                                                

       KerbFree(CacheEntry);
    }                                             

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbScanResults
//
//  Synopsis:   Scans result list.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//---

BOOLEAN
KerbScanResults(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PUNICODE_STRING Realm,
    IN OUT PULONG Index
    )
{
    BOOLEAN Found = FALSE;
    ULONG i;
    
    for ( i=0; i < CacheEntry->ResultCount; i++)
    { 
        if (RtlEqualUnicodeString(
                &CacheEntry->Results[i].AccountRealm,
                Realm,
                TRUE
                ))
        {
            Found = TRUE;
            *Index = i;
            break;
        }
    }

    return Found;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateSpnCacheEntry
//
//  Synopsis:   Updates a spn cache entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateSpnCacheEntry(
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY ExistingCacheEntry,
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    )
{
    PKERB_SPN_CACHE_ENTRY CacheEntry = ExistingCacheEntry;
    NTSTATUS              Status = STATUS_SUCCESS;
    BOOLEAN               Found = FALSE, Update = FALSE;
    ULONG                 Index = 0;

    //
    // We're not using SPN cache
    //
    if (KerbGlobalSpnCacheTimeout.QuadPart == 0 || !KerberosSpnCacheInitialized )
    {
        return STATUS_SUCCESS;
    }

    //
    // If we didn't have a cache entry before, see if we do now, or create
    // one if necessary.
    //
   
    if (!ARGUMENT_PRESENT( ExistingCacheEntry ))
    {
        KerbWriteLockSpnCache();
        CacheEntry = KerbLocateSpnCacheEntry( Spn );

        if ( CacheEntry == NULL)
        {
            Status = KerbCreateSpnCacheEntry(
                        Spn,
                        AccountCredential,
                        UpdateFlags,
                        NewRealm,
                        &CacheEntry
                        );

            if (NT_SUCCESS(Status))
            {
                //
                // All done, get outta here.
                //
                D_DebugLog((DEB_TRACE_SPN_CACHE, "Created new cache entry %p (%x) \n", CacheEntry, UpdateFlags));
                D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, Spn);
                D_DebugLog((DEB_TRACE_SPN_CACHE, "%wZ\n", &AccountCredential->DomainName));

                KerbDereferenceSpnCacheEntry( CacheEntry );
            }
            
            KerbUnlockSpnCache();
            return Status;
        }   

        KerbUnlockSpnCache();
    }


    //
    // Got an existing entry - update it.
    //
    KerbReadLockSpnCacheEntry( CacheEntry );  
    
    if (KerbScanResults(
                    CacheEntry,
                    &AccountCredential->DomainName,
                    &Index
                    ))
    {
        Found = TRUE;
        Update = (( CacheEntry->Results[Index].CacheFlags & UpdateFlags) != UpdateFlags);
    }

    KerbUnlockSpnCacheEntry( CacheEntry );

    //
    // To avoid always taking the write lock, we'll need to rescan the result
    // list under a write lock.
    //
    if ( Update )
    {
        KerbWriteLockSpnCacheEntry( CacheEntry );

        if (KerbScanResults(
                CacheEntry,
                &AccountCredential->DomainName,
                &Index
                ))
        {
            //
            // Hasn't been updated or removed in the small time slice above.  Update.
            //

            if (( CacheEntry->Results[Index].CacheFlags & UpdateFlags) != UpdateFlags )
            {
                D_DebugLog(( 
                     DEB_TRACE_SPN_CACHE, 
                     "KerbUpdateSpnCacheEntry changing _KERB_SPN_CACHE_ENTRY %p Result Index %#x: AccountRealm %wZ, TargetRealm %wZ, NewRealm %wZ, CacheFlags %#x to CacheFlags %#x for ", 
                     CacheEntry,
                     Index,
                     &CacheEntry->Results[Index].AccountRealm,
                     &CacheEntry->Results[Index].TargetRealm,
                     NewRealm,
                     CacheEntry->Results[Index].CacheFlags, 
                     UpdateFlags
                     ));
                D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, CacheEntry->Spn);

                CacheEntry->Results[Index].CacheFlags = UpdateFlags;
                GetSystemTimeAsFileTime( (LPFILETIME) &CacheEntry->Results[Index].CacheStartTime );

                KerbFreeString(&CacheEntry->Results[Index].TargetRealm);

                if (ARGUMENT_PRESENT( NewRealm ))
                {
                    DsysAssert( UpdateFlags == KERB_SPN_KNOWN );
                    Status = KerbDuplicateStringEx(
                                    &CacheEntry->Results[Index].TargetRealm,
                                    NewRealm,
                                    FALSE
                                    );

                    if (!NT_SUCCESS( Status ))
                    {
                        KerbUnlockSpnCacheEntry( CacheEntry );
                        goto Cleanup;
                    }                
                }                     
            }
        }
        else
        {
            Found = FALSE;
        }

        KerbUnlockSpnCacheEntry( CacheEntry ); 
    }

    if (!Found)
    {   
        KerbWriteLockSpnCacheEntry ( CacheEntry );

        //
        // Still not found
        //
        if (!KerbScanResults( CacheEntry, &AccountCredential->DomainName, &Index ))
        {
            Status = KerbAddCacheResult(
                        CacheEntry,
                        AccountCredential,
                        UpdateFlags,
                        NewRealm
                        );
        }

        KerbUnlockSpnCacheEntry( CacheEntry );

        if (!NT_SUCCESS(Status))
        {   
            goto Cleanup;
        }
    }  


Cleanup:
    
    //
    // Created a new cache entry, referenced w/i this function.
    //
    if (!ARGUMENT_PRESENT( ExistingCacheEntry ) && CacheEntry )
    {
        KerbDereferenceSpnCacheEntry( CacheEntry );
    }

    return Status;
}







//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateSpnCacheEntry
//
//  Synopsis:   References a spn cache entry by name
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              DesiredFlags - Flags desired for binding, such as PDC required
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_SPN_CACHE_ENTRY
KerbLocateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME Spn
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;
    
    if (Spn->NameType != KRB_NT_SRV_INST)
    {
        return NULL;
    }
    
    //
    // We're not using SPN cache
    //
    if (KerbGlobalSpnCacheTimeout.QuadPart == 0 || !KerberosSpnCacheInitialized )
    {
        return NULL;
    }
          

    //
    // Scale the cache by aging out old entries.
    //
    if ( SpnCount > MAX_CACHE_ENTRIES )
    {
        KerbSpnCacheScavenger();
    }                               

    KerbReadLockSpnCache();
    //
    // Go through the spn cache looking for the correct entry
    //

    for (ListEntry = KerbSpnCache.List.Flink ;
         ListEntry !=  &KerbSpnCache.List ;
         ListEntry = ListEntry->Flink )
    {   
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SPN_CACHE_ENTRY, ListEntry.Next);
        
        if (KerbEqualKdcNames(CacheEntry->Spn,Spn))
        {                
            KerbReferenceSpnCacheEntry(
                    CacheEntry,
                    FALSE
                    ); 

            D_DebugLog((DEB_TRACE_SPN_CACHE, "SpnCacheEntry %p\n", CacheEntry));

            Found = TRUE;
            break;
        }
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    

    KerbUnlockSpnCache();           
    return(CacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupResultList
//
//  Synopsis:   Frees memory associated with a result list
//
//  Effects:
//
//  Arguments:  SpnCacheEntry - The cache entry to free. It must be
//                      unlinked, and the Resultlock must be held.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupResultList(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
{
    for (ULONG i = 0; i < CacheEntry->ResultCount; i++)
    {
        KerbCleanupResult(&CacheEntry->Results[i]);
    }

    CacheEntry->ResultCount = 0;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeSpnCacheEntry
//
//  Synopsis:   Frees memory associated with a spn cache entry
//
//  Effects:
//
//  Arguments:  SpnCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    )
{
    
    //
    // Must be unlinked..
    //
    DsysAssert(SpnCacheEntry->ListEntry.Next.Flink == NULL);
    DsysAssert(SpnCacheEntry->ListEntry.Next.Blink == NULL);
    
    KerbWriteLockSpnCacheEntry(SpnCacheEntry);    
    KerbCleanupResultList(SpnCacheEntry);         
    KerbUnlockSpnCacheEntry(SpnCacheEntry);
    
    RtlDeleteResource(&SpnCacheEntry->ResultLock);
    KerbFreeKdcName(&SpnCacheEntry->Spn);
    KerbFree(SpnCacheEntry);

    InterlockedDecrement( &SpnCount );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertBinding
//
//  Synopsis:   Inserts a binding into the spn cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInsertSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
{
    KerbInsertListEntry(
        &CacheEntry->ListEntry,
        &KerbSpnCache
        );

    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSpnCacheStatus
//
//  Synopsis:   Gets the status of a cache entry for a given realm.
//
//  Effects:    Returns STATUS_NO_SAM_TRUST_RELATIONSHIP for unknown SPNs,
//              STATUS_NO_MATCH, if we're missing a realm result, or
//              STATUS_SUCCESS ++ dupe the SPNREalm for the "real" realm
//              of the SPN relative to the account realm.
//
//  Arguments:  CacheEntry - SPN cache entry from ProcessTargetName()
//              Credential - Primary cred for account realm.
//              SpnRealm - IN OUT Filled in w/ target realm of SPN
//              
//              
//  Requires:
//
//  Returns:     
//
//  Notes:      
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSpnCacheStatus(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL Credential,
    IN OUT PUNICODE_STRING SpnRealm
    )
{   
    NTSTATUS        Status = STATUS_NO_MATCH;;
    ULONG           i;
    TimeStamp       CurrentTime;     
    BOOLEAN         Purge = FALSE;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);  

    //
    // Read Lock the spn cache entry
    //
    KerbReadLockSpnCacheEntry( CacheEntry );    

    if (KerbScanResults(
            CacheEntry,
            &Credential->DomainName,
            &i
            ))
    {
        if (CacheEntry->Results[i].CacheFlags & KERB_SPN_UNKNOWN)
        { 
            //
            // Check and see if this timestamp has expired.
            //          
            if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
            {   
                Purge = TRUE;            
                Status = STATUS_SUCCESS;
            }   
            else
            {
                Status = STATUS_NO_TRUST_SAM_ACCOUNT;
                DebugLog((DEB_WARN, "SPN not found\n"));
                KerbPrintKdcName(DEB_WARN, CacheEntry->Spn);
            }
        }
        else if (CacheEntry->Results[i].CacheFlags & KERB_SPN_KNOWN)
        {
            Status = KerbDuplicateStringEx(
                            SpnRealm,
                            &CacheEntry->Results[i].TargetRealm,
                            FALSE
                            );

            D_DebugLog((DEB_TRACE_SPN_CACHE, "Found %wZ\n", SpnRealm));
            D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, CacheEntry->Spn);
        }
    }

    KerbUnlockSpnCacheEntry( CacheEntry );

    if (!NT_SUCCESS( Status ))
    {
        return Status; 
    }

    //
    // Take the write lock, and verify that we still need to purge the above 
    // result.
    //
    if ( Purge )
    {
        KerbWriteLockSpnCacheEntry( CacheEntry );
        if (KerbScanResults(
              CacheEntry,
              &Credential->DomainName,
              &i
              ))
        {
            if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + 
                KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
            {
                D_DebugLog((DEB_TRACE_SPN_CACHE, "Purging %p due to time\n", &CacheEntry->Results[i]));
                KerbPurgeResultByIndex( CacheEntry, i ); 
            }                                            
        }

        KerbUnlockSpnCacheEntry( CacheEntry );
        Status = STATUS_NO_MATCH;
    }                                         

    return Status;                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\timesync.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        timesync.h
//
// Contents:    Prototypes for time-sync functions
//
//
// History:     3-Nov-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TIMESYNC_H__
#define __TIMESYNC_H__

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef TIMESYNC_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

typedef struct _KERB_TIME_SKEW_ENTRY {
    TimeStamp RequestTime;
    BOOLEAN Skewed;
} KERB_TIME_SKEW_ENTRY, *PKERB_TIME_SKEW_ENTRY;

typedef struct _KERB_TIME_SKEW_STATE {
    TimeStamp LastSync;                 // time of last sync
    TimeStamp MinimumSyncLapse;         // Minimum allowed time between sync requests
    ULONG SkewThreshold;                // number of skews to trigger sync
    ULONG TotalRequests;                // Number of entries to track
    ULONG SkewedRequests;               // number of time skew events
    ULONG SuccessRequests;              // number of success events
    ULONG LastRequest;                  // index into next skew entry
    LONG ActiveSyncs;                   // number of threads doing a sync
    PKERB_TIME_SKEW_ENTRY SkewEntries;  // array of skew entries
    RTL_CRITICAL_SECTION Lock;          // lock for skew state
} KERB_TIME_SKEW_STATE, *PKERB_TIME_SKEW_STATE;

EXTERN KERB_TIME_SKEW_ENTRY KerbSkewEntries[10];
EXTERN KERB_TIME_SKEW_STATE KerbSkewState;

VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    );

NTSTATUS
KerbInitializeSkewState(
    VOID
    );

#endif // __TIMESYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\spncache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        spncache.h
//
// Contents:    Prototypes and types for SPN cache
//
//
// History:     29-August-2000  Created         MikeSw
//
//------------------------------------------------------------------------
#ifndef __SPNCACHE_H__
#define __SPNCACHE_H__


extern BOOLEAN KerberosSpnCacheInitialized;
extern KERBEROS_LIST KerbSpnCache;

//
// The below value tells us when to start scavenging 
// our cache
//                           
#define MAX_CACHE_ENTRIES   350


typedef struct _SPN_CACHE_RESULT {
    UNICODE_STRING AccountRealm;
    UNICODE_STRING TargetRealm;
    ULONG          CacheFlags;
    TimeStamp      CacheStartTime;
} SPN_CACHE_RESULT, *PSPN_CACHE_RESULT;


#define MAX_RESULTS 16

typedef struct _KERB_SPN_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    PKERB_INTERNAL_NAME Spn;
    RTL_RESOURCE        ResultLock;       
    ULONG               ResultCount;
    SPN_CACHE_RESULT    Results[MAX_RESULTS];
} KERB_SPN_CACHE_ENTRY, *PKERB_SPN_CACHE_ENTRY;


//
//  Valid CacheFlags
//
#define KERB_SPN_UNKNOWN   0x1
#define KERB_SPN_KNOWN     0x2

#define KERB_SPNCACHE_KEY L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\SpnCache"
#define KERB_REALM_STRING L"Realm"


//
NTSTATUS
KerbGetSpnCacheStatus(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL Credential,
    IN OUT PUNICODE_STRING SpnRealm
    );

VOID
KerbCleanupSpnCache(
    VOID
    );

VOID
KerbFreeSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    );

NTSTATUS
KerbInitSpnCache(
    VOID
    );



NTSTATUS
KerbInsertSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    );

VOID
KerbDereferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    );

PKERB_SPN_CACHE_ENTRY
KerbLocateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME Spn
    );

NTSTATUS
KerbUpdateSpnCacheEntry(
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY ExistingCacheEntry,
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    );


#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\tktcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktcache.h
//
// Contents:    Prototypes and types for ticket cache
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TKTCACHE_H__
#define __TKTCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef TKTCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef WIN32_CHICAGO
EXTERN CRITICAL_SECTION KerberosTicketCacheLock;
#else // WIN32_CHICAGO
EXTERN RTL_RESOURCE KerberosTicketCacheLock;
#endif // WIN32_CHICAGO
EXTERN BOOLEAN KerberosTicketCacheInitialized;
EXTERN LONG KerbTicketCacheHits;
EXTERN LONG KerbTicketCacheMisses;

#define KERB_TICKET_CACHE_PRIMARY_TGT           0x1     // ticket is primary TGT
#define KERB_TICKET_CACHE_DELEGATION_TGT        0x2     // ticket is delegation TGT
#define KERB_TICKET_CACHE_TKT_ENC_IN_SKEY       0x10    // ticket is encrypted with a session key

#ifdef WIN32_CHICAGO
#define KerbWriteLockTicketCache() (EnterCriticalSection(&KerberosTicketCacheLock))
#define KerbReadLockTicketCache() (EnterCriticalSection(&KerberosTicketCacheLock))
#define KerbUnlockTicketCache() (LeaveCriticalSection(&KerberosTicketCacheLock))
#else // WIN32_CHICAGO
#define KerbWriteLockTicketCache() (RtlAcquireResourceExclusive(&KerberosTicketCacheLock,TRUE))
#define KerbReadLockTicketCache() (RtlAcquireResourceShared(&KerberosTicketCacheLock, TRUE))
#define KerbUnlockTicketCache() (RtlReleaseResource(&KerberosTicketCacheLock))
#endif // WIN32_CHICAGO

VOID
KerbReferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbFreeTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbReleaseTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbDereferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

NTSTATUS
KerbInitTicketCaching(
    VOID
    );

VOID
KerbFreeTicketCache(
    VOID
    );


NTSTATUS
KerbCacheTicket(
    IN OPTIONAL PKERB_TICKET_CACHE TicketCache,
    IN PKERB_KDC_REPLY KdcReply,
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody,
    IN OPTIONAL PKERB_INTERNAL_NAME TargetName,
    IN OPTIONAL PUNICODE_STRING TargetRealm,
    IN ULONG Flags,
    IN BOOLEAN LinkEntry,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    );

VOID
KerbPurgeTicketCache(
    IN PKERB_TICKET_CACHE Cache
    );


VOID
KerbInitTicketCache(
    IN PKERB_TICKET_CACHE TicketCache
    );

PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_INTERNAL_NAME FullServiceName,
    IN PUNICODE_STRING RealmName
    );


PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntryByRealm(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PUNICODE_STRING RealmName,
    IN ULONG RequiredFlags
    );


VOID
KerbInsertTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbRemoveTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

BOOLEAN
KerbTicketIsExpiring(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOLEAN AllowSkew
    );

VOID
KerbSetTicketCacheEntryTarget(
    IN PUNICODE_STRING TargetName,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );


#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\timesync.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        timesync.cxx
//
// Contents:    Code for logon and logoff for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#define TIMESYNC_ALLOCATE
#include <kerbp.h>
extern "C"
{
#include <w32timep.h>
}

#ifndef WIN32_CHICAGO



//+-------------------------------------------------------------------------
//
//  Function:   KerbTimeSyncWorker
//
//  Synopsis:   Does work of time sync
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbTimeSyncWorker(PVOID Dummy)
{
    HANDLE hTimeSlipEvent = NULL; 
    ULONG Status = STATUS_SUCCESS;

    D_DebugLog((DEB_TRACE_TIME, "Calling W32TimeSyncNow\n"));
    if (InterlockedIncrement(&KerbSkewState.ActiveSyncs) == 1)
    {
        // Use this named event instead of W32TimeSyncNow().  W32TimeSyncNow uses kerberos to 
        // make an authenticated RPC call, which can fail if there is a time skew.  We should
        // be able to set the named event regardless of skew.  
        hTimeSlipEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT); 
        if (NULL == hTimeSlipEvent) { 
            Status = GetLastError(); 
        } else { 
            if (!SetEvent(hTimeSlipEvent)) { 
                Status = GetLastError(); 
            }

            CloseHandle(hTimeSlipEvent); 
        }

        if (Status != ERROR_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sync time: %d\n",Status));
        }
    }
    InterlockedDecrement(&KerbSkewState.ActiveSyncs);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbKickoffTime
//
//  Synopsis:   Puts a item on scavenger queue to time sync
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbKickoffTimeSync(
    VOID
    )
{
    ULONG Index;

    //
    // Reset the time skew data so we don't sync too often.
    //

    for (Index = 0; Index < KerbSkewState.TotalRequests ; Index++ )
    {
        KerbSkewState.SkewEntries[Index].Skewed = FALSE;
        KerbSkewState.SkewEntries[Index].RequestTime = KerbGlobalWillNeverTime;

    }

    KerbSkewState.SkewedRequests = 0;
    KerbSkewState.SuccessRequests = KerbSkewState.TotalRequests;
    KerbSkewState.LastRequest = 0;

    LsaFunctions->RegisterNotification(
        KerbTimeSyncWorker,
        NULL,
        NOTIFIER_TYPE_IMMEDIATE,
        0,                       // no class
        NOTIFIER_FLAG_ONE_SHOT,
        0,
        NULL
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateSkewTime
//
//  Synopsis:   Updates the statistics for time skew. If necessary, triggers
//              time skew in another thread
//
//  Effects:
//
//  Arguments:  Skewed  - The last request did not generate a time skew error
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    )
{
    TimeStamp CurrentTime;

    RtlEnterCriticalSection(&KerbSkewState.Lock);

    //
    // If this changes the entry, update the counts
    //

    if (Skewed != KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed)
    {
        if (KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed)
        {
            KerbSkewState.SkewedRequests--;
            KerbSkewState.SuccessRequests++;
        }
        else
        {
            KerbSkewState.SkewedRequests++;
            KerbSkewState.SuccessRequests--;
        }

        KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed = Skewed;
    }

    D_DebugLog((DEB_TRACE_TIME,"Updating skew statistics: Skewed = %d, successful = %d, latest = %s\n",
        KerbSkewState.SkewedRequests,
        KerbSkewState.SuccessRequests,
        Skewed ? "Skewed" : "Success"
        ));

    GetSystemTimeAsFileTime((PFILETIME)
        &CurrentTime
        );

    KerbSkewState.SkewEntries[KerbSkewState.LastRequest].RequestTime = CurrentTime;

    KerbSkewState.LastRequest = (KerbSkewState.LastRequest + 1) % KerbSkewState.TotalRequests;

    //
    // Check to see if this triggers a time sync, in that we have enough
    // failure events and the last sync was a while ago
    //

    if ((KerbSkewState.SkewedRequests > KerbSkewState.SkewThreshold) && // enough events
        ((CurrentTime.QuadPart - KerbSkewState.LastSync.QuadPart) >
            KerbSkewState.MinimumSyncLapse.QuadPart ) &&                // last sync a while ago
         (KerbSkewState.SkewEntries[KerbSkewState.LastRequest].RequestTime.QuadPart >
            KerbSkewState.LastSync.QuadPart ) )                         // all events were since the last sync
    {
        KerbSkewState.LastSync = CurrentTime;
        KerbKickoffTimeSync();
    }
    RtlLeaveCriticalSection(&KerbSkewState.Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSkewState
//
//  Synopsis:   Initializes all state for the time-sync code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeSkewState(
    VOID
    )
{
    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;
    KerbSkewState.TotalRequests = sizeof(KerbSkewEntries) / sizeof(KERB_TIME_SKEW_ENTRY);
    Status = RtlInitializeCriticalSection(
        &KerbSkewState.Lock
        );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the list of skew entries to show that we are very successful
    //

    KerbSkewState.SkewEntries = KerbSkewEntries;
    for (Index = 0; Index < KerbSkewState.TotalRequests ; Index++ )
    {
        KerbSkewState.SkewEntries[Index].Skewed = FALSE;
        KerbSkewState.SkewEntries[Index].RequestTime = KerbGlobalWillNeverTime;

    }

    KerbSkewState.SkewedRequests = 0;
    KerbSkewState.SuccessRequests = KerbSkewState.TotalRequests;
    KerbSkewState.LastRequest = 0;
    //
    // We need to have 1/2 failures to trigger a skew
    //

    KerbSkewState.SkewThreshold = KerbSkewState.TotalRequests / 2;
    KerbSkewState.MinimumSyncLapse.QuadPart =
        (LONGLONG) 10000000 * 60 * 60;          // don't sync more than every hour
    //
    // Start off last sync at zero
    //

    KerbSkewState.LastSync.QuadPart = 0;
    KerbSkewState.ActiveSyncs = 0;
Cleanup:
    return(Status);
}
#else // WIN32_CHICAGO

VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    )
{
    return;
}

NTSTATUS
KerbInitializeSkewState(
    VOID
    )
{
    return(STATUS_SUCCESS);
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\tktlogon.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        tktlogon.cxx
//
// Contents:    Code for proxy logon for the Kerberos package
//
//
// History:     15-March        Created             MikeSw
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTicketLogonSession
//
//  Synopsis:   Does all the work for a ticket logon, removing it from
//              LsaApLogonUserEx2
//
//  Effects:
//
//  Arguments:  WorkstationTicket - ticket to workstation. The ticket
//                      cache entry is pretty much empty except for
//                      the ticket, and is not linked
//              ForwardedTgt - receives pointers into the Protocol
//                      SubmitBuffer to the forwarded TGT.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateTicketLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession,
    OUT PLUID LogonId,
    OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
    OUT PKERB_MESSAGE_BUFFER ForwardedTgt
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TICKET_LOGON LogonInfo = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERB_KDC_REPLY KdcReply = {0};
    ULONG_PTR Offset;
    UNICODE_STRING EmptyString = {0};
    PKERB_TICKET Ticket = NULL;
    KERBERR KerbErr;



    *WorkstationTicket = NULL;
    ForwardedTgt->Buffer = NULL;
    ForwardedTgt->BufferSize = 0;

    //
    // Pull the interesting information out of the submit buffer
    //

    if (SubmitBufferSize < sizeof(KERB_TICKET_LOGON))
    {
        DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    LogonInfo = (PKERB_TICKET_LOGON) ProtocolSubmitBuffer;

    DsysAssert((LogonInfo->MessageType == KerbTicketLogon) || (LogonInfo->MessageType == KerbTicketUnlockLogon));




    //
    // Relocate any pointers to be relative to 'LogonInfo'
    //


    Offset = ((PUCHAR) LogonInfo->ServiceTicket) - ((PUCHAR)ClientBufferBase);
    if ( (Offset >= SubmitBufferSize) ||
         (Offset + LogonInfo->ServiceTicketLength > SubmitBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    LogonInfo->ServiceTicket = (PUCHAR) ProtocolSubmitBuffer + Offset;

    if (LogonInfo->TicketGrantingTicketLength != 0)
    {
        if (LogonInfo->TicketGrantingTicket == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        Offset = ((PUCHAR) LogonInfo->TicketGrantingTicket) - ((PUCHAR)ClientBufferBase);
        if ( (Offset >= SubmitBufferSize) ||
             (Offset + LogonInfo->TicketGrantingTicketLength > SubmitBufferSize))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        LogonInfo->TicketGrantingTicket = (PUCHAR) ProtocolSubmitBuffer + Offset;
        ForwardedTgt->BufferSize = LogonInfo->TicketGrantingTicketLength;
        ForwardedTgt->Buffer = LogonInfo->TicketGrantingTicket;
    }


    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Build a logon session to hold all this information
    //

    Status = KerbCreateLogonSession(
                LogonId,
                &EmptyString,
                &EmptyString,
                NULL,                       // no password
                NULL,                       // no old password
                0,                          // no password options
                LogonType,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Unpack the supplied service ticket
    //


    KerbErr = KerbUnpackData(
                LogonInfo->ServiceTicket,
                LogonInfo->ServiceTicketLength,
                KERB_TICKET_PDU,
                (PVOID *) &Ticket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack service ticket in ticket logon\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build a ticket structure from the service ticket.
    //


    KdcReply.ticket = *Ticket;
    Status = KerbCacheTicket(
                NULL,                   // no ticket cache
                &KdcReply,
                NULL,                   // no kdc reply
                NULL,                   // no target name
                NULL,                   // no target realm
                0,                      // no flags
                FALSE,                  // don't link entry
                WorkstationTicket
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Return the new logon session.
    //

    *NewLogonSession = LogonSession;
    LogonSession = NULL;



Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }

    }

    if (Ticket != NULL)
    {
        KerbFreeData(KERB_TICKET_PDU, Ticket);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractForwardedTgt
//
//  Synopsis:   Extracts a forwarded TGT from its encoded representation
//              and sticks it in the logon session ticket cache. This
//              also updates the user name & domain name in the
//              logon session, if they aren't present.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExtractForwardedTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN PKERB_ENCRYPTED_TICKET WorkstationTicket
    )
{
    PKERB_CRED KerbCred = NULL;
    PKERB_ENCRYPTED_CRED EncryptedCred = NULL;
    KERBERR KerbErr;
    NTSTATUS Status = STATUS_SUCCESS;

    D_DebugLog((DEB_TRACE, "Extracting a forwarded TGT\n"));

    KerbErr = KerbUnpackKerbCred(
                ForwardedTgt->Buffer,
                ForwardedTgt->BufferSize,
                &KerbCred
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "Failed to unpack kerb cred for forwaded tgt\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;

    }

    //
    // Now decrypt the encrypted part of the KerbCred.
    //

    KerbErr = KerbDecryptDataEx(
                &KerbCred->encrypted_part,
                &WorkstationTicket->key,
                KERB_CRED_SALT,
                (PULONG) &KerbCred->encrypted_part.cipher_text.length,
                KerbCred->encrypted_part.cipher_text.value
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt KERB_CRED: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;

            //
            // MIT clients don't encrypt the encrypted part, so drop through
            //

        }
    }

    //
    // Now unpack the encrypted part.
    //

    KerbErr = KerbUnpackEncryptedCred(
                KerbCred->encrypted_part.cipher_text.value,
                KerbCred->encrypted_part.cipher_text.length,
                &EncryptedCred
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Use the old status if it is available.
        //

        if (NT_SUCCESS(Status))
        {
            Status = KerbMapKerbError(KerbErr);
        }
        DebugLog((DEB_WARN, "Failed to unpack encrypted cred\n"));
        goto Cleanup;
    }

    //
    // Now build a logon session.
    //

    Status = KerbCreateLogonSessionFromKerbCred(
                NULL,
                WorkstationTicket,
                KerbCred,
                EncryptedCred,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session from kerb cred: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:
    if (EncryptedCred != NULL)
    {
        KerbFreeEncryptedCred(EncryptedCred);
    }
    if (KerbCred != NULL)
    {
        KerbFreeKerbCred(KerbCred);
    }
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\tktcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktcache.cxx
//
// Contents:    Ticket cache for Kerberos Package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#define TKTCACHE_ALLOCATE
#include <kerbp.h>


//
// Statistics for trackign hits/misses in cache
//

#define UpdateCacheHits() (InterlockedIncrement(&KerbTicketCacheHits))
#define UpdateCacheMisses() (InterlockedIncrement(&KerbTicketCacheMisses))


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketCaching
//
//  Synopsis:   Initialize the ticket caching code
//
//  Effects:    Creates a RTL_RESOURCE
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, NTSTATUS from Rtl routines
//              on error
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitTicketCaching(
    VOID
    )
{

    RtlInitializeResource(&KerberosTicketCacheLock);
    KerberosTicketCacheInitialized = TRUE;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketCache
//
//  Synopsis:   Initializes a single ticket cache
//
//  Effects:    initializes list entry
//
//  Arguments:  TicketCache - The ticket cache to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitTicketCache(
    IN PKERB_TICKET_CACHE TicketCache
    )
{
    InitializeListHead(&TicketCache->CacheEntries);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketCache
//
//  Synopsis:   Frees the ticket cache global data
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeTicketCache(
    VOID
    )
{
//    if (KerberosTicketCacheInitialized)
//    {
//        KerbWriteLockTicketCache();
//        RtlDeleteResource(&KerberosTicketCacheLock);
//    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketCacheEntry
//
//  Synopsis:   Frees memory associated with a ticket cache entry
//
//  Effects:
//
//  Arguments:  TicketCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    KerbFreeKdcName(&TicketCacheEntry->ServiceName);
    KerbFreeString(&TicketCacheEntry->DomainName);
    KerbFreeString(&TicketCacheEntry->TargetDomainName);
    KerbFreeString(&TicketCacheEntry->AltTargetDomainName);
    KerbFreeString(&TicketCacheEntry->ClientDomainName);
    KerbFreeKdcName(&TicketCacheEntry->ClientName);
    KerbFreeKdcName(&TicketCacheEntry->TargetName);
    KerbFreeDuplicatedTicket(&TicketCacheEntry->Ticket);
    KerbFreeKey(&TicketCacheEntry->SessionKey);
    KerbFree(TicketCacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceTicketCacheEntry
//
//  Synopsis:   Dereferences a ticket cache entry
//
//  Effects:    Dereferences the ticket cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   TicketCacheEntry - The ticket cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

    if ( 0 == InterlockedDecrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount )) {

        KerbFreeTicketCacheEntry(TicketCacheEntry);
    }

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReleaseTicketCacheEntry
//
//  Synopsis:   Release a ticket cache entry
//
//  Effects:
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   TicketCacheEntry - The ticket cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReleaseTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    if (TicketCacheEntry->Linked)
    {
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
    else
    {
        KerbFreeTicketCacheEntry(TicketCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceTicketCacheEntry
//
//  Synopsis:   References a ticket cache entry
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCacheEntry - Ticket cache entry  to reference
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

    InterlockedIncrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertTicketCachEntry
//
//  Synopsis:   Inserts a ticket cache entry onto a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache - The ticket cache on which to stick the ticket.
//              TicketCacheEntry - The entry to stick in the cache.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------



VOID
KerbInsertTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    if ( !InterlockedCompareExchange(
              &TicketCacheEntry->Linked,
              (LONG)TRUE,
              (LONG)FALSE )) {

        InterlockedIncrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount );

        KerbWriteLockTicketCache();

        InsertHeadList(
            &TicketCache->CacheEntries,
            &TicketCacheEntry->ListEntry.Next
            );

        KerbUnlockTicketCache();
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemoveTicketCachEntry
//
//  Synopsis:   Removes a ticket cache entry from its ticket cache
//
//  Effects:
//
//  Arguments:  TicketCacheEntry - The entry to yank out of the cache.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRemoveTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    //
    // An entry can only be unlinked from the cache once
    //

    if ( InterlockedCompareExchange(
             &TicketCacheEntry->Linked,
             (LONG)FALSE,
             (LONG)TRUE )) {

        DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

        KerbWriteLockTicketCache();

        RemoveEntryList(&TicketCacheEntry->ListEntry.Next);

        KerbUnlockTicketCache();

        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheTicket
//
//  Synopsis:   Caches a ticket in the ticket cache
//
//  Effects:    creates a cache entry
//
//  Arguments:  Cache - The cache in which to store the ticket - not needed
//                      if ticket won't be linked.
//              Ticket - The ticket to cache
//              KdcReply - The KdcReply corresponding to the ticket cache
//              ReplyClientName - Client name from the KDC reply structure
//              TargetName - Name of service supplied by client
//              LinkEntry - If TRUE, insert cache entry into cache
//              NewCacheEntry - receives new cache entry (referenced)
//
//  Requires:
//
//  Returns:
//
//  Notes:      The ticket cache owner must be locked for write access
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCacheTicket(
    IN OPTIONAL PKERB_TICKET_CACHE TicketCache,
    IN PKERB_KDC_REPLY KdcReply,
    IN OPTIONAL PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody,
    IN OPTIONAL PKERB_INTERNAL_NAME TargetName,
    IN OPTIONAL PUNICODE_STRING TargetDomainName,
    IN ULONG CacheFlags,
    IN BOOLEAN LinkEntry,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    )
{
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG OldCacheFlags = 0;

    *NewCacheEntry = NULL;

    CacheEntry = (PKERB_TICKET_CACHE_ENTRY)
        KerbAllocate(sizeof(KERB_TICKET_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the entries from the KDC reply
    //


    if (ARGUMENT_PRESENT(KdcReplyBody))
    {

        CacheEntry->TicketFlags = KerbConvertFlagsToUlong(&KdcReplyBody->flags);

        if (!KERB_SUCCESS(KerbDuplicateKey(
                            &CacheEntry->SessionKey,
                            &KdcReplyBody->session_key
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->StartTime,
                &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_starttime,
                NULL
                );
        }
        else
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->StartTime,
                &KdcReplyBody->authtime,
                NULL
                );
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->EndTime,
            &KdcReplyBody->endtime,
            NULL
            );



        if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->RenewUntil,
                &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_renew_until,
                NULL
                );
        }

        //
        // Check to see if the ticket has already expired
        //

        if (KerbTicketIsExpiring(CacheEntry, FALSE))
        {
            DebugLog((DEB_ERROR,"Tried to cache an already-expired ticket\n"));
            Status = STATUS_TIME_DIFFERENCE_AT_DC;
            goto Cleanup;
        }


    }

    //
    // Fill in the FullServiceName which is the domain name concatenated with
    // the service name.
    //
    // The full service name is domain name '\' service name.
    //

    //
    // Fill in the domain name and service name separately in the
    // cache entry, using the FullServiceName buffer.
    //



    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                        &CacheEntry->DomainName,
                        &KdcReply->ticket.realm
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                        &CacheEntry->ServiceName,
                        &KdcReply->ticket.server_name
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Extract the realm name from the principal name
    //

    Status = KerbExtractDomainName(
                &CacheEntry->TargetDomainName,
                CacheEntry->ServiceName,
                &CacheEntry->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // The reply need not include the name
    //

    if (KdcReply->client_realm != NULL)
    {
        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                    &CacheEntry->ClientDomainName,
                    &KdcReply->client_realm)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Fill in the target name the client provided, which may be
    // different then the service name
    //

    if (ARGUMENT_PRESENT(TargetName))
    {
        Status = KerbDuplicateKdcName(
                    &CacheEntry->TargetName,
                    TargetName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(TargetDomainName))
    {
        Status = KerbDuplicateString(
                    &CacheEntry->AltTargetDomainName,
                    TargetDomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Store the client name so we can use the right name
    // in later requests.
    //

    if (KdcReply->client_name.name_string != NULL)

    {
        if (!KERB_SUCCESS( KerbConvertPrincipalNameToKdcName(
                &CacheEntry->ClientName,
                &KdcReply->client_name)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    if (!KERB_SUCCESS(KerbDuplicateTicket(
                        &CacheEntry->Ticket,
                        &KdcReply->ticket
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Set the number of references equal to 2 - one for the ticket cache
    // and one for the returned pointer
    //

    CacheEntry->ListEntry.ReferenceCount = 1;

    CacheEntry->CacheFlags = CacheFlags;

    //
    // Before we insert this ticket we want to remove any
    // previous instances of tickets to the same service.
    //
    if (LinkEntry)
    {

        PKERB_TICKET_CACHE_ENTRY OldCacheEntry = NULL;

        if ((CacheFlags & (KERB_TICKET_CACHE_DELEGATION_TGT |
                           KERB_TICKET_CACHE_PRIMARY_TGT)) != 0)
        {
            OldCacheEntry = KerbLocateTicketCacheEntryByRealm(
                                TicketCache,
                                NULL,
                                CacheFlags
                                );
        }
        else
        {
            OldCacheEntry = KerbLocateTicketCacheEntry(
                                TicketCache,
                                CacheEntry->ServiceName,
                                &CacheEntry->DomainName
                                );
        }
        if (OldCacheEntry != NULL)
        {
            OldCacheFlags = OldCacheEntry->CacheFlags;
            KerbRemoveTicketCacheEntry( OldCacheEntry );
            KerbDereferenceTicketCacheEntry( OldCacheEntry );
            OldCacheEntry = NULL;
        }

        //
        // If the old ticket was the primary TGT, mark this one as the
        // primary TGT as well.
        //


        CacheEntry->CacheFlags |= (OldCacheFlags &
                                    (KERB_TICKET_CACHE_DELEGATION_TGT |
                                    KERB_TICKET_CACHE_PRIMARY_TGT));



        //
        // Insert the cache entry into the cache
        //

        KerbInsertTicketCacheEntry(
            TicketCache,
            CacheEntry
            );

    }

    //
    // Update the statistics
    //

    UpdateCacheMisses();

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != CacheEntry)
        {
            KerbFreeTicketCacheEntry(CacheEntry);
        }
    }

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicketCache
//
//  Synopsis:   Purges a cache of all its tickets
//
//  Effects:    unreferences all tickets in the cache
//
//  Arguments:  Cache - Ticket cache to purge
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbPurgeTicketCache(
    IN PKERB_TICKET_CACHE Cache
    )
{
    PKERB_TICKET_CACHE_ENTRY CacheEntry;

    KerbWriteLockTicketCache();
    while (!IsListEmpty(&Cache->CacheEntries))
    {
        CacheEntry = CONTAINING_RECORD(
                        Cache->CacheEntries.Flink,
                        KERB_TICKET_CACHE_ENTRY,
                        ListEntry.Next
                        );

        KerbRemoveTicketCacheEntry(
            CacheEntry
            );
    }

    KerbUnlockTicketCache();
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateTicketCacheEntry
//
//  Synopsis:   References a ticket cache entry by name
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCache - the ticket cache to search
//              FullServiceName - Optionally contains full service name
//                      of target, including domain name. If it is NULL,
//                      then the first element in the list is returned.
//              RealmName - Realm of service name. If length is zero, is not
//                      used for comparison.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------


PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_INTERNAL_NAME FullServiceName,
    IN PUNICODE_STRING RealmName
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;
    BOOLEAN Remove = FALSE;

    KerbReadLockTicketCache();

    //
    // Go through the ticket cache looking for the correct entry
    //

    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);
        if (!ARGUMENT_PRESENT(FullServiceName) ||
            KerbEqualKdcNames(
                CacheEntry->ServiceName,
                FullServiceName
                ) ||
            ((CacheEntry->TargetName != NULL) &&
             KerbEqualKdcNames(
                CacheEntry->TargetName,
                FullServiceName
                ) ) )
        {
            //
            // Make sure they are principals in the same realm
            //

            if ((RealmName->Length != 0) &&
                !RtlEqualUnicodeString(
                    RealmName,
                    &CacheEntry->DomainName,
                    TRUE                                // case insensitive
                    ) &&
                !RtlEqualUnicodeString(
                    RealmName,
                    &CacheEntry->AltTargetDomainName,
                    TRUE                                // case insensitive
                    ))
            {
                continue;
            }


            //
            // We don't want to return any special tickets.
            //

            if (CacheEntry->CacheFlags != 0)
            {
                continue;
            }

            //
            // Check to see if the entry has expired, or is not yet valid. If it has, just
            // remove it now.
            //

            if (KerbTicketIsExpiring(CacheEntry, FALSE ))
            {
                Remove = TRUE;
                Found = FALSE;
            }
            else
            {
                Found = TRUE;
            }

            KerbReferenceTicketCacheEntry(CacheEntry);

            break;
        }

    }

    KerbUnlockTicketCache();

    if (Remove)
    {
        KerbRemoveTicketCacheEntry(CacheEntry);
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    //
    // Update the statistics
    //

    if (Found)
    {
        UpdateCacheHits();
    }
    else
    {
        UpdateCacheMisses();
    }

    return(CacheEntry);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateTicketCacheEntryByRealm
//
//  Synopsis:   References a ticket cache entry by realm name. This is used
//              only for the cache of TGTs
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCache - the ticket cache to search
//              RealmName - Optioanl realm of ticket - if NULL looks for
//                      initial ticket
//              RequiredFlags - any ticket cache flags the return ticket must
//                      have. If the caller asks for a primary TGT, then this
//                      API won't do expiration checking.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//              We we weren't given a RealmName, then we need to look
//              through the whole list for the ticket.
//
//
//--------------------------------------------------------------------------


PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntryByRealm(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PUNICODE_STRING RealmName,
    IN ULONG RequiredFlags
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE, NoRealmSupplied = FALSE;
    BOOLEAN Remove = FALSE;

    NoRealmSupplied = ((RealmName == NULL) || (RealmName->Length == 0));

    KerbReadLockTicketCache();

    //
    // Go through the ticket cache looking for the correct entry
    //

    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);

        //
        // Match if the caller supplied no realm name, the realm matches the
        // target domain name, or it matches the alt target domain name
        //

        if (((RealmName == NULL) || (RealmName->Length == 0)) ||
            ((CacheEntry->TargetDomainName.Length != 0) &&
            RtlEqualUnicodeString(
                &CacheEntry->TargetDomainName,
                RealmName,
                TRUE
                )) ||
            ((CacheEntry->AltTargetDomainName.Length != 0) &&
             RtlEqualUnicodeString(
                &CacheEntry->AltTargetDomainName,
                RealmName,
                TRUE
                )) )
        {

            //
            // Check the required flags are set.
            //

            if (((CacheEntry->CacheFlags & RequiredFlags) != RequiredFlags) ||
                (((CacheEntry->CacheFlags & KERB_TICKET_CACHE_DELEGATION_TGT) != 0) &&
                 ((RequiredFlags & KERB_TICKET_CACHE_DELEGATION_TGT) == 0)))
            {
                Found = FALSE;
                //
                // We need to continue looking
                //
                continue;

            }

            //
            // Check to see if the entry has expired. If it has, just
            // remove it now.
            //

            if (KerbTicketIsExpiring(CacheEntry, FALSE ))
            {
                //
                // if this is not the primary TGT, go ahead and remove it. We
                // want to save the primary TGT so we can renew it.
                //

                if ((CacheEntry->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT) == 0)
                {
                    Remove = TRUE;
                    Found = FALSE;
                }
                else
                {
                    //
                    // If the caller was asking for the primary TGT,
                    // return it whether or not it expired.
                    //

                    if ((RequiredFlags & KERB_TICKET_CACHE_PRIMARY_TGT) != 0 )
                    {
                        Found = TRUE;
                    }
                    else
                    {
                        Found = FALSE;
                    }
                }

                if ( Remove || Found )
                {
                    KerbReferenceTicketCacheEntry(CacheEntry);
                }
            }
            else
            {
                KerbReferenceTicketCacheEntry(CacheEntry);

                Found = TRUE;
            }

            break;

        }

    }

    KerbUnlockTicketCache();

    if (Remove)
    {
        KerbRemoveTicketCacheEntry(CacheEntry);
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    //
    // Update the statistics
    //

    if (Found)
    {
        UpdateCacheHits();
    }
    else
    {
        UpdateCacheMisses();
    }

    return(CacheEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTicketIsExpiring
//
//  Synopsis:   Check if a ticket is expiring
//
//  Effects:
//
//  Arguments:  CacheEntry - Entry to check
//              AllowSkew - Expire ticket that aren't outside of skew of
//                      expiring
//
//  Requires:
//
//  Returns:
//
//  Notes:      Ticket cache lock must be held
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbTicketIsExpiring(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOLEAN AllowSkew
    )
{
    TimeStamp CutoffTime;

    GetSystemTimeAsFileTime((PFILETIME) &CutoffTime);


    //
    // We want to make sure we have at least skewtime left on the ticket
    //

    if (AllowSkew)
    {
        KerbSetTime(&CutoffTime, KerbGetTime(CutoffTime) + KerbGetTime(KerbGlobalSkewTime));
    }

    //
    // Adjust for server skew time.
    //

    KerbSetTime(&CutoffTime, KerbGetTime(CutoffTime) + KerbGetTime(CacheEntry->TimeSkew));

    if (KerbGetTime(CacheEntry->EndTime) < KerbGetTime(CutoffTime))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetTicketCacheEntryTarget
//
//  Synopsis:   Sets target name for a cache entry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



VOID
KerbSetTicketCacheEntryTarget(
    IN PUNICODE_STRING TargetName,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    KerbWriteLockTicketCache();
    KerbFreeString(&TicketCacheEntry->AltTargetDomainName);
    KerbDuplicateString(
        &TicketCacheEntry->AltTargetDomainName,
        TargetName
        );

    KerbUnlockTicketCache();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\tktlogon.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktlogon.h
//
// Contents:    Structures and prototypes for ticket logon
//
//
// History:     17-February-1999    Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TKTLOGON_H__
#define __TKTLOGON_H__


NTSTATUS
KerbExtractForwardedTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN PKERB_ENCRYPTED_TICKET WorkstationTicket
    );

NTSTATUS
KerbCreateTicketLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession,
    OUT PLUID LogonId,
    OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
    OUT PKERB_MESSAGE_BUFFER ForwardedTgt
    );


#endif // __TKTLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\userapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.h
//
// Contents:    Structures and prototypes for user mode Kerberos functions
//
//
// History:     3-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __USERAPI_H__
#define __USERAPI_H__

#include "krbprgma.h"
#include <gssapiP.h>

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef USERAPI_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // USERAPI_ALLOCATE


#ifndef WIN32_CHICAGO
EXTERN PSID KerbGlobalLocalSystemSid;
EXTERN PSID KerbGlobalAliasAdminsSid;
#endif // WIN32_CHICAGO

extern gss_OID_desc * gss_mech_krb5;
extern gss_OID_desc * gss_mech_krb5_new;
extern gss_OID_desc * gss_mech_krb5_u2u;
extern gss_OID_desc * gss_mech_krb5_spnego;


typedef struct _KERB_GSS_SIGNATURE {
    BYTE SignatureAlgorithm[2];           // see below table for values
    union {
        BYTE SignFiller[4];               // filler, must be ff ff ff ff
        struct {
            BYTE SealAlgorithm[2];
            BYTE SealFiller[2];
        };
    };
    BYTE SequenceNumber[8];
    BYTE Checksum[8];
} KERB_GSS_SIGNATURE, *PKERB_GSS_SIGNATURE;

#define KERB_GSS_SIG_CONFOUNDER_SIZE    8

typedef struct _KERB_GSS_SEAL_SIGNATURE {
    KERB_GSS_SIGNATURE Signature;
    BYTE Confounder[KERB_GSS_SIG_CONFOUNDER_SIZE];
} KERB_GSS_SEAL_SIGNATURE, *PKERB_GSS_SEAL_SIGNATURE;

typedef ULONG KERB_NULL_SIGNATURE, *PKERB_NULL_SIGNATURE;



//
// This value goes in the second bye of the signature algorithm
//

#define KERB_GSS_SIG_SECOND 0x00

//
// These values go in the first byte
//

#define KERB_GSS_SIG_DES_MAC_MD5        0x00
#define KERB_GSS_SIG_MD25               0x01
#define KERB_GSS_SIG_DES_MAC            0x02


#define KERB_GSS_SIG_HMAC               0x11

//
// These are sealing algorithm values
//

#define KERB_GSS_SEAL_DES_CBC           0x00
#define KERB_GSS_SEAL_RC4_OLD           0x11
#define KERB_GSS_SEAL_RC4               0x10
#define KERB_GSS_NO_SEAL                0xff
#define KERB_GSS_NO_SEAL_SECOND         0xff

//
// These are the flags passed in to MakeSignature and VerifySignature
// corresponding to the above flags, taken from RFC 1964
//

#define GSS_KRB5_INTEG_C_QOP_DEFAULT    0x0
#define GSS_KRB5_INTEG_C_QOP_MD5        0x1
#define GSS_KRB5_INTEG_C_QOP_DES_MD5    0x2
#define GSS_KRB5_INTEG_C_QOP_DES_MAC    0x3


/** constants **/

#define CKSUMTYPE_KG_CB         0x8003

#define KG_TOK_CTX_AP_REQ       0x0100
#define KG_TOK_CTX_AP_REP       0x0200
#define KG_TOK_CTX_ERROR        0x0300
#define KG_TOK_SIGN_MSG         0x0101
#define KG_TOK_SEAL_MSG         0x0201
#define KG_TOK_MIC_MSG          0x0101
#define KG_TOK_WRAP_MSG         0x0201
#define KG_TOK_DEL_CTX          0x0102
#define KG_TOK_CTX_TGT_REQ      0x0400
#define KG_TOK_CTX_TGT_REP      0x0401

#define KRB5_GSS_FOR_CREDS_OPTION 1

#define KERB_SIGN_FLAGS (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)

#define KERB_IS_DES_ENCRYPTION(_x_) ((((_x_) >= KERB_ETYPE_DES_CBC_CRC) && \
                                      ((_x_) <= KERB_ETYPE_DES_CBC_MD5)) || \
                                     ((_x_) == KERB_ETYPE_DES_PLAIN))
#endif // __USERAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\userlist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        userlist.cxx
//
// Contents:    Routines for logging a client with a PAC onto an existing
//              NT account.
//
//
// History:     21-Febuary-1997         Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#ifndef WIN32_CHICAGO
extern "C"
{
#include <samrpc.h>
#include <lsaisrv.h>
#include <samisrv.h>
}
#include <userall.h>

//+-------------------------------------------------------------------------
//
//  Function:   KerbReadRegistryString
//
//  Synopsis:   Reads & allocates a string from the registry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the value was found
//              STATUS_NO_SUCH_USER - the value was not found
//              STATUS_INSUFFICIENT_RESOURCES - memory allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbReadRegistryString(
    IN HKEY Key,
    IN LPWSTR Value,
    IN OUT PUNICODE_STRING String
    )
{
    ULONG Type;
    ULONG WinError = ERROR_SUCCESS;
    ULONG StringSize = 0;
    NTSTATUS Status = STATUS_NO_SUCH_USER;

    WinError = RegQueryValueEx(
                Key,
                Value,
                NULL,
                &Type,
                NULL,
                &StringSize
                );
    if ((WinError == ERROR_MORE_DATA) || (WinError == ERROR_SUCCESS))
    {
        //
        // The value exists - get the name from it
        //

        String->Buffer = (LPWSTR) KerbAllocate(StringSize);
        if (String->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        WinError = RegQueryValueEx(
                    Key,
                    Value,
                    NULL,
                    &Type,
                    (PUCHAR) String->Buffer,
                    &StringSize
                    );
        if (WinError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        RtlInitUnicodeString(
            String,
            String->Buffer
            );
        Status = STATUS_SUCCESS;
    }

Cleanup:
    if (!NT_SUCCESS(Status) && (String->Buffer != NULL))
    {
        KerbFreeString(String);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapClientName
//
//  Synopsis:   Maps a Kerberos client name to an NT user name. First it
//              tries converting the name to a string and looking for a
//              value with that name. If that fails, it looks for a
//              value with the client realm name.
//
//  Effects:
//
//  Arguments:  MappedName - receives the name of the local account the
//                      client maps to
//              ClientName - Kerberos principal name of the client
//              ClientRealm - Kerberos realm of the client
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapClientName(
    OUT PUNICODE_STRING MappedName,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    )
{

    LPWSTR UserName = NULL;
    DWORD WinError;
    NTSTATUS Status = STATUS_NO_SUCH_USER;
    HKEY Key = NULL;
    UNICODE_STRING ClientString = {0};

    EMPTY_UNICODE_STRING( MappedName );


    //
    // First convert the MIT client name to a registry value name. We do
    // this by adding a '/' between every component of the client name
    // and appending "@ClientRealm"
    //

    //
    // Make sure the client realm is null terminated
    //

    DsysAssert(ClientRealm->Length == 0 || (ClientRealm->MaximumLength >= ClientRealm->Length + sizeof(WCHAR)));
    DsysAssert(ClientRealm->Length == 0 || (ClientRealm->Buffer[ClientRealm->Length/sizeof(WCHAR)] == L'\0'));

    //
    // The value length is the length of all the components of the names,
    // all the '/' separtors, and the name of the domain name plus '@'
    //


    if (!KERB_SUCCESS(KerbConvertKdcNameToString(
            &ClientString,
            ClientName,
            ClientRealm)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Mapping client name %wZ\n",&ClientString ));

    //
    // Also build just the username, which is used when users are mapped
    // back to their own name
    //

    UserName = (LPWSTR) KerbAllocate(ClientName->Names[0].Length + sizeof(WCHAR));
    if (UserName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlCopyMemory(
        UserName,
        ClientName->Names[0].Buffer,
        ClientName->Names[0].Length
        );
    UserName[ClientName->Names[0].Length / sizeof(WCHAR)] = L'\0';

    //
    // Now check the registry for a mapping for this name
    //

    WinError = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                KERB_USERLIST_KEY,
                &Key
                );
    if (WinError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Read out the value
    //

    Status = KerbReadRegistryString(
                Key,
                ClientString.Buffer,
                MappedName
                );
    if (Status == STATUS_NO_SUCH_USER)
    {

        //
        // Try again with just the domain name - this allows all users in
        // a domain to be mapped
        //
        Status = KerbReadRegistryString(
                    Key,
                    ClientRealm->Buffer,
                    MappedName
                    );

    }
    if (Status == STATUS_NO_SUCH_USER)
    {
        Status = KerbReadRegistryString(
                    Key,
                    KERB_ALL_USERS_VALUE,
                    MappedName
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the mapped name is '*', then use the client's name
    //

    if (_wcsicmp(MappedName->Buffer,KERB_MATCH_ALL_NAME) == 0)
    {
        KerbFree(MappedName->Buffer);
        RtlInitUnicodeString(
            MappedName,
            UserName
            );
        UserName = NULL;
    }


    Status = STATUS_SUCCESS;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(MappedName);
    }
    KerbFreeString(&ClientString);
    if (UserName != NULL)
    {
        KerbFree(UserName);
    }
    if (Key != NULL)
    {
        RegCloseKey(Key);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreatePacForKerbClient
//
//  Synopsis:   Creates a PAC structure for a kerb client without a PAC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreatePacForKerbClient(
    OUT PPACTYPE * Pac,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PUNICODE_STRING MappedClientName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    SAMPR_HANDLE SamHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_GET_GROUPS_BUFFER Groups = NULL;
    SID_AND_ATTRIBUTES_LIST TransitiveGroups = {0};
    PSAMPR_USER_INFO_BUFFER UserInfo = NULL;
    PPACTYPE LocalPac = NULL;
    SAMPR_ULONG_ARRAY RidArray;
    SAMPR_ULONG_ARRAY UseArray;
    SECPKG_CLIENT_INFO ClientInfo;

    //
    // local variables containing copy of globals.
    //

    UNICODE_STRING LocalMachineName;
    UNICODE_STRING LocalDomainName;
    UNICODE_STRING LocalAccountName = NULL_UNICODE_STRING;
    KERBEROS_MACHINE_ROLE LocalRole = KerbRoleWorkstation;
    BOOLEAN GlobalsLocked = FALSE;

    RidArray.Element = NULL;
    UseArray.Element = NULL;

    LocalMachineName.Buffer = NULL;
    LocalDomainName.Buffer = NULL;

    //
    // Verify that the caller has TCB privilege. Otherwise anyone can forge
    // a ticket to themselves to logon with any name in the list.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (!ClientInfo.HasTcbPrivilege)
    {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // If we are a domain controller, call SAM to do the mapping.
    // Otherwise, do it ourselves.
    //

    //
    // Common code for both wksta and DC - open SAM
    // However, if we're a realmless wksta, we know we have a client 
    // mapping to a local account so skip lookup on DC
    //

    //
    // Call the LSA to get our domain sid
    //

            
    Status = LsaIQueryInformationPolicyTrusted(
                    PolicyAccountDomainInformation,
                    &PolicyInfo
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Open SAM to get the account information
    //


    Status = SamIConnect(
                NULL,                   // no server name
                &SamHandle,
                0,                      // no desired access
                TRUE                    // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrOpenDomain(
                    SamHandle,
                    0,                      // no desired access
                    (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                    &DomainHandle
                    );
            
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // grab the globals while holding the lock.
    // ... then release the lock prior to making the call!
    //

    KerbGlobalReadLock();
    GlobalsLocked = TRUE;

    LocalRole = KerbGlobalRole;

    Status = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }

    if( LocalRole == KerbRoleDomainController ) 
    {
        Status = KerbDuplicateString( &LocalDomainName, &KerbGlobalDomainName );
        if(!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalDomainName\n"));
            goto Cleanup;
        }
    }

    KerbGlobalReleaseLock();
    GlobalsLocked = FALSE;

    //
    // If the is a DC, try to look up the name in SAM as an AltSecId.
    // If that fails, we will try looking at the registry mapping.
    //

    if (LocalRole == KerbRoleDomainController)
    {
        UNICODE_STRING AltSecId = {0};
        KERBERR KerbErr;

        KerbErr = KerbBuildAltSecId(
                        &AltSecId,
                        ClientName,
                        NULL,               // no unicode realm
                        ClientRealm
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        Status = SamIGetUserLogonInformationEx(
                        SamHandle,
                        SAM_OPEN_BY_ALTERNATE_ID,
                        &AltSecId,
                        USER_ALL_PAC_INIT,
                        &UserInfo,
                        &TransitiveGroups,
                        NULL                // no user handle
                        );

        KerbFreeString(&AltSecId);

    }
    
     

    if (!NT_SUCCESS(Status) || (UserInfo == NULL))
    {
        if (!ARGUMENT_PRESENT(MappedClientName) || MappedClientName->Buffer == NULL)
        {   
            Status = KerbMapClientName(
                        &LocalAccountName,
                        ClientName,
                        ClientRealm
                        );
        
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            KerbDuplicateString(
                    &LocalAccountName,
                    MappedClientName
                    );               

        }

    
        Status = SamrLookupNamesInDomain(
                    DomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) &LocalAccountName,
                    &RidArray,
                    &UseArray
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if ((UseArray.Element[0] != SidTypeUser) &&
            (UseArray.Element[0] != SidTypeComputer))
        {
            Status = STATUS_NONE_MAPPED;
            goto Cleanup;
        }

        //
        // Finally open the user
        //
        Status = SamrOpenUser(
                    DomainHandle,
                    0,                      // no desired access,
                    RidArray.Element[0],
                    &UserHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Status = SamrQueryInformationUser(
                    UserHandle,
                    UserAllInformation,
                    &UserInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SamrGetGroupsForUser(
                    UserHandle,
                    &Groups
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


    }

    //
    // This is common code
    //


    //
    // Set the password must changes time to inifinite because we don't
    // want spurious password must change popups
    //

    UserInfo->All.PasswordMustChange = *(POLD_LARGE_INTEGER) &KerbGlobalWillNeverTime;

    //
    // Finally build the PAC
    //


    Status = PAC_Init(
                &UserInfo->All,
                Groups,
                &TransitiveGroups,   // no extra groups
                PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                ((LocalRole == KerbRoleDomainController) ?
                    &LocalDomainName : &LocalMachineName),
                &LocalMachineName,
                0,      // no signature
                0,      // no additional data
                NULL,   // no additional data
                &LocalPac
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *Pac = LocalPac;
    LocalPac = NULL;

Cleanup:

    if( GlobalsLocked )
    {
        KerbGlobalReleaseLock();
    }

    KerbFreeString( &LocalMachineName );
    KerbFreeString( &LocalDomainName );
    KerbFreeString( &LocalAccountName );
    

    if (UserHandle != NULL)
    {
        SamrCloseHandle( &UserHandle );
    }
    if (DomainHandle != NULL)
    {
        SamrCloseHandle( &DomainHandle );
    }
    if (SamHandle != NULL)
    {
        SamrCloseHandle( &SamHandle );
    }
    if (Groups != NULL)
    {
        SamIFree_SAMPR_GET_GROUPS_BUFFER( Groups );
    }

    SamIFreeSidAndAttributesList(&TransitiveGroups);

    if (UserInfo != NULL)
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserInfo, UserAllInformation );
    }
    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            PolicyInfo
            );
    }
    SamIFree_SAMPR_ULONG_ARRAY( &UseArray );
    SamIFree_SAMPR_ULONG_ARRAY( &RidArray );

    if (LocalPac != NULL)
    {
        MIDL_user_free(LocalPac);
    }

    return(Status);

}
#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
*/

#include <kerb.hxx>

#define USERAPI_ALLOCATE
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#ifndef WIN32_CHICAGO
extern "C"
{
#include <cryptdll.h>
}
#endif // WIN32_CHICAGO
#include "userapi.h"

#define DONT_SUPPORT_OLD_TYPES_USER 1

// can't sign or seal messages greater than this
#define KERB_MAX_MESSAGE_SIZE 0x40000000
//
// Common GSS object IDs, taken from MIT kerberos distribution.
//

gss_OID_desc oids[] = {
    {5, "\053\005\001\005\002"},                      // original mech id
    {9, "\052\206\110\206\367\022\001\002\002"},      // standard mech id
    {10, "\052\206\110\206\367\022\001\002\002\001"}, // krb5_name type
    {10, "\052\206\110\206\367\022\001\002\002\002"}, // krb5_principal type
    {10, "\052\206\110\206\367\022\001\002\002\003"}, // user2user mech id
    {9, "\052\206\110\202\367\022\001\002\002"},      // bogus mangled OID from spnego
};

gss_OID_desc * gss_mech_krb5 = oids;
gss_OID_desc * gss_mech_krb5_new = oids+1;
gss_OID_desc * gss_mech_krb5_u2u = oids+4;
gss_OID_desc * gss_mech_krb5_spnego = oids+5;

#ifndef WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Returns table of usermode functions to caller
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    SUCCESS if version is correct
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d. %ws, line %d\n", LsaVersion, THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    KerberosUserFunctionTable.InstanceInit = SpInstanceInit;
    KerberosUserFunctionTable.MakeSignature = SpMakeSignature;
    KerberosUserFunctionTable.VerifySignature = SpVerifySignature;
    KerberosUserFunctionTable.SealMessage = SpSealMessage;
    KerberosUserFunctionTable.UnsealMessage = SpUnsealMessage;
    KerberosUserFunctionTable.GetContextToken = SpGetContextToken;
    KerberosUserFunctionTable.QueryContextAttributes = SpQueryContextAttributes;
    KerberosUserFunctionTable.CompleteAuthToken = SpCompleteAuthToken;
    KerberosUserFunctionTable.InitUserModeContext = SpInitUserModeContext;
    KerberosUserFunctionTable.DeleteUserModeContext = SpDeleteUserModeContext;
    KerberosUserFunctionTable.FormatCredentials = SpFormatCredentials;
    KerberosUserFunctionTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    KerberosUserFunctionTable.ExportContext = SpExportSecurityContext;
    KerberosUserFunctionTable.ImportContext = SpImportSecurityContext;

    *pcTables = 1;


    *UserFunctionTable = &KerberosUserFunctionTable;

    return( STATUS_SUCCESS );

}
#endif // WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the Kerberos package in a client's
//              address space
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by Kerberos
//              UserFunctions - Receives a copy of Kerberos's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!KerbGlobalInitialized)
    {
#ifndef WIN32_CHICAGO
    KerbInitializeDebugging();

#endif // WIN32_CHICAGO

        KerberosState = KerberosUserMode;


        Status = KerbInitContextList();
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to initialize context list: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }


    }
    else
    {
        D_DebugLog((DEB_TRACE,"Re-initializing kerberos from LSA mode to User Mode\n"));
    }

    UserFunctions = DllFunctionTable;

#ifndef WIN32_CHICAGO
    //
    // Build the two well known sids we need.
    //

    if( KerbGlobalLocalSystemSid == NULL )
    {
        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &KerbGlobalLocalSystemSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if( KerbGlobalAliasAdminsSid == NULL )
    {
        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,0,0,0,0,0,
                    &KerbGlobalAliasAdminsSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO


    KerbGlobalInitialized = TRUE;

Cleanup:

    if( !KerbGlobalInitialized && !NT_SUCCESS(Status) )
    {
        if( KerbGlobalLocalSystemSid != NULL )
        {
            RtlFreeSid( KerbGlobalLocalSystemSid );
            KerbGlobalLocalSystemSid = NULL;
        }

        if( KerbGlobalAliasAdminsSid != NULL )
        {
            RtlFreeSid( KerbGlobalAliasAdminsSid );
            KerbGlobalAliasAdminsSid = NULL;
        }
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located, SEC_I_NO_LSA_CONTEXT if this was
//              created from an exported context
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpDeleteUserModeContext called\n"));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                TRUE,
                &Context                // unlink it
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle));
        return(STATUS_SUCCESS); // no error code should be returned in this case
    }

    //
    // Make sure we don't try to call the LSA to delete imported contexts
    //

    KerbReadLockContexts();
    if ((Context->ContextAttributes & KERB_CONTEXT_IMPORTED) != 0)
    {
        Status = SEC_I_NO_LSA_CONTEXT;
    }
    KerbUnlockContexts();

    KerbDereferenceContext(
        Context
        );

    D_DebugLog((DEB_TRACE_API, "SpDeleteUserModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpInitUserModeContext called\n"));

    Status = KerbCreateUserModeContext(
                ContextHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create user mode context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    D_DebugLog((DEB_TRACE_API, "SpInitUserModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    PKERB_CONTEXT Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN MappedContext = FALSE;


    D_DebugLog((DEB_TRACE_API,"SpExportContext Called\n"));
    D_DebugLog((DEB_TRACE_USER,"Exporting context 0x%p, flags 0x%x\n",ContextHandle, Flags));

    //
    // We don't support reseting the context
    //

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for ExportSecurityContext(%p) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbMapContext(
                Context,
                &MappedContext,
                PackedContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    DsysAssert(MappedContext);

    //
    // We need to figure out if this was exported
    //

    ((PKERB_CONTEXT)PackedContext->pvBuffer)->ContextAttributes |= KERB_CONTEXT_EXPORTED;
    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        KerbWriteLockContexts();
        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *TokenHandle = Context->TokenHandle;
            Context->TokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->TokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }
        KerbUnlockContexts();

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpExportSecurityContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpImportSecurityContext called\n"));

    Status = KerbCreateUserModeContext(
                0,              // no lsa context
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create user mode context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    KerbWriteLockContexts();
    Context->TokenHandle = Token;
    Context->ContextAttributes |= KERB_CONTEXT_IMPORTED;




    *ContextHandle = KerbGetContextHandle(Context);
//    Context->LsaContextHandle = *ContextHandle;

    KerbUnlockContexts();

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpImportSecurityContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    D_DebugLog((DEB_TRACE_USER," Imported Context handle = 0x%x\n",*ContextHandle));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetChecksumAndEncryptionType
//
//  Synopsis:   Gets the ChecksumType and the EncryptionType
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              ChecksumType - Receives the type of checksum to use
//              EncryptionType - Receives the type of encryption to use
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetChecksumAndEncryptionType(
    IN PKERB_CONTEXT Context,
    IN ULONG QualityOfProtection,
    OUT PULONG ChecksumType,
    OUT PULONG EncryptionType
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {

#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN;
        }
        else
        {
            DsysAssert (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        }
    }
    else
    {
        //
        // Use the exportable version if necessasry
        //

        *EncryptionType = KERB_ETYPE_DES_PLAIN;

        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            *ChecksumType = KERB_CHECKSUM_MD25;
            break;
        case KERB_WRAP_NO_ENCRYPT:
        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            *ChecksumType = KERB_CHECKSUM_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d. %ws, line %d\n",
                QualityOfProtection, THIS_FILE, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignatureToken
//
//  Synopsis:   Makes the signature token for a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              SignatureBuffer - Buffer in which to place signature
//              TotalBufferSize - Total size of all buffers to be signed
//              Encrypt - if TRUE, then prepare a header for an encrypted buffer
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_SIGNATURE Signature;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    ULONG MessageSize;
    ULONG SignatureSize;
    PULONG Nonce;
    gss_OID MechUsed;
    BOOLEAN GssCompatible = TRUE;

    //
    // Compute the size of the header. For encryption headers, we need
    // to round up the size of the data & add 8 bytes for a confounder.
    //

    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0 ||
        (Context->ContextFlags & ISC_RET_DATAGRAM) != 0)
    {
        GssCompatible = FALSE;
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!GssCompatible || !Encrypt)
    {
        TotalBufferSize = 0;
    }

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }
    if (Encrypt)
    {
        //
        // NOTE: according to rfc1964, buffers that are an even multiple of
        // 8 bytes have 8 bytes of zeros appended. Because we cannot modify
        // the input buffers, the caller will have to do this for us.
        //


        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SEAL_SIGNATURE);
    }
    else
    {
        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SIGNATURE);
    }

    SignatureSize = g_token_size(MechUsed, MessageSize) - TotalBufferSize;


    //
    // Make Dave happy (verify that the supplied signature buffer is large
    // enough for a signature):
    //

    if (SignatureBuffer->cbBuffer < SignatureSize)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }


    //
    // create the header with the GSS oid
    //

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    g_make_token_header(
        MechUsed,
        MessageSize,
        (PUCHAR *) &Signature,
        (Encrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG)
        );


    //
    // Fill in the header information according to RFC1964
    //



    Signature->SignatureAlgorithm[1] = KERB_GSS_SIG_SECOND;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {


#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }
        else
        {
            DsysAssert (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }

        //
        // if we aren't actually encrypting, reset the encryption alg
        //

        if (QualityOfProtection == KERB_WRAP_NO_ENCRYPT)
        {
            if (!Encrypt)
            {
                DebugLog((DEB_ERROR,"KERB_WRAP_NO_ENCRYPT flag passed to MakeSignature!\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // In this case use the default, but we will not encrypt
            //

            Signature->SealAlgorithm[1] = KERB_GSS_NO_SEAL_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_NO_SEAL;

        }
    }
    else
    {
        if (Encrypt)
        {
            Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_SEAL_DES_CBC;

        }

        //
        // Use the exportable version if necessasry
        //

        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_MD25;
            break;
        case KERB_WRAP_NO_ENCRYPT:
            if (!Encrypt)
            {
                DebugLog((DEB_ERROR,"KERB_WRAP_NO_ENCRYPT flag passed to MakeSignature!\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // In this case use the default, but we will not encrypt
            //

            Signature->SealAlgorithm[1] = KERB_GSS_NO_SEAL_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_NO_SEAL;

        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d. %ws, line %d\n",
                QualityOfProtection, THIS_FILE, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    }

    //
    // Put in the filler - it is different for signing & sealing
    //

    if (Encrypt)
    {
        memset(Signature->SealFiller,0xff,2);
    }
    else
    {
        memset(Signature->SignFiller,0xff,4);
    }

    //
    // Inbound contexts get a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    Nonce = &Context->Nonce;

    if (Context->ContextAttributes & KERB_CONTEXT_INBOUND)
    {
        *(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) = 0xffffffff;


    }
    else
    {
        DsysAssert((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0);
        *(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) = 0x00000000;
    }

    //
    // If this is datagram, or integrity without replay & sequence detection,
    // use the nonce from the caller
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))

    {
        Nonce = &SuppliedNonce;
    }

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {
        Signature->SequenceNumber[0] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
        Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
        Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
        Signature->SequenceNumber[3] = (UCHAR)  (*Nonce & 0x000000ff);
    }
    else
    {
        Signature->SequenceNumber[3] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
        Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
        Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
        Signature->SequenceNumber[0] = (UCHAR)  (*Nonce & 0x000000ff);
    }

    (*Nonce)++;


    *SequenceNumber = *(ULONG UNALIGNED *)Signature->SequenceNumber;

    D_DebugLog((DEB_TRACE_USER,"Makign signature buffer (encrypt = %d) with nonce 0x%x\n",
        Encrypt,
        *SequenceNumber
        ));

    //
    // If we are encrypting, add the confounder to the end of the signature
    //

    if (Encrypt)
    {
        SealSignature = (PKERB_GSS_SEAL_SIGNATURE) Signature;
        KerbRandomFill(
            SealSignature->Confounder,
            KERB_GSS_SIG_CONFOUNDER_SIZE
            );
    }
    //
    // Set the size of the signature
    //

    SignatureBuffer->cbBuffer = SignatureSize;
    *OutputSignature = Signature;

Cleanup:
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignatureToken
//
//  Synopsis:   Verifies the header on a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - context to use for verification
//              SignatureBuffer - Buffer containing signature
//              TotalBufferSize - Size of all buffers signed/encrypted
//              Decrypt - TRUE if we are unsealing
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              QualityOfProtection - returns GSS quality of protection flags
//              ChecksumType - Type of checksum used in this signature
//              EncryptionType - Type of encryption used in this signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PULONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SignatureSize = 0;
    UCHAR Nonce[8];
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    ULONG OutputSize;
    ULONG EncryptionType = 0;
    PCRYPTO_SYSTEM LocalCryptSystem = NULL ;
    PKERB_GSS_SIGNATURE Signature;
    PULONG ContextNonce;
    gss_OID MechUsed;

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Decrypt ||
       ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
       ((Context->ContextFlags & ISC_RET_DATAGRAM) != 0))
    {
        TotalBufferSize = 0;
    }


    //
    // Verify the signature header
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    if (!g_verify_token_header(
            MechUsed,
            (INT *) &SignatureSize,
            (PUCHAR *) &Signature,
            (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
            SignatureBuffer->cbBuffer + TotalBufferSize))
    {
        //Status = SEC_E_MESSAGE_ALTERED; bug 28448
        Status = SEC_E_INVALID_TOKEN; 
    }

    //
    // If that didn't work, try with the old mech. Need this is for DCE clients
    // for whom we can't tell what mech they use.
    //

    if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
    {
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                gss_mech_krb5,
                (INT *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
           //Status = SEC_E_MESSAGE_ALTERED; bug 28448
           Status = SEC_E_INVALID_TOKEN; 
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    //
    // MS RPC clients don't send the size properly, so set the total size
    // to zero and try again.
    //

    if (Decrypt && !NT_SUCCESS(Status))
    {
        TotalBufferSize = 0;
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                MechUsed,
                (INT *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
           //Status = SEC_E_MESSAGE_ALTERED; bug 28448
           Status = SEC_E_INVALID_TOKEN; 

        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        //
        // If that didn't work, try with the old mech. Need this is for DCE clients
        // for whom we can't tell what mech they use.
        //

        if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
            if (!g_verify_token_header(
                    gss_mech_krb5,
                    (INT *) &SignatureSize,
                    (PUCHAR *) &Signature,
                    (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                    SignatureBuffer->cbBuffer + TotalBufferSize))
            {
               //Status = SEC_E_MESSAGE_ALTERED; bug 28448
               Status = SEC_E_INVALID_TOKEN; 
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // Protection from bad Signature Size
    //

    if (SignatureSize == 0)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Subtract the total buffer size from Signature size to get the real
    // size of the signature.
    //

    SignatureSize -= TotalBufferSize;

    //
    // Make sure the signature is big enough. We can't enforce a strict
    // size because RPC will transmit the maximum number of bytes instead
    // of the actual number.
    //

    if ((Decrypt && (SignatureSize < sizeof(KERB_GSS_SEAL_SIGNATURE))) ||
        (!Decrypt && (SignatureSize < sizeof(KERB_GSS_SIGNATURE))))
    {
        //Status = SEC_E_MESSAGE_ALTERED; bug 28448
        Status = SEC_E_INVALID_TOKEN; 
        goto Cleanup;
    }

    //
    // Verify the sequence number
    //

    if (Signature->SignatureAlgorithm[1] != KERB_GSS_SIG_SECOND)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    //
    // Figure out the algorithm
    //

    switch(Context->SessionKey.keytype) {
    case KERB_ETYPE_DES_CBC_MD5:
    case KERB_ETYPE_DES_CBC_CRC:
        EncryptionType = KERB_ETYPE_DES_PLAIN;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        break;
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_NT:
        EncryptionType = KERB_ETYPE_RC4_PLAIN;
        break;
    default:
        DebugLog((DEB_ERROR,"Unknown key type: %d. %ws, %d\n",
           Context->SessionKey.keytype,
           THIS_FILE, __LINE__ ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // if the key is exportable, make sure to use the exportable plain
    // version.
    //


    switch(Signature->SignatureAlgorithm[0]) {
    case KERB_GSS_SIG_MD25:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_MD5;
        *ChecksumType = KERB_CHECKSUM_MD25;
        break;
    case KERB_GSS_SIG_DES_MAC_MD5:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MD5;
        *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
        break;
    case KERB_GSS_SIG_DES_MAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MAC;
        *ChecksumType = KERB_CHECKSUM_DES_MAC;
        break;
    case KERB_GSS_SIG_HMAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DEFAULT;
        *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
        break;
    default:
        DebugLog((DEB_ERROR,"Invalid signature type to VerifySignature: %d. %ws, line %d\n",
                Signature->SignatureAlgorithm[0], THIS_FILE, __LINE__ ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;

    }

    if (Decrypt)
    {
        if ((Signature->SealAlgorithm[1] == KERB_GSS_NO_SEAL_SECOND) &&
            (Signature->SealAlgorithm[0] == KERB_GSS_NO_SEAL))
        {
            *QualityOfProtection = KERB_WRAP_NO_ENCRYPT;
        }
        else
        {
            if (Signature->SealAlgorithm[1] != KERB_GSS_SIG_SECOND)
            {
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }

            //
            // Verify the seal algorithm
            //

            switch(EncryptionType) {
            case KERB_ETYPE_DES_PLAIN:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_DES_CBC)
                {
                    DebugLog((DEB_ERROR,"Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            case KERB_ETYPE_RC4_PLAIN_OLD_EXP:
            case KERB_ETYPE_RC4_PLAIN_OLD:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4_OLD)
                {
                    DebugLog((DEB_ERROR,"Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            case KERB_ETYPE_RC4_PLAIN_EXP:
            case KERB_ETYPE_RC4_PLAIN:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4)
                {
                    DebugLog((DEB_ERROR,"Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            default:
                DebugLog((DEB_ERROR,"Invalid seal type to VerifySignature: %d, %d. %ws, line %d\n",
                        Signature->SealAlgorithm[0], EncryptionType, THIS_FILE, __LINE__ ));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
        }

    }

    //
    // Check the filler
    //

    if ((Decrypt && (*(USHORT UNALIGNED *) Signature->SealFiller != 0xffff)) ||
        (!Decrypt && (*(ULONG UNALIGNED *) Signature->SignFiller != 0xffffffff)))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number. To do this we need to decrypt it with
    // the session key with the checksum as the IV.
    //


    Status = CDLocateCSystem(EncryptionType, &LocalCryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptionType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now we need to Decrypt the sequence number, using the checksum as the
    // IV
    //

    Status = LocalCryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                      // no flags
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = LocalCryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    OutputSize = 8;

    Status = LocalCryptSystem->Decrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // For datagram or integrity only, we use just the supplied nonce.
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))
    {
        ContextNonce = &SuppliedNonce;
    }
    else
    {
        ContextNonce = &Context->ReceiveNonce;
    }

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {
        Nonce[0] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
        Nonce[1] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
        Nonce[2] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
        Nonce[3] = (UCHAR)      (*ContextNonce & 0x000000ff);
    }
    else
    {
        Nonce[3] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
        Nonce[2] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
        Nonce[1] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
        Nonce[0] = (UCHAR)      (*ContextNonce & 0x000000ff);
    }

    *SequenceNumber = *(ULONG UNALIGNED *) Nonce;

    D_DebugLog((DEB_TRACE_USER,"Verifying signature buffer (decrypt = %d) with nonce 0x%x, message seq  0x%x\n",
        Decrypt,
        *(ULONG UNALIGNED *) Nonce,
        *(ULONG UNALIGNED *) Signature->SequenceNumber
        ));

    if (!RtlEqualMemory(
            Nonce,
            Signature->SequenceNumber,
            4))
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    (*ContextNonce)++;

    //
    // Inbound contexts send a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
    {
        if (*(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) != 0xffffffff)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }
    else
    {
        DsysAssert((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0);
        if (*(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) != 0)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(CryptSystem))
    {
        *CryptSystem = LocalCryptSystem;
    }

    *OutputSignature = Signature;

Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( LocalCryptSystem != NULL ) )
    {
        LocalCryptSystem->Discard(&CryptBuffer);
    }
    return(Status);
}

#define KERB_MAX_CHECKSUM_LENGTH    24
#define KERB_MAX_KEY_LENGTH         24
#define KERB_MAX_BLOCK_LENGTH       24


//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    BOOLEAN ContextsLocked = FALSE;
    ULONG ChecksumType = 0;
    ULONG EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpMakeSignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "Make Signature handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for MakeSignature(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        if (SignatureBuffer->cbBuffer < sizeof(KERB_NULL_SIGNATURE))
        {
            Status = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        SignatureBuffer->cbBuffer = sizeof(KERB_NULL_SIGNATURE);
        *(PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer = 0;

        Status = STATUS_SUCCESS;
        goto Cleanup;

    }

    Status = KerbGetChecksumAndEncryptionType(
                Context,
                QualityOfProtection,
                &ChecksumType,
                &EncryptType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                FALSE,                  // don't encrypt
                MessageSequenceNumber,
                &Signature,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x. %ws, line %d\n",ChecksumType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //


    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    NULL,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        Signature->Checksum,
        LocalChecksum,
        8
        );


    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpMakeSignature returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    ULONG ChecksumType;
    BOOLEAN ContextsLocked = FALSE;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    ULONG Protection;
    ULONG TotalBufferSize = 0;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpVerifySignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "Verify Signature handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for VerifySignature(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Also, verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        PKERB_NULL_SIGNATURE NullSignature = (PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer;

        if (SignatureBuffer->cbBuffer >= sizeof(KERB_NULL_SIGNATURE) &&
            (*NullSignature == 0))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        goto Cleanup;

    }

    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 FALSE,                 // don't decrypt
                 MessageSequenceNumber,
                 &Signature,
                 &Protection,
                 &ChecksumType,
                 NULL,                   // don't need crypt system
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize  <= sizeof(LocalChecksum));

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //


    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    Signature->Checksum,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature->Checksum,
            8))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }
Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpVerifySignature returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


#define STREAM_CIPHER_BLOCKLEN      1

//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Seals a message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the data, checksum
//              and a sequence number.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    UCHAR LocalKey[KERB_MAX_KEY_LENGTH];

    UCHAR LocalBlockBuffer[KERB_MAX_BLOCK_LENGTH];
    ULONG BeginBlockSize = 0;
    PBYTE BeginBlockPointer = NULL;
    ULONG EndBlockSize = 0;
    ULONG EncryptBufferSize;
    PBYTE EncryptBuffer;

    BOOLEAN ContextsLocked = FALSE;
    BOOLEAN DoEncryption = TRUE;
    ULONG BlockSize = 1;
    ULONG ChecksumType = 0;
    ULONG EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG ContextAttributes;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpSealMessage Called\n"));
    D_DebugLog((DEB_TRACE_USER, "SealMessage handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for SpSealMessage(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // get the encryption type for the context
    //

    Status = KerbGetChecksumAndEncryptionType(
                Context,
                QualityOfProtection,
                &ChecksumType,
                &EncryptType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the cryptsystem for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    BlockSize = CryptSystem->BlockSize;

    //
    // Find the body and signature SecBuffers from pMessage
    //

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            //
            // use real block size from crypt type
            //

            if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_PADDING)
            {
                if (STREAM_CIPHER_BLOCKLEN != BlockSize)
                {
                    TotalBufferSize = ROUND_UP_COUNT(TotalBufferSize+1,BlockSize);
                }
                else
                {
                    //
                    // For stream encryption, only 1 byte of padding
                    //

                    TotalBufferSize += BlockSize;
                }
            }
            else
            {
                TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
            }

        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    ContextAttributes = Context->ContextAttributes;

    //
    // If we are not encrypting, just wrapping, remember that
    //

    if (QualityOfProtection == KERB_WRAP_NO_ENCRYPT)
    {
        DoEncryption = FALSE;
        //
        // Reset the block size because we are not really encrypting
        //

    }

    //
    // Verify that the context was created with the integrity bit
    //

    if (DoEncryption && ((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) == 0))
    {
        DebugLog((DEB_ERROR,"Trying to seal without asking for confidentiality. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;

    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                TRUE,                  // do encrypt
                MessageSequenceNumber,
                (PKERB_GSS_SIGNATURE *) &SealSignature,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x. %ws, line %d\n",ChecksumType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));


    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    Status = Check->InitializeEx(
                Context->SessionKey.keyvalue.value,
                (ULONG) Context->SessionKey.keyvalue.length,
                KERB_PRIV_SALT,
                &CheckBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    //
    // Create the encryption key by xoring with 0xf0f0f0f0
    //

    DsysAssert(Context->SessionKey.keyvalue.length <= sizeof(LocalKey));
    if (Context->SessionKey.keyvalue.length > sizeof(LocalKey))
    {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }


    for (Index = 0; Index < Context->SessionKey.keyvalue.length  ; Index++ )
    {
        LocalKey[Index] = Context->SessionKey.keyvalue.value[Index] ^ 0xf0;
    }

    Status = CryptSystem->Initialize(
                LocalKey,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) SealSignature) -2
        );


    //
    // Sum the confounder
    //

    Check->Sum(
        CheckBuffer,
        KERB_GSS_SIG_CONFOUNDER_SIZE,
        SealSignature->Confounder
        );


    if ((EncryptType == KERB_ETYPE_RC4_PLAIN) ||
        (EncryptType == KERB_ETYPE_RC4_PLAIN_EXP))
    {
        Status = CryptSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    (PUCHAR) &SequenceNumber,
                    sizeof(ULONG)
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Encrypt the 8 confounder bytes
    //

    if (DoEncryption)
    {
        Status = CryptSystem->Encrypt(
                    CryptBuffer,
                    SealSignature->Confounder,
                    KERB_GSS_SIG_CONFOUNDER_SIZE,
                    SealSignature->Confounder,
                    &OutputSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            //
            // Take into account that the input buffers may not all be aligned
            // properly
            //


            DsysAssert(BeginBlockSize < BlockSize);
            if (BeginBlockSize != 0)
            {
                //
                // We have a fragment we still need to encrypt
                //

                EncryptBuffer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                                (BlockSize - BeginBlockSize);
                EncryptBufferSize = MessageBuffers->pBuffers[Index].cbBuffer -
                                (BlockSize - BeginBlockSize);
            }
            else
            {
                //
                // There is no fragment to encrypt, so try to do the whole
                // buffer
                //

                EncryptBuffer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer;
                EncryptBufferSize = MessageBuffers->pBuffers[Index].cbBuffer;
            }
            EndBlockSize = EncryptBufferSize - ROUND_DOWN_COUNT(EncryptBufferSize,BlockSize);
            DsysAssert(EndBlockSize < BlockSize);
            EncryptBufferSize = EncryptBufferSize - EndBlockSize;


            //
            // If this is padding, fill it in with the appropriate data &
            // length
            //

            if (MessageBuffers->pBuffers[Index].BufferType == SECBUFFER_PADDING)
            {
                if (MessageBuffers->pBuffers[Index].cbBuffer < BlockSize)
                {
                    DebugLog((DEB_ERROR, "Pad buffer is too small: %d instead of %d. %ws, %d\n",
                        MessageBuffers->pBuffers[Index].cbBuffer,
                        BlockSize,
                        THIS_FILE,
                        __LINE__
                        ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                memset(
                    MessageBuffers->pBuffers[Index].pvBuffer,
                    BlockSize - BeginBlockSize,
                    BlockSize - BeginBlockSize
                    );
                MessageBuffers->pBuffers[Index].cbBuffer = BlockSize - BeginBlockSize;

                //
                // If there is a fragment, we will encrypt the padding with the fragment.
                // Otherwise we will do just a padding buffer.
                //

                if (BeginBlockSize != 0)
                {
                    EncryptBufferSize = 0;
                }

                //
                // The padding fixes up the end block.
                //

                EndBlockSize = 0;
            }

            //
            // Checksum the whole buffer. We do this now to get the right amount of
            // padding.
            //

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );


            if (BeginBlockSize != 0)
            {
                RtlCopyMemory(
                    LocalBlockBuffer+BeginBlockSize,
                    MessageBuffers->pBuffers[Index].pvBuffer,
                    BlockSize - BeginBlockSize
                    );

                if (DoEncryption)
                {
                    //
                    // Now encrypt the buffer
                    //

                    Status = CryptSystem->Encrypt(
                                CryptBuffer,
                                LocalBlockBuffer,
                                BlockSize,
                                LocalBlockBuffer,
                                &OutputSize
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
                }

                //
                // Copy the pieces back
                //

                RtlCopyMemory(
                    BeginBlockPointer,
                    LocalBlockBuffer,
                    BeginBlockSize
                    );

                RtlCopyMemory(
                    MessageBuffers->pBuffers[Index].pvBuffer,
                    LocalBlockBuffer + BeginBlockSize,
                    BlockSize - BeginBlockSize
                    );

            }

            if (DoEncryption && (EncryptBufferSize != 0))
            {
                //
                // Now encrypt the buffer
                //

                Status = CryptSystem->Encrypt(
                            CryptBuffer,
                            EncryptBuffer,
                            EncryptBufferSize,
                            EncryptBuffer,
                            &OutputSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                DsysAssert(OutputSize == EncryptBufferSize);
            }

            //
            // Prepare for the next go-round
            //

            RtlCopyMemory(
               LocalBlockBuffer,
               EncryptBuffer+EncryptBufferSize,
               EndBlockSize
               );
            BeginBlockSize = EndBlockSize;
            BeginBlockPointer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                                  MessageBuffers->pBuffers[Index].cbBuffer -
                                  EndBlockSize;

        }
    }

    //
    // Make sure there are no left-over bits
    //

    if (BeginBlockSize != 0)
    {
        DebugLog((DEB_ERROR,"Non-aligned buffer size to SealMessage: %d extra bytes\n",
            BeginBlockSize ));
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    CheckBuffer = NULL;


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        SealSignature->Signature.Checksum,
        LocalChecksum,
        8
        );


    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    CryptSystem->Discard( &CryptBuffer );

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //
    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                SealSignature->Signature.SequenceNumber,
                8,
                SealSignature->Signature.SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpSealMessage returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSealMessageBodySize
//
//  Synopsis:   From a input encrypted message, figures out where the
//              body starts
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    0 on failure, # of bytes of data on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbGetSealMessageBodySize(
    IN OUT PVOID * InputBuffer,
    IN ULONG InputBufferSize
    )
{
   INT BufferSize = (INT) InputBufferSize;
   PBYTE Buffer = (PBYTE) *InputBuffer;
   INT DerBufferSize;
   INT OidLength;

   if ((BufferSize-=1) < 0)
      return(0);
   if (*(Buffer++) != 0x60)
      return(0);

   if ((DerBufferSize = der_read_length(&Buffer, &BufferSize)) < 0)
      return(0);

   if (DerBufferSize != BufferSize)
      return(0);

   if ((BufferSize-=1) < 0)
      return(0);
   if (*(Buffer++) != 0x06)
      return(0);

   if ((BufferSize-=1) < 0)
      return(0);
   OidLength = *(Buffer++);

   if ((OidLength & 0x7fffffff) != OidLength) /* Overflow??? */
      return(0);
   if ((BufferSize-= (int) OidLength) < 0)
      return(0);
   Buffer+=OidLength;


   if ((BufferSize-=2) < 0)
      return(0);
  Buffer += 2;


   //
   // take off size of header
   //

   if ((BufferSize -= sizeof(KERB_GSS_SEAL_SIGNATURE)) < 0)
   {
       return(0);
   }
   Buffer += sizeof(KERB_GSS_SEAL_SIGNATURE);
   *InputBuffer = Buffer;
   return((ULONG) BufferSize);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Decrypts & Verifies an encrypted message according to
//              RFC 1964 Unwrap() API description
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    PSecBuffer StreamBuffer = NULL;
    SecBuffer LocalSignatureBuffer = {0};
    SecBuffer LocalDataBuffer = {0};
    SecBufferDesc LocalBufferDesc = {0};
    PSecBufferDesc BufferList = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    ULONG ChecksumType;
    BOOLEAN ContextsLocked = FALSE;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    UCHAR LocalKey[KERB_MAX_KEY_LENGTH];

    UCHAR LocalBlockBuffer[KERB_MAX_BLOCK_LENGTH];
    ULONG BeginBlockSize = 0;
    PBYTE BeginBlockPointer = NULL;
    ULONG EndBlockSize = 0;
    ULONG EncryptBufferSize;
    PBYTE EncryptBuffer;

    BOOLEAN DoDecryption = TRUE;
    ULONG BlockSize = 1;
    ULONG Protection = 0;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG ContextAttributes;
    ULONG SequenceNumber;



    D_DebugLog((DEB_TRACE_API,"SpUnsealSignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "SealMessage handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for SpUnsealMessage (0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            StreamBuffer = &MessageBuffers->pBuffers[Index];

            //
            // The total buffer size is everything in the stream buffer
            //

            TotalBufferSize = MessageBuffers->pBuffers[Index].cbBuffer;
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY) == 0)

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }

    //
    // Check for a stream buffer. If it is present, it contains the whole
    // message
    //

    if (StreamBuffer != NULL)
    {
        if (SignatureBuffer != NULL)
        {
            DebugLog((DEB_ERROR,"Both stream and signature buffer present. %ws, line %d\n",THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Parse the stream to distinguish the header from the body
        //

        LocalSignatureBuffer = *StreamBuffer;
        LocalSignatureBuffer.BufferType = SECBUFFER_TOKEN;
        LocalDataBuffer = *StreamBuffer;
        LocalDataBuffer.BufferType = SECBUFFER_DATA;


        LocalDataBuffer.cbBuffer = KerbGetSealMessageBodySize(
                                    &LocalDataBuffer.pvBuffer,
                                    LocalDataBuffer.cbBuffer
                                    );
        if (LocalDataBuffer.cbBuffer == 0)
        {
            DebugLog((DEB_ERROR,"Failed to find header on stream buffer. %ws %d\n",
                THIS_FILE,__LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        LocalSignatureBuffer.cbBuffer = StreamBuffer->cbBuffer - LocalDataBuffer.cbBuffer;
        SignatureBuffer = &LocalSignatureBuffer;
        LocalBufferDesc.cBuffers = 1;
        LocalBufferDesc.pBuffers = &LocalDataBuffer;
        BufferList = &LocalBufferDesc;
        //
        // Adjust the total buffer size to remove the signature
        //
        TotalBufferSize -= LocalSignatureBuffer.cbBuffer;

    }
    else if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    else
    {
        BufferList = MessageBuffers;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    ContextAttributes = Context->ContextAttributes;



    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 TRUE,                  // do decrypt
                 MessageSequenceNumber,
                 (PKERB_GSS_SIGNATURE *) &SealSignature,
                 &Protection,
                 &ChecksumType,
                 &CryptSystem,
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }



    //
    // If the protection level is no encryption, remember not to do the
    // decryption
    //

    if (Protection == KERB_WRAP_NO_ENCRYPT)
    {
        DoDecryption = FALSE;

    }

    //
    // Also, verify that the context was created with the Confidentiality bit
    //

    if ((DoDecryption && (Context->ContextFlags & ISC_RET_CONFIDENTIALITY) == 0))
    {
        DebugLog((DEB_ERROR,"Tried to decrypt using non-confidential context. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;

    }

    BlockSize = CryptSystem->BlockSize;


    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Create the encryption key by xoring with 0xf0f0f0f0
    //

    DsysAssert(Context->SessionKey.keyvalue.length <= sizeof(LocalKey));
    if (Context->SessionKey.keyvalue.length > sizeof(LocalKey))
    {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }


    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //


    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    SealSignature->Signature.Checksum,
                    KERB_PRIV_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_PRIV_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    for (Index = 0; Index < Context->SessionKey.keyvalue.length  ; Index++ )
    {
        LocalKey[Index] = Context->SessionKey.keyvalue.value[Index] ^ 0xf0;
    }

    Status = CryptSystem->Initialize(
                LocalKey,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) SealSignature) -2
        );

    //
    // Decrypt the confounder
    //

    if ((CryptSystem->EncryptionType == KERB_ETYPE_RC4_PLAIN) ||
        (CryptSystem->EncryptionType == KERB_ETYPE_RC4_PLAIN_EXP))
    {
        Status = CryptSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    (PUCHAR) &SequenceNumber,
                    sizeof(ULONG)
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (DoDecryption)
    {
        OutputSize = KERB_GSS_SIG_CONFOUNDER_SIZE;
        Status = CryptSystem->Decrypt(
                    CryptBuffer,
                    SealSignature->Confounder,
                    KERB_GSS_SIG_CONFOUNDER_SIZE,
                    SealSignature->Confounder,
                    &OutputSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Sum the confounder
    //

    Check->Sum(
        CheckBuffer,
        KERB_GSS_SIG_CONFOUNDER_SIZE,
        SealSignature->Confounder
        );


    for (Index = 0; Index < BufferList->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(BufferList->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(BufferList->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (BufferList->pBuffers[Index].cbBuffer != 0))
        {

            //
            // Take into account that the input buffers may not all be aligned
            // properly
            //


            //
            // If there is a fragment to decrypt, convert it to a block
            // size fragment
            //

            if (BeginBlockSize != 0)
            {
                EncryptBuffer = (PBYTE) BufferList->pBuffers[Index].pvBuffer +
                                (BlockSize - BeginBlockSize);
                EncryptBufferSize = BufferList->pBuffers[Index].cbBuffer -
                                (BlockSize - BeginBlockSize);
            }
            else
            {
                EncryptBuffer = (PBYTE) BufferList->pBuffers[Index].pvBuffer;
                EncryptBufferSize = BufferList->pBuffers[Index].cbBuffer;
            }

            EndBlockSize = EncryptBufferSize - ROUND_DOWN_COUNT(EncryptBufferSize,BlockSize);
            DsysAssert(EndBlockSize < BlockSize);
            EncryptBufferSize = EncryptBufferSize - EndBlockSize;


            if (BeginBlockSize != 0)
            {
                RtlCopyMemory(
                    LocalBlockBuffer+BeginBlockSize,
                    BufferList->pBuffers[Index].pvBuffer,
                    BlockSize - BeginBlockSize
                    );

                //
                // Now decrpt the buffer
                //
                if (DoDecryption)
                {
                    Status = CryptSystem->Decrypt(
                                CryptBuffer,
                                LocalBlockBuffer,
                                BlockSize,
                                LocalBlockBuffer,
                                &OutputSize
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
                }

                //
                // Then checksum the buffer
                //

                Check->Sum(
                    CheckBuffer,
                    BlockSize,
                    LocalBlockBuffer
                    );

                //
                // Copy the pieces back
                //

                RtlCopyMemory(
                    BeginBlockPointer,
                    LocalBlockBuffer,
                    BeginBlockSize
                    );

                RtlCopyMemory(
                    BufferList->pBuffers[Index].pvBuffer,
                    LocalBlockBuffer + BeginBlockSize,
                    BlockSize - BeginBlockSize
                    );

            }

            //
            // Decrypt the buffer first
            //


            if (DoDecryption)
            {
                OutputSize = BufferList->pBuffers[Index].cbBuffer;
                Status = CryptSystem->Decrypt(
                            CryptBuffer,
                            EncryptBuffer,
                            EncryptBufferSize,
                            EncryptBuffer,
                            &OutputSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                DsysAssert(OutputSize == BufferList->pBuffers[Index].cbBuffer);
            }

            //
            // Prepare for the next go-round
            //

            RtlCopyMemory(
                LocalBlockBuffer,
                EncryptBuffer+EncryptBufferSize,
                EndBlockSize
                );
            BeginBlockSize = EndBlockSize;
            BeginBlockPointer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                                  MessageBuffers->pBuffers[Index].cbBuffer -
                                  EndBlockSize;



            //
            // Then checksum the buffer
            //

            Check->Sum(
                CheckBuffer,
                EncryptBufferSize,
                EncryptBuffer
                );


        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);
    CheckBuffer = NULL;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Make sure there are no left-over bits
    //

    if (BeginBlockSize != 0)
    {
        DebugLog((DEB_ERROR,"Non-aligned buffer size to SealMessage: %d extra bytes\n",
            BeginBlockSize ));
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            SealSignature->Signature.Checksum,
            8))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }

    //
    // If this was a stream input, return the data in the data buffer
    //

    if (StreamBuffer != NULL)
    {
        BYTE PaddingBytes;

        //
        // Pull the padding off the data buffer
        //

        if (LocalDataBuffer.cbBuffer < 1)
        {
            DebugLog((DEB_ERROR,"Data buffer is zero length!\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        PaddingBytes = *(((PBYTE)LocalDataBuffer.pvBuffer) + LocalDataBuffer.cbBuffer - 1 );

        //
        // Verify the padding:
        //

        if ((BlockSize >= PaddingBytes) &&
            (LocalDataBuffer.cbBuffer >= PaddingBytes))
        {

            LocalDataBuffer.cbBuffer -= PaddingBytes;
            for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
            {
                if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_DATA)
                {
                    MessageBuffers->pBuffers[Index] = LocalDataBuffer;
                    break;
                }
            }
        }
        else
        {
DebugLog((DEB_ERROR,"Bad padding: %d bytes\n", PaddingBytes));
            Status = STATUS_INVALID_PARAMETER;
        }

    }

Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    D_DebugLog((DEB_TRACE_API, "SpUnsealMessage returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ContextExpires;


    D_DebugLog((DEB_TRACE_API,"SpGetContextToken called pid:0x%x, ctxt:0x%x\n", GetCurrentProcessId(), ContextHandle));

    if (ImpersonationToken == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "Null token handle supplied for GetContextToken. %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for GetContextToken(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
    }

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

    KerbReadLockContexts();
    *ImpersonationToken = Context->TokenHandle;
    ContextExpires = Context->Lifetime;
    KerbUnlockContexts();

    if (KerbGlobalEnforceTime && ContextExpires.QuadPart < CurrentTime.QuadPart)
    {
        DebugLog((DEB_ERROR, "GetContextToken: Context 0x%x expired. %ws, line %d\n", ContextHandle, THIS_FILE, __LINE__));
        Status = SEC_E_CONTEXT_EXPIRED;
        *ImpersonationToken = NULL;
    }
    else if (*ImpersonationToken == NULL)
    {
        Status = SEC_E_NO_IMPERSONATION;
    }

    if (Context != NULL)
    {
        //
        // Note: once we dereference the context the handle we return
        // may go away or be re-used. That is the price we have to pay
        // to avoid duplicating it.
        //

        KerbDereferenceContext(Context);
    }

Cleanup:
    D_DebugLog((DEB_TRACE_API,"SpGetContextToken returned 0x%x, pid:0x%x, ctxt:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PSecPkgContext_Sizes SizeInfo;
    PSecPkgContext_Names NameInfo;
    PSecPkgContext_DceInfo DceInfo;
    PSecPkgContext_Lifespan LifespanInfo;
    PSecPkgContext_Flags FlagsInfo;
    PSecPkgContext_PackageInfo PackageInfo;
    PSecPkgContext_NegotiationInfo NegInfo ;
    PSecPkgContext_SessionKey  SessionKeyInfo;
    PSecPkgContext_KeyInfo KeyInfo;
    PSecPkgContext_AccessToken AccessToken;
    ULONG PackageInfoSize = 0;
    UNICODE_STRING FullName;
    ULONG ChecksumType;
    ULONG EncryptType;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    TimeStamp CurrentTime;

    D_DebugLog((DEB_TRACE_API,"SpQueryContextAttributes called pid:0x%x, ctxt:0x%x, Attr:0x%x\n", GetCurrentProcessId(), ContextHandle, ContextAttribute));
      
    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {
    case SECPKG_ATTR_SIZES:
        gss_OID_desc * MechId;
        UINT MessageSize;

        if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
        {
            MechId = gss_mech_krb5_u2u;
        }
        else
        {
            MechId = gss_mech_krb5_new;
        }

        //
        // The sizes returned are used by RPC to determine whether to call
        // MakeSignature or SealMessage. The signature size should be zero
        // if neither is to be called, and the block size and trailer size
        // should be zero if SignMessage is not to be called.
        //

        SizeInfo = (PSecPkgContext_Sizes) Buffer;
        SizeInfo->cbMaxToken = KerbGlobalMaxTokenSize;

        // If we need to be Gss Compatible, then the Signature buffer size is
        // dependent on the message size. So, we'll set it to be largest pad
        // for the largest message size, say 1G. But, don't tax dce style
        // callers with extra bytes.


        if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
            ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            MessageSize = 0;
        }
        else
        {
            MessageSize = KERB_MAX_MESSAGE_SIZE;
        }

        if ((Context->ContextFlags & (KERB_SIGN_FLAGS | ISC_RET_CONFIDENTIALITY)) != 0)
        {
              SizeInfo->cbMaxSignature = g_token_size(MechId, sizeof(KERB_GSS_SIGNATURE));
        }
        else
        {
            SizeInfo->cbMaxSignature = sizeof(KERB_NULL_SIGNATURE);
        }

        //
        // get the encryption type for the context
        //

        Status = KerbGetChecksumAndEncryptionType(
                    Context,
                    KERB_WRAP_NO_ENCRYPT,   // checksum not needed so use hardcoded QOP 
                    &ChecksumType,          // checksum not needed here
                    &EncryptType
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Locate the cryptsystem for the context, loading it if necessary from the
        // the crypto support DLL
        //

        Status = CDLocateCSystem(EncryptType, &CryptSystem);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // RPC keys off the trailer size to tell whether or not
        // to encrypt, not the flags from isc/asc. So, for dce style,
        // say the blocksize & trailersize are zero.
        //
        if (((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) != 0) ||
            ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) == 0))
        {
            //
            // Use block size from crypto system
            //

            SizeInfo->cbBlockSize = CryptSystem->BlockSize;
            SizeInfo->cbSecurityTrailer =
                g_token_size(MechId, sizeof(KERB_GSS_SEAL_SIGNATURE) + MessageSize) - MessageSize;
        }
        else
        {

            SizeInfo->cbBlockSize = 0;
            SizeInfo->cbSecurityTrailer = 0;
        }
        break;
    case SECPKG_ATTR_SESSION_KEY:



        SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
        SessionKeyInfo->SessionKeyLength = Context->SessionKey.keyvalue.length;
        if (SessionKeyInfo->SessionKeyLength != 0)
        {
            SessionKeyInfo->SessionKey = (PUCHAR)
            UserFunctions->AllocateHeap(
                SessionKeyInfo->SessionKeyLength);
            if (SessionKeyInfo->SessionKey!=NULL)
            {
                RtlCopyMemory(
                    SessionKeyInfo->SessionKey,
                    Context->SessionKey.keyvalue.value,
                    Context->SessionKey.keyvalue.length
                    );
            }
            else
                {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            SessionKeyInfo->SessionKey = (PUCHAR) UserFunctions->AllocateHeap(1);
            if (SessionKeyInfo->SessionKey!=NULL)
            {
                *(PUCHAR) SessionKeyInfo->SessionKey = 0;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    

    break;



    case SECPKG_ATTR_NAMES:
        NameInfo = (PSecPkgContext_Names) Buffer;
        if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &Context->ClientRealm,
                &Context->ClientName,
                &FullName
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

#ifndef WIN32_CHICAGO
        NameInfo->sUserName = (LPWSTR) UserFunctions->AllocateHeap(FullName.Length + sizeof(WCHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                FullName.Buffer,
                FullName.Length
                );
            NameInfo->sUserName[FullName.Length/sizeof(WCHAR)] = L'\0';

        }
#else // WIN32_CHICAGO
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &FullName,
                                      TRUE);

        NameInfo->sUserName = (LPTSTR) UserFunctions->AllocateHeap(AnsiString.Length + sizeof(CHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                AnsiString.Buffer,
                AnsiString.Length
                );
            NameInfo->sUserName[AnsiString.Length] = '\0';

            RtlFreeAnsiString(&AnsiString);
        }
#endif // WIN32_CHICAGO
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbFreeString(&FullName);

        break;
    case SECPKG_ATTR_DCE_INFO:
        DceInfo = (PSecPkgContext_DceInfo) Buffer;
        if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &Context->ClientRealm,
                &Context->ClientName,
                &FullName
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        DceInfo->AuthzSvc = RPC_C_AUTHZ_NAME;

#ifndef WIN32_CHICAGO
        DceInfo->pPac = UserFunctions->AllocateHeap(FullName.Length + sizeof(WCHAR));
        if (DceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                DceInfo->pPac,
                FullName.Buffer,
                FullName.Length
                );
            ((LPWSTR)DceInfo->pPac)[FullName.Length/sizeof(WCHAR)] = L'\0';

        }
#else // WIN32_CHICAGO

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &FullName,
                                      TRUE);

        DceInfo->pPac = UserFunctions->AllocateHeap(AnsiString.Length + sizeof(CHAR));
        if (DceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                DceInfo->pPac,
                AnsiString.Buffer,
                AnsiString.Length
                );
            ((LPTSTR) DceInfo->pPac)[AnsiString.Length] = '\0';

            RtlFreeAnsiString(&AnsiString);
        }
#endif // WIN32_CHICAGO
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbFreeString(&FullName);

        break;
    case SECPKG_ATTR_LIFESPAN:
        LifespanInfo = (PSecPkgContext_Lifespan) Buffer;         
        
        if (KerbGetTime(Context->StartTime) != KerbGetTime(KerbGlobalHasNeverTime))
        {
           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &(Context->StartTime)
              );

           D_DebugLog((DEB_TRACE, "Used context start time \n"));
        }
        else if (NULL != Context->TicketCacheEntry)
        {  
           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &(Context->TicketCacheEntry->StartTime)
              );

           KerbWriteLockContexts();
           Context->StartTime = Context->TicketCacheEntry->StartTime;
           KerbUnlockContexts();

           DebugLog((DEB_ERROR, "Used tkt cache entry start time \n"));

        } 
        else  // set it to current time
        {
           // The context is not in a state where we've got a 
           // tkt cache entry, so let's use current time.
           GetSystemTimeAsFileTime((PFILETIME)
                                   &CurrentTime
                                   );

           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &CurrentTime
              );
           
           DebugLog((DEB_ERROR, "NO START TIME PRESENT IN CONTEXT, or CACHE ENTRY!\n"));
        }

        KerbUtcTimeToLocalTime(
            &LifespanInfo->tsExpiry,
            &Context->Lifetime
            );

        break;
    case SECPKG_ATTR_FLAGS:
        FlagsInfo = (PSecPkgContext_Flags) Buffer;

        if ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0)
        {
            FlagsInfo->Flags = KerbMapContextFlags( Context->ContextFlags );
        }
        else
        {
            FlagsInfo->Flags = Context->ContextFlags;
        }
        break;
#ifndef WIN32_CHICAGO
    case SECPKG_ATTR_KEY_INFO:
        PCRYPTO_SYSTEM CryptoSystem;
        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;

        KeyInfo->KeySize = KerbIsKeyExportable(&Context->SessionKey) ? 56 : 128;
        KeyInfo->EncryptAlgorithm = Context->SessionKey.keytype;
        KeyInfo->SignatureAlgorithm = KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype) ? KERB_CHECKSUM_MD25 : KERB_CHECKSUM_HMAC_MD5;
        KeyInfo->sSignatureAlgorithmName = NULL;
        KeyInfo->sEncryptAlgorithmName = NULL;

        //
        // The checksum doesn't include a name, so don't fill it in - leave
        // it as an empty string, so callers don't die when they
        // try to manipulate it.
        //

        Status = CDLocateCSystem(KeyInfo->EncryptAlgorithm, &CryptoSystem);
        if (NT_SUCCESS(Status))
        {
            KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                UserFunctions->AllocateHeap(sizeof(WCHAR) * (wcslen(CryptoSystem->Name) + 1));
            if (KeyInfo->sEncryptAlgorithmName != NULL)
            {
                wcscpy(
                    KeyInfo->sEncryptAlgorithmName,
                    CryptoSystem->Name
                    );
                KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                    UserFunctions->AllocateHeap(sizeof(WCHAR));

                if (KeyInfo->sSignatureAlgorithmName != NULL)
                {
                    *KeyInfo->sSignatureAlgorithmName = L'\0';
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    UserFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                    KeyInfo->sEncryptAlgorithmName = NULL;

                }
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;
#endif // WIN32_CHICAGO
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfoSize = sizeof(SecPkgInfo) + sizeof(KERBEROS_PACKAGE_NAME) + sizeof(KERBEROS_PACKAGE_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfo) UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPTSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPTSTR) (((PBYTE) PackageInfo->PackageInfo->Name) + sizeof(KERBEROS_PACKAGE_NAME));
        lstrcpy(
            PackageInfo->PackageInfo->Name,
            KERBEROS_PACKAGE_NAME
            );

        lstrcpy(
            PackageInfo->PackageInfo->Comment,
            KERBEROS_PACKAGE_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_GSS_KERBEROS;
        PackageInfo->PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
        PackageInfo->PackageInfo->cbMaxToken    = KerbGlobalMaxTokenSize;
        if ( ContextAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }
        break;

    case SECPKG_ATTR_ACCESS_TOKEN:
    {
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //
        AccessToken->AccessToken = (void*)Context->TokenHandle;
        break;
    }
    
    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryContextAttributes returned 0x%x, pid:0x%x, ctxt:0x%x, Attr:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle, ContextAttribute));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLsaModeContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryLsaModeContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    SecPkgContext_NativeNames NameInfo = {0};
    BOOLEAN ContextsLocked = FALSE;
    UNICODE_STRING ServerName = {0};
    UNICODE_STRING ClientName = {0};
    BOOLEAN IsClientContext = FALSE;


    D_DebugLog((DEB_TRACE_API,"SpQueryLsaModeContextAttributes called ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));
      
    Status = KerbReferenceContext(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbReadLockContexts();
    ContextsLocked = TRUE;

    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {

    case SECPKG_ATTR_NATIVE_NAMES:

        //
        // Get outbound names from the ticket
        //


        if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
        {
            IsClientContext = TRUE;
            if (Context->TicketCacheEntry != NULL)
            {
                KERBERR KerbErr = KDC_ERR_NONE;
                KerbReadLockTicketCache();
                KerbErr = KerbConvertKdcNameToString(
                            &ServerName,
                            Context->TicketCacheEntry->ServiceName,
                            &Context->TicketCacheEntry->DomainName
                            );
                if (KERB_SUCCESS(KerbErr))
                {
                    KerbErr = KerbConvertKdcNameToString(
                                &ClientName,
                                Context->TicketCacheEntry->ClientName,
                                &Context->TicketCacheEntry->ClientDomainName
                                );
                }
                KerbUnlockTicketCache();
                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }


            }
            else
            {
                //
                // We couldn't find the names, so return an error
                //

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                goto Cleanup;
            }
        }
        else
        {
            //
            // We have a server context
            //

            ClientName = Context->ClientPrincipalName;
            ServerName = Context->ServerPrincipalName;
        }
#ifndef WIN32_CHICAGO

        if (ServerName.Length != 0)
        {
            Status = LsaFunctions->AllocateClientBuffer(
                        NULL,
                        ServerName.Length + sizeof(WCHAR),
                        (PVOID *) &NameInfo.sServerName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        ServerName.Length + sizeof(WCHAR),
                        NameInfo.sServerName,
                        ServerName.Buffer
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        if (ClientName.Length != 0)
        {
            Status = LsaFunctions->AllocateClientBuffer(
                        NULL,
                        ClientName.Length + sizeof(WCHAR),
                        (PVOID *) &NameInfo.sClientName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        ClientName.Length + sizeof(WCHAR),
                        NameInfo.sClientName,
                        ClientName.Buffer
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        //
        // Copy the whole structure
        //

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(SecPkgContext_NativeNames),
                    Buffer,
                    &NameInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

#else // WIN32_CHICAGO
        {
            ANSI_STRING AnsiString = {0};
            if (ServerName.Length != 0)
            {
                RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    &ServerName,
                    TRUE);

                if (AnsiString.Length > 0)
                {
                    NameInfo.sServerName = (LPSTR) LsaFunctions->AllocateLsaHeap(
                                AnsiString.Length + sizeof(CHAR)
                                );
                    if (NameInfo.sServerName == NULL)
                    {
                        RtlFreeAnsiString(&AnsiString);
                        goto Cleanup;
                    }
                    RtlCopyMemory(
                        NameInfo.sServerName,
                        AnsiString.Buffer,
                        AnsiString.Length
                        );
                    NameInfo.sServerName[AnsiString.Length+1] = '\0';
                    RtlFreeAnsiString(&AnsiString);

                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
            if (ClientName.Length != 0)
            {
                RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    &ClientName,
                    TRUE);

                if (AnsiString.Length > 0)
                {
                    NameInfo.sClientName = (LPSTR) LsaFunctions->AllocateLsaHeap(
                                AnsiString.Length + sizeof(CHAR)
                                );
                    if (NameInfo.sClientName == NULL)
                    {
                        RtlFreeAnsiString(&AnsiString);
                        goto Cleanup;
                    }
                    RtlCopyMemory(
                        NameInfo.sClientName,
                        AnsiString.Buffer,
                        AnsiString.Length
                        );
                    NameInfo.sClientName[AnsiString.Length+1] = '\0';
                    RtlFreeAnsiString(&AnsiString);

                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }

            RtlCopyMemory(
                Buffer,
                &NameInfo,
                sizeof(SecPkgContext_NativeNames)
                );
        }
#endif // WIN32_CHICAGO
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    if (IsClientContext)
    {
        KerbFreeString(
            &ClientName
            );
        KerbFreeString(
            &ServerName
            );
    }
    if (!NT_SUCCESS(Status))
    {
#ifndef WIN32_CHICAGO
        if (NameInfo.sServerName != NULL)
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                NameInfo.sServerName
                );
        }
        if (NameInfo.sClientName != NULL)
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                NameInfo.sClientName
                );
        }
#else // WIN32_CHICAGO
        if (NameInfo.sServerName != NULL)
        {
            LsaFunctions->FreeLsaHeap(
                NameInfo.sServerName
                );
        }
        if (NameInfo.sClientName != NULL)
        {
            LsaFunctions->FreeLsaHeap(
                NameInfo.sClientName
                );
        }
#endif
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryLsaModeContextAttributes returned 0x%x, pid:0x%x, ctxt:0x%x, Attr:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle, ContextAttribute));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}


#ifndef WIN32_CHICAGO
NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    return(STATUS_NOT_SUPPORTED);
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cpcrypt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpcrypt.c

Abstract:

    include file for private\security\kerberos\common2\crypt.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\crypt.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cpkeygn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpkeygn.c

Abstract:

    include file for private\security\kerberos\common2\keygen.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\keygen.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cpkrb5.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpkrb5.c

Abstract:

    include file for private\security\kerberos\common2\krb5.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\krb5.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cpnames.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpnames.c

Abstract:

    include file for private\security\kerberos\common2\names.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\names.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cppaswd.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cppaswd.c

Abstract:

    include file for private\security\kerberos\common2\passwd.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\passwd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\userlist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        userlist.h
//
// Contents:    Prototypes for user mapping functions
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __USERLIST_H__
#define __USERLIST_H__

#include <pac.hxx>

#define KERB_USERLIST_KEY L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\UserList"
#define KERB_MATCH_ALL_NAME L"*"
#define KERB_ALL_USERS_VALUE L"*"

NTSTATUS
KerbCreatePacForKerbClient(
    OUT PPACTYPE * Pac,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm ,
    IN OPTIONAL PUNICODE_STRING MappedClientRealm
    );



NTSTATUS
KerbMapClientName(
    OUT PUNICODE_STRING MappedName,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    );



#endif // __USERLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cpsock.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpsock.c

Abstract:

    include file for private\security\kerberos\common2\sockets.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\sockets.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\cptick.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cptick.cxx

Abstract:

    include file for private\security\kerberos\common2\tickets.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\tickets.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

//
// kerbstub.cxx will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT          0x00000001 // Initialization
#define SSP_MISC          0x00000002 // Misc debug
#define SSP_API           0x00000004 // API processing
#define SSP_LPC           0x00000008 // LPC
#define SSP_CRITICAL      0x00000100 // Only real important errors

//
// Very verbose bits
//

#define SSP_API_MORE      0x04000000 // verbose API
#define SSP_LPC_MORE      0x08000000 // verbose LPC

//
// Control bits.
//

#define SSP_TIMESTAMP     0x20000000 // TimeStamp each output line
#define SSP_REQUEST_TARGET 0x40000000 // Force client to ask for target name
#define SSP_USE_OEM       0x80000000 // Force client to use OEM character set

// bits from kerberos (from kerbdbg.h)

#define DEB_ERROR             0x0001
#define DEB_WARN              0x0002
#define DEB_TRACE             0x0004
#define DEB_TRACE_API         0x0008
#define DEB_TRACE_CRED        0x0010
#define DEB_TRACE_CTXT        0x0020
#define DEB_TRACE_LSESS       0x0040
#define DEB_TRACE_LOGON       0x0100
#define DEB_TRACE_KDC         0x0200
#define DEB_TRACE_CTXT2       0x0400
#define DEB_TRACE_LOCKS       0x01000000
#define DEB_T_SOCK            0x00000080

// bits from kerberos (from security\dsysdbg.h)
#define DSYSDBG_CLEAN         0x40000000

//
// Name and directory of log file
//

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\ntlmssp.log"
#define DEBUG_BAK_FILE      L"\\ntlmssp.bak"

//#if DBG
#ifdef RETAIL_LOG_SUPPORT

#define DebugLog(_x_) KerbPrintRoutine _x_

VOID __cdecl
KerbPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                         // OTHER ARGUMENTS ARE POSSIBLE.
    );

#else

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.
#define DebugLog(_x_)

#endif // DBG

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\kerbstub.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    kerbcomn.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _KERBSTUB_INCLUDED_
#define _KERBSTUB_INCLUDED_

//
// kerbstub.cxx will #include this file with KERBCOMN_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBSTUB_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN CRITICAL_SECTION KerbDllCritSect;    // Serializes access to all globals in module

#if DBG

//
// To serialize access to log file.
//

EXTERN CRITICAL_SECTION KerbGlobalLogFileCritSect;

//
// Control which messages get displayed
//

EXTERN DWORD KerbInfoLevel;
#endif // DBG

#define KERBEROS_TICKET_KEY TEXT("Network\\KerberosLogon")
#define KERBEROS_TICKET_USERNAME_KEY TEXT("UserName")
#define KERBEROS_TICKET_DOMAINNAME_KEY TEXT("DomainName")
#define KERBEROS_TICKET_LOGONSESSION_KEY TEXT("LogonSession")

EXTERN SecurityFunctionTable KerbDllSecurityFunctionTable;
EXTERN LSA_SECPKG_FUNCTION_TABLE FunctionTable;

////////////////////////////////////////////////////////////////////////
//
// Typedefs required for dumping to/from registry
//
////////////////////////////////////////////////////////////////////////

typedef struct _KERB_LOGON_SESSION_CACHE {
    TimeStamp      Lifetime;
    ULONG          LogonSessionFlags;
    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    USHORT         Revision;
    USHORT         Flags;
    USHORT         CredentialCount;
    KERB_ENCRYPTION_KEY Credentials[ANYSIZE_ARRAY];
} KERB_LOGON_SESSION_CACHE, *PKERB_LOGON_SESSION_CACHE;

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

//
// Procedure forwards from stub.c
//


SECURITY_STATUS
KerbEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    );

SECURITY_STATUS
KerbQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo * Package
    );

SECURITY_STATUS SEC_ENTRY
KerbFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    );

SECURITY_STATUS
KerbAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    );

SECURITY_STATUS
KerbFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    );

SECURITY_STATUS
KerbQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS
KerbSspiLogonUser(
    IN LPTSTR PackageName,
    IN LPTSTR UserName,
    IN LPTSTR DomainName,
    IN LPTSTR Password
    );

SECURITY_STATUS
KerbInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

SECURITY_STATUS
KerbDeleteSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    );


SECURITY_STATUS
KerbImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbRevertSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS SEC_ENTRY
KerbCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    );

SECURITY_STATUS
KerbMakeSignature (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    );

SECURITY_STATUS
KerbVerifySignature (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    );

SECURITY_STATUS
KerbSealMessage (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    );

SECURITY_STATUS
KerbUnsealMessage (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    );

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    );

BOOLEAN
GetCallInfo(
    OUT PSECPKG_CALL_INFO CallInfo
    );

// fake it.
//typedef ULONG LSA_CLIENT_REQUEST;
//typedef LSA_CLIENT_REQUEST *LSA_CLIENT_REQUEST;

NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    );

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    );

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    );

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    );

PVOID
AllocateLsaHeap(
    IN ULONG Length
    );

VOID
FreeLsaHeap(
    IN PVOID Base
    );

VOID
FreeReturnBuffer(
    IN PVOID Base
    );

#endif // ifndef _KERBSTUB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello2\hello2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.39 */
/* at Thu Jun 27 14:12:43 1996
 */
/* Compiler settings for .\hello2.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref 
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __hello2_h__
#define __hello2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __hello2_INTERFACE_DEFINED__
#define __hello2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: hello2
 * at Thu Jun 27 14:12:43 1996
 * using MIDL 3.00.39
 ****************************************/
/* [implicit_handle][unique][version][uuid] */ 


void HelloProc2( 
    /* [string][in] */ unsigned char __RPC_FAR *pszString);

void Shutdown2( void);


extern handle_t hello2_IfHandle;


extern RPC_IF_HANDLE hello2_v1_0_c_ifspec;
extern RPC_IF_HANDLE hello2_v1_0_s_ifspec;
#endif /* __hello2_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\ntcalls.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntcalls.cxx
//
// Contents:    Code for rtl support on Win95
//
//
// History:     01-April-1997   Created        ChandanS
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,247 years, or around 10,682,247 days.

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/



//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


WCHAR
MyUpcaseChar (WCHAR wc)
//
// WARNING -- not DBCS safe
//
{
    CHAR sz[2];
    sz[0]= (CHAR) wc;
    sz[1]=0;

    AnsiUpper(sz);

    return (WCHAR) (sz[0]);

}

WCHAR
MyLowercaseChar (WCHAR wc)
//
// WARNING -- not DBCS safe
//
{
    CHAR sz[2];
    sz[0]= (CHAR) wc;
    sz[1]=0;

    AnsiLower(sz);

    return (WCHAR) (sz[0]);

}



VOID
MyRtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
MyRtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}

VOID
MyRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
MyRtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}

NTSTATUS
MyRtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index = 0;
    NTSTATUS st = STATUS_SUCCESS;

    UnicodeLength = (SourceString->Length + 1) * sizeof(WCHAR);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (PWSTR) LocalAlloc(0, UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = MultiByteToWideChar(
             CP_ACP,
             MB_PRECOMPOSED,
             SourceString->Buffer,
             SourceString->Length,
             DestinationString->Buffer,
             DestinationString->MaximumLength
             );

        if (Index == 0) {
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }

            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = UNICODE_NULL;

    return st;
}

BOOLEAN
MyRtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSTR SourceString
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if (!ARGUMENT_PRESENT(SourceString))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        return (TRUE);
    }

    MyRtlInitAnsiString( &AnsiString, SourceString );
    Status = MyRtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


NTSTATUS
MyRtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;


    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Upcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
        WCHAR uc;
        uc  = MyUpcaseChar(SourceString->Buffer[Index]);
        DestinationString->Buffer[Index] = uc;
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Downcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
        WCHAR lc;
        WCHAR TempChar = SourceString->Buffer[Index];
        lc  = MyLowercaseChar(TempChar);
        DestinationString->Buffer[Index] = lc;
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


VOID
MyRtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    if (AnsiString->Buffer) {
        LocalFree(AnsiString->Buffer);
#if 0
        memset( AnsiString, 0, sizeof( *AnsiString ) );
#endif
        ZeroMemory( AnsiString, sizeof( *AnsiString ) );
        }
}

BOOLEAN
MyRtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2;
    ULONG n1, n2, Count;
    CHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

#if 0
        DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

        Limit = (PWCHAR)((PCHAR)s1 + n1);
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;

// WIN32_CHICAGO Do something better than AnsiUpper
                uc1= AnsiUpper (&c1);
                uc2 = AnsiUpper (&c2);
                if ((c1 != c2) && ((*uc1) != *(uc2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }
#else // 0
        if (CaseInSensitive)
        {
            Count = 0;
            // Can't use wcsnicmp

            while (Count < (n1/sizeof(WCHAR)))
            {
                WCHAR uc1, uc2;
                uc1= MyUpcaseChar (*(s1 + Count));
                uc2 = MyUpcaseChar (*(s2 + Count));
                if (uc1 != uc2) {
                    return FALSE;
                }
                Count++;
            }
            return TRUE;
        }
        else
        {
            if (wcsncmp (s1, s2, (n1/sizeof(WCHAR))) == 0)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
#endif // 0

    } else {
        return FALSE;
    }
}

NTSTATUS
MyRtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index = 0;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOL fUsed;

    AnsiLength = (SourceString->Length / sizeof(WCHAR)) + 1;
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = WideCharToMultiByte(
             CP_ACP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );

        if (Index == 0)
        { // WIN32_CHICAGO do something useful here
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }
            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function upper cases the specified unicode source string and then
    converts it into an oem string. The translation is done with respect
    to the OEM code page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    // NOTE: This routine is not DBCS safe yet!
    ULONG OemLength;
    ULONG Index;
    BOOL fUsed;
    NTSTATUS st = STATUS_SUCCESS;

    // Do not rely on callers to set MaximumLength as Length + 2
    OemLength = (SourceString->Length  / sizeof(WCHAR)) + 1;
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = WideCharToMultiByte(
             CP_OEMCP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );
    if (Index == 0)
    { // WIN32_CHICAGO do something useful here
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
        return STATUS_NO_MEMORY;
    }
/*
    st = RtlUnicodeToMultiByteN(
                    DestinationString->Buffer,
                    DestinationString->Length,
                    &Index,
                    SourceString->Buffer,
                    SourceString->Length
                    );
    if (!NT_SUCCESS(st))
    {
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
    }
*/

    DestinationString->Buffer[Index] = '\0';

    return st;
}


BOOLEAN
MyRtlEqualString(
    IN POEM_STRING String1,
    IN POEM_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = (PUCHAR)String1->Buffer;
        s2 = (PUCHAR)String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    WCHAR uc1, uc2;
 // WIN32_CHICAGO Use something better to upcase here
                    uc1 = MyUpcaseChar((WCHAR)c1);
                    uc2 = MyUpcaseChar((WCHAR)c2);
                    if (uc1 != uc2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

VOID
MyRtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    if (OemString->Buffer) {
        LocalFree(OemString->Buffer);
        memset( OemString, 0, sizeof( *OemString ) );
        }
}


BOOLEAN
MyRtlEqualDomainName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualDomainName function compares two domain names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReturnValue = FALSE;
    OEM_STRING OemString1;
    OEM_STRING OemString2;

    //
    // Upper case and convert the first string to OEM
    //

    Status = MyRtlUpcaseUnicodeStringToOemString( &OemString1,
                                                String1,
                                                TRUE );   // Allocate Dest

    if ( NT_SUCCESS( Status ) ) {

        //
        // Upper case and convert the second string to OEM
        //

        Status = MyRtlUpcaseUnicodeStringToOemString( &OemString2,
                                                    String2,
                                                    TRUE );   // Allocate Dest

        if ( NT_SUCCESS( Status ) ) {

            //
            // Do a case insensitive comparison.
            //

            ReturnValue = MyRtlEqualString( &OemString1,
                                          &OemString2,
                                          FALSE );

            MyRtlFreeOemString( &OemString2 );
        }

        MyRtlFreeOemString( &OemString1 );
    }

    return ReturnValue;
}


VOID
MyRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
}

LONG
MyRtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);
    DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                WCHAR uc1, uc2;

                //
                // Note that this needs to reference the translation table!
                //

// WIN32_CHICAGO Need to do something better here
                uc1 = MyUpcaseChar(c1);
                uc2 = MyUpcaseChar(c2);
                if (uc1 != uc2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


VOID
MyRtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{

    if (UnicodeString->Buffer) {
        LocalFree(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


NTSTATUS
MyRtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    NTSTATUS Status;
    UCHAR Buffer[256];
    UCHAR String[256];

    UCHAR   i;
    ULONG   Tmp;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure

    ANSI_STRING AnsiString;

#ifndef WIN32_CHICAGO // Painful to do this
    if (RtlValidSid( Sid ) != TRUE) {
        return(STATUS_INVALID_SID);
    }
#endif // WIN32_CHICAGO


    _snprintf((CHAR *)Buffer, sizeof(Buffer), "S-%u-", (USHORT)iSid->Revision );
    strcpy((char *)String, (const char *)Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        _snprintf((CHAR *) Buffer, sizeof(Buffer), "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        strcat((char *) String, (const char *)Buffer);

    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        _snprintf((char *)Buffer, sizeof(Buffer), "%lu", Tmp);
        strcat((char *)String, (const char *)Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        _snprintf((char *) Buffer, sizeof(Buffer), "-%lu", iSid->SubAuthority[i]);
        strcat((char *)String, (const char *)Buffer);
    }

    //
    // Convert the string to a Unicode String
    //

    RtlInitString(&AnsiString, (PSZ) String);

    Status = RtlAnsiStringToUnicodeString( UnicodeString,
                                           &AnsiString,
                                           AllocateDestinationString
                                           );

    return(Status);
}


//
// Inline functions to convert between FILETIME and TimeStamp
//
#pragma warning( disable : 4035)    // Don't complain about no return

TimeStamp __inline
FileTimeToTimeStamp(
    const FILETIME *pft)
{
    _asm {
        mov edx, pft
        mov eax, [edx].dwLowDateTime
        mov edx, [edx].dwHighDateTime
    }
}

#pragma warning( default : 4035)    // Reenable warning

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    )
/*++

Routine Description:

    This routine returns the current system time (UTC), as a timestamp
    (a 64-bit unsigned integer, in 100-nanosecond increments).

Arguments:

    None.

Return Value:

    The current system time.

--*/

{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    *SystemTimeStamp = FileTimeToTimeStamp(&FileTime);

    return STATUS_SUCCESS; // WIN32_CHICAGO do something useful here
}


NTSTATUS
MyNtAllocateLocallyUniqueId(
    OUT PLUID Luid
    )
{
    // WIN32_CHICAGO do something useful here
    Luid->HighPart = 1;
    Luid->LowPart = 1;
    return STATUS_SUCCESS;
}

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    )
{
    // We don't care about these. Just fake it so that the common code does
    // look too unreadable.

    MyNtAllocateLocallyUniqueId (&ClientInfo->LogonId);
    ClientInfo->HasTcbPrivilege = TRUE;
    ClientInfo->ProcessID = 0;
    return STATUS_SUCCESS;
}

BOOLEAN
GetCallInfo(
    OUT PSECPKG_CALL_INFO CallInfo
    )
{
    ZeroMemory( CallInfo, sizeof( SECPKG_CALL_INFO ) );
    return(TRUE);
}


NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    )
{
    RtlCopyMemory(
        BufferToCopy,
        ClientBaseAddress,
        Length
        );
    return STATUS_SUCCESS;
}

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )
{
    *ClientBaseAddress = (PVOID)KerbAllocate(LengthRequired);
    if (ClientBaseAddress == NULL)
    {
        return STATUS_NO_MEMORY;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )
{
    RtlCopyMemory(
        ClientBaseAddress,
        BufferToCopy,
        Length
        );

    return STATUS_SUCCESS;
}

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    )
{
    KerbFree(ClientBaseAddress);

    return STATUS_SUCCESS;
}

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    )
{
    // WIN32_CHICAGO do something useful here
}

ULONG
MyRtlLengthSid (
    PSID Sid
    )
{
    return 0;
}

BOOLEAN
MyRtlValidSid (
    PSID Sid
    )
{
    return TRUE;
}

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

NTSTATUS
MyNtClose(
    IN HANDLE Handle
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

PVOID
AllocateLsaHeap(
    IN ULONG Length
    )
{
    return LocalAlloc(0, Length);
}

VOID
FreeLsaHeap(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

VOID
FreeReturnBuffer(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    LocalFree(pvContextBuffer);
    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello2\client\hello2c.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello2.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABD";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello2_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello2_IfHandle,
                    "makalu\\mikesw",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc2(pszString);    // make call with user message
        }
        Shutdown2();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello2_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\chicago\kerbstub.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Kerberos Security Support Provider client stubs.

Author:

    Chandana Surlu (ChandanS) 11-Feb-1997

Environment:  Win9x User Mode

Revision History:

--*/

#include <kerb.hxx>

#include <rpc.h>          // PSEC_WINNT_AUTH_IDENTITY
#include <stdarg.h>       // Variable-length argument support

#define KERBSTUB_ALLOCATE

#include <kerbp.h>

SECPKG_DLL_FUNCTIONS UserFunctionTable;
VOID
KerbShutdownSecurityInterface(
    VOID
    );

VOID DumpLogonSession();

BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    ULONG  dwReason,
    PVOID  lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeCriticalSection( &KerbDllCritSect );

#if DBG
        InitializeCriticalSection( &KerbGlobalLogFileCritSect );
        KerbInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API |
                        DEB_TRACE_CRED | DEB_TRACE_CTXT | DEB_TRACE_LOCKS |
                        DEB_TRACE_CTXT2 | DEB_TRACE_KDC | DEB_TRACE_LSESS |
                        DEB_TRACE_LOGON;
#endif // DBG
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        KerbShutdownSecurityInterface();
#if DBG
        DeleteCriticalSection( &KerbGlobalLogFileCritSect );
#endif // DBG

        DeleteCriticalSection( &KerbDllCritSect );
    }

    return TRUE;
}


PSecurityFunctionTable
InitSecurityInterfaceA(
    VOID
    )

/*++

Routine Description:

    RPC calls this function to get the addresses of all the other functions
    that it might call.

Arguments:

    None.

Return Value:

    A pointer to our static SecurityFunctionTable.  The caller need
    not deallocate this table.

--*/

{
    HKEY hRegKey;
    DWORD dwError = 0, dwSize = 0;
    DWORD dwType = REG_BINARY;
    LPWSTR pUserName = NULL, pDomainName = NULL;
    PKERB_LOGON_SESSION_CACHE RegLogonSession = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    SECURITY_STATUS Status = SEC_E_OK;

    // BUBUG Init this to something, we need Parameters.DomainName,
    // Parameters.DnsDomainName & Parameters.version at least
    SECPKG_PARAMETERS Parameters;
    PVOID ignored = NULL;

    DebugLog((DEB_TRACE_API, "Entering KerbInitSecurityInterface\n"));

    // Initialize the SecurityFunctionTable
    ZeroMemory( &KerbDllSecurityFunctionTable,
                sizeof(KerbDllSecurityFunctionTable) );

    KerbGlobalCapabilities  = KERBEROS_CAPABILITIES;

    KerbGlobalEncryptionPermitted = TRUE; //unless proven otherwise

    KerberosState = KerberosUserMode;

    KerbDllSecurityFunctionTable.dwVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;

    KerbDllSecurityFunctionTable.EnumerateSecurityPackages = KerbEnumerateSecurityPackages;
    KerbDllSecurityFunctionTable.AcquireCredentialsHandle = KerbAcquireCredentialsHandle;
    KerbDllSecurityFunctionTable.FreeCredentialHandle = KerbFreeCredentialsHandle;
    KerbDllSecurityFunctionTable.InitializeSecurityContext = KerbInitializeSecurityContext;
    KerbDllSecurityFunctionTable.QueryCredentialsAttributes = KerbQueryCredentialsAttributes;
    KerbDllSecurityFunctionTable.AcceptSecurityContext = NULL;
    KerbDllSecurityFunctionTable.CompleteAuthToken = KerbCompleteAuthToken;
    KerbDllSecurityFunctionTable.QueryContextAttributes = KerbQueryContextAttributes;
    KerbDllSecurityFunctionTable.SspiLogonUser = KerbSspiLogonUser;
    KerbDllSecurityFunctionTable.DeleteSecurityContext = KerbDeleteSecurityContext;
    KerbDllSecurityFunctionTable.ApplyControlToken = KerbApplyControlToken;
    KerbDllSecurityFunctionTable.ImpersonateSecurityContext = KerbImpersonateSecurityContext;
    KerbDllSecurityFunctionTable.RevertSecurityContext = KerbRevertSecurityContext;
    KerbDllSecurityFunctionTable.MakeSignature = KerbMakeSignature;
    KerbDllSecurityFunctionTable.VerifySignature = KerbVerifySignature;
    KerbDllSecurityFunctionTable.FreeContextBuffer = KerbFreeContextBuffer;
    KerbDllSecurityFunctionTable.QuerySecurityPackageInfo = KerbQuerySecurityPackageInfo;
    KerbDllSecurityFunctionTable.Reserved3 = KerbSealMessage;
    KerbDllSecurityFunctionTable.Reserved4 = KerbUnsealMessage;
    KerbDllSecurityFunctionTable.EncryptMessage = KerbSealMessage;
    KerbDllSecurityFunctionTable.DecryptMessage = KerbUnsealMessage;


// Before we call SpInitialize, fill a table of LsaFunctions that are
// imlemented locally. This is done so that the code does not look awful.
// Fill in dummy functions in case more functions are used so we don't
// av

//    FunctionTable.CreateLogonSession = CreateLogonSession;
//    FunctionTable.DeleteLogonSession = DeleteLogonSession;
//    FunctionTable.AddCredential     =  AddCredential;
//    FunctionTable.GetCredentials    =  GetCredentials;
//    FunctionTable.DeleteCredential   = DeleteCredential;
    FunctionTable.AllocateLsaHeap  =    AllocateLsaHeap;
    FunctionTable.FreeLsaHeap       =  FreeLsaHeap;
    FunctionTable.AllocateClientBuffer = AllocateClientBuffer;
    FunctionTable.FreeClientBuffer   = FreeClientBuffer;
    FunctionTable.CopyToClientBuffer = CopyToClientBuffer;
    FunctionTable.CopyFromClientBuffer = CopyFromClientBuffer;
//    FunctionTable.ImpersonateClient = ImperosnateClient;
//    FunctionTable.UnloadPackage = UnloadPackage;
    FunctionTable.DuplicateHandle = KerbDuplicateHandle;
//    FunctionTable.SaveSupplementalCredentials = SaveSupplementalCredentials;
//    FunctionTable.GetWindow = GetWindow;
//    FunctionTable.ReleaseWindow = ReleaseWindow;
//    FunctionTable.CreateThread = CreateThread;
    FunctionTable.GetClientInfo = GetClientInfo;
//    FunctionTable.RegisterNotification = RegisterNotification;
//    FunctionTable.CancelNotification = CancelNotification;
    FunctionTable.MapBuffer = MapBuffer;
//    FunctionTable.CreateToken = CreateToken;
    FunctionTable.AuditLogon = AuditLogon;
//    FunctionTable.CallPackage = CallPackage;
    FunctionTable.FreeReturnBuffer = FreeReturnBuffer;
    FunctionTable.GetCallInfo = GetCallInfo;
//    FunctionTable.CallPackageEx = CallPackageEx;
//    FunctionTable.CreateSharedMemory = CreateSharedMemory;
//    FunctionTable.AllocateSharedMemory = AllocateSharedMemory;
//    FunctionTable.FreeSharedMemory = FreeSharedMemory;
//    FunctionTable.DeleteSharedMemory = DeleteSharedMemory;
//    FunctionTable.OpenSamUser  = OpenSamUser;
//    FunctionTable.GetUserCredentials =  GetUserCredentials;
//    FunctionTable.GetUserAuthData  = GetUserAuthData;
//    FunctionTable.CloseSamUser  = CloseSamUser;
//    FunctionTable.ConvertAuthDataToTokenInfo = ConvertAuthDataToTokenInfo;

    // we call into the kerb routines
    Parameters.Version = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    Parameters.MachineState = SECPKG_STATE_STANDALONE;

    // NOTE - Yikes!
    Parameters.DomainName.Buffer = L"";
    Parameters.DomainName.Length = 0;
    Parameters.DomainName.MaximumLength = 2;
    Parameters.DnsDomainName.Buffer = L"";
    Parameters.DnsDomainName.Length = 0;
    Parameters.DnsDomainName.MaximumLength = 2;

    // If logon session data exists, load it

    if ( ERROR_SUCCESS != ( dwError = RegOpenKeyEx (
                               HKEY_LOCAL_MACHINE,
                               KERBEROS_TICKET_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hRegKey ) ) )
    {
        DebugLog((DEB_ERROR, "Error opening KERBEROS_TICKET_KEY\n"));
        goto RestOfInit;
    }

    // get username size
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_USERNAME_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading KERBEROS_TICKET_USERNAME_KEY size\n"));
        goto RestOfInit;
    }

    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_USERNAME_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    pUserName = (LPWSTR) KerbAllocate(dwSize);

    if (pUserName == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_USERNAME_KEY \n"));
        goto RestOfInit;
    }
    // get username into LogonSession->PrimaryCredentials->Username
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_USERNAME_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) pUserName,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_USERNAME_KEY\n"));
        goto RestOfInit;
    }

    // get domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_DOMAINNAME_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading KERBEROS_TICKET_DOMAINNAME_KEY size\n"));
        goto RestOfInit;
    }
    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_DOMAINNAME_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    pDomainName = (LPWSTR) KerbAllocate(dwSize);

    if (pDomainName == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_DOMAINNAME_KEY \n"));
        goto RestOfInit;
    }
    // get domainname into LogonSession->PrimaryCredentials->Domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_DOMAINNAME_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) pDomainName,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_DOMAINNAME_KEY\n"));
        goto RestOfInit;
    }

    // get domainname into Parameters.DomainName
    Parameters.DomainName.Buffer = pDomainName;
    Parameters.DomainName.Length = (USHORT)dwSize;
    Parameters.DomainName.MaximumLength = (USHORT)dwSize;


    // get logon session data size
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_LOGONSESSION_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        goto RestOfInit;
    }

    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_LOGONSESSION_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    RegLogonSession = (PKERB_LOGON_SESSION_CACHE) KerbAllocate(dwSize);

    if (RegLogonSession == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
        goto RestOfInit;
    }
    // get logon session into LogonSession->PrimaryCredentials->Domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_LOGONSESSION_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) RegLogonSession,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        goto RestOfInit;
    }


    if ( ERROR_SUCCESS != ( dwError = RegCloseKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error closing KERBEROS_TICKET_KEY\n"));
        goto RestOfInit;
    }

RestOfInit:

    Status = SpInitialize(1, &Parameters, &FunctionTable);

// Do the user mode init too
// Before we call SpInstanceInit, fill a table of functions that are
// imlemented locally. This is done so that the code does not look awful.
// Fill in dummy functions in case more functions are used so we don't
// av

    UserFunctionTable.FreeHeap = FreeLsaHeap;
    UserFunctionTable.AllocateHeap = AllocateLsaHeap;

    Status = SpInstanceInit(SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                            &UserFunctionTable,
                            &ignored );


    // Now, copy the logon sessions (if they exist)
    // This is kina what KerbCreateLogonSession does, expect that we don't
    // have to build password list etc.

    if (RegLogonSession != NULL)
    {
        LUID LogonId;
        NTSTATUS Status;
        ULONG PasswordSize, EncryptKeySize, CredentialSize;
        ULONG Index;
        PUCHAR Base;
        UINT Offset;

       //
       // Allocate the new logon session
       //

       Status = NtAllocateLocallyUniqueId (&LogonId);

       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }

       Status = KerbAllocateLogonSession( &LogonSession );

       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }

       //
       // Fill in the logon session components
       //

       LogonSession->Lifetime = RegLogonSession->Lifetime;
       LogonSession->LogonSessionFlags = RegLogonSession->LogonSessionFlags;
       LogonSession->LogonId = LogonId;

       //
       // Munge RegLogonSession & ptrs for username & domainame
       //

       RegLogonSession->UserName.Buffer = (LPWSTR)((PUCHAR)RegLogonSession + (INT)(RegLogonSession->UserName.Buffer));

       RegLogonSession->DomainName.Buffer = (LPWSTR)((PUCHAR)RegLogonSession + (INT)(RegLogonSession->DomainName.Buffer));

       //
       // actually copy the username struct and alloc username.buffer
       //

       LogonSession->PrimaryCredentials.UserName.Buffer = (LPWSTR) KerbAllocate(RegLogonSession->UserName.MaximumLength);

       if (LogonSession->PrimaryCredentials.UserName.Buffer == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       RtlCopyMemory(LogonSession->PrimaryCredentials.UserName.Buffer,
                     RegLogonSession->UserName.Buffer,
                     RegLogonSession->UserName.MaximumLength);

       LogonSession->PrimaryCredentials.UserName.Length = RegLogonSession->UserName.Length;
       LogonSession->PrimaryCredentials.UserName.MaximumLength = RegLogonSession->UserName.MaximumLength;


       // actually copy the domainname struct and alloc domainname.buffer

       LogonSession->PrimaryCredentials.DomainName.Buffer = (LPWSTR) KerbAllocate(RegLogonSession->DomainName.MaximumLength);

       if (LogonSession->PrimaryCredentials.DomainName.Buffer == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       RtlCopyMemory(LogonSession->PrimaryCredentials.DomainName.Buffer,
                     RegLogonSession->DomainName.Buffer,
                     RegLogonSession->DomainName.MaximumLength);

       LogonSession->PrimaryCredentials.DomainName.Length = RegLogonSession->DomainName.Length;
       LogonSession->PrimaryCredentials.DomainName.MaximumLength = RegLogonSession->DomainName.MaximumLength;


       //
       //  What is the size of the Credentials struct
       //

       EncryptKeySize = sizeof(KERB_KEY_DATA) * RegLogonSession->CredentialCount;
       PasswordSize = 0;

       for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
       {
           PasswordSize += RegLogonSession->Credentials[Index].keyvalue.length;
           RegLogonSession->Credentials[Index].keyvalue.value = (unsigned char*)
                   ((PUCHAR) RegLogonSession  +
                   (INT)(RegLogonSession->Credentials[Index].keyvalue.value));
       } // for

       //
       // Alloc & copy over the Credentials block
       //

       CredentialSize = sizeof(KERB_STORED_CREDENTIAL) -
                        (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                        EncryptKeySize + PasswordSize;

       LogonSession->PrimaryCredentials.Passwords = (PKERB_STORED_CREDENTIAL) KerbAllocate(CredentialSize);

       if (LogonSession->PrimaryCredentials.Passwords == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       //
       // copy revision, flags & credentialcount
       //

       LogonSession->PrimaryCredentials.Passwords->Revision = RegLogonSession->Revision;
       LogonSession->PrimaryCredentials.Passwords->Flags = RegLogonSession->Flags;
       LogonSession->PrimaryCredentials.Passwords->CredentialCount = RegLogonSession->CredentialCount;

       //
       // copy all keyvalue.value
       //

       Offset = 0;
       Base = (PUCHAR)LogonSession->PrimaryCredentials.Passwords +
              CredentialSize - PasswordSize;

       for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
       {
           RtlCopyMemory(Base + Offset,
                         RegLogonSession->Credentials[Index].keyvalue.value,
                         RegLogonSession->Credentials[Index].keyvalue.length);

           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keytype =
                         RegLogonSession->Credentials[Index].keytype;
           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length =
                         RegLogonSession->Credentials[Index].keyvalue.length;
           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value =
                         (unsigned char*) (Base + Offset);
           Offset += RegLogonSession->Credentials[Index].keyvalue.length;
       } // for

       //
       // All logons are deferred until proven otherwise
       //

       LogonSession->LogonSessionFlags = KERB_LOGON_DEFERRED;

       if (LogonSession->PrimaryCredentials.Passwords == NULL)
       {
           LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
       }

       //
       // Now that the logon session structure is filled out insert it
       // into the list. After this you need to hold the logon session lock
       // to read or write this logon session.
       //

       Status = KerbInsertLogonSession(LogonSession);
       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbFreeLogonSession(LogonSession);
        }
    }
    else
    {
        if (LogonSession != NULL)
        {
            KerbDereferenceLogonSession(LogonSession);
        }
    }

    if (RegLogonSession != NULL)
    {
        KerbFree(RegLogonSession);
    }
    // NOTE - what about pUsername & pDomainname

    DebugLog((DEB_TRACE_API, "Leaving KerbInitSecurityInterface\n"));
    return SEC_SUCCESS(Status) ? &KerbDllSecurityFunctionTable : NULL;
}


VOID
KerbShutdownSecurityInterface(
    VOID
    )

/*++

Routine Description:

    Cleanup the data shared by the DLL and SERVICE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKERB_LOGON_SESSION LogonSession;
    LUID LogonId;
    PKERB_LOGON_SESSION_CACHE RegLogonSession;

    HKEY hRegKey;
    DWORD dwDisposition;
    DWORD dwError = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_API, "Entering KerbShutdownSecurityInterface\n"));

    Status = NtAllocateLocallyUniqueId (&LogonId);

    LogonSession = KerbReferenceLogonSession(
                           &LogonId,
                           TRUE);

    // Need to dump out logon session info in the registry
    // create or open the parameters key
    if ( ( dwError = RegCreateKeyEx (
                                   HKEY_LOCAL_MACHINE,
                                   KERBEROS_TICKET_KEY,
                                   0,
                                   "",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hRegKey,
                                   &dwDisposition) ) )
    {
        DebugLog((DEB_ERROR, "Error creating KERBEROS_TICKET_KEY\n"));
        goto Cleanup;
    }

    if (LogonSession != NULL)
    {
        ULONG PasswordSize, Offset;
        ULONG Index;
        ULONG TotalSize = 0 ;
        PUCHAR Base;

        //
        // Compute the size of the passwords, which are assumed to be
        // marshalled in order.
        //

        PasswordSize = sizeof(KERB_LOGON_SESSION_CACHE) - sizeof(KERB_KEY_DATA) * ANYSIZE_ARRAY +
                        LogonSession->PrimaryCredentials.Passwords->CredentialCount * sizeof(KERB_KEY_DATA);

        for (Index = 0; Index < LogonSession->PrimaryCredentials.Passwords->CredentialCount ; Index++ )
        {
            PasswordSize += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;
            DsysAssert((PUCHAR) LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value <=
                (PUCHAR) LogonSession->PrimaryCredentials.Passwords + PasswordSize );
        }

        // Total size of the logon session cache
        TotalSize = LogonSession->PrimaryCredentials.UserName.MaximumLength +
                    LogonSession->PrimaryCredentials.DomainName.MaximumLength +
                    PasswordSize;

        RegLogonSession = (PKERB_LOGON_SESSION_CACHE) KerbAllocate(TotalSize);

        if (RegLogonSession == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RegLogonSession->Lifetime =
                    LogonSession->Lifetime;
        RegLogonSession->LogonSessionFlags =
                    LogonSession->LogonSessionFlags;
        RegLogonSession->UserName.Length =
                    LogonSession->PrimaryCredentials.UserName.Length;
        RegLogonSession->UserName.MaximumLength =
                    LogonSession->PrimaryCredentials.UserName.MaximumLength;
        RegLogonSession->DomainName.Length =
                    LogonSession->PrimaryCredentials.DomainName.Length;
        RegLogonSession->DomainName.MaximumLength =
                    LogonSession->PrimaryCredentials.DomainName.MaximumLength;
        RegLogonSession->Revision =
                    LogonSession->PrimaryCredentials.Passwords->Revision;
        RegLogonSession->Flags =
                    LogonSession->PrimaryCredentials.Passwords->Flags;
        RegLogonSession->CredentialCount=
                    LogonSession->PrimaryCredentials.Passwords->CredentialCount;

        Base = (PUCHAR) RegLogonSession;

        Offset = sizeof(KERB_LOGON_SESSION_CACHE) -
                 (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                 (RegLogonSession->CredentialCount * sizeof(KERB_KEY_DATA));
        // Offset from the struct

        RegLogonSession->UserName.Buffer = (LPWSTR)Offset;

        RtlCopyMemory(Base + Offset,
                      LogonSession->PrimaryCredentials.UserName.Buffer,
                      LogonSession->PrimaryCredentials.UserName.MaximumLength);

        Offset += LogonSession->PrimaryCredentials.UserName.MaximumLength;

        RegLogonSession->DomainName.Buffer = (LPWSTR)(Offset);

        RtlCopyMemory(Base + Offset,
                      LogonSession->PrimaryCredentials.DomainName.Buffer,
                      LogonSession->PrimaryCredentials.DomainName.MaximumLength);
        Offset += LogonSession->PrimaryCredentials.DomainName.MaximumLength;

        for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
        {
            RegLogonSession->Credentials[Index].keytype =
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keytype;

            RegLogonSession->Credentials[Index].keyvalue.length =
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

            RegLogonSession->Credentials[Index].keyvalue.value =
                    (unsigned char *) (Offset);

            RtlCopyMemory(Base + Offset,
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value,
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length);

            Offset += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

        } // for


        // add username from LogonSession->PrimaryCredentials->Username
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_USERNAME_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) LogonSession->PrimaryCredentials.UserName.Buffer,
                                   LogonSession->PrimaryCredentials.UserName.Length
                                   ) ))
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_USERNAME_KEY\n"));
            goto Cleanup;
        }

        // add domainname from LogonSession->PrimaryCredentials->domainname
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_DOMAINNAME_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) LogonSession->PrimaryCredentials.DomainName.Buffer,
                                   LogonSession->PrimaryCredentials.DomainName.Length)))
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_DOMAINNAME_KEY\n"));
            goto Cleanup;
        }

        // add logon session data from RegLogonSession & TotalSize
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_LOGONSESSION_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) RegLogonSession,
                                   TotalSize) ) )
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_LOGONSESSION_KEY\n"));
            goto Cleanup;
        }
    }
    else // (LogonSession is NULL)
    {
        // We did not have any valid kerberos logon sessions.
        // Delete all the registry values in keys.

        DebugLog((DEB_TRACE, "No Kerberos LogonSession\n"));
        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_USERNAME_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_USERNAME_KEY\n"));
        }

        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_DOMAINNAME_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_DOMAINNAME_KEY\n"));
        }

        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_LOGONSESSION_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        }

    }

Cleanup:

    if ( ( dwError = RegFlushKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error Flushing KERBEROS_TICKET_KEY\n"));
    }

    if ( ( dwError = RegCloseKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error closing KERBEROS_TICKET_KEY\n"));
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
        LogonSession = NULL;
    }

    SpShutdown();

    DebugLog((DEB_TRACE_API, "Leaving KerbShutdownSecurityInterface\n"));

}


SECURITY_STATUS
KerbSpGetInfo(
    IN LPTSTR PackageName,
    OUT PSecPkgInfo *PackageInfo
    )

/*++

Routine Description:

    This API is intended to provide basic information about Security
    Packages themselves.  This information will include the bounds on sizes
    of authentication information, credentials and contexts.

    ?? This is a local routine rather than the real API call since the API
    call has a bad interface that neither allows me to allocate the
    buffer nor tells me how big the buffer is.  Perhaps when the real API
    is fixed, I'll make this the real API.

Arguments:

     PackageName - Name of the package being queried.

     PackageInfo - Returns a pointer to an allocated block describing the
        security package.  The allocated block must be freed using
        FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    LPTSTR Where;

    //
    // Ensure the correct package name was passed in.
    //

    if ( lstrcmpi( PackageName, KERBEROS_PACKAGE_NAME ) != 0 ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) LocalAlloc( 0, sizeof(SecPkgInfo) +
                                  sizeof(KERBEROS_PACKAGE_NAME) +
                                  sizeof(KERBEROS_PACKAGE_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = KerbGlobalCapabilities;
    (*PackageInfo)->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    (*PackageInfo)->cbMaxToken = KERBEROS_MAX_TOKEN;

    Where = (LPTSTR)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_NAME);
    Where += lstrlen(Where) + 1;

    (*PackageInfo)->Comment = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_COMMENT);
    Where += lstrlen(Where) + 1;

    return SEC_E_OK;
}


SECURITY_STATUS
KerbEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    )

/*++

Routine Description:

    This API returns a list of Security Packages available to client (i.e.
    those that are either loaded or can be loaded on demand).  The caller
    must free the returned buffer with FreeContextBuffer.  This API returns
    a list of all the security packages available to a service.  The names
    returned can then be used to acquire credential handles, as well as
    determine which package in the system best satisfies the requirements
    of the caller.  It is assumed that all available packages can be
    included in the single call.

    This is really a dummy API that just returns information about this
    security package.  It is provided to ensure this security package has the
    same interface as the multiplexer DLL does.

Arguments:

     PackageCount - Returns the number of packages supported.

     PackageInfo - Returns an allocate array of structures
        describing the security packages.  The array must be freed
        using FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    //
    // Get the information for this package.
    //

    LPTSTR Where;

    *PackageCount = 1;
    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) LocalAlloc( 0, sizeof(SecPkgInfo) +
                                  sizeof(KERBEROS_PACKAGE_NAME) +
                                  sizeof(KERBEROS_PACKAGE_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = KerbGlobalCapabilities;
    (*PackageInfo)->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    (*PackageInfo)->cbMaxToken = KERBEROS_MAX_TOKEN;

    Where = (LPTSTR)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_NAME);
    Where += lstrlen(Where) + 1;

    (*PackageInfo)->Comment = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_COMMENT);
    Where += lstrlen(Where) + 1;


    return SEC_E_OK;

}

SECURITY_STATUS
KerbQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo SEC_FAR * Package
    )
{

        return ( KerbSpGetInfo(
                                PackageName,
                                Package));

}



SECURITY_STATUS SEC_ENTRY
KerbFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    )

/*++

Routine Description:

    This API is provided to allow callers of security API such as
    InitializeSecurityContext() for free the memory buffer allocated for
    returning the outbound context token.

Arguments:

    ContextBuffer - Address of the buffer to be freed.

Return Value:

    SEC_E_OK - Call completed successfully

--*/

{
    //
    // The only allocated buffer that the kerb currently returns to the caller
    // is from EnumeratePackages.  It uses LocalAlloc to allocate memory.  If
    // we ever need memory to be allocated by the service, we have to rethink
    // how this routine distinguishes between to two types of allocated memory.
    //

    (VOID) LocalFree( ContextBuffer );
    return SEC_E_OK;
}

#if DBG
//
// Control which messages get displayed
//

// DWORD KerbInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API;

//
// SspPrintRoutine - Displays debug output
//
VOID __cdecl
KerbPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FormatString,    // PRINTF()-STYLE FORMAT STRING.
    ...                        // OTHER ARGUMENTS ARE POSSIBLE.
    )
{
    static char prefix[] = "KERB: ";
    char outbuf[256];
    va_list args;

    if ( DebugFlag & KerbInfoLevel) {
        EnterCriticalSection( &KerbGlobalLogFileCritSect );
        lstrcpy(outbuf, prefix);
        va_start(args, FormatString);
        wvsprintf(outbuf + sizeof(prefix) - 1, FormatString, args);
        OutputDebugString(outbuf);
        LeaveCriticalSection( &KerbGlobalLogFileCritSect );
    }

    return;
}
#endif DBG

SECURITY_STATUS
KerbAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;
    UNICODE_STRING NewPrincipalName;

    //
    // Validate the arguments
    //

    if ( lstrcmpi( PackageName, KERBEROS_PACKAGE_NAME ) != 0 ) {
        SecStatus = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    if ( (CredentialUseFlags & SECPKG_CRED_OUTBOUND) &&
         ARGUMENT_PRESENT(PrincipalName) && *PrincipalName != '\0' ) {
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(LogonId) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyArgument) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    //
    // Don't allow inbound credentials if we don't have an authentication
    // server avaiable
    //

    if ( (KerbGlobalCapabilities & SECPKG_FLAG_CLIENT_ONLY)
         && (CredentialUseFlags & SECPKG_CRED_INBOUND) ) {
        DebugLog(( SSP_API,
            "KerbAcquireCredentialHandle: no authentication service for inbound handle.\n" ));
        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &NewPrincipalName, PrincipalName)){
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;;
        goto Cleanup;
    }


    SecStatus = SpAcquireCredentialsHandle(
                            &NewPrincipalName,
                            CredentialUseFlags,
                            (PLUID)LogonId,
                            AuthData,
                            GetKeyFunction,
                            GetKeyArgument,
                            &CredentialHandle->dwUpper,
                            Lifetime );

Cleanup:

    return SecStatus;

}

SECURITY_STATUS
KerbFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:

    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    SEC_E_OK -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    SECURITY_STATUS SecStatus;




    SecStatus = SpFreeCredentialsHandle(
                            CredentialHandle->dwUpper );



    return SecStatus;

}

SECURITY_STATUS
KerbQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    SECURITY_STATUS SecStatus;


    SecStatus = SpQueryCredentialsAttributes(
                            CredentialsHandle->dwUpper,
                            Attribute,
                            Buffer );

    return SecStatus;
}

SECURITY_STATUS
KerbInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )
{
    UNICODE_STRING TargetNameUStr;
    BOOLEAN fMappedContext;
    SecBuffer ContextData;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    SECURITY_STATUS SecondaryStatus = SEC_E_OK;
    SecBufferDesc EmptyBuffer =  {0,0, NULL};

    RtlCreateUnicodeStringFromAsciiz (&TargetNameUStr, TargetName);

    if (!ARGUMENT_PRESENT(InputToken))
    {
        InputToken = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(OutputToken))
    {
        OutputToken = &EmptyBuffer;
    }

    SecStatus = SpInitLsaModeContext (
                          CredentialHandle ? CredentialHandle->dwUpper : NULL,
                          OldContextHandle ? OldContextHandle->dwUpper : NULL,
                          &TargetNameUStr,
                          ContextReqFlags,
                          TargetDataRep,
                          InputToken,
                          &NewContextHandle->dwUpper,
                          OutputToken,
                          ContextAttributes,
                          ExpirationTime,
                          &fMappedContext,
                          &ContextData);

    if (NT_SUCCESS(SecStatus) && fMappedContext)
    {
        SecondaryStatus = SpInitUserModeContext(NewContextHandle->dwUpper,
                                 &ContextData);

        if (!NT_SUCCESS(SecondaryStatus))
        {
            SecStatus = SecondaryStatus;

            SecondaryStatus = KerbDeleteSecurityContext(NewContextHandle);
        }
    }

    return SecStatus;
}

SECURITY_STATUS
KerbDeleteSecurityContext (
    IN PCtxtHandle ContextHandle
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpDeleteContext (ContextHandle->dwUpper);

    return SecStatus;

}

SECURITY_STATUS
KerbApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpApplyControlToken(ContextHandle->dwUpper, Input);

    return SecStatus;
}


SECURITY_STATUS
KerbImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
KerbRevertSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
KerbQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpQueryContextAttributes(ContextHandle->dwUpper,
                                         Attribute,
                                         Buffer);

    return SecStatus;
}

SECURITY_STATUS SEC_ENTRY
KerbCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpCompleteAuthToken(ContextHandle->dwUpper, BufferDescriptor);

    return SecStatus;
}

SECURITY_STATUS
KerbMakeSignature (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpMakeSignature(ContextHandle->dwUpper,
                                QualityOfProtection,
                                Message,
                                SequenceNumber);

    return SecStatus;
}

SECURITY_STATUS
KerbVerifySignature (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpVerifySignature(ContextHandle->dwUpper,
                                  Message,
                                  SequenceNumber,
                                  QualityOfProtection);

    return SecStatus;
}

SECURITY_STATUS
KerbSealMessage (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpSealMessage(ContextHandle->dwUpper,
                              QualityOfProtection,
                              Message,
                              SequenceNumber);

    return SecStatus;
}

SECURITY_STATUS
KerbUnsealMessage (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpUnsealMessage(ContextHandle->dwUpper,
                                Message,
                                SequenceNumber,
                                QualityOfProtection);

    return SecStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello3\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "761";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    "makalu\\mikesw",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<5 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello2\server\hello2s.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello2.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789AB3";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'n':  // network address
                    pszNetworkAddress = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 'u':
                    pszUuid = argv[++i];
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello2_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", RPC_C_AUTHN_DCE_PRIVATE, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
                side of RPC distributed application
    FUNCTIONS:  HelloProc() - prints "hello, world" or other string
                sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc2(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    CHAR UserName[100];
    ULONG NameLen = 100;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }
    GetUserName(UserName,&NameLen);
    printf("%s: %s\n",UserName, pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown2(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\ssp\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <netlib.h>     // NetpGetLocalDomainId


#define SECURITY_KERBEROS
#include <security.h>   // General definition of a Security Support Provider

BOOLEAN QuietMode = FALSE; // Don't be verbose
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
#define MAX_RECURSION_DEPTH 2


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

VOID
ConfigureServiceRoutine(
    VOID
    )
/*++

Routine Description:

    Configure the NtLmSsp Service

Arguments:

    None

Return Value:

    None

--*/
{
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    WCHAR ServiceName[MAX_PATH];
    DWORD WinStatus,NetStatus;
    HKEY LsaKey = NULL;
    USER_INFO_1 UserInfo;
    PSID PrimaryDomain = NULL;
    PSID AccountDomain = NULL;

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_ACCOUNTS, &AccountDomain) != NERR_Success)
    {
        printf("Failed to get account domain ID\n");
        return;
    }

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_PRIMARY, &PrimaryDomain) != NERR_Success)
    {
        printf("Failed to get primary domain ID\n");
        return;
    }


    //
    // First set REDMOND as the preferred domain
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa\\MSV1_0",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"PreferredDomain",
                    0,
                    REG_SZ,
                    (PBYTE) L"REDMOND",
                    sizeof(L"REDMOND")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }
    //
    // Then add Kerberos as a security package
    //


    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"Security Packages",
                    0,
                    REG_MULTI_SZ,
                    (PBYTE) L"Kerberos\0",
                    sizeof(L"Kerberos\0")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }


    //
    // First add Kerberos as a security package for RPC
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Rpc\\SecurityService",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"1",
                    0,
                    REG_SZ,
                    (PBYTE) L"secur32.dll",
                    sizeof(L"secur32.dll")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    //
    // If we are on a DC (and the primary domain sid == account domain sid)
    // setup the KDC service
    //

    if ((PrimaryDomain) != NULL && RtlEqualSid(PrimaryDomain, AccountDomain))
    {
        //
        // Build the name of the Kerberos service.
        //

        if ( !GetWindowsDirectoryW(
                ServiceName,
                sizeof(ServiceName)/sizeof(WCHAR) ) ) {
            printf( "GetWindowsDirectoryW failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        wcscat( ServiceName, L"\\system32\\lsass.exe" );


        //
        // Open a handle to the Service Controller
        //

        ScManagerHandle = OpenSCManager(
                              NULL,
                              NULL,
                              SC_MANAGER_CREATE_SERVICE );

        if (ScManagerHandle == NULL) {
            printf( "OpenSCManager failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        //
        // If the service already exists,
        //  delete it and start afresh.
        //

        ServiceHandle = OpenService(
                            ScManagerHandle,
                            L"KDC",
                            DELETE );

        if ( ServiceHandle == NULL ) {
            WinStatus = GetLastError();
            if ( WinStatus != ERROR_SERVICE_DOES_NOT_EXIST ) {
                printf( "OpenService failed:" );
                PrintStatus( WinStatus );
                goto Cleanup;
            }
        } else {

            if ( !DeleteService( ServiceHandle ) ) {
                printf( "DeleteService failed:" );
                PrintStatus( GetLastError() );
                goto Cleanup;
            }

            (VOID) CloseServiceHandle(ServiceHandle);
        }

        //
        // Create the service
        //

        ServiceHandle = CreateService(
                            ScManagerHandle,
                            L"KDC",
                            L"Key Distribution Center",
                            SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG,
                            SERVICE_WIN32_SHARE_PROCESS,
                            SERVICE_AUTO_START,
                            SERVICE_ERROR_NORMAL,
                            ServiceName,
                            NULL,       // No load order group
                            NULL,       // No Tag Id required
                            L"Netlogon\0rpcss\0afd\0",
                            NULL,       // Run as LocalSystem
                            NULL );     // No password



        if ( ServiceHandle == NULL ) {
            printf( "CreateService failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }


        //
        // Create the KDC user account
        //

        UserInfo.usri1_name = L"KDC";
        UserInfo.usri1_password = L"KDC";
        UserInfo.usri1_password_age = 0;
        UserInfo.usri1_priv = USER_PRIV_USER;
        UserInfo.usri1_home_dir = NULL;
        UserInfo.usri1_comment = L"Key Distribution Center Service Account";
        UserInfo.usri1_script_path = NULL;
        UserInfo.usri1_flags = UF_SCRIPT;

        NetStatus = NetUserAdd(
                        NULL,
                        1,
                        &UserInfo,
                        NULL
                        );
        if ((NetStatus != NERR_Success) && (NetStatus != NERR_UserExists))
        {
            printf("Failed to create KDC account: %d\n",NetStatus);
        }

    }

Cleanup:
    if (PrimaryDomain != NULL)
    {
        LocalFree(PrimaryDomain);
    }
    if (AccountDomain != NULL)
    {
        LocalFree(AccountDomain);
    }

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    return;

}


VOID
TestSspRoutine(
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    BOOLEAN AcquiredServerCred = FALSE;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    WCHAR TargetName[100];



    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( L"kerberos", &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //
    if (ServerCredHandle == NULL)
    {

        ServerCredHandle = &ServerCredHandleStorage;
        AcquiredServerCred = TRUE;

        SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        L"kerberos",    // Package Name
                        SECPKG_CRED_INBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        ServerCredHandle,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "AcquireCredentialsHandle failed: ");
            PrintStatus( SecStatus );
            return;
        }

        if ( !QuietMode ) {
            printf( "ServerCredHandle: 0x%lx 0x%lx   ",
                    ServerCredHandle->dwLower, ServerCredHandle->dwUpper );
            PrintTime( "Lifetime: ", Lifetime );
        }

    }

    //
    // Acquire a credential handle for the client side
    //



    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    ClientFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_DCE_STYLE  | ISC_REQ_DATAGRAM; // | ISC_REQ_DELEGATE;

    if (Calls == 0)
    {
        ClientFlags |= ISC_REQ_IDENTIFY;
    }
    Calls++;

    wcscpy(
        TargetName,
        DomainName
        );
    wcscat(
        TargetName,
        L"\\"
        );
    wcscat(
        TargetName,
        UserName
        );

    InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetName,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }



#if 0



    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PrintTime("   Start:", ContextLifespan.tsStart );
        PrintTime("  Expiry:", ContextLifespan.tsExpiry );
    }

#endif



    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }
    ServerFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_DATAGRAM;

    AcceptStatus = AcceptSecurityContext(
                    ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }




    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
            return;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        L"\\\\Frank\\IPC$",     // Faked target name
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "\n\nAuthenticate Message:\n" );

            printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );

            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            0,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "AcceptSecurityContext (Challenge): " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                printf( "\n\nFinal Authentication:\n" );

                printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                printf(" \n" );
            }
        }

    }

#ifdef notdef
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif

    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }

    }

    //
    // If delegation is enabled and we are below our recursion depth, try
    // this again.
    //
    if ((ClientFlags & ISC_REQ_DELEGATE) && (++RecursionDepth < MAX_RECURSION_DEPTH))
    {
        TestSspRoutine();
    }

    //
    // RevertToSelf (ServerSide)
    //

//    SecStatus = RevertSecurityContext( &ServerContextHandle );
//
//    if ( SecStatus != STATUS_SUCCESS ) {
//        printf( "RevertSecurityContext: " );
//        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
//    }


#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

//    if (!RevertToSelf())
//    {
//        printf( "RevertToSelf failed: %d\n ",GetLastError() );
//        return;
//    }
    CloseHandle(Token);
#endif

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    if (AcquiredServerCred)
    {
        SecStatus = FreeCredentialsHandle( ServerCredHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "FreeCredentialsHandle failed: " );
            PrintStatus( SecStatus );
            return;
        }
        ServerCredHandle = NULL;

    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN LPSTR UserName,
    IN LPSTR DomainName,
    IN LPSTR Password
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    printf("Logging On %s\\%s %s\n",DomainName, UserName, Password);
    LogonInfoSize += (strlen(UserName) + ((DomainName == NULL)? 0 : strlen(DomainName)) + strlen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PKERB_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = KerbInteractiveLogon;

    RtlInitString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->UserName,
        &Name,
        FALSE
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->LogonDomainName,
        &Name,
        FALSE
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Password,
        &Name,
        FALSE
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = KerbInteractiveLogon;
    LogonInfo->Flags = 0;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &Name,
                Interactive,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        return;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
        return;
    }

    ImpersonateLoggedOnUser( TokenHandle );
    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();
    NtClose(TokenHandle);



}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;
    LPSTR UserName,DomainName,Password;




    enum {
        NoAction,
#define TESTSSP_PARAM "/TestSsp"
        TestSsp,
#define CONFIG_PARAM "/ConfigureService"
        ConfigureService,
#define LOGON_PARAM "/Logon"
        TestLogon,
    } Action = NoAction;





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //

        if ( _stricmp( argument, CONFIG_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = ConfigureService;


        } else if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;


        } else if ( _stricmp( argument, LOGON_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;

            if (argc < i + 2)
            {
                goto Usage;
            }
            Password = argv[++i];
            UserName = argv[++i];
            if (i < argc)
            {
                DomainName = argv[++i];
            }
            else
            {
                DomainName = NULL;
            }
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {

    case ConfigureService:
        ConfigureServiceRoutine();
        break;

    case TestSsp: {
        for ( j=0; j<Iterations ; j++ ) {
            TestSspRoutine( );
        }
        break;
    }
    case TestLogon : {
            TestLogonRoutine(
                UserName,
                DomainName,
                Password
                );
    }
    }

Usage:
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\tlogon\tlogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon2.c
//
//  Contents:   Logon test app
//
//  Classes:
//
//  Functions:
//
//  History:    6-20-94   richardw   Created
//
//----------------------------------------------------------------------------


#ifdef UNICODE
#undef UNICODE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>

#define DUMP_TOKEN  1
#define DUMP_HEX    2


char *User = NULL;
char *Domain = NULL;
char *Password = NULL;
char *SecPackage = NULL;
char *Cmd = NULL;

DWORD   fLogon = 0;
DWORD   fMe = 0;
DWORD   fService = 0;
DWORD   fCookie = 0;
FILE *  fOut;
DWORD   Threads;
DWORD   fDup = 0;
DWORD   LogonType = LOGON32_LOGON_INTERACTIVE;

char *  ImpLevels[] = { "Anonymous", "Identity", "Impersonation", "Delegation"};

char *  LogonTypes[] = { "Invalid", "Invalid", "Interactive", "Network", "Batch", "Service", "Proxy" };

void DumpToken(HANDLE hToken);

BOOL
WINAPI
KerbLogonUserW(
    PWSTR       lpszUsername,
    PWSTR       lpszDomain,
    PWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    );

BOOL
WINAPI
KerbLogonUserA(
    LPSTR       lpszUsername,
    LPSTR       lpszDomain,
    LPSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    );

BOOL
Logon32Initialize(
    VOID
    );

void
DoArgs(int argc,
        char **argv)

{
    int i;

    Threads = 1;

    if (argc < 3)
    {
        fprintf( fOut,"usage: %s <name> <domain> [-p pw] [-f flags] [-s] [-d] [-x cmd]\n", argv[0]);
        fprintf( fOut,"Tests logon path\n");
        fprintf( fOut," -p     \tOverride password\n");
        fprintf( fOut," -D     \tDump token\n");
        fprintf( fOut," -d     \tduplicate\n");
        fprintf( fOut," -s     \tLogon as service\n");
        fprintf( fOut," -x cmd \tStart cmd as user\n");
        fprintf( fOut," -o file\tSend output to file\n");
        fprintf( fOut," -t #   \tHit with # threads at once\n");
        fprintf( fOut," -l type\tLogon type\n");
        exit(1);
    }

    for (i = 1; i < argc ; i++ )
    {
        if (*argv[i] == '-')
        {
            switch (*(argv[i]+1))
            {
                case 'f':
                    fLogon = atoi(argv[++i]);
                    break;

                case 'd':
                    fDup = 1;
                    break;

                case 'D':
                    fMe |= DUMP_TOKEN;
                    break;

                case 'x':
                    Cmd = argv[++i];
                    break;

                case 'p':
                    Password = argv[++i];
                    break;

                case 't':
                    Threads = atoi(argv[++i]);
                    break;

                case 's':
                    LogonType = LOGON32_LOGON_SERVICE;
                    break;

                case 'l':
                    ++i;
                    if (argv[i] == NULL )
                    {
                        fprintf(fOut, "No logon type specified\n");
                        exit(1);
                    }
                    for (LogonType = 2 ;
                         LogonType < sizeof(LogonTypes) / sizeof(PSTR) ;
                         LogonType ++ )
                    {
                        if (_stricmp( LogonTypes[LogonType], argv[i]) == 0 )
                        {
                            break;
                        }
                    }

                    if (LogonType == (sizeof(LogonTypes) / sizeof(PSTR) ))
                    {
                        fprintf(fOut, "Invalid logon type '%s'\n", argv[i]);
                        exit(1);
                    }
                    break;

                case 'o':
                    fOut = fopen(argv[++i], "w");
                    if (!fOut)
                    {
                        fOut = stderr;
                    }
                    break;

                default:
                    fprintf( fOut,"Invalid switch %s\n", argv[i]);
                    exit(1);
            }
        }
        else
        {
            if (!User)
                User = argv[i];
             else
                if (!Domain)
                    Domain = argv[i];
        }
    }

    if (!Password)
        Password = User;
}

DWORD
DoIt(
    PVOID   pv)
{
    NTSTATUS         scRet, SubStatus, Status;
    PISID                   pSid;
    LUID                    Luid;
    TOKEN_GROUPS            TokenGroups;
    STRING                  sMe;
    HANDLE                  hToken;
    HANDLE                  hImp;
    HANDLE                  hDup;
    STRING                  sPackage;
    ULONG                   Package;
    LUID                    LogonId;
    TOKEN_SOURCE            TokenSource;
    char                    ImpersonateName[MAX_PATH];
    DWORD                   cbImpersonateName = MAX_PATH;
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    HANDLE  hWait;

    hWait = (HANDLE) pv;

    if (hWait != NULL)
    {
        WaitForSingleObjectEx( hWait, INFINITE, FALSE );
    }

    fprintf( fOut,"Logging on %s to %s\n", User, Domain);

    //
    // Copy the strings into the right places:
    //

    if (!KerbLogonUserA(User, Domain, Password,
                LogonType,
                LOGON32_PROVIDER_WINNT40, &hToken))
    {
        fprintf( fOut,"FAILED to logon, GetLastError is %d\n", GetLastError());
    }

    else
    {
        if (fMe & DUMP_TOKEN)
            DumpToken(hToken);

        if (!ImpersonateLoggedOnUser(hToken))
        {
            fprintf( fOut, "FAILED to impersonate, GetLastError is %d\n", GetLastError());
        }

        GetUserName(ImpersonateName, &cbImpersonateName);
        if (fDup)
        {
            if (OpenThreadToken( GetCurrentThread(),
                            MAXIMUM_ALLOWED,
                            TRUE,
                            &hImp))
            {
                DumpToken( hImp );
                if (DuplicateTokenEx(   hImp,
                                        MAXIMUM_ALLOWED,
                                        NULL,
                                        SecurityImpersonation,
                                        TokenPrimary,
                                        &hDup ) )
                {
                    fprintf( fOut, "Success!  Duplicated that token!\n");
                    DumpToken( hToken );
                    CloseHandle( hToken );
                }
                else
                {
                    fprintf( fOut, "DuplicateTokenEx FAILED, %d\n", GetLastError() );

                }

                CloseHandle( hImp );

            }
            else
            {
                fprintf( fOut, "OpenThreadToken FAILED, %d\n", GetLastError() );
            }

        }
        RevertToSelf();
        fprintf( fOut,"Hey look!  I'm %s\n", ImpersonateName);

        if (Cmd)
        {
            fprintf( fOut,"Starting '%s' as user\n", Cmd);
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            if (!CreateProcessAsUser(hToken, NULL, Cmd, NULL, NULL, FALSE,
                                CREATE_SEPARATE_WOW_VDM, NULL,
                                NULL, &si, &pi))
            {
                fprintf( fOut,"FAILED, %d\n", GetLastError());
            }

            fprintf( fOut,"Process Info:\n");
            fprintf( fOut,"  Process Handle    \t%x\n", pi.hProcess );
            fprintf( fOut,"  Thread Handle     \t%x\n", pi.hThread );
            fprintf( fOut,"  Process Id        \t%d\n", pi.dwProcessId );
            fprintf( fOut,"  Thread Id         \t%d\n", pi.dwThreadId );

            ZeroMemory( Buffer, 1024 );
#ifdef notdef

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
            pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
            pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

            Status = NtQueryObject( pi.hProcess, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject(pi.hProcess, ObjectBasicInformation, pBasicInfo, 1024, NULL);
            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Attributes   \t%#x\n", pBasicInfo->Attributes );
                fprintf( fOut,"  GrantedAccess\t%#x\n", pBasicInfo->GrantedAccess );
                fprintf( fOut,"  HandleCount  \t%d\n", pBasicInfo->HandleCount );
                fprintf( fOut,"  PointerCount \t%d\n", pBasicInfo->PointerCount );
            }
            else
            {
                fprintf( fOut,"FAILED %x to query basic info\n", Status );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject( pi.hProcess, ObjectNameInformation, pNameInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Name         \t%ws\n", pNameInfo->Name.Buffer);
            }
            else
            {
                fprintf( fOut,"FAILED %x to query name info\n", Status );
            }
#endif
            CloseHandle( pi.hProcess );
            CloseHandle( pi.hThread );

        }
        CloseHandle(hToken);

    }



    return(0);

}


__cdecl
main (int argc, char *argv[])
{
    HANDLE  hWait;
    DWORD   i;
    DWORD   tid;
    HANDLE  hThreads[64];

    fOut = stdout;

    Logon32Initialize();

    //
    // Get params
    //
    DoArgs(argc, argv);

    if (Threads == 1)
    {
        DoIt(NULL);

    }
    else
    {
        if (Threads > 64 )
        {
            Threads = 64;
        }

        hWait = CreateEvent( NULL, TRUE, FALSE, NULL );

        for (i = 0; i < Threads ; i++ )
        {
            hThreads[i] = CreateThread( NULL, 0, DoIt, hWait, 0, &tid);
        }

        SetEvent( hWait );

        WaitForMultipleObjectsEx( Threads, hThreads, TRUE, INFINITE, FALSE );

        for ( i = 0 ; i < Threads ; i++ )
        {
            CloseHandle( hThreads[i] );
        }
    }


    return( 0 );
}


#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3


ULONG   PID;

void
DumpSid(PSID    pxSid)
{
    PISID   pSid = pxSid;
    int i, j =0;


    fprintf( fOut,"  S-%d-", pSid->Revision);
    for (i = 0;i < 6 ; i++ )
    {
        if (j)
        {
            fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
        }
        else
        {
            if (pSid->IdentifierAuthority.Value[i])
            {
                j = 1;
                fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
            }
        }
        if (i==4)
        {
            j = 1;
        }
    }
    for (i = 0; i < pSid->SubAuthorityCount ; i++ )
    {
        fprintf( fOut,(fMe & DUMP_HEX ? "-%x" : "-%lu"), pSid->SubAuthority[i]);
    }
}

void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    DumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        fprintf( fOut,"\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            fprintf( fOut,"Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            fprintf( fOut,"Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            fprintf( fOut,"LogonId ");
        }
    }

}

CHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        default:
            return("Unknown Privilege");
    }
}

void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{
    char *  PrivName;

    fprintf( fOut,"0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    fprintf( fOut," %-32s", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        fprintf( fOut,"  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
    }

}

void
DumpToken(HANDLE    hToken)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_OWNER        pTOwner;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbInfo;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;


    pTUser = malloc(256);


    status = GetTokenInformation(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        fprintf( fOut,"FAILED querying token, %#x\n", status);
        return;
    }

    fprintf( fOut,"User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    fprintf( fOut,"\nGroups");
    pTGroups = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    pTPrimaryGroup  = malloc(128);
    status = GetTokenInformation(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    fprintf( fOut,"\nPrimary Group:\n  ");
    DumpSid(pTPrimaryGroup->PrimaryGroup);

    fprintf( fOut,"\nPrivs\n");
    pTPrivs = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = GetTokenInformation(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    fprintf( fOut, "\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    fprintf( fOut, "TokenId     %x:%x\n", TStats.TokenId.HighPart, TStats.TokenId.LowPart);
    fprintf( fOut, "TokenType   %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
    fprintf( fOut, "Imp Level   %s\n", ImpLevels[ TStats.ImpersonationLevel ]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\winnt5\makefile.inc ===
$(O)\kerbevt.h  : ..\kerbevt.mc
    mc -h .\$(O) -r .\$(O) -v ..\kerbevt.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello3\server\hello2c.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello2.h"     // header file generated by MIDL compiler


int __cdecl
hello2_main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABD";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello2_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello2_IfHandle,
                    "makalu\\suzannep",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<10 ; i++ ) {
            HelloProc2(pszString);    // make call with user message
        }
//        Shutdown2();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello2_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\hello3\server\hellos.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello.h"    // header file generated by MIDL compiler

int __cdecl
hello2_main (int argc, char *argv[]);

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = "761";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'n':  // network address
                    pszNetworkAddress = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 'u':
                    pszUuid = argv[++i];
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", RPC_C_AUTHN_DCE_PRIVATE, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
                side of RPC distributed application
    FUNCTIONS:  HelloProc() - prints "hello, world" or other string
                sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    CHAR UserName[100];
    ULONG NameLen = 100;

    char * args[] = {"", "-n", "mikesw5" };

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }

    GetUserName(UserName,&NameLen);
    printf("%s: %s\n",UserName, pszString);
    hello2_main(3, args);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\utest\tlogon\logon32.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon32.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-30-94   RichardW   Created
//
//----------------------------------------------------------------------------

#undef UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <crypt.h>
#include <mpr.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wchar.h>
#include <stdlib.h>
#include <lmcons.h>

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>

//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
ULONG       Logon32KerbHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[16] = L"";    // NOTE:  This should be DNLEN from
                                            // lmcons.h, but that would be a
                                            // lot of including
QUOTA_LIMITS    Logon32QuotaLimits;
HINSTANCE       Logon32MprHandle = NULL;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;


RTL_CRITICAL_SECTION    Logon32Lock;

#define LockLogon()     RtlEnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   RtlLeaveCriticalSection( &Logon32Lock )


SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;



#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD

#define BaseSetLastNTError(_x_) \
    { \
        ULONG dwErrorCode; \
        dwErrorCode = RtlNtStatusToDosError( (_x_) ); \
        SetLastError( dwErrorCode ); \
    }


//+---------------------------------------------------------------------------
//
//  Function:   Logon32Initialize
//
//  Synopsis:   Initializes the critical section
//
//  Arguments:  [hMod]    --
//              [Reason]  --
//              [Context] --
//
//----------------------------------------------------------------------------
BOOL
Logon32Initialize(
    VOID
    )
{
    NTSTATUS    Status;

    Status = RtlInitializeCriticalSection( &Logon32Lock );
    return( Status == STATUS_SUCCESS );
}


/***************************************************************************\
* CreateLogonSid
*
* Creates a logon sid for a new logon.
*
* If LogonId is non NULL, on return the LUID that is part of the logon
* sid is returned here.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSID
L32CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED, Length);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &L32SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.
        RichardW    10-Jan-95   Liberated from sockets and stuck in base

********************************************************************/
BOOL
L32GetDefaultDomainName(
    PUNICODE_STRING     pDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;
    PUNICODE_STRING             pDomain;

    if (Logon32DomainName[0] != L'\0')
    {
        RtlInitUnicodeString(pDomainName, Logon32DomainName);
        return(TRUE);
    }
    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        BaseSetLastNTError(NtStatus);
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( Logon32DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    Logon32DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    //
    // And init the string
    //
    RtlInitUnicodeString(pDomainName, Logon32DomainName);

    return TRUE;

}   // GetDefaultDomainName

//+---------------------------------------------------------------------------
//
//  Function:   L32pInitLsa
//
//  Synopsis:   Initialize connection with LSA
//
//  Arguments:  (none)
//
//  History:    4-21-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pInitLsa(void)
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    GetModuleFileNameA(NULL, MyName, MAX_PATH);
    ModuleName = strrchr(MyName, '\\');
    if (!ModuleName)
    {
        ModuleName = MyName;
    }


    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, ModuleName);
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &Logon32LsaHandle,
                 &dummy
                 );


    //
    // Turn off the privilege now.
    //
    if (!WasEnabled)
    {
        (VOID) RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, FALSE, &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32MsvHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        return(FALSE);
    }

    //
    // Connect with the Kerberos authentication package
    //
    RtlInitString(&PackageName, MICROSOFT_KERBEROS_NAME_A);
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32KerbHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();

    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pLogonUser
//
//  Synopsis:   Wraps up the call to LsaLogonUser
//
//  Arguments:  [LsaHandle]             --
//              [AuthenticationPackage] --
//              [LogonType]             --
//              [UserName]              --
//              [Domain]                --
//              [Password]              --
//              [LogonSid]              --
//              [LogonId]               --
//              [LogonToken]            --
//              [Quotas]                --
//              [pProfileBuffer]        --
//              [pProfileBufferLength]  --
//              [pSubStatus]            --
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
L32pLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_LOGON MsvAuthInfo;
    PKERB_INTERACTIVE_LOGON KerbAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    PTOKEN_GROUPS TokenGroups;
    PSID LocalSid;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    union {
        LUID            Luid;
        NT_CHALLENGE    NtChallenge;
    } Challenge;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING  LmPassword;
    UCHAR       LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;


#if DBG
    if (!RtlValidSid(LogonSid))
    {
        return(STATUS_INVALID_PARAMETER);
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "Advapi  ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "LogonUser API");


    //
    // For network logons, do the magic.
    //

    if (AuthenticationPackage == Logon32MsvHandle)
    {
        if ( LogonType == Network )
        {
            ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

            if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
            {
                return( STATUS_INVALID_PARAMETER );
            }

            AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                            sizeof( WCHAR ) * ( wcslen( UserName->Buffer ) + 1 +
                                                wcslen( Domain->Buffer ) + 1 +
                                                ComputerNameLength + 1) +
                                                NT_RESPONSE_LENGTH +
                                                LM_RESPONSE_LENGTH ;

            MsvNetAuthInfo = AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                            HEAP_ZERO_MEMORY,
                                                            AuthInfoSize );

            if ( !MsvNetAuthInfo )
            {
                return( STATUS_NO_MEMORY );
            }

            //
            // Start packing in the string
            //

            MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

            //
            // Copy the user name into the authentication buffer
            //

            MsvNetAuthInfo->UserName.Length =
                        (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
            MsvNetAuthInfo->UserName.MaximumLength =
                        MsvNetAuthInfo->UserName.Length + sizeof(WCHAR);

            MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
            wcscpy(MsvNetAuthInfo->UserName.Buffer, UserName->Buffer);


            //
            // Copy the domain name into the authentication buffer
            //

            MsvNetAuthInfo->LogonDomainName.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
            MsvNetAuthInfo->LogonDomainName.MaximumLength =
                         MsvNetAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

            MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                         ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                         MsvNetAuthInfo->UserName.MaximumLength);

            wcscpy(MsvNetAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

            //
            // Copy the workstation name into the buffer
            //

            MsvNetAuthInfo->Workstation.Length = (USHORT)
                                (sizeof(WCHAR) * ComputerNameLength);

            MsvNetAuthInfo->Workstation.MaximumLength =
                                MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

            MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                                ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                                MsvNetAuthInfo->LogonDomainName.MaximumLength );

            wcscpy( MsvNetAuthInfo->Workstation.Buffer, ComputerName );

            //
            // Now, generate the bits for the challenge
            //

            Status = NtAllocateLocallyUniqueId( &Challenge.Luid );

            if ( !NT_SUCCESS(Status) )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, MsvNetAuthInfo );

                return( Status );
            }

            RtlCopyMemory(  MsvNetAuthInfo->ChallengeToClient,
                            & Challenge,
                            MSV1_0_CHALLENGE_LENGTH );

            //
            // Set up space for response
            //

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PUCHAR)
                        ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                        MsvNetAuthInfo->Workstation.MaximumLength );

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
                                NT_RESPONSE_LENGTH;

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                                NT_RESPONSE_LENGTH;

            RtlCalculateNtOwfPassword(
                        Password,
                        & PasswordHash );

            RtlCalculateNtResponse(
                    & Challenge.NtChallenge,
                    & PasswordHash,
                    (PNT_RESPONSE) MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer );


            //
            // Now do the painful LM compatible hash, so anyone who is maintaining
            // their account from a WfW machine will still have a password.
            //

            LmPassword.Buffer = LmPasswordBuf;
            LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

            Status = RtlUpcaseUnicodeStringToOemString(
                            & LmPassword,
                            Password,
                            FALSE );

            if ( NT_SUCCESS(Status) )
            {

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer = (PUCHAR)
                   ((PBYTE) (MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer) +
                   MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length =
                                LM_RESPONSE_LENGTH;

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength =
                                LM_RESPONSE_LENGTH;


                RtlCalculateLmOwfPassword(
                            LmPassword.Buffer,
                            & LmPasswordHash );

                ZeroMemory( LmPassword.Buffer, LmPassword.Length );

                RtlCalculateLmResponse(
                            & Challenge.NtChallenge,
                            & LmPasswordHash,
                            (PLM_RESPONSE) MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer );

            }
            else
            {
                //
                // If we're here, the NT (supplied) password is longer than the
                // limit allowed for LM passwords.  NULL out the field, so that
                // MSV knows not to worry about it.
                //

                RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                               sizeof( STRING ) );
            }

        }
        else
        {
            //
            // Build logon structure for non-network logons - service,
            // batch, interactive
            //

            AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
                sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                               wcslen(Domain->Buffer)   + 1 +
                               wcslen(Password->Buffer) + 1 );

            MsvAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize);

            if (MsvAuthInfo == NULL) {
                return(STATUS_NO_MEMORY);
            }

            //
            // This authentication buffer will be used for a logon attempt
            //

            MsvAuthInfo->MessageType = MsV1_0InteractiveLogon;


            //
            // Copy the user name into the authentication buffer
            //

            MsvAuthInfo->UserName.Length =
                        (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
            MsvAuthInfo->UserName.MaximumLength =
                        MsvAuthInfo->UserName.Length + sizeof(WCHAR);

            MsvAuthInfo->UserName.Buffer = (PWSTR)(MsvAuthInfo+1);
            wcscpy(MsvAuthInfo->UserName.Buffer, UserName->Buffer);


            //
            // Copy the domain name into the authentication buffer
            //

            MsvAuthInfo->LogonDomainName.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
            MsvAuthInfo->LogonDomainName.MaximumLength =
                         MsvAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

            MsvAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                         ((PBYTE)(MsvAuthInfo->UserName.Buffer) +
                                         MsvAuthInfo->UserName.MaximumLength);

            wcscpy(MsvAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

            //
            // Copy the password into the authentication buffer
            // Hide it once we have copied it.  Use the same seed value
            // that we used for the original password in pGlobals.
            //


            MsvAuthInfo->Password.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Password->Buffer);
            MsvAuthInfo->Password.MaximumLength =
                         MsvAuthInfo->Password.Length + sizeof(WCHAR);

            MsvAuthInfo->Password.Buffer = (PWSTR)
                                         ((PBYTE)(MsvAuthInfo->LogonDomainName.Buffer) +
                                         MsvAuthInfo->LogonDomainName.MaximumLength);

            wcscpy(MsvAuthInfo->Password.Buffer, Password->Buffer);

        }
    }
    else if (AuthenticationPackage == Logon32KerbHandle)
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive
        //

        AuthInfoSize = sizeof(KERB_INTERACTIVE_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(Password->Buffer) + 1 );

        KerbAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    AuthInfoSize);

        if (KerbAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        KerbAuthInfo->MessageType = KerbInteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        KerbAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        KerbAuthInfo->UserName.MaximumLength =
                    KerbAuthInfo->UserName.Length + sizeof(WCHAR);

        KerbAuthInfo->UserName.Buffer = (PWSTR)(KerbAuthInfo+1);
        wcscpy(KerbAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        KerbAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        KerbAuthInfo->LogonDomainName.MaximumLength =
                     KerbAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        KerbAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(KerbAuthInfo->UserName.Buffer) +
                                     KerbAuthInfo->UserName.MaximumLength);

        wcscpy(KerbAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        KerbAuthInfo->Password.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Password->Buffer);
        KerbAuthInfo->Password.MaximumLength =
                     KerbAuthInfo->Password.Length + sizeof(WCHAR);

        KerbAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(KerbAuthInfo->LogonDomainName.Buffer) +
                                     KerbAuthInfo->LogonDomainName.MaximumLength);

        wcscpy(KerbAuthInfo->Password.Buffer, Password->Buffer);

    }




    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS) RtlAllocateHeap(RtlProcessHeap(), 0,
                                    sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));

    if (TokenGroups == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);
        return(STATUS_NO_MEMORY);
    }

    //
    // Fill in the logon token group list
    //

    Status = RtlAllocateAndInitializeSid(
                    &L32LocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &LocalSid
                    );

    if ( NT_SUCCESS( Status ) )
    {

        TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
        TokenGroups->Groups[0].Sid = LogonSid;
        TokenGroups->Groups[0].Attributes =
                SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
                SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
        TokenGroups->Groups[1].Sid = LocalSid;
        TokenGroups->Groups[1].Attributes =
                SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
                SE_GROUP_ENABLED_BY_DEFAULT;

        //
        // Now try to log this on
        //


        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                    AuthenticationPackage,
                    AuthInfoBuf,
                    AuthInfoSize,
                    TokenGroups,
                    &SourceContext,
                    pProfileBuffer,
                    pProfileBufferLength,
                    LogonId,
                    LogonToken,
                    Quotas,
                    pSubStatus
                    );

        RtlFreeSid(LocalSid);

    }

    //
    // Discard token group list
    //

    RtlFreeHeap(RtlProcessHeap(), 0, TokenGroups);

    //
    // Notify all the network providers, if this is a NON network logon
    //

    if ( NT_SUCCESS( Status ) &&
         (LogonType != Network) )
    {
        L32pNotifyMpr(AuthInfoBuf, LogonId);
    }

    //
    // Discard authentication buffer
    //

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);


    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserA
//
//  Synopsis:   ANSI wrapper for LogonUserW.  See description below
//
//  Arguments:  [lpszUsername]    --
//              [lpszDomain]      --
//              [lpszPassword]    --
//              [dwLogonType]     --
//              [dwLogonProvider] --
//              [phToken]         --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
KerbLogonUserA(
    LPSTR       lpszUsername,
    LPSTR       lpszDomain,
    LPSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Password;
    NTSTATUS Status;
    BOOL    bRet;


    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    Status = RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }
    Status = RtlCreateUnicodeStringFromAsciiz(&Domain, lpszDomain);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    Status = RtlCreateUnicodeStringFromAsciiz(&Password, lpszPassword);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = KerbLogonUserW(
                Username.Buffer,
                Domain.Buffer,
                Password.Buffer,
                dwLogonType,
                dwLogonProvider,
                phToken);

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Password.Buffer)
    {
        RtlZeroMemory(Password.Buffer, Password.Length);
        RtlFreeUnicodeString(&Password);
    }

    return(bRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]    -- User name
//              [lpszDomain]      -- Domain name
//              [lpszPassword]    -- Password
//              [dwLogonType]     -- Logon type
//              [dwLogonProvider] -- Provider
//              [phToken]         -- Returned handle to primary token
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
KerbLogonUserW(
    PWSTR       lpszUsername,
    PWSTR       lpszDomain,
    PWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{

    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    UNICODE_STRING  Password;
    LUID        LogonId;
    PSID        pLogonSid;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus;
    SECURITY_LOGON_TYPE LogonType;


    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT35;
    }

    if (dwLogonProvider > LOGON32_PROVIDER_WINNT40)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
    }

    //
    // If the MSV handle is -1, grab the lock, and try again:
    //

    if (Logon32MsvHandle == 0xFFFFFFFF)
    {
        LockLogon();

        //
        // If the MSV handle is still -1, init our connection to lsa.  We
        // have the lock, so no other threads can be trying this right now.
        //
        if (Logon32MsvHandle == 0xFFFFFFFF)
        {
            if (!L32pInitLsa())
            {
                return( FALSE );
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Initialize the token handle, if the pointer is invalid, then catch
    // the exception now.
    //

    *phToken = NULL;

    //
    // Parse that domain.  Note, if the special token . is passed in for
    // domain, we will use the right value from the LSA, meaning AccountDomain.
    // If the domain is null, the lsa will talk to the local domain, the
    // primary domain, and then on from there...
    //
    if (lpszDomain && *lpszDomain)
    {
        if ((lpszDomain[0] == L'.') &&
            (lpszDomain[1] == L'\0') )
        {
            if (!L32GetDefaultDomainName(&Domain))
            {
                return(FALSE);
            }
        }
        else
            RtlInitUnicodeString(&Domain, lpszDomain);
    }
    else
    {
        RtlInitUnicodeString(&Domain, lpszDomain);
    }

    //
    // Finally, init the password
    //
    RtlInitUnicodeString(&Password, lpszPassword);


    //
    // Get a logon sid to refer to this guy (not that anyone will be able to
    // use it...
    //
    pLogonSid = L32CreateLogonSid(NULL);
    if (!pLogonSid)
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return(FALSE);
    }


    //
    // Attempt the logon
    //

    Status = L32pLogonUser(
                    Logon32LsaHandle,
                    (dwLogonProvider == LOGON32_PROVIDER_WINNT35) ?
                        Logon32MsvHandle : Logon32KerbHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    pLogonSid,
                    &LogonId,
                    phToken,
                    &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Done with logon sid, regardless of result:
    //

    LocalFree( pLogonSid );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_ACCOUNT_RESTRICTION)
        {
            BaseSetLastNTError(SubStatus);
        }
        else
            BaseSetLastNTError(Status);

        return(FALSE);
    }

    if (Profile != NULL)
    {
        LsaFreeReturnBuffer(Profile);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\authen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       authen.cxx
//
//  Contents:   Authenticator verification code
//
//  Classes:    CAuthenticatorList
//
//  Functions:  Compare, AuthenAllocate, AuthenFree
//
//  History:    4-04-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

//
// Security include files.
//
#include <kerbcomm.h>
#include <authen.hxx>
extern "C"
{
#include <md5.h>
}




typedef struct _KERB_AUTHEN_HEADER
{
    LARGE_INTEGER tsTime;
    BYTE Checksum[MD5DIGESTLEN];
} KERB_AUTHEN_HEADER, *PKERB_AUTHEN_HEADER;

#define KERB_MAX_AUTHEN_SIZE 1024

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two KerbInternalAuthenticators for RTL_GENERIC_TABLE
//
//  Effects:    none.
//
//  Arguments:  [Table]        -- ignored
//              [FirstStruct]  --
//              [SecondStruct] --
//
//  Returns:    GenericEqual, GenericLessThan, GenericGreaterThan.
//
//  Algorithm:  Sorts by TimeStamp first, than nonce, then principal, and
//              finally by realm
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      This must impose a complete ordering.  The table package
//              will not allow an authenticator to be inserted in the table
//              if it is equal (according to this function) to one already
//              there.
//
//----------------------------------------------------------------------------

RTL_GENERIC_COMPARE_RESULTS
Compare(
    IN struct _RTL_GENERIC_TABLE *Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
{
    PKERB_AUTHEN_HEADER pOne, pTwo;
    RTL_GENERIC_COMPARE_RESULTS ret;
    int comp;
    pOne = (PKERB_AUTHEN_HEADER) FirstStruct ;
    pTwo = (PKERB_AUTHEN_HEADER) SecondStruct ;

    DsysAssert( (pOne != NULL) && (pTwo != NULL) );


    comp = memcmp( pOne->Checksum,
                   pTwo->Checksum,
                   MD5DIGESTLEN );
    if (comp > 0)
    {
        ret = GenericGreaterThan;
    }
    else if (comp < 0)
    {
        ret = GenericLessThan;
    }
    else
    {
        ret = GenericEqual;
    }

    return(ret);
}


//+---------------------------------------------------------------------------
//
//  Function:   AuthenAllocate
//
//  Synopsis:   Memory allocator for RTL_GENERIC_TABLE
//
//  Effects:    Allcoates memory.
//
//  Arguments:  [Table]    -- ignored
//              [ByteSize] -- number of bytes to allocate
//
//  Signals:    Throws exception on failure.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
AuthenAllocate( struct _RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return(MIDL_user_allocate ( ByteSize ) );
}



//+---------------------------------------------------------------------------
//
//  Function:   AuthenFree
//
//  Synopsis:   Memory deallacotor for the RTL_GENERIC_TABLE.
//
//  Effects:    frees memory.
//
//  Arguments:  [Table]  -- ingnored
//              [Buffer] -- buffer to free
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
AuthenFree( struct _RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    MIDL_user_free ( Buffer );
}



//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::CAuthenticatorList
//
//  Synopsis:   Initializes the authenticator list.
//
//  Effects:    Calls RtlInitializeGenericTable (does not allocate memory).
//
//  Arguments:  [tsMax] -- Maximum acceptable age for an authenticator.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::CAuthenticatorList(LARGE_INTEGER tsMax)
    :_tsMaxAge(tsMax)
{
    NTSTATUS Status;
    // The last parameter is the "user defined context" for this table.
    // I have no idea what this means.  As far as I can tell from the code
    // this "context" is never refered to by the table routines.

    RtlInitializeGenericTable( &_Table, Compare, AuthenAllocate, AuthenFree, NULL );
    Status = RtlInitializeCriticalSection(&_Mutex);
    DsysAssert(NT_SUCCESS(Status));

}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::~CAuthenticatorList
//
//  Synopsis:   Destructor removes all authenticators in the list.
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  Algorithm:  Uses "Age" to remove everything.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::~CAuthenticatorList()
{
    LARGE_INTEGER tsForever;
    SetMaxTimeStamp( tsForever );
    (void) Age( tsForever );
    DsysAssert( RtlIsGenericTableEmpty( &_Table ) );
    RtlDeleteCriticalSection(&_Mutex);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::SetMaxAge
//
//  Synopsis:   Changes the new maximum age for an Authenticator.
//
//  Effects:    May cause some authenticators to be aged out.
//
//  Arguments:  [tsNewMaxAge] --
//
//  Algorithm:
//
//  History:    24-May-94   wader   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CAuthenticatorList::SetMaxAge( LARGE_INTEGER tsNewMaxAge )
{
    LARGE_INTEGER tsNow;
    LARGE_INTEGER tsCutoff;

    _tsMaxAge = tsNewMaxAge;

    GetSystemTimeAsFileTime((PFILETIME) &tsNow );

    tsCutoff.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;

    (void) Age( tsCutoff );
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Age
//
//  Synopsis:   Deletes all entries from the table that are earlier than
//              the given time.
//
//  Effects:    Frees memory
//
//  Arguments:  [tsCutoffTime] -- Delete all elements before this time.
//
//  Returns:    number of elements deleted.
//
//  Algorithm:  Get the oldest element in the table.  If it is older than
//              the time, delete it and loop back.  Else return.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The table contains the packed forms of Authenticators (as
//              created by PackAuthenticator in Kerbsupp).  The TimeStamp
//              must be first.
//
//----------------------------------------------------------------------------

ULONG
CAuthenticatorList::Age(const LARGE_INTEGER& tsCutoffTime)
{
    PKERB_AUTHEN_HEADER pahOldest;

    BOOL fDeleted;
    ULONG cDeleted = 0;

    do
    {
        // Number 0 is the oldest element in the table.
        pahOldest = (PKERB_AUTHEN_HEADER) RtlGetElementGenericTable( &_Table, 0 );
        if ((pahOldest != NULL) &&
            (pahOldest->tsTime.QuadPart < tsCutoffTime.QuadPart))
        {
            fDeleted = RtlDeleteElementGenericTable( &_Table, pahOldest );
            DsysAssert( fDeleted );
            cDeleted++;
        }
        else
        {
            fDeleted = FALSE;
        }
    } while ( fDeleted );
    return(cDeleted);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Check
//
//  Synopsis:   Determines if an authenticator is valid.
//
//  Effects:    Allocates memory
//
//  Arguments:  [pedAuth] -- Authenticator to check (decrypted, but marshalled)
//
//  Returns:    KDC_ERR_NONE if authenticator is OK.
//              KRB_AP_ERR_SKEW if authenticator is expired (assumes clock skew).
//              KRB_AP_ERR_REPEAT if authenticator has been used already.
//              some other error if something throws an exception.
//
//  Signals:    none.
//
//  Modifies:   _Table
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR
CAuthenticatorList::Check(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    IN PLARGE_INTEGER Time,
    IN BOOLEAN Insert
    )
{
    PKERB_AUTHEN_HEADER pDataInTable = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;


    //
    // Hold the mutex until we have finished the insert and the Age
    // operations.
    //

    RtlEnterCriticalSection(&_Mutex);

    __try
    {
        LARGE_INTEGER tsNow;
        LARGE_INTEGER tsCutoffPast;
        LARGE_INTEGER tsCutoffFuture;

        //
        // Determine the cut off time.
        //

        GetSystemTimeAsFileTime((PFILETIME) &tsNow );

        tsCutoffPast.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;
        tsCutoffFuture.QuadPart = tsNow.QuadPart + _tsMaxAge.QuadPart;



        if ((Time->QuadPart < tsCutoffPast.QuadPart) ||
            (Time->QuadPart > tsCutoffFuture.QuadPart))
        {
            KerbErr = KRB_AP_ERR_SKEW;
        }
        else
        {
            BOOLEAN fIsNew;
            KERB_AUTHEN_HEADER Header;
            MD5_CTX Md5Context;

            //
            // Store the first chunk of the authenticator. If the authenticator
            // doesn't fit on the stack, allocate some space on the heap.
            //

            Header.tsTime = *Time;
            MD5Init(
                &Md5Context
                );

            MD5Update(
                &Md5Context,
                (PBYTE) Buffer,
                BufferLength
                );
            if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
            {
                MD5Update(
                    &Md5Context,
                    (PBYTE) OptionalBuffer,
                    OptionalBufferLength
                    );
            }
            MD5Final(
                &Md5Context
                );
            RtlCopyMemory(
                Header.Checksum,
                Md5Context.digest,
                MD5DIGESTLEN
                );

            if (!Insert)
            {
                pDataInTable = (PKERB_AUTHEN_HEADER)RtlLookupElementGenericTable(
                                                        &_Table,
                                                        &Header );
                
                if (NULL == pDataInTable)
                {
                    KerbErr = KDC_ERR_NONE;
                }
                else
                {
                    KerbErr = KRB_AP_ERR_REPEAT;
                }
            }
            else
            {
                RtlInsertElementGenericTable( &_Table,
                                              &Header,
                                              sizeof( KERB_AUTHEN_HEADER ),
                                              &fIsNew );

                if (fIsNew)
                {
                    KerbErr = KDC_ERR_NONE;
                }
                else
                {
                    KerbErr = KRB_AP_ERR_REPEAT;
                }
            }

        }

        // Age out the old ones.

        (void) Age( tsCutoffPast );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    RtlLeaveCriticalSection(&_Mutex);

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\crypt.c ===
//+-----------------------------------------------------------------------
//
// File:        crypt.c
//
// Contents:    cryptography routines for building EncryptedData structs
//
//
// History:     17-Dec-91,  RichardW    Created
//              25-Feb-92,  RichardW    Revised for CryptoSystems
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO


#define CONFOUNDER_SIZE     8
#define CHECKSUM_SIZE       sizeof(CheckSum)



//+-------------------------------------------------------------------------
//
//  Function:   KerbEncryptData
//
//  Synopsis:   shim for KerbEncryptDataEx
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    return(KerbEncryptDataEx(
                EncryptedData,
                DataSize,
                Data,
                Algorithm,
                0,              // no usage flags
                Key
                ) );
}
//+---------------------------------------------------------------------------
//
//  Function:   KerbEncryptDataEx
//
//  Synopsis:   Turns cleartext into cipher text
//
//  Effects:    In place encryption of data
//
//  Arguments:  Data - Contains data to be encrypted
//              DataSize - Contains length of data in bytes
//              Algorithm - Algorithm to be used for encryption/checksum
//              UsageFlags - Flags indicating usage (client/serve, encryption/authentication)
//              Key - Key to use for encryption
//
//
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    //
    // Initialize header
    //

    EncryptedData->encryption_type = Algorithm;


    Status = pcsCrypt->Initialize(
                (PUCHAR) Key->keyvalue.value,
                Key->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    Status =  pcsCrypt->Encrypt(
                psbCryptBuffer,
                Data,
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    (void) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }
    else
    {
        return(KDC_ERR_NONE);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptData
//
//  Synopsis:   Shim for KerbDecryptDataEx with no usage flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbDecryptData(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    return(KerbDecryptDataEx(
            EncryptedData,
            pkKey,
            0,          // no usage flags
            DataSize,
            Data
            ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbDecryptDataEx
//
//  Synopsis:   Decrypts an EncryptedData structure
//
//  Effects:
//
//  Arguments:  [pedData] -- EncryptedData
//              [pkKey]   -- Key to use
//
//  History:    4-16-93   RichardW   Created Comment
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbDecryptDataEx(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    PCRYPTO_SYSTEM       pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS     Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(
                EncryptedData->encryption_type,
                &pcsCrypt
                );
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    if (EncryptedData->cipher_text.length & (pcsCrypt->BlockSize - 1))
    {
        return(KRB_ERR_GENERIC);
    }


    Status = pcsCrypt->Initialize(
                (PUCHAR) pkKey->keyvalue.value,
                pkKey->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    Status = pcsCrypt->Decrypt(
                psbCryptBuffer,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                Data,
                DataSize
                );

    (VOID) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return(KRB_AP_ERR_MODIFIED);
    }
    else
    {
        return(KDC_ERR_NONE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetEncryptionOverhead
//
//  Synopsis:   Gets the extra space required for encryption to store the ckecksum
//
//  Effects:
//
//  Arguments:  Algorithm - the algorithm to use
//              Overhead - receives the overhead in bytes
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or KRB_E_ETYPE_NOSUPP
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    )
{
    PCRYPTO_SYSTEM       pcsCrypt;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }
    *Overhead = pcsCrypt->HeaderSize;
    if (ARGUMENT_PRESENT(BlockSize))
    {
        *BlockSize = pcsCrypt->BlockSize;
    }
    return(KDC_ERR_NONE);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateEncryptionBuffer
//
//  Synopsis:   Allocates the space required for encryption with a given
//              key
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//              
//
//--------------------------------------------------------------------------


KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG EncryptionOverhead = 0;
    ULONG BlockSize = 0;

    KerbErr = KerbGetEncryptionOverhead(
                EncryptionType,
                &EncryptionOverhead,
                &BlockSize
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    *EncryptionBufferSize = (UINT) ROUND_UP_COUNT(EncryptionOverhead + BufferSize, BlockSize);

    *EncryptionBuffer =  (PBYTE) MIDL_user_allocate(*EncryptionBufferSize);
    if (*EncryptionBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

Cleanup:
    return(KerbErr);

}

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
	KERBERR KerbErr = KDC_ERR_NONE;
	unsigned int tempInt = 0;

	KerbErr = KerbAllocateEncryptionBuffer(
				EncryptionType,
				BufferSize,
				&tempInt,
				EncryptionBuffer
				);

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
	*EncryptionBufferSize = tempInt;

Cleanup:
	return (KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.h
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    28-Jun-93   WadeR   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C"
{
#endif

#include <dsysdbg.h>

#ifdef __cplusplus
}
#endif

#define DEB_T_SOCK  0x00001000

#if DBG
#define DEBUG_SUPPORT
#endif 

#ifdef DEBUG_SUPPORT

    #undef DEF_INFOLEVEL
    #define DEF_INFOLEVEL       (DEB_ERROR | DEB_WARN)

    DECLARE_DEBUG2(KSupp);
    
    #define KerbPrintKdcName(Level,Name) KerbPrintKdcNameEx(KSuppInfoLevel, (Level),(Name))
    #define DebugLog(_x_)       KSuppDebugPrint _x_

#else

    #define DebugLog(_x_)       
    #define KerbPrintKdcName(_x_)   

#endif  // DBG

#define MAX_EXPR_LEN        50


////////////////////////////////////////////////////////////////////
//
//  Name:       RET_IF_ERROR
//
//  Synopsis:   Evaluates an expression, returns from the caller if error.
//
//  Arguments:  l    - Error level to print error message at.
//              e    - expression to evaluate
//
// NOTE: THIS MACRO WILL RETURN FROM THE CALLING FUNCTION ON ERROR!!!!
//
// This will execute the expression (e), and check the return code.  If the
// return code indicates a failure, it prints an error message and returns
// from the calling function.
//
#define RET_IF_ERROR(l,e)                                           \
    {   NTSTATUS X_hr_XX__=(e) ;                                              \
        if (!NT_SUCCESS(X_hr_XX__)) {                                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
            return(X_hr_XX__);                                             \
        }                                                           \
    }




////////////////////////////////////////////////////////////////////
//
//  Name:       WARN_IF_ERROR
//
//  Synopsis:   Evaluates an expression, prints warning if error.
//
//  Arguments:  l    - Error level to print warning at.
//              e    - expression to evaluate
//
//  Notes:      This calls DebugLog(()) to print.  In retail, it just
//              evaluates the expression.
//
#if DBG
#define WARN_IF_ERROR(l,e)                                          \
    {   NTSTATUS X_hr_XX__=(e) ;                                              \
        if (!NT_SUCCESS(X_hr_XX__)) {                                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
        }                                                           \
    }

#define D_KerbPrintKdcName(l,n) KerbPrintKdcName(l,n)
#define D_DebugLog(_x_)    DebugLog(_x_)

#else // not DBG

#define WARN_IF_ERROR(l,e)  (e)
#define D_KerbPrintKdcName(l,n)
#define D_DebugLog(_x_)
#endif


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\kerbscav.cxx ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        kerbscav.cxx
//
// Contents:    Scavenger (task automation) code
//
//
// History:     22-April-2001   Created         MarkPu
//
//-----------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsysdbg.h>
}
#else
#include <kerb.hxx>
#include <kerbp.h>
#endif
#include <kerbcomm.h>
#include <kerbscav.h>
#include <kerbpq.h>

//
// FESTER: not a good idea to have these as globals, in case the application
//         would want multiple scavenger instances.  This will do for now.
//

BOOLEAN ScavengerInitialized = FALSE;
RTL_CRITICAL_SECTION ScavengerLock;
HANDLE ScavengerTimerQueue = NULL;
HANDLE ScavengerTimerShutdownEvent = NULL;
LIST_ENTRY ScavengerTaskQueue = {0};
LIST_ENTRY ScavengerDeadPool = {0};
ULONG ScavengerDeadPoolSize = 0;

#define LockScavengerQueue()   RtlEnterCriticalSection( &ScavengerLock )
#define UnlockScavengerQueue() RtlLeaveCriticalSection( &ScavengerLock )

struct SCAVENGER_TASK
{
    LIST_ENTRY m_ListEntry;

    //
    // Periodicity control code
    //

    DWORD m_InsideTrigger;           // Set to the ID of the callback thread
    BOOLEAN m_Changed;               // TRUE if periodicity was changed
    BOOLEAN m_Canceled;              // TRUE if task was canceled
    BOOLEAN m_Periodic;              // TRUE if periodic
    LONG m_Interval;                 // recurrence interval, in milliseconds

    //
    // Task management
    //

    HANDLE m_Timer;                  // Timer handle
    ULONG m_Flags;                   // Timer flags (see CreateTimerQueueTimer)
    HANDLE m_ShutdownEvent;          // Shutdown event
    LONG m_Processing;               // Set to TRUE while inside the trigger
    KERB_TASK_TRIGGER m_pfnTrigger;  // Invocation callback
    KERB_TASK_DESTROY m_pfnDestroy;  // Destruction callback
    void * m_Context;                  // User-supplied task context
};

typedef SCAVENGER_TASK * PSCAVENGER_TASK;


// ----------------------------------------------------------------------------
//
// Internal scavenger routines
//
// ----------------------------------------------------------------------------

VOID
ScavengerTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN Reason
    );


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerFreeTask
//
//  Synopsis:   Task 'destructor'
//
//  Arguments:  Task            - task to be freed
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerFreeTask(
    IN PSCAVENGER_TASK Task
    )
{
    if ( Task != NULL ) {

        if ( Task->m_pfnDestroy ) {

            Task->m_pfnDestroy( Task->m_Context );
        }

        NtClose( Task->m_ShutdownEvent );
        MIDL_user_free( Task );
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerPurgeDeadPool
//
//  Synopsis:   Disposes of items in the deadpool
//
//  Arguments:  TaskToAvoid     - Task to leave hanging around (because
//                                it corresponds to the current timer callback)
//                                This parameter can be NULL
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerPurgeDeadPool(    
    IN OPTIONAL PSCAVENGER_TASK TaskToAvoid
    )
{
    ULONG TasksLeftOver = 0;

    LockScavengerQueue();

    while ( !IsListEmpty( &ScavengerDeadPool ) &&
             TasksLeftOver < ScavengerDeadPoolSize ) {

        //
        // Get a task out of the list
        //

        BOOLEAN PutItBack = FALSE;
        PSCAVENGER_TASK Task = CONTAINING_RECORD(
                                   RemoveHeadList( &ScavengerDeadPool ),
                                   SCAVENGER_TASK,
                                   m_ListEntry
                                   );

        //
        // Only canceled tasks are allowed in the deadpool
        //

        DsysAssert( Task->m_Canceled );

        DsysAssert( ScavengerDeadPoolSize > 0 );
        ScavengerDeadPoolSize -= 1;

        UnlockScavengerQueue();

        if ( Task == TaskToAvoid ) {

            //
            // If this is the task associated with the current callback, skip it
            //

            PutItBack = TRUE;

        } else {

            //
            // Destroy the timer handle if it still exists
            //

            if ( Task->m_Timer != NULL ) {

                BOOL Success;

                Success = DeleteTimerQueueTimer(
                              ScavengerTimerQueue,
                              Task->m_Timer,
                              Task->m_ShutdownEvent
                              );

                DsysAssert( Success );

                Task->m_Timer = NULL;
            }

            //
            // If the shutdown event is signaled,
            // it is safe to dispose of the task;
            // Otherwise, someone else will have to garbage collect this one
            //

            if ( WAIT_OBJECT_0 == WaitForSingleObject(
                                      Task->m_ShutdownEvent,
                                      0 )) {

                ScavengerFreeTask( Task );

            } else {

                PutItBack = TRUE;
            }
        }

        LockScavengerQueue();

        //
        // If this is 'our' task, or there was trouble, insert it at the tail
        // so we can continue with tasks at the head of the deadpool list
        //

        if ( PutItBack ) {

            InsertTailList( &ScavengerDeadPool, &Task->m_ListEntry );
            ScavengerDeadPoolSize += 1;
            TasksLeftOver += 1;
        }
    }

    UnlockScavengerQueue();

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerCancelTask
//
//  Synopsis:   Stops a task's timer for subsequent removal
//
//  Arguments:  Task            - Task to cancel
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerCancelTask(
    IN PSCAVENGER_TASK Task
    )
{
    DsysAssert( Task );

    LockScavengerQueue();

    //
    // Only canceled tasks are allowed in the deadpool
    //

    DsysAssert( Task->m_Canceled );

    //
    // Move the task from the active task list to the deadpool
    //

    RemoveEntryList( &Task->m_ListEntry );
    InsertTailList( &ScavengerDeadPool, &Task->m_ListEntry );
    ScavengerDeadPoolSize += 1;

    UnlockScavengerQueue();

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerAddTask
//
//  Synopsis:   Common logic involved in scheduling a new task
//
//  Arguments:  Parameter       - Task being scheduled
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
ScavengerAddTask(
    IN PSCAVENGER_TASK Task
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Success;

    DsysAssert( Task );

    LockScavengerQueue();

    //
    // Assumptions: properly configured task, ready to be scheduled
    //

    DsysAssert( Task->m_InsideTrigger == 0 );
    DsysAssert( !Task->m_Changed );
    DsysAssert( !Task->m_Canceled );
    DsysAssert( Task->m_Timer == NULL );
    DsysAssert( Task->m_ShutdownEvent != NULL );
    DsysAssert( Task->m_Processing == FALSE );

    //
    // Schedule the task by creating its timer
    //

    Success = CreateTimerQueueTimer(
                  &Task->m_Timer,
                  ScavengerTimerQueue,
                  ScavengerTimerCallback,
                  Task,
                  Task->m_Interval,
                  Task->m_Periodic ? Task->m_Interval : 0,
                  Task->m_Flags
                  );

    if ( !Success ) {

        //
        // FESTER: map GetLastError() to an NT status code maybe?
        //

        Status = STATUS_UNSUCCESSFUL;
        DsysAssert( FALSE );

    } else {

        InsertHeadList( &ScavengerTaskQueue, &Task->m_ListEntry );
    }

    UnlockScavengerQueue();

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerRescheduleTask
//
//  Synopsis:   Waits for a changed task to finish then reschedules it
//
//  Arguments:  Parameter       - Task being rescheduled
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

DWORD
WINAPI
ScavengerRescheduleTask(
    LPVOID Parameter
    )
{
    NTSTATUS Status;
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )Parameter;
    BOOL Success;

    //
    // Assumptions: this is a properly configured 'changed' task
    //

    DsysAssert( Task );
    DsysAssert( Task->m_Timer );
    DsysAssert( Task->m_ShutdownEvent );
    DsysAssert( Task->m_Changed );
    DsysAssert( !Task->m_Canceled );

    //
    // Cancel the timer
    //

    Success = DeleteTimerQueueTimer(
                  ScavengerTimerQueue,
                  Task->m_Timer,
                  Task->m_ShutdownEvent
                  );

    DsysAssert( Success );

    Task->m_Timer = NULL;

    //
    // Wait for all outstanding timer callbacks to finish
    //

    WaitForSingleObject( Task->m_ShutdownEvent, INFINITE );

    InterlockedExchange( &Task->m_Processing, FALSE );

    //
    // Reset the shutdown event so it can be recycled
    //

    Status = NtResetEvent( Task->m_ShutdownEvent, NULL );

    DsysAssert( NT_SUCCESS( Status ));

    //
    // Now reschedule the task
    //

    Task->m_Changed = FALSE;

    Status = ScavengerAddTask( Task );

    if ( !NT_SUCCESS( Status )) {

        ScavengerFreeTask( Task );
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerTimerCallback
//
//  Synopsis:   Scavenger worker routine
//
//  Arguments:  Parameter       - Task handle
//              Reason          - see definition of WAITORTIMERCALLBACK
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
ScavengerTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN Reason
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )Parameter;

    DsysAssert( Task );
    DsysAssert( Reason == TRUE );
    DsysAssert( Task->m_pfnTrigger );

    //
    // Callbacks that step on each others' heels are thrown out
    //

    if ( FALSE != InterlockedCompareExchange(
                      &Task->m_Processing,
                      TRUE,
                      FALSE )) {

        return;
    }

    //
    // Invoke the trigger
    //

    DsysAssert( Task->m_InsideTrigger == 0 );
    DsysAssert( !Task->m_Changed );
    DsysAssert( !Task->m_Canceled );

    Task->m_InsideTrigger = GetCurrentThreadId();
    Task->m_pfnTrigger( Task, Task->m_Context );
    Task->m_InsideTrigger = 0;

    if ( Task->m_Changed && !Task->m_Canceled ) {

        //
        // If the task's periodicity has changed, reschedule it.
        //
        // Can't create a timer inside a timer callback routine, so do it
        // asynchronously
        //

        if ( FALSE == QueueUserWorkItem(
                          ScavengerRescheduleTask,
                          Task,
                          WT_EXECUTEDEFAULT )) {

            //
            // A task that cannot be rescheduled has to die
            //

            Task->m_Canceled = TRUE;
        }

    } else if ( !Task->m_Periodic ) {

        //
        // Non-periodic tasks get removed right away
        //

        Task->m_Canceled = TRUE;
    }

    //
    // If the task has been canceled, move it to the deadpool
    //

    if ( Task->m_Canceled ) {

        ScavengerCancelTask( Task );

    } else {

        //
        // Task has not been canceled, so open it up to timer callbacks
        //

        InterlockedExchange( &Task->m_Processing, FALSE );
    }

    //
    // A timer callback is a good place to bury some bodies
    //

    ScavengerPurgeDeadPool( Task );

    return;
}


// ----------------------------------------------------------------------------
//
// External scavenger interfaces
//
// ----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   KerbInitializeScavenger
//
//  Synopsis:   Initializes the scavenger
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbInitializeScavenger()
{
    NTSTATUS Status;

    DsysAssert( !ScavengerInitialized );

    //
    // Task queue and dead pool could be protected by different
    // locks, but the amount of time spent inside those locks is minimal,
    // so the same lock is used
    //

    Status = RtlInitializeCriticalSection( &ScavengerLock );

    if ( !NT_SUCCESS( Status )) {

        return Status;
    }

    InitializeListHead( &ScavengerTaskQueue );
    InitializeListHead( &ScavengerDeadPool );
    ScavengerDeadPoolSize = 0;

    DsysAssert( ScavengerTimerShutdownEvent == NULL );

    Status = NtCreateEvent(
                 &ScavengerTimerShutdownEvent,
                 EVENT_QUERY_STATE |
                    EVENT_MODIFY_STATE |
                    SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    DsysAssert( ScavengerTimerQueue == NULL );

    Status = RtlCreateTimerQueue( &ScavengerTimerQueue );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // We're ready to rock-n-roll
    //

    ScavengerInitialized = TRUE;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    DsysAssert( !NT_SUCCESS( Status ));

    if ( ScavengerTimerQueue != NULL ) {

        RtlDeleteTimerQueue( ScavengerTimerQueue );
        ScavengerTimerQueue = NULL;
    }

    if ( ScavengerTimerShutdownEvent != NULL ) {

        NtClose( ScavengerTimerShutdownEvent );
        ScavengerTimerShutdownEvent = NULL;
    }

    RtlDeleteCriticalSection( &ScavengerLock );

    ScavengerInitialized = FALSE;

    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbShutdownScavenger
//
//  Synopsis:   Shuts down the scavenger
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS if everything cleaned up properly
//              STATUS_ error code otherwise
//
//  Note:       If errors are encountered, the scavenger will not be destroyed,
//              but the task queue will be emptied.
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbShutdownScavenger()
{
    NTSTATUS Status;

    DsysAssert( ScavengerInitialized );

    Status = RtlDeleteTimerQueueEx(
                 ScavengerTimerQueue,
                 ScavengerTimerShutdownEvent
                 );

    ScavengerPurgeDeadPool( NULL );

    WaitForSingleObject( ScavengerTimerShutdownEvent, INFINITE );

    //
    // Purge the contents of the scavenger queue
    // NOTE: no need to lock the queue anymore, as the timer has been shut down
    //

    while ( !IsListEmpty( &ScavengerTaskQueue )) {

        PSCAVENGER_TASK Task = CONTAINING_RECORD(
                                   RemoveHeadList( &ScavengerTaskQueue ),
                                   SCAVENGER_TASK,
                                   m_ListEntry
                                   );

        ScavengerFreeTask( Task );
    }

    if ( NT_SUCCESS( Status )) {

        NtClose( ScavengerTimerShutdownEvent );
        ScavengerTimerShutdownEvent = NULL;
        ScavengerTimerQueue = NULL;
        RtlDeleteCriticalSection( &ScavengerLock );
        ScavengerInitialized = FALSE;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbAddScavengerTask
//
//  Synopsis:   Adds a task to the list of those managed by the scavenger object
//
//  Arguments:  Periodic        - If TRUE, this is to be a recurring task
//              Interval        - Execution interval in milliseconds
//              Flags           - WT_ flags (see CreateTimerQueueTimer)
//              pfnTrigger      - Trigger callback
//              pfnDestroy      - Destruction callback (OPTIONAL)
//              TaskItem        - Task context (OPTIONAL)
//
//  Returns:    STATUS_SUCCESS if everything cleaned up properly
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbAddScavengerTask(
    IN BOOLEAN Periodic,
    IN LONG Interval,
    IN ULONG Flags,
    IN KERB_TASK_TRIGGER pfnTrigger,
    IN KERB_TASK_DESTROY pfnDestroy,
    IN void * TaskItem
    )
{
    NTSTATUS Status;
    PSCAVENGER_TASK Task;

    DsysAssert( ScavengerInitialized );

    //
    // Validate the passed in parameters
    //

    if ( pfnTrigger == NULL ||
         ( Periodic && Interval == 0 )) {

        DsysAssert( FALSE && "RTFM: Invalid parameter passed in to KerbAddScavengerTask." );
        return STATUS_INVALID_PARAMETER;
    }

    Task = ( PSCAVENGER_TASK )MIDL_user_allocate( sizeof( SCAVENGER_TASK ));

    if ( Task == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Task->m_InsideTrigger = 0;
    Task->m_Changed = FALSE;
    Task->m_Canceled = FALSE;
    Task->m_Periodic = Periodic;
    Task->m_Interval = Interval;
    Task->m_Timer = NULL;
    Task->m_Flags = Flags;
    Task->m_ShutdownEvent = NULL;
    Task->m_Processing = FALSE;
    Task->m_pfnTrigger = pfnTrigger;
    Task->m_pfnDestroy = pfnDestroy;
    Task->m_Context = TaskItem;

    Status = NtCreateEvent(
                 &Task->m_ShutdownEvent,
                 EVENT_QUERY_STATE |
                    EVENT_MODIFY_STATE |
                    SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS( Status )) {

        MIDL_user_free( Task );
        return Status;
    }

    Status = ScavengerAddTask( Task );

    if ( !NT_SUCCESS( Status )) {

        Task->m_pfnDestroy = NULL; // Didn't take ownership yet, caller will destroy
        ScavengerFreeTask( Task );
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskIsPeriodic
//
//  Synopsis:   Tells whether a given task is a periodic task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    TRUE if the task is periodic, FALSE otherwise
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

BOOLEAN
KerbTaskIsPeriodic(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    return Task->m_Periodic;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskGetInterval
//
//  Synopsis:   Retrieves the interval of a periodic task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    Interval associated with the task, in milliseconds
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

LONG
KerbTaskGetInterval(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    return Task->m_Interval;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskReschedule
//
//  Synopsis:   Sets periodicity of a task
//
//  Arguments:  TaskHandle      - Task handle
//              Periodic        - if TRUE, this is going to be a periodic task
//              Interval        - recurrence interval, in milliseconds
//
//  Returns:    Nothing
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

void
KerbTaskReschedule(
    IN void * TaskHandle,
    IN BOOLEAN Periodic,
    IN LONG Interval
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    if ( Periodic && Interval == 0 ) {

        DsysAssert( FALSE && "Invalid parameter passed in to KerbTaskReschedule\n" );

    } else {

        Task->m_Changed = TRUE;
        Task->m_Periodic = Periodic;
        Task->m_Interval = Interval;
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskCancel
//
//  Synopsis:   Cancels the task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    Nothing
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

void
KerbTaskCancel(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    Task->m_Canceled = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\keygen.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        keygen.c
//
// Contents:    Key generation unit, with very random numbers
//
//
// History:     created, 10 Dec 91, richardw
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <dsysdbg.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO


//+---------------------------------------------------------------------------
//
//  Function:   KerbRandomFill
//
//  Synopsis:   Generates random data in the buffer.
//
//  Arguments:  [pbBuffer] --
//              [cbBuffer] --
//
//  History:    5-20-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbRandomFill( PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{
    if (!CDGenerateRandomBits(pbBuffer, cbBuffer))
    {
        return(KRB_ERR_GENERIC);
    }
    return(KDC_ERR_NONE);
}




//+-----------------------------------------------------------------------
//
// Function:    KerbMakeKey, public
//
// Synopsis:    Create a random desKey
//
// Effects:     fills a desKey with (more or less) cryptographically random
//              bytes.
//
// Arguments:   [EncryptionType]        - Encryption type of key
//              [NewKey] -- Key to create
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     10 Dec 91   RichardW    Created
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                EncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    NewKey->keyvalue.length = CryptoSystem->KeySize;

    NewKey->keytype = EncryptionType;

Cleanup:
    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return(Status);
}


//+-----------------------------------------------------------------------
//
// Function:    KerbCreateKeyFromBuffer
//
// Synopsis:    Create a KERB_ENCRYPT_KEY from a buffer
//
// Effects:
//
// Arguments:   NewKey -- Key to create
//              Buffer -- Buffer to create key
//              BufferSize - Length of buffer in bytes
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{

    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = (PUCHAR) Buffer;
    return(KDC_ERR_NONE);
}


//+-----------------------------------------------------------------------
//
// Function:    KerbDuplicateKey
//
// Synopsis:    Duplicates a KERB_ENCRYPT_KEY
//
// Effects:     Allocates memory
//
// Arguments:   NewKey -- Key to create
//              Key - key to duplicate
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PKERB_ENCRYPTION_KEY Key
    )
{


    *NewKey = *Key;
    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(Key->keyvalue.length);
    if (NewKey->keyvalue.value == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    RtlCopyMemory(
        NewKey->keyvalue.value,
        Key->keyvalue.value,
        Key->keyvalue.length
        );
    return(KDC_ERR_NONE);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeKey
//
//  Synopsis:   Frees a key created by KerbMakeKey or KerbCreateKeyFromBuffer
//
//  Effects:
//
//  Arguments:  Key - the key to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    if (Key->keyvalue.value != NULL)
    {
        MIDL_user_free(Key->keyvalue.value);
        Key->keyvalue.value = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeExportableKey
//
//  Synopsis:   Takes a keytype and makes a new key that uses export-strength
//              encryption from the key
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//              
//
//--------------------------------------------------------------------------

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                KeyType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus) || (CryptoSystem->ExportableEncryptionType == 0))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }
    NtStatus = CDLocateCSystem(
                CryptoSystem->ExportableEncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    NewKey->keyvalue.length = CryptoSystem->KeySize;

    NewKey->keytype = CryptoSystem->EncryptionType;

Cleanup:
    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsKeyExportable
//
//  Synopsis:   Checks to see if a key is exportable
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//              
//
//--------------------------------------------------------------------------


BOOLEAN
KerbIsKeyExportable(
    IN PKERB_ENCRYPTION_KEY Key
    )
{

    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;
    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                (ULONG) Key->keytype,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    if ((CryptoSystem->Attributes & CSYSTEM_EXPORT_STRENGTH) != 0)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\names.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <dnsapi.h>
#include <wincrypt.h>
#include <certca.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include "debug.h"
#include <sddl.h>

#endif // WIN32_CHICAGO

#define KERB_NAME_PREFIX L"Kerberos:"
UNICODE_STRING KerbNamePrefix = {sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR), sizeof(KERB_NAME_PREFIX), KERB_NAME_PREFIX };
UNICODE_STRING KerbNameSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"/" };
UNICODE_STRING KerbDomainSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"@" };

// Local Prototype */
BOOL SafeRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

BOOL SafeRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

LPWSTR
KerbAllocWStrFromUtf8Str(
    IN LPSTR Utf8String
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPWSTR UnicodeString = NULL;
    int UnicodeStringLen;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    UnicodeString = (LPWSTR) MIDL_user_allocate( (UnicodeStringLen+1)*sizeof(WCHAR) );

    if ( UnicodeString == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString,
                        UnicodeStringLen );

    if ( UnicodeStringLen == 0 ) {
        MIDL_user_free( UnicodeString );
        return NULL;
    }

    UnicodeString[UnicodeStringLen] = L'\0';

    return UnicodeString;
}

NTSTATUS
KerbUnicodeStringFromUtf8Str(
    IN LPSTR Utf8String,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.
    UnicodeString - Receives the converted unicode string


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    int UnicodeStringLen;
    ULONG ulLength = 0;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString->Buffer,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return (STATUS_SUCCESS);
    }

    //
    // The conversion routine returns space for a null terminator, so
    // adjust for that.
    //

    // check to make sure size fits into a USHORT value (with NULL appended)
    ulLength = (UnicodeStringLen - 1) * sizeof(WCHAR);

    if (ulLength > KERB_MAX_UNICODE_STRING)        
    {
        return(STATUS_NAME_TOO_LONG);
    }

    UnicodeString->Length = (USHORT)ulLength;

    if (UnicodeString->MaximumLength < UnicodeString->Length + sizeof(WCHAR))
    {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString->Buffer,
                        UnicodeStringLen );

    DsysAssert( UnicodeStringLen != 0 );

    UnicodeString->Buffer[UnicodeStringLen-1] = L'\0';
    UnicodeString->Length = (USHORT)((UnicodeStringLen-1) * sizeof(WCHAR));
    UnicodeString->MaximumLength = (USHORT)(UnicodeStringLen * sizeof(WCHAR));

    return STATUS_SUCCESS;
}

LPSTR
KerbAllocUtf8StrFromUnicodeString(
    IN PUNICODE_STRING UnicodeString

    )

/*++

Routine Description:

    Convert a Unicode (zero terminated) string to the corresponding UTF8
    string.

Arguments:

    UnicodeString - Specifies the Unicode zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UTF8 string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPSTR Utf8String = NULL;
    int Utf8StringLen;

    //
    // If the length is zero, return a null string.
    //

    if (UnicodeString->Length == 0)
    {
        Utf8String = (LPSTR) MIDL_user_allocate(sizeof(CHAR));
        if (Utf8String != NULL)
        {
            *Utf8String = '\0';
        }
        return(Utf8String);
    }

    //
    // Determine the length of the Unicode string.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        0,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {

        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    Utf8String = (LPSTR) MIDL_user_allocate( Utf8StringLen+1 );

    if ( Utf8String == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        Utf8StringLen,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {
        MIDL_user_free( Utf8String );
        return NULL;
    }

    Utf8String[Utf8StringLen] = '\0';

    return Utf8String;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnicodeStringToKerbString
//
//  Synopsis:   Converts a UNICODE_STRING to a kerberos-ansi string
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  KerbString - receives ansi-ized string
//              String - containes source unicode string
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This routine hides the details of whether we use UTF-8 or
//              unicode->ansi conversion
//
//
//--------------------------------------------------------------------------

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN PUNICODE_STRING String
    )
{
    STRING TempString;
    BOOL fAssigned = FALSE;


    if (!ARGUMENT_PRESENT(KerbString))
    {
        return(KRB_ERR_GENERIC);
    }

    TempString.Buffer = KerbAllocUtf8StrFromUnicodeString(String);
    if (TempString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    
    fAssigned = SafeRtlInitString(
        &TempString,
        TempString.Buffer
        );
    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);    // string length would not fit into USHORT
    }
    *KerbString = TempString;
    return(KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbStringToUnicodeString
//
//  Synopsis:   Converts a kerberos string to a unicode string
//
//  Effects:    allocates result string with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PSTRING KerbString
    )
{
    LPSTR TerminatedString;
    UNICODE_STRING TempString;
    BOOL fAssigned = FALSE;

    if (!ARGUMENT_PRESENT(KerbString) || !ARGUMENT_PRESENT(String))
    {
        return(KRB_ERR_GENERIC);
    }
    //
    // Null terminate the string
    //

    if ((KerbString->MaximumLength > KerbString->Length) &&
        (KerbString->Buffer[KerbString->Length] == '\0'))
    {
        TerminatedString = KerbString->Buffer;
    }
    else
    {
        //
        // Validate inputs before doing alloc.. This is because the Length can only be USHORT_MAX - 1 - sizeof(CHAR)
        // or we'll set max_length == 0.
        //
        if ( KerbString->Length > KERB_MAX_STRING )
        {
            return (KRB_ERR_GENERIC);
        } 

        TerminatedString = (LPSTR) MIDL_user_allocate(KerbString->Length + sizeof(CHAR));
        if (TerminatedString == NULL)
        {
            return(KRB_ERR_GENERIC);
        }
        RtlCopyMemory(
            TerminatedString,
            KerbString->Buffer,
            KerbString->Length
            );
        TerminatedString[KerbString->Length] = '\0';

    }

    TempString.Buffer = KerbAllocWStrFromUtf8Str(
                            TerminatedString
                            );
    if (TerminatedString != KerbString->Buffer)
    {
        MIDL_user_free(TerminatedString);
    }

    if (TempString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    fAssigned = SafeRtlInitUnicodeString(
        &TempString,
        TempString.Buffer
        );

    if (fAssigned == FALSE)
    {
        MIDL_user_free(TempString.Buffer);
        return(KRB_ERR_GENERIC);
    }

    *String = TempString;
    return(KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNames
//
//  Synopsis:   Compares two principal names for equality
//
//  Effects:
//
//  Arguments:  Name1 - the first principal name
//              Name2 - the second principal name
//
//  Requires:
//
//  Returns:    TRUE for eqaulity, FALSE for non-equality.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    )
{
    BOOLEAN Result = TRUE;
    PKERB_PRINCIPAL_NAME_ELEM NextName1, NextName2;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }

    //
    // If the name types are known, make sure they match.
    //

    if ((Name1->name_type != KRB_NT_UNKNOWN) &&
        (Name2->name_type != KRB_NT_UNKNOWN) &&
        (Name1->name_type != Name2->name_type))
    {
        Result = FALSE;
        goto Cleanup;
    }

    NextName1 = Name1->name_string;
    NextName2 = Name2->name_string;

    while ((NextName1 != NULL) && (NextName2 != NULL))
    {
        if (lstrcmpiA(
                NextName1->value,
                NextName2->value
                ) != 0)
        {
            Result = FALSE;
            goto Cleanup;
        }
        NextName1 = NextName1->next;
        NextName2 = NextName2->next;

    }

    //
    // if one has more names than the other, fail
    //

    if (!((NextName1 == NULL) && (NextName2 == NULL)))
    {
        Result = FALSE;
        goto Cleanup;
    }

    return(TRUE);
Cleanup:

    //
    // BUG 455493: transitional code
    //

    if (Result == FALSE)
    {
        KERBERR KerbErr;
        ULONG NameType;
        UNICODE_STRING UName1;
        UNICODE_STRING UName2;

        KerbErr = KerbConvertPrincipalNameToString(
                    &UName1,
                    &NameType,
                    Name1
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            return(FALSE);
        }
        KerbErr = KerbConvertPrincipalNameToString(
                    &UName2,
                    &NameType,
                    Name2
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            KerbFreeString(&UName1);
            return(FALSE);
        }
        Result = RtlEqualUnicodeString(
                    &UName1,
                    &UName2,
                    TRUE
                    );

        KerbFreeString( &UName1 );
        KerbFreeString( &UName2 );

        // FESTER
        // IF THIS ASSERT GETS FIRED, Contact Todds (0x30864)
        // This code *should* be transitional, and I've not seen it called,
        // but the only way to be certain is to add Assert and let it rot in
        // Whistler...  Remove before B2.
        //
        if (Result)
        {
            D_DebugLog((DEB_ERROR,"Assert about to fire.  Dead code called.\n"));
            DsysAssert(FALSE);
        }
    }
    return (Result);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    )
{
    INT len1;
    INT len2;
    
    if ((Realm1 == NULL) && (Realm2 == NULL))
    {
        return TRUE;
    }
    else if ((Realm1 == NULL) || (Realm2 == NULL))
    {
        return FALSE;
    }

    len1 = strlen( *Realm1 );
    len2 = strlen( *Realm2 );

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( (*Realm2)[len1] != '.' )
            {
                return( FALSE );
            }

            //
            //  len1 is comparable length
            //
        }
        else if ( len2+1 == len1 )
        {
            if ( (*Realm1)[len2] != '.' )
            {
                return( FALSE );
            }

            //
            //  len1 is set to comparable length
            //

            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }


    //
    //  compare only comparable length of string
    //

    return( !_strnicmp( *Realm1, *Realm2, len1 ) );

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareUnicodeRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2
    )
{
    UNICODE_STRING Realm1 = {0};
    UNICODE_STRING Realm2 = {0};

    if ((Domain1 == NULL) && (Domain2 == NULL))
    {
        return TRUE;
    }
    else if ((Domain1 == NULL) || (Domain2 == NULL))
    {
        return FALSE;
    }
    else if ((Domain1->Buffer == NULL) && (Domain2->Buffer == NULL))
    {
        return(TRUE);
    }
    else if ((Domain1->Buffer == NULL) || (Domain2->Buffer == NULL))
    {
        return(FALSE);
    }

    Realm1 = *Domain1;
    Realm2 = *Domain2;

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( Realm2.Length != Realm1.Length )
    {
        if ( Realm2.Length == Realm1.Length+sizeof(WCHAR) )
        {
            if ( Realm2.Buffer[Realm1.Length / sizeof(WCHAR)] != '.' )
            {
                return( FALSE );
            }
            else
            {
                Realm2.Length = Realm1.Length;
            }

        }
        else if ( Realm2.Length+sizeof(WCHAR) == Realm1.Length )
        {
            if ( Realm1.Buffer[Realm2.Length / sizeof(WCHAR)] != '.' )
            {
                return( FALSE );
            }
            else
            {
                Realm1.Length = Realm2.Length;
            }
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

    return( RtlEqualUnicodeString( &Realm1, &Realm2, TRUE ));

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcName
//
//  Synopsis:   Frees all parts of a KDC name structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME *  KdcName
    )
{
    if (*KdcName != NULL)
    {
        MIDL_user_free(*KdcName);
        *KdcName = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToKdcName
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG NameCount = 0;
    ULONG Index;
    STRING Names[MAX_NAME_ELEMENTS+1];
    PKERB_PRINCIPAL_NAME_ELEM NameElement;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    ULONG NameLength = 0;
    PUCHAR Where;
    BOOL fAssigned = FALSE;

    NameElement = PrincipalName->name_string;
    while (NameElement!= NULL)
    {
        //  Verify we do not overrun a USHORT length
        fAssigned = SafeRtlInitString(
                            &Names[NameCount],
                            NameElement->value
                            );
        if (fAssigned == FALSE)
        {
            D_DebugLog((DEB_ERROR,"KerbConvertPrincipalNameToKdcName:Name part too long\n"));
            return(KRB_ERR_GENERIC);
        }
        NameLength += (Names[NameCount].Length + 1) * sizeof(WCHAR);
        NameCount++;
        NameElement = NameElement->next;
        if (NameCount > MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameCount));
            return(KRB_ERR_GENERIC);
        }
    }

    // check to make sure size fits into a USHORT value (with NULL appended)
    // NameLength will be casted to USHORT below.
    if (NameLength > KERB_MAX_UNICODE_STRING)        
    {
        D_DebugLog((DEB_ERROR,"KerbConvertPrincipalNameToKdcName: Overall size too large\n"));
        return(KRB_ERR_GENERIC);
    }

    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return(KRB_ERR_GENERIC);
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    RtlZeroMemory(
        KdcName,
        NameSize
        );
    KdcName->NameCount = (USHORT) NameCount;
    KdcName->NameType = (USHORT) PrincipalName->name_type;

    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < NameCount ; Index++ )
    {
        KdcName->Names[Index].Length = 0;
        KdcName->Names[Index].MaximumLength = (USHORT)NameLength;
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        Status = KerbUnicodeStringFromUtf8Str(
                    Names[Index].Buffer,
                    &KdcName->Names[Index]
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Where += KdcName->Names[Index].MaximumLength;
        NameLength = NameLength - KdcName->Names[Index].MaximumLength;
    }
    *OutputName = KdcName;
    KdcName = NULL;

Cleanup:
    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCovnertKdcNameToPrincipalName
//
//  Synopsis:   Converts a KDC name to a Principal name & allocates output with
//              MIDL_user_allocate
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    PKERB_PRINCIPAL_NAME_ELEM * Last;
    STRING TempKerbString;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;

    PrincipalName->name_type = (int) KdcName->NameType;
    PrincipalName->name_string = NULL;
    Last = &PrincipalName->name_string;

    //
    // Index through the KDC name and add each element to the list
    //

    for (Index = 0; Index < KdcName->NameCount ; Index++ )
    {
        // Must free up TempKerbStringFirst to prevent leaks on error  KTD
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    &KdcName->Names[Index]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem->value = TempKerbString.Buffer;
        Elem->next = NULL;
        *Last = Elem;
        Last = &Elem->next;
    }
Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Cleanup the principal name
        //

        KerbFreePrincipalName(PrincipalName);
    }

    // free up any unused temp buffers  KTD
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbEqualKdcNames
//
//  Synopsis:   Compares to KDC names for equality
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if the names are identical
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbEqualKdcNames(
    IN PKERB_INTERNAL_NAME Name1,
    IN PKERB_INTERNAL_NAME Name2
    )
{
    BOOLEAN Equal = TRUE;
    ULONG Index;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }
    //
    // Special case some Microsoft name types
    //

    if (Name1->NameCount != Name2->NameCount)
    {
        Equal = FALSE;
    }
    else
    {

        for (Index = 0; Index < Name1->NameCount ; Index++ )
        {
            if (!RtlEqualUnicodeString(
                    &Name1->Names[Index],
                    &Name2->Names[Index],
                    TRUE                        // case insensitive
                    ))
            {
                Equal = FALSE;
                break;
            }
        }
    }

    return(Equal);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNameToKdcName
//
//  Synopsis:   Compares a princial name to a KDC name by first converting
//              and then comparing.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbCompareKdcNameToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName,
    OUT PBOOLEAN Result
    )
{
    PKERB_INTERNAL_NAME TempName = NULL;

    DsysAssert(Result);

    if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                        &TempName,
                        PrincipalName
                        )))
    {
        return(KRB_ERR_GENERIC);
    }

    *Result = KerbEqualKdcNames( TempName, KdcName );


    KerbFreeKdcName( &TempName );
    return(KDC_ERR_NONE);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateKdcName
//
//  Synopsis:   Duplicates an internal name by copying the pointer and
//              referencing the structure.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN PKERB_INTERNAL_NAME Source
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Index;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    ULONG NameLength = 0;
    PUCHAR Where;



    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (Source->NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return(STATUS_INVALID_PARAMETER);
    }

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        NameLength += Source->Names[Index].Length + sizeof(WCHAR);
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(Source->NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(
        KdcName,
        NameSize
        );
    KdcName->NameCount = (USHORT) Source->NameCount;
    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(Source->NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        if (Source->Names[Index].Length > KERB_MAX_UNICODE_STRING)
        {
            Status = STATUS_NAME_TOO_LONG;
            goto Cleanup;    // length will not fit into USHORT value
        }
        KdcName->Names[Index].Length = Source->Names[Index].Length;
        KdcName->Names[Index].MaximumLength = Source->Names[Index].Length + sizeof(WCHAR);
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            Source->Names[Index].Buffer,
            Source->Names[Index].Length
            );
        KdcName->Names[Index].Buffer[Source->Names[Index].Length / sizeof(WCHAR)] = L'\0';
        Where += KdcName->Names[Index].MaximumLength;
    }
    KdcName->NameType = Source->NameType;
    *Destination = KdcName;
    KdcName = NULL;

Cleanup:
    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }
    return(Status);
}

#ifdef RETAIL_LOG_SUPPORT
VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Index;
    if ((InfoLevel & DebugLevel) != 0)
    {
        for (Index = 0; Name && (Index < Name->NameCount); Index++)
        {
            DebugLog((DebugLevel | DSYSDBG_CLEAN, " %wZ ", &Name->Names[Index]));
        }
        DebugLog((DebugLevel | DSYSDBG_CLEAN, "\n"));
    }
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToKdcName
//
//  Synopsis:   Converts a string to a KRB_NT_MS_PRINCIPAL kdc name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN PUNICODE_STRING String
    )
{
    PKERB_INTERNAL_NAME LocalName = NULL;

    LocalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(1) + String->Length + sizeof(WCHAR));
    if (LocalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    LocalName->NameCount = 1;
    LocalName->NameType = KRB_NT_MS_PRINCIPAL;
    LocalName->Names[0].Length = String->Length;
    LocalName->Names[0].MaximumLength = String->Length + sizeof(WCHAR);
    LocalName->Names[0].Buffer = (LPWSTR) ((PUCHAR) LocalName + KERB_INTERNAL_NAME_SIZE(1));
    RtlCopyMemory(
        LocalName->Names[0].Buffer,
        String->Buffer,
        String->Length
        );
    LocalName->Names[0].Buffer[String->Length/sizeof(WCHAR)] = L'\0';

    *PrincipalName = LocalName;
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKdcNameToString
//
//  Synopsis:   Converts a KdcName to a '/' separated unicode string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PUNICODE_STRING RealmName
    )
{
    USHORT StringLength = 0;
    ULONG Index;
    PBYTE Where;

    if (!ARGUMENT_PRESENT(PrincipalName) || !ARGUMENT_PRESENT(String))
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // Count up the size of the name parts
    //

    // ULONG test on USHORT overflow for StringLength  KTD
    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        StringLength = StringLength + PrincipalName->Names[Index].Length;
    }

    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        StringLength += sizeof(WCHAR) + RealmName->Length;
    }

    //
    // Add in '/' separators and a null terminator
    //

    DsysAssert(PrincipalName->NameCount > 0);
    StringLength += (USHORT) PrincipalName->NameCount * sizeof(WCHAR);

    if ((StringLength - sizeof(WCHAR)) > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    String->Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (String->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    String->MaximumLength = StringLength;
    String->Length = StringLength - sizeof(WCHAR);

    Where = (PBYTE) String->Buffer;

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        //
        // Add a '/' before every segment but the first
        //

        if (Index != 0)
        {
            *((LPWSTR)(Where)) = L'/';
            Where += sizeof(WCHAR);
        }
        RtlCopyMemory(
            Where,
            PrincipalName->Names[Index].Buffer,
            PrincipalName->Names[Index].Length
            );
        Where += PrincipalName->Names[Index].Length;
    }
    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        *((LPWSTR)(Where)) = L'@';
        Where += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            RealmName->Buffer,
            RealmName->Length
            );
        Where += RealmName->Length;

    }

    *((LPWSTR)(Where)) = L'\0';
    Where += sizeof(WCHAR);
    DsysAssert(Where - (PUCHAR) String->Buffer == (LONG) StringLength);

    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name.
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------


KERBERR
KerbBuildFullServiceName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING FullServiceName
    )
{
    PUCHAR Where;
    ULONG ulLength = 0;

    FullServiceName->Buffer = NULL;

    ulLength = (ULONG)DomainName->Length +
               (ULONG)ServiceName->Length +
               sizeof(WCHAR);

    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    FullServiceName->Length = (USHORT)ulLength;

    FullServiceName->MaximumLength =
        FullServiceName->Length + sizeof(WCHAR);

    FullServiceName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            FullServiceName->MaximumLength
                                            );
    if (FullServiceName->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = (PUCHAR) FullServiceName->Buffer;

    RtlCopyMemory(
        FullServiceName->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    Where += DomainName->Length;

    if ((DomainName->Length !=0) && (ServiceName->Length != 0))
    {
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }


    RtlCopyMemory(
        Where,
        ServiceName->Buffer,
        ServiceName->Length
        );

    Where += ServiceName->Length;
    FullServiceName->Length = (USHORT)(Where - (PUCHAR) FullServiceName->Buffer);
    *(LPWSTR) Where = L'\0';
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildEmailName
//
//  Synopsis:   Combines a service name and domain name to make an email
//              name = "service@domain".
//
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildEmailName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING EmailName
    )
{
    PUCHAR Where;
    ULONG ulLength;

    EmailName->Buffer = NULL;

    ulLength = (ULONG)DomainName->Length +
               (ULONG)ServiceName->Length +
               sizeof(WCHAR);


    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    EmailName->Length = (USHORT)ulLength;

    EmailName->MaximumLength =
        EmailName->Length + sizeof(WCHAR);

    EmailName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            EmailName->MaximumLength
                                            );
    if (EmailName->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = (PUCHAR) EmailName->Buffer;

    RtlCopyMemory(
        EmailName->Buffer,
        ServiceName->Buffer,
        ServiceName->Length
        );
    Where += ServiceName->Length;

    *(LPWSTR) Where = L'@';
    Where += sizeof(WCHAR);


    RtlCopyMemory(
        Where,
        DomainName->Buffer,
        DomainName->Length
        );

    Where += DomainName->Length;
    EmailName->Length = (USHORT)(Where - (PUCHAR) EmailName->Buffer);
    *(LPWSTR) Where = L'\0';
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildUnicodeSpn
//
//  Synopsis:   Builds a 2 part SPN
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Spn - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildUnicodeSpn(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    )

{

    PWSTR Spn, tmp;
    ULONG BuffSize;
    BOOL fAssigned = FALSE;

    BuffSize = DomainName->MaximumLength +
                ServiceName->MaximumLength +
                (sizeof(WCHAR) * 2);

    Spn = (PWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Spn)
    {
        return KRB_ERR_GENERIC;
    }

    tmp = Spn;

    RtlCopyMemory(
        Spn,
        ServiceName->Buffer,
        ServiceName->Length
        );

    tmp += (ServiceName->Length / sizeof(WCHAR));
    *tmp = L'/';

    RtlCopyMemory(
        ++tmp,
        DomainName->Buffer,
        DomainName->Length
        );

    tmp += (DomainName->Length / sizeof(WCHAR));
    *tmp = L'\0';

    fAssigned = SafeRtlInitUnicodeString(
        UnicodeSpn,
        Spn
        );

    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);    // string length would not fit into USHORT
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildFullServiceKdcName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{

    return(KerbBuildFullServiceKdcNameWithSid(
            DomainName,
            ServiceName,
            NULL,
            NameType,
            FullServiceName
            ));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKpasswdName
//
//  Synopsis:   Builds the name of the kpasswd service
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    )
{
    UNICODE_STRING KpasswdServiceNames[2];

    //
    // Build the service name for the ticket
    //

    (void)RtlInitUnicodeString(
        &KpasswdServiceNames[0],
        KERB_KPASSWD_FIRST_NAME
        );

    (void)RtlInitUnicodeString(
        &KpasswdServiceNames[1],
        KERB_KPASSWD_SECOND_NAME
        );

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                        &KpasswdServiceNames[1],
                        &KpasswdServiceNames[0],
                        KRB_NT_SRV_INST,
                        KpasswdName
                        )))

    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcNameWithSid
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions. If a sid is presenet, it is tacked on as
//              the last segment of the name
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Sid - Optionally contains the sid to use
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{
    PKERB_INTERNAL_NAME FinalName = NULL;
    PUCHAR Where;
    ULONG NameParts;
    ULONG NameLength = 0;
    ULONG ulLength = 0;
    WCHAR SidBuffer[256];
    UNICODE_STRING SidString;
    KERBERR KerbErr = KRB_ERR_GENERIC;

    SidString.Length = 0;
    SidString.MaximumLength = sizeof(SidBuffer);
    SidString.Buffer = SidBuffer;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))

    {
        NameParts = 1;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
            (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
            (NameType == KRB_NT_ENTERPRISE_PRINCIPAL) ||
            (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        NameParts = 1;
        NameLength = ServiceName->Length + sizeof(WCHAR);
    }
    else
    {
        NameParts = 2;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }

    //
    // If a SID is present, add another name part
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        NTSTATUS Status;
        Status = KerbConvertSidToString(
                    Sid,
                    &SidString,
                    FALSE               // don't allocate
                    );
        if (!NT_SUCCESS(Status))
        {
            return(KRB_ERR_GENERIC);
        }
        NameParts++;
        NameLength += SidString.Length + sizeof(WCHAR);
    }


    *FullServiceName = NULL;

    FinalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength);
    if (FinalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    RtlZeroMemory(
        FinalName,
        KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength
        );

    Where = (PUCHAR) FinalName + KERB_INTERNAL_NAME_SIZE(NameParts);
    FinalName->NameType = (USHORT) NameType;
    FinalName->NameCount = (USHORT) NameParts;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))
    {
        //
        // If the domain name does not have an initial '\', reserve space for one
        //

        FinalName->Names[0].Buffer = (LPWSTR) Where;

        // This is dependent on our naming conventions.
        //
        // The full service name is the '\' domain name ':' service name.
        //

        ulLength = DomainName->Length +
                                  ServiceName->Length +
                                  sizeof(WCHAR);

        if (ulLength > KERB_MAX_UNICODE_STRING)
        {
            KerbErr = KRB_ERR_GENERIC;   // required size too large for Length
            goto Cleanup;
        }

        FinalName->Names[0].Length = (USHORT)ulLength;

        FinalName->Names[0].MaximumLength =
            FinalName->Names[0].Length + sizeof(WCHAR);


        RtlCopyMemory(
            FinalName->Names[0].Buffer,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;

        if ((DomainName->Length !=0) && (ServiceName->Length != 0))
        {
            *(LPWSTR) Where = L'\\';
            Where += sizeof(WCHAR);
        }


        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );

        Where += ServiceName->Length;
        ulLength = (ULONG)(Where - (PUCHAR) FinalName->Names[0].Buffer);

        if (ulLength > KERB_MAX_UNICODE_STRING)
        {
            KerbErr = KRB_ERR_GENERIC;   // required size too large for Length
            goto Cleanup;
        }

        FinalName->Names[0].Length = (USHORT)ulLength;
        *(LPWSTR) Where = L'\0';
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
             (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
             (NameType == KRB_NT_ENTERPRISE_PRINCIPAL)||
             (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        //
        // Principals have no domain name
        //

        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';

    }
    else
    {

        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);


        FinalName->Names[1].Length = DomainName->Length;
        FinalName->Names[1].MaximumLength = DomainName->Length + sizeof(WCHAR);
        FinalName->Names[1].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);

    }

    //
    // Append the string, if present
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        FinalName->Names[NameParts-1].Length = SidString.Length;
        FinalName->Names[NameParts-1].MaximumLength = SidString.Length + sizeof(WCHAR);
        FinalName->Names[NameParts-1].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            SidString.Buffer,
            SidString.Length
            );
        Where += SidString.Length;
        *((LPWSTR) Where) = L'\0';
    }


    *FullServiceName = FinalName;
    FinalName = NULL;
    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (FinalName)
    {
        MIDL_user_free(FinalName);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractSidFromKdcName
//
//  Synopsis:   Extracts the sid portion from a KDC name with a sid. This
//              routine also decrements the name count so that future
//              users of the name don't see the sid.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;

    DsysAssert(Sid);

    //
    // The sid is in the last portion of the name.
    //

    Status = KerbConvertStringToSid(
                &Name->Names[Name->NameCount-1],
                Sid
                );
    if (NT_SUCCESS(Status))
    {
        Name->NameCount--;
    }
    else
    {
        //
        // If the name wasn't a sid, return success. If it was another
        // problem, return an error
        //

        if (Status != STATUS_INVALID_PARAMETER)
        {
            return(KRB_ERR_GENERIC);
        }
    }
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateStringEx
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The EX function doesn't
//              automatically NULL terminate your buffer...
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString,
    IN BOOLEAN NullTerminate
    )
{   
    ULONG Buffsize = SourceString->Length + (NullTerminate ? sizeof(WCHAR) :  0);

    if ((SourceString == NULL) || (SourceString->Buffer == NULL))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = DestinationString->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    //
    // Detect potential B.0.s here on USHORT
    //

    if (SourceString->Length > KERB_MAX_UNICODE_STRING ) 
    {
        DsysAssert(FALSE);
        return (STATUS_NAME_TOO_LONG);
    }

    DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(Buffsize);
    if (DestinationString->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    DestinationString->Length = SourceString->Length;
    DestinationString->MaximumLength = (USHORT) Buffsize;
    RtlCopyMemory(
        DestinationString->Buffer,
        SourceString->Buffer,
        SourceString->Length
        );


    if (NullTerminate)
    {
        DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
    }

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateString
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    return(KerbDuplicateStringEx(
                DestinationString,
                SourceString,
                TRUE
                ));

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildNullTerminatedString
//
//  Synopsis:   Converts a UNICODE_STRING to a NULL-termianted string
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:  String - string to null terminate.
//
//  Requires:
//
//  Returns:    NULL on error, a pointer on success
//
//  Notes:      an input string with a NULL buffer pointe results in a
//              return string consisting of just "\0"
//
//
//--------------------------------------------------------------------------
LPWSTR
KerbBuildNullTerminatedString(
    IN PUNICODE_STRING String
    )
{
    LPWSTR ReturnString;

    ReturnString = (LPWSTR) MIDL_user_allocate(String->Length + sizeof(WCHAR));
    if (ReturnString == NULL)
    {
        return(NULL);
    }
    if (String->Buffer != NULL)
    {
        RtlCopyMemory(
            ReturnString,
            String->Buffer,
            String->Length
            );
    }
    ReturnString[String->Length/sizeof(WCHAR)] = L'\0';
    return(ReturnString);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeString
//
//  Synopsis:   Frees a string allocated by KerbDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        MIDL_user_free(String->Buffer);
        ZeroMemory(String, sizeof(UNICODE_STRING));
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeRealm
//
//  Synopsis:   Frees a realm allcoated with KerbConvertXXXToRealm
//
//  Effects:    null out the realm.
//
//  Arguments:  Realm - Realm to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    )
{
    if (*Realm != NULL)
    {
        MIDL_user_free(*Realm);
        *Realm = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePrincipalName
//
//  Synopsis:   Frees a principal name allocated with KerbConvertxxxToPrincipalName
//
//  Effects:    zeros out principal name so it won't be freed again
//
//  Arguments:  Name - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem,NextElem;

    Elem = Name->name_string;
    while (Elem != NULL)
    {
        if (Elem->value != NULL)
        {
            MIDL_user_free(Elem->value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
    Name->name_string = NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUnicodeStringToRealm
//
//  Synopsis:   Converts a unicode-string form of a domain name to a
//              KERB_REALM structure.
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              String - The string to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN PUNICODE_STRING String
    )
{
    KERBERR KerbErr;
    STRING TempString = {0};

    *Realm = NULL;
    KerbErr = KerbUnicodeStringToKerbString(
                  &TempString,
                  String
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        return(KerbErr);
    }
    *Realm = TempString.Buffer;
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertRealmToUnicodeString
//
//  Synopsis:   Converts a KERB_REALM structure to a unicode-string form
//              of a domain name.
//
//  Effects:
//
//  Arguments:  String - the unicode realm name
//              Realm - the realm to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PKERB_REALM Realm
    )
{
    KERBERR Status;
    STRING TempString;
    BOOL fAssigned = FALSE;

    fAssigned = SafeRtlInitString(
            &TempString,
            *Realm
            );
    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);
    }

    Status = KerbStringToUnicodeString(
                String,
                &TempString
                );
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateRealm
//
//  Synopsis:   Duplciates a realm name
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              SourceRealm - The realm to duplicate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    )
{
    ULONG RealmLength;

    if (ARGUMENT_PRESENT(SourceRealm))
    {
        RealmLength = lstrlenA(SourceRealm);
        *Realm = (PCHAR) MIDL_user_allocate(RealmLength + sizeof(CHAR));
        if (*Realm == NULL)
        {
            return(KRB_ERR_GENERIC);
        }
        RtlCopyMemory(
            *Realm,
            SourceRealm,
            RealmLength + sizeof(CHAR)
            );
    }
    else
    {
        *Realm = NULL;
    }
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareStringToPrincipalName
//
//  Synopsis:   Compares a unicode string name to a principal name for
//              equality
//
//  Effects:
//
//  Arguments:  PrincipalName - kerberos principal name
//              String - String name
//
//  Requires:
//
//  Returns:    TRUE if one of the principal names matches the string name
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbCompareStringToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String
    )
{
    KERBERR Status;
    BOOLEAN FoundMatch = FALSE;
    UNICODE_STRING TempString = {0};
    ULONG NameType;

    Status = KerbConvertPrincipalNameToString(
                &TempString,
                &NameType,
                PrincipalName
                );

    if (!KERB_SUCCESS(Status))
    {
        return(FALSE);
    }


    if (RtlEqualUnicodeString(
            &TempString,
            String,
            TRUE                        // case insensitive
            ))
    {
        FoundMatch = TRUE;
    }

    KerbFreeString(&TempString);
    return(FoundMatch);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToPrincipalName
//
//  Synopsis:   converts a string to a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              String - the string name to convert
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String,
    IN ULONG NameType
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    STRING TempKerbString;
    KERBERR Status = KDC_ERR_NONE;
    UNICODE_STRING TempElemString;
    UNICODE_STRING TempString;
    ULONG Index;
    ULONG ulLength;


    RtlZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );


    PrincipalName->name_type = (int) NameType;

    //
    // MS principals are stuck all in one string
    //

    if (NameType == KRB_NT_MS_PRINCIPAL)
    {
        Status = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    String
                    );

        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            MIDL_user_free(TempKerbString.Buffer);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem->value = TempKerbString.Buffer;
        Elem->next = PrincipalName->name_string;
        PrincipalName->name_string = Elem;

        Status = KDC_ERR_NONE;
        goto Cleanup;

    }
    else
    {
        //
        // Go through the string. If we hit  a '\\' separator, split
        // the name there into another component.
        //

        TempString = *String;
        Index = 0;

        while (Index <= TempString.Length / sizeof(WCHAR))
        {
            if ((Index == TempString.Length/sizeof(WCHAR)) ||
                (TempString.Buffer[Index] == L'\\') )
            {
                //
                // Build the element string
                //

                ulLength = Index * sizeof(WCHAR);

                if (ulLength > KERB_MAX_UNICODE_STRING)
                {
                    Status = KRB_ERR_GENERIC;    // length exceed USHORT range
                    goto Cleanup;
                }

                TempElemString.Buffer = TempString.Buffer;
                TempElemString.MaximumLength = (USHORT) ulLength;
                TempElemString.Length = TempElemString.MaximumLength;

                Status = KerbUnicodeStringToKerbString(
                            &TempKerbString,
                            &TempElemString
                            );

                if (!KERB_SUCCESS(Status))
                {
                    goto Cleanup;
                }
                Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
                if (Elem == NULL)
                {
                    MIDL_user_free(TempKerbString.Buffer);
                    Status = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                Elem->value = TempKerbString.Buffer;
                Elem->next = PrincipalName->name_string;
                PrincipalName->name_string = Elem;

                //
                // Reset the string to be the remains of the name
                //

                if (Index != TempString.Length / sizeof(WCHAR))
                {
                    ulLength = (Index+1) * sizeof(WCHAR);

                    if (ulLength > KERB_MAX_UNICODE_STRING)
                    {
                        Status = KRB_ERR_GENERIC;    // length exceed USHORT range
                        goto Cleanup;
                    }
                    TempString.Buffer = TempString.Buffer + Index + 1;
                    TempString.Length = TempString.Length - (USHORT) ulLength;
                    TempString.MaximumLength = TempString.MaximumLength - (USHORT) ulLength;
                    Index = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                Index++;
            }
        }
    }

Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicatePrincipalName
//
//  Synopsis:   Duplicates  a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              SourcePrincipalName - the name to copy
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------
KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_PRINCIPAL_NAME SourcePrincipalName
    )
{
    KERBERR Status = KDC_ERR_NONE;
    ULONG NameLen;
    PKERB_PRINCIPAL_NAME_ELEM SourceElem;
    PKERB_PRINCIPAL_NAME_ELEM DestElem;
    PKERB_PRINCIPAL_NAME_ELEM * NextElem;


    RtlZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );


    //
    // Fill in correct name type
    //

    PrincipalName->name_type = SourcePrincipalName->name_type;
    SourceElem = SourcePrincipalName->name_string;
    NextElem = &PrincipalName->name_string;

    *NextElem = NULL;
    while (SourceElem != NULL)
    {
        DestElem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NameLen = lstrlenA(SourceElem->value);

        DestElem->value = (PCHAR) MIDL_user_allocate(NameLen + sizeof(CHAR));
        if (DestElem->value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        RtlCopyMemory(
            DestElem->value,
            SourceElem->value,
            NameLen + sizeof(CHAR)
        );
        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];


    *NameType = (ULONG) PrincipalName->name_type;
    NameElements[NameParts] = PrincipalName->name_string;
    while (NameElements[NameParts] != NULL)
    {

        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return(KRB_ERR_GENERIC);
        }

    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return(KRB_ERR_GENERIC);
    }

    // Test for overflow on USHORT lengths
    if ( (StringLength - sizeof(CHAR)) > KERB_MAX_STRING )
    {
        return (KRB_ERR_GENERIC);
    } 

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;
    TempAnsiString.Buffer = (LPSTR) MIDL_user_allocate(StringLength);
    if (TempAnsiString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        ULONG NameLength = lstrlenA(NameElements[Index]->value);
        RtlCopyMemory(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '\0';
        }
        Where++;
    }

    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);


    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );
    MIDL_user_free(TempAnsiString.Buffer);
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToFullServiceString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string with
//              a realm name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN KERB_REALM RealmName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG NameLength;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];



    NameElements[NameParts] = PrincipalName->name_string;
    while (NameElements[NameParts] != NULL)
    {

        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return(KRB_ERR_GENERIC);
        }

    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // Add in space for the "@" and the realm
    //

    StringLength += lstrlenA(RealmName) + 1;

    // Test for overflow on USHORT lengths
    if ( (StringLength - sizeof(CHAR)) > KERB_MAX_STRING )
    {
        return (KRB_ERR_GENERIC);
    } 

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;
    TempAnsiString.Buffer = (LPSTR) MIDL_user_allocate(StringLength);
    if (TempAnsiString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        NameLength = lstrlenA(NameElements[Index]->value);
        RtlCopyMemory(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '@';
        }
        Where++;
    }

    NameLength = lstrlenA(RealmName);
    RtlCopyMemory(
        Where,
        RealmName,
        NameLength
        );

    Where += NameLength;

    //
    // Add either a trailing '\0'
    //

    *Where = '\0';
    Where++;


    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);


    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );
    MIDL_user_free(TempAnsiString.Buffer);
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySalt
//
//  Synopsis:   Combines a service name and domain name to make a key salt.
//              For machine account it is DOMAINNAMEhostmachinenamedomainname
//              For users it is DOMAINNAMEusername
//              For trusted domains it is DOMAINNAMEkrbtgtservicename
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              AccountType - Type of account, which changes the salt
//              KeySalt - Receives the key salt
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildKeySalt(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    )
{
    PUCHAR Where;
    ULONG  FinalLength;
    ULONG  ulLength = 0;
    USHORT DeadSpace = 0;
    USHORT Index;
    KERBERR KerbErr = KDC_ERR_NONE;

    DsysAssert(KeySalt);

    KeySalt->Buffer = NULL;

    //
    // If there is no domain name, this is a UPN so build a UPN salt.
    //

    if (DomainName->Length == 0)
    {
        return(KerbBuildKeySaltFromUpn(
                    ServiceName,
                    KeySalt ));
    }

    FinalLength = DomainName->Length +
                              ServiceName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        //
        // Check to see if the name is already a "host/..." name. If so,
        // we don't need to do this work.
        //

        if ((ServiceName->Length > sizeof(KERB_HOST_STRING) &&
            (_wcsnicmp(
                ServiceName->Buffer,
                KERB_HOST_STRING,
                (sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)) == 0) &&
            (ServiceName->Buffer[(sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)] == L'/')))
        {
            AccountType = UserAccount;
        }
        else
        {
            FinalLength += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

            //
            // Add in the rest of the DNS name of the principal
            // as well
            //

            FinalLength += DomainName->Length + sizeof(WCHAR);
        }
    }
    else if (AccountType == DomainTrustAccount)
    {
        FinalLength += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);
    }
    else if (AccountType == UnknownAccount)
    {
        for (Index = 0; Index < ServiceName->Length/ sizeof(WCHAR) ; Index++ )
        {
            if (ServiceName->Buffer[Index] == L'/')
            {
                DeadSpace += sizeof(WCHAR);
            }
        }

        FinalLength = FinalLength - DeadSpace;
    }

    //
    // Detect and reject overflows
    //

    if (FinalLength > KERB_MAX_UNICODE_STRING)
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KeySalt->Length        = 0;
    KeySalt->MaximumLength = (USHORT) FinalLength + sizeof(WCHAR);
    KeySalt->Buffer        = (LPWSTR) MIDL_user_allocate(KeySalt->MaximumLength);

    if (KeySalt->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = (PUCHAR) KeySalt->Buffer;

    RtlCopyMemory(
        KeySalt->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    // KeySalt->Length = KeySalt->Length + DomainName->Length;
    ulLength = KeySalt->Length + DomainName->Length;

    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KeySalt->Length = (USHORT)ulLength;

    Where += DomainName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        USHORT DontCopyChars = 0;
        UNICODE_STRING LowerCase = {0};
        NTSTATUS Status;

        ulLength = 0;


        RtlCopyMemory(
            Where,
            KERB_HOST_STRING,
            sizeof(KERB_HOST_STRING) - sizeof(WCHAR)
            );
        Where += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        LowerCase.Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
        // LowerCase.Length += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
        ulLength += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;

        //
        // add in the rest of the DNS name of the server
        //


        *(LPWSTR) Where = L'.';
        Where += sizeof(WCHAR);
        // LowerCase.Length += sizeof(WCHAR);
        ulLength += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        // LowerCase.Length = LowerCase.Length + DomainName->Length;
        ulLength = ulLength + DomainName->Length;

        // Test for overflow on USHORT lengths
        if (ulLength > KERB_MAX_UNICODE_STRING )
        {
            KerbErr =  KRB_ERR_GENERIC;
            goto Cleanup;
        } 

        LowerCase.Length = (USHORT) ulLength;
        LowerCase.MaximumLength = LowerCase.Length;

        Status = RtlDowncaseUnicodeString(
                    &LowerCase,
                    &LowerCase,
                    FALSE
                    );

        DsysAssert(NT_SUCCESS(Status));

    }
    else if (AccountType == DomainTrustAccount)
    {
        ULONG DontCopyChars = 0;

        RtlCopyMemory(
            Where,
            KDC_PRINCIPAL_NAME,
            sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR)
            );
        Where += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;

    }
    else if (AccountType == UnknownAccount)
    {
        //
        // Pull out an '/' from unknown accounts
        //

        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR) ; Index++)
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR) Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }
    else
    {
        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR); Index++ )
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR)Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }

    // check for USHORT overflow on length

    ulLength = (ULONG)(Where - (PUCHAR) KeySalt->Buffer);

    if (ulLength > KERB_MAX_UNICODE_STRING )
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    } 

    KeySalt->Length = (USHORT) ulLength;
    *(LPWSTR) Where = L'\0';
    KerbErr = KDC_ERR_NONE;

Cleanup:

   if (!KERB_SUCCESS(KerbErr))
   {
       if (KeySalt->Buffer)
       {
           MIDL_user_free(KeySalt->Buffer);
           KeySalt->Buffer = NULL;
       }

   }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySaltFromUpn
//
//  Synopsis:   Creaes salt from a UPN
//
//  Effects:
//              For users it is DOMAINNAMEusername
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    OUT PUNICODE_STRING Salt
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING RealUpn = {0};
    UNICODE_STRING RealmName = {0};
    UNICODE_STRING LocalSalt = {0};
    ULONG Index;
    ULONG ulLength = 0;

    //
    // If there is an "@" in UPN, strip it out & use the dns domain name
    //

    RealUpn = *Upn;
    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] == L'@')
        {
            RealUpn.Length = (USHORT) (Index * sizeof(WCHAR));
            RealmName.Buffer = &RealUpn.Buffer[Index+1];
            RealmName.Length = Upn->Length - RealUpn.Length - sizeof(WCHAR);
            RealmName.MaximumLength = RealmName.Length;
            break;
        }
    }
    if (RealmName.Length == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Create the salt. It starts off with the domain name & then has the
    // UPN without any of the / pieces
    //

    ulLength = RealmName.Length + RealUpn.Length;

    // Test for overflow on USHORT lengths
    if (ulLength > KERB_MAX_UNICODE_STRING )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    LocalSalt.MaximumLength = (USHORT)ulLength;
    LocalSalt.Length = 0;
    LocalSalt.Buffer = (LPWSTR) MIDL_user_allocate(LocalSalt.MaximumLength);
    if (LocalSalt.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        LocalSalt.Buffer,
        RealmName.Buffer,
        RealmName.Length
        );
    // LocalSalt.Length = LocalSalt.Length + RealmName.Length;
    ulLength = RealmName.Length;

    //
    // Add in the real upn but leave out any "/" marks
    //

    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] != L'/')
        {
            LocalSalt.Buffer[ulLength / sizeof(WCHAR)] = RealUpn.Buffer[Index];
            ulLength += sizeof(WCHAR);
        }
    }

    // Test for overflow on USHORT lengths - no need already done on MAX size possible
    LocalSalt.Length = (USHORT)ulLength;

    //
    // We have to lowercase the username for users
    //

#ifndef WIN32_CHICAGO
    CharLowerBuff(&(LocalSalt.Buffer[RealmName.Length/sizeof(WCHAR)]), RealUpn.Length/sizeof(WCHAR));
#endif // WIN32_CHICAGO

    *Salt = LocalSalt;     // give memory to caller
    LocalSalt.Buffer = NULL;

Cleanup:
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertSidToString
//
//  Synopsis:   Converts a sid to a string using RtlConvertSidToUnicodeString
//              but with a different allocator.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    UNICODE_STRING TempString;

    if (AllocateDestination)
    {
        TempString.Length = 0;
        TempString.MaximumLength = sizeof(Buffer);
        TempString.Buffer = Buffer;
    }
    else
    {
         TempString = *String;
    }

    Status = RtlConvertSidToUnicodeString(
                &TempString,
                Sid,
                FALSE
                );
    if (NT_SUCCESS(Status))
    {
        if (!AllocateDestination)
        {
            *String = TempString;
        }
        else
        {
            String->Buffer = (LPWSTR) MIDL_user_allocate(TempString.Length+sizeof(WCHAR));
            if (String->Buffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                String->Length = TempString.Length;
                String->MaximumLength = TempString.Length+sizeof(WCHAR);
                RtlCopyMemory(
                    String->Buffer,
                    TempString.Buffer,
                    TempString.Length
                    );
                String->Buffer[TempString.Length / sizeof(WCHAR)] = L'\0';
            }
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToSid
//
//  Synopsis:   Converts back a sid from KerbConvertSidToString. If the
//              string is malformed, it will return STATUS_INVALID_PARAMTER
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbConvertStringToSid(
    IN PUNICODE_STRING String,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    PSID SidT;

    *Sid = NULL;

    if ( String->Length + sizeof( WCHAR ) <= sizeof( Buffer )) {

        RtlCopyMemory( Buffer, String->Buffer, String->Length );

    } else {

        return STATUS_INVALID_PARAMETER;
    }

    Buffer[String->Length / sizeof( WCHAR )] = L'\0';

    if ( ConvertStringSidToSidW(
             Buffer,
             &SidT )) {

        Status = KerbDuplicateSid(
                     Sid,
                     SidT
                     );

        LocalFree( SidT );

    } else {

        switch( GetLastError()) {

        case ERROR_NOT_ENOUGH_MEMORY:

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        case ERROR_INVALID_SID:

            Status = STATUS_INVALID_PARAMETER;
            break;

        default:
            DsysAssert( FALSE ); // add mapping for the error code
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildAltSecId
//
//  Synopsis:   Builds the name for the alt-sec-id field lookup
//
//  Effects:    Converts a principal name from name1 name2 name3 to
//              "kerberos:name1/name2/name3@realm"
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    IN OPTIONAL PUNICODE_STRING UnicodeRealm
    )
{
    ULONG StringLength = sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR);
    ULONG Index;
    UNICODE_STRING TempString = {0};
    UNICODE_STRING LocalRealm = {0};
    KERBERR KerbErr = KDC_ERR_NONE;

    *AlternateName = TempString;

    if (ARGUMENT_PRESENT(UnicodeRealm))
    {
        LocalRealm = *UnicodeRealm;
    }
    else if (ARGUMENT_PRESENT(Realm))
    {

        KerbErr = KerbConvertRealmToUnicodeString(
                    &LocalRealm,
                    Realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (PrincipalName->NameCount == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Add in the size of all the components of the name plus a separtor
    // or a null terminator.
    //

    for (Index = 0; Index < PrincipalName->NameCount; Index++ )
    {
        StringLength += PrincipalName->Names[Index].Length + sizeof(WCHAR);
    }

    if (LocalRealm.Length != 0)
    {
        StringLength += sizeof(WCHAR) + // for @
                        LocalRealm.Length;

    }

    //
    // Now build the name, front to back (differently from KerbConvertPrincipalNameToString()
    //

    // Test for overflow on USHORT lengths
    if (StringLength > KERB_MAX_UNICODE_STRING )   // actually more accurate to use (StringLength - 1) > MAX
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    TempString.Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (TempString.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    TempString.Length = 0;
    TempString.MaximumLength = (USHORT) StringLength;

    //
    // Now start appending the various portions to the string - max length already tested for overflow
    //

    RtlAppendUnicodeStringToString(
        &TempString,
        &KerbNamePrefix
        );

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        if (Index != 0)
        {
            RtlAppendUnicodeStringToString(
                &TempString,
                &KerbNameSeparator
                );

        }
        RtlAppendUnicodeStringToString(
            &TempString,
            &PrincipalName->Names[Index]
            );
    }
    if (LocalRealm.Length != 0)
    {
        RtlAppendUnicodeStringToString(
            &TempString,
            &KerbDomainSeparator
            );
        RtlAppendUnicodeStringToString(
            &TempString,
            &LocalRealm
            );

    }
    *AlternateName = TempString;

Cleanup:
    if (!ARGUMENT_PRESENT(UnicodeRealm))
    {
        KerbFreeString(&LocalRealm);
    }
    return(KerbErr);
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPrincipalNameFromCertificate
//
//  Synopsis:   Derives the principal name from a certificate
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    )
{
    UNICODE_STRING NameString = {0};
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   ExtensionIndex = 0;
    BOOL fAssigned = FALSE;
    PCERT_ALT_NAME_INFO AltName=NULL;
    PCERT_NAME_VALUE    PrincipalNameBlob = NULL;
    LPWSTR              CertNameString = NULL;

    CRYPT_DECODE_PARA   DecodePara = {sizeof(CRYPT_DECODE_PARA),
                                      MIDL_user_allocate,
                                      MIDL_user_free };


    //
    // Get the client name from the cert
    //

    // See if cert has UPN in AltSubjectName->otherName
    for(ExtensionIndex = 0;
        ExtensionIndex < ClientCert->pCertInfo->cExtension;
        ExtensionIndex++)
    {
        if(strcmp(ClientCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                &DecodePara,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];
                    if((CERT_ALT_NAME_OTHER_NAME  == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            &DecodePara,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {

                            fAssigned = SafeRtlInitUnicodeString(&NameString,
                                                                 (LPCWSTR)PrincipalNameBlob->Value.pbData);
                            if (fAssigned == FALSE)
                            {
                                Status = STATUS_NAME_TOO_LONG;
                                goto Cleanup;
                            }

                            if(NameString.Length)
                            {
                                break;
                            }

                            MIDL_user_free(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;
                        }

                    }
                }
                if(NameString.Length)
                {
                    break;
                }
                MIDL_user_free(AltName);
                AltName = NULL;
            }
        }
    }
    /*
    Beta 3 code.  We no longer honor the CN in the certificate

    if(0 == NameString.Length)
    {
        if (!(NameLength = CertGetNameStringW(
                ClientCert,
                CERT_NAME_ATTR_TYPE,
                0,                          // no flags
                szOID_COMMON_NAME,          // type parameter
                NULL,
                0
                )))
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to get name from cert: %d.\n",Status));
            goto Cleanup;
        }
        CertNameString = (LPWSTR) MIDL_user_allocate(NameLength * sizeof(WCHAR));
        if (CertNameString == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        if (!(NameLength = CertGetNameStringW(
                ClientCert,
                CERT_NAME_ATTR_TYPE,
                0,                          // no flags
                szOID_COMMON_NAME,          // type parameter
                CertNameString,
                NameLength
                )))
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to get name from cert: %d.\n",Status));
            goto Cleanup;
        }



        RtlInitUnicodeString(
            String,
            CertNameString
            );
        CertNameString = NULL;

    }
    else
    {

    */

    if(0 != NameString.Length)
    {
        Status = KerbDuplicateString(String, &NameString);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to normalize name "));
            // KerbPrintKdcName(DEB_ERROR,ClientName);
            goto Cleanup;
        }

        D_DebugLog((DEB_TRACE,"UPN from certificate is %wZ\n",&NameString));
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        D_DebugLog((DEB_ERROR,"No valid name in Sclogon certificate\n"));
        goto Cleanup;
    }


Cleanup:

    if(PrincipalNameBlob)
    {
        MIDL_user_free(PrincipalNameBlob);
    }
    if(AltName)
    {
        MIDL_user_free(AltName);
    }
    if(CertNameString)
    {
        MIDL_user_free(CertNameString);
    }

    return(Status);
}
#endif


BOOL
SafeRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    TRUE if assignment took place, FALSE on error - such as USHORT overflow

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        if (Length > KERB_MAX_STRING)
        {
            return FALSE;    // length will not fit into USHORT value
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
    return TRUE;
}

BOOL
SafeRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        ASSERT( Length <= KERB_MAX_UNICODE_STRING );
        if (Length > KERB_MAX_UNICODE_STRING)
        {
            return FALSE;    // length will not fit into USHORT value
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\restrict.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        restrict.cxx
//
// Contents:    Logon restriction code
//
//
// History:      4-Aug-1996     MikeSw          Created from tickets.cxx
//
//------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <lmcons.h>
#include "debug.h"


//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckLogonRestrictions
//
//  Synopsis:   Checks logon restrictions for an account
//
//  Effects:
//
//  Arguments:  UserHandle - handle to a user
//              Workstation - Name of client's workstation
//              SecondsToLogon - Receives logon duration in seconds
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCheckLogonRestrictions(
    IN PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PNTSTATUS RetStatus
    )
{
    NTSTATUS Status;
    KERBERR KerbErr;
    LARGE_INTEGER KickoffTime;
    LARGE_INTEGER CurrentTime;
    PLARGE_INTEGER TempTime;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // Check the restrictions SAM doesn't:
    //

    TempTime = (PLARGE_INTEGER) &UserAll->AccountExpires;
    if ((TempTime->QuadPart != 0) &&
        (TempTime->QuadPart < CurrentTime.QuadPart))
    {
        Status = STATUS_ACCOUNT_EXPIRED;
        goto Cleanup;
    }

    //
    // For user accounts, check if the password has expired.
    //

    if (((LogonRestrictionsFlags & KDC_RESTRICT_IGNORE_PW_EXPIRATION) == 0) &&
        ((UserAll->UserAccountControl & USER_NORMAL_ACCOUNT) != 0))
    {
        TempTime = (PLARGE_INTEGER) &UserAll->PasswordMustChange;

        if (TempTime->QuadPart < CurrentTime.QuadPart)
        {
            if (TempTime->QuadPart == 0)
            {
                Status = STATUS_PASSWORD_MUST_CHANGE;
            }
            else
            {
                Status = STATUS_PASSWORD_EXPIRED;
            }
            goto Cleanup;
        }
    }

    if ((UserAll->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        Status = STATUS_ACCOUNT_DISABLED;
        goto Cleanup;
    }

    //
    // The Administrator account can not be locked out.
    //


    if ((UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) &&
        (UserAll->UserId != DOMAIN_USER_RID_ADMIN))
    {
        Status = STATUS_ACCOUNT_LOCKED_OUT;
        goto Cleanup;
    }

    if ((UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED) &&
        ((LogonRestrictionsFlags & KDC_RESTRICT_PKINIT_USED) == 0))
    {
        Status = STATUS_SMARTCARD_LOGON_REQUIRED;
        goto Cleanup;
    }


    Status = SamIAccountRestrictions(
                UserHandle,
                Workstation,
                &UserAll->WorkStations,
                &UserAll->LogonHours,
                LogoffTime,
                &KickoffTime
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    *RetStatus = Status;
    switch(Status)
    {
    case STATUS_SUCCESS:
        KerbErr = KDC_ERR_NONE;
        break;
    case STATUS_ACCOUNT_EXPIRED:    // See bug #23456
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_INVALID_LOGON_HOURS:
    case STATUS_LOGIN_TIME_RESTRICTION:
    case STATUS_LOGIN_WKSTA_RESTRICTION:
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        break;
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_PASSWORD_MUST_CHANGE:
        KerbErr = KDC_ERR_KEY_EXPIRED;
        break;
    default:
        KerbErr = KDC_ERR_POLICY;
    }
    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\passwd.c ===
//+-----------------------------------------------------------------------
//
// File:        passwd.c
//
// Contents:    Password hashing routine
//
//
// History:     12-20-91, RichardW, created
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerbcon.h>
#include <kerberr.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO
#include "wincrypt.h"

//
// Globals used for allowing the replacement of the StringToKey functions
//
HCRYPTPROV KerbGlobalStrToKeyProvider = 0;

//+-------------------------------------------------------------------------
//
//  Function:   CheckForOutsideStringToKey
//
//  Synopsis:   Call CryptoAPI to query to see if a CSP is registered
//              of the type PROV_REPLACE_OWF.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: STATUS_SUCCESS if it succeeds, otherwise STATUS_UNSUCCESSFUL
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CheckForOutsideStringToKey()
{
    HCRYPTPROV hProv = 0;

    KerbGlobalStrToKeyProvider = 0;

    //
    // Try to acquire a context to a CSP which is used for OWF replacement
    //
    if (!CryptAcquireContext(&hProv,
                             NULL,
                             NULL,
                             PROV_REPLACE_OWF,
                             CRYPT_VERIFYCONTEXT))
    {
        return;
    }

    KerbGlobalStrToKeyProvider = hProv;

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   UseOutsideStringToKey
//
//  Synopsis:   Calls the CSP to do an outside StringToKey function
//              using the hashing entry points of CryptoAPI.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
UseOutsideStringToKey(
    IN PUNICODE_STRING pPassword,
    IN ULONG cbKey,
    OUT PUCHAR pbKey
    )
{
    HCRYPTHASH hHash = 0;
    ULONG cb;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    //
    // create the hash
    //
    if (!CryptCreateHash(KerbGlobalStrToKeyProvider,
                         CALG_HASH_REPLACE_OWF,
                         0,
                         0,
                         &hHash))
    {
        goto Cleanup;
    }

    //
    // hash the password
    //

    if (!CryptHashData(hHash,
                       (PUCHAR)pPassword->Buffer,
                       pPassword->Length,
                       0))
    {
        if (NTE_BAD_DATA == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    //
    // Get the HP_HASHVAL, this is the key
    //
    cb = cbKey;
    if (!CryptGetHashParam(hHash,
                           HP_HASHVAL,
                           pbKey,
                           &cb,
                           0))
    {
        if (NTE_BAD_LEN == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if (0 != hHash)
    {
        CryptDestroyHash(hHash);
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPasswordEx
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPasswordEx(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    )
{
    PCRYPTO_SYSTEM CryptoSystem;
    NTSTATUS Status;
    KERBERR KerbErr;
    UNICODE_STRING CombinedName;
    ULONG Temp = 0;
    BOOLEAN fUseDefaultStringToKey = TRUE;


    RtlInitUnicodeString(
        &CombinedName,
        NULL
        );

    Key->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    Status = CDLocateCSystem(
                EncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    //
    // Check to see if the principal name must be appended to the password
    //

    if ((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) != 0)
    {
        Temp = (ULONG) Password->Length + (ULONG) PrincipalName->Length;

        if (Temp > (USHORT) -1)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        
        CombinedName.Length = (USHORT) Temp;
        CombinedName.MaximumLength = CombinedName.Length;
        CombinedName.Buffer = (LPWSTR) MIDL_user_allocate(CombinedName.Length);
        if (CombinedName.Buffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        RtlCopyMemory(
            CombinedName.Buffer,
            Password->Buffer,
            Password->Length
            );
        RtlCopyMemory(
            CombinedName.Buffer + Password->Length/sizeof(WCHAR),
            PrincipalName->Buffer,
            PrincipalName->Length
            );
    }
    else
    {
        CombinedName = *Password;
    }

    //
    // Get the preferred checksum
    //



    Key->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (Key->keyvalue.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Check if we need to use an outside supplied string to key
    // calculation
    //
    if (0 != KerbGlobalStrToKeyProvider)
    {
        Status = UseOutsideStringToKey(
                    &CombinedName,
                    CryptoSystem->KeySize,
                    Key->keyvalue.value
                    );

        if (NT_SUCCESS(Status))
        {
            fUseDefaultStringToKey = FALSE;
        }
        //
        // the function will return STATUS_UNSUCCESSFUL indicates not to fall
        // back to the typical string to key function.
        // 
        else if (STATUS_UNSUCCESSFUL == Status)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    if (fUseDefaultStringToKey)
    {
        Status = CryptoSystem->HashString(
                    &CombinedName,
                    Key->keyvalue.value
                    );
        
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    Key->keyvalue.length = CryptoSystem->KeySize;

    Key->keytype = EncryptionType;
    KerbErr = KDC_ERR_NONE;

Cleanup:

    if ((CombinedName.Buffer != Password->Buffer) &&
        (CombinedName.Buffer != NULL))
    {
        MIDL_user_free(CombinedName.Buffer);
    }

    if (!KERB_SUCCESS(KerbErr) && Key->keyvalue.value != NULL)
    {
        MIDL_user_free(Key->keyvalue.value);
        Key->keyvalue.value = NULL;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPassword
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    )
{
    UNICODE_STRING TempString;
    RtlInitUnicodeString(
        &TempString,
        NULL
        );
    return( KerbHashPasswordEx(
                Password,
                &TempString,                   // no principal name
                EncryptionType,
                Key
                ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\sockets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sockets.cxx
//
//  Contents:   Code for kerberos client sockets
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jul-1996     MikeSw          Created
//
//----------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef WIN32_CHICAGO
#include <winsock2.h>
#else // WIN32_CHICAGO
#include <winsock.h>
#endif // WIN32_CHICAGO
#include <dsgetdc.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include <tostring.hxx>
#include "debug.h"
#else // WIN32_CHICAGO
extern "C"
{
#include <winsock.h>
}
#endif // WIN32_CHICAGO


LONG SocketStarts = -1;
ULONG TcpFragLength = 0x7fffffff ;
ULONG TcpFragDelay = 0 ;

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSockets
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeSockets(
    IN ULONG VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int Error;
    WSADATA SocketData;
#ifndef WIN32_CHICAGO
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
#endif // WIN32_CHICAGO

    //
    // Initialze sockets
    //

    *TcpNotInstalled = FALSE;

    if (InterlockedIncrement(&SocketStarts) != 0)
    {
        return(STATUS_SUCCESS);
    }

    Error = WSAStartup((int) VersionRequired, &SocketData);
    if (Error != 0)
    {
        DebugLog((DEB_ERROR,"WSAStartup failed: 0x%x\n",Error));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Make sure the version is high enough for us
    //

    if ((LOBYTE(SocketData.wVersion) < HIBYTE(VersionRequired)) ||
        (((LOBYTE(SocketData.wVersion) == HIBYTE(VersionRequired)) &&
         (HIBYTE(SocketData.wVersion) < LOBYTE(VersionRequired)))))
    {
        DebugLog((DEB_ERROR,"Invalid socket version: wanted 0x%x, got 0x%x\n",
            VersionRequired, SocketData.wVersion));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (SocketData.iMaxSockets < MinSockets)
    {
        DebugLog((DEB_ERROR,"Not enough sockets available: wanted %d, got %d\n",
            MinSockets, SocketData.iMaxSockets ));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    //
    // Check if TCP is an available xport
    //

    protocols[0] = IPPROTO_TCP;                                             
    protocols[1] = NULL;                                                    
    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);           
    if (nRet == 0)                                                          
    {                                                                       
        //                                                                  
        // Tcp is not installed as a xport.                                 
        //                                                                  
                                                                        
        D_DebugLog((DEB_T_SOCK,"WSAEnumProtocols returned 0x%x.\n", nRet));
        *TcpNotInstalled = TRUE;                                             
    }
#endif // WIN32_CHICAGO
Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (SocketStarts != -1)
        {
            WSACleanup();
            InterlockedDecrement(&SocketStarts);
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupSockets
//
//  Synopsis:   Cleansup socket handling code
//
//  Effects:    calls WSACleanup()
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbCleanupSockets(
    )
{
    if (InterlockedDecrement(&SocketStarts) < 0)
    {
        WSACleanup();
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCloseSocket
//
//  Synopsis:   Closes a socket binding handle
//
//  Effects:    calls closesocket on the handle
//
//  Arguments:  SocketHandle - handle to close
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCloseSocket(
    IN SOCKET SocketHandle
    )
{
    int SockError;
    if (SocketHandle != 0)
    {
        SockError = closesocket(SocketHandle);
        if (SockError != 0)
        {
            DebugLog((DEB_ERROR,"CloseSocket failed: last error = %d\n",WSAGetLastError()));
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBindSocketByAddress
//
//  Synopsis:   Binds to the KDC socket on the specified address
//
//  Effects:
//
//  Arguments:  Address - Address to bind to
//              AddressType - Address type, as specified by DC locator
//              ContextHandle - Receives bound socket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBindSocketByAddress(
    IN PUNICODE_STRING Address,
    IN ULONG AddressType,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    OUT SOCKET * ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET ClientSocket = INVALID_SOCKET;
    struct sockaddr_in ServerAddress;
    struct sockaddr_in ClientAddress;
    LPHOSTENT ServerInfo = NULL;
    STRING AnsiAddress = {0};

    AnsiAddress.Buffer = NULL;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiAddress,
                Address,
                TRUE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    ClientSocket = socket(
                    PF_INET,
                    (UseDatagram ? SOCK_DGRAM : SOCK_STREAM),
                    0
                    );
    if (ClientSocket == INVALID_SOCKET)
    {
        DebugLog((DEB_ERROR,"Failed to create socket: %d\n",WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (UseDatagram)
    {
        //
        // Bind client socket to any local interface and port
        //

        ClientAddress.sin_family = AF_INET;
        ClientAddress.sin_addr.s_addr = INADDR_ANY;
        ClientAddress.sin_port = 0;                 // no specific port

        if (bind(
                ClientSocket,
                (LPSOCKADDR) &ClientAddress,
                sizeof(ClientAddress)
                ) == SOCKET_ERROR )
        {
            DebugLog((DEB_ERROR,"Failed to bind client socket: %d\n",WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }
    }

    if (AddressType == DS_INET_ADDRESS)
    {
        ULONG InetAddress;
        //
        // Get the address of the server
        //

        InetAddress = inet_addr(AnsiAddress.Buffer);


        if (InetAddress == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to convert %Z to address: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = AF_INET;

        RtlCopyMemory(
            &ServerAddress.sin_addr,
            &InetAddress,
            sizeof(ULONG)
            );

    }
    else
    {
        //
        // Get the address of the server
        //

        ServerInfo = gethostbyname(AnsiAddress.Buffer);
        if (ServerInfo == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to get host %Z by name: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = ServerInfo->h_addrtype;

        RtlCopyMemory(
            &ServerAddress.sin_addr,
            ServerInfo->h_addr,
            sizeof(ULONG)
            );

    }

    ServerAddress.sin_port = htons(PortNumber);

    if (connect(
            ClientSocket,
            (LPSOCKADDR) &ServerAddress,
            sizeof(ServerAddress)
            ) == SOCKET_ERROR)
    {
        DebugLog((DEB_ERROR,"Failed to connect to server %Z: %d\n",&AnsiAddress, WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    *ContextHandle = ClientSocket;
    D_DebugLog((DEB_TRACE,"Successfully bound to %Z\n",&AnsiAddress));

Cleanup:
    if (AnsiAddress.Buffer != NULL)
    {
        RtlFreeAnsiString(&AnsiAddress);
    }
    if (!NT_SUCCESS(Status))
    {
        if (ClientSocket != INVALID_SOCKET)
        {
            closesocket(ClientSocket);
        }
    }
    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCallKdc
//
//  Synopsis:   Socket client stub for calling the KDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Bytes;
    int NumberReady;
    SOCKET Socket = 0;
    PUCHAR RemainingBuffer;
    ULONG RemainingSize;
    ULONG SendSize ;
    fd_set ReadHandles;
    struct timeval TimeoutTime;
    ULONG NetworkSize;
    BOOLEAN RetriedOnce = FALSE;

#ifndef WIN32_CHICAGO
    WSABUF Buffers[2] = {0};
    LPWSABUF SendBuffers = NULL;
    ULONG BufferCount = 0;
    int SendStatus;
#endif // WIN32_CHICAGO

    //
    // Start out by binding to the KDC
    //

    DebugLog((DEB_TRACE, "Calling KDC: %S\n", KdcAddress->Buffer));

    Status = KerbBindSocketByAddress(
                KdcAddress,
                AddressType,
                UseDatagram,
                PortNumber,
                &Socket
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RemainingBuffer = Input->Buffer;
    RemainingSize = Input->BufferSize;

#ifndef WIN32_CHICAGO

    //
    // Use winsock2
    //

    Buffers[0].len = sizeof(ULONG);
    NetworkSize = htonl(RemainingSize);
    Buffers[0].buf = (PCHAR) &NetworkSize;
    Buffers[1].len = Input->BufferSize;
    Buffers[1].buf = (PCHAR) Input->Buffer;

    if (UseDatagram)
    {
        BufferCount = 1;
        SendBuffers = &Buffers[1];
        RemainingSize = Buffers[1].len;
    }
    else
    {
        BufferCount = 2;
        SendBuffers = &Buffers[0];
        RemainingSize = Buffers[0].len + Buffers[1].len;
    }

RetrySend:

    SendStatus = WSASend(
                    Socket,
                    SendBuffers,
                    BufferCount,
                    &Bytes,
                    0,          // no flags
                    NULL,               // no overlapped
                    NULL                // no completion routine
                    );

    if ((SendStatus != 0) || (Bytes == 0))
    {
        DsysAssert(SendStatus == SOCKET_ERROR);
        DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }
    if (Bytes < RemainingSize)
    {
        RemainingSize -= Bytes;
        if (Bytes > SendBuffers->len)
        {
            //
            // We sent the whole of a buffer, so move on to the next
            //

            Bytes -= SendBuffers->len;

            DsysAssert(BufferCount > 1);
            BufferCount--;
            SendBuffers++;
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        else
        {
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        goto RetrySend;
    }




#else // WIN32_CHICAGO

    //
    // Use winsock1 for win9x
    //

    //
    // For TCP, send length first
    //

RetrySend:

    if (!UseDatagram)
    {
        NetworkSize = htonl(RemainingSize);
        Bytes = send(Socket, (char *)&NetworkSize,sizeof(ULONG), 0);
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to send TCP packet length: bytes sent = %d, last err = %d\n",
                Bytes,
                WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
    }
    do
    {
        if (!UseDatagram)
        {
            if ( RemainingSize > TcpFragLength )
            {
                SendSize = TcpFragLength ;
            }
            else
            {
                SendSize = RemainingSize ;
            }
            if ( TcpFragDelay )
            {
                Sleep( TcpFragDelay );
            }
        }
        else
        {
            SendSize = RemainingSize ;
        }
        D_DebugLog(( DEB_T_SOCK, "Sending %x bytes to %wZ\n",
                        SendSize, KdcAddress ));
        Bytes = send(Socket, (char *) RemainingBuffer, SendSize, 0);
        if (Bytes == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        if (Bytes != SendSize)
        {
            DebugLog((DEB_ERROR,"Failed to send all data - only send %d out of %d\n",
                Bytes, RemainingSize ));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingBuffer += Bytes;
        RemainingSize -= Bytes;
    } while ((Bytes != 0) && (RemainingSize != 0));

#endif

    //
    // Now select on the socket and wait for a response
    // ReadHandles and TimeoutTime must be reset each time, cause winsock
    // zeroes them out in case of error

    ReadHandles.fd_count = 1;
    ReadHandles.fd_array[0] = Socket;
    TimeoutTime.tv_sec = Timeout;
    TimeoutTime.tv_usec = 0;

    D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
    NumberReady = select(
                    1,
                    &ReadHandles,
                    NULL,
                    NULL,
                    &TimeoutTime
                    );
    if ((NumberReady == SOCKET_ERROR) ||
        (NumberReady == 0))
    {

        DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

        DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

        //
        // Retry again and wait.
        //

        if ((NumberReady == 0) && (!RetriedOnce))
        {
            RetriedOnce = TRUE;
            goto RetrySend;
        }
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Now receive the data
    //

    if (UseDatagram)
    {
        Output->BufferSize = KERB_MAX_KDC_RESPONSE_SIZE;
        Output->Buffer = (PUCHAR) MIDL_user_allocate(KERB_MAX_KDC_RESPONSE_SIZE);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Bytes = recv(
                    Socket,
                    (char *) Output->Buffer,
                    Output->BufferSize,
                    0
                    );
        if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        Output->BufferSize = Bytes;
    }
    else
    {
        Bytes = recv(
                    Socket,
                    (char *) &NetworkSize,
                    sizeof(ULONG),
                    0
                    );
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingSize = ntohl(NetworkSize);
        Output->BufferSize = RemainingSize;
        Output->Buffer = (PUCHAR) MIDL_user_allocate(RemainingSize);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        while (RemainingSize != 0)
        {
            //
            // Make sure there is data ready
            //

            D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
            NumberReady = select(
                            1,
                            &ReadHandles,
                            NULL,
                            NULL,
                            &TimeoutTime
                            );
            if ((NumberReady == SOCKET_ERROR) ||
                (NumberReady == 0))
            {
                DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

                DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup;
            }

            //
            // Receive the data
            //

            Bytes = recv(
                        Socket,
                        (char *) Output->Buffer + Output->BufferSize - RemainingSize,
                        RemainingSize,
                        0
                        );
            if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
            {
                DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
                Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                goto Cleanup;
            }
            RemainingSize -= Bytes;
        }
    }

Cleanup:
    if (Socket != 0)
    {
        KerbCloseSocket(Socket);
    }
    if (!NT_SUCCESS(Status))
    {
        if (Output->Buffer != NULL)
        {
            MIDL_user_free(Output->Buffer);
            Output->Buffer = NULL;
        }
    }
    return(Status);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\tickets.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include<kerb.hxx>
#include<kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>
#include <wincrypt.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include <tostring.hxx>
#include "debug.h"
#include "fileno.h"
#else// WIN32_CHICAGO
#include "tostring.hxx"
#endif // WIN32_CHICAGO

#include <utils.hxx>

#define FILENO  FILENO_TICKETS

//
// Debugging support.
//

#ifndef WIN32_CHICAGO
#ifdef DEBUG_SUPPORT

DEBUG_KEY   KSuppDebugKeys[] = { {DEB_ERROR, "Error"},
                                 {DEB_WARN,  "Warning"},
                                 {DEB_TRACE, "Trace"},
                                 {DEB_T_SOCK, "Sock"},
                                 {0, NULL }
                                 };
#endif

DEFINE_DEBUG_DEFER(KSupp, KSuppDebugKeys);
#endif // WIN32_CHICAGO

RTL_CRITICAL_SECTION OssCriticalSection;
BOOLEAN TicketsInitialized;
BOOLEAN KerbUseFastDecodeAlloc = FALSE;

#define I_LsaIThreadAlloc MIDL_user_allocate
#define I_LsaIThreadFree MIDL_user_free

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertGeneralizedTimeToLargeInt
//
//  Synopsis:   Converts a generalized time (ASN.1 format) to a large integer
//              (NT format)
//
//  Effects:
//
//  Arguments:  TimeStamp - receives NT-style time
//              ClientTime - client generalized time
//              ClientUsec - client micro second count
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime;
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

    RtlZeroMemory(
        &ZeroTime,
        sizeof(KERB_TIME)
        );

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //


    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }
    else
    {
        TimeFields.Year = ClientTime->year;
        TimeFields.Month = ClientTime->month;
        TimeFields.Day = ClientTime->day;
        TimeFields.Hour = ClientTime->hour;
        TimeFields.Minute = ClientTime->minute;
        TimeFields.Second = ClientTime->second;
        TimeFields.Milliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.Weekday = 0;

#ifndef WIN32_CHICAGO
        RtlTimeFieldsToTime(
            &TimeFields,
            TimeStamp
            );
#else // WIN32_CHICAGO
        LARGE_INTEGER TempTimeStamp;
        RtlTimeFieldsToTime(
            &TimeFields,
            &TempTimeStamp
            );
        *TimeStamp = TempTimeStamp.QuadPart;
#endif // WIN32_CHICAGO

        //
        // add in any micro seconds
        //

#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart += ClientUsec * 10;
#else // WIN32_CHICAGO
        *TimeStamp += ClientUsec * 10;
#endif // WIN32_CHICAGO

    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertLargeIntToGeneralizedTime
//
//  Synopsis:   Converts a large integer to ageneralized time
//
//  Effects:
//
//  Arguments:  ClientTime - receives generalized time
//              ClientUsec - receives micro second count
//              TimeStamp - contains NT-style time
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

#ifndef WIN32_CHICAGO
    if (TimeStamp->QuadPart == 0)
#else // WIN32_CHICAGO
    if (*TimeStamp == 0)
#endif // WIN32_CHICAGO
    {
        RtlZeroMemory(
            ClientTime,
            sizeof(KERB_TIME)
            );
        //
        // For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {

#ifndef WIN32_CHICAGO
        RtlTimeToTimeFields(
            TimeStamp,
            &TimeFields
            );
#else // WIN32_CHICAGO
        RtlTimeToTimeFields(
            (LARGE_INTEGER*)TimeStamp,
            &TimeFields
            );
#endif // WIN32_CHICAGO

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.Year;
        }
        ClientTime->month = (ASN1uint8_t) TimeFields.Month;
        ClientTime->day = (ASN1uint8_t) TimeFields.Day;
        ClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        ClientTime->second = (ASN1uint8_t) TimeFields.Second;

        // MIT kerberos does not support millseconds
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // Since we don't include milliseconds above, use the whole
            // thing here.
            //

#ifndef WIN32_CHICAGO
            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
#else // WIN32_CHICAGO
            *ClientUsec = (int) ((*TimeStamp / 10) % 1000000);
#endif // WIN32_CHICAGO
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }

}

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
        int temp;

        if (ClientUsec != NULL)
        {
                KerbConvertLargeIntToGeneralizedTime(
                        ClientTime,
                        &temp,
                        TimeStamp
                        );

                *ClientUsec = temp;
        }
        else
        {
                KerbConvertLargeIntToGeneralizedTime(
                        ClientTime,
                        NULL,
                        TimeStamp
                        );
        }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeHostAddresses
//
//  Synopsis:   Frees a host address  allocated with KerbBuildHostAddresses
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES Elem,NextElem;

    Elem = Addresses;
    while (Elem != NULL)
    {
        if (Elem->value.address.value != NULL)
        {
            MIDL_user_free(Elem->value.address.value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}




#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckTimeSkew
//
//  Synopsis:   Verifies the supplied time is within the skew of another
//              supplied time
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    )
{
    TimeStamp TimePlus, TimeMinus;

    TimePlus.QuadPart = CurrentTime->QuadPart + AllowedSkew->QuadPart;
    TimeMinus.QuadPart = CurrentTime->QuadPart - AllowedSkew->QuadPart;

    if ((ClientTime->QuadPart > TimePlus.QuadPart) ||
        (ClientTime->QuadPart < TimeMinus.QuadPart))
    {
        return(FALSE);
    }

    return(TRUE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyTicket
//
//  Synopsis:   Verifies that the specified ticket is valid by checking
//              for valid times, flags, and server principal name. This is
//              called by KerbCheckTicket to verify an AP request and by the
//              KDC to verify additional tickets in TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbVerifyTicket(
    IN PKERB_TICKET PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL PUNICODE_STRING ServiceNames,
    IN PUNICODE_STRING ServiceRealm,
    IN PKERB_ENCRYPTION_KEY ServiceKey,
    IN OPTIONAL PTimeStamp SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING TicketRealm = {0};
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    TimeStamp TimePlus, TimeMinus, TimeNow, StartTime,EndTime, Time2Plus;
    ULONG TicketFlags = 0;

#ifdef notedef
    if ( ARGUMENT_PRESENT(ServiceNames) )
    {
        ULONG Index;

        KerbErr = KRB_AP_ERR_NOT_US;

        //
        // Loop through names looking for a match
        //

        for (Index = 0; Index < NameCount ; Index++ )
        {
            if (KerbCompareStringToPrincipalName(
                &PackedTicket->server_name,
                &ServiceNames[Index]
                ) )
            {
                KerbErr = KDC_ERR_NONE;
                break;
            }

        }
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%s) not for this service (%wZ).\n",
                                 KLIN(FILENO, __LINE__),
                                 PackedTicket->server_name.name_string->value,
                                 &ServiceNames[0] ));
            goto Cleanup;
        }
    }


    if (ARGUMENT_PRESENT(ServiceRealm))
    {
        KerbErr = KerbConvertRealmToUnicodeString(
                    &TicketRealm,
                    &PackedTicket->realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if (!KerbCompareUnicodeRealmNames(
                &TicketRealm,
                ServiceRealm
                ))
        {
            KerbErr = KRB_AP_ERR_NOT_US;
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%wZ) not for this realm (%wZ).\n",
                                 KLIN(FILENO, __LINE__), &TicketRealm, ServiceRealm ));
            goto Cleanup;

        }
    }
#endif

    //
    // Unpack ticket.
    //

    KerbErr = KerbUnpackTicket(
                    PackedTicket,
                    ServiceKey,
                    &EncryptPart
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "KLIN(%x) KerbUnpackTicket failed: 0x%x",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }


    if (PackedTicket->ticket_version != KERBEROS_VERSION)
    {
        DebugLog(( DEB_WARN, "KLIN(%x) Ticket has bad version %d\n",
            KLIN(FILENO, __LINE__),PackedTicket->ticket_version ));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }



    //
    // If the caller provided a skew time, check the times on the ticket.
    // Otherwise it is up to the caller to check that the ticket times are
    // correct
    //


    if (ARGUMENT_PRESENT(SkewTime))
    {
        //
        // Check the times on the ticket.  We do this last because when the KDC
        // wants to renew a ticket, the timestamps may be incorrect, but it will
        // accept the ticket anyway.  This way the KDC can be certain when the
        // times are wrong that everything else is OK.
        //

        GetSystemTimeAsFileTime((PFILETIME) &TimeNow );

    #ifndef WIN32_CHICAGO
        TimePlus.QuadPart = TimeNow.QuadPart + SkewTime->QuadPart;
        Time2Plus.QuadPart = TimePlus.QuadPart + SkewTime->QuadPart;
        TimeMinus.QuadPart = TimeNow.QuadPart - SkewTime->QuadPart;
    #else // WIN32_CHICAGO
        TimePlus = TimeNow + *SkewTime;
        Time2Plus = TimePlus + *SkewTime;
        TimeMinus = TimeNow - *SkewTime;
    #endif // WIN32_CHICAGO

        KerbConvertGeneralizedTimeToLargeInt(
            &EndTime,
            &EncryptPart->endtime,
            0
            );

        //
        // Did the ticket expire already?
        //

    #ifndef WIN32_CHICAGO
        if ( EndTime.QuadPart < TimeMinus.QuadPart )
    #else // WIN32_CHICAGO
        if ( EndTime < TimeMinus )
    #endif // WIN32_CHICAGO
        {
            DebugLog(( DEB_WARN, "KLIN(%x) KerbCheckTicket: ticket is expired.\n",
                KLIN(FILENO, __LINE__)));

            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }

        //
        // Is the ticket  valid yet?
        //

        if (EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &StartTime,
                &EncryptPart->KERB_ENCRYPTED_TICKET_starttime,
                0
                );


            TicketFlags = KerbConvertFlagsToUlong(
                            &EncryptPart->flags
                            );
            //
            // BUG 403734: Look into this a bit more
            // We don't check for tickets that aren't valid yet, as
            // our KDC doesn't normally hand out post dated tickets. As long
            // as the end time is valid, that is good enough for us.
            //

            //
            // Does the ticket start in the future? Allow twice the skew in
            // the reverse direction.
            //
    #ifndef WIN32_CHICAGO
            if ( (StartTime.QuadPart > Time2Plus.QuadPart) ||
    #else // WIN32_CHICAGO
            if ( (StartTime > Time2Plus) ||
    #endif // WIN32_CHICAGO
                ((TicketFlags & KERB_TICKET_FLAGS_invalid) != 0 ))
            {
                KerbErr = KRB_AP_ERR_TKT_NYV;
                goto Cleanup;
            }
        }
    }

    *DecryptedTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:
    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }
    KerbFreeString(&TicketRealm);
    return(KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbCheckTicket
//
//  Synopsis:   Decrypts a ticket and authenticator, verifies them.
//
//  Effects:    decrypts the ticket and authenticator (in place) allocates mem.
//
//  Arguments:  [PackedTicket]    -- Encrypted ticket
//              [PackedTicketSize] - Size of encrypted ticket
//              [pedAuth]         -- Encrypted authenticator
//              [pkKey]           -- Key to decrypt ticket with
//              [alAuthenList]    -- List of authenticators to check against
//              [NameCount]       -- Count of service names
//              [pwzServiceName]  -- Name of service (may be NULL).
//              [CheckForReplay]  -- If TRUE, check authenticator cache for replay
//              [KdcRequest]      -- If TRUE, this is the ticket in a TGS req
//              [pkitTicket]      -- Decrypted ticket
//              [pkiaAuth]        -- Decrypted authenticator
//              [pkTicketKey]     -- Session key from ticket
//              [pkSessionKey]    -- Session key to use
//
//  Returns:    KDC_ERR_NONE if everything is OK, else error.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The caller must call KerbFreeTicket and
//              KerbFreeAuthenticator on pkitTicket and pkiaAuth,
//              respectively.
//
//              If pwzServiceName == NULL, it won't check the service name.
//
//              See sections 3.2.3 and A.10 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCheckTicket(
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  PKERB_ENCRYPTION_KEY pkKey,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  PTimeStamp SkewTime,
    IN  ULONG NameCount,
    IN  PUNICODE_STRING ServiceNames,
    IN  PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT PBOOLEAN UseSubKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    LARGE_INTEGER AuthenticatorTime;


    //
    // The caller will free these, so we must make sure they are valid
    // if we return before putting anything in them.  This will zero out
    // all of the pointers in them, so it's safe to free them later.
    //

    *EncryptTicket = NULL;
    *Authenticator = NULL;
    *UseSubKey = FALSE;

    RtlZeroMemory(
        pkSessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        *pkTicketKey = *pkSessionKey;
    }


    //
    // Is the ticket for this service?
    // ServerName in ticket is different length then ServerName passed in,
    // or same length but contents don't match.



    //
    // If either of KerbUnpackTicket or KerbUnpackAuthenticator
    // get bad data, they could access violate.
    //

    __try
    {

        KerbErr = KerbVerifyTicket(
                    PackedTicket,
                    NameCount,
                    ServiceNames,
                    ServiceRealm,
                    pkKey,
                    SkewTime,
                    &EncryptPart
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            __leave;
        }


        //
        // Unpack Authenticator.
        //

        KerbErr = KerbUnpackAuthenticator(
                    &EncryptPart->key,
                    EncryptedAuthenticator,
                    KdcRequest,
                    Authenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,"KerbUnpackAuthenticator failed: 0x%x\n", KerbErr) );
            __leave;
        }



        //
        // Check the contents of the authenticator
        //
        if ((*Authenticator)->authenticator_version != KERBEROS_VERSION)
        {
            DebugLog(( DEB_WARN, "Authenticator has bad version %d\n",
                                  (*Authenticator)->authenticator_version ));
            KerbErr = KRB_AP_ERR_BADVERSION;
            __leave;
        }


        if (!KerbComparePrincipalNames(
                &EncryptPart->client_name,
                &(*Authenticator)->client_name
                ) ||
            !KerbCompareRealmNames(
                &EncryptPart->client_realm,
                &(*Authenticator)->client_realm
                ) )
        {
            DebugLog(( DEB_WARN, "Authenticator principal != ticket principal\n"));
            KerbErr = KRB_AP_ERR_BADMATCH;
            __leave;
        }


        //
        // Make sure the authenticator isn't a repeat, or too old.
        //

        if (CheckForReplay)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &AuthenticatorTime,
                &(*Authenticator)->client_time,
                (*Authenticator)->client_usec
                );

            KerbErr = (KERBERR) AuthenticatorList->Check(
                                    EncryptedAuthenticator->cipher_text.value,
                                    EncryptedAuthenticator->cipher_text.length,
                                    NULL,
                                    0,
                                    &AuthenticatorTime,
                                    TRUE
                                    );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_WARN,"Failed authenticator check: 0x%x\n",KerbErr));
                __leave;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Any exceptions are likely from bad ticket data being unmarshalled.
        DebugLog(( DEB_WARN, "Exception 0x%X in KerbCheckTicket (likely bad ticket or auth.\n",
            GetExceptionCode() ));
        KerbErr = KRB_AP_ERR_BADVERSION;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // Extract the correct session key.  If the Sub-session key in the
    // Authenticator is present, use it.  Otherwise, use the session key
    // from the ticket.
    //

    if (((*Authenticator)->bit_mask & KERB_AUTHENTICATOR_subkey_present) != 0)
    {
        D_DebugLog(( DEB_TRACE, "Using sub session key from authenticator.\n" ));
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &(*Authenticator)->KERB_AUTHENTICATOR_subkey
                    );
        *UseSubKey = TRUE;
    }
    else
    {
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &EncryptPart->key
                    );
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // The reply has to be encrypted with the ticket key, not the new
    // session key
    //

    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        KerbErr = KerbDuplicateKey(
                    pkTicketKey,
                    &EncryptPart->key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }


    *EncryptTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:
    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeKey(pkSessionKey);
        if (ARGUMENT_PRESENT(pkTicketKey))
        {
            KerbFreeKey(pkTicketKey);
        }
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    if (!RtlValidSid(SourceSid))
    {
        return STATUS_INVALID_PARAMETER;
    }

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);
    *DestinationSid = (PSID) MIDL_user_allocate( SidSize );
    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );
    return(STATUS_SUCCESS);
}

#endif // WIN32_CHICAGO


//
// Ticket pack/unpack code.
//



struct BufferState
{
    PBYTE   pbBufferPointer;
    ULONG   cbBufferSize;
};

static void
AllocFcn( void * pvState, char ** ppbOut, unsigned int * pulSize )
{
    BufferState* state = (BufferState*) pvState;

    //
    // MIDL pickling calls this routine with the size of the object
    // obtained by _GetSize(). This routine must return a buffer in
    // ppbOut with at least *pulSize bytes.
    //

    DsysAssert( state->pbBufferPointer != NULL );
    DsysAssert( state->cbBufferSize >= *pulSize );

    *ppbOut = (char*)state->pbBufferPointer;
    state->pbBufferPointer += *pulSize;
    state->cbBufferSize -= *pulSize;
}

static void
WriteFcn( void * pvState, char * pbOut, unsigned int ulSize )
{
    //
    // Since the data was pickled directly to the target buffer, don't
    // do anything here.
    //
}

static void
ReadFcn( void * pvState, char ** ppbOut, unsigned int * pulSize )
{
    BufferState* state = (BufferState*) pvState;

    //
    // MIDL pickling calls this routine with the size to read.
    // This routine must return a buffer in ppbOut which contains the
    // encoded data.
    //

    DsysAssert( state->pbBufferPointer != NULL );
    DsysAssert( state->cbBufferSize >= *pulSize );

    *ppbOut = (char*)state->pbBufferPointer;
    state->pbBufferPointer += *pulSize;
    state->cbBufferSize -= *pulSize;
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbPackTicket
//
//  Synopsis:   Packs a KerbInternalTicket to a KerbTicket
//
//  Effects:    Allocates the KerbTicket via MIDL.
//
//  Arguments:  [InternalTicket] -- Internal ticket to pack. Those fields
//                      reused in the packed ticket are zeroed.
//              [pkKey]      -- Key to pack it with
//              [EncryptionType] -- Encryption type to use
//              [PackedTicket] -- (out) encrypted ticket. Only the encrypt_part
//                      is allocated.
//
//  History:    08-Jun-93   WadeR   Created
//
//  Notes:      The MES encoding needs to be changed to ASN1 encoding
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbPackTicket(
    IN PKERB_TICKET InternalTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    OUT PKERB_TICKET PackedTicket
    )
{
    KERBERR       KerbErr = KDC_ERR_NONE;
    PKERB_TICKET    OutputTicket = 0;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    ULONG           cbEncryptedPart;
    KERB_TICKET     TemporaryTicket;
    PUCHAR          MarshalledEncryptPart = NULL;
    ULONG           EncryptionOverhead;
    ULONG           BlockSize;

    //
    // Pack the data into the encrypted portion.
    //

    RtlZeroMemory(
        &TemporaryTicket,
        sizeof(KERB_TICKET)
        );

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) InternalTicket->encrypted_part.cipher_text.value;


    KerbErr = KerbPackData(
                EncryptedTicket,
                KERB_ENCRYPTED_TICKET_PDU,
                &cbEncryptedPart,
                &MarshalledEncryptPart
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // And encrypt it.
    //



    TemporaryTicket = *InternalTicket;

    RtlZeroMemory(
        &InternalTicket->realm,
        sizeof(KERB_REALM)
        );

    RtlZeroMemory(
        &InternalTicket->server_name,
        sizeof(KERB_PRINCIPAL_NAME)
        );


    KerbErr = KerbAllocateEncryptionBufferWrapper(
                EncryptionType,
                cbEncryptedPart,
                &TemporaryTicket.encrypted_part.cipher_text.length,
                &TemporaryTicket.encrypted_part.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                &TemporaryTicket.encrypted_part,
                cbEncryptedPart,
                MarshalledEncryptPart,
                EncryptionType,
                KERB_TICKET_SALT,
                pkKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *PackedTicket = TemporaryTicket;

Cleanup:
    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        if (TemporaryTicket.encrypted_part.cipher_text.value != NULL)
        {
            MIDL_user_free(TemporaryTicket.encrypted_part.cipher_text.value);
        }

    }
    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbUnpackTicket
//
//  Synopsis:   Decrypts and unpacks the encyrpted part of aticket.
//
//  Effects:    Allocates memory, decrypts pktTicket in place
//
//  Arguments:  [PackedTicket]  -- ticket to unpack
//              [PackedTicketSize] -- length of packed ticket
//              [pkKey]      -- key to unpack it with
//              [InternalTicket] -- (out) unpacked ticket
//
//  Returns:    KDC_ERR_NONE or error from decrypt
//
//  Signals:    Any exception the MIDL unpacking code throws.
//
//  History:    09-Jun-93   WadeR   Created
//
//  Notes:      Free InternalTicket with KerbFreeTicket, below.
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    )
{
    KERBERR   KerbErr = KDC_ERR_NONE;
    PKERB_TICKET DecryptedTicket = NULL;
    PUCHAR EncryptedPart = NULL;
    ULONG EncryptSize;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;


    //
    // Now decrypt the encrypted part of the ticket
    //

    EncryptedPart = (PUCHAR) MIDL_user_allocate(PackedTicket->encrypted_part.cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptSize = PackedTicket->encrypted_part.cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                &PackedTicket->encrypted_part,
                pkKey,
                KERB_TICKET_SALT,
                &EncryptSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptSize,
                KERB_ENCRYPTED_TICKET_PDU,
                (PVOID *) &EncryptedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *InternalTicket = EncryptedTicket;
Cleanup:
    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }
    return(KerbErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   KerbCreateAuthenticator
//
//  Synopsis:   Creates an authenticator for a client to pass to a service
//
//  Effects:    Encrypts pedAuthenticator
//
//  Arguments:  [pkKey]            -- (in) session key from the ticket this
//                                         authenticator is for.
//              [dwEncrType]       -- (in) Desired encryption type
//              [dwSeq]            -- (in) nonce for authenticator
//              [ClientName]       -- (in) name of principal
//              [ClientRealm]      -- (in) logon realm of principal
//              [SkewTime]         -- (in) Skew of server's time
//              [pkSubKey]         -- (in) desired sub key (may be NULL)
//              [GssChecksum]      -- (in) optional checksum message to put in authenticator
//              [KdcRequest]       -- (in) If TRUE, this is an authenticator for a KDC request
//                                              and we use a different salt
//              [Authenticator]-- (out) completed authenticator
//
//  History:    4-28-93   WadeR   Created
//
//  Notes:      If pkKey is NULL, a null subkey is used.
//
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateAuthenticator(
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PTimeStamp SkewTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    )
{
    KERB_AUTHENTICATOR InternalAuthenticator;
    PKERB_AUTHENTICATOR AuthPointer = &InternalAuthenticator;
    ULONG cbAuthenticator;
    ULONG cbTotal;
    PUCHAR PackedAuthenticator = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    TimeStamp TimeToUse;
    ULONG EncryptionOverhead;
    ULONG BlockSize;

    Authenticator->cipher_text.value = NULL;

    RtlZeroMemory(
        &InternalAuthenticator,
        sizeof(KERB_AUTHENTICATOR)
        );

    // Build an authenticator

    InternalAuthenticator.authenticator_version = KERBEROS_VERSION;

    // Use "InitString" because we will marshall and then discard the
    // InternalAthenticator.  Therefore it's not a problem having the
    // string point to memory we don't own.

    KerbErr = KerbConvertUnicodeStringToRealm(
                &InternalAuthenticator.client_realm,
                ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertKdcNameToPrincipalName(
                &InternalAuthenticator.client_name,
                ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Stick the correct time in the authenticator
    //

    GetSystemTimeAsFileTime((PFILETIME)&TimeToUse);
    if (ARGUMENT_PRESENT(SkewTime))
    {
#ifndef WIN32_CHICAGO
        TimeToUse.QuadPart += SkewTime->QuadPart;
#else // WIN32_CHICAGO
        TimeToUse += *SkewTime;
#endif // WIN32_CHICAGO
    }

        KerbConvertLargeIntToGeneralizedTimeWrapper(
        &InternalAuthenticator.client_time,
        &InternalAuthenticator.client_usec,
        &TimeToUse
        );

    InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_sequence_number_present;

    ASN1intx_setuint32(
        &InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number,
        SequenceNumber
        );
    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pkSubKey))
    {
        InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_subkey_present;
        InternalAuthenticator.KERB_AUTHENTICATOR_subkey = *pkSubKey;
    }

    //
    // If the GSS checksum is present, include it and set it in the bitmask
    //

    if (ARGUMENT_PRESENT(GssChecksum))
    {
        InternalAuthenticator.checksum = *GssChecksum;
        InternalAuthenticator.bit_mask |= checksum_present;
    }

    KerbErr = KerbPackData(
                AuthPointer,
                KERB_AUTHENTICATOR_PDU,
                &cbAuthenticator,
                &PackedAuthenticator
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Now we need to encrypt the buffer
    //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                EncryptionType,
                cbAuthenticator,
                &Authenticator->cipher_text.length,
                &Authenticator->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                Authenticator,
                cbAuthenticator,
                PackedAuthenticator,
                EncryptionType,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                pkKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }


Cleanup:
    KerbFreePrincipalName(&InternalAuthenticator.client_name);
    KerbFreeRealm(&InternalAuthenticator.client_realm);
    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value != NULL)
    {
        ASN1intx_free(&InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number);
    }
    if (PackedAuthenticator != NULL)
    {
        MIDL_user_free(PackedAuthenticator);

    }
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAuthenticator
//
//  Synopsis:   Unpacks and decrypts an authenticator
//
//  Effects:    allocates memory for output authenticator
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    )
{
    KERBERR  KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart;
    ULONG EncryptedSize;
    ULONG Pdu = KERB_AUTHENTICATOR_PDU;

    *Authenticator = NULL;
    //
    // Decrypt it
    //


    EncryptedPart = (PUCHAR) MIDL_user_allocate(EncryptedAuthenticator->cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptedSize = EncryptedAuthenticator->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedAuthenticator,
                Key,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                &EncryptedSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Unpack it
    //

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptedSize,
                Pdu,
                (PVOID *) Authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:
    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }
    if (!KERB_SUCCESS(KerbErr) && (*Authenticator != NULL))
    {
        MIDL_user_free(*Authenticator);
        *Authenticator = NULL;
    }
    return(KerbErr);
}



//
// KDC Reply stuff
//



//+-------------------------------------------------------------------------
//
//  Function:   KerbPackKdcReplyBody
//
//  Synopsis:   Marshalls a the body of a KDC reply
//
//  Effects:    allocates value of encrypted reply
//
//  Arguments:  ReplyBody - The reply body to marshall
//              Key - The key to encrypt the reply
//              EncryptionType - the algorithm to encrypt with
//              Pdu - Pdu to pack with, eith AS or TGS reply
//              EncryptedReplyBody - receives the encrypted and marshalled reply
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbPackKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG EncryptionType,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG BodySize;
    ULONG EncryptionOverhead;
    PUCHAR MarshalledReply = NULL;
    ULONG TotalSize;
    ULONG BlockSize = 0;

    EncryptedReply->cipher_text.value = NULL;


    KerbErr = KerbPackData(
                ReplyBody,
                Pdu,
                &BodySize,
                &MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall kdc reply body: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Now we need to encrypt this into the encrypted  data structure.
    //


    //
    // First get the overhead size
    //

    KerbErr = KerbGetEncryptionOverhead(
                EncryptionType,
                &EncryptionOverhead,
                &BlockSize
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    DsysAssert(BlockSize <= 8);


    TotalSize = ROUND_UP_COUNT(EncryptionOverhead + BodySize, BlockSize);

    EncryptedReply->cipher_text.length = TotalSize;
    EncryptedReply->cipher_text.value = (PUCHAR) MIDL_user_allocate(TotalSize);
    if (EncryptedReply->cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now encrypt the buffer
    //

    KerbErr = KerbEncryptDataEx(
                EncryptedReply,
                BodySize,
                MarshalledReply,
                EncryptionType,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                Key
                );

#ifndef USE_FOR_CYBERSAFE
    EncryptedReply->version = 1;
    EncryptedReply->bit_mask |= version_present;
#endif

Cleanup:
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (!KERB_SUCCESS(KerbErr) && (EncryptedReply->cipher_text.value != NULL))
    {
        MIDL_user_free(EncryptedReply->cipher_text.value);
        EncryptedReply->cipher_text.value = NULL;
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackKdcReplyBody
//
//  Synopsis:   Unpacks a KDC reply body
//
//  Effects:
//
//  Arguments:  EncryptedReplyBody - an encrypted marshalled reply body.
//              Key - Key to decrypt the reply.
//              Pdu - PDU of reply body (eithe AS or TGS)
//              ReplyBody - receives the decrypted reply body, allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUCHAR MarshalledReply = NULL;
    ULONG ReplySize;

    *ReplyBody = NULL;
    MarshalledReply = (PUCHAR) MIDL_user_allocate(EncryptedReplyBody->cipher_text.length);

    if (MarshalledReply == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // First decrypt the buffer
    //

    ReplySize = EncryptedReplyBody->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedReplyBody,
                Key,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                &ReplySize,
                MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                MarshalledReply,
                ReplySize,
                Pdu,
                (PVOID *) ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        //
        // MIT KDCs send back TGS reply bodies instead of AS reply bodies
        // so try TGS here
        //

        if (Pdu == KERB_ENCRYPTED_AS_REPLY_PDU)
        {
            KerbErr = KerbUnpackData(
                        MarshalledReply,
                        ReplySize,
                        KERB_ENCRYPTED_TGS_REPLY_PDU,
                        (PVOID *) ReplyBody
                        );

        }
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unmarshall kdc reply body: 0x%x\n",KerbErr));
            goto Cleanup;
        }

    }
Cleanup:
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (!KERB_SUCCESS(KerbErr) && (*ReplyBody != NULL))
    {
        MIDL_user_free(*ReplyBody);
        *ReplyBody = NULL;
    }
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbFindAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_AUTHORIZATION_DATA
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.auth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindPreAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    )
{
    PKERB_PA_DATA_LIST TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.preauth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData  != NULL ? &TempData->value : NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePreAuthData
//
//  Synopsis:   Frees a pa-data list
//
//  Effects:
//
//  Arguments:  PreAuthData - data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    )
{
    PKERB_PA_DATA_LIST Next,Last;

    Next = PreAuthData;

    while (Next != NULL)
    {
        Last = Next->next;
        if (Next->value.preauth_data.value != NULL)
        {
            MIDL_user_free(Next->value.preauth_data.value);
        }
        MIDL_user_free(Next);
        Next = Last;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeAuthData
//
//  Synopsis:   Frees and auth data structure that was allocated in
//              pieces
//
//  Effects:    frees with MIDL_user_Free
//
//  Arguments:  AuthData - the auth data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData1,TempData2;

    TempData1 = AuthData;
    while (TempData1 != NULL)
    {
        TempData2 = TempData1->next;
        if (TempData1->value.auth_data.value != NULL)
        {
            MIDL_user_free(TempData1->value.auth_data.value);
        }
        MIDL_user_free(TempData1);
        TempData1 = TempData2;
    }
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyAndAppendAuthData
//
//  Synopsis:   copies the elements from the input auth data and appends
//              them to the end of the output auth data.
//
//  Effects:    allocates each auth data with MIDL_user_allocate
//
//  Arguments:  OutputAuthData - receives list of append auth data
//              InputAuthData - optionally contains auth data to append
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:      on failure output auth data will be freed and set to NULL.
//
//
//--------------------------------------------------------------------------


KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA  *LastEntry = OutputAuthData;
    PKERB_AUTHORIZATION_DATA TempEntry = NULL;

    //
    // Find the end of the list
    //

    while (*LastEntry != NULL)
    {
        LastEntry = &((*LastEntry)->next);
    }

    while (InputAuthData != NULL)
    {
        //
        // copy the existing entry
        //

        TempEntry = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
        if (TempEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        TempEntry->value.auth_data.length = InputAuthData->value.auth_data.length;
        TempEntry->value.auth_data_type = InputAuthData->value.auth_data_type;
        TempEntry->next = NULL;

        TempEntry->value.auth_data.value = (PUCHAR) MIDL_user_allocate(InputAuthData->value.auth_data.length);

        if (TempEntry->value.auth_data.value == NULL)
        {
            MIDL_user_free(TempEntry);
            goto Cleanup;
        }

        RtlCopyMemory(
            TempEntry->value.auth_data.value,
            InputAuthData->value.auth_data.value,
            InputAuthData->value.auth_data.length
            );

        //
        // add it to the end of the list
        //

        *LastEntry = TempEntry;
        LastEntry = &TempEntry->next;
        InputAuthData = InputAuthData->next;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeAuthData(*OutputAuthData);
        *OutputAuthData = NULL;
    }
    return(KerbErr);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertCryptListToArray
//
//  Synopsis:   Converts a linked-list crypt vector to an array of ULONGs
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    )

{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_CRYPT_LIST NextEType;
    ULONG ClientETypeCount;
    PULONG ClientETypes = NULL;

    //
    // Build a vector of the client encrypt types
    //

    NextEType = CryptList;

    ClientETypeCount = 0;
    while (NextEType != NULL)
    {
        ClientETypeCount++;
        NextEType = NextEType->next;
    }

    ClientETypes = (PULONG) MIDL_user_allocate(sizeof(ULONG) * ClientETypeCount);
    if (ClientETypes == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NextEType = CryptList;

    ClientETypeCount = 0;
    while (NextEType != NULL)
    {
        ClientETypes[ClientETypeCount] = NextEType->value;
        ClientETypeCount++;
        NextEType = NextEType->next;
    }
    *ETypeCount = ClientETypeCount;
    *ETypeArray = ClientETypes;

Cleanup:
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertArrayToCryptList
//
//  Synopsis:   Converts an array of encryption to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (ETypeCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < ETypeCount ; Index++ )
    {
        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));
        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NewListEntry->value = ETypeArray[Index];
        NewListEntry->next = NULL;
        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }
        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:
    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKeysToCryptList
//
//  Synopsis:   Converts an array of keys to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (Keys->CredentialCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < Keys->CredentialCount ; Index++ )
    {
        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));
        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NewListEntry->value = Keys->Credentials[Index].Key.keytype;
        NewListEntry->next = NULL;
        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }
        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:
    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCryptList
//
//  Synopsis:   Frees a list of crypt types
//
//  Effects:
//
//  Arguments:  CryptList - List to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    )
{
    PKERB_CRYPT_LIST ListHead = CryptList;
    PKERB_CRYPT_LIST NewListEntry;

    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateApRequest
//
//  Synopsis:   builds an AP request message
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  ClientName - Name of client
//              ClientRealm - Realm of client
//              SessionKey - Session key for the ticket
//              SubSessionKey - obtional sub Session key for the authenticator
//              Nonce - Nonce to use in authenticator
//              ServiceTicket - Ticket for service to put in request
//              ApOptions - Options to stick in AP request
//              GssChecksum - Checksum for GSS compatibility containing
//                      context options and delegation info.
//              KdcRequest - if TRUE, this is an AP request for a TGS req
//              ServerSkewTime - Optional skew of server's time
//              RequestSize - Receives size of the marshalled request
//              Request - Receives the marshalled request
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on memory or
//              marshalling failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KerbCreateApRequest(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_AP_REQUEST ApRequest;
    ULONG ApFlags;

    *Request = NULL;
    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;
    ApFlags = KerbConvertUlongToFlagUlong(ApOptions);
    ApRequest.ap_options.value = (PUCHAR) &ApFlags;
    ApRequest.ap_options.length = sizeof(ULONG) * 8;
    ApRequest.ticket = *ServiceTicket;

    //
    // Create the authenticator for the request
    //



    KerbErr = KerbCreateAuthenticator(
                SessionKey,
                SessionKey->keytype,
                Nonce,
                ClientName,
                ClientRealm,
                ServerSkewTime,
                SubSessionKey,
                GssChecksum,
                KdcRequest,
                &ApRequest.authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to build authenticator: 0x%x\n",
            KerbErr ));
        goto Cleanup;
    }

    //
    // Now marshall the request
    //

    KerbErr = KerbPackApRequest(
                &ApRequest,
                RequestSize,
                Request
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack AP request: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:
    if (ApRequest.authenticator.cipher_text.value != NULL)
    {
        MIDL_user_free(ApRequest.authenticator.cipher_text.value);
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitAsn
//
//  Synopsis:   Initializes asn1 marshalling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL fKRB5ModuleStarted = FALSE;

KERBERR
KerbInitAsn(
    IN OUT ASN1encoding_t * pEnc,
        IN OUT ASN1decoding_t * pDec
    )
{
    int Result;
    KERBERR KerbErr = KRB_ERR_GENERIC;
        ASN1error_e Asn1Err;

        if (!fKRB5ModuleStarted)
        {
                fKRB5ModuleStarted = TRUE;
                KRB5_Module_Startup();
        }

        if (pEnc != NULL)
        {
                Asn1Err = ASN1_CreateEncoder(
                                         KRB5_Module,
                                         pEnc,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }
        else
        {
                Asn1Err = ASN1_CreateDecoder(
                                         KRB5_Module,
                                         pDec,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }

        if (ASN1_SUCCESS != Asn1Err)
        {
                DebugLog((DEB_ERROR, "Failed to init ASN1: 0x%x\n",Asn1Err));
                goto Cleanup;
        }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTermAsn
//
//  Synopsis:   terminates an ASN world
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
        {
                ASN1_CloseEncoder(pEnc);
        }
        else if (pDec != NULL)
        {
                ASN1_CloseDecoder(pDec);
        }

        //KRB5_Module_Cleanup();
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPackData
//
//  Synopsis:   Packs a datatype using ASN.1 encoding
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  Data - The message to marshall/pack.
//              PduValue - The PDU for the message type
//              DataSize - receives the size of the marshalled message in
//                      bytes.
//              MarshalledData - receives a pointer to the marshalled
//                      message buffer.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    int Result = 0;
    PUCHAR Buffer = NULL;
    ASN1encoding_t pEnc = NULL;
        ASN1error_e Asn1Err;

    KerbErr = KerbInitAsn(
                &pEnc,          // we are encoding
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Encode the data type.
    //

    D_DebugLog((DEB_TRACE,"encoding pdu #%d\n",PduValue));
    Asn1Err = ASN1_Encode(
                pEnc,
                Data,
                PduValue,
                ASN1ENCODE_ALLOCATEBUFFER,
                NULL,                       // pbBuf
                0                           // cbBufSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        DebugLog((DEB_ERROR,"Failed to encode data: %d\n",Asn1Err));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    else
    {
        //
        // when the oss compiler was used the allocation routines were configurable.
        // therefore, the encoded data could just be free'd using our
        // deallocator.  in the new model we cannot configure the allocation routines
        // for encoding.

        // so we do not have to go and change every place where a free
        // of an encoded buffer is done, use our allocator to allocate a new buffer,
        // then copy the encoded data to it, and free the buffer that was allocated by
        // the encoding engine.  THIS SHOULD BE CHANGED FOR BETTER PERFORMANCE
        //

        *MarshalledData = (PUCHAR) MIDL_user_allocate(pEnc->len);
        if (*MarshalledData == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            *DataSize = 0;
        }
        else
        {
            RtlCopyMemory(*MarshalledData, pEnc->buf, pEnc->len);
            *DataSize = pEnc->len;

        }

        ASN1_FreeEncoded(pEnc, pEnc->buf);
    }

Cleanup:

    KerbTermAsn(pEnc, NULL);

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackData
//
//  Synopsis:   Unpacks an message from the ASN.1 encoding
//
//  Effects:
//
//  Arguments:  Data - Buffer containing the reply message.
//              DataSize - Size of the reply message in bytes
//              Reply - receives a KERB_ENCRYPTED_DATA structure allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    int Result;
    ULONG OldPduValue;
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
        ASN1error_e Asn1Err;

    if ((DataSize == 0) || (Data == NULL))
    {
        DebugLog((DEB_ERROR,"Trying to unpack NULL data\n"));
        return(KRB_ERR_GENERIC);
    }


    KerbErr = KerbInitAsn(
                NULL,
                &pDec           // we are decoding
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        return(KerbErr);
    }

    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                pDec,
                DecodedData,
                PduValue,
                ASN1DECODE_SETBUFFER,
                (BYTE *) Data,
                DataSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {

        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            D_DebugLog((DEB_TRACE,"More input required to decode data %d.\n",PduValue));
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            if (ASN1_ERR_BADTAG != Asn1Err)
            {
                DebugLog((DEB_ERROR,"Failed to decode data: %d\n", Asn1Err ));
            }
            KerbErr = KRB_ERR_GENERIC;
        }
        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

    return(KerbErr);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeData
//
//  Synopsis:   Frees a structure unpacked by the ASN1 decoder
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    )
{
    ASN1decoding_t pDec = NULL;


    if (ARGUMENT_PRESENT(Data))
    {
        KERBERR KerbErr;
        KerbErr = KerbInitAsn(
                    NULL,
                    &pDec       // this is a decoded structure
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            ASN1_FreeDecoded(pDec, Data, PduValue);

            KerbTermAsn(NULL, pDec);
        }
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketExtensions
//
//  Synopsis:   Frees a host address  allocated with KerbDuplicateTicketExtensions
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeTicketExtensions(
    IN PKERB_TICKET_EXTENSIONS Extensions
    )
{
    PKERB_TICKET_EXTENSIONS Elem,NextElem;

    Elem = Extensions;
    while (Elem != NULL)
    {
        if (Elem->value.te_data.value != NULL)
        {
            MIDL_user_free(Elem->value.te_data.value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicketExtensions
//
//  Synopsis:   duplicates the ticket extensions field from a ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbDuplicateTicketExtensions(
    OUT PKERB_TICKET_EXTENSIONS * Dest,
    IN PKERB_TICKET_EXTENSIONS Source
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_TICKET_EXTENSIONS  SourceElem;
    PKERB_TICKET_EXTENSIONS DestElem;
    PKERB_TICKET_EXTENSIONS * NextElem;

    *Dest = NULL;



    SourceElem = Source;
    NextElem = Dest;

    while (SourceElem != NULL)
    {
        DestElem = (PKERB_TICKET_EXTENSIONS) MIDL_user_allocate(sizeof(KERB_TICKET_EXTENSIONS));
        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        *DestElem = *SourceElem;
        DestElem->value.te_data.value = (PUCHAR) MIDL_user_allocate(SourceElem->value.te_data.length);
        if (DestElem->value.te_data.value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        RtlCopyMemory(
            DestElem->value.te_data.value,
            SourceElem->value.te_data.value,
            SourceElem->value.te_data.length
        );
        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KerbFreeTicketExtensions(*Dest);
        *Dest = NULL;
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicket
//
//  Synopsis:   Duplicates a ticket so the original may be freed
//
//  Effects:
//
//  Arguments:  Dest - Destination, receives duplicate
//              Source - Source ticket
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET Dest,
    IN PKERB_TICKET Source
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    RtlZeroMemory(
        Dest,
        sizeof(KERB_TICKET)
        );

    Dest->ticket_version = Source->ticket_version;
    KerbErr = KerbDuplicatePrincipalName(
                &Dest->server_name,
                &Source->server_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateRealm(
                &Dest->realm,
                Source->realm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateTicketExtensions(
                &Dest->ticket_extensions,
                Source->ticket_extensions
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Dest->encrypted_part = Source->encrypted_part;
    Dest->encrypted_part.cipher_text.value = (PUCHAR) MIDL_user_allocate(Dest->encrypted_part.cipher_text.length);
    if (Dest->encrypted_part.cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlCopyMemory(
        Dest->encrypted_part.cipher_text.value,
        Source->encrypted_part.cipher_text.value,
        Dest->encrypted_part.cipher_text.length
        );

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeDuplicatedTicket(Dest);
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDuplicatedTicket
//
//  Synopsis:   Frees ticket duplicated with KerbDuplicateTicket
//
//  Effects:    frees memory
//
//  Arguments:  Ticket - ticket to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    )
{
    KerbFreePrincipalName(
        &Ticket->server_name
        );
    KerbFreeRealm(
        &Ticket->realm
        );
    if (Ticket->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Ticket->encrypted_part.cipher_text.value);
    }
    KerbFreeTicketExtensions(
        Ticket->ticket_extensions
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildErrorMessageEx
//
//  Synopsis:   Builds an error message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    marshalled error message, to be freed with MIDL_user_free
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR* ErrorMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_ERROR Error;
    KERB_TYPED_DATA Data = {0};
    TimeStamp TimeNow;

    *ErrorMessageSize = 0;
    *ErrorMessage = NULL;

    GetSystemTimeAsFileTime(
        (PFILETIME) &TimeNow
        );

    RtlZeroMemory(
        &Error,
        sizeof(KERB_ERROR)
        );

    DsysAssert(ErrorCode != KDC_ERR_MORE_DATA);

    Error.version = KERBEROS_VERSION;
    Error.message_type = KRB_ERROR;

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &Error.server_time,
        &Error.server_usec,
        &TimeNow
        );

    Error.error_code = ErrorCode;

    //
    // Ignore errors because this is already an error return
    //

    KerbConvertUnicodeStringToRealm(
        &Error.realm,
        ServerRealm
        );

    if (ARGUMENT_PRESENT(ClientRealm) && (ClientRealm->Buffer != NULL))
    {
        KerbConvertUnicodeStringToRealm(
            &Error.client_realm,
            ClientRealm
            );

        Error.bit_mask |= client_realm_present;
    }

    KerbConvertKdcNameToPrincipalName(
        &Error.server_name,
        ServerName
        );

    //
    // Small problem here.  We may have preauth data that we want
    // to return to the client, instead of extended errors.  To
    // avoid this, we just make sure that we only return extended
    // errors if no ErrorData previously set.
    //

    if (ARGUMENT_PRESENT(ErrorData))
    {
        Error.error_data.length = (int) ErrorDataSize;
        Error.error_data.value = ErrorData;
        Error.bit_mask |= error_data_present;
    }
    else if (ARGUMENT_PRESENT(pExtendedError) && !EXT_ERROR_SUCCESS((*pExtendedError)))
    {
        Data.data_type = TD_EXTENDED_ERROR;

        KerbErr = KerbPackData(
            pExtendedError,
            KERB_EXT_ERROR_PDU,
            &Data.data_value.length,
            &Data.data_value.value
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN, "KerbBuildErrorMessageEx failed To pack extended error %#x!\n", KerbErr));
            goto Cleanup;
        }

        Error.bit_mask |= error_data_present;

        KerbErr = TypedDataListPushFront(
            NULL,
            &Data,
            &Error.error_data.length,
            &Error.error_data.value
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN, "KerbBuildErrorMessageEx failed To pack typed data %#x!\n", KerbErr));
            goto Cleanup;
        }
    }

    KerbErr = KerbPackData(
        &Error,
        KERB_ERROR_PDU,
        ErrorMessageSize,
        ErrorMessage
        );

Cleanup:

    KerbFreeRealm(
        &Error.realm
        );

    KerbFreeRealm(
        &Error.client_realm
        );

    KerbFreePrincipalName(
        &Error.server_name
        );

    if (Data.data_value.value && Data.data_value.length)
    {
        MIDL_user_free(Data.data_value.value);
    }

    if ((ErrorData != Error.error_data.value)
        && Error.error_data.value
        && Error.error_data.length)
    {
        MIDL_user_free(Error.error_data.value);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildExtendedError
//
//  Synopsis:   Packs the extended error data structure into a
//              KERB_ERROR_METHOD_DATA structure for return to
//              client
//
//  Effects:
//
//  Arguments:  pExtendedError, pointer to extended error
//
//  Requires:
//
//  Returns:    KERBERR to indicate successful packing
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildExtendedError(
   IN PKERB_EXT_ERROR  pExtendedError,
   OUT PULONG          ExtErrorSize,
   OUT PBYTE*          ExtErrorData
   )
{
    KERB_ERROR_METHOD_DATA ErrorMethodData;
    KERBERR KerbErr;

    ErrorMethodData.data_type = TD_EXTENDED_ERROR;
    ErrorMethodData.bit_mask |= data_value_present;
    ErrorMethodData.data_value.value = (PBYTE) pExtendedError;
    ErrorMethodData.data_value.length = sizeof(KERB_EXT_ERROR);

    KerbErr = KerbPackData(
        &ErrorMethodData,
        KERB_EXT_ERROR_PDU,
        ExtErrorSize,
        ExtErrorData
        );

    return (KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKeyFromList
//
//  Synopsis:   Gets the key of the appropriate encryption type off the list
//
//  Effects:
//
//  Arguments:  Passwords - list of keys
//              EncryptionType - Encryption type to use
//
//  Requires:
//
//  Returns:    The found key, or NULL if one wasn't found
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PKERB_ENCRYPTION_KEY
KerbGetKeyFromList(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords))
    {
        return(NULL);
    }

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            return(&Passwords->Credentials[Index].Key);
        }
    }
    return(NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonCryptSystem
//
//  Synopsis:   Finds a common crypt system including availablity
//              of passwords.
//
//  Effects:
//
//  Arguments:  CryptList - List of client's crypto systems
//              Passwords - List of passwords
//              MorePassword - Optionally another list of passwords to consider
//              CommonCryptSystem - Receives common crypo system ID
//              Key - Receives key for common crypt system
//
//  Requires:
//
//  Returns:    KDC_ERR_ETYPE_NOTSUPP if no common system can be found
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbFindCommonCryptSystem(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN OPTIONAL PKERB_STORED_CREDENTIAL MorePasswords,
    OUT PULONG CommonCryptSystem,
    OUT PKERB_ENCRYPTION_KEY * Key
    )
{
    ULONG PasswordTypes[KERB_MAX_CRYPTO_SYSTEMS] = {0};

    PULONG pCryptoSystems = NULL;
    ULONG CryptoSystems[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG PasswordCount;
    ULONG CryptoCount;
    ULONG Index;
    PKERB_CRYPT_LIST NextEType;
    ULONG Index2;
    ULONG KeyCount;
    KERBERR KerbErr = KDC_ERR_ETYPE_NOTSUPP;


    if ((Passwords == NULL ) || (CryptList == NULL))
    {
        DebugLog((DEB_ERROR, "Null password or crypt list passed to KerbFindCommonCryptSystem\n"));
        return(KDC_ERR_ETYPE_NOTSUPP);
    }
    PasswordCount = Passwords->CredentialCount;


    if (PasswordCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        D_DebugLog((DEB_ERROR, "Got more than 20 crypto systems in password list\n"));
        DsysAssert(PasswordCount < KERB_MAX_CRYPTO_SYSTEMS);
        return(KDC_ERR_ETYPE_NOTSUPP);
    }


    KeyCount = 0;
    for (Index = 0; Index < PasswordCount ; Index++ )
    {

        if (ARGUMENT_PRESENT(MorePasswords))
        {
            for (Index2 = 0; Index2 < MorePasswords->CredentialCount; Index2++ )
            {
                if (Passwords->Credentials[Index].Key.keytype == MorePasswords->Credentials[Index2].Key.keytype)
                {
                    PasswordTypes[KeyCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
                    break;
                }
            }
        }
        else
        {
            PasswordTypes[KeyCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
        }
    }

    CryptoCount = 0;
    NextEType = CryptList;


    while (NextEType != NULL)
    {
        NextEType = NextEType->next;
        CryptoCount++;

        // restrict to 100 crypt systems, even on a slowbuffer.
        if (CryptoCount > KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF)
        {
            return(KDC_ERR_ETYPE_NOTSUPP);
        }
    }


    if (CryptoCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        pCryptoSystems = (PULONG) MIDL_user_allocate(CryptoCount * sizeof(ULONG));
        if (NULL == pCryptoSystems)
        {
            return ( KRB_ERR_GENERIC );
        }
    }
    else // fast buff
    {
        pCryptoSystems = CryptoSystems;
    }


    // populate values
    NextEType = CryptList;
    Index = 0;

    while (NextEType != NULL)
    {
        pCryptoSystems[Index] = NextEType->value;
        NextEType = NextEType->next;
        Index++;
    }

    DsysAssert(Index == CryptoCount);

    if (!NT_SUCCESS(CDFindCommonCSystemWithKey(
            CryptoCount,
            pCryptoSystems,
            PasswordCount,
            PasswordTypes,
            CommonCryptSystem
            )))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Missing common crypt system\n", KLIN(FILENO, __LINE__)));
        goto cleanup;
    }

    //
    // Now find the key to return.
    //

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) *CommonCryptSystem)
        {
            *Key = &Passwords->Credentials[Index].Key;
            KerbErr = KDC_ERR_NONE;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Couldn't find password type after finding common csystem!\n",
                  KLIN(FILENO, __LINE__)));
    }


cleanup:


    if ((pCryptoSystems != NULL) &&
        (pCryptoSystems != CryptoSystems))
    {
        MIDL_user_free(pCryptoSystems);
    }


    return (KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKerbError
//
//  Synopsis:   Maps a kerb error to an NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    NTSTATUS Status;
    switch(KerbError) {
    case KDC_ERR_NONE:
        Status = STATUS_SUCCESS;
        break;
    case KDC_ERR_CLIENT_REVOKED:
        Status = STATUS_ACCOUNT_DISABLED;
        break;
    case KDC_ERR_KEY_EXPIRED:
        Status = STATUS_PASSWORD_EXPIRED;
        break;
    case KRB_ERR_GENERIC:
        Status = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case KRB_AP_ERR_SKEW:
    case KRB_AP_ERR_TKT_NYV:
    // Note this was added because of the following scenario:
    // Let's say the dc and the client have the correct time. And the
    // server's time is off. We aren't going to get rid of the ticket for the
    // server on the client because it hasn't expired yet. But, the server
    // thinks it has. If event logging was turned on, then admins could look
    // at the server's event log and potentially deduce that the server's
    // time is off relative to the dc.
    case KRB_AP_ERR_TKT_EXPIRED:
        Status = STATUS_TIME_DIFFERENCE_AT_DC;
        break;
    case KDC_ERR_POLICY:
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;
    case KDC_ERR_C_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_S_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        break;
    case KRB_AP_ERR_MODIFIED:
    case KDC_ERR_PREAUTH_FAILED:
        Status = STATUS_WRONG_PASSWORD;
        break;
    case KRB_ERR_RESPONSE_TOO_BIG:
        Status = STATUS_INVALID_BUFFER_SIZE;
        break;
    case KDC_ERR_PADATA_TYPE_NOSUPP:
        Status = STATUS_NOT_SUPPORTED;
        break;
    case KRB_AP_ERR_NOT_US:
        Status = SEC_E_WRONG_PRINCIPAL;
        break;

    case KDC_ERR_SVC_UNAVAILABLE:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_WRONG_REALM:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_CANT_VERIFY_CERTIFICATE:
        Status = TRUST_E_SYSTEM_ERROR;
        break;
    case KDC_ERR_INVALID_CERTIFICATE:
        Status = STATUS_INVALID_PARAMETER;
        break;
    case KDC_ERR_REVOKED_CERTIFICATE:
        Status = CRYPT_E_REVOKED;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNKNOWN:
        Status = CRYPT_E_NO_REVOCATION_CHECK;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNAVAILABLE:
        Status = CRYPT_E_REVOCATION_OFFLINE;
        break;
    case KDC_ERR_CLIENT_NAME_MISMATCH:
    case KERB_PKINIT_CLIENT_NAME_MISMATCH:
    case KDC_ERR_KDC_NAME_MISMATCH:
        Status = STATUS_PKINIT_NAME_MISMATCH;
        break;
    case KDC_ERR_PATH_NOT_ACCEPTED:
        Status = STATUS_TRUST_FAILURE;
        break;
    case KDC_ERR_ETYPE_NOTSUPP:
        Status = STATUS_KDC_UNKNOWN_ETYPE;
        break;
    case KDC_ERR_MUST_USE_USER2USER:
    case KRB_AP_ERR_USER_TO_USER_REQUIRED:
        Status = STATUS_USER2USER_REQUIRED;
        break;
    case KRB_AP_ERR_NOKEY:
        Status = STATUS_NO_KERB_KEY;
        break;
    default:
        Status = STATUS_LOGON_FAILURE;
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID allocated with MIDL_user_allocate.
//
//  Effects:
//
//  Arguments:  DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Sid - Returns a pointer to a buffer allocated from
//              MIDL_user_allocate containing the resultant Sid.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = MIDL_user_allocate( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        MIDL_user_free( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCertificateList
//
//  Synopsis:   Frees a list of certificates created by KerbCreateCertificateList
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    )
{
    PKERB_CERTIFICATE_LIST Last,Next;

    Last = NULL;
    Next = Certificates;
    while (Next != NULL)
    {
        Last = Next;
        Next = Next->next;
        if (Last->value.cert_data.value != NULL)
        {
            MIDL_user_free(Last->value.cert_data.value);
        }
        MIDL_user_free(Last);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCertificateList
//
//  Synopsis:   Creates a list of certificates from a cert context
//
//  Effects:
//
//  Arguments:  Certficates - receives list of certificates.
//              CertContext - Context containing certificates
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_CERTIFICATE_LIST ListEntry = NULL;

    if (!ARGUMENT_PRESENT(CertContext))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    //
    // Croft up a bogus certificate entry
    //

    ListEntry = (PKERB_CERTIFICATE_LIST) MIDL_user_allocate(sizeof(KERB_CERTIFICATE_LIST));
    if (ListEntry == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ListEntry->next = NULL;
    ListEntry->value.cert_type = KERB_CERTIFICATE_TYPE_X509;
    ListEntry->value.cert_data.length = CertContext->cbCertEncoded;
    ListEntry->value.cert_data.value = (PUCHAR) MIDL_user_allocate(ListEntry->value.cert_data.length);
    if (ListEntry->value.cert_data.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlCopyMemory(
        ListEntry->value.cert_data.value,
        CertContext->pbCertEncoded,
        CertContext->cbCertEncoded
        );
    *Certificates = ListEntry;
    ListEntry = NULL;

Cleanup:
    KerbFreeCertificateList(ListEntry);
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertFlagsToUlong
//
//  Synopsis:   Converts a bit-stream flags field into a ULONG
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbConvertFlagsToUlong(
    IN PVOID Flags
    )
{
    ULONG Output = 0;
    PUCHAR OutputPointer = &((PUCHAR) &Output)[3];
    ULONG Index = 0;
    PKERB_TICKET_FLAGS InternalFlags = (PKERB_TICKET_FLAGS) Flags;
    ULONG InternalLength;

    if (InternalFlags->length > 32)
    {
        InternalLength = 32;
    }
    else
    {
        InternalLength = (ULONG) InternalFlags->length;
    }

    while (InternalLength > 7)
    {
        *OutputPointer = InternalFlags->value[Index++];
        OutputPointer--;
        InternalLength -= 8;
    }

    //
    // Copy the remaining bits, masking off what should be zero
    //

    if (InternalLength != 0)
    {
        *OutputPointer = InternalFlags->value[Index] & ~((1 << (8-InternalLength)) - 1);
    }


    return(Output);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUlongToFlagUlong
//
//  Synopsis:   Converts the byte order of a ULONG into that used by flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return(ReturnFlag);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareObjectIds
//
//  Synopsis:   Compares two object IDs for equality
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    )
{
    while (Object1 != NULL)
    {

        if (Object2 == NULL)
        {
            return(FALSE);
        }

        if (Object1->value != Object2->value)
        {
            return(FALSE);
        }
        Object1 = Object1->next;
        Object2 = Object2->next;
    }

    if (Object2 != NULL)
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetClientNetbiosAddress
//
//  Synopsis:   Gets the client's netbios address from the list of
//              addresses it sends.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES TempAddress = Addresses;
    STRING TempString;
    KERBERR KerbErr;

    RtlInitUnicodeString(
        ClientNetbiosAddress,
        NULL
        );

    while (TempAddress != NULL)
    {
        //
        // Check for netbios
        //

        if (TempAddress->value.address_type == KERB_ADDRTYPE_NETBIOS)
        {
            //
            // Copy out the string
            //

            TempString.Buffer = (PCHAR) TempAddress->value.address.value;
            TempString.Length = TempString.MaximumLength = (USHORT) TempAddress->value.address.length;

            KerbErr = KerbStringToUnicodeString(
                        ClientNetbiosAddress,
                        &TempString
                        );
            if (KERB_SUCCESS(KerbErr))
            {
                //
                // Strip trailing spaces
                //

                if (ClientNetbiosAddress->Length >= sizeof(WCHAR))
                {
                    while ((ClientNetbiosAddress->Length > 0) &&
                           (ClientNetbiosAddress->Buffer[(ClientNetbiosAddress->Length / sizeof(WCHAR))-1] == L' '))
                    {
                        ClientNetbiosAddress->Length -= sizeof(WCHAR);
                    }
                    return(KDC_ERR_NONE);
                }
            }
            else
            {
                return(KerbErr);
            }

        }

        TempAddress = TempAddress->next;
    }

    //
    // It is o.k. to not have a netbios name
    //

    return(KDC_ERR_NONE);
}
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPacFromAuthData
//
//  Synopsis:   Gets the PAC from the auth data list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetPacFromAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT PKERB_AUTHORIZATION_DATA * Pac
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA RelevantAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;

    *ReturnIfRelevantData = NULL;
    *Pac = NULL;



    //
    // Look for the if-relevant data
    //

    RelevantAuthData = KerbFindAuthDataEntry(
                        KERB_AUTH_DATA_IF_RELEVANT,
                        AuthData
                        );
    if (RelevantAuthData != NULL)
    {
        //
        // Unpack it
        //

        KerbErr = KerbUnpackData(
                    RelevantAuthData->value.auth_data.value,
                    RelevantAuthData->value.auth_data.length,
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    (PVOID *) &IfRelevantData
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            //
            // Look for the PAC in the if-relevant data
            //

            PacAuthData = KerbFindAuthDataEntry(
                            KERB_AUTH_DATA_PAC,
                            *IfRelevantData
                            );
        }
        else
        {
            //
            // We don't mind if we couldn't unpack it.
            // Tickets do not always have PAC information.
            //

            KerbErr = KDC_ERR_NONE;
        }


    }

    //
    // If we didn't find it in the if-relevant data, look outside
    //

    if (PacAuthData == NULL)
    {
        PacAuthData = KerbFindAuthDataEntry(
                        KERB_AUTH_DATA_PAC,
                        AuthData
                        );

    }

    //
    // Copy the PAC to return it
    //

    if (PacAuthData != NULL)
    {
        *Pac = PacAuthData;
    }

    *ReturnIfRelevantData = IfRelevantData;
    IfRelevantData = NULL;


    return(KerbErr);
}


#if DBG
#define KERB_DEBUG_WARN_LEVEL   0x0002
//+-------------------------------------------------------------------------
//
//  Function:   DebugDisplayTime
//
//  Synopsis:   Displays a FILETIME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN FILETIME *pFileTime
    )
{
    CHAR pszTime[256];
    SYSTEMTIME SystemTime;

    if (DebugLevel & KERB_DEBUG_WARN_LEVEL)
    {
        FileTimeToSystemTime(pFileTime, &SystemTime);

        DebugLog((DEB_ERROR," %02d:%02d:%02d - %02d %02d %04d\n",
                 SystemTime.wHour,SystemTime.wMinute,SystemTime.wSecond,
                 SystemTime.wDay,SystemTime.wMonth,SystemTime.wYear));
    }
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\idl\pacimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        pacimp.h
//
// Contents:    imports for pac.idl
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <lsass.h>
#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntmsv1_0.h>
#include <logonmsv.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\utils.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        utils.cxx
//
//  Contents:   utilities
//
//  History:    LZhu   Feb 1, 2002 Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include<kerb.hxx>
#include<kerbp.h>
#endif // WIN32_CHICAGO

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>
#include <wincrypt.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include <tostring.hxx>
#include <kerberos.h>
#include "debug.h"
#include <fileno.h>
#include <pac.hxx>
#include <utils.hxx>

#define FILENO  FILENO_COMMON_UTILS

//+-------------------------------------------------------------------------
//
//  Function: KerbUnpackErrorData
//
//  Synopsis: This routine unpacks error information from a KERB_ERROR message
//
//  Effects:
//
//  Arguments: Unpacked error data.  Returns extended error to
//             be freed using KerbFreeData with KERB_EXT_ERROR_PDU
//
//  Requires:
//
//  Returns:  KERB_ERROR
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbUnpackErrorData(
   IN OUT PKERB_ERROR ErrorMessage,
   IN OUT PKERB_EXT_ERROR * ExtendedError
   )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    TYPED_DATA_Element* TypedDataElem = NULL;


    TYPED_DATA_Element* ErrorData = NULL;
    KERB_ERROR_METHOD_DATA* ErrorMethodData = NULL;

    UCHAR* ExtErrTemp = NULL; // need to free it

    UCHAR* ExtErr = NULL;
    ULONG ExtErrSize = 0;

    *ExtendedError = NULL;

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
        KerbErr = (KRB_ERR_GENERIC);
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
        ErrorMessage->error_data.value,
        ErrorMessage->error_data.length,
        TYPED_DATA_PDU,
        (VOID**) &ErrorData
        );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // we do not use error method data from kdc any more, but need to watch
        // for those slipped into clients with ServicePacks
        //

        DebugLog((DEB_WARN, "KerbUnpackData failed to unpack typed data, trying error method data\n"));

        KerbErr = KerbUnpackData(
            ErrorMessage->error_data.value,
            ErrorMessage->error_data.length,
            KERB_ERROR_METHOD_DATA_PDU,
            (VOID**) &ErrorMethodData
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if ((ErrorMethodData->bit_mask & data_value_present)
            && (KERB_ERR_TYPE_EXTENDED == ErrorMethodData->data_type)
            && ErrorMethodData->data_value.length >= sizeof(KERB_EXT_ERROR))
        {
            //
            // pack the raw data
            //

            KerbErr = KerbPackData(
                ErrorMethodData->data_value.value,
                KERB_EXT_ERROR_PDU,
                &ExtErrSize,
                &ExtErrTemp
                );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            ExtErr = ExtErrTemp;
        }
    }
    else
    {
        TypedDataElem = TypedDataListFind(ErrorData, TD_EXTENDED_ERROR);
        if (TypedDataElem)
        {
            ExtErrSize = TypedDataElem->value.data_value.length;
            ExtErr = TypedDataElem->value.data_value.value;
        }

        if ((KDC_ERR_S_PRINCIPAL_UNKNOWN == ErrorMessage->error_code)
            && (NULL != TypedDataListFind(ErrorData, TD_MUST_USE_USER2USER)))
        {
            DebugLog((DEB_WARN, "KerbUnpackData remap KDC_ERR_S_PRINCIPAL_UNKNOWN to KDC_ERR_MUST_USE_USER2USER\n"));

            ErrorMessage->error_code = KDC_ERR_MUST_USE_USER2USER;
        }
    }

    if (ExtErr && ExtErrSize)
    {
        KerbErr = KerbUnpackData(
            ExtErr,
            ExtErrSize,
            KERB_EXT_ERROR_PDU,
            (VOID**)ExtendedError
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (*ExtendedError)
    {
        DebugLog((DEB_ERROR, "KerbUnpackErrorData received failure from kdc %#x KLIN(%#x) NTSTATUS(%#x)\n",
            ErrorMessage->error_code, (*ExtendedError)->klininfo, (*ExtendedError)->status));
    }

Cleanup:

    if (NULL != ErrorMethodData)
    {
        KerbFreeData(KERB_ERROR_METHOD_DATA_PDU, ErrorMethodData);
    }

    if (NULL != ErrorData)
    {
        KerbFreeData(TYPED_DATA_PDU, ErrorData);
    }

    if (NULL != ExtErrTemp)
    {
        MIDL_user_free(ExtErrTemp);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   TypedDataListFind
//
//  Synopsis:   find a kerb typed data from a type data list
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TYPED_DATA_Element that is found, NULL otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

TYPED_DATA_Element*
TypedDataListFind(
    IN OPTIONAL TYPED_DATA_Element* InputDataList,
    IN LONG Type
    )
{
    for (TYPED_DATA_Element* p = InputDataList; p != NULL; p = p->next)
    {
        if (p->value.data_type == Type)
        {
            return p;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   TypedDataListPushFront
//
//  Synopsis:   Insert a kerb typed data to a type data list
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    KERBERR
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
TypedDataListPushFront(
    IN OPTIONAL TYPED_DATA_Element* InputDataList,
    IN KERB_TYPED_DATA* Data,
    OUT ULONG* OutputDataListSize,
    OUT UCHAR** OutputDataList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    TYPED_DATA_Element TypedDataElem = {0};
    TYPED_DATA_Element* TypedDataList = &TypedDataElem;

    TypedDataElem.value = *Data;
    TypedDataElem.next = InputDataList;

    KerbErr = KerbPackData(
        &TypedDataList,
        TYPED_DATA_PDU,
        OutputDataListSize,
        OutputDataList
        );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KdcGetTicket faild to pack error data as typed data\n", KLIN(FILENO, __LINE__)));
        goto Cleanup;
    }

Cleanup:

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\exts\kerbexts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
}
#include <stdio.h>

#include <ntsdexts.h>

#include <dsysdbg.h>
#define SECURITY_PACKAGE
#define SECURITY_WIN32
#include <security.h>
#include <kerberos.h>
#include <secint.h>
#include <cryptdll.h>

#include <..\client2\kerb.hxx>
#include <..\client2\kerbp.h>

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;

#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, x)
#define FreeHeap(x) RtlFreeHeap(RtlProcessHeap(), 0, x)

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

char * ContextState[] = {
    "IdleState",
    "TgtRequestSentState",
    "TgtReplySentState",
    "ApRequestSentState",
    "ApReplySentState",
    "AuthenticatedState",
    "ErrorMessageSentState",
    "InvalidState"};

void PrintContextAttributes( ULONG Attributes)
{
    DebuggerOut("  ContextAttributes\t0x%lx:", Attributes);
    if (Attributes & KERB_CONTEXT_MAPPED)
    {
        DebuggerOut(" KERB_CONTEXT_MAPPED");
    }
    if (Attributes & KERB_CONTEXT_OUTBOUND)
    {
        DebuggerOut(" KERB_CONTEXT_OUTBOUND");
    }
    if (Attributes & KERB_CONTEXT_INBOUND)
    {
        DebuggerOut(" KERB_CONTEXT_INBOUND");
    }
    if (Attributes & KERB_CONTEXT_USED_SUPPLIED_CREDS)
    {
        DebuggerOut(" KERB_CONTEXT_USED_SUPPLIED_CREDS");
    }
    if (Attributes & KERB_CONTEXT_USER_TO_USER)
    {
        DebuggerOut(" KERB_CONTEXT_USER_TO_USER");
    }
    if (Attributes & KERB_CONTEXT_REQ_SERVER_NAME)
    {
        DebuggerOut(" KERB_CONTEXT_REQ_SERVER_NAME");
    }
    if (Attributes & KERB_CONTEXT_REQ_SERVER_REALM)
    {
        DebuggerOut(" KERB_CONTEXT_REQ_SERVER_REALM");
    }
    if (Attributes & KERB_CONTEXT_IMPORTED)
    {
        DebuggerOut(" KERB_CONTEXT_IMPORTED");
    }
    if (Attributes & KERB_CONTEXT_EXPORTED)
    {
        DebuggerOut(" KERB_CONTEXT_EXPORTED");
    }
    DebuggerOut("\n");
}
void PrintContextFlags ( ULONG Flags)
{
    DebuggerOut("  ContextFlags for 0x%lx are:\n", Flags);
    if (Flags & 0x00000001)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_DELEGATE\n");
    }
    if (Flags & 0x00000002)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_MUTUAL_AUTH\n");
    }
    if (Flags & 0x00000004)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_REPLAY_DETECT\n");
    }
    if (Flags & 0x00000008)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_SEQUENCE_DETECT\n");
    }
    if (Flags & 0x00000010)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_CONFIDENTIALITY\n");
    }
    if (Flags & 0x00000020)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_USE_SESSION_KEY\n");
    }
    if (Flags & 0x00000040)
    {
        DebuggerOut("\tISC_REQ_PROMPT_FOR_CREDS or ISC_RET_USED_COLLECTED_CREDS\n");
    }
    if (Flags & 0x00000080)
    {
        DebuggerOut("\tISC_REQ_USE_SUPPLIED_CREDS or ISC_RET_USED_SUPPLIED_CREDS\n");
    }
    if (Flags & 0x00000100)
    {
        DebuggerOut("\tISC(ASC)_REQ_ALLOCATE_MEMORY or ISC(ASC)_RET_ALLOCATED_MEMORY\n");
    }
    if (Flags & 0x00000200)
    {
        DebuggerOut("\tISC(ASC)_REQ_USE_DCE_STYLE or ISC(ASC)_RET_USED_DCE_STYLE\n");
    }
    if (Flags & 0x00000400)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_DATAGRAM\n");
    }
    if (Flags & 0x00000800)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_CONNECTION\n");
    }
    if (Flags & 0x00001000)
    {
        DebuggerOut("\tISC(ASC)_REQ_CALL_LEVEL or ISC_RET_INTERMEDIATE_RETURN\n");
    }
    if (Flags & 0x00002000)
    {
        DebuggerOut("\tISC(ASC)_RET_CALL_LEVEL\n");
    }
    if (Flags & 0x00004000)
    {
        DebuggerOut("\tISC_REQ(RET)_EXTENDED_ERROR or ASC_RET_THIRD_LEG_FAILED\n");
    }
    if (Flags & 0x00008000)
    {
        DebuggerOut("\tISC_REQ(RET)_STREAM or ASC_REQ(RET)_EXTENDED_ERROR\n");
    }
    if (Flags & 0x00010000)
    {
        DebuggerOut("\tISC_REQ(RET)_INTEGRITY or ASC_REQ(RET)_STREAM\n");
    }
    if (Flags & 0x00020000)
    {
        DebuggerOut("\tISC_REQ(RET)_IDENTIFY or ASC_REQ(RET)_INTEGRITY\n");
    }
    if (Flags & 0x00040000)
    {
        DebuggerOut("\tISC_REQ(RET)_NULL_SESSION or ASC_REQ(RET)_LICENSING\n");
    }
    if (Flags & 0x00080000)
    {
        DebuggerOut("\tISC_REQ(RET)_MANUAL_CRED_VALIDATION or ASC_REQ(RET)_IDENTIFY\n");
    }
    if (Flags & 0x00100000)
    {
        DebuggerOut("\tISC_REQ(RET)_DELEGATE_IF_SAFE or ASC_REQ_ALLOW_NULL_SESSION or ASC_RET_NULL_SESSION\n");
    }
    if (Flags & 0x00200000)
    {
        DebuggerOut("\tASC_REQ(RET)_ALLOW_NON_USER_LOGONS\n");
    }
    if (Flags & 0x00400000)
    {
        DebuggerOut("\tASC_REQ(RET)_ALLOW_CONTEXT_REPLAY\n");
    }
}
SECURITY_STATUS
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    SIZE_T       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            DebuggerOut("  counts don't match\n");
            return(-1);
        }
        return(0);
    }
    DebuggerOut("  GetLastError from readMemory is %d\n", GetLastError());
    return(GetLastError());

}

SECURITY_STATUS
WriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    SIZE_T       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());
}

DWORD
GetDword(PVOID  pvMemory)
{
    DWORD   dwVal;
    SIZE_T   cbActual = sizeof(DWORD);

    if (ReadProcessMemory(hDbgProcess, pvMemory, &dwVal, sizeof(DWORD), &cbActual))
    {
        if (cbActual != sizeof(DWORD))
        {
            return((DWORD) -1);
        }
        return(dwVal);
    }
    return((DWORD) -1);
}

#define TIMEBUF_SZ  64
char *Months[]      = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
            "Aug", "Sep", "Oct", "Nov", "Dec" };
void CTimeStamp(PTimeStamp      ptsTime,
                LPSTR           pszTimeBuf)
{
    SYSTEMTIME      stTime;
    FILETIME        tLocal;
    SYSTEMTIME      stLocal;

    if (ptsTime->HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
    }
    else if (ptsTime->HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
    }
    FileTimeToLocalFileTime((LPFILETIME) ptsTime, &tLocal);
    FileTimeToSystemTime((LPFILETIME) ptsTime, &stTime);
    FileTimeToSystemTime(&tLocal, &stLocal);
    sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d:%02d.%03d, %s %02d, %d Local)", stTime.wHour,
        stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
        Months[stTime.wMonth], stTime.wDay, stTime.wYear,
        stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds, Months[stLocal.wMonth], stLocal.wDay, stLocal.wYear);
}

void ContextTimeStamp(PTimeStamp      ptsTime,
                      LPSTR           pszTimeBuf)
{
    // We set local times in sspi
    SYSTEMTIME      stTime;
    FILETIME        tutc;
    SYSTEMTIME      stLocal;
    TimeStamp       Time;

    if (ReadMemory( ptsTime, sizeof( TimeStamp), &Time))
    {
        DebuggerOut("  Could not read context\n");
        return;
    }
    if (Time.HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
    }
    else if (Time.HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
    }
    FileTimeToSystemTime((LPFILETIME) &Time, &stLocal);
    LocalFileTimeToFileTime((LPFILETIME) &Time, &tutc);
    FileTimeToSystemTime(&tutc, &stTime);
    sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d:%02d.%03d, %s %02d, %d Local)", stTime.wHour,
        stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
        Months[stTime.wMonth], stTime.wDay, stTime.wYear,
        stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds, Months[stLocal.wMonth], stLocal.wDay, stLocal.wYear);
}

void
MapString(PSECURITY_STRING  pClientString,
      PSECURITY_STRING  pLocalString)
{
    if (!pLocalString->Buffer)
    {
        pLocalString->Buffer = (PWSTR) AllocHeap(pClientString->Length + 2);
        if (pLocalString->Buffer == NULL)
        {
            return;
        }
        pLocalString->MaximumLength = pClientString->Length + 2;
    }

    RtlZeroMemory(pLocalString->Buffer, pLocalString->MaximumLength);

    if (!ReadMemory(pClientString->Buffer, pClientString->Length, pLocalString->Buffer))
    {
        pLocalString->Length = pClientString->Length;
    }
    else
    {
        DebuggerOut("\nWarning: could not read string @%x\n", pClientString->Buffer);
    }

}

void PrintSid(PVOID pvSid)
{
    SID Sid;
    PSID   pSid;
    UNICODE_STRING  ucsSid;

    DebuggerOut("  UserSid         \t0x%lx ", pvSid);
    if (pvSid)
    {
        if (ReadMemory(pvSid, sizeof(SID), &Sid))
        {
            DebuggerOut("Could not read from %x\n", pvSid);
        }

        pSid = AllocHeap(RtlLengthRequiredSid(Sid.SubAuthorityCount));
        if (pSid == NULL)
        {
            return;
        }
        if (ReadMemory(pvSid, RtlLengthRequiredSid(Sid.SubAuthorityCount), pSid))
        {
            DebuggerOut("Could not read from %x\n", pvSid);
        }

        RtlConvertSidToUnicodeString(&ucsSid, pSid, TRUE);
        DebuggerOut("  %wZ", &ucsSid);
        RtlFreeUnicodeString(&ucsSid);
        FreeHeap(pSid);
    }
    DebuggerOut("\n");
}

VOID
PrintEType(
    ULONG EType
)
{
    switch(EType)
    {
    case KERB_ETYPE_NULL:
    DebuggerOut("KERB_ETYPE_NULL\n"); break;
    case KERB_ETYPE_DES_CBC_CRC:
    DebuggerOut("KERB_ETYPE_DES_CBC_CRC\n"); break;
    case KERB_ETYPE_DES_CBC_MD4:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD4\n"); break;
    case KERB_ETYPE_DES_CBC_MD5:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD5\n"); break;
    case KERB_ETYPE_OLD_RC4_MD4:
    DebuggerOut("KERB_ETYPE_OLD_RC4_MD4\n"); break;
    case KERB_ETYPE_OLD_RC4_PLAIN:
    DebuggerOut("KERB_ETYPE_OLD_RC4_PLAIN\n"); break;
    case KERB_ETYPE_OLD_RC4_LM:
    DebuggerOut("KERB_ETYPE_OLD_RC4_LM\n"); break;
    case KERB_ETYPE_OLD_RC4_SHA:
    DebuggerOut("KERB_ETYPE_OLD_RC4_SHA\n"); break;
    case KERB_ETYPE_OLD_DES_PLAIN:
    DebuggerOut("KERB_ETYPE_OLD_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_MD4:
    DebuggerOut("KERB_ETYPE_RC4_MD4\n"); break;
    case KERB_ETYPE_RC4_PLAIN2:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN2\n"); break;
    case KERB_ETYPE_RC4_LM:
    DebuggerOut("KERB_ETYPE_RC4_LM\n"); break;
    case KERB_ETYPE_RC4_SHA:
    DebuggerOut("KERB_ETYPE_RC4_SHA\n"); break;
    case KERB_ETYPE_DES_PLAIN:
    DebuggerOut("KERB_ETYPE_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_PLAIN:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD:
    DebuggerOut("KERB_ETYPE_RC4_HMAC_OLD\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
    DebuggerOut("KERB_ETYPE_RC4_HMAC_OLD_EXP\n"); break;
    case KERB_ETYPE_RC4_PLAIN_EXP:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN_EXP\n"); break;
    case KERB_ETYPE_DSA_SIGN:
    DebuggerOut("KERB_ETYPE_DSA_SIGN\n"); break;
    case KERB_ETYPE_RSA_PRIV:
    DebuggerOut("KERB_ETYPE_RSA_PRIV\n"); break;
    case KERB_ETYPE_RSA_PUB:
    DebuggerOut("KERB_ETYPE_RSA_PUB\n"); break;
    case KERB_ETYPE_RSA_PUB_MD5:
    DebuggerOut("KERB_ETYPE_RSA_PUB_MD5\n"); break;
    case KERB_ETYPE_RSA_PUB_SHA1:
    DebuggerOut("KERB_ETYPE_RSA_PUB_SHA1\n"); break;
    case KERB_ETYPE_PKCS7_PUB:
    DebuggerOut("KERB_ETYPE_PKCS7_PUB\n"); break;
    case KERB_ETYPE_DES_CBC_MD5_NT:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD5_NT\n"); break;
default:
    DebuggerOut("Unknown EType: 0x%lx\n", EType); break;
    }
}
VOID
ShowKerbContext(
    IN PVOID pContext
    )
{
    KERB_CONTEXT Context;
    CHAR TimeBuf[80];
    SECURITY_STRING sLocal;
    sLocal.Buffer = NULL;

    if (ReadMemory( pContext, sizeof( KERB_CONTEXT), &Context ))
    {
        DebuggerOut("  Could not read context\n");
        return;
    }

    CTimeStamp( &Context.Lifetime, TimeBuf );
    DebuggerOut("  Lifetime       \t%s\n", TimeBuf );

    CTimeStamp( &Context.RenewTime, TimeBuf );
    DebuggerOut("  RenewTime       \t%s\n", TimeBuf );

    MapString( &Context.ClientName, &sLocal);
    DebuggerOut("  ClientName     \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Context.ClientRealm, &sLocal);
    DebuggerOut("  ClientRealm     \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  Process ID      \t0x%lx\n", Context.ClientProcess);
    DebuggerOut("  LogonId         \t0x%lx : 0x%lx\n", Context.LogonId.LowPart, Context.LogonId.HighPart );
    DebuggerOut("  TokenHandle     \t0x%lx\n", Context.TokenHandle );
    DebuggerOut("  CredentialHandle\t0x%lx\n", Context.CredentialHandle);
    DebuggerOut("  SessionKey type \t");
    PrintEType(Context.SessionKey.keytype);
    DebuggerOut("  SessionKey length \t0x%lx\n", Context.SessionKey.keyvalue.length);
    DebuggerOut("  Nonce           \t0x%lx\n", Context.Nonce);
    DebuggerOut("  ReceiveNonce    \t0x%lx\n", Context.ReceiveNonce);
    DebuggerOut("  ContextFlags    \t0x%lx\n", Context.ContextFlags);
    PrintContextAttributes(Context.ContextAttributes);
    DebuggerOut("  EncryptionType  \t");
    PrintEType(Context.EncryptionType);
    PrintSid(Context.UserSid);
    DebuggerOut("  ContextState    \t%s\n", ContextState[Context.ContextState]);
    DebuggerOut("  Retries         \t0x%lx\n", Context.Retries );
    DebuggerOut("  TicketKey type  \t");
    PrintEType(Context.TicketKey.keytype);
    DebuggerOut("  TicketKey length\t0x%lx\n", Context.TicketKey.keyvalue.length);
    DebuggerOut("  TicketCacheEntry\t0x%lx\n", Context.TicketCacheEntry);
}

VOID
DumpContext(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    ShowKerbContext( pContext );

}

void PrintLogonType(SECURITY_LOGON_TYPE LogonType)
{
    switch(LogonType)
    {
    case Interactive:
    DebuggerOut("Interactive\n"); break;
    case Network:
    DebuggerOut("Network\n"); break;
    case Batch:
    DebuggerOut("Batch\n"); break;
    case Service:
    DebuggerOut("Service\n"); break;
    case Proxy:
    DebuggerOut("Proxy\n"); break;
    case Unlock:
    DebuggerOut("Unlock\n"); break;
    default:
    DebuggerOut("Unknown Logon Type: 0x%lx\n", LogonType); break;
    }
}

VOID
ShowKerbTCacheEntry(PVOID pCache)
{
/*
typedef struct _KERB_TICKET_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    PKERB_INTERNAL_NAME ServiceName;
    PKERB_INTERNAL_NAME TargetName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    PKERB_INTERNAL_NAME ClientName;
    ULONG TicketFlags;
    ULONG CacheFlags;
    KERB_ENCRYPTION_KEY SessionKey;
    TimeStamp KeyExpirationTime;
    TimeStamp StartTime;
    TimeStamp EndTime;
    TimeStamp RenewUntil;
    KERB_TICKET Ticket;
    TimeStamp TimeSkew;
} KERB_TICKET_CACHE_ENTRY, *PKERB_TICKET_CACHE_ENTRY;
*/
    KERB_TICKET_CACHE_ENTRY Cache;
    CHAR TimeBuf[64];
    SECURITY_STRING sLocal;
    ULONG Temp;
    sLocal.Buffer = NULL;

    if (ReadMemory( pCache, sizeof( KERB_TICKET_CACHE_ENTRY), &Cache))
    {
        DebuggerOut("  Could not read ticket cache entry\n");
        return;
    }
    DebuggerOut("  ServiceName     \t0x%lx\n", Cache.ServiceName);
    DebuggerOut("  TargetName      \t0x%lx\n", Cache.TargetName);

    MapString( &Cache.DomainName, &sLocal);
    DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Cache.TargetDomainName, &sLocal);
    DebuggerOut("  TargetDomainName \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Cache.AltTargetDomainName, &sLocal);
    DebuggerOut("  AltTargetDomainName  \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  ClientName      \t0x%lx\n", Cache.ClientName);
    DebuggerOut("  TicketFlags     \t0x%lx\n", Cache.TicketFlags);
    DebuggerOut("  CacheFlags      \t0x%lx\n", Cache.CacheFlags);
    DebuggerOut("  EncryptionType  \t");
    PrintEType(Cache.SessionKey.keytype);
    CTimeStamp( &Cache.KeyExpirationTime, TimeBuf );
    DebuggerOut("  KeyExpirationTime \t%s\n", TimeBuf );
    CTimeStamp( &Cache.StartTime, TimeBuf );
    DebuggerOut("  StartTime       \t%s\n", TimeBuf );
    CTimeStamp( &Cache.EndTime, TimeBuf );
    DebuggerOut("  Endtime          \t%s\n", TimeBuf );
    CTimeStamp( &Cache.RenewUntil, TimeBuf );
    DebuggerOut("  RenewUntil       \t%s\n", TimeBuf );
}

VOID
ShowKerbLSession(
    IN PVOID pSession
    )
{
    KERB_LOGON_SESSION Session;
    CHAR TimeBuf[64];
    SECURITY_STRING sLocal;
    ULONG_PTR Temp;
    sLocal.Buffer = NULL;

    if (ReadMemory( pSession, sizeof( KERB_LOGON_SESSION), &Session))
    {
        DebuggerOut("  Could not read logon session\n");
        return;
    }
    //DebuggerOut("  Credential      \t0x%lx\n", Session.SspCredentials);
    DebuggerOut("  LogonId         \t0x%lx : 0x%lx\n", Session.LogonId.LowPart, Session.LogonId.HighPart );
    CTimeStamp( &Session.Lifetime, TimeBuf );
    DebuggerOut("  Lifetime       \t%s\n", TimeBuf );
    //PrintPCred(Session.PrimaryCredentials);

    MapString( &Session.PrimaryCredentials.UserName, &sLocal);
    DebuggerOut("  UserName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Session.PrimaryCredentials.DomainName, &sLocal);
    DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  Passwords        \t0x%lx\n", Session.PrimaryCredentials.Passwords);
    DebuggerOut("  OldPasswords     \t0x%lx\n", Session.PrimaryCredentials.OldPasswords);
    DebuggerOut("  PublicKeyCreds   \t0x%lx\n", Session.PrimaryCredentials.PublicKeyCreds);
    DebuggerOut("  LogonSessionFlags\t0x%lx\n", Session.LogonSessionFlags);

    // ServerTicketCache
    Temp =  (ULONG_PTR)pSession+ FIELD_OFFSET(KERB_LOGON_SESSION, PrimaryCredentials) + FIELD_OFFSET(KERB_PRIMARY_CREDENTIAL, ServerTicketCache);

    DebuggerOut("  ServerTicketCache \t0x%p\n", Temp);

    // AuthenticationTicketCache
    Temp =  (ULONG_PTR)pSession+ FIELD_OFFSET(KERB_LOGON_SESSION, PrimaryCredentials) + FIELD_OFFSET(KERB_PRIMARY_CREDENTIAL, AuthenticationTicketCache);

    DebuggerOut("  AuthenticationTicketCache \t0x%p\n", Temp );


}

VOID
DumpLSession(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pSession;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pSession = GetExpr( pszCommand );

    if ( pSession == NULL ) {

        return;
    }

    ShowKerbLSession( pSession);

}

VOID
DumpTCacheEntry(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pCache;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pCache = GetExpr( pszCommand );

    if ( pCache == NULL ) {

        return;
    }

    ShowKerbTCacheEntry( pCache);
}

/*
VOID
ShowDomainList(PVOID pDomain)
{
    PLIST_ENTRY DomainList = (PLIST_ENTRY) pDomain;
    SECURITY_STRING sLocal;
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;


    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        MapString( &Domain->DnsName, &sLocal);
        DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
        FreeHeap(sLocal.Buffer);
        sLocal.Buffer = NULL;

        if (Domain->ClosestRoute == NULL)
        {
            DebuggerOut("  No closest route\n");
        }
        else
        {
            MapString( Domain->ClosestRoute, &sLocal);
            DebuggerOut("  Closest Route      \t%ws\n", sLocal.Buffer);
            FreeHeap(sLocal.Buffer);
            sLocal.Buffer = NULL;
        }

        if (Domain->Parent == NULL)
        {
            DebuggerOut("  No parent\n");
        }
        else
        {
            MapString( &Domain->Parent->DnsName, &sLocal);
            DebuggerOut("  Parent       \t%ws\n", sLocal.Buffer);
            FreeHeap(sLocal.Buffer);
            sLocal.Buffer = NULL;
        }
    }
}

VOID
DumpReferralTree(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pDomain;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pDomain = GetExpr( pszCommand );

    if ( pDomain == NULL ) {

        return;
    }
    ShowDomainList(pDomain);
}
*/

VOID
DumpContextFlags(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    PrintContextFlags( (ULONG)((ULONG_PTR)pContext) );

}

VOID
DumpCTimeStamp(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;
    CHAR TimeBuf[100];

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    ContextTimeStamp( (PTimeStamp) pContext, TimeBuf );
    DebuggerOut("  TimeStamp  \t%s\n", TimeBuf );

}

void
Help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    DebuggerOut("Kerberos Exts Debug Help\n");
    DebuggerOut("   DumpContext  <addr>     \tDumps a Kerberos context\n");
    DebuggerOut("   DumpLSession <addr>     \tDumps a Kerberos logon session\n");
    DebuggerOut("   DumpTCacheEntry <addr>  \tDumps a Kerberos ticket cache entry\n");
    DebuggerOut("   DumpContextFlags <hex ulong>\tDumps an SSPI context flags\n");
    DebuggerOut("   DumpCTimeStamp <hex ulong>\tDumps a Context Expiry Time\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\idl\secimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        secimp.h
//
// Contents:    imports for security .idl files
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <security.h>
#include <kerbcred.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\exterr.h ===
//+-----------------------------------------------------------------------
//
// File:        exterr.h
//
// Contents:    Kerberos extended error structures and macros
//
// History:     23-Feb-2000    Todds   Created
//
//
//------------------------------------------------------------------------

#ifndef __EXTERR_H__
#define __EXTERR_H__

//
// This macro is universally used for extended errors
//
#define EXT_ERROR_SUCCESS(s)             (NT_SUCCESS(s.status))

//
// defines for flags member of KERB_EXT_ERROR structure
//
#define  EXT_ERROR_CLIENT_INFO      0x1   // this is an extended error for use by client

//
// is there a useful NTSTATUS embedded in returned error?
//
#define  EXT_CLIENT_INFO_PRESENT(p)    ((NULL != p) && (p->flags & EXT_ERROR_CLIENT_INFO) && !NT_SUCCESS(p->status))

#endif // __EXTERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//  Stolen from DS line number obfuscation macros
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for kerberos c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define KLIN(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to kerberos\utest\klin.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsvent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_CLIENT2   (0)                             // \client2
#define DIRNO_COMMON2   (1 << 8)                        // \common2
#define DIRNO_KERNEL    (2 << 8)                        // \kernel
#define DIRNO_RTL       (3 << 8)                        // \rtl
#define DIRNO_SERVER    (4 << 8)                        // \server

// client2 directory
#define FILENO_BNDCACHE         (DIRNO_CLIENT2 + 0)      // bndcache.cxx
#define FILENO_CREDAPI          (DIRNO_CLIENT2 + 1)      // credapi.cxx
#define FILENO_CREDMGR          (DIRNO_CLIENT2 + 2)      // credmgr.cxx
#define FILENO_CTXTAPI          (DIRNO_CLIENT2 + 3)      // ctxtapi.cxx
#define FILENO_CTXTMGR          (DIRNO_CLIENT2 + 4)      // ctxtmgr.cxx
#define FILENO_GSSUTIL          (DIRNO_CLIENT2 + 5)      // gssutil.cxx
#define FILENO_KERBEROS         (DIRNO_CLIENT2 + 6)      // kerberos.cxx
#define FILENO_KERBLIST         (DIRNO_CLIENT2 + 7)      // kerblist.cxx
#define FILENO_KERBPASS         (DIRNO_CLIENT2 + 8)      // kerbpass.cxx
#define FILENO_KERBTICK         (DIRNO_CLIENT2 + 9)      // kerbtick.cxx
#define FILENO_KERBUTIL         (DIRNO_CLIENT2 + 10)     // kerbutil.cxx
#define FILENO_KERBWOW          (DIRNO_CLIENT2 + 11)     // kerbwow.cxx
#define FILENO_KRBEVENT         (DIRNO_CLIENT2 + 12)     // krbevent.cxx
#define FILENO_KRBTOKEN         (DIRNO_CLIENT2 + 13)     // krbtoken.cxx
#define FILENO_LOGONAPI         (DIRNO_CLIENT2 + 14)     // logonapi.cxx
#define FILENO_MISCAPI          (DIRNO_CLIENT2 + 15)     // miscapi.cxx
#define FILENO_MITUTIL          (DIRNO_CLIENT2 + 16)     // mitutil.cxx
#define FILENO_PKAUTH           (DIRNO_CLIENT2 + 17)     // pkauth.cxx
#define FILENO_PROXYAPI         (DIRNO_CLIENT2 + 18)     // proxyapi.cxx
#define FILENO_RPCUTIL          (DIRNO_CLIENT2 + 19)     // rpcutil.cxx
#define FILENO_SIDCACHE         (DIRNO_CLIENT2 + 20)     // sidcache.cxx
#define FILENO_TIMESYNC         (DIRNO_CLIENT2 + 21)     // timesync.cxx
#define FILENO_TKTCACHE         (DIRNO_CLIENT2 + 22)     // tktcache.cxx
#define FILENO_TKTLOGON         (DIRNO_CLIENT2 + 23)     // tktlogon.cxx
#define FILENO_USERAPI          (DIRNO_CLIENT2 + 24)     // userapi.cxx
#define FILENO_USERLIST         (DIRNO_CLIENT2 + 25)     // userlist.cxx

// common2 directory
#define FILENO_AUTHEN           (DIRNO_COMMON2 + 0)       // authen.cxx
#define FILENO_CRYPT            (DIRNO_COMMON2 + 1)       // crypt.c
#define FILENO_KEYGEN           (DIRNO_COMMON2 + 2)       // keygen.c
#define FILENO_KRB5             (DIRNO_COMMON2 + 3)       // krb5.c
#define FILENO_NAMES            (DIRNO_COMMON2 + 4)       // names.cxx
#define FILENO_PASSWD           (DIRNO_COMMON2 + 5)       // passwd.c
#define FILENO_RESTRICT         (DIRNO_COMMON2 + 6)       // restrict.cxx
#define FILENO_SOCKETS          (DIRNO_COMMON2 + 7)       // sockets.cxx
#define FILENO_TICKETS          (DIRNO_COMMON2 + 8)       // tickets.cxx
#define FILENO_COMMON_UTILS     (DIRNO_COMMON2 + 9)       // utils.cxx

// kernel directory
#define FILENO_CPGSSUTL            (DIRNO_KERNEL + 0)         // cpgssutl.cxx
#define FILENO_CTXTMGR2            (DIRNO_KERNEL + 1)         // ctxtmgr.cxx
#define FILENO_KERBLIST2           (DIRNO_KERNEL + 2)         // kerblist.cxx
#define FILENO_KRNLAPI             (DIRNO_KERNEL + 3)         // krnlapi.cxxc

// RTL directory
#define FILENO_AUTHDATA         (DIRNO_RTL + 0)     // authdata.cxx
#define FILENO_CRACKPAC         (DIRNO_RTL + 1)     // crackpac.cxx
#define FILENO_CRED             (DIRNO_RTL + 2)     // cred.cxx
#define FILENO_CREDLIST         (DIRNO_RTL + 3)     // credlist.cxx
#define FILENO_CREDLOCK         (DIRNO_RTL + 4)     // credlock.cxx
#define FILENO_DBUTIL           (DIRNO_RTL + 5)     // dbutil.cxx
#define FILENO_DBOPEN           (DIRNO_RTL + 6)     // domain.cxx
#define FILENO_DOMCACHE         (DIRNO_RTL + 7)     // domcache.cxx
#define FILENO_FILTER           (DIRNO_RTL + 8)     // filter.cxx
#define FILENO_MAPERR           (DIRNO_RTL + 9)     // maperr.cxx
#define FILENO_MAPSECER         (DIRNO_RTL + 10)    // mapsecerr.cxx
#define FILENO_MISCID           (DIRNO_RTL + 11)    // miscid.cxx
#define FILENO_PAC              (DIRNO_RTL + 12)    // pac.cxx
#define FILENO_PAC2             (DIRNO_RTL + 13)    // pac2.cxx
#define FILENO_PARMCHK          (DIRNO_RTL + 14)    // parmchk.cxx
#define FILENO_REG              (DIRNO_RTL + 15)    // reg.cxx
#define FILENO_SECSTR           (DIRNO_RTL + 16)    // secstr.cxx
#define FILENO_SERVICES         (DIRNO_RTL + 17)    // services.c
#define FILENO_STRING           (DIRNO_RTL + 18)    // string.cxx
#define FILENO_TIMESERV         (DIRNO_RTL + 19)    // timeserv.cxx
#define FILENO_TOKENUTL         (DIRNO_RTL + 20)    // tokenutl.cxx
#define FILENO_TRNSPORT         (DIRNO_RTL + 21)    // trnsport.cxx

// Server directory
#define FILENO_DEBUG            (DIRNO_SERVER + 0)     // debug.cxx
#define FILENO_DGUTIL           (DIRNO_SERVER + 1)     // dgutil.cxx
#define FILENO_EVENTS           (DIRNO_SERVER + 2)     // events.cxx
#define FILENO_GETAS            (DIRNO_SERVER + 3)     // getas.cxx
#define FILENO_GETTGS           (DIRNO_SERVER + 4)     // gettgs.cxx
#define FILENO_KDC              (DIRNO_SERVER + 5)     // kdc.cxx
#define FILENO_KDCTRACE         (DIRNO_SERVER + 6)     // kdctrace.cxx
#define FILENO_KPASSWD          (DIRNO_SERVER + 7)     // kpasswd.cxx
#define FILENO_NOTIFY2          (DIRNO_SERVER + 8)     // notify2.cxx
#define FILENO_SRVPAC           (DIRNO_SERVER + 9)     // pac.cxx
#define FILENO_PKSERV           (DIRNO_SERVER + 10)    // pkserv.cxx
#define FILENO_REFER            (DIRNO_SERVER + 11)    // refer.cxx
#define FILENO_RPCIF            (DIRNO_SERVER + 12)    // rpcif.cxx
#define FILENO_SECDATA          (DIRNO_SERVER + 13)    // secdata.cxx
#define FILENO_SOCKUTIL         (DIRNO_SERVER + 14)    // sockutil.cxx
#define FILENO_TKTUTIL          (DIRNO_SERVER + 15)    // tktutil.cxx
#define FILENO_TRANSIT          (DIRNO_SERVER + 16)    // transit.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\dsstring.h ===
//+------------------------------------------------------------------
//
// File: DSSTRING.H
//
// Contents:  It contains the all the constant strings used all thru
//            DS project
//
// Synoposis: Collection of strings.
//
// Classes:    -none-
//
// Functions: -none-
//
// History:     Oct 27, 1993    AlokS   Created
//              5-Apr095        MikeSe  Moved, modified
//
//-------------------------------------------------------------------

#ifndef __DSSTRING_H__
#define __DSSTRING_H__

#include <lmsname.h>    // for SERVICE_SERVER, SERVICE_NETLOGON,
                        // and SERVICE_SCHEDULE

#define ACCOUNT_OPERATORS      L"AccountOperators"
#define BACKUP_OPERATORS       L"BackupOperators"
#define CAIRODSGROUP           L"Cairo DS"
#define COMP_NAME_KEY          L"System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define COMP_NAME_VALUE        L"ComputerName"
#define DC_TYPE                L"DCType"
#define DFS_VOLUME             L"\\volumes"
#define DFSM_PASSWORD          L"dfsm"
#define DFSM_PRINCIPAL         L"DFSM"
#define ORASVC_PASSWORD        L"ora"
#define ORASVC_PRINCIPAL       L"ORA"
#define DOMAIN_ADMIN           L"DomainAdmin"
#define DOMAIN_ADMIN_PASSWORD  L"DomainAdmin"
#define DOMAIN_ADMINS          L"DomainAdmins"
#define DOMAIN_NAME            L"CairoDomainName"
#define DOMAIN_PASSWORD        L"DomainPassword"
#define DOMAIN_ROOT            L"DOM:\\"
#define DOMAIN_USERS           L"DomainUsers"
#define DOMAINOBJECTNAME       L"Domain"
#define DS_REG_DOMAIN_ID       L"DomainID"// Type Binary
#define DS_REG_SITE_ID         L"SiteID"// Type Binary
#define DS_REG_DOMAIN_NAME     L"DomainName"// Type REG_SZ
#define DS_REG_DOMAIN_ROOT     L"DomainRoot"// Type REG_SZ
#define DS_REG_LOCAL_ID        L"LocalID"// Type Binary
#define DS_REG_MACHINE_NAME    L"MachineName"// Type REG_SZ
#define DS_REG_MACHINE_ROOT    L"MachineRoot"// Type REG_SZ
#define DS_REG_MACHINE_STATE   L"MachineState"// Type DWORD
#define DS_REG_MACHINE_TARGET_STATE  L"MachineTargetState"// Type DWORD
#define DS_REG_MACHINE_VOLID   L"MachineVolumeId" // Type Binary
#define DS_REG_MACHINE_WEIGHT  L"MachineWeight"  // type DWORD
#define DS_REG_OU_NAME         L"OUName"// Type REG_SZ
#define DS_REG_PATH            L"System\\CurrentControlSet\\Control\\Cairo\\DS"
#define DS_REG_PUSER_NAME      L"PUserName"// Type REG_SZ
#define DS_REG_TIME_SYNC_STATE L"ReliableTimeSource" // Type DWORD
#define DS_REG_DOWNLEVEL_SID   L"DownlevelDomainSid" // Type REG_BINARY
#define DSDFSVOLUMES           L"VOLUMES"
#define DSDOMAINROOT           L"DSDomain"
#define DSLOCALROOT            L"DSLocal"
#define DSORGROOT              L"DSOrg"
#define DSORAROOT              L"Ora"
#define DSROOTNAME             L"DS"
#define DSSERVER               L"DSServer"
#define DSSERVERPWD            L"dsserver"
#define DSDOMAIN_REPLICA_SET_NAME        L"dsdomain"
#define DSDOMAIN_REPLICA_OBJECT_SET_ROOT L"dsshare\\dsdomain"
#define DSORG_REPLICA_SET_NAME   L"dsorg"
#define DSORG_REPLICA_OBJECT_SET_ROOT L"dsshare\\dsorg"
#define GUEST_ACCOUNT          L"Guest"
#define NET_DSSHARE            L"DsShare"
#define NET_DSSHARE_COMMENT    L"Replication share for DS domain objects"
#define NET_ORASHARE           L"Ora"
#define NET_ORASHARE_COMMENT   L"Replication share for Object Replication Agent"
#define FIRST_NONROOT_DC       L"FirstNonRootDC"
#define INST_TYPE_STANDALONE   L"Standalone"
#define INST_TYPE_DC           L"DC"
#define INST_TYPE_WKSTA        L"Workstation"
#define INSTALL_DIR            L"InstallDir"
#define INSTALL_DRIVE          L"ObjDrive"
#define INSTALL_TYPE           L"InstallType"
#define KDC_KEY                L"System\\CurrentControlSet\\Control\\Cairo\\CairoKDC"
#define KDC_NOTIFYADDRS        L"System\\CurrentControlSet\\Control\\Cairo\\DS\\DC\\NotifyAddrs"
#define KDC_PASSWORD           L"kdc"
#define KDC_PRINCIPAL          L"KDC"
#define KDC_LOGONNAME          L"\\" KDC_PRINCIPAL
#define LOCAL_DOMAIN_NAME      L"WORKGROUP"
#define MACHINE_ADDR           L"MachineAddress"
#define MACHINE_NAME           L"MachineName"
#define MACHINE_PWD            L"MachinePassword"
#define MACHINE_ROOT           L"MACH:\\"
#define NTLMSVC_PASSWORD       L"netlogon"
#define NTLMSVC_PRINCIPAL      L"Netlogon"
#define OU_NAME                L"OuName"
#define PRINT_OPERATORS        L"PrintOperators"
#define PRIVATE_GROUP          L"Private"
#define PRIVSVR_PRINCIPAL      L"PrivSvr"
#define PRIVSVR_PASSWORD       L"privsvr"
#define PROFILE_IMAGE_PATH     L"ProfileImagePath"
#define PROFILE_LIST_KEY       L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define PROFILE_PATH           L"ProfilePath"
#define DAYTONA_PROFILE        L"DaytonaProfile"
#define PUBLIC_GROUP           L"Public"
#define REPL_DC                L"ReplicaDC"
#define FIRST_DC               L"FirstDC"
#define SECTION_HEADER         L"FirstPass"
#define SECURITY_FOLDER        L"security"
#define SERVER_OPERATORS       L"ServerOperators"
#define SERVICE_CAIROKDC       L"CairoKdc"
#define SERVICE_CAIROORA       L"CairoOra"
#define SERVICE_ORASVC         L"CairoOra"
#define SERVICE_DFSDRIVER      L"Dfs"
#define SERVICE_DFSMANAGER     L"DfsManager"
#define SERVICE_NTLM           L"Netlogon"
#define SERVICE_PRIVSVR        L"PrivSvrService"
#define STANDALONE_DOMAIN_NAME L"Local"
#define USER_NAME              L"UserName"

#define UNICODE_BACKSLASH      L"\\"
#define UNICODE_NULL_STRING    L""
#define WCHAR_BACKSLASH        L'\\'
#define WCHAR_NULL             L'\0'

#endif // __DSSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kdcexp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        kdcexp.h
//
// Contents:    Private Exports from kdcsvc.dll
//
//
// History:     27-June-1997    MikeSw          Created
//
//------------------------------------------------------------------------


#ifndef __KDCEXP_H__
#define __KDCEXP_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

NTSTATUS
KdcVerifyPac(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );

#define KDC_VERIFY_PAC_NAME "KdcVerifyPac"
typedef NTSTATUS
(NTAPI *PKDC_VERIFY_PAC_ROUTINE)(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );

KERBERR
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

#define KDC_GET_TICKET_NAME "KdcGetTicket"
typedef KERBERR
(NTAPI *PKDC_GET_TICKET_ROUTINE) (
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

#define KDC_CHANGE_PASSWORD_NAME "KdcChangePassword"

KERBERR
KdcChangePassword(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

VOID
KdcFreeMemory(
     IN PVOID Ptr
     );

#define KDC_FREE_MEMORY_NAME "KdcFreeMemory"

typedef VOID
(NTAPI * PKDC_FREE_MEMORY_ROUTINE) (
    IN PVOID Ptr
    );

NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

BOOLEAN
KdcUpdateKrbtgtPassword(
    IN PUNICODE_STRING DnsDomainName,
    IN PLARGE_INTEGER MaxPasswordAge
    );

//
// Exported routines from kerberos.dll
//

NTSTATUS
KerbMakeKdcCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN OUT PKERB_MESSAGE_BUFFER ReplyMessage,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    );

VOID
KerbFree(
    IN PVOID Buffer
    );


NTSTATUS
KerbCreateTokenFromTicket(
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR Authenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain
    );

BOOLEAN
KerbIsInitialized(
);

NTSTATUS
KerbKdcCallBack(
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KDCEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kerbcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbcred.h
//
// Contents:    structures for kerberos primary and supplemental credentials
//
//
// History:     20-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCRED_H__
#define __KERBCRED_H__


//
// Kerberos primary credentials store keys suitable for different
// encryption types.
//
#ifndef _KRB5_Module_H_
typedef struct _KERB_RPC_OCTET_STRING {
    unsigned long length;
#ifdef MIDL_PASS
    [size_is(length)]
#endif // MIDL_PASS
    unsigned char *value;
} KERB_RPC_OCTET_STRING;

typedef struct _KERB_ENCRYPTION_KEY {
    long keytype;
    KERB_RPC_OCTET_STRING keyvalue;
} KERB_ENCRYPTION_KEY;
#endif // _KRB5_Module_H_


typedef struct _KERB_KEY_DATA {
    UNICODE_STRING Salt;
    KERB_ENCRYPTION_KEY Key;
} KERB_KEY_DATA, *PKERB_KEY_DATA;

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA Credentials[*];
#else
    KERB_KEY_DATA Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;


#define KERB_PRIMARY_CRED_OWF_ONLY      2
#define KERB_PRIMARY_CRED_REVISION      3

//
// Flags for setting account keys
//

#define KERB_SET_KEYS_REPLACE   0x1



//
// KERB_STORED_CREDENTIALS are stored in the DS (blob), so
// they've got to be stored in 32 bit format, for W2k and 
// 32bit DC compatibility. 7/6/2000 - TS
//

#define KERB_KEY_DATA32_SIZE 20 
#define KERB_STORED_CREDENTIAL32_SIZE 16

#pragma pack(4)

typedef struct _KERB_ENCRYPTION_KEY32 {
    LONG keytype;
    ULONG keyvaluelength;       // KERB_RPC_OCTET_STRING32 
    ULONG keyvaluevalue;
} KERB_ENCRYPTION_KEY32;

typedef struct _KERB_KEY_DATA32 {
    UNICODE_STRING32 Salt;
    KERB_ENCRYPTION_KEY32 Key; // KERB_ENCRYPTION_KEY32
} KERB_KEY_DATA32, *PKERB_KEY_DATA32;



typedef struct _KERB_STORED_CREDENTIAL32 {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING32 DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA32 Credentials[*];              // KERB_KEY_DATA32
#else
    KERB_KEY_DATA32 Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL32, *PKERB_STORED_CREDENTIAL32;

#pragma pack()

#ifdef _WIN64

NTSTATUS
KdcPack32BitStoredCredential(
   IN PKERB_STORED_CREDENTIAL Cred64,
   OUT PKERB_STORED_CREDENTIAL32 * ppCred32,
   OUT PULONG pCredSize
   );

NTSTATUS
KdcUnpack32BitStoredCredential(
    IN PKERB_STORED_CREDENTIAL32 Cred32,
    IN OUT PKERB_STORED_CREDENTIAL * ppCred64,
    IN OUT PULONG CredLength
    );
#endif // WIN64
       



#endif // __KERBCRED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kerbcomm.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbcomm.h
//
// Contents:    prototypes for common kerberos routines
//
//
// History:     15-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef _KERBCOMM_H_
#define _KERBCOMM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
#include <rpc.h>
#include <rpcndr.h>
#ifndef WIN32_CHICAGO
#include <ntsam.h>
#endif // WIN32_CHICAGO
#include <windef.h>
#include <stdio.h>
#include <limits.h>
#include <winbase.h>
#include <krb5.h>
#include <cryptdll.h>
#include <align.h>
#ifdef __cplusplus
}
#endif // _cplusplus
#include <krb5p.h>
#include <kerberr.h>
#include <exterr.h>
#include <kerbcred.h>
#ifndef WIN32_CHICAGO
// SECURITY_WIN32 is already defined
#include <security.h>
#endif // WIN32_CHICAGO

//
// HACK HACK HACK on xp sp1, we can not have STATUS_USER2USER_REQUIRED in ntstatus.mc!
//

//
// MessageId: STATUS_USER2USER_REQUIRED
//
// MessageText:
//
//  Kerberos sub-protocol User2User is required.
//
#define STATUS_USER2USER_REQUIRED        ((NTSTATUS)0xC0000408L)

//////////////////////////////////////////////////////////////////////////
//
// Definitions (for lack of a better place)
//
//////////////////////////////////////////////////////////////////////////

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response


//
// Pre-auth data types

#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_S4U                 21
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE       64
#define KERB_AUTH_SESAME        65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data
#define KERB_AUTH_PROXY_ANNOTATION      139     // entry id for a proxy logon annotation string

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC
#define KERB_AUTH_DATA_TOKEN_RESTRICTIONS 141   // entry id for token restrictions
//
// Transited realm compression types:
//

#define DOMAIN_X500_COMPRESS            1

//
// Certificate types for PKINIT
//

#define KERB_CERTIFICATE_TYPE_X509      1
#define KERB_CERTIFICATE_TYPE_PGP       2

//
// Signature & seal types used by PKINIT
//

#define KERB_PKINIT_SIGNATURE_ALG               CALG_MD5
#define KERB_PKINIT_EXPORT_SEAL_OID             szOID_RSA_RC2CBC
#define KERB_PKINIT_EXPORT_SEAL_ETYPE           KERB_ETYPE_RC2_CBC_ENV
#define KERB_PKINIT_SEAL_ETYPE                  KERB_ETYPE_DES_EDE3_CBC_ENV
#define KERB_PKINIT_SEAL_OID                    szOID_RSA_DES_EDE3_CBC
#define KERB_PKINIT_SIGNATURE_OID               szOID_RSA_MD5RSA
#define KERB_PKINIT_KDC_CERT_TYPE               szOID_PKIX_KP_SERVER_AUTH

#ifdef szOID_KP_SMARTCARD_LOGON
#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_KP_SMARTCARD_LOGON
#else
#define KERB_PKINIT_CLIENT_CERT_TYPE "1.3.6.1.4.1.311.20.2.2"
#endif


//
// Transport information
//

#define KERB_KDC_PORT                   88
#define KERB_KPASSWD_PORT               464

//
// KDC service principal
//

#define KDC_PRINCIPAL_NAME              L"krbtgt"
#define KDC_PRINCIPAL_NAME_A            "krbtgt"
#define KERB_HOST_STRING_A              "host"
#define KERB_HOST_STRING                L"host"
#define KERB_KPASSWD_FIRST_NAME         L"kadmin"
#define KERB_KPASSWD_SECOND_NAME        L"changepw"


//
// address types - corresponds to GSS types
//
#define KERB_ADDRTYPE_UNSPEC           0x0
#define KERB_ADDRTYPE_LOCAL            0x1
#define KERB_ADDRTYPE_INET             0x2
#define KERB_ADDRTYPE_IMPLINK          0x3
#define KERB_ADDRTYPE_PUP              0x4
#define KERB_ADDRTYPE_CHAOS            0x5
#define KERB_ADDRTYPE_NS               0x6
#define KERB_ADDRTYPE_NBS              0x7
#define KERB_ADDRTYPE_ECMA             0x8
#define KERB_ADDRTYPE_DATAKIT          0x9
#define KERB_ADDRTYPE_CCITT            0xA
#define KERB_ADDRTYPE_SNA              0xB
#define KERB_ADDRTYPE_DECnet           0xC
#define KERB_ADDRTYPE_DLI              0xD
#define KERB_ADDRTYPE_LAT              0xE
#define KERB_ADDRTYPE_HYLINK           0xF
#define KERB_ADDRTYPE_APPLETALK        0x10
#define KERB_ADDRTYPE_BSC              0x11
#define KERB_ADDRTYPE_DSS              0x12
#define KERB_ADDRTYPE_OSI              0x13
#define KERB_ADDRTYPE_NETBIOS          0x14
#define KERB_ADDRTYPE_X25              0x15


//
// Misc. Flags
//

#define KERB_EXPORT_KEY_FLAG 0x20000000

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

//
// Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2

//
// Types for extended errors
//
#define KERB_ERR_TYPE_EXTENDED                3

#define TD_MUST_USE_USER2USER                 -128
#define TD_EXTENDED_ERROR                     -129

//
// PKINIT method errors
//
#define KERB_PKINIT_UNSPEC_ERROR        0       // not specified
#define KERB_PKINIT_BAD_PUBLIC_KEY      1       // cannot verify public key
#define KERB_PKINIT_INVALID_CERT        2       // invalid certificate
#define KERB_PKINIT_REVOKED_CERT        3       // revoked certificate
#define KERB_PKINIT_INVALID_KDC_NAME    4       // invalid KDC name
#define KERB_PKINIT_CLIENT_NAME_MISMATCH 5      // client name mismatch

//
// Flag bit defines for use with the LogonRestrictionsFlag parameter
// passed to the KerbCheckLogonRestrictions function
//
#define     KDC_RESTRICT_PKINIT_USED            1
#define     KDC_RESTRICT_IGNORE_PW_EXPIRATION   2

//
// HACK for MAX_UNICODE_STRING, as KerbDuplicateString & others add a NULL
// terminator when doing the duplication
//
#define KERB_MAX_UNICODE_STRING (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))
#define KERB_MAX_STRING        (UNICODE_STRING_MAX_BYTES - sizeof(CHAR))


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

#define KERBFLAG_LOGON                  0x1
#define KERBFLAG_INTERACTIVE            0x2

//
// KDC-Kerberos interaction
//

#define KDC_START_EVENT                 L"\\Security\\KdcStartEvent"

#define KERB_MAX_CRYPTO_SYSTEMS 20
#define KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF 100

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5
#define KERB_DEFAULT_PREAUTH_TYPE       0

//
// Registry parameters
//

#define KERB_PARAMETER_PATH             L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos"
#define KERB_PARAMETER_SKEWTIME         L"SkewTime"
#define KERB_PARAMETER_MAX_UDP_PACKET   L"MaxPacketSize"
#define KERB_PARAMETER_START_TIME       L"StartupTime"
#define KERB_PARAMETER_KDC_CALL_TIMEOUT L"KdcWaitTime"
#define KERB_PARAMETER_KDC_BACKOFF_TIME L"KdcBackoffTime"
#define KERB_PARAMETER_KDC_SEND_RETRIES L"KdcSendRetries"
#define KERB_PARAMETER_USE_SID_CACHE    L"UseSidCache"
#define KERB_PARAMETER_LOG_LEVEL        L"LogLevel"
#define KERB_PARAMETER_DEFAULT_ETYPE    L"DefaultEncryptionType"
#define KERB_PARAMETER_FAR_KDC_TIMEOUT  L"FarKdcTimeout"
#define KERB_PARAMETER_NEAR_KDC_TIMEOUT L"NearKdcTimeout"
#define KERB_PARAMETER_STRONG_ENC_DG    L"StronglyEncryptDatagram"
#define KERB_PARAMETER_MAX_REFERRAL_COUNT L"MaxReferralCount"
#define KERB_PARAMETER_MAX_TOKEN_SIZE   L"MaxTokenSize"
#define KERB_PARAMETER_SPN_CACHE_TIMEOUT L"SpnCacheTimeout"
#define KERB_PARAMETER_RETRY_PDC        L"RetryPDC"
#define KERB_PARAMETER_REQUEST_OPTIONS      L"RequestOptions"
#define KERB_PARAMETER_CLIENT_IP_ADDRESSES  L"ClientIpAddresses"
#define KERB_PARAMETER_TGT_RENEWAL_INTERVAL L"TgtRenewalInterval"

//
// Registry defaults
//

#define KERB_DEFAULT_LOGLEVEL 0
#define KERB_DEFAULT_USE_SIDCACHE FALSE
#define KERB_DEFAULT_USE_STRONG_ENC_DG FALSE
#define KERB_DEFAULT_CLIENT_IP_ADDRESSES 0
#define KERB_DEFAULT_TGT_RENEWAL_INTERVAL ( 10 * 60 - 5 )

//
// These are arbitrary sizes for max request and responses sizes for datagram
// requests.
//

#define KERB_MAX_KDC_RESPONSE_SIZE      4000
#define KERB_MAX_KDC_REQUEST_SIZE       4000
#define KERB_MAX_DATAGRAM_SIZE          2000
#define KERB_MAX_RETRIES                3
#define KERB_MAX_REFERRAL_COUNT         10

//
// timeout values in minutes
//

#define KERB_BINDING_FAR_DC_TIMEOUT     10
#define KERB_BINDING_NEAR_DC_TIMEOUT    30
#define KERB_SPN_CACHE_TIMEOUT          15
#define KERB_DEFAULT_SKEWTIME           5

//
// Network service session timer callback frequency
//

#define KERB_SKLIST_CALLBACK_FEQ        10

//
// timeout values in seconds
//

#define KERB_KDC_CALL_TIMEOUT                   5
#define KERB_KDC_CALL_TIMEOUT_BACKOFF           5
#define KERB_KDC_WAIT_TIME      120

//
// BER encoding values
//

#define KERB_BER_APPLICATION_TAG 0xc0
#define KERB_BER_APPLICATION_MASK 0x1f
#define KERB_TGS_REQ_TAG 12
#define KERB_AS_REQ_TAG 10
#define KERB_TGS_REP_TAG 13
#define KERB_AS_REP_TAG 11
#define KERB_ERROR_TAG 30

//
// Common types
//

typedef struct _KERB_MESSAGE_BUFFER {
    ULONG BufferSize;
    PUCHAR Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;

//
// This is the maximum number of elements in a KERB_INTERNAL_NAME
//

#define MAX_NAME_ELEMENTS 20

typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;

//
// Prototypes
//
#ifdef __cplusplus

class CAuthenticatorList;

KERBERR NTAPI
KerbCheckTicket(
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  PKERB_ENCRYPTION_KEY pkKey,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  PTimeStamp SkewTime,
    IN  ULONG ServiceNameCount,
    IN  OPTIONAL PUNICODE_STRING ServiceName,
    IN  OPTIONAL PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PBOOLEAN UseSubKey
    );

extern "C" {

#endif // __cplusplus

KERBERR
KerbVerifyTicket(
    IN PKERB_TICKET PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL PUNICODE_STRING ServiceNames,
    IN OPTIONAL PUNICODE_STRING ServiceRealm,
    IN PKERB_ENCRYPTION_KEY ServiceKey,
    IN OPTIONAL PTimeStamp SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket
    );

KERBERR NTAPI
KerbPackTicket(
    IN PKERB_TICKET InternalTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    OUT PKERB_TICKET PackedTicket
    );

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    );

// VOID NTAPI
// KerbFreeTicket(
//     IN PKERB_ENCRYPTED_TICKET Ticket
//     );

#define KerbFreeTicket( Ticket ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TICKET_PDU, \
        (Ticket) \
        )

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET DestinationTicket,
    IN PKERB_TICKET SourceTicket
    );

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    );

VOID
CheckForOutsideStringToKey();

KERBERR NTAPI
KerbHashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbHashPasswordEx(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

BOOLEAN
KerbIsKeyExportable(
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PKERB_ENCRYPTION_KEY Key
    );

VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    );

PKERB_ENCRYPTION_KEY
KerbGetKeyFromList(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType
    );

KERBERR
KerbFindCommonCryptSystem(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN OPTIONAL PKERB_STORED_CREDENTIAL MorePasswords,
    OUT PULONG CommonCryptSystem,
    OUT PKERB_ENCRYPTION_KEY * Key
    );

KERBERR NTAPI
KerbRandomFill(
    IN OUT PUCHAR pbBuffer,
    IN ULONG cbBuffer
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PTimeStamp ptsTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    );

// VOID NTAPI
// KerbFreeAuthenticator(
//     IN PKERB_AUTHENTICATOR Authenticator
//     );

#define KerbFreeAuthenticator( Authenticator ) \
    KerbFreeData( \
        KERB_AUTHENTICATOR_PDU, \
        (Authenticator) \
        )

KERBERR NTAPI
KerbPackKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG EncryptionType,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    );

// KERBERR NTAPI
// KerbPackAsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackAsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_AS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackAsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackAsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeAsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeAsReply( Request) \
    KerbFreeData( \
        KERB_AS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackTgsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_TGS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackTgsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackTgsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeTgsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeTgsReply( Request) \
    KerbFreeData( \
        KERB_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// VOID
// KerbFreeKdcReplyBody(
//    IN PKERB_ENCRYPTED_KDC_REPLY Request
//    );

#define KerbFreeKdcReplyBody( Request) \
    KerbFreeData( \
        KERB_ENCRYPTED_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackAsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackAsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackAsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackAsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_AS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeAsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeAsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackTgsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackTgsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackTgsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_TGS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeTgsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeTgsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackEncryptedData(
//     IN PKERB_ENCRYPTED_DATA EncryptedData,
//     OUT PULONG DataSize,
//     OUT PUCHAR * MarshalledData
//     );

#define KerbPackEncryptedData( EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedData(
//     IN PUCHAR EncryptedData,
//    IN ULONG DataSize,
//    OUT PKERB_ENCRYPTED_DATA * Data
//    );

#define KerbUnpackEncryptedData( EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

// VOID
// KerbFreeEncryptedData(
//    IN PKERB_ENCRYPTED_DATA EncryptedData
//    );

#define KerbFreeEncryptedData( EncryptedData) \
    KerbFreeData( \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID) (EncryptedData) \
        )

#ifdef notdef
// KERBERR NTAPI
// KerbPackAuthData(
//     IN PKERB_AUTHORIZATION_DATA AuthData,
//     OUT PULONG AuthDataSize,
//     OUT PUCHAR * MarshalledAuthData
//     );

#define KerbPackAuthData( AuthData, AuthDataSize, MarshalledAuthData ) \
    KerbPackData( \
        (PVOID) (AuthData), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (AuthDataSize), \
        (MarshalledAuthData) \
        )

// KERBERR NTAPI
// KerbUnpackAuthData(
//     IN PUCHAR PackedAuthData,
//     IN ULONG AuthDataSize,
//     OUT PKERB_AUTHORIZATION_DATA * AuthData
//     );

#define KerbUnpackAuthData( PackedAuthData, AuthDataSize, AuthData ) \
    KerbUnpackData( \
        (PackedAuthData), \
        (AuthDataSize), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID *) (AuthData) \
        )

// VOID
// KerbFreeAuthData(
//    IN PKERB_AUTH_DATA AuthData
//    );

#define KerbFreeAuthData( AuthData) \
    KerbFreeData( \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID) (AuthData) \
        )

#endif // notdef

VOID
KerbFreeAuthData(
   IN PKERB_AUTHORIZATION_DATA AuthData
   );

// KERBERR NTAPI
// KerbPackApRequest(
//     IN PKERB_AP_REQUEST ApRequestMessage,
//     OUT PULONG ApRequestSize,
//     OUT PUCHAR * MarshalledApRequest
//     );

#define KerbPackApRequest( ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

// KERBERR NTAPI
// KerbUnpackApRequest(
//    IN PUCHAR ApRequestMessage,
//    IN ULONG ApRequestSize,
//    OUT PKERB_AP_REQUEST * ApRequest
//    );

#define KerbUnpackApRequest( ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

// VOID
// KerbFreeApRequest(
//    IN PKERB_AP_REQUEST Request
//    );

#define KerbFreeApRequest( Request) \
    KerbFreeData( \
        KERB_AP_REQUEST_PDU, \
        (PVOID) (Request) \
        )


// KERBERR NTAPI
// KerbPackApReply(
//     IN PKERB_AP_REPLY ApReplyMessage,
//     OUT PULONG ApReplySize,
//     OUT PUCHAR * MarshalledApReply
//     );

#define KerbPackApReply( ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

// KERBERR NTAPI
// KerbUnpackApReply(
//     IN PUCHAR ApReplyMessage,
//     IN ULONG ApReplySize,
//     OUT PKERB_AP_REPLY * ApReply
//    );

#define KerbUnpackApReply( ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

// VOID
// KerbFreeApReply(
//    IN PKERB_AP_REPLY Reply
//    );

#define KerbFreeApReply( Reply) \
    KerbFreeData( \
        KERB_AP_REPLY_PDU, \
        (PVOID) (Reply) \
        )

// KERBERR NTAPI
// KerbPackApReplyBody(
//     IN PKERB_ENCRYPTED_AP_REPLY ApReplyBodyMessage,
//     OUT PULONG ApReplyBodySize,
//     OUT PUCHAR * MarshalledApReplyBody
//    );

#define KerbPackApReplyBody( ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

// KERBERR NTAPI
// KerbUnpackApReplyBody(
//     IN PUCHAR ApReplyBodyMessage,
//     IN ULONG ApReplyBodySize,
//     OUT PKERB_ENCRYPTED_AP_REPLY * ApReplyBody
//    );

#define KerbUnpackApReplyBody( ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

// VOID
// KerbFreeApReplyBody(
//    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody
//    );

#define KerbFreeApReplyBody( ReplyBody) \
    KerbFreeData( \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID) (ReplyBody) \
        )

// KERBERR NTAPI
// KerbUnmarshallTicket(
//     IN PUCHAR TicketMessage,
//     IN ULONG TicketSize,
//     OUT PKERB_ENCRYPTED_TICKET * Ticket
//     );

#define KerbUnmarshallTicket( TicketMessage, TicketSize, Ticket ) \
    KerbUnpackData( \
        (TicketMessage), \
        (TicketSize), \
        KERB_ENCRYPTED_TICKET_PDU, \
        (PVOID *) (Ticket) \
        )

// KERBERR NTAPI
// KerbPackEncryptedCred(
//     IN PKERB_ENCRYPTED_CRED EncryptedCred,
//     OUT PULONG CredSize,
//     OUT PUCHAR * MarshalledCred
//     );

#define KerbPackEncryptedCred( EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedCred(
//     IN PUCHAR EncryptedCred,
//    IN ULONG CredSize,
//    OUT PKERB_ENCRYPTED_CRED * Cred
//    );

#define KerbUnpackEncryptedCred( EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

// VOID
// KerbFreeEncryptedCred(
//    IN PKERB_ENCRYPTED_CRED EncryptedCred
//    );

#define KerbFreeEncryptedCred( EncryptedCred) \
    KerbFreeData( \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID) (EncryptedCred) \
        )

// KERBERR NTAPI
// KerbPackKerbCred(
//     IN PKERB_CRED KerbCred,
//     OUT PULONG KerbCredSize,
//     OUT PUCHAR * MarshalledKerbCred
//     );

#define KerbPackKerbCred( KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

// KERBERR NTAPI
// KerbUnpackKerbCred(
//    IN PUCHAR MarshalledKerbCred,
//    IN ULONG KerbCredSize,
//    OUT PKERB_CRED * KerbCred
//    );

#define KerbUnpackKerbCred( MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

// VOID
// KerbFreeKerbCred(
//    IN PKERB_CRED KerbCred
//    );

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

// KERBERR NTAPI
// KerbPackKerbError(
//     IN PKERB_ERROR ErrorMessage,
//     OUT PULONG ErrorSize,
//     OUT PUCHAR * MarshalledError
//     );

#define KerbPackKerbError( ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

// KERBERR NTAPI
// KerbUnpackKerbError(
//     IN PUCHAR ErrorMessage,
//     IN ULONG ErrorSize,
//     OUT PKERB_ERROR * Error
//     );

#define KerbUnpackKerbError( ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

// VOID
// KerbFreeKerbError(
//    IN PKERB_ERROR Request
//    );

#define KerbFreeKerbError( Error ) \
    KerbFreeData( \
        KERB_ERROR_PDU, \
        (PVOID) (Error) \
        )

// KERBERR NTAPI
// KerbPackEncryptedTime(
//     IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTimeMessage,
//     OUT PULONG EncryptedTimeSize,
//     OUT PUCHAR * MarshalledEncryptedTime
//     );

#define KerbPackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedTime(
//     IN PUCHAR EncryptedTimeMessage,
//     IN ULONG EncryptedTimeSize,
//     OUT PKERB_ENCRYPTED_TIMESTAMP * EncryptedTime
//     );

#define KerbUnpackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

// VOID
// KerbFreeEncryptedTime(
//    IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTime
//    );

#define KerbFreeEncryptedTime( EncryptedTime ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID) (EncryptedTime) \
        )

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptData(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

#ifndef WIN32_CHICAGO
KERBERR NTAPI
KerbCheckSumVerify(
    IN PUCHAR pbBuffer,
    IN ULONG cbBuffer,
    OUT PKERB_CHECKSUM pcsCheck
    );

KERBERR NTAPI
KerbCheckSum(
    PUCHAR pbData,
    ULONG cbData,
    PCHECKSUM_FUNCTION pcsfSum,
    PKERB_CHECKSUM pcsCheckSum
    );
#endif // WIN32_CHICAGO

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    );

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
KerbConvertStringToSid(
    IN PUNICODE_STRING String,
    OUT PSID * Sid
    );

NTSTATUS
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    );

KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    );

KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

LPWSTR
KerbBuildNullTerminatedString(
    IN PUNICODE_STRING String
    );

VOID
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    );

VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    );

#ifndef WIN32_CHICAGO
KERBERR
KerbCheckLogonRestrictions(
    IN PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PTimeStamp LogoffTime,
    OUT PNTSTATUS RetStatus
    );

#include <pacndr.h>
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    );

NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    );



#define KERB_TOKEN_RESTRICTION_DISABLE_GROUPS   1
#define KERB_TOKEN_RESTRICTION_RESTRICT_SIDS    2
#define KERB_TOKEN_RESTRICTION_DELETE_PRIVS     4


#endif // WIN32_CHICAGO

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String,
    IN ULONG NameType
    );

KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_PRINCIPAL_NAME SourcePrincipalName
    );

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN KERB_REALM RealmName
    );

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    );

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN PUNICODE_STRING String
    );

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PKERB_REALM Realm
    );

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    );

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    );

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2
    );

BOOLEAN
KerbCompareStringToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    );

KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount
    );

KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    );

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    );

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    );

PKERB_AUTHORIZATION_DATA
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    );

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    );

KERBERR
KerbGetPacFromAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT PKERB_AUTHORIZATION_DATA * Pac
    );

KERBERR
KerbCreateApRequest(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

KERBERR
KerbBuildFullServiceName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING FullServiceName
    );

KERBERR
KerbBuildUnicodeSpn(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    );


KERBERR
KerbBuildEmailName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING EmailName
    );

KERBERR
KerbBuildFullServiceKdcName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    IN OPTIONAL PUNICODE_STRING UnicodeRealm
    );

KERBERR
KerbBuildKeySalt(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    );

KERBERR
KerbBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    OUT PUNICODE_STRING Salt
    );

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR * ErrorMessage
    );

KERBERR
KerbBuildExtendedError(
   IN PKERB_EXT_ERROR  pExtendedError,
   OUT PULONG          ExtErrorSize,
   OUT PBYTE*          ExtErrorData
   );



#ifdef __cplusplus
}   // extern "C"
#endif

//
// Socket functions
//

NTSTATUS
KerbInitializeSockets(
    IN ULONG VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    );

VOID
KerbCleanupSockets(
    );

NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    );

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    );

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    );

KERBERR
KerbDuplicateHostAddresses(
    OUT PKERB_HOST_ADDRESSES * DestAddresses,
    IN PKERB_HOST_ADDRESSES SourceAddresses
    );

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN PUNICODE_STRING String
    );

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PSTRING KerbString
    );

BOOLEAN
KerbMbStringToUnicodeString(
      PUNICODE_STRING     pDest,
      char *              pszString
      );

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME * KdcName
    );

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName
    );

BOOLEAN
KerbEqualKdcNames(
    IN PKERB_INTERNAL_NAME Name1,
    IN PKERB_INTERNAL_NAME Name2
    );

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName,
    OUT PBOOLEAN Result
    );

VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN PKERB_INTERNAL_NAME Name
    );

#define KERB_INTERNAL_NAME_SIZE(NameCount) (sizeof(KERB_INTERNAL_NAME) + ((NameCount) - ANYSIZE_ARRAY) * sizeof(UNICODE_STRING))

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN PUNICODE_STRING String
    );

NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    );

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING Realm
    );

NTSTATUS
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN PKERB_INTERNAL_NAME Source
    );

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

ULONG
KerbConvertFlagsToUlong(
    IN PVOID Flags
    );

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    );

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );

#ifdef __WINCRYPT_H__
KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    );

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    );

NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    );



NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString,
    IN BOOLEAN NullTerminate
    );


#if DBG

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN FILETIME *pFileTime
    );
#endif

#endif //  __WINCRYPT_H__

#endif // _KERBCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kerbscav.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        kerbscav.h
//
// Contents:    Scavenger (task automation) code
//
//
// History:     29-April-2001   Created         MarkPu
//
//------------------------------------------------------------------------

#ifndef __KERBSCAV_HXX_
#define __KERBSCAV_HXX_

#ifdef __cplusplus
extern "C" {
#endif

//
// Scavenger API
//

NTSTATUS
KerbInitializeScavenger();

NTSTATUS
KerbShutdownScavenger();

//
// A trigger function fires when it's time to execute a task
//
//      TaskHandle -- a context for KerbTask* functions
//      TaskItem -- context that was passed to KerbAddScavengerTask
//
// The scavenger code serializes the calls to trigger functions (NT timers don't)
//

typedef void ( *KERB_TASK_TRIGGER )( void * TaskHandle, void * TaskItem );

//
// A destroy function fires when the scavenger is done with a task and it will
// not be rescheduled.
//

typedef void ( *KERB_TASK_DESTROY )( void * TaskItem );

NTSTATUS
KerbAddScavengerTask(
    IN BOOLEAN Periodic,
    IN LONG Interval,
    IN ULONG Flags,
    IN KERB_TASK_TRIGGER pfnTrigger,
    IN KERB_TASK_DESTROY pfnDestroy,
    IN void * TaskItem
    );

//
// Task manipulation code to be used inside trigger functions
//

BOOLEAN
KerbTaskIsPeriodic(
    IN void * TaskHandle
    );

LONG
KerbTaskGetInterval(
    IN void * TaskHandle
    );

void
KerbTaskReschedule(
    IN void * TaskHandle,
    IN BOOLEAN Periodic,
    IN LONG Interval
    );

void
KerbTaskCancel(
    IN void * TaskHandle
    );

#ifdef __cplusplus
}
#endif

#endif // __KERBSCAV_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kerberr.h ===
//+-----------------------------------------------------------------------
//
// File:        kerberr.h
//
// Contents:    Security Status codes
//
// History:     <Whenever>  RichardW    Created secscode.h
//              26-May-93   RichardW    fixed dependency & conflict with scode.h
//              02-Jun-93   WadeR   Added FAILED and SUCCEDED macros
//              14-Jun-93   WadeR   Added "proper" kerberos errors, changed
//                                  to hex.
//              07-Jul-93   WadeR   Removed FAILED and SUCCEEDED macros
//              20-Sep-93   WadeR   Moved to $(SECURITY)\h\kerberr.h
//
//------------------------------------------------------------------------

#ifndef __KERBERR_H__
#define __KERBERR_H__




// Component specific errors:

//
// KERBERR is a kerberos-specific error. Make it a pointer to a structure
// to make sure we only return the correct error.
//

typedef LONG KERBERR, *PKERBERR;

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCEPTED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KERBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)
//
// These are local definitions that should not be sent over the network
//

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )
#define KDC_ERR_NOT_RUNNING           ((KERBERR) 0x80000002 )
#define KDC_ERR_NO_RESPONSE           ((KERBERR) 0x80000003 ) // used when we don't get a certain level of "goodness" in our response.

#endif // __KERBERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kpasswd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kpasswd.h
//
// Contents:    types for Kerberos change password
//
//
// History:     30-Sep-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KPASSWD_H__
#define __KPASSWD_H__


//
// Name of the kpasswd service
//


#define KERB_KPASSWD_NAME L"kadmin"

#define KERB_KPASSWD_VERSION 0x0001
#define KERB_KPASSWD_SET_VERSION 0xff80

#define SET_SHORT(_field_, _short_) \
{ \
    (_field_)[0] = ((_short_)&0xff00) >> 8; \
    (_field_)[1] = (_short_)&0xff; \
}

#define GET_SHORT( _short_,_field_) \
{ \
    (_short_) = ((_field_)[0] << 8) + (_field_)[1]; \
}

//
// Type for a kpasswd request
//

#include <pshpack1.h>
typedef struct _KERB_KPASSWD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_KPASSWD_REQ, *PKERB_KPASSWD_REQ;

//
// type for a kpasswd reply
//

typedef struct _KERB_KPASSWD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_KPASSWD_REP, *PKERB_KPASSWD_REP;


//
// Type for a set password request
//

typedef struct _KERB_SET_PASSWORD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_SET_PASSWORD_REQ, *PKERB_SET_PASSWORD_REQ;

//
// type for a set password reply
//

typedef struct _KERB_SET_PASSWORD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_SET_PASSWORD_REP, *PKERB_SET_PASSWORD_REP;
#include <poppack.h>

//
// Result codes:
//

#define KERB_KPASSWD_SUCCESS            0x0000
#define KERB_KPASSWD_MALFORMED          0x0001
#define KERB_KPASSWD_ERROR              0x0002
#define KERB_KPASSWD_AUTHENTICATION     0x0003
#define KERB_KPASSWD_POLICY             0x0004
#define KERB_KPASSWD_AUTHORIZATION      0x0005
#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\kerbsupp.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbsupp.h
//
// Contents:    prototypes for kerberos support routines
//
//
// History:
//
//------------------------------------------------------------------------

#ifndef _INC_KERBSUPP_
#define _INC_KERBSUPP_

#include <intkerb.h>
#include <tickets.h>
#include <crypto.h>
#include <samrpc.h>

//
// Global time constants
//
const TimeStamp tsInfinity = {0xFFFFFFFF, 0x7FFFFFFF};
const TimeStamp tsZero     = {0, 0};
const LONG      lInfinity  = 0x7FFFFFFF;

// Prototypes

#ifdef __cplusplus

class CAuthenticatorList;
class CLogonAccount;

//
// Contains domain account policies that are required for checking logon
// restrictions.
//
typedef struct _LogonPolicies {
   TimeStamp   MaxPasswordAge;
} LogonPolicies, *PLogonPolicies;


SECURITY_STATUS NTAPI
KerbCheckTicket(IN PKerbTicket                 pktTicket,
                IN PEncryptedData              pedAuth,
                IN const KerbKey&              kKey,
                IN OUT CAuthenticatorList&     alAuthenList,
                IN const TimeStamp&            tsSkew,
                IN const PWCHAR                pwzServiceName,
                OUT PKerbInternalTicket        pkitTicket,
                OUT PKerbInternalAuthenticator pkiaAuth,
                OUT PKerbKey                   pkSessionKey );

SECURITY_STATUS NTAPI
CheckLogonRestrictions( IN  SAMPR_HANDLE            UserHandle,
                        IN  const TimeStamp&        tsNow,
                        IN  const SECURITY_STRING&  sMachineName,
                        IN  PLogonPolicies          LogonData,
                        OUT PULONG                  pcLogonSeconds );


#endif // ifdef __cplusplus




#ifdef __cplusplus
extern "C" {
#endif

SECURITY_STATUS NTAPI
KerbPackTicket(     PKerbInternalTicket     pkitTicket,
                    PKerbKey                pkKey,
                    ULONG                   dwEncrType,
                    PKerbTicket *           ppktTicket);

SECURITY_STATUS NTAPI
KerbUnpackTicket(PKerbTicket, PKerbKey, PKerbInternalTicket);

SECURITY_STATUS NTAPI
KerbMakeKey(PKerbKey);

SECURITY_STATUS NTAPI
KerbRandomFill(PUCHAR, ULONG);

SECURITY_STATUS NTAPI
KerbCreateAuthenticator(IN  PKerbKey        pkKey,
                        IN  DWORD           dwEncrType,
                        IN  DWORD           dwSeq,
                        IN  PUNICODE_STRING ClientName,
                        IN  PUNICODE_STRING ClientDomainName,
                        IN  PTimeStamp      ptsTime,
                        IN  PKerbKey        pkSubKey,
                        IN OUT PULONG       pcbAuthenIn,
                        OUT PEncryptedData* ppedAuthenticator );

SECURITY_STATUS NTAPI
KerbUnpackAuthenticator(PKerbInternalTicket, PEncryptedData, PKerbInternalAuthenticator);

SECURITY_STATUS NTAPI
KerbPackKDCReply(PKerbKDCReply, PKerbKey, ULONG, PEncryptedData *);

SECURITY_STATUS NTAPI
KerbUnpackKDCReply(PEncryptedData, PKerbKey, PKerbKDCReply);

SECURITY_STATUS NTAPI
KerbFreeTicket( PKerbInternalTicket pkitTicket );

SECURITY_STATUS NTAPI
KerbFreeAuthenticator( PKerbInternalAuthenticator pkiaAuth );

SECURITY_STATUS NTAPI
KerbFreeKDCReply( PKerbKDCReply pkrReply );

void NTAPI
KerbHashPassword(PSECURITY_STRING, PKerbKey);

SECURITY_STATUS NTAPI
KIEncryptData(PEncryptedData, ULONG, ULONG, PKerbKey);

SECURITY_STATUS NTAPI
KIDecryptData(PEncryptedData, PKerbKey);

void * KerbSafeAlloc(unsigned long);
void KerbSafeFree(void *);


typedef struct _KerbScatterBlock {
    ULONG   cbData;
    PUCHAR  pbData;
} KerbScatterBlock, * PKerbScatterBlock;

#ifdef __CRYPTDLL_H__

SECURITY_STATUS NTAPI
KICheckSum( PUCHAR              pbData,
            ULONG               cbData,
            PCheckSumFunction   pcsfSum,
            PCheckSum           pcsCheckSum);


SECURITY_STATUS NTAPI
KICheckSumVerify(   PUCHAR       pbBuffer,
                    ULONG       cbBuffer,
                    PCheckSum   pcsCheck);


SECURITY_STATUS NTAPI
KIScatterEncrypt(   PUCHAR               pbHeader,
                    ULONG                cBlocks,
                    PKerbScatterBlock   psbList,
                    PCryptoSystem       pcsCrypt,
                    PCheckSumFunction   pcsfSum,
                    PKerbKey            pkKey);


SECURITY_STATUS NTAPI
KIScatterDecrypt(   PUCHAR              pbHeader,
                    ULONG               cBlocks,
                    PKerbScatterBlock   psbList,
                    PCryptoSystem       pcsCrypt,
                    PCheckSumFunction   pcsfSum,
                    PKerbKey            pkKey);

#endif // using CRYPTDLL.h defines

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _INC_KERBSUPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct TYPED_DATA_s * PTYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_EXT_ERROR)

typedef struct TYPED_DATA_s {
    PTYPED_DATA next;
    KERB_TYPED_DATA value;
} TYPED_DATA_Element, *TYPED_DATA;
#define TYPED_DATA_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(TYPED_DATA_Element)

typedef struct KERB_PA_FOR_USER {
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\common2\krb5.c ===
#include "krbprgma.h"
#include <windows.h>
#include "krb5.h"

ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[49] = {
    (ASN1EncFun_t) ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) ASN1Enc_TYPED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[49] = {
    (ASN1DecFun_t) ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) ASN1Dec_TYPED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[49] = {
    (ASN1FreeFun_t) ASN1Free_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_PKERB_PREAUTH_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_PRIV,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTION_KEY,
    (ASN1FreeFun_t) ASN1Free_KERB_CHECKSUM,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_PKERB_ETYPE_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PKCS_SIGNATURE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE2,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_DH_KEY_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_SERV_REFERRAL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_CHANGE_PASSWORD_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR_METHOD_DATA,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_TYPED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_FOR_USER,
    (ASN1FreeFun_t) ASN1Free_KERB_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTHENTICATOR,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SAFE_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PRIV_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTH_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP2,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ2,
};
static const ULONG sizetab[49] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 49, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = lstrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = lstrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TYPED_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PTYPED_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TYPED_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val)
{
    PTYPED_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TYPED_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = lstrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\krb5p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krb5p.h
//
// Contents:    pointer type definitions for ASN.1 stub types
//
//
// History:     8-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERB5P_H__
#define __KERB5P_H__

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_EXT_ERROR *PKERB_EXT_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;
typedef KERB_PA_FOR_USER *PKERB_PA_FOR_USER;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;
#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_cname_in_addl_tkt 0x00020000
#define                     KERB_KDC_OPTIONS_cname_in_pa_data  0x00040000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001


#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses


#endif // __KERB5P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\cpgssutl.cxx ===
/*++                                                                        
                                                                            
Copyright (c) 1991  Microsoft Corporation                                   
                                                                            
Module Name:                                                                
                                                                            
    cpgssutl.c                                                                
                                                                            
Abstract:                                                                   
                                                                            
    include file for private\net\netlib\data.c                              
                                                                            
Author:                                                                     
                                                                            
    Chandana Surlu (ChandanS) 09-Apr-1998                                   
                                                                            
Environment:                                                                
                                                                            
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)       
    Requires ANSI C extensions: slash-slash comments, long external names.  
                                                                            
Revision History:                                                           
                                                                            
    09-Apr-1998 ChandanS                                                    
        Created.                                                            
--*/                                                                        
                                                                            
#include "..\client2\gssutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\userall.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        userall.h
//
// Contents:    Flags for prefetching for SAM information
//
//
// History:     23-March-2001       Created     MarkPu
//
//------------------------------------------------------------------------

#ifndef __USERALL_H
#define __USERALL_H

const ULONG USER_ALL_PAC_BUILD_CREDENTIALS =
    USER_ALL_LMPASSWORDPRESENT |
    USER_ALL_OWFPASSWORD |
    USER_ALL_NTPASSWORDPRESENT;

const ULONG USER_ALL_KDC_GET_USER_KEYS =
    USER_ALL_LMPASSWORDPRESENT |
    USER_ALL_OWFPASSWORD |
    USER_ALL_NTPASSWORDPRESENT |
    USER_ALL_PRIVATEDATA |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_USERNAME;

const ULONG USER_ALL_KDC_BUILD_SUPPLEMENTAL_CREDENTIALS =
    USER_ALL_PAC_BUILD_CREDENTIALS;

const ULONG USER_ALL_PAC_MARSHALL_VALIDATION_INFO =
    USER_ALL_ACCOUNTEXPIRES |
    USER_ALL_BADPASSWORDCOUNT |
    USER_ALL_FULLNAME |
    USER_ALL_HOMEDIRECTORY |
    USER_ALL_HOMEDIRECTORYDRIVE |
    USER_ALL_LASTLOGON |
    USER_ALL_LOGONCOUNT |
    USER_ALL_PARAMETERS |
    USER_ALL_PASSWORDCANCHANGE |
    USER_ALL_PASSWORDLASTSET |
    USER_ALL_PASSWORDMUSTCHANGE |
    USER_ALL_PRIMARYGROUPID |
    USER_ALL_PROFILEPATH |
    USER_ALL_SCRIPTPATH |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_USERNAME;

const ULONG USER_ALL_PAC_INIT =
    USER_ALL_PAC_MARSHALL_VALIDATION_INFO;

const ULONG USER_ALL_GET_PAC_AND_SUPP_CRED =
    USER_ALL_KDC_BUILD_SUPPLEMENTAL_CREDENTIALS |
    USER_ALL_PAC_INIT;

const ULONG USER_ALL_KDC_GET_PAC_AUTH_DATA =
    USER_ALL_GET_PAC_AND_SUPP_CRED;

const ULONG USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS =
    USER_ALL_ACCOUNTEXPIRES |
    USER_ALL_LOGONHOURS |
    USER_ALL_PASSWORDMUSTCHANGE |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_WORKSTATIONS;

const ULONG USER_ALL_KDC_CHECK_PREAUTH_DATA =
    USER_ALL_USERACCOUNTCONTROL;

const ULONG USER_ALL_SUCCESSFUL_LOGON =
    USER_ALL_BADPASSWORDCOUNT;

#endif // __USERALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\krbprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    krbprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let Kerberos compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\inc\secmisc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:        secmisc.h
//
//  Contents:    Helper functions and macros for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    10-Dec-91 Richardw    Created
//
//--------------------------------------------------------------------------

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif



///////////////////////////////////////////////////////////////////////////
//
//  Common TimeStamp Manipulation Functions
//
///////////////////////////////////////////////////////////////////////////


// Functions to get/set current local time, or time in UTC:

void    GetCurrentTimeStamp(PLARGE_INTEGER);

// Some convenient "functions"




//
//  BOOL
//  TSIsZero(PLARGE_INTEGER pTS)
//
#define TSIsZero(pTS)   ((pTS)->QuadPart == 0)


#define SetMaxTimeStamp(ts)      \
        (ts).HighPart = 0x7FFFFFFF; \
        (ts).LowPart = 0xFFFFFFFF;

#define SetZeroTimeStamp(ts)      \
        (ts).QuadPart = 0;

void    AddSecondsToTimeStamp(PLARGE_INTEGER, ULONG);
BOOLEAN TSIsNearlyLessThan(PLARGE_INTEGER, PLARGE_INTEGER, PLARGE_INTEGER, LONG);
ULONG   TimeStampDiffInSeconds( PLARGE_INTEGER t1, PLARGE_INTEGER t2);

#define TS_NO_TEND          0
#define TS_TEND_TO_FALSE    1
#define TS_TEND_TO_TRUE     2



// RPC transport constants and routines

#define TRANS_NB        0
#define TRANS_XNS       1
#define TRANS_TCPIP     2
#define TRANS_NP        3

NTSTATUS
GetRpcTransports(PDWORD         pTransports);


NTSTATUS
NewQueryValue(  HKEY            hKey,
                LPWSTR          Key,
                PBYTE *         pValue,
                PULONG          pcbValue);

NTSTATUS
GetMachineName( LPWSTR *        pszMachName);

NTSTATUS
GetLocalDomain( LPWSTR *        pszLocalDomain);

typedef enum _MACHINE_STATE {
    Standalone,
    Workstation,
    StandardServer,
    BackupDomainController,
    DomainController
} MACHINE_STATE;

MACHINE_STATE
GetMachineState(VOID);


//
// Misc. checking routines
//

void
SRtlCheckSecBufferDesc( PSecBufferDesc pData);

void
SRtlCheckSecBuffer( PSecBuffer pBuffer);






#ifdef __cplusplus
}
#endif


#endif  // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kerbcli\changepw.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        changepw.cxx
//
// Contents:    Code for KerbSetPassword and KerbChangePassword
//
//
// History:     24-May-1999     MikeSw          Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <sspi.h>
#include <ntsecapi.h>
#include <align.h>
#include <dsgetdc.h>
#include <kerbcli.h>




//+-------------------------------------------------------------------------
//
//  Function:   KerbChangePasswordUserEx
//
//  Synopsis:   Changes a users password. If the user is logged on,
//              it also updates the in-memory password.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbChangePasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response = NULL ;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(
                &LogonHandle
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    if ( OldPass.Length > (127*sizeof(WCHAR)) ||
         NewPass.Length > (127*sizeof(WCHAR)) )
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );
    if (NULL == ChangeRequest)
    {
        goto Cleanup;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
        goto Cleanup;
    }

Cleanup:

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (ChangeRequest != NULL)
    {
        LocalFree(ChangeRequest);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordUserEx
//
//  Synopsis:   Sets a password for a user in the specified domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSetPasswordUserEx(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle,
    IN OPTIONAL LPWSTR  KdcAddress
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response = NULL;
    ULONG ResponseSize;
    KERB_PROTOCOL_MESSAGE_TYPE MessageType = KerbSetPasswordMessage;
    NTSTATUS SubStatus;
    PKERB_SETPASSWORD_EX_REQUEST SetRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass, KdcAddr, ClientName, ClientRealm;
    
    // If you supply a KdcAddress, you must supply name type
    if (ARGUMENT_PRESENT(KdcAddress))
    {
       MessageType = KerbSetPasswordExMessage;
       
       RtlInitUnicodeString(
          &KdcAddr,
          KdcAddress
          );  
    } 
    else                                     
    {         
       RtlInitUnicodeString(
          &KdcAddr,
          NULL
          );  
    }
    
    Status = LsaConnectUntrusted(
                &LogonHandle
                );      

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    // These aren't used here (yet)
    RtlInitUnicodeString(
        &ClientName,
        NULL
        );
    
    RtlInitUnicodeString(
        &ClientRealm,
        NULL
        );          

    if ( NewPass.Length > (127 * sizeof(WCHAR)) )
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_SETPASSWORD_EX_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    NewPass.Length +
                                    KdcAddr.Length +
                                    ClientName.Length +
                                    ClientRealm.Length;

    SetRequest = (PKERB_SETPASSWORD_EX_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );
    if (NULL == SetRequest)
    {
        goto Cleanup;
    }

    SetRequest->MessageType = MessageType;
    SetRequest->KdcAddressType = DS_UNKNOWN_ADDRESS_TYPE;
    SetRequest->AccountRealm = Domain;
    SetRequest->AccountRealm.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_SETPASSWORD_EX_REQUEST) + (PBYTE) SetRequest,4);

    RtlCopyMemory(
        SetRequest->AccountRealm.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    SetRequest->AccountName = User;
    SetRequest->AccountName.Buffer = SetRequest->AccountRealm.Buffer + SetRequest->AccountRealm.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );


    SetRequest->Password = NewPass;
    SetRequest->Password.Buffer = SetRequest->AccountName.Buffer + SetRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->Password.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );
    
    // Not yet implemented
    SetRequest->ClientRealm = ClientRealm;
    SetRequest->ClientRealm.Buffer = SetRequest->Password.Buffer + SetRequest->Password.Length / sizeof(WCHAR);
         
    RtlCopyMemory(
         SetRequest->ClientRealm.Buffer,
         ClientRealm.Buffer,
         ClientRealm.Length   
         );                  
                           
    SetRequest->ClientName  = ClientName;
    SetRequest->ClientName.Buffer = SetRequest->ClientRealm.Buffer + SetRequest->ClientRealm.Length / sizeof(WCHAR);
                                    
    RtlCopyMemory(                    
        SetRequest->ClientName.Buffer,    
        ClientName.Buffer,                      
        ClientName.Length                          
        );
    //      

    SetRequest->KdcAddress = KdcAddr;
    SetRequest->KdcAddress.Buffer = SetRequest->ClientRealm.Buffer + SetRequest->ClientRealm.Length / sizeof(WCHAR);

    RtlCopyMemory(
       SetRequest->KdcAddress.Buffer,
       KdcAddr.Buffer,
       KdcAddr.Length
       );

    if (ARGUMENT_PRESENT(CredentialsHandle))
    {
        SetRequest->CredentialsHandle = *CredentialsHandle;
        SetRequest->Flags |= KERB_SETPASS_USE_CREDHANDLE;
    }

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                SetRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
        goto Cleanup;
    }

Cleanup:

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }                  

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (SetRequest != NULL)
    {
        LocalFree(SetRequest);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordUser
//
//  Synopsis:   Sets a password for a user in the specified domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbSetPasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle
    )
{
    
   return(KerbSetPasswordUserEx(
                  DomainName,
                  UserName,
                  NewPassword,
                  CredentialsHandle,
                  NULL
                  ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\ctxtmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.cxx
//
// Contents:    Code for managing contexts list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#define CTXTMGR_ALLOCATE
#include <kerbkrnl.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitContextList)
#pragma alloc_text(PAGE, KerbFreeContextList)
#pragma alloc_text(PAGEMSG, KerbAllocateContext)
#pragma alloc_text(PAGEMSG, KerbInsertContext)
#pragma alloc_text(PAGEMSG, KerbReferenceContext)
#pragma alloc_text(PAGEMSG, KerbDereferenceContext)
#pragma alloc_text(PAGEMSG, KerbReferenceContextByPointer)
#pragma alloc_text(PAGEMSG, KerbReferenceContextByLsaHandle)
#pragma alloc_text(PAGEMSG, KerbCreateKernelModeContext)
#endif


#define MAYBE_PAGED_CODE()  \
    if ( KerbPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitContextList
//
//  Synopsis:   Initializes the contexts list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitContextList(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = ExInitializeResourceLite( &KerbContextResource );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = KerbInitializeList( &KerbContextList );

    if (!NT_SUCCESS(Status))
    {
        ExDeleteResourceLite( &KerbContextResource );
        goto Cleanup;
    }
    KerberosContextsInitialized = TRUE;

Cleanup:

    return(Status);
}

#if 0
//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContextList
//
//  Synopsis:   Frees the contexts list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeContextList(
    VOID
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_KERNEL_CONTEXT Context;

    PAGED_CODE();

    if (KerberosContextsInitialized)
    {
        KerbLockList(&KerbContextList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbContextList.List))
        {
            Context = CONTAINING_RECORD(
                            KerbContextList.List.Flink,
                            KERB_KERNEL_CONTEXT,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbContextList,
                (PKERBEROS_LIST_ENTRY) Context,
                TRUE
                );

            KerbDereferenceContext(Context);

        }

        KerbUnlockList(&KerbContextList);
        KerbFreeList(&KerbContextList);
    }
}
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateContext
//
//  Synopsis:   Allocates a Context structure
//
//  Effects:    Allocates a Context, but does not add it to the
//              list of Contexts
//
//  Arguments:  NewContext - receives a new Context allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateContext(
    PKERB_KERNEL_CONTEXT * NewContext
    )
{
    PKERB_KERNEL_CONTEXT Context;
    NTSTATUS Status;

    MAYBE_PAGED_CODE();

    //
    // Get the client process ID if we are running in the LSA
    //


    Context = (PKERB_KERNEL_CONTEXT) KerbAllocate(
                        sizeof(KERB_KERNEL_CONTEXT) );

    if (Context == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(
        Context,
        sizeof(KERB_KERNEL_CONTEXT)
        );

    KsecInitializeListEntry( &Context->List, KERB_CONTEXT_SIGNATURE );

    *NewContext = Context;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertContext
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Context - Context to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    MAYBE_PAGED_CODE();

    KSecInsertListEntry(
        KerbActiveList,
        (PKSEC_LIST_ENTRY) Context
        );

    return(STATUS_SUCCESS);
}

#if 0
//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByLsaHandle
//
//  Synopsis:   Locates a context by lsa handle and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_KERNEL_CONTEXT
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_KERNEL_CONTEXT Context = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CLIENT_INFO ClientInfo;
    NTSTATUS Status;

    PAGED_CODE();

    KerbLockList(&KerbContextList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    for (ListEntry = KerbContextList.List.Flink ;
         ListEntry !=  &KerbContextList.List ;
         ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KERB_KERNEL_CONTEXT, ListEntry.Next);
        if (ContextHandle == Context->LsaContextHandle)
        {


            KerbReferenceListEntry(
                &KerbContextList,
                (PKERBEROS_LIST_ENTRY) Context,
                RemoveFromList
                );


            Found = TRUE;
            break;
        }

    }

    if (!Found)
    {
        Context = NULL;
    }
    KerbUnlockList(&KerbContextList);
    return(Context);
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContext
//
//  Synopsis:   Locates a context and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Lsa Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_KERNEL_CONTEXT
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    NTSTATUS Status;

    MAYBE_PAGED_CODE();

    Status = KSecReferenceListEntry(
                    (PKSEC_LIST_ENTRY) ContextHandle,
                    KERB_CONTEXT_SIGNATURE,
                    RemoveFromList );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PKERB_KERNEL_CONTEXT) ContextHandle ;
    }

    //
    // In kernel mode we trust the caller to provide a valid pointer, but
    // make sure it is a kernel mode pointer.
    //


    return(Context);
}

#if 0
//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByPointer
//
//  Synopsis:   References a context by the context pointer itself.
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  Context - The context to reference.
//              RemoveFromList - If TRUE, context will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceContextByPointer(
    IN PKERB_KERNEL_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    )
{
    PAGED_CODE();

    KerbLockList(&KerbContextList);

    KerbReferenceListEntry(
        &KerbContextList,
        (PKERBEROS_LIST_ENTRY) Context,
        RemoveFromList
        );

    if (RemoveFromList)
    {
        Context->ContextSignature = KERB_CONTEXT_DELETED_SIGNATURE;
    }

    KerbUnlockList(&KerbContextList);
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContext
//
//  Synopsis:   Frees a context that is unlinked
//
//  Effects:    frees all storage associated with the context
//
//  Arguments:  Context - context to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    PAGED_CODE();

    if (Context->TokenHandle != NULL)
    {
        NtClose(Context->TokenHandle);
    }
    if (Context->AccessToken != NULL)
    {
        ObDereferenceObject( Context->AccessToken );
    }

    if (Context->FullName.Buffer != NULL)
    {
        KerbFree(Context->FullName.Buffer);
    }
    if (Context->SessionKey.keyvalue.value != NULL)
    {
        KerbFree(Context->SessionKey.keyvalue.value);
    }

    if (Context->pbMarshalledTargetInfo != NULL)
    {
        KerbFree(Context->pbMarshalledTargetInfo);
    }
    KerbFree(Context);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceContext
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Context - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    BOOLEAN Delete ;

    MAYBE_PAGED_CODE();

    KSecDereferenceListEntry(
        (PKSEC_LIST_ENTRY) Context,
        &Delete );

    if ( Delete )
    {
        KerbFreeContext( Context );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateKernelModeContext
//
//  Synopsis:   Creates a kernel-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateKernelModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_KERNEL_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PKERB_PACKED_CONTEXT PackedContext ;
    PUCHAR Where;

    PAGED_CODE();

    if (MarshalledContext->cbBuffer < sizeof(KERB_PACKED_CONTEXT))
    {
        DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PKERB_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Status = KerbAllocateContext( &Context );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KsecInitializeListEntry( &Context->List, KERB_CONTEXT_SIGNATURE );

    Context->Lifetime = PackedContext->Lifetime;
    Context->RenewTime = PackedContext->RenewTime;
    Context->Nonce = PackedContext->Nonce;
    Context->ReceiveNonce = PackedContext->ReceiveNonce;
    Context->ContextFlags = PackedContext->ContextFlags;
    Context->ContextAttributes = PackedContext->ContextAttributes;
    Context->EncryptionType = PackedContext->EncryptionType;

    Context->LsaContextHandle = ContextHandle;
    Context->ReceiveNonce = Context->Nonce;
    Context->TokenHandle = (HANDLE) ULongToPtr(PackedContext->TokenHandle);

    //
    // Fill in the full name, which is the concatenation of the client name
    // and client realm with a '\\' separator
    //

    Context->FullName.MaximumLength = PackedContext->ClientName.Length +
                                PackedContext->ClientRealm.Length +
                                sizeof(WCHAR);
    Context->FullName.Buffer = (LPWSTR) KerbAllocate(Context->FullName.MaximumLength);
    if (Context->FullName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) Context->FullName.Buffer;
    if (PackedContext->ClientRealm.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) PackedContext + (ULONG_PTR) PackedContext->ClientRealm.Buffer,
            PackedContext->ClientRealm.Length
            );
        Where += PackedContext->ClientRealm.Length;
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }

    if (PackedContext->ClientName.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) PackedContext + (ULONG_PTR) PackedContext->ClientName.Buffer,
            PackedContext->ClientName.Length
            );
        Where += PackedContext->ClientName.Length;
    }

    Context->FullName.Length = (USHORT) (Where - (PUCHAR) Context->FullName.Buffer);

    //
    // Copy in the session key
    //



    Context->SessionKey.keytype = PackedContext->SessionKeyType;
    Context->SessionKey.keyvalue.length = PackedContext->SessionKeyLength;
    if (Context->SessionKey.keyvalue.length != 0)
    {
        Context->SessionKey.keyvalue.value = (PUCHAR) KerbAllocate( Context->SessionKey.keyvalue.length );
        if (Context->SessionKey.keyvalue.value == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->SessionKey.keyvalue.value,
            (PUCHAR) PackedContext + PackedContext->SessionKeyOffset,
            Context->SessionKey.keyvalue.length
            );

    }


    //
    // copy in the marshalled target info.
    //

    Context->cbMarshalledTargetInfo = PackedContext->MarshalledTargetInfoLength;
    if (PackedContext->MarshalledTargetInfo)
    {
        Context->pbMarshalledTargetInfo = (PUCHAR) KerbAllocate( Context->cbMarshalledTargetInfo );
        if (Context->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->pbMarshalledTargetInfo,
            (PUCHAR) PackedContext + PackedContext->MarshalledTargetInfo,
            Context->cbMarshalledTargetInfo
            );

    } else {
        Context->pbMarshalledTargetInfo = NULL;
    }

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to insert context: 0x%x\n",Status));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}
#if 0
NTSTATUS
KerbCreateKernelModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_KERNEL_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PKERB_CONTEXT LsaContext;
    PUCHAR Where;

    PAGED_CODE();

    if (MarshalledContext->cbBuffer < sizeof(KERB_CONTEXT))
    {
        DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    LsaContext = (PKERB_CONTEXT) MarshalledContext->pvBuffer;

    Status = KerbAllocateContext( &Context );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KsecInitializeListEntry( &Context->List, KERB_CONTEXT_SIGNATURE );

    Context->Lifetime = LsaContext->Lifetime;
    Context->RenewTime = LsaContext->RenewTime;
    Context->Nonce = LsaContext->Nonce;
    Context->ReceiveNonce = LsaContext->ReceiveNonce;
    Context->ContextFlags = LsaContext->ContextFlags;
    Context->ContextAttributes = LsaContext->ContextAttributes;
    Context->EncryptionType = LsaContext->EncryptionType;

    Context->LsaContextHandle = ContextHandle;
    Context->ReceiveNonce = Context->Nonce;
    Context->TokenHandle = LsaContext->TokenHandle;

    //
    // Fill in the full name, which is the concatenation of the client name
    // and client realm with a '\\' separator
    //

    Context->FullName.MaximumLength = LsaContext->ClientName.Length +
                                LsaContext->ClientRealm.Length +
                                sizeof(WCHAR);
    Context->FullName.Buffer = (LPWSTR) KerbAllocate(Context->FullName.MaximumLength);
    if (Context->FullName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) Context->FullName.Buffer;
    if (LsaContext->ClientRealm.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) LsaContext + (ULONG_PTR) LsaContext->ClientRealm.Buffer,
            LsaContext->ClientRealm.Length
            );
        Where += LsaContext->ClientRealm.Length;
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }

    if (LsaContext->ClientName.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) LsaContext + (ULONG_PTR) LsaContext->ClientName.Buffer,
            LsaContext->ClientName.Length
            );
        Where += LsaContext->ClientName.Length;
    }

    Context->FullName.Length = (USHORT) (Where - (PUCHAR) Context->FullName.Buffer);

    //
    // Copy in the session key
    //


    LsaContext->SessionKey.keyvalue.value = (PUCHAR) LsaContext->SessionKey.keyvalue.value + (ULONG_PTR) LsaContext;

    Context->SessionKey.keytype = LsaContext->SessionKey.keytype;
    Context->SessionKey.keyvalue.length = LsaContext->SessionKey.keyvalue.length;
    if (Context->SessionKey.keyvalue.length != 0)
    {
        Context->SessionKey.keyvalue.value = (PUCHAR) KerbAllocate(LsaContext->SessionKey.keyvalue.length);
        if (Context->SessionKey.keyvalue.value == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->SessionKey.keyvalue.value,
            LsaContext->SessionKey.keyvalue.value,
            LsaContext->SessionKey.keyvalue.length
            );

    }

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to insert context: 0x%x\n",Status));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\kerbkrnl.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbp.h
//
// Contents:    global include file for Kerberos security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBP_H__
#define __KERBP_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines KERBP_ALLOCATE
//


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

extern "C"
{
#include <ntosp.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <winerror.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#include <zwapi.h>
}
extern "C"
{
#include "kerblist.h"
#include "ctxtmgr.h"
}

//
// Macros for package information
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBKRNL_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // KERBP_ALLOCATE


//
// Global state variables
//

EXTERN ULONG KerberosPackageId;
extern PSECPKG_KERNEL_FUNCTIONS KernelFunctions;

//
// Useful macros
//
#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //ifndef INVALID_HANDLE_VALUE

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

extern PVOID KerbPagedList ;
extern PVOID KerbNonPagedList ;
extern PVOID KerbActiveList ;
extern POOL_TYPE KerbPoolType ;

#define KerbAllocate( _x_ ) ExAllocatePoolWithTag( KerbPoolType, (_x_) ,  'CbrK')
#define KerbFree( _x_ ) ExFreePool(_x_)


#if DBG


#define DEB_ERROR               0x00000001
#define DEB_WARN                0x00000002
#define DEB_TRACE               0x00000004
#define DEB_TRACE_LOCKS         0x00010000

extern "C"
{
void KsecDebugOut(ULONG, const char *, ...);
}

#define DebugLog(x) KsecDebugOut x

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __KERBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\kerblist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.cxx
//
// Contents:    Common list code for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------
#include <kerbkrnl.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitializeList)
#pragma alloc_text(PAGE, KerbFreeList)
#pragma alloc_text(PAGEMSG, KerbInitializeListEntry)
#pragma alloc_text(PAGEMSG, KerbInsertListEntry)
#pragma alloc_text(PAGEMSG, KerbReferenceListEntry)
#pragma alloc_text(PAGEMSG, KerbDereferenceListEntry)
#pragma alloc_text(PAGEMSG, KerbValidateListEx)
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeList
//
//  Synopsis:   Initializes a kerberos list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    InitializeListHead(&List->List);

    Status = ExInitializeResourceLite(
                &List->Lock
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeList
//
//  Synopsis:   Frees a kerberos list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    )
{
    PAGED_CODE();
    //
    // Make sure the list is empty first
    //

    ASSERT(List->List.Flink == List->List.Blink);
    ExDeleteResourceLite(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    )
{
    PAGED_CODE();
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntry
//
//  Synopsis:   Inserts an entry into a kerberos list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    PAGED_CODE();
    ListEntry->ReferenceCount++;

    KerbLockList(List);

    KerbValidateList(List);

    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);


    KerbUnlockList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{
    PAGED_CODE();
    KerbValidateList(List);

    if (RemoveFromList)
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else
    {
        ListEntry->ReferenceCount++;
    }

    KerbValidateList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    PAGED_CODE();
    KerbLockList(List);
    KerbValidateList(List);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    KerbValidateList(List);

    KerbUnlockList(List);
    return(DeleteEntry);
}


#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateListEx
//
//  Synopsis:   Validates that a list is valid
//
//  Effects:    traverses a list to make sure it is has no loops
//
//  Arguments:  List - The list to validate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      This routine assumes there are less than 1000 entries
//              in the list.
//
//
//--------------------------------------------------------------------------

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;

    PAGED_CODE();
    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if (++Entries > 1000) {
            DebugLog((DEB_ERROR,"List is looping - more than 1000 entries found\n"));
            DbgBreakPoint();
            break;
        }
    }

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\ctxtmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.h
//
// Contents:    Structures and prototyps for Kerberos context list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CTXTMGR_H__
#define __CTXTMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CTXTMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CTXTMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN ERESOURCE KerbContextResource;
EXTERN KERBEROS_LIST KerbContextList;
EXTERN BOOLEAN KerberosContextsInitialized;

#define KerbGetContextHandle(_Context_) ((ULONG_PTR)(_Context_))

//
// Context flags - these are attributes of a context and are stored in
// the ContextAttributes field of a KERB_KERNEL_CONTEXT.
//

#define KERB_CONTEXT_MAPPED       0x1
#define KERB_CONTEXT_OUTBOUND     0x2
#define KERB_CONTEXT_INBOUND      0x4
#define KERB_CONTEXT_USER_TO_USER 0x10
#define KERB_CONTEXT_IMPORTED     0x80
#define KERB_CONTEXT_EXPORTED     0x100

//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#define KerbWriteLockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n"));         \
        KeEnterCriticalRegion();                                        \
        ExAcquireResourceExclusiveLite(&KerbContextResource,TRUE);      \
    }                                                                   \
}
#define KerbReadLockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n"));          \
        KeEnterCriticalRegion();                                        \
        ExAcquireSharedWaitForExclusive(&KerbContextResource, TRUE);    \
    }                                                                   \
}
#define KerbUnlockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n"));             \
        ExReleaseResourceLite(&KerbContextResource);                    \
        KeLeaveCriticalRegion();                                        \
    }                                                                   \
}

NTSTATUS
KerbInitContextList(
    VOID
    );

VOID
KerbFreeContextList(
    VOID
    );


NTSTATUS
KerbAllocateContext(
    PKERB_KERNEL_CONTEXT * NewContext
    );

NTSTATUS
KerbInsertContext(
    IN PKERB_KERNEL_CONTEXT Context
    );


PKERB_KERNEL_CONTEXT
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    );


VOID
KerbDereferenceContext(
    IN PKERB_KERNEL_CONTEXT Context
    );


VOID
KerbReferenceContextByPointer(
    IN PKERB_KERNEL_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    );

PKERB_KERNEL_CONTEXT
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    );



NTSTATUS
KerbCreateKernelModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_KERNEL_CONTEXT * NewContext
    );



#endif // __CTXTMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\kerblist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.h
//
// Contents:    types for Kerbers internal lists
//
//
// History:     16-Apr-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBLIST_H__
#define __KERBLIST_H__


//
// Generic list entry structure allowing common code for inserting
// logon sessions, credentials, and contexts.
//

typedef struct _KERBEROS_LIST {
    LIST_ENTRY List;
    ERESOURCE Lock;
} KERBEROS_LIST, *PKERBEROS_LIST;

typedef struct _KERBEROS_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} KERBEROS_LIST_ENTRY, *PKERBEROS_LIST_ENTRY;




typedef enum _KERB_CONTEXT_STATE {
    IdleState,
    TgtRequestSentState,
    TgtReplySentState,
    ApRequestSentState,
    ApReplySentState,
    AuthenticatedState,
    ErrorMessageSentState,
    InvalidState
} KERB_CONTEXT_STATE, *PKERB_CONTEXT_STATE;

//
// Guards - this structure is defined in krb5.h
//

#ifndef OSS_krb5
typedef struct KERB_ENCRYPTION_KEY {
    int             keytype;
    struct {
        unsigned int    length;
        unsigned char   *value;
    } keyvalue;
} KERB_ENCRYPTION_KEY;
#endif

#define KERB_CONTEXT_SIGNATURE 'BREK'
#define KERB_CONTEXT_DELETED_SIGNATURE 'XBRK'

typedef struct _KERB_KERNEL_CONTEXT {
    KSEC_LIST_ENTRY List ;
    LARGE_INTEGER Lifetime;             // end time/expiration time
    LARGE_INTEGER RenewTime;            // time to renew until
    UNICODE_STRING FullName;
    LSA_SEC_HANDLE LsaContextHandle;
    PACCESS_TOKEN AccessToken;
    HANDLE TokenHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG EncryptionType;
    PUCHAR pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;
} KERB_KERNEL_CONTEXT, *PKERB_KERNEL_CONTEXT;



typedef struct _KERB_CONTEXT {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp Lifetime;             // end time/expiration time
    TimeStamp RenewTime;            // time to renew until
    TimeStamp StartTime;
    UNICODE_STRING ClientName;
    UNICODE_STRING ClientRealm;
    union {
        ULONG ClientProcess;
        ULONG LsaContextHandle;
    };
    LUID LogonId;
    HANDLE TokenHandle;
    ULONG CredentialHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG EncryptionType;
    PSID UserSid;
    KERB_CONTEXT_STATE ContextState;
    ULONG Retries;
    KERB_ENCRYPTION_KEY TicketKey;
    PVOID TicketCacheEntry;
    //
    // marshalled target info for DFS/RDR.
    //

    PUCHAR pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;
} KERB_CONTEXT, *PKERB_CONTEXT;

typedef struct _KERB_PACKED_CONTEXT {
    ULONG   ContextType ;               // Indicates the type of the context
    ULONG   Pad;                        // Pad data
    TimeStamp Lifetime;                 // Matches basic context above
    TimeStamp RenewTime ;
    TimeStamp StartTime;
    UNICODE_STRING32 ClientName ;
    UNICODE_STRING32 ClientRealm ;
    ULONG LsaContextHandle ;
    LUID LogonId ;
    ULONG TokenHandle ;
    ULONG CredentialHandle ;
    ULONG SessionKeyType ;
    ULONG SessionKeyOffset ;
    ULONG SessionKeyLength ;
    ULONG Nonce ;
    ULONG ReceiveNonce ;
    ULONG ContextFlags ;
    ULONG ContextAttributes ;
    ULONG EncryptionType ;
    KERB_CONTEXT_STATE ContextState ;
    ULONG Retries ;
    ULONG MarshalledTargetInfo; // offset
    ULONG MarshalledTargetInfoLength;
} KERB_PACKED_CONTEXT, * PKERB_PACKED_CONTEXT ;

#define KERB_PACKED_CONTEXT_MAP     0
#define KERB_PACKED_CONTEXT_EXPORT  1


//
// Functions for manipulating Kerberos lists
//


NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );


VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    );

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    );

#if DBG
#define KerbValidateList(_List_) KerbValidateListEx(_List_)
#else
#define KerbValidateList(_List_)
#endif // DBG


#define KerbLockList(_List_)                                \
{                                                           \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(&(_List_)->Lock, TRUE ); \
}

#define KerbUnlockList(_List_)                              \
{                                                           \
    ExReleaseResourceLite(&(_List_)->Lock);                 \
    KeLeaveCriticalRegion();                                \
}

#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\krnlapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krnlapi.h
//
// Contents:    Structures and prototypes for kernel mode Kerberos functions
//
//
// History:     3-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KRNLAPI_H__
#define __KRNLAPI_H__

typedef unsigned char  BYTE, *PBYTE;

#define USERAPI_ALLOCATE
#include "..\client2\userapi.h"

#define KERB_SAFE_SALT                  15

#define KERB_SIGNATURE_SIZE 10

#define KERBEROS_CAPABILITIES ( SECPKG_FLAG_INTEGRITY | \
                                SECPKG_FLAG_PRIVACY | \
                                SECPKG_FLAG_TOKEN_ONLY | \
                                SECPKG_FLAG_DATAGRAM | \
                                SECPKG_FLAG_CONNECTION | \
                                SECPKG_FLAG_MULTI_REQUIRED | \
                                SECPKG_FLAG_EXTENDED_ERROR | \
                                SECPKG_FLAG_IMPERSONATION | \
                                SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                                SECPKG_FLAG_NEGOTIABLE | \
                                SECPKG_FLAG_GSS_COMPATIBLE | \
                                SECPKG_FLAG_LOGON | \
                                SECPKG_FLAG_MUTUAL_AUTH | \
                                SECPKG_FLAG_DELEGATION )


#define KERBEROS_MAX_TOKEN 12000
#define KERBEROS_PACKAGE_NAME L"Kerberos"
#define KERBEROS_PACKAGE_COMMENT L"Microsoft Kerberos V1.0"
#define KERB_PARAMETER_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"
#define KERB_PARAMETER_MAX_TOKEN_SIZE L"MaxTokenSize"                                          

#define KERBEROS_RPCID 0x10   // RPC_C_AUTHN_GSS_KERBEROS

#endif // __KRNLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\kernel\krnlapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------
#include <kerbkrnl.h>
extern "C"
{
#include <cryptdll.h>
}
#include "krnlapi.h"

#define DONT_SUPPORT_OLD_TYPES_USER 1

//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
KspInitPackageFn       KerbInitKernelPackage;
KspDeleteContextFn     KerbDeleteKernelContext;
KspInitContextFn       KerbInitKernelContext;
KspMapHandleFn         KerbMapKernelHandle;
KspMakeSignatureFn     KerbMakeSignature;
KspVerifySignatureFn   KerbVerifySignature;
KspSealMessageFn       KerbSealMessage;
KspUnsealMessageFn     KerbUnsealMessage;
KspGetTokenFn          KerbGetContextToken;
KspQueryAttributesFn   KerbQueryContextAttributes;
KspCompleteTokenFn     KerbCompleteToken;
SpExportSecurityContextFn      KerbExportContext;
SpImportSecurityContextFn      KerbImportContext;
KspSetPagingModeFn     KerbSetPageMode ;

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG ChecksumType,
    OUT PULONG EncryptionType,
    OUT PULONG SequenceNumber
    );

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PULONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    );

NTSTATUS NTAPI
KerbInitDefaults();

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitKernelPackage)
#pragma alloc_text(PAGE, KerbDeleteKernelContext)
#pragma alloc_text(PAGE, KerbInitKernelContext)
#pragma alloc_text(PAGE, KerbMapKernelHandle)
#pragma alloc_text(PAGEMSG, KerbMakeSignature)
#pragma alloc_text(PAGEMSG, KerbVerifySignature)
#pragma alloc_text(PAGEMSG, KerbSealMessage)
#pragma alloc_text(PAGEMSG, KerbUnsealMessage)
#pragma alloc_text(PAGEMSG, KerbGetContextToken)
#pragma alloc_text(PAGEMSG, KerbQueryContextAttributes)
#pragma alloc_text(PAGEMSG, KerbMakeSignatureToken)
#pragma alloc_text(PAGEMSG, KerbVerifySignatureToken)
#pragma alloc_text(PAGE, KerbCompleteToken)
#pragma alloc_text(PAGE, KerbExportContext)
#pragma alloc_text(PAGE, KerbImportContext)
#pragma alloc_text(PAGE, KerbInitDefaults)
#endif

SECPKG_KERNEL_FUNCTION_TABLE KerberosFunctionTable = {
    KerbInitKernelPackage,
    KerbDeleteKernelContext,
    KerbInitKernelContext,
    KerbMapKernelHandle,
    KerbMakeSignature,
    KerbVerifySignature,
    KerbSealMessage,
    KerbUnsealMessage,
    KerbGetContextToken,
    KerbQueryContextAttributes,
    KerbCompleteToken,
    KerbExportContext,
    KerbImportContext,
    KerbSetPageMode

};
POOL_TYPE KerbPoolType ;

#define MAYBE_PAGED_CODE()  \
    if ( KerbPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }

PVOID KerbPagedList ;
PVOID KerbNonPagedList ;
PVOID KerbActiveList ;
ERESOURCE KerbGlobalResource;
BOOLEAN KerbCryptInitialized;
ULONG KerbMaxTokenSize = KERBEROS_MAX_TOKEN;

extern "C"
{
int LibAttach(HANDLE, PVOID);
}

#define KerbWriteLockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Globals\n"));      \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite(&KerbGlobalResource,TRUE);       \
}
#define KerbReadLockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Globals\n"));       \
    KeEnterCriticalRegion();                                    \
    ExAcquireSharedWaitForExclusive(&KerbGlobalResource, TRUE); \
}
#define KerbUnlockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Globals\n"));          \
    ExReleaseResourceLite(&KerbGlobalResource);                     \
    KeLeaveCriticalRegion();                                    \
}

//
// Common GSS object IDs, taken from MIT kerberos distribution.
//

gss_OID_desc oids[] = {
    {5, "\053\005\001\005\002"},                      // original mech id
    {9, "\052\206\110\206\367\022\001\002\002"},      // standard mech id
    {10, "\052\206\110\206\367\022\001\002\002\001"}, // krb5_name type
    {10, "\052\206\110\206\367\022\001\002\002\002"}, // krb5_principal type
    {10, "\052\206\110\206\367\022\001\002\002\003"}, // user2user mech id
};

gss_OID_desc * gss_mech_krb5 = oids;
gss_OID_desc * gss_mech_krb5_new = oids+1;
gss_OID_desc * gss_mech_krb5_u2u = oids+4;


#define KERB_MAX_CHECKSUM_LENGTH    24

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitDefaults
//
//  Synopsis:   Opens registry key, and gets custom defaults
//
//  Effects:    Changes MaxTokenSize
//
//  Arguments:  None
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
KerbInitDefaults()
{
   UNICODE_STRING       ParameterPath;
   UNICODE_STRING       MaxTokenValue;
   OBJECT_ATTRIBUTES    oa;
   ULONG                BytesRead;
   NTSTATUS             Status;
   HANDLE               hParamKey = INVALID_HANDLE_VALUE;
   
   KEY_VALUE_PARTIAL_INFORMATION KeyPartialInformation; 
   
   PAGED_CODE();
   
   RtlInitUnicodeString(&ParameterPath, KERB_PARAMETER_PATH);
   RtlInitUnicodeString(&MaxTokenValue, KERB_PARAMETER_MAX_TOKEN_SIZE);

   InitializeObjectAttributes(
               &oa,
               &ParameterPath,
               OBJ_CASE_INSENSITIVE,
               NULL,
               NULL
               );

   Status = ZwOpenKey(
               &hParamKey,
               KEY_READ,
               &oa
               );

   if (!NT_SUCCESS(Status))
   {
      DebugLog((DEB_WARN, "KerbInitDefault:OpenKey failed:0x%x\n",Status));
      goto Cleanup;
   }  

   Status = ZwQueryValueKey(
               hParamKey,
               &MaxTokenValue,
               KeyValuePartialInformation,
               (PVOID)&KeyPartialInformation,
               sizeof(KeyPartialInformation),
               &BytesRead
               );

   if (!NT_SUCCESS(Status) || KeyPartialInformation.Type != REG_DWORD)
   {
      DebugLog((DEB_WARN, "KerbInitDefault:QueryValueKey failed:0x%x\n",Status));
      goto Cleanup;
   } else {
      PULONG Value = (PULONG) &KeyPartialInformation.Data;
      KerbMaxTokenSize = *((PULONG)Value);
   }

Cleanup:

   if (INVALID_HANDLE_VALUE != hParamKey)
   {
      ZwClose(hParamKey);
   }

   return Status;
}
   
//+-------------------------------------------------------------------------
//
//  Function:   KerbInitKernelPackage
//
//  Synopsis:   Initialize an instance of the Kerberos package in the kernel
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by Kerberos
//              UserFunctions - Receives a copy of Kerberos's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbInitKernelPackage(
    PSECPKG_KERNEL_FUNCTIONS    FunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    KerbPoolType = PagedPool ;

    KerbPagedList = KSecCreateContextList( KSecPaged );

    if ( !KerbPagedList )
    {
        return STATUS_NO_MEMORY ;
    }

    KerbActiveList = KerbPagedList ;

    Status = ExInitializeResourceLite (&KerbGlobalResource);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    // Get registry values, ignore failures
    KerbInitDefaults();                    

    return STATUS_SUCCESS ;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle - Receives LSA context handle of the context
//                      to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDeleteKernelContext(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PLSA_SEC_HANDLE LsaContextHandle
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    NTSTATUS SaveStatus = STATUS_SUCCESS;
    DebugLog((DEB_TRACE,"KerbDeleteUserModeContext called\n"));


    Context = KerbReferenceContext(
                ContextHandle,
                TRUE                // unlink it
                );
    if (Context == NULL)
    {
        DebugLog((DEB_WARN,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle ));
        *LsaContextHandle = ContextHandle;
        return(STATUS_INVALID_HANDLE);
    }

    KerbReadLockContexts();

    *LsaContextHandle = Context->LsaContextHandle;

    if ((Context->ContextAttributes & KERB_CONTEXT_EXPORTED) != 0)
    {
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }

    KerbUnlockContexts();

    KerbDereferenceContext(
        Context
        );

    return((SaveStatus == SEC_I_NO_LSA_CONTEXT) ?
                          SEC_I_NO_LSA_CONTEXT :
                          STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//              NewContextHandle - Receives kernel mode context handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbInitKernelContext(
    IN LSA_SEC_HANDLE LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PLSA_SEC_HANDLE NewContextHandle
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbInitUserModeContex called\n"));

    Status = KerbCreateKernelModeContext(
                LsaContextHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *NewContextHandle = KerbGetContextHandle(Context);

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if (PackedContext->pvBuffer != NULL)
    {
        KspKernelFunctions.FreeHeap(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }


    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Effects:
//
//  Arguments:  ContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbMapKernelHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PLSA_SEC_HANDLE LsaContextHandle
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    DebugLog((DEB_TRACE,"KerbMapKernelhandle called\n"));

    PAGED_CODE();
    Context = KerbReferenceContext(
                ContextHandle,
                FALSE                // don't it
                );
    if (Context == NULL)
    {
        DebugLog((DEB_WARN,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle ));
        *LsaContextHandle = ContextHandle;
    }
    else
    {
        *LsaContextHandle = Context->LsaContextHandle;
        KerbDereferenceContext(
            Context
            );
        //
        // If the lsa context handle is zero, this is an imported context
        // so there is no lsa context
        //

        if (*LsaContextHandle == 0)
        {
            return(SEC_E_UNSUPPORTED_FUNCTION);
        }

    }

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRandomFill
//
//  Synopsis:   Generates random data in the buffer.
//
//  Arguments:  [pbBuffer] --
//              [cbBuffer] --
//
//  History:    5-20-93   RichardW   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
KerbRandomFill( PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{
    if (!CDGenerateRandomBits(pbBuffer, cbBuffer))
    {
        return;
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignatureToken
//
//  Synopsis:   Makes the signature token for a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              SignatureBuffer - Buffer in which to place signature
//              TotalBufferSize - Total size of all buffers to be signed
//              Encrypt - if TRUE, then prepare a header for an encrypted buffer
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              ChecksumType - Receives the type of checksum to use
//              EncryptionType - Receives the type of encryption to use
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG ChecksumType,
    OUT PULONG EncryptionType,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_SIGNATURE Signature;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    ULONG MessageSize;
    ULONG SignatureSize = 0;
    PULONG Nonce;
    gss_OID MechUsed;
    BOOLEAN GssCompatible = TRUE;

    //
    // Make sure that cryptdll stuff is initialized.
    //

    MAYBE_PAGED_CODE();

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();
        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    //
    // Compute the size of the header. For encryption headers, we need
    // to round up the size of the data & add 8 bytes for a confounder.
    //

    if (QualityOfProtection == GSS_KRB5_INTEG_C_QOP_DEFAULT)
    {
        GssCompatible = FALSE;
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Encrypt || !GssCompatible)
    {
        TotalBufferSize = 0;
    }

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }
    if (Encrypt)
    {
        //
        // NOTE: according to rfc1964, buffers that are an even multiple of
        // 8 bytes have 8 bytes of zeros appended. Because we cannot modify
        // the input buffers, the caller will have to do this for us.
        //


        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SEAL_SIGNATURE);
    }
    else
    {
        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SIGNATURE);
    }

    SignatureSize = g_token_size(MechUsed, MessageSize) - TotalBufferSize;


    //
    // Make Dave happy (verify that the supplied signature buffer is large
    // enough for a signature):
    //

    if (SignatureBuffer->cbBuffer < SignatureSize)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }


    //
    // create the header with the GSS oid
    //

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    g_make_token_header(
        MechUsed,
        MessageSize,
        (PUCHAR *) &Signature,
        (Encrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG)
        );


    //
    // Fill in the header information according to RFC1964
    //



    Signature->SignatureAlgorithm[1] = KERB_GSS_SIG_SECOND;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {

#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
        Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN;
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }
        else
        {
            ASSERT (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }
    }
    else
    {
        if (Encrypt)
        {
            Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_SEAL_DES_CBC;

        }

        //
        // Use the exportable version if necessasry
        //

        *EncryptionType = KERB_ETYPE_DES_PLAIN;


        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_MD25;
            *ChecksumType = KERB_CHECKSUM_MD25;
            break;
        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC_MD5;
            *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC;
            *ChecksumType = KERB_CHECKSUM_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d.\n",
                QualityOfProtection ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    }

    //
    // Put in the filler - it is different for signing & sealing
    //

    if (Encrypt)
    {
        memset(Signature->SealFiller,0xff,2);
    }
    else
    {
        memset(Signature->SignFiller,0xff,4);
    }

    //
    // Inbound contexts get a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_INBOUND)
    {
        *(PULONG)(&Signature->SequenceNumber[4]) = 0xffffffff;

        Nonce = &Context->ReceiveNonce;

    }
    else
    {
        ASSERT((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0);
        *(PULONG)(&Signature->SequenceNumber[4]) = 0x00000000;
        Nonce = &Context->Nonce;
    }

    //
    // If this is datagram, or integrity without replay & sequence detection,
    // use the nonce from the caller
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))

    {
        Nonce = &SuppliedNonce;
    }

    Signature->SequenceNumber[0] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
    Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
    Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
    Signature->SequenceNumber[3] = (UCHAR)  (*Nonce & 0x000000ff);

    (*Nonce)++;


    *SequenceNumber = *(PULONG)Signature->SequenceNumber;

    //
    // If we are encrypting, add the confounder to the end of the signature
    //

    if (Encrypt)
    {
        SealSignature = (PKERB_GSS_SEAL_SIGNATURE) Signature;
        KerbRandomFill(
            SealSignature->Confounder,
            KERB_GSS_SIG_CONFOUNDER_SIZE
            );
    }
    //
    // Set the size of the signature
    //

    SignatureBuffer->cbBuffer = SignatureSize;
    *OutputSignature = Signature;

Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignatureToken
//
//  Synopsis:   Verifies the header on a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - context to use for verification
//              SignatureBuffer - Buffer containing signature
//              TotalBufferSize - Size of all buffers signed/encrypted
//              Decrypt - TRUE if we are unsealing
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              QualityOfProtection - returns GSS quality of protection flags
//              ChecksumType - Type of checksum used in this signature
//              EncryptionType - Type of encryption used in this signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PULONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SignatureSize = 0;
    UCHAR Nonce[8];
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    ULONG OutputSize;
    ULONG EncryptionType;
    PCRYPTO_SYSTEM LocalCryptSystem = NULL ;
    PKERB_GSS_SIGNATURE Signature;
    PULONG ContextNonce;
    gss_OID MechUsed;

    //
    // Make sure that cryptdll stuff is initialized.
    //

    MAYBE_PAGED_CODE();

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();

        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Decrypt ||
       ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
       ((Context->ContextFlags & ISC_RET_DATAGRAM) != 0))
    {
        TotalBufferSize = 0;
    }


    //
    // Verify the signature header
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    if (!g_verify_token_header(
            MechUsed,
            (int *) &SignatureSize,
            (PUCHAR *) &Signature,
            (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
            SignatureBuffer->cbBuffer + TotalBufferSize))
    {
        Status = SEC_E_MESSAGE_ALTERED;
    }

    //
    // If that didn't work, try with the old mech. Need this is for DCE clients
    // for whom we can't tell what mech they use.
    //

    if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
    {
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                gss_mech_krb5,
                (int *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    //
    // MS RPC clients don't send the size properly, so set the total size
    // to zero and try again.
    //

    if (Decrypt && !NT_SUCCESS(Status))
    {
        TotalBufferSize = 0;
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                MechUsed,
                (int *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        //
        // If that didn't work, try with the old mech. Need this is for DCE clients
        // for whom we can't tell what mech they use.
        //

        if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
            if (!g_verify_token_header(
                    gss_mech_krb5,
                    (int *) &SignatureSize,
                    (PUCHAR *) &Signature,
                    (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                    SignatureBuffer->cbBuffer + TotalBufferSize))
            {
                Status = SEC_E_MESSAGE_ALTERED;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // Protection from bad Signature Size
    //

    if (SignatureSize == 0)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Subtract the total buffer size from Signature size to get the real
    // size of the signature.
    //

    SignatureSize -= TotalBufferSize;

    //
    // Make sure the signature is big enough. We can't enforce a strict
    // size because RPC will transmit the maximum number of bytes instead
    // of the actual number.
    //

    if ((Decrypt && (SignatureSize < sizeof(KERB_GSS_SEAL_SIGNATURE))) ||
        (!Decrypt && (SignatureSize < sizeof(KERB_GSS_SIGNATURE))))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number
    //

    if (Signature->SignatureAlgorithm[1] != KERB_GSS_SIG_SECOND)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    //
    // Figure out the algorithm
    //
    switch(Context->SessionKey.keytype) {
    case KERB_ETYPE_DES_CBC_MD5:
    case KERB_ETYPE_DES_CBC_CRC:
        EncryptionType = KERB_ETYPE_DES_PLAIN;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        break;
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_NT:
        EncryptionType = KERB_ETYPE_RC4_PLAIN;
        break;
    default:
        DebugLog((DEB_ERROR,"Unknown key type: %d\n",
           Context->SessionKey.keytype ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // if the key is exportable, make sure to use the exportable plain
    // version.
    //


    switch(Signature->SignatureAlgorithm[0]) {
    case KERB_GSS_SIG_MD25:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_MD5;
        *ChecksumType = KERB_CHECKSUM_MD25;
        break;
    case KERB_GSS_SIG_DES_MAC_MD5:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MD5;
        *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
        break;
    case KERB_GSS_SIG_DES_MAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MAC;
        *ChecksumType = KERB_CHECKSUM_DES_MAC;
        break;
    case KERB_GSS_SIG_HMAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DEFAULT;
        *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
        break;
    default:
        DebugLog((DEB_ERROR,"Invalid signature type to VerifySignature: %d\n",
                Signature->SignatureAlgorithm[0]));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;

    }

    if (Decrypt)
    {
        if (Signature->SealAlgorithm[1] != KERB_GSS_SIG_SECOND)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }

        //
        // Verify the seal algorithm
        //

        switch(EncryptionType) {
        case KERB_ETYPE_DES_PLAIN:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_DES_CBC)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n" ));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        case KERB_ETYPE_RC4_PLAIN_OLD_EXP:
        case KERB_ETYPE_RC4_PLAIN_OLD:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4_OLD)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n"));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        case KERB_ETYPE_RC4_PLAIN_EXP:
        case KERB_ETYPE_RC4_PLAIN:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n"));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid seal type to VerifySignature: %d, %d\n", Signature->SealAlgorithm[0], EncryptionType));
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    //
    // Check the filler
    //

    if ((Decrypt && (*(PUSHORT) Signature->SealFiller != 0xffff)) ||
        (!Decrypt && (*(PULONG) Signature->SignFiller != 0xffffffff)))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number. To do this we need to decrypt it with
    // the session key with the checksum as the IV.
    //


    Status = CDLocateCSystem(EncryptionType, &LocalCryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x\n", EncryptionType,Status));
        goto Cleanup;
    }

    //
    // Now we need to Decrypt the sequence number, using the checksum as the
    // IV
    //

    Status = LocalCryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                      // no flags
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = LocalCryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    OutputSize = 8;

    Status = LocalCryptSystem->Decrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // For datagram or integrity only, we use just the supplied nonce.
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))
    {
        ContextNonce = &SuppliedNonce;
    }
    else
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0)
        {
            ContextNonce = &Context->ReceiveNonce;
        }
        else
        {
            ContextNonce = &Context->Nonce;
        }
    }

    Nonce[0] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
    Nonce[1] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
    Nonce[2] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
    Nonce[3] = (UCHAR)  (*ContextNonce & 0x000000ff);

    *SequenceNumber = *(PULONG) Nonce;

    if (!RtlEqualMemory(
            Nonce,
            Signature->SequenceNumber,
            4))
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    (*ContextNonce)++;

    //
    // Inbound contexts send a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
    {
        if (*(PULONG)(&Signature->SequenceNumber[4]) != 0xffffffff)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }
    else
    {
        ASSERT((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0);
        if (*(PULONG)(&Signature->SequenceNumber[4]) != 0)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(CryptSystem))
    {
        *CryptSystem = LocalCryptSystem;
    }

    *OutputSignature = Signature;

Cleanup:
    if ( ( CryptBuffer != NULL) &&
         ( LocalCryptSystem != NULL ) )
    {
        LocalCryptSystem->Discard(&CryptBuffer);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: Cluster folks need to run this at dpc level (non paged)
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    BOOLEAN ContextsLocked = FALSE;
    ULONG ChecksumType = 0;
    ULONG EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG SequenceNumber;


    MAYBE_PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbMakeSignature Called\n"));

    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for MakeSignature(0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        if (SignatureBuffer->cbBuffer < sizeof(KERB_NULL_SIGNATURE))
        {
            Status = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        SignatureBuffer->cbBuffer = sizeof(KERB_NULL_SIGNATURE);
        *(PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer = 0;

        Status = STATUS_SUCCESS;
        goto Cleanup;

    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                FALSE,                  // don't encrypt
                MessageSequenceNumber,
                &Signature,
                &ChecksumType,
                &EncryptType,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x.\n ",ChecksumType,Status ));
        goto Cleanup;
    }

    ASSERT(Check->CheckSumSize <= sizeof(LocalChecksum));

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",EncryptType,Status ));
        goto Cleanup;
    }

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    NULL,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        Signature->Checksum,
        LocalChecksum,
        8
        );


    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    return(Status);
}
//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: Cluster folks need to run this at dpc level (non paged)
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
KerbVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    ULONG ChecksumType;
    BOOLEAN ContextsLocked = FALSE;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    ULONG Protection;
    ULONG TotalBufferSize = 0;
    ULONG SequenceNumber;


    MAYBE_PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbVerifySignature Called\n"));

    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for VerifySignature(0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Also, verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        PKERB_NULL_SIGNATURE NullSignature = (PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer;

        if (SignatureBuffer->cbBuffer >= sizeof(KERB_NULL_SIGNATURE) &&
            (*NullSignature == 0))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        goto Cleanup;

    }

    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 FALSE,                 // don't decrypt
                 MessageSequenceNumber,
                 &Signature,
                 &Protection,
                 &ChecksumType,
                 NULL,                   // don't need crypt system
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x\n", Status));
        goto Cleanup;
    }

    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x\n", Status));
        goto Cleanup;
    }

    ASSERT(Check->CheckSumSize  <= sizeof(LocalChecksum));

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
            Status = Check->InitializeEx2(
                Context->SessionKey.keyvalue.value,
                (ULONG) Context->SessionKey.keyvalue.length,
                Signature->Checksum,
                KERB_SAFE_SALT,
                &CheckBuffer
                );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature->Checksum,
            8))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }
Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    DebugLog((DEB_TRACE, "SpVerifySignature returned 0x%x\n", Status));

    return(Status);
}

NTSTATUS NTAPI
KerbSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    MAYBE_PAGED_CODE();
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
KerbUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    MAYBE_PAGED_CODE();
    return(STATUS_NOT_SUPPORTED);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT OPTIONAL PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN * RawToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();


    DebugLog((DEB_TRACE,"KerbGetContextToken Called\n"));


    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for GetContextToken(0x%x)\n",
            ContextHandle));
        return(STATUS_INVALID_HANDLE);
    }

    KerbReadLockContexts();

    if (Context->TokenHandle == NULL)
    {
        Status = SEC_E_NO_IMPERSONATION;
        KerbUnlockContexts();
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(ImpersonationToken))
    {
        *ImpersonationToken = Context->TokenHandle;
    }

    if (ARGUMENT_PRESENT(RawToken))
    {
        if (Context->TokenHandle != NULL)
        {
            if (Context->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                            Context->TokenHandle,
                            TOKEN_IMPERSONATE,
                            NULL,
                            ExGetPreviousMode(),
                            (PVOID *) &Context->AccessToken,
                            NULL                // no handle information
                            );

            }
        }

        if (NT_SUCCESS(Status))
        {
            *RawToken = Context->AccessToken;
        }
    }

    KerbUnlockContexts();

Cleanup:

    if (Context != NULL)
    {
        //
        // Note: once we dereference the context the handle we return
        // may go away or be re-used. That is the price we have to pay
        // to avoid duplicating it.
        //

        KerbDereferenceContext(Context);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PSecPkgContext_Sizes SizeInfo;
    PSecPkgContext_Names NameInfo;
    PSecPkgContext_Lifespan LifespanInfo;
    PSecPkgContext_Flags FlagsInfo;
    PSecPkgContext_SessionKey SessionKeyInfo;
    PSecPkgContext_UserFlags UserFlagsInfo ;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_TargetInformation TargetInformation = NULL;
    UNICODE_STRING FullName;

    PAGED_CODE();

    DebugLog((DEB_TRACE,"SpQueryContextAttributes Called\n"));



    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );


    //
    // allow PACKAGE_INFO or NEGOTIATION_INFO to be queried against
    // incomplete contexts.
    //

    if( (Context == NULL) &&
        (ContextAttribute != SECPKG_ATTR_PACKAGE_INFO) &&
        (ContextAttribute != SECPKG_ATTR_NEGOTIATION_INFO)
        ) {

        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x)\n",
            ContextHandle));
        return(STATUS_INVALID_HANDLE);
    }


    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {
    case SECPKG_ATTR_SIZES:
        //
        // The sizes returned are used by RPC to determine whether to call
        // MakeSignature or SealMessage. The signature size should be zero
        // if neither is to be called, and the block size and trailer size
        // should be zero if SignMessage is not to be called.
        //

        SizeInfo = (PSecPkgContext_Sizes) Buffer;
        SizeInfo->cbMaxToken = KerbMaxTokenSize;
//        if ((Context->ContextFlags & (ISC_RET_CONFIDENTIALITY | ISC_RET_SEQUENCE_DETECT)) != 0)
//        {
              SizeInfo->cbMaxSignature = KERB_SIGNATURE_SIZE;
//        }
//        else
//        {
//            SizeInfo->cbMaxSignature = 0;
//        }
        if ((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) != 0)
        {
            SizeInfo->cbBlockSize = 1;
            SizeInfo->cbSecurityTrailer = KERB_SIGNATURE_SIZE;
        }
        else
        {
            SizeInfo->cbBlockSize = 0;
            SizeInfo->cbSecurityTrailer = 0;
        }
        break;
    case SECPKG_ATTR_NAMES:
        NameInfo = (PSecPkgContext_Names) Buffer;

        NameInfo->sUserName = (LPWSTR) KspKernelFunctions.AllocateHeap(Context->FullName.Length + sizeof(WCHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                Context->FullName.Buffer,
                Context->FullName.Length
                );
            NameInfo->sUserName[Context->FullName.Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;
    case SECPKG_ATTR_TARGET_INFORMATION:

        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (Context->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_NOT_FOUND;
            break;
        }

        TargetInformation->MarshalledTargetInfo = (PUCHAR) KspKernelFunctions.AllocateHeap(
                                                                    Context->cbMarshalledTargetInfo
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                Context->pbMarshalledTargetInfo,
                Context->cbMarshalledTargetInfo
                );

            TargetInformation->MarshalledTargetInfoLength = Context->cbMarshalledTargetInfo;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;

    case SECPKG_ATTR_LIFESPAN:
        LifespanInfo = (PSecPkgContext_Lifespan) Buffer;
        //
        // BUG 454552: set start time properly.
        //
        LifespanInfo->tsStart.QuadPart = 0;
        LifespanInfo->tsExpiry = Context->Lifetime;
        break;
    case SECPKG_ATTR_FLAGS:
        FlagsInfo = (PSecPkgContext_Flags) Buffer;

        FlagsInfo->Flags = Context->ContextFlags;
        break;
    case SECPKG_ATTR_SESSION_KEY:
        SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
        SessionKeyInfo->SessionKeyLength = Context->SessionKey.keyvalue.length;
        if (SessionKeyInfo->SessionKeyLength != 0)
        {
            SessionKeyInfo->SessionKey = (PUCHAR) KspKernelFunctions.AllocateHeap(SessionKeyInfo->SessionKeyLength);
            if (SessionKeyInfo->SessionKey != NULL)
            {
                RtlCopyMemory(
                    SessionKeyInfo->SessionKey,
                    Context->SessionKey.keyvalue.value,
                    Context->SessionKey.keyvalue.length
                    );
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }
        else
        {
            SessionKeyInfo->SessionKey = (PUCHAR) KspKernelFunctions.AllocateHeap(1);
            if (SessionKeyInfo->SessionKey != NULL)
            {
                *(PUCHAR) SessionKeyInfo->SessionKey = 0;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlagsInfo = (PSecPkgContext_UserFlags) Buffer ;
        UserFlagsInfo->UserFlags = 0 ;
        Status = STATUS_SUCCESS ;
        break;

    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfo->PackageInfo = (PSecPkgInfo) KspKernelFunctions.AllocateHeap(
                                                        sizeof(SecPkgInfo) +
                                                        sizeof(KERBEROS_PACKAGE_NAME) +
                                                        sizeof(KERBEROS_PACKAGE_COMMENT)
                                                        );
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        PackageInfo->PackageInfo->Name = (LPTSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPTSTR) (((PBYTE) PackageInfo->PackageInfo->Name) + sizeof(KERBEROS_PACKAGE_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            KERBEROS_PACKAGE_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            KERBEROS_PACKAGE_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = KERBEROS_RPCID;
        PackageInfo->PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
        PackageInfo->PackageInfo->cbMaxToken    = KerbMaxTokenSize;
        if ( ContextAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            PSecPkgContext_NegotiationInfo NegInfo ;

            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            if( Context != NULL ) {
                NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
            } else {
                NegInfo->NegotiationState = 0;
            }
        }
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCompleteToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbCompleteToken(
    IN LSA_SEC_HANDLE ContextId,
    IN PSecBufferDesc Token
    )
{
    PAGED_CODE();
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExportContext(
    IN LSA_SEC_HANDLE Context,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    IN OUT PHANDLE TokenHandle
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbImportContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbInitUserModeContext called\n"));

    Status = KerbCreateKernelModeContext(
                0,              // LsaContextHandle not present
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();
        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    KerbWriteLockContexts();

    Context->TokenHandle = TokenHandle;
    *ContextHandle = KerbGetContextHandle(Context);
    Context->ContextAttributes |= KERB_CONTEXT_IMPORTED;

    KerbUnlockContexts();

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    return(Status);
}

NTSTATUS
KerbSetPageMode(
    BOOLEAN Pagable
    )
{
    if ( Pagable )
    {
        KerbPoolType = PagedPool ;
        KerbActiveList = KerbPagedList ;
    }
    else
    {
        if ( KerbNonPagedList == NULL )
        {
            KerbNonPagedList = KSecCreateContextList( KSecNonPaged );
            if ( KerbNonPagedList == NULL )
            {
                return STATUS_NO_MEMORY ;
            }
        }

        KerbActiveList = KerbNonPagedList ;

        KerbPoolType = NonPagedPool ;
    }
    return STATUS_SUCCESS ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\apreq.c ===
//=============================================================================
//  MODULE: apreq.c
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================


#include "kerbGlob.h"


LPBYTE HandleAPReq(HFRAME hFrame, LPBYTE TempFrame)
{
// Display AP-Req (6E)
	TempFrame = DispASNTypes(hFrame, TempFrame, 5, DispKerbMsgType, KrbApReqBitF);

// Calculate Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 7);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
	TempFrame = DispSeqOctets(hFrame, TempFrame, 7, ASN1UnivTagSumID, ASN1UnivTag);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Protocol Version value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 6, DispProtocolVer);

//Display Integer value of pvno[0]	
	// Display ASN.1 Identifier
	TempFrame = DispASNTypes(hFrame, TempFrame, 7, KrbApReqID, KrbApReqBitF);

// Break Down INTEGER values	
	TempFrame = DefineValue(hFrame, TempFrame, 9, KdcContentsValue);

// Display Message Type value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 6, DispKerbMsgType);

// Display msg-type[1]
	TempFrame = DispASNTypes(hFrame, TempFrame, 7, KrbApReqID, KrbApReqBitF);

// Break Down INTEGER values	
	TempFrame = DefineValue(hFrame, TempFrame, 9, KrbMsgTypeID);

// Display AP Options at the Top level
	TempFrame = DispTopSum(hFrame, TempFrame, 6, DispApOptionsSum);

// Display ap-options[2]
	TempFrame = DispASNTypes(hFrame, TempFrame, 7, KrbApReqID, KrbApReqBitF);

// Display Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 10);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Universal Class Tag
	TempFrame = DispASNTypes(hFrame, TempFrame, 9, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 12);
	
// Need to increment TempFrame by two because AP Options is 32bit
	TempFrame+=2;

// Break down AP-Option Flags
	TempFrame = DefineKdcOptions(hFrame, TempFrame, 7, DispFlagApOptions);

// Incrementing TempFrame to next Class Tag
	TempFrame+=3;

// Display Ticket at Top Level
	TempFrame = DispTopSum(hFrame, TempFrame, 6, DispSumTicket);

// Display ticket[3]
	TempFrame = HandleTicket(hFrame, TempFrame, 7);

// Handle the display of authenticator[4]
// Display Ciper Text at the Top level
	TempFrame = DispTopSum(hFrame, TempFrame, 6, DispCipherText); 

// Display authenticator[4] of Ticket
	TempFrame = DispASNTypes(hFrame, TempFrame, 7, KrbApReqID, KrbApReqBitF);

// Display  Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 10);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
	TempFrame = DispASNTypes(hFrame, TempFrame, 9, ASN1UnivTagSumID, ASN1UnivTag);

// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 11);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Handle EncryptedData Needs to start with A0
	TempFrame = HandleEncryptedData(hFrame, TempFrame, 7);


return TempFrame;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kdcrep.c ===
//=============================================================================
//  MODULE: kdcrep.c
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================
//#define KDCREP_H

//#include "kerbparser.h"
#include "kerbGlob.h"
#include "kdcrep.h"

// Definitions

BYTE CheckForOptional;
LPBYTE TempFrameRep;

;  // Need to find out why error compiling without the semicolon

LPBYTE KdcResponse(HFRAME hFrame, LPBYTE TempFrame)
{
	

	// 1st attach command displays the 1st Identifier frame
	
// Display SEQUENCE (First frame we handle in this file.
	TempFrame = DispASNTypes(hFrame, TempFrame, 3, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet	
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 5); 

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);
	

// Display Protocol Version value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispProtocolVer);

// Displays pvno[0]
	TempFrame = KdcRepTypes(hFrame, TempFrame, 2);  

// Display Message Type value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispKerbMsgType);

// Displays kdc-rep msg-type[1]
	TempFrame = KdcRepTypes(hFrame, TempFrame, 2); 

// Display padata[2] if present  THIS CODE HASN'T BEEN
// VERIFIED AGAINST A CAPTURE TO TEST IT'S VALIDITY
// Start code to break down pa-data
	 if(*(TempFrame+1) == 0xA2)
	 {

	// Display Pre-Authentication Data at the Top level
		TempFrame = DispTopSum(hFrame, TempFrame, 1, DispSumPreAuth);

	// Display padata[2]
		TempFrame = HandlePaData(hFrame, TempFrame, 2, PaDataSummary);

	}
//  Bring comment back here
	
// Display Client Realm value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringCliRealm);
		
// Next function handles displaying crealm[3]
	TempFrame = KdcRepTypes(hFrame, TempFrame, 2);

// Display Client Name value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringCliName);

// Next function handles displaying cname[4]
	TempFrame = KdcRepTypes(hFrame, TempFrame, 2);

// Display Kerberos Ticket at the Top level
					   
	TempFrame = DispTopSum(hFrame, TempFrame, 1, DispSumKerbTix);

// Next call handles displaying ticket[5]
	TempFrame = KdcHandleTix(hFrame, TempFrame, 2);

// Display Ciper Text at the Top level
	TempFrame = DispTopSum(hFrame, TempFrame, 1, DispCipherText); 

// Display enc-part[6] of Ticket
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KdcRepTagID, lblTagNumber);

// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 5);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
	TempFrame = DispASNTypes(hFrame, TempFrame, 4, ASN1UnivTagSumID, ASN1UnivTag);

// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 7);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);
 
// Handle EncryptedData Needs to start with A0
	TempFrame = HandleEncryptedData(hFrame, TempFrame, 2);

/* kf 11/9/99 FIXING PADATA
*///kf 11/9/99 FIXING PADATA

return TempFrame;
	
};



LPBYTE KdcRepTypes(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{

	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, KdcRepTagID, lblTagNumber);

	
// Next statement checks for crealm or cname in order to display a string
// Value for TempAsnMsg is assigned in DispASNTypes

	if(( *(TempFrame) & 0x1F) == 3 || (*(TempFrame) & 0x1F) == 4)
		{ // The next function breaks down PrincipalName
			if((*(TempFrame) & 0x1F) == 4)
			{	
				
				//Display Length Octet
					TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);
				
				//  Incrementing TempFrame based on the number of octets
				//	taken up by the Length octet
					TempFrame = IncTempFrame(TempFrame);
				
				// Display SEQUENCE
					TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);		
				
				// Print out Length Octet 
					TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

				//  Incrementing TempFrame based on the number of octets
				//	taken up by the Length octet
					TempFrame = IncTempFrame(TempFrame);
				
				// This call breaks down PrincipalName defined in cname[4]	
					TempFrame =DefinePrincipalName(hFrame, TempFrame, OffSet+2, DispString);
			}
			else
				TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, DispString);
		}
	else
		TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, KdcContentsValue);





return TempFrame;
};



/***********************************************************************************************************
**
** This function will break down ASN.1 PrincipalName.
** Ticket ::= [APPLICATION 1] {
**							tkt-vno[0]		INTEGER,		Specifies the version # for the ticket format
**							realm[1]		Realm,			Specifies the realm that issued the ticket
**							sname[2]		PrinicipalName,	Specifies the name part of the Server Identity
**							enc-part[3]		EncryptedData,	Holds encoding of the EncTicketPart sequence							
**							
**							
**							
**
**************************************************************************************************************/
LPBYTE KdcHandleTix(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{

/*  Need to make a function to call that displays the main variables of the Ticket structure and 
	displays to save repitive code.

*/
//Display Ticket[5]	
	TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet, KdcRepTagID, lblTagNumber);


// Display Length
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+2);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Identifier Octet for [APPLICATION 1]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, KrbTixAppSumID, KrbTixApp1ID);


// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);
	
// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Ticket Version value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, OffSet, DispSumTixVer);

// Display tkt-vno[0]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KrbTicketSumID, KrbTicketID);

// Breakdown and display tkt-vno[0]
	TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, KdcContentsValue);

// Display Realm name value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, OffSet, DispStringRealmName);

// Display realm[1]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KrbTicketSumID, KrbTicketID);

// Breakdown and display Realm name
	TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, DispString);

// Display Server name value at the Top level
//KF 8/16 IN FRAME 4 OF MACHBOOT.CAP, THERE IS ONLY ONE NAME UNDER SNAME WHICH
// BREAKS THE REST OF THE DISPLAY.  NEED TO DO SOMETYPE OF CHECK TO SEE IF THERE ARE
// MULTIPLE NAMES.  MAYBE A COUNTER IN THE WHILE LOOP.

	TempFrame = DispSumString(hFrame, TempFrame, 0x1B, OffSet, DispStringServNameGS);

// Process sname[2] PrincipalName portion
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KrbTicketSumID, KrbTicketID);

//Display short length
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE 
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4, ASN1UnivTagSumID, ASN1UnivTag);

// Calculate short length
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+6);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// This call will break down the PrincipalName portion of sname[2]
	TempFrame = DefinePrincipalName(hFrame, TempFrame, OffSet+4, DispString);	
// End code for displaying sname[2]

// Display Ciper Text at the Top level
	TempFrame = DispTopSum(hFrame, TempFrame, OffSet, DispCipherText);


// Display enc-data[3] of Ticket
	TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+1, KrbTicketSumID, KrbTicketID);


// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Sequence
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);

// Display Long form Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+6);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Handling enc-data.
// Handle EncryptedData Needs to start with A0
	TempFrame = HandleEncryptedData( hFrame, TempFrame, OffSet+1);

	return TempFrame;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kdcreq.c ===
//=============================================================================
//  MODULE: kdcreq.c
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================

//#include "kerbparser.h"
#include "kerbGlob.h"
#include "kdcreq.h"


LPBYTE KdcRequest(HFRAME hFrame, LPBYTE TempFrame)
{

// 1st attach command displays the 1st Identifier frame
	TempFrame = DispSeqOctets(hFrame, TempFrame, 3, ASN1UnivTagSumID, ASN1UnivTag);

// Incrementing TempFrame by one to get to the correct frame.  
	TempFrame+=CalcLenOctet(--TempFrame);

// Display Protocol Version value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispProtocolVer);

// Display pvno[1]
	TempFrame = KdcReqTypes(hFrame, TempFrame, KdcReqTagID, KdcReqSeq, KdcContentsValue);


// Display Message Type value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispKerbMsgType);

// Display msg-type[2]
	TempFrame = KdcReqTypes(hFrame, TempFrame, KdcReqTagID, KdcReqSeq, KrbMsgTypeID);

// Start code to break down pa-data
	 if(*(TempFrame+1) == 0xA3)
	 {

	// Display Pre-Authentication Data at the Top level
		TempFrame = DispTopSum(hFrame, TempFrame, 1, DispSumPreAuth);

	// Display padata[3]
		TempFrame = HandlePaData(hFrame, TempFrame, 2, PaDataSummary);

	}


// Display KDC Request Body at the Top level
	TempFrame = DispTopSum(hFrame, TempFrame, 1, DispSumReqBody);

// Display req-body[4]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KdcReqTagID, KdcReqSeq);

// Calculate Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 4);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
	TempFrame = DispSeqOctets(hFrame, TempFrame, 4, ASN1UnivTagSumID, ASN1UnivTag);

// Following call breaks handles displaying req-body[4]
	TempFrame = HandleReqBody(hFrame, TempFrame, 2);

	return ++TempFrame;
};



LPBYTE KdcReqTypes(HFRAME hFrame, LPBYTE TempFrame, DWORD TypeVal, DWORD TypeVal2, DWORD TypeVal3)
{
// Display ASN.1 Identifier
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, TypeVal, TypeVal2);

// Break Down INTEGER values	
	TempFrame = DefineValue(hFrame, TempFrame, 4, TypeVal3);


	
	return TempFrame;
}

LPBYTE HandleReqBody(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{
// Display kdc-options[0]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, DispStringTixFlag, KdcReqBodyBitF);

// Display Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// Display Universal Class Tag
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

// Must get TempFrame 2 bytes past Length octet 05
	TempFrame+=2;

// Display KDC-Option Flags
	TempFrame = DefineKdcOptions(hFrame, TempFrame, OffSet+1, DispFlagKdcOptions);


// Move Adjust TempFrame past KDC-Options to start at cname[1]
	TempFrame+=3;
	
// Display cname[1] OPTIONAL

	if(*(TempFrame+1) == 0xA1)
		{
		// Display Client Name value at the Top level
			TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, OffSet,   DispStringCliName);
		
		// Display cname[1].  
			TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

		// Display Length Octet
			TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

		//  Incrementing TempFrame based on the number of octets
		//	taken up by the Length octet
			TempFrame = IncTempFrame(TempFrame);
		
		// Display SEQUENCE Octets
			TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);

		// Display cname[1]
			TempFrame = DefinePrincipalName(hFrame, TempFrame, OffSet+3, DispStringCliName);

			TempFrame--;
		
		}


 

// Display realm[2]
// Display Realm name value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, OffSet, DispStringRealmName);
	

	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);
	TempFrame = DefineValue(hFrame, TempFrame, OffSet+3, DispStringRealmName);


// MUST FIND OUT WHY 8 IS GETTING APPENDED TO KRBTGT AT THE TOP LEVEL
// Display sname[3] OPTIONAL
	if(*(TempFrame+1) == 0xA3)
		{	
		// Display Server name value at the Top level
			TempFrame = DispSumString(hFrame, TempFrame, 0x1B, OffSet, DispStringServNameGS);
		
		// Display sname[3]
			TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

		// Display Length Octet
			TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

		//  Incrementing TempFrame based on the number of octets
		//	taken up by the Length octet
			TempFrame = IncTempFrame(TempFrame);
		
		// Display SEQUENCE Octets
			TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);

		// Display sname[3]  
			TempFrame = DefinePrincipalName(hFrame, TempFrame, OffSet+3, DispStringServerName);

//			--TempFrame;

		}



// Display from[4] OPTIONAL
	if(*(TempFrame) == 0xA4)
		{	//THIS CODE HASN'T BEEN TESTED. May need to put TempFrame-- on last line
		
		// Display Post Date value at the Top level
			TempFrame = DispSumTime(hFrame, TempFrame, 0x18, OffSet, DispStringPostDate);
		
		// Display from[4]
			TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

		// Display KerberosTime
			TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, DispString);

				//TempFrame--
		}

// Display Expiration Date value at the Top level (till[5])
	TempFrame = DispSumTime(hFrame, TempFrame, 0x18, OffSet, DispStringExpDate);

// 1/27/00 KKF  TODAY I NOTICED THAT TILL[5] WAS OFF ONE OFFSET.  HADN'T NOTICED THIS
// BEFORE.  WENT BACK AND CHECKED A BUILD FROM NOV. AND THE PROBLEM DIDN'T EXIST. HOWEVER
// I MATCHED THE CODE AND DON'T SEE THE DIFFERENCE.  GOING TO DECREMENT TEMPFRAME WHILE
// SENDING TO DISPASNTYPES.

// Display till[5]	
	TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);


// Display KerberosTime
	TempFrame = DefineValue(hFrame, TempFrame, OffSet+3, DispString);


// Display rtime[6] OPTIONAL
	if(*(TempFrame+1) == 0xA6)
		{
		// Display Expiration Date value at the Top level
			TempFrame = DispSumTime(hFrame, TempFrame, 0x18, OffSet, DispStringRenewTill);
		
		// Display from[4]
			TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

		// Display KerberosTime
			TempFrame = DefineValue(hFrame, TempFrame, OffSet+3, DispString);

			//TempFrame--
		}


// Display Top level for nonce[7]
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, OffSet, DispSumRandomNumber);

// Display nonce[7]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

//Display INTEGER
	TempFrame = DefineValue(hFrame, TempFrame, OffSet+3, DispSumRandomNumber);



// SINCE THIS FIELD LISTS THE NUMEROUS ENCRYPTION OPTIONS A CLIENT
// SUPPORTS, IT CAN BE CONFUSING DISPLAYING THE FIRST OPTION AT THE TOP
// LEVEL SO I'M REMMING OUT THE NEXT LINE OF CODE.
//Display Encryption Algorithm at the top Level etype[8]
//	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x02, OffSet, DispSumEtype2);

//Display Encryption Type Option(s) at the top Level etype[8]
	TempFrame = DispTopSum(hFrame, TempFrame, 2, DispEncryptionOptions);
// Display etype[8]
	TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);

// Display Length Octet
	TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

//  Display all the encryption types.
	TempFrame = DefineEtype(hFrame, TempFrame, OffSet+1, DispSumEtype2, ASN1UnivTagSumID, ASN1UnivTag);


// Display addresses[9]
	
	if(*(TempFrame) == 0xA9)

		{
		// Display Expiration Date value at the Top level
			TempFrame = DispSum(hFrame, TempFrame, 0x04, 0x30, OffSet, DispStringAddresses);
			
		// Adjust TempFrame to proper octet
			--TempFrame;
		// Display addresses[9]
			TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+1, KdcReqBodyID, KdcReqBodyBitF);
		
		// Display Length Octet
			TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);
		
		//  Incrementing TempFrame based on the number of octets
		//	taken up by the Length octet
			TempFrame = IncTempFrame(TempFrame);
		
		// Display SEQUENCE OF Octets
			TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);
		
		//Display addresses[9]
			TempFrame = DispHostAddresses(hFrame, TempFrame, OffSet+1);



		}


/* 
	LEFT OFF HERE BECAUSE THE SNIFFS I HAVE DON'T HAVE THE FINAL OPTIONS.  FINISH HANDLING THE KDC-REQ PACKET 
	IF/WHEN YOU GET A SNIFF WITH THE INFO, THEN GO BACK AND ADD CODE FOR THE OPTIONAL'S IN KRB-ERROR 
	USING MIKE'S SNIFF.

	Missing enc-authorization-data[10] & additional-tickets[11]

*/


	return TempFrame;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kerbglob.h ===
//=============================================================================
//  MODULE: kerbGlob.h
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================
#include <windows.h>
#include <string.h>
#include <bh.h>
#include <netmon.h>

//#define FORMAT_BUFFER_SIZE 80

//  Using a typedef enum instead of all the defines


typedef enum{
		KerberosSummary	= 0x00,
		KerberosIDSummary,
		KerberosClassTag,
		PCIdentifier,			
		ASN1UnivTag,				
		LengthSummary,			
		LengthFlag,				
		LengthBits,				
		LongLength1,				
		LongLength2,				
		ASNIdentifier,			
		UniversalTagID,			
		KdcReqTagID,				
		KdcReqSeq,				
		KdcReqSeqLength,			
		ASN1UnivTagSumID,		
		KdcContentsValue,		
		PaDataSummary,			
		PaDataSeq,				
		DispString,				
		KerberosIdentifier,		
		lblTagNumber,			
		KdcRepTagID,				
		KrbPrincipalNamelSet,	
		KrbPrincNameType,		
		KrbPrincipalNamelBitF,	
		KrbTicketID,				
		KrbTixApp1ID,			
		KrbErrTagID,				
		DispTimeID,				
		KrbErrTagSumID,			
		KrbTixAppSumID,			
		KrbTicketSumID,			
		KrbErrCodeID,			
		KrbMsgTypeID,			
		PadataTypeValID,			
		CipherTextDisp,			
		FragUdpID,				
		KdcReqBodyID,			
		KdcReqBodyBitF,			
		HostAddressesID,			
		HostAddressesBitF,		
		DispStringCliName,		
		DispStringRealmName,		
		DispStringServerName,	
		DispStringTixFlag,		
		DispStringExpDate,		
		DispStringPostDate,		
		DispStringRenewTill,		
		DispSumRandomNumber,		
		DispSumEtype,			
		DispStringAddresses,		
		DispSummary,				
		DispStringCliRealm,		
		DispProtocolVer,			
		DispKerbMsgType,			
		DispSumPreAuth,			
		DispSumReqBody,			
		DispSumKerbTix,			
		DispSumTixVer,			
		DispCipherText,			
		DispStringCliTime,		
		DispSumCuSec,			
		DispStringSrvTime,		
		DispSumSuSec,			
		DispSumKerbErr,			
		DispStringErrorText,		
		DispStringErrorData,		
		DispFlagKdcOptions,		
		DispStringServNameGS,	
		DispSumEtype2,			
		EncryptedDataTag,		
		EncryptedDataTagBitF,	
		KrbApReqID,				
		KrbApReqBitF,			
		DispApOptionsSum,		
		DispFlagApOptions,		
		DispSumTicket,			
		ApTicketID,				
		ApTicketBitF,			
		TicketStructID,			
		TicketStructBitF,		
		KerberosDefaultlbl,
		PaDataSummaryMulti,
		Certificatelbl,
		DispEncryptionOptions,
		MethodDataSummary,
		MethodDataBitF,
		DispReqAddInfo
};
		

// Global functions in kerbparser.c
LPBYTE EntryFrame(HFRAME, LPBYTE, DWORD);

// Used to breakdown and display padata fields
LPBYTE HandlePaData(HFRAME hFrame, LPBYTE TempFrame, int, DWORD TypeVal);
LPBYTE CalcMsgType(HFRAME, LPBYTE, int, DWORD TypeVal);
LPBYTE CalcLengthSummary(HFRAME, LPBYTE, int);
LPBYTE DefineValue(HFRAME, LPBYTE, int, DWORD);
LPBYTE DefinePrincipalName(HFRAME hFrame, LPBYTE TempFrame, int, DWORD TypeVal);
LPBYTE DispASNTypes(HFRAME, LPBYTE, int, DWORD, DWORD);
LPBYTE DispSeqOctets(HFRAME,LPBYTE, int, DWORD, DWORD);
LPBYTE DispHostAddresses(HFRAME, LPBYTE, int);
LPBYTE DispSum(HFRAME, LPBYTE, int ClassValue, int ClassValue2, int OffSet, DWORD TypeVal);
LPBYTE DispTopSum(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal);
LPBYTE DefineKdcOptions(HFRAME, LPBYTE, int, DWORD);
LPBYTE DefineEtype(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal, DWORD TypeVal2, DWORD TypeVal3);
LPBYTE HandleEncryptedData(HFRAME hFrame, LPBYTE TempFrame, int OffSet);
LPBYTE DispPadata(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal);
LPBYTE HandleAPReq(HFRAME hFrame, LPBYTE TempFrame);
LPBYTE HandleTicket(HFRAME hFrame, LPBYTE TempFrame, int OffSet);

// Function to display Padata within e-data of Kerb-Error
LPBYTE HandlePadataKrbErr(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal);

// Function to display Method-Data
LPBYTE HandleMethodData(HFRAME hFrame, LPBYTE TempFrame);

LPBYTE DispASNSum(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal);
LPBYTE DispSumSec(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int ClassValue2, int OffSet, DWORD TypeVal);

// Displays e-data
LPBYTE DispEdata(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal);

// Creating this function to change the format of GeneralizedTime
LPBYTE DispSumTime(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int OffSet, DWORD TypeVal);

// Created this function display the FQDN of sname at the top level
LPBYTE DispSumString(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int OffSet, DWORD TypeVal);

int CalcMsgLength(LPBYTE);
int CalcLenOctet(LPBYTE);


LPBYTE IncTempFrame(LPBYTE);

BYTE TempAsnMsg;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kdcreq.h ===
//==========================================================================================================================
//  MODULE: KdcReq.h
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//==========================================================================================================================


LPBYTE KdcRequest(HFRAME hframe, LPBYTE TempFrame);
LPBYTE KdcReqTypes(HFRAME hframe, LPBYTE TempFrame, DWORD TypeVal, DWORD TypeVal2, DWORD TypeVal3);
LPBYTE HandleReqBody(HFRAME, LPBYTE, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\krberr.c ===
//=============================================================================
//  MODULE: krberr.c
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================

//#include "kerbparser.h"
#include "kerbGlob.h"
#include "krberr.h"

int lValueKrbErr;
BYTE TempError;

LPBYTE KrbError(HFRAME hFrame, LPBYTE TempFrame)
{

// Display SEQUENCE (First frame we handle in this file.
	TempFrame = DispASNTypes(hFrame, TempFrame, 3, ASN1UnivTagSumID, ASN1UnivTag);

	lValueKrbErr=CalcLenOctet(TempFrame);

// Display Length Octet	
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 4); 


// Next line increments TempFrame appropriately based on the number of Length octets
// caculated previously
	
	TempFrame+=lValueKrbErr;

// Display Protocol Version value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispProtocolVer);

// Display pvno[0]
	TempFrame = DispASNTypes(hFrame, --TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display octets associated with Integer
	TempFrame = DefineValue(hFrame, TempFrame, 4, KdcContentsValue);

// Display Message Type value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispKerbMsgType);

// Display msg-type[1]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display octets associated with Integer
	TempFrame = DefineValue(hFrame, TempFrame, 4, KrbMsgTypeID);

/* Here we need to check for ctime[2] which is an optional value.
	If present, display the data if not go to the next tag.
*/
	TempError = *(TempFrame+1);
	
	if(TempError == 0xA2)
		{// Display Client Time value at the Top level
		//	TempFrame = DispSum(hFrame, TempFrame, 0x18, 0x30, 1, DispStringCliTime);
			TempFrame = DispSumTime(hFrame, TempFrame, 0x18, 1, DispStringCliTime);
			
		// Display ctime[2].  
			TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

		// Display octets associated with KerberosTime
			TempFrame = DefineValue(hFrame, TempFrame, 4, DispString);
		
		// Need to put code here to display the timestamp.
		}


	TempError = *(TempFrame+1);

//Display cusec[3] (If available)
	if(TempError == 0xA3)
		{// NEED TO GET THIS CODE TO PRINT OUT THE COMBINED VALUE OF MICROSECONDS
		// Display MicroSec of Client value at the Top level
			TempFrame = DispSumSec(hFrame, TempFrame, 0x02, 0x30, 1, DispSumCuSec);

		// Display cusec[3]
			TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

		// Display octets associated with Integer
			TempFrame = DefineValue(hFrame, TempFrame, 4, DispTimeID);
		}

// Display Server Time value at the Top level
//	TempFrame = DispSum(hFrame, TempFrame, 0x18, 0x30, 1, DispStringSrvTime);
	TempFrame = DispSumTime(hFrame, TempFrame, 0x18, 1, DispStringSrvTime);		
// Display stime[4]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display KerberosTime
	TempFrame = DefineValue(hFrame, TempFrame, 4, DispString);
	

// NEED TO GET THIS CODE TO PRINT OUT THE TOTAL VALUE OF MICROSECOND

// Display MicroSec of Server value at the Top level
	TempFrame = DispSumSec(hFrame, TempFrame, 0x02, 0x30, 1, DispSumSuSec);

//Display susec[5]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display value of susec  
	TempFrame = DefineValue(hFrame, TempFrame, 4, DispTimeID);

// Display Error value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, 1, DispSumKerbErr);

// Display error-code[6]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display value of error-code[6]
	TempFrame = DefineValue(hFrame, TempFrame, 4, KrbErrCodeID);
	
// Get the value of TempFrame+1
	TempError = *(TempFrame+1);

// Display value of crealm[7] (Optional
	if(TempError == 0xA7)
		{// Display Client Realm name value at the Top level
			TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringCliRealm);
		// Display crealm[7]
			TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);
		
		// Display Realm string
			TempFrame = DefineValue(hFrame, TempFrame, 4, DispString);
		}

// Get the value of TempFrame+1
	TempError = *(TempFrame+1);
	
// Display cname[8]
	if(TempError == 0xA8)
		{// This code wasn't tested as it wasn't in the sniff
		// Display Client name value at the Top level
			TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringCliName);
		
		// Display cname[8]
			TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);
		
		//Display Length Octet
			TempFrame = CalcLengthSummary(hFrame, TempFrame, 4);

		//  Incrementing TempFrame based on the number of octets
		//	taken up by the Length octet
			TempFrame = IncTempFrame(TempFrame);
				
		// Display SEQUENCE
			TempFrame = DispASNTypes(hFrame, TempFrame, 5, ASN1UnivTagSumID, ASN1UnivTag);		
				
		// Print out Length Octet 
			TempFrame = CalcLengthSummary(hFrame, TempFrame, 6);

		//  Incrementing TempFrame based on the number of octets
		//	taken up by the Length octet
			TempFrame = IncTempFrame(TempFrame);
		
		// This call breaks down PrincipalName defined in cname[8]	
			TempFrame =DefinePrincipalName(hFrame, TempFrame, 3, DispString);

		// Decrementing TempFrame by 1 as DefinePrincipal takes the offset
		// to where Realm Name starts
			--TempFrame;
		}

// Display Realm name value at the Top level
	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringRealmName);

//Display realm[9]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);

// Display realm[9] string
	TempFrame = DefineValue(hFrame, TempFrame, 4, DispString);

// Begin breaking out sname[10]

// Display Server name value at the Top level
//	TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringServerName);
	TempFrame = DispSumString(hFrame, TempFrame, 0x1B, 1, DispStringServNameGS);




// Display sname[10]
	TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);


//Display Length
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 4);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);


// Display SEQUENCE 
	TempFrame = DispASNTypes(hFrame, TempFrame, 4, ASN1UnivTagSumID, ASN1UnivTag);


// Calculate short length
	TempFrame = CalcLengthSummary(hFrame, TempFrame, 5);

//  Incrementing TempFrame based on the number of octets
//	taken up by the Length octet
	TempFrame = IncTempFrame(TempFrame);

// This call will break down the PrincipalName portion of sname[2]
	TempFrame =DefinePrincipalName(hFrame, TempFrame, 4, DispString);
	
	TempFrame--;
// End code for displaying sname[10]

// Get the value of TempFrame+1
	TempError = *(TempFrame+1);

// Display e-text[11] Optional
	if(TempError == 0xAB)
	{// Display Error Text at the Top Level
		TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, 1, DispStringErrorText);
	// Display e-text[11]
		TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);
		
	// Display Realm string
		TempFrame = DefineValue(hFrame, TempFrame, 4, DispString);
	}

// Get the value of TempFrame+1
	TempError = *(TempFrame+1);


// Display e-data[12]

if(TempError == 0xAC)
		{// Not sure how to display this data at this time.  Adding code and will
		//	worry about the accuracy at a later stage.
		
		
		// Display Error Text at the Top Level
			TempFrame = DispSum(hFrame, TempFrame, 0x04, 0x30, 1, DispStringErrorData);

		// Display e-data[12]
			TempFrame = DispASNTypes(hFrame, TempFrame, 2, KrbErrTagSumID, KrbErrTagID);
		
		// Display e-data string
			TempFrame = DispEdata(hFrame, TempFrame, 4, DispString);
		}

/*
  8/17 ADDITIONALLY, IT LOOKS AS E-DATA[12] IS A SEQUENCE OF PADATA.  HOWEVER I AM CURRENTLY 
  PREPARING TO TRANSITION TO ANOTHER POSITION SO I'M LEAVING THIS CODE OUT FOR NOW.  WILL LOOK
  AT ADDING IT WHEN I START ADJUSTING THE CODE TO WORK WITH THE COALESCER.
*/
	return TempFrame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kdcrep.h ===
//=============================================================================
//  MODULE: kdcrep.h
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================

// Function definitions for kdcrep.c

LPBYTE KdcResponse(HFRAME, LPBYTE);
LPBYTE KdcRepTypes(HFRAME, LPBYTE, int);
LPBYTE KdcHandleTix(HFRAME, LPBYTE, int);
//LPBYTE DefinePrincipalNameTix(HFRAME, LPBYTE, int, DWORD);


// End Function Definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kerbparser.h ===
#include <windows.h>
#include <string.h>
#include <bh.h>
#include <netmon.h>


#define FORMAT_BUFFER_SIZE 80

// Variables used in kerbparser.c to check 
// for continuation packets.
HPROTOCOL hTCP = NULL;
HPROTOCOL hUDP = NULL;


// Begin Definitions for Encryption types
// Leaving the negative values out until I can figure out 
// why some are labeled negative and some positive.
/*
#define KERB_ETYPE_RC4_MD4				-128
#define KERB_ETYPE_RC4_PLAIN2			-129
#define KERB_ETYPE_RC4_LM				-130
#define KERB_ETYPE_RC4_SHA				-131
#define KERB_ETYPE_DES_PLAIN			-132
*/

#define KERB_ETYPE_RC4_HMAC_OLD			0x7B	//-133
#define KERB_ETYPE_RC4_PLAIN_OLD		0x7A	//-134
#define KERB_ETYPE_RC4_HMAC_OLD_EXP		0x79	//-135
#define KERB_ETYPE_RC4_PLAIN_OLD_EXP	0x78	//-136
#define KERB_ETYPE_RC4_PLAIN			0x77	//-140
#define KERB_ETYPE_RC4_PLAIN_EXP		0x76	//-141

#define KERB_ETYPE_NULL					0
#define KERB_ETYPE_DES_CBC_CRC			1
#define KERB_ETYPE_DES_CBC_MD4			2
#define KERB_ETYPE_DES_CBC_MD5			3

#define KERB_ETYPE_DSA_SHA1_CMS         9
#define KERB_ETYPE_RSA_MD5_CMS			10
#define KERB_ETYPE_RSA_SHA1_CMS			11
#define KERB_ETYPE_RC2_CBC_ENV			12
#define KERB_ETYPE_RSA_ENV				13
#define KERB_ETYPE_RSA_ES_OEAP_ENV		14
#define KERB_ETYPE_DES_EDE3_CBC_ENV     15

#define KERB_ETYPE_DES_CBC_MD5_NT        20
#define KERB_ETYPE_RC4_HMAC_NT           23
#define KERB_ETYPE_RC4_HMAC_NT_EXP       24

#define KERB_ETYPE_OLD_RC4_MD4          128
#define KERB_ETYPE_OLD_RC4_PLAIN        129
#define KERB_ETYPE_OLD_RC4_LM           130
#define KERB_ETYPE_OLD_RC4_SHA          131
#define KERB_ETYPE_OLD_DES_PLAIN        132





/*  These are in kerbcon.h as well but there is a conflict
	with the ones listed above.  Worry about it later.
#define KERB_ETYPE_DSA_SIGN             8
#define KERB_ETYPE_RSA_PRIV             9
#define KERB_ETYPE_RSA_PUB              10
#define KERB_ETYPE_RSA_PUB_MD5          11
#define KERB_ETYPE_RSA_PUB_SHA1         12
#define KERB_ETYPE_PKCS7_PUB            13
*/
// In use types



// End Definition of encryption types


#define ASN1_KRB_AS_REQ			0x0A
#define ASN1_KRB_AS_REP			0x0B
#define ASN1_KRB_TGS_REQ		0x0C
#define ASN1_KRB_TGS_REP		0x0D
#define ASN1_KRB_AP_REQ			0x0E
#define ASN1_KRB_AP_REP			0x0F
#define ASN1_KRB_SAFE			0x14
#define ASN1_KRB_PRIV			0x15
#define ASN1_KRB_CRED			0x16
#define ASN1_KRB_ERROR			0x1E

#define UNIVERSAL 				0x00
#define APPLICATION				0x40
#define CONTEXT_SPECIFIC		0x80
#define PRIVATE					0xC0


// Creating this function to change the format of GeneralizedTime
LPBYTE DispSumTime(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int OffSet, DWORD TypeVal);


LPBYTE TempFrame, TempFramePadata, TempFrameReq, TempFrameReq2;
DWORD TypeVal, TypeVal2, TypeVal3;

#define TIME_FORMAT_STRING "%c%c/%c%c/%c%c%c%c %c%c:%c%c:%c%c UTC Time Zone"
#define TIME_FORMAT_SIZE sizeof("00/00/0000 00:00:00 UTC Time Zone")
#define MAX_SERVER_NAME_SEGMENTS 100

LPPROTOCOLINFO ProtoInfo;
BOOL TestForUDP;

//char test[1];
char MsgType[ sizeof "Didn't recognize" ]/*, MsgType2[24]*/;
//char PrinName[32];
 

BYTE LongSize, TempStore, TempStoreEF;
int x, OffSet, lValue, ClassValue;
WORD TempLen;

//  Definitions for KDC-REP
BYTE TempRepCname, TempRepGString, TempReqPadata, TempReq;
int lValueRepMsg, lValueCname, lValuePadata, lValueReq;

// Following enum is for the variables of KDC-REP
enum{
			PvnoKdcRep = 0,
			MsgTypeKdcRep,
			PaDataKdcRep,
			CrealmKdcRep,
			CnameKdcRep,
			TicketKdcRep,
			EncpartKdcRep
};


// End definitions for KDC-REP
// Following enum is for Variables of ticket
enum{
		tktvno = 0,
		realm,
		sname,
		encpart
};

enum{
		app1 = 1
};

enum{
	PVNO =1,
	MSGTYPE,
	PADATA,
	REQBODY
};

enum{
	nametype = 0,
	namestring
};

// Set values for Principal Name types
enum{
	NT_UKNOWN = 0,
	NT_PRINCIPAL,
	NT_SRV_INST,
	NT_SRV_HST,
	NT_SRV_XHST,
	NT_UID,
	NT_X500_PRINCIPAL
};

// Enum to set the Tag values for KRB-ERROR
enum{
	PvnoErr = 0,
	MsgtypeErr,
	CtimeErr,
	CusecErr,
	StimeErr,
	SusecErr,
	ErrorcodeErr,
	CrealmErr,
	CnameErr,
	RealmErr,
	SnameErr,
	EtextErr,
	EdataErr
};

// Enum to assign values to Kerberos Errors
enum{
	KDC_ERR_NONE = 0,				// 0
	KDC_ERR_NAME_EXP,				// 1
	KDC_ERR_SERVICE_EXP,			// 2
	KDC_ERR_BAD_PVNO,				// 3
	KDC_ERR_C_OLD_MAST_KVNO,		// 4
	KDC_ERR_S_OLD_MAST_KVNO,		// 5
	KDC_ERR_C_PRINCIPAL_UNKNOWN,	// 6
	KDC_ERR_S_PRINCIPAL_UNKNOWN,	// 7
	KDC_ERR_PRINCIPAL_NOT_UNIQUE,	// 8
	KDC_ERR_NULL_KEY,				// 9
	KDC_ERR_CANNOT_POSTDATE,		// 10
	KDC_ERR_NEVER_VALID,			// 11
	KDC_ERR_POLICY,					// 12
	KDC_ERR_BADOPTION,				// 13
	KDC_ERR_ETYPE_NOSUPP,			// 14
	KDC_ERR_SUMTYPE_NOSUPP,			// 15
	KDC_ERR_PADATA_TYPE_NOSUPP,		// 16
	KDC_ERR_TRTYPE_NOSUPP,			// 17
	KDC_ERR_CLIENT_REVOKED,			// 18
	KDC_ERR_SERVICE_REVOKED,		// 19
	KDC_ERR_TGT_REVOKED,			// 20
	KDC_ERR_CLIENT_NOTYET,			// 21
	KDC_ERR_SERVICE_NOTYET,			// 22
	KDC_ERR_KEY_EXPIRED,			// 23
	KDC_ERR_PREAUTH_FAILED,			// 24
	KDC_ERR_PREAUTH_REQUIRED,		// 25
	KDC_ERR_SERVER_NOMATCH,			// 26
	KDC_ERR_MUST_USE_USER2USER,		// 27
	KDC_ERR_PATH_NOT_ACCEPTED,		// 28
	KDC_ERR_SVC_UNAVAILABLE,		// 29
	KRB_AP_ERR_BAD_INTEGRITY = 31,	// 31
	KRB_AP_ERR_TKT_EXPIRED,			// 32
	KRB_AP_ERR_TKT_NYV,				// 33
	KRB_AP_ERR_REPEAT,				// 34
	KRB_AP_ERR_NOT_US,				// 35
	KRB_AP_ERR_BADMATCH,			// 36
	KRB_AP_ERR_SKEW,				// 37
	KRB_AP_ERR_BADADDR,				// 38
	KRB_AP_ERR_BADVERSION,			// 39
	KRB_AP_ERR_MSG_TYPE,			// 40
	KRB_AP_ERR_MODIFIED,			// 41
	KRB_AP_ERR_BADORDER,			// 42
	KRB_AP_ERR_BADKEYVER = 44,		// 44
	KRB_AP_ERR_NOKEY,				// 45
	KRB_AP_ERR_MUT_FAIL,			// 46
	KRB_AP_ERR_BADDIRECTION,		// 47
	KRB_AP_ERR_METHOD,				// 48
	KRB_AP_ERR_BADSEQ,				// 49
	KRB_AP_ERR_INAPP_CKSUM,			// 50
	KRB_AP_PATH_NOT_ACCEPTED,		// 51
	KRB_ERR_RESPONSE_TOO_BIG,		// 52
	KRB_ERR_GENERIC = 60,			// 60
	KRB_ERR_FIELD_TOOLONG,			// 61
	KDC_ERROR_CLIENT_NOT_TRUSTED,	// 62
	KDC_ERROR_KDC_NOT_TRUSTED,		// 63
	KDC_ERROR_INVALID_SIG,			// 64
	KDC_ERROR_KEY_TOO_WEAK,			// 65
	KDC_ERR_CERTIFICATE_MISMATCH,	// 66
	KDC_AP_ERROR_NO_TGT,			// 67
	KDC_ERR_WRONG_REALM,			// 68
	KDC_AP_ERR_USER_TO_USER_REQURED,	// 69
	KDC_ERR_CANT_VERIFY_CERTIFICATE, // 70
	KDC_ERR_INVALID_CERTIFICATE,	// 71
	KDC_ERR_REVOKED_CERTIFICATE,	// 72
	KDC_ERR_REVOCATION_STATUS_UNKNOWN,	//73
	KDC_ERR_REVOCATION_STATUS_UNAVAILABLE,	// 74
	KDC_ERR_CLIENT_NAME_MISMATCH,	// 75
	KDC_ERR_KDC_NAME_MISMATCH		// 76
};
// End Enum for error codes

// Values of padata type
enum{
	PA_TGS_REQ = 1,
	PA_ENC_TIMESTAMP,	// 2
	PA_PW_SALT,			// 3
	Reserved,			// 4
	PA_ENC_UNIX_TIME,	// 5
	PA_SANDIA_SECUREID,	// 6
	PA_SESAME,			// 7
	PA_OSF_DCE,			// 8
	PA_CYBERSAFE_SECUREID,	// 9	
	PA_AFS3_SALT,		// 0x0A
	PA_ETYPE_INFO,		// 0x0B
	SAM_CHALLENGE,		// 0x0C
	SAM_RESPONSE,		// 0x0D
	PA_PK_AS_REQ,		// 0x0E
	PA_PK_AS_REP,		// 0x0F
	PA_PK_AS_SIGN,		// 0x10
	PA_PK_KEY_REQ,		// 0x11
	PA_PK_KEY_REP,		// 0x12
	PA_USE_SPECIFIELD_KVNO,	// 0x13
	SAM_REDIRECT,			// 0x14
	PA_GET_FROM_TYPED_DATA	// 0x15
};

enum{
	kdcoptions = 0,
	cnamebody,
	realmbody,
	snamebody,
	frombody,
	tillbody,
	rtimebody,
	noncebody,
	etypebody,
	addressesbody,
	encauthdatabody,
	addtixbody
};

enum{
	addrtype = 0,
	address
};

enum{
	etype = 0,
	kvno,
	cipher
};

enum{
	PvnoApReq = 0,
	MsgTypeApReq,
	ApOptionsApReq,
	TicketApReq,
	AuthenticatorApReq
};

enum { ticket = 1};

enum{
	Tixtkt_vno = 0,
	TixRealm,
	TixSname,
	TixEnc_part
};

enum{
	methodtype = 0,
	methoddata
};


// kf 8/10 Rem the ifdef and trying to prevent global variables
// Using this statement to prevent multiple definitions
//#ifdef MAINPROG
// Defining these here while troubleshooting a report Access Violation
// Need to define the values locally and do away with as many of the 
// Global variables as possible.

//KF 10/15 CHANGING TO LABELED_BIT IN ORDER TO TRY AND PHASE OUT
// QUAL_BITFIELDS AND USE QUAL_FLAGS.  THERE ARE APPROX 15 BITFIELD
// USED IN KERBEROSDATABASE.  I WILL COMMENT THERE WHERE I CHANGED TO FLAGS
// BUT I WILL NOT COMMENT THE LABLELS ANY MORE.  ALL LABELED_BYTES HAVE BEEN 
// CHANGED TO LABELED_BIT
//LABELED_BYTE ClassTag[] = { 
  LABELED_BYTE ClassTag[] = {
		{0xC0, NULL},
		{UNIVERSAL, "Class Tag (Universal)"},
		{APPLICATION, "Class Tag (Application)"},
		{CONTEXT_SPECIFIC, "Class Tag (Context Specific)"},
		{PRIVATE, "Class Tag (Private)"},
	};


SET ClassTagSet = { (sizeof(ClassTag)/sizeof(LABELED_BYTE)), ClassTag };



LABELED_BIT PC[] = {
    { 5, "P/C (Primitive)", "P/C (Constructed)"},
   };
    
SET PCSet = { sizeof(PC)/sizeof(LABELED_BIT), PC };


LABELED_BYTE KrbMsgType[] = { 
		{0x1F, NULL},
		{ASN1_KRB_AS_REQ, "KRB_AS_REQ"},
		{ASN1_KRB_AS_REP, "KRB_AS_REP"},
		{ASN1_KRB_TGS_REQ, "KRB_TGS_REQ"},
		{ASN1_KRB_TGS_REP, "KRB_TGS_REP"},
		{ASN1_KRB_AP_REQ, "KRB_AP_REQ"},
		{ASN1_KRB_AP_REP, "KRB_AP_REP"},
		{ASN1_KRB_SAFE, "KRB_SAFE"},
		{ASN1_KRB_PRIV, "KRB_PRIV"},
		{ASN1_KRB_CRED, "KRB_CRED"},
		{ASN1_KRB_ERROR, "KRB_ERROR"}
	};

SET KrbMsgTypeSet = { (sizeof(KrbMsgType)/sizeof(LABELED_BYTE)), KrbMsgType };

LABELED_BIT Length[] = {
    { 7, "Short Form", "Long Form"},
   };
    
SET LengthSet = { sizeof(Length)/sizeof(LABELED_BIT), Length };

LABELED_BYTE UniversalTag[] = { 
		{0x1F, NULL},
		{0x01, "BOOLEAN"},
		{0x02, "INTEGER"},
		{0x03, "BIT STRING"},
		{0x04, "OCTET STRING"},
		{0x05, "NULL"},
		{0x06, "OBJECT IDENTIFIER"},
		{0x07, "ObjectDescriptor"},
		{0x08, "EXTERNAL"},
		{0x09, "REAL"},
		{0x0A,  "ENUMERATED"},
		{0x10, "SEQUENCE/SEQUENCE OF"},
		{0x11, "SET/SET OF"},
		{0x12, "NumericString"},
		{0x13, "PrintableString"},
		{0x14, "T61String"},
		{0x15, "VideotexString"},
		{0x16, "IA5String"},
		{0x17, "UTCTime"},
		{0x18, "GeneralizedTime"},
		{0x19, "GraphicString"},
		{0x1A, "VisibleString"},
		{0x1B, "GeneralString"}
};

SET UniversalTagSet = { sizeof(UniversalTag)/sizeof(LABELED_BYTE), UniversalTag };


LABELED_BYTE KdcReqTag[] = { 
		{0x1F, NULL},
		{PVNO, "Protocol Version 5 (pvno[1])"},
		{MSGTYPE, "Kerberos Message Type (msg-type[2])"},
		{PADATA, "Pre-Authentication Data (padata[3])"},
		{REQBODY, "KDC-Req-Body (req-body[4])"}
};

SET KdcReqTagSet = { sizeof(KdcReqTag)/sizeof(LABELED_BYTE), KdcReqTag };


LABELED_BYTE PaDataTag[] = { 
		{0x1F, NULL},
		{0x01, "padata-type[1]"},
		{0x02, "padata-value[2]"}
};

SET PaDataTagSet = { sizeof(PaDataTag)/sizeof(LABELED_BYTE), PaDataTag };

// For kdcrep packet
LABELED_BYTE KdcRepTag[] = {
				{0x1F, NULL},
				{PvnoKdcRep, "Protocol Version 5 (pvno[0])"},
				{MsgTypeKdcRep, "Kerberos Message Type (msg-type[1])"},
				{PaDataKdcRep, "Pre-Auth (padata[2])"},
				{CrealmKdcRep, "Realm (crealm[3])"},
				{CnameKdcRep, "Principal ID (cname[4])"},
				{TicketKdcRep, "Ticket (ticket[5])"},
				{EncpartKdcRep, "CipherText (enc-part[6])"}
				};

SET KdcRepTagSet = {sizeof(KdcRepTag)/sizeof(LABELED_BYTE), KdcRepTag};

LABELED_BYTE PrincipalName[] = {
				{0x1F, NULL},
				{nametype, "Name Type (name-type[0])"},
				{namestring, "Name String (name-string[1])"}
				};

SET PrincipalNameSet = {sizeof(PrincipalName)/sizeof(LABELED_BYTE), PrincipalName};

LABELED_BYTE PrincNameType[] = {
				{0x1F, NULL},
				{NT_UKNOWN, "NT_UNKNOWN (Name Type not Known)"},
				{NT_PRINCIPAL, "NT_PRINCIPAL (Name of Principal)"},
				{NT_SRV_INST, "NT_SRV_INST (Service & other unique Instance)"},
				{NT_SRV_HST, "NT_SRV_HST (Serv with Host Name as Instance)"},
				{NT_SRV_XHST, "NT_SRV_XHST (Service with Host as remaining components)"},
				{NT_UID, "NT_UID (Unique ID)"},
				{NT_X500_PRINCIPAL, "NT_X500_PRINCIPAL (Encoded X.509 Distinguished Name)"}
				};

SET PrincNameTypeSet = {sizeof(PrincNameType)/sizeof(LABELED_BYTE), PrincNameType};

LABELED_BYTE KrbTicket[] = {
				{0x1F, NULL},
				{tktvno, "Ticket Version (tkt-vno[0])"},
				{realm, "Realm (realm[1])"},
				{sname, "Server ID (sname[2])"},
				{encpart, "Cipher Text (enc-part[3])"}
				};

SET KrbTicketSet = {sizeof(KrbTicket)/sizeof(LABELED_BYTE), KrbTicket};

LABELED_BYTE KrbTixApp1 [] = {
				{0x1F, NULL},
				{app1, "Ticket ::= [APPLICATION 1]"}
};

SET KrbTixApp1Set = {sizeof(KrbTixApp1)/sizeof(LABELED_BYTE), KrbTixApp1};

LABELED_BYTE KrbErrTag [] = {
				{0x1F, NULL}, 
				{PvnoErr, "Protocol Version (pvno[0])"},
				{MsgtypeErr, "Message Type (msg-type[1])"},
				{CtimeErr, "Client Current Time (ctime[2])"},
				{CusecErr, "MicroSec on Client (cusec[3])"},
				{StimeErr, "Server Current Time (stime[4])"},
				{SusecErr, "MicroSec on Server (susec[5])"},
				{ErrorcodeErr, "Error Code (error-code[6])"},
				{CrealmErr, "Client Realm (crealm[7])"},
				{CnameErr, "Client Name (cname[8])"},
				{RealmErr, "Correct Realm (realm[9])"},
				{SnameErr, "Server Name (sname[10])"},
				{EtextErr, "Addtional Error Info (etext[11])"},
				{EdataErr, "Error Handling Data (edata[12])"}
};

SET KrbErrTagSet = {sizeof(KrbErrTag)/sizeof(LABELED_BYTE), KrbErrTag};

LABELED_BYTE KrbErrCode [] = {
				{0xFF, NULL},
				{KDC_ERR_NONE, "No error"},		// 0
				{KDC_ERR_NAME_EXP, "Client's entry in database has expired"},	// 1
				{KDC_ERR_SERVICE_EXP, "Server's entry in database has expired"},// 2
				{KDC_ERR_BAD_PVNO, "Requested protocol ver. number not supported"}, // 3
				{KDC_ERR_C_OLD_MAST_KVNO, "Client's key encrypted in old master key"},  // 4
				{KDC_ERR_S_OLD_MAST_KVNO, "Server's key encrypted in old master key"},  //5
				{KDC_ERR_C_PRINCIPAL_UNKNOWN, "Client not found in Kerberos database"},//6
				{KDC_ERR_S_PRINCIPAL_UNKNOWN, "Server not found in Kerberos database"},//7
				{KDC_ERR_PRINCIPAL_NOT_UNIQUE, "Multiple principal entries in database"},//8
				{KDC_ERR_NULL_KEY, "The client or server has a null key"},//9
				{KDC_ERR_CANNOT_POSTDATE, "Ticket not eligible for postdating"},//10
				{KDC_ERR_NEVER_VALID, "Requested start time is later than end time"},//11
				{KDC_ERR_POLICY, "KDC policy rejects request"}, //12
				{KDC_ERR_BADOPTION, "KDC cannot accommodate requested option"}, //13
				{KDC_ERR_ETYPE_NOSUPP, "KDC has no support for encryption type"}, //14
				{KDC_ERR_SUMTYPE_NOSUPP, "KDC has no support for checksum type"}, //15
				{KDC_ERR_PADATA_TYPE_NOSUPP, "KDC has no support for padata type"}, //16
				{KDC_ERR_TRTYPE_NOSUPP, "KDC has no support for transited type"}, //17
				{KDC_ERR_CLIENT_REVOKED, "Clients credentials have been revoked"}, //18
				{KDC_ERR_SERVICE_REVOKED, "Credentials for server have been revoked"}, //19
				{KDC_ERR_TGT_REVOKED, "TGT has been revoked"}, //20
				{KDC_ERR_CLIENT_NOTYET, "Client not yet valid try again later"}, //21
				{KDC_ERR_SERVICE_NOTYET, "Server not yet valid try again later"}, //22
				{KDC_ERR_KEY_EXPIRED, "Password has expired change password to reset"}, //23
				{KDC_ERR_PREAUTH_FAILED, "Pre-authentication information was invalid"}, //24
				{KDC_ERR_PREAUTH_REQUIRED, "Additional preauthentication required"}, //25
				{KDC_ERR_SERVER_NOMATCH, "Requested Server and ticket don't match"}, // 26
				{KDC_ERR_MUST_USE_USER2USER, "Server principal valid for user2user only"}, // 27
				{KDC_ERR_PATH_NOT_ACCEPTED, "KDC Policy rejects transited patth"}, //28
				{KDC_ERR_SVC_UNAVAILABLE, "A service is not available"}, // 29
				{KRB_AP_ERR_BAD_INTEGRITY, "Integrity check on decrypted field failed"}, //31
				{KRB_AP_ERR_TKT_EXPIRED, "Ticket expired"}, //32
				{KRB_AP_ERR_TKT_NYV, "Ticket not yet valid"}, //33
				{KRB_AP_ERR_REPEAT, "Request is a replay"}, //34
				{KRB_AP_ERR_NOT_US, "The ticket isn't for us"}, //35
				{KRB_AP_ERR_BADMATCH, "Ticket and authenticator don't match"}, //36
				{KRB_AP_ERR_SKEW, "Clock skew too great"}, // 37
				{KRB_AP_ERR_BADADDR, "Incorrect net address"}, // 38
				{KRB_AP_ERR_BADVERSION, "Protocol version mismatch"}, // 39
				{KRB_AP_ERR_MSG_TYPE, "Invalid msg type"}, // 40
				{KRB_AP_ERR_MODIFIED, "Message stream modified"}, //41
				{KRB_AP_ERR_BADORDER, "Message out of order"}, //42
				{KRB_AP_ERR_BADKEYVER, "Specified version of key is not available"}, //44
				{KRB_AP_ERR_NOKEY, "Service key not available"}, //45
				{KRB_AP_ERR_MUT_FAIL, "Mutual authentication failed"}, // 46
				{KRB_AP_ERR_BADDIRECTION, "Incorrect message direction"}, // 47
				{KRB_AP_ERR_METHOD, "Alternative authentication method required"}, // 48
				{KRB_AP_ERR_BADSEQ, "Incorrect sequence number in message"}, // 49
				{KRB_AP_ERR_INAPP_CKSUM, "Inappropriate type of checksum in message"}, // 50
				{KRB_AP_PATH_NOT_ACCEPTED, "Policy rejects transited path"}, // 51
				{KRB_ERR_RESPONSE_TOO_BIG, "Response too big for UDP, retry with TCP"}, // 52
				{KRB_ERR_GENERIC, "Generic error"}, // 60
				{KRB_ERR_FIELD_TOOLONG, "Field is too long for this implementation"},  // 61
				{KDC_ERROR_CLIENT_NOT_TRUSTED, "Client is not trusted"}, // 62
				{KDC_ERROR_KDC_NOT_TRUSTED, "KDC is not trusted"}, // 63
				{KDC_ERROR_INVALID_SIG, "Invalid signature"}, // 64
				{KDC_ERROR_KEY_TOO_WEAK, "Key is too weak"}, // 65
				{KDC_ERR_CERTIFICATE_MISMATCH, "Certificate does not match"}, // 66
				{KDC_AP_ERROR_NO_TGT, "No TGT"}, // 67
				{KDC_ERR_WRONG_REALM, "Wrong realm"}, // 68
				{KDC_AP_ERR_USER_TO_USER_REQURED, "User to User required"}, // 69
				{KDC_ERR_CANT_VERIFY_CERTIFICATE, "Can't verify certificate"}, // 70
				{KDC_ERR_INVALID_CERTIFICATE, "Invalid certificate"}, // 71
				{KDC_ERR_REVOKED_CERTIFICATE, "Revoked certificate"}, // 72
				{KDC_ERR_REVOCATION_STATUS_UNKNOWN, "Revocation status unknown"}, //73
				{KDC_ERR_REVOCATION_STATUS_UNAVAILABLE, "Revocation status unavailable"}, // 74
				{KDC_ERR_CLIENT_NAME_MISMATCH, "Client name mismatch"}, //75
				{KDC_ERR_KDC_NAME_MISMATCH, "KDC name mismatch"} // 76
};

SET KrbErrCodeSet = {sizeof(KrbErrCode)/sizeof(LABELED_BYTE), KrbErrCode};

LABELED_BYTE PadataTypeVal [] = {
				{0xFF, NULL},
				{PA_TGS_REQ, "PA-TGS-REQ"},
				{PA_ENC_TIMESTAMP, "PA-ENC-TIMESTAMP"},
				{PA_PW_SALT, "PA-PW-SALT"},
				{Reserved, "Reserved Value"},
				{PA_ENC_UNIX_TIME, "PA-END-UNIX-TIME"},
				{PA_SANDIA_SECUREID, "PA-SANDIA-SECUREID"},
				{PA_AFS3_SALT, "PA-AFS3-SALT"},
				{PA_ETYPE_INFO, "PA-ETYPE-INFO"},
				{SAM_CHALLENGE, "SAM-CHALLENGE"},
				{SAM_RESPONSE, "SAM-RESPONSE"},
				{PA_PK_AS_REQ, "PA-PK-AS-REP"},
				{PA_PK_AS_REP, "PA-PK-AS-REP"},
				{PA_PK_AS_SIGN, "PA-PK-AS-SIGN"},
				{PA_PK_KEY_REQ, "PA-PK-KEY-REQ"},
				{PA_PK_KEY_REP, "PA-PK-KEY-REP"},
				{PA_USE_SPECIFIELD_KVNO, "PA-USE-SPECIFIELD-KVNO"},
				{SAM_REDIRECT, "SAM-REDIRECT"},
				{PA_GET_FROM_TYPED_DATA, "PA-GET-FROM-TYPED-DATA"}
};

SET PadataTypeValSet = {sizeof(PadataTypeVal)/sizeof(LABELED_BYTE), PadataTypeVal};

LABELED_BYTE KdcReqBody [] = {
				{0x1F, NULL},
				{kdcoptions, "Ticket Flags (kdc-options[0])"},
				{cnamebody, "Client Name (cname[1])"}, 
				{realmbody, "Realm (realm[2])"}, 
				{snamebody, "Server Name (sname[3])"},
				{frombody, "Start Time (from[4])"},
				{tillbody, "Expiration date (till[5])"},
				{rtimebody, "Requested renew till (rtime[6])"},
				{noncebody, "Random Number (nonce[7])"},
				{etypebody,	"Encryption Alg. (etype[8])"},
				{addressesbody, "Addresses (addresses[9])"},
				{encauthdatabody, "Cipher Text (enc-authorization-data[10])"},
				{addtixbody, "Additional Tix (additional-ticketsp[11])"}
};

SET KdcReqBodySet = {sizeof(KdcReqBody)/sizeof(LABELED_BYTE), KdcReqBody};


LABELED_BYTE HostAddresses [] = {
				{0x1F, NULL},
				{addrtype, "Type of Address (addr-type[0])"},
				{address, "Addresses (address[1])"}
};

SET HostAddressesSet = {sizeof(HostAddresses)/sizeof(LABELED_BYTE), HostAddresses};

// KDC-Options
LABELED_BIT KdcOptionFlags[] =
{   {31, "Reserved (Bit 0)",						// 0 bit = Reserved,
		   "Reserved (Bit 0)" 
    },

	{30, "Forwardable Bit Not Set (Bit 1)",			// 1 bit = Fowardable
		  "Forwardable Bit Set (Bit 1)"
	},

	{29, "Forwarded Bit Not Set (Bit 2)",			// 2 bit = Forwarded
		 "Fowarded Bit Set (Bit 2)"
	},

	{28, "Proxiable Bit Not Set (Bit 3)",			// 3 bit = Proxiable
		 "Proxiable Bit Set (Bit 3)"
	},

	{27,	"Proxy Bit Not Set (Bit 4)",				// 4 bit = Proxy
			"Proxy Bit Set (Bit 4)"
	},

	{26,	"Allow-PostDate Bit Not Set (Bit 5)",		// 5 bit = Allow-Postdate
			"May-Postdate Bit Set (Bit 5)"
	},

	{25,	"PostDated Bit Not Set (Bit 6)",			// 6 bit = Postdated
			"Postdated Bit Set (Bit 6)"
	},

	{24,	"Unused (Bit 7)",							// 7 bit = Unused
			"Unused (Bit 7) "					
	},

	{23,	"Renewable Bit Not Set (Bit 8)",			// 8 bit = Renewable
			"Renewable Bit Set (Bit 8)"
	},

	{22,	"Unused (Bit 9)",							// 9 bit = Reserved
			"Unused (Bit 9)"
	},

	{21,	"Unused (Bit 10)",							// 10 bit = Reserved
			"Unused (Bit 10)"
	},

	{20,	"Unused (Bit 11)",							// 11 bit = Reserved
			"Unused (Bit 11)"
	},

	{19,	"Unused (Bit 12)",							// 12 bit = Reserved
			"Unused (Bit 12)"
	},

	{18,	"Unused (Bit 13)",							// 13 bit = Reserved
			"Unused (Bit 13)"
	},

	{17,	"Request-Anonymous Bit Not Set (Bit 14)",	// 14 bit = Reserved
			"Request-Anonymous Bit Set (Bit 14)"
	},

	{16,	"Name-Canonicalize Bit Not Set (Bit 15)",	// 15 bit = Reserved
			"Name-Canonicalize Bit Set (Bit 15)"	
	},

	{15,	"Reserved (Bit 16)",							// 16 bit = Reserved
			"Reserved (Bit 16)"
	},

	{14,	"Reserved (Bit 17)",							// 17 bit = Reserved
			"Reserved (Bit 17)"
	},

	{13,	"Reserved (Bit 18)",							// 18 bit = Reserved
			"Reserved (Bit 18)"
	},

	{12,	"Reserved (Bit 19)",							// 19 bit = Reserved
			"Reserved (Bit 19)"
	},

	{11,	"Reserved (Bit 20)",							// 20 bit = Reserved
			"Reserved (Bit 20)"
	},

	{10,	"Reserved (Bit 21)",							// 21 bit = Reserved
			"Reserved (Bit 21)"
	},

	{9,		"Reserved (Bit 22)",							// 22 bit = Reserved
			"Reserved (Bit 22)"
	},

	{8,		"Reserved (Bit 23)",							// 23 bit = Reserved
			"Reserved (Bit 23)"
	},

	{7,		"Reserved (Bit 24)",							// 24 bit = Reserved
			"Reserved (Bit 24)"
	},

	{6,		"Reserved (Bit 25)",							// 25 bit = Reserved
			"Reserved (Bit 25)"
	},

	{5,		"Disable-Transited-Check Bit Not Set (Bit 26)",	// 26 bit = Reserved
			"Disable-Transited-Check Bit Set (Bit 26)"
	},

	{4,		"Renewable-OK Bit Not Set (Bit 27)",			// 27 bit = Renewable-OK
			"Renewable-OK Bit Set (Bit 27)"
	},

	{3,		"Enc-Tkt-In-Skey Bit Not Set (Bit 28)",			// 28 bit = Enc-Tkt-In-Skey
			"Enc-Tkt-In-Skey Bit Not Set (Bit 28)"
	},

	{2,		"Reserved (Bit 29)",							// 29 bit = Reserved
			"Reserved (Bit 29)"
	},

	{1,		"Renew Bit Not Set (Bit 30)",					// 30 bit = Renew
			"Renew Bit Set (Bit 30)"
	},

	{0,		"Validate Bit Not Set (Bit 31)",				// 31 bit = Validate
			"Validate Bit Set (Bit 31)"
	}
};

SET KdcOptionFlagsSet = {sizeof(KdcOptionFlags)/sizeof(LABELED_BIT), KdcOptionFlags};

LABELED_BYTE EncryptionType [] = {
				{0xFF, NULL},
				{KERB_ETYPE_RC4_HMAC_OLD, "RC4-HMAC-OLD"},
				{KERB_ETYPE_RC4_PLAIN_OLD, "RC4-PLAIN-OLD"},
				{KERB_ETYPE_RC4_HMAC_OLD_EXP, "RC4-HMAC-OLD-EXP"},
				{KERB_ETYPE_RC4_PLAIN_OLD_EXP, "RC4-PLAIN-OLD-EXP"},
				{KERB_ETYPE_RC4_PLAIN, "RC4-PLAIN"},
				{KERB_ETYPE_RC4_PLAIN_EXP, "RC4-PLAIN-EXP"},
				{KERB_ETYPE_NULL, "NULL"},
				{KERB_ETYPE_DES_CBC_CRC, "DES-CBC-CRC"},
				{KERB_ETYPE_DES_CBC_MD4, "DES-CBC-MD4"},
				{KERB_ETYPE_DES_CBC_MD5, "DES-CBC-MD5"},
				{KERB_ETYPE_DSA_SHA1_CMS, "DSA-SHA1-CMS"},
				{KERB_ETYPE_RSA_MD5_CMS, "RSA-MD5-CMS"},
				{KERB_ETYPE_RSA_SHA1_CMS, "RSA-SHA1-CMS"},
				{KERB_ETYPE_RC2_CBC_ENV, "RC2-CBC-ENV"},
				{KERB_ETYPE_RSA_ENV, "RSA-ENV"},
				{KERB_ETYPE_RSA_ES_OEAP_ENV, "RSA-ES-OEAP-ENV"},
				{KERB_ETYPE_DES_EDE3_CBC_ENV, "DES-EDE3-CBC-ENV"},
				{KERB_ETYPE_DES_CBC_MD5_NT, "DES-CBC-MD5-NT"},
				{KERB_ETYPE_RC4_HMAC_NT, "RC4-HMAC-NT"},
				{KERB_ETYPE_RC4_HMAC_NT_EXP, "RC4-HMAC-NT-EXP"},
				{KERB_ETYPE_OLD_RC4_MD4, "RC4-MD4-OLD"},
				{KERB_ETYPE_OLD_RC4_PLAIN, "RC4-PLAIN-OLD"},
				{KERB_ETYPE_OLD_RC4_LM, "RC4-LM-OLD"},
				{KERB_ETYPE_OLD_RC4_SHA, "RC4-SHA-OLD"},
				{KERB_ETYPE_OLD_DES_PLAIN, "DES-PLAIN-OLD"}
};

SET EncryptionTypeSet = {sizeof(EncryptionType)/sizeof(LABELED_BYTE), EncryptionType};


LABELED_BYTE EncryptedData[] ={
				{0x1F, NULL},
				{etype, "Encryption Type (etype[0])"},
				{kvno, "Key Version Number (kvno[1])"},
				{cipher, "Enciphered Text (cipher[2]"}
};

SET EncryptedDataSet = {sizeof(EncryptedData)/sizeof(LABELED_BYTE), EncryptedData};

LABELED_BYTE KrbApReq[] = {
				{0x1F, NULL},
				{PvnoApReq, "Protocol Version (pvno[0])"},
				{MsgTypeApReq, "Message Type (msg-type[1])"},
				{ApOptionsApReq, "AP Options (ap-options[2])"},
				{TicketApReq, "Ticket (ticket[3])"},
				{AuthenticatorApReq, "Authenticator (authenticator[4])"}
};

SET KrbApReqSet = {sizeof(KrbApReq)/sizeof(LABELED_BYTE), KrbApReq};

// AP-Options
LABELED_BIT ApOptionFlags[] =
{   {31, "Reserved (Bit 0)",							// 0 bit = Reserved,
		   "Reserved (Bit 0)" 
    },

	{30, "Use-Session-Key Bit Not Set(Bit 1)",				// 1 bit = Use-Session-Key
		  "Use-Session-Key Bit Set (Bit 1)"
	},

	{29, "Mutual-Required Bit Not Set (Bit 2)",				// 2 bit = Mutual-Required
		 "Mutual-Required Bit Set (Bit 2)"
	},

	{28, "Reserved (Bit 3)",							// 3 bit = Reserved
		 "Reserved(Bit 3)"
	},

	{27,	"Reserved (Bit 4)",							// 4 bit = Reserved
			"Reserved (Bit 4)"
	},

	{26,	"Reserved (Bit 5)",							// 5 bit = Reserved
			"Reserved (Bit 5)"
	},

	{25,	"Reserved (Bit 6)",							// 6 bit = Reserved
			"Reserved (Bit 6)"
	},

	{24,	"Reserved (Bit 7)",							// 7 bit = Reserved
			"Reserved (Bit 7)"					
	},

	{23,	"Reserved (Bit 8)",							// 8 bit = Reserved
			"Reserved (Bit 8)"
	},

	{22,	"Reserved (Bit 9)",							// 9 bit = Reserved
			"Reserved (Bit 9)"
	},

	{21,	"Reserved (Bit 10)",						// 10 bit = Reserved
			"Reserved (Bit 10)"
	},

	{20,	"Reserved (Bit 11)",						// 11 bit = Reserved
			"Reserved (Bit 11)"
	},

	{19,	"Reserved (Bit 12)",						// 12 bit = Reserved
			"Reserved (Bit 12)"
	},

	{18,	"Reserved (Bit 13)",						// 13 bit = Reserved
			"Reserved (Bit 13)"
	},

	{17,	"Reserved (Bit 14)",						// 14 bit = Reserved
			"Reserved (Bit 14)"
	},

	{16,	"Reserved (Bit 15)",						// 15 bit = Reserved
			"Reserved (Bit 15)"	
	},

	{15,	"Reserved (Bit 16)",							// 16 bit = Reserved
			"Reserved (Bit 16)"
	},

	{14,	"Reserved (Bit 17)",							// 17 bit = Reserved
			"Reserved (Bit 17)"
	},

	{13,	"Reserved (Bit 18)",							// 18 bit = Reserved
			"Reserved (Bit 18)"
	},

	{12,	"Reserved (Bit 19)",							// 19 bit = Reserved
			"Reserved (Bit 19)"
	},

	{11,	"Reserved (Bit 20)",							// 20 bit = Reserved
			"Reserved (Bit 20)"
	},

	{10,	"Reserved (Bit 21)",							// 21 bit = Reserved
			"Reserved (Bit 21)"
	},

	{9,		"Reserved (Bit 22)",							// 22 bit = Reserved
			"Reserved (Bit 22)"
	},

	{8,		"Reserved (Bit 23)",							// 23 bit = Reserved
			"Reserved (Bit 23)"
	},

	{7,		"Reserved (Bit 24)",							// 24 bit = Reserved
			"Reserved (Bit 24)"
	},

	{6,		"Reserved (Bit 25)",							// 25 bit = Reserved
			"Reserved (Bit 25)"
	},

	{5,		"Reserved (Bit 26)",							// 26 bit = Reserved
			"Reserved (Bit 26)"
	},

	{4,		"Reserved (Bit 27)",							// 27 bit = Renewable-OK
			"Reserved (Bit 27)"
	},

	{3,		"Reserved (Bit 28)",							// 28 bit = Enc-Tkt-In-Skey
			"Reserved (Bit 28)"
	},

	{2,		"Reserved (Bit 29)",							// 29 bit = Reserved
			"Reserved (Bit 29)"
	},

	{1,		"Reserved(Bit 30)",								// 30 bit = Renew
			"Reserved (Bit 30)"
	},

	{0,		"Reserved (Bit 31)",							// 31 bit = Reserved
			"Reserved (Bit 31)"
	}
};

SET ApOptionFlagsSet = {sizeof(ApOptionFlags)/sizeof(LABELED_BIT), ApOptionFlags};

LABELED_BYTE ApTicket[] = {
				{0x1F, NULL},
				{ticket, "AP Ticket"}
};

SET ApTicketSet = {sizeof(ApTicket)/sizeof(LABELED_BYTE), ApTicket};

LABELED_BYTE TicketStruct[] = {
				{0x1F, NULL},
				{Tixtkt_vno, "Ticket Version Number (tkt-vno[0])"},
				{TixRealm, "Issuing Realm (realm[1])"},
				{TixSname, "Server (sname[2])"},
				{TixEnc_part, "Cipher Encoding (enc-part[3])"}
};

SET TicketStructSet = {sizeof(TicketStruct)/sizeof(LABELED_BYTE), TicketStruct};

LABELED_BYTE MethodDataType[] = { 
		{0x1F, NULL},
		{methodtype, "Req. Alt. Method (method-type[0])"},
		{methoddata, "Req. Alt. Info (method-data[1])"}
	};

SET MethodDataSet = { (sizeof(MethodDataType)/sizeof(LABELED_BYTE)), MethodDataType};

//=============================================================================
//  Kerberos database.
//=============================================================================

//KF 10/19/99 NEED TO GO THROUGH AND WEED OUT DUPLICATE NODES.  ALSO
// NEED TO RENAME THE DUPLICATES WHICH ARE NEEDED BECAUSE OF DIFFERENT
// DATATYPE LABELS.

PROPERTYINFO KerberosDatabase[] =
{
    {   //  KerberosSummary				0x00
		// Global Variable,description for all Kerberos Message Types
        0,0, 
        MsgType,  
        "Kerberos Packet", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

    {   //  KerberosIDSummary			0x01
		// Global Variable, used in identifying the Identifier Octet for Kerberos frames
        0,0, 
        "Message Type",  
        "Display Message Type", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // KerberosClassTag	0x02
		// Global Variable used to display ASN.1 Class tag of initial Identifier octet
        0,0, 
        "Class Tag",     
        "Display Class Tag", 
        PROP_TYPE_BYTE,    
		//PROP_QUAL_FLAGS,
		PROP_QUAL_LABELED_BITFIELD,
        &ClassTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // PCIdentifier					0x03
		// Global Variable, used to determine method of encoding used.
        0,0, 
        "P/C",     
        "Display Primitive/Constructed", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_FLAGS,
        &PCSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // ASN1UnivTag					0x04
		// Global Variable, probably needs to be renamed.  This takes the last 5 bits
		// of the Initial Identifier Octet and prints out the message type of the packet
        0,0, 
        "Contents",     
        "Display Contents", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
		&UniversalTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // LengthSummary				0x05
		
        0,0, 
        "Length Summary",     
        "Display Length Summary", 
        PROP_TYPE_BYTE,    
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

		
	{   // LengthFlag					0x06
        // Global Variable, Used in determining if the ASN.1 length octet is short or long form
		0,0, 
        "Length Flag",     
        "Display Length Flag", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_FLAGS,
        &LengthSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // LengthBits					0x07
		// Global Variable, used for labeling
        0,0, 
        "Number of Octets (Size)",     
        "Display Number of Octets (Size)", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // LongLength1					0x08
		// Global Variable, used for labeling values spanning multiple octets
        0,0, 
        "Size (BSW)",     
        "Display Size (Long)", 
        PROP_TYPE_BYTESWAPPED_WORD,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // LongLength2					0x09
		// Not sure about this one but looks to be for labeling
        0,0, 
        "Size (B)",     
        "Display Size (short)", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // ASNIdentifier				0x0A
		// Global, used for labeling of ASN.1 Identifier Octets
        0,0, 
        "Identifier",     
        "Display Identifier Octet", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},


	{   // UniversalTagID				0x0B
		//Global, Used for displaying ASN.1 Universal Class Tags 
        0,0, 
        "Tag Number",     
        "Display Tag Number (Bitfield)", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &UniversalTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // KdcReqTagID					0x0C
        0,0, 
        "KERB_KDC_REQ Type",     
        "Dipslay KERB_KDC_REQ Summary",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_SET,
        &KdcReqTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // KdcReqSeq					0x0D
        0,0, 
        "Tag Number (BF)",     
        "Display Tag Number", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &KdcReqTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // KdcReqSeqLength				0x0E
		// Global, however only used to represent the body of kdc-req packets
        0,0, 
        "Length",     
        "Length", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // ASN1UnivTagSumID				0x0F
		// This points to the Universal Class Tags
		//Used to display summary
        0,0, 
        "Univ. Class Tag",  
        "Universal Class Tag",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_SET,
		&UniversalTagSet,
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // KdcContentsValue				0x10
		// Global label
        0,0, 
        "Value",     
        "Value", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // PaDataSummary				0x11
		// Global Displays values for the PADATA type
        0,0, 
        "PA-DATA Type",     
        "PA-DATA Summary",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_SET,
        &PaDataTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // PaDataSeq					0x12
        0,0, 
        "Tag Number",     
        "Tag Number", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &PaDataTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // DispString					0x13
        0,0, 
        "Value",     
        "Value", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KerberosIdentifier			0x14
		0,0,
		"KRB MSG-Type Identifier",
		"Displays Kerberos Message Type",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_BITFIELD,
		//PROP_QUAL_FLAGS,
		&KrbMsgTypeSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},
		
	{	// lblTagNumber					0x15
		// Created this as a lable
		0,0, 
        "Tag Number",     
        "Display Explicit Tags", 
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &KdcRepTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{  //KdcRepTagID					0x16
		0,0,
		"KERB_KDC_REP Tag",
		"Struct of KDC-REP packet",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&KdcRepTagSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{	// KrbPrincipalNamelSet			0x17
		0, 0,
		"Principal Name",
		"PrincipalName Structure",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&PrincipalNameSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{	// KrbPrincNameType				0x18
		0, 0,
		"Name Type",
		"Principal Name Type",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&PrincNameTypeSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{	//KrbPrincipalNamelBitF			0x19
		0, 0,
		"Name Type",
		"Principal Name Type",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_BITFIELD,
		&PrincipalNameSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{	// KrbTicketID					0x1A
		0,0,
		"Kerberos Ticket",
		"Kerberos Ticket",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_BITFIELD,
		&KrbTicketSet,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{	// KrbTixApp1ID					0x1B
		0, 0,
		"Ticket Identifier",
		"Tag for Ticket",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_BITFIELD,
		&KrbTixApp1Set,
		FORMAT_BUFFER_SIZE,
		FormatPropertyInstance},

	{   // KrbErrTagID					0x1C
		// Global Displays values for the KRB-ERR type
        0,0, 
        "KRB-ERROR",     
        "KRB-ERROR Packet",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &KrbErrTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // DispTimeID					0x1D
        0,0, 
        "Micro Sec",     
        "Micro Seconds", 
        PROP_TYPE_BYTESWAPPED_DWORD,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KrbErrTagSumID				0x1E
		// Used in the inital display of KRB-ERROR
		0,0, 
        "KRB-ERROR",  
        "Kerberos Error", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbErrTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},


	{	//KrbTixAppSumID				0x1F
		//Used in summary displays of Explicit Application Tags
		0,0, 
        "Explicit Tag",  
        "Explicit Tags", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbTixApp1Set, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KrbTicketSumID				0x20
		// Used in summary displays of Ticket Variables
		0,0, 
        "KRB-Ticket",  
        "Kerberos Ticket", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbTicketSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},
	
	{	//KrbErrCodeID					0x21
		//Used to display Kerberos Error Codes
		0,0, 
        "Kerberos Error",  
        "Kerberos Error", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbErrCodeSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KrbMsgTypeID					0x22

		0,0,
		"Contents",
		"Display Contents Octet",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbMsgTypeSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},
		
	{	//PadataTypeValID				0x23
		0,0,
		"padata-type",
		"Value of padata-type",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &PadataTypeValSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//CipherTextDisp				0x24
		// Changed display from Cipher Text to Length.  Could possibly get rid of this
		// Leaving it in place in case we need to break down padata.
		0, 0,
		"Length",
		"Display Cipher Text",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		0,
		FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//FragUdpID						0x25
		0,0, 
        "Fragmented Kerberos cont.",  
        "Display Fragmented Kerberos Packets", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KdcReqBodyID					0x26
		0,0,
		"KDC-Req-Body",
		"KDC Req Body",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KdcReqBodySet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KdcReqBodyBitF				0x27
		0,0,
		"KDC-Req-Body",
		"KDC Req Body",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &KdcReqBodySet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//HostAddressesID				0x28
		0,0,
		"Addresses",
		"Addresses",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &HostAddressesSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//HostAddressesBitF				0x29
		0,0,
		"Addresses",
		"Addresses",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &HostAddressesSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	// DispStringCliName			0x2A
		0,0, 
        "Client Name",     
        "Display Client Name", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringRealmName			0x2B
		0,0, 
        "Realm Name",     
        "Display Realm Name", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringServerName			0x2C
		0,0, 
        "Server Name",     
        "Display Server Name", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringTixFlag				0x2D
		0,0, 
        "Ticket Flags",     
        "Display Ticket Flags", 
        PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringExpDate				0x2E
		0,0, 
        "Expiration Date",     
        "Display Expiration Date", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringPostDate			0x2F
		0,0, 
        "Post Date",     
        "Display Post Date", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringRenewTill			0x30
		0,0, 
        "Renew Till",     
        "Display Renew Till Time", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumRandomNumber   		0x31
		0,0, 
        "Random Number",     
        "Display Random Number", 
        PROP_TYPE_BYTESWAPPED_DWORD,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumEtype					0x32
		0,0,
		"Encryption Type",
		"Display Encryption Type",
		PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringAddresses			0x33
		0,0, 
        "Client Host Address",     
        "Display Random Number", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSummary					0x34
		0,0, 
        "Summary (ASN.1)",  
        "Display ASN.1 Summary", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringCliRealm			0x35
		0,0, 
        "Client Realm",     
        "Display Client's Realm", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispProtocolVer				0x36
		0,0,
		"Kerberos Protocol Version",
		"Display Kerberos Protocol Version",
		PROP_TYPE_BYTE, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispKerbMsgType				0x37
		0,0,
		"Kerberos Message Type",
		"Display Kerberos Message Type",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbMsgTypeSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumPreAuth				0x38
		0,0, 
        "Pre-Authentication Data",  
        "Display Pre-Authentication Date", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumReqBody				0x39
		0,0, 
        "KDC Request Body",  
        "Display KDC Request Body", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumKerbTix				0x3A
		0,0, 
        "Kerberos Ticket",  
        "Display Kerberos Ticket", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumTixVer					0x3B
		0,0, 
        "Ticket Version",  
        "Display Ticket Version", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispCipherText				0x3C
		0,0, 
        "Cipher Text",  
        "Display Text", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringCliTime				0x3D
		0,0, 
        "Current Client Time",     
        "Display Client's Current Time", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumCuSec					0x3E
		0,0, 
        "MicroSec Of Client",  
        "Display Microseconds of Client", 
        PROP_TYPE_BYTESWAPPED_DWORD,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringSrvTime				0x3F
		0,0, 
        "Current Server Time",     
        "Display Server's Current Time", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumSuSec					0x40
		0,0, 
        "MicroSec Of Server",  
        "Display Microseconds of Server", 
        PROP_TYPE_BYTESWAPPED_DWORD,
		PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumKerbErr				0x41
		0,0,
		"Kerberos Error",
		"Display Kerberos Error",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &KrbErrCodeSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringErrorText			0x42
		0,0, 
        "Error Text",     
        "Display Error Text", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispStringErrorData			0x43
		0,0, 
        "Error Data",     
        "Display Error Data", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	// DispFlagKdcOptions			0x44
	   0,0,
	  "KDC-Option Flags",
	  "Specifies KDC-Option Flags",
	  PROP_TYPE_BYTESWAPPED_DWORD,
	  PROP_QUAL_FLAGS,
	  &KdcOptionFlagsSet,
	  80 * 32,
	  FormatPropertyInstance },

	{	//DispStringServNameGS			0x45
		0,0,
		"Server Name",
		"Displays General Strings",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispSumEtype2					0x46
		0,0,
		"Encryption Type",
		"Display Encryption Type",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &EncryptionTypeSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//EncryptedDataTag				0x47
		0,0,
		"Encrypted Data",
		"Display Encrypted Data",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_SET, 
        &EncryptedDataSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//EncryptedDataTagBitF			0x48
		0,0,
		"Encrypted Data",
		"Encrypted Data",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &EncryptedDataSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KrbApReqID					0x49
		0,0,
		"Kerb-AP-Req",
		"Display AP-Req",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&KrbApReqSet,
		FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//KrbApReqBitF					0x4A
		0,0,
		"Kerb-AP-Req",
		"Display AP Req ASN.1",
		PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &KrbApReqSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispApOptionsSum				0x4B
		0,0, 
        "AP Options",     
        "Display AP Option Flags", 
        PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispFlagApOptions				0x4C
	   0,0,
	  "AP-Option Flags",
	  "Specifies AP-Option Flags",
	  PROP_TYPE_BYTESWAPPED_DWORD,
	  PROP_QUAL_FLAGS,
	  &ApOptionFlagsSet,
	  80 * 32,
	  FormatPropertyInstance },

	{	//DispSumTicket					0x4D
		0,0, 
        "Ticket",     
        "Display Ticket", 
        PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//ApTicketID					0x4E
		0,0,
		"Kerb-Ticket",
		"Display Ticket",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&ApTicketSet,
		FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//ApTicketBitF					0x4F
		0,0, 
        "Kerb-Ticket",
		"Display Ticket", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &ApTicketSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//TicketStructID				0x50
		0,0,
		"Kerb-Ticket",
		"Display Ticket",
		PROP_TYPE_BYTE,
		PROP_QUAL_LABELED_SET,
		&TicketStructSet,
		FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},
		
	{	//TicketStructBitF				0x51
		0,0, 
        "Kerb-Ticket",
		"Display Ticket", 
        PROP_TYPE_BYTE, 
        PROP_QUAL_LABELED_BITFIELD, 
        &TicketStructSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   //KerberosDefaultlbl			0x52
		// Kerberos continuation packets
        0,0, 
        "Kerberos Packet (Cont.) Use the Coalescer to view contents",  
        "Display Kerberos Continuation Packets", 
        PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // PaDataSummaryMulti			0x53
		// Global Displays values for the PADATA type if integer is multiple octets
        0,0, 
        "PA-DATA Type",     
        "PA-DATA Summary",     
        PROP_TYPE_BYTESWAPPED_WORD,    
		PROP_QUAL_LABELED_SET,
        &PaDataTagSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	// Certificatelbl				0x54
		// Because I couldn't find the ASN.1 layout for the certificates
		// Present in AS-Req and Rep's, I'm labeling the bits for now
		0,0,
		"Certificate Data",
		"Certificate Data Label",
		PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{	//DispEncryptionOptions			0x55
		0,0,
		"Supported Encryption Types",
		"Available Encryption Type",
		PROP_TYPE_SUMMARY, 
        PROP_QUAL_NONE, 
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // MethodDataSummary			0x56
		// Global Displays values for the PADATA type if integer is multiple octets
        0,0, 
        "Method-Data Type",     
        "Method-Data Type Summary",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_SET,
        &MethodDataSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // MethodDataBitF				0x57
		// Global Displays values for the PADATA type if integer is multiple octets
        0,0, 
        "Method-Data ",     
        "Method-Data Display",     
        PROP_TYPE_BYTE,    
		PROP_QUAL_LABELED_BITFIELD,
        &MethodDataSet, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance},

	{   // DispReqAddInfo				0x58
        0,0, 
        "Required Additional Info",     
        "Req Add Info Summary", 
        PROP_TYPE_STRING,
		PROP_QUAL_NONE,
        0, 
        FORMAT_BUFFER_SIZE, 
        FormatPropertyInstance}
		
		

};

DWORD nKerberosProperties = ((sizeof KerberosDatabase) / PROPERTYINFO_SIZE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\kerbparser.c ===
//=============================================================================
//  MODULE: Kerbparser.c
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

#define MAINPROG

#include "kerbparser.h"
#include "kerbGlob.h"
#include "kdcreq.h"
#include "kdcrep.h"
#include "krberr.h"
#include <stdio.h>


;// Need to find out why error is generated without this semicolon

//=============================================================================
//  Forward references.
//=============================================================================

VOID WINAPIV            KerberosFormatSummary(LPPROPERTYINST lpPropertyInst);
     
//=============================================================================
//  Protocol entry points.
//=============================================================================

VOID   WINAPI KerberosRegister(HPROTOCOL);
VOID   WINAPI KerberosDeregister(HPROTOCOL);
LPBYTE WINAPI KerberosRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);
LPBYTE WINAPI KerberosAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);
DWORD  WINAPI KerberosFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS KerberosEntryPoints =
{
    KerberosRegister,
    KerberosDeregister,
    KerberosRecognizeFrame,
    KerberosAttachProperties,
    KerberosFormatProperties
};

HPROTOCOL hKerberos = NULL;

DWORD Attached = 0;

PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD NumProtocols, NumHandoffs;
    PPF_HANDOFFSET    pHandoffSet;
    PPF_HANDOFFENTRY  pHandoffEntry;

    // Base structure ========================================================

    // Allocate memory for parser info:
    NumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc( GetProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof( PF_PARSERDLLINFO ) +
                                                   NumProtocols * sizeof( PF_PARSERINFO) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }       
    
    // fill in the parser DLL info
    pParserDllInfo->nParsers = NumProtocols;

    // fill in the individual parser infos...

    // BLRPLATE ==============================================================
    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    sprintf( pParserInfo->szProtocolName, "KERBEROS" );
    sprintf( pParserInfo->szComment,      "Kerberos Authentication Protocol" );
    sprintf( pParserInfo->szHelpFile,     "");

    
    // the incoming handoff set ----------------------------------------------
    // allocate
    NumHandoffs = 2;
    pHandoffSet = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof( PF_HANDOFFSET ) +
                                             NumHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pHandoffSet == NULL )
    {
        // just return early
        return pParserDllInfo;
    }

    // fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = NumHandoffs;

    // UDP PORT 88
    pHandoffEntry = &(pHandoffSet->Entry[0]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "KERBEROS" );
    pHandoffEntry->dwHandOffValue =        88;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;
    
    // TCP PORT 88
    pHandoffEntry = &(pHandoffSet->Entry[1]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "TCP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "KERBEROS" );
    pHandoffEntry->dwHandOffValue =        88;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;


    return pParserDllInfo;
}

//=============================================================================
//  FUNCTION: DLLEntry()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

BOOL WINAPI DLLEntry(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
    //=========================================================================
    //  If we are loading!
    //=========================================================================

    if ( Command == DLL_PROCESS_ATTACH )
    {
        if ( Attached++ == 0 )
        {
            hKerberos = CreateProtocol("KERBEROS", &KerberosEntryPoints, ENTRYPOINTS_SIZE);
        }
    }

    //=========================================================================
    //  If we are unloading!
    //=========================================================================

    if ( Command == DLL_PROCESS_DETACH )
    {
        if ( --Attached == 0 )
        {
            DestroyProtocol(hKerberos);
        }
    }

    return TRUE;                    //... Bloodhound parsers ALWAYS return TRUE.
}


//=============================================================================
//  FUNCTION: KerberosRegister()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

VOID WINAPI KerberosRegister(HPROTOCOL hKerberosProtocol)
{
    register DWORD i;

    //=========================================================================
    //  Create the property database.
    //=========================================================================

    CreatePropertyDatabase(hKerberosProtocol, nKerberosProperties);

    for(i = 0; i < nKerberosProperties; ++i)
    {
        AddProperty(hKerberosProtocol, &KerberosDatabase[i]);
    }

// Here we are checking to see whether TCP or UDP is being used.
    hTCP = GetProtocolFromName("TCP");
    hUDP = GetProtocolFromName("UDP");

}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

VOID WINAPI KerberosDeregister(HPROTOCOL hKerberosProtocol)
{
    DestroyPropertyDatabase(hKerberosProtocol);
}

//=============================================================================
//  FUNCTION: KerberosRecognizeFrame()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

LPBYTE WINAPI KerberosRecognizeFrame(HFRAME          hFrame,                //... frame handle.
                                LPBYTE          MacFrame,                   //... Frame pointer.
                                LPBYTE          KerberosFrame,             //... Relative pointer.
                                DWORD           MacType,                    //... MAC type.
                                DWORD           BytesLeft,                  //... Bytes left.
                                HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                                DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
                                LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
                                LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
                                PDWORD_PTR      InstData)                   //... Next protocol instance data.
{
//  ProtoInfo=GetProtocolInfo(hPreviousProtocol);

//  MessageBox(NULL, _itoa(TestForUDP,test,10),"TestForUDP 1", MB_OK);

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    return NULL;
}

//=============================================================================
//  FUNCTION: KerberosAttachProperties()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//=============================================================================

LPBYTE WINAPI KerberosAttachProperties(HFRAME    hFrame,
                                  LPBYTE    Frame,
                                  LPBYTE    KerberosFrame,
                                  DWORD     MacType,
                                  DWORD     BytesLeft,
                                  HPROTOCOL hPreviousProtocol,
                                  DWORD     nPreviousProtocolOffset,
                                  DWORD_PTR InstData)
{
// Local variable to hold the value of KerberosFrame, depending on whether
//  the packet is TCP or UDP.
    LPBYTE pKerberosFrame;
    


/* kf Here checking to see if first two octets of are equal to 00 00 which would be 
   the case should the packet be the first of TCP. 

*/
    if(KerberosFrame[0] == 0x00 && KerberosFrame[1] == 0x00)
    {
        TempFrame = KerberosFrame+4;
        pKerberosFrame = TempFrame;
    }
    else
    {
        TempFrame = KerberosFrame;
        pKerberosFrame = TempFrame;
    }

// Here we are going to do a check to see if the packet is TCP and
// check to see if the first two octets of the packet don't have the
// value of 00 00.  If not, then we mark the frame as a continuation
// packet.  Reason for doing this is because, sometimes 0x1F of the 
// first packet can still match one of the case statements which
// erroneously displays a continuation packet.  

// NOTE:  THIS CODE BREAKS ON SOME OF THE OLDER SNIFFS BECAUSE THE 4 
// OCTETS WHICH SPECIFY THE ENTIRE PACKET LENGTH WERE SENT IN A TCP 
// PACKET ALL BY ITSELF.  ACCORDING TO DEV, THIS ISN'T EXPECTED BEHAVIOR
// IN THE LATER W2K BUILDS.  THE 4 LENGTH OCTETS FOR TCP SHOULD ALWAYS BE 
// PRE-PENDED TO THE FIRST TCP PACKET


    if( hPreviousProtocol == hTCP && KerberosFrame[0] != 0 && KerberosFrame[1] != 0 )
    {
    // Displaying as a continutation packet
        AttachPropertyInstance(hFrame,
                               KerberosDatabase[KerberosDefaultlbl].hProperty,
                               BytesLeft,
                               TempFrame,
                               0, 0, 0);
    }
    else
    {

    // pKerberosFrame is a local variable and is used
    // to display TCP data as well.

        switch (*(pKerberosFrame) & 0x1F)
        {

            case ASN1_KRB_AS_REQ:
            case ASN1_KRB_TGS_REQ:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                TempFrame=KdcRequest(hFrame, TempFrame);
                break;

            case ASN1_KRB_AS_REP:
            case ASN1_KRB_TGS_REP:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                TempFrame=KdcResponse(hFrame, TempFrame);
                break;
            case ASN1_KRB_AP_REQ:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                break;
            case ASN1_KRB_AP_REP:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                break;
            case ASN1_KRB_SAFE:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                break;
            case ASN1_KRB_PRIV:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                break;
            case ASN1_KRB_CRED:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                break;

            case ASN1_KRB_ERROR:
                TempFrame=EntryFrame(hFrame, TempFrame, BytesLeft);
                TempFrame=KrbError(hFrame, TempFrame);
                break;

            default:
                AttachPropertyInstance(hFrame,
                                   KerberosDatabase[KerberosDefaultlbl].hProperty,
                                   BytesLeft,
                                   TempFrame,
                                   0, 0, 0);
            
            break;

        }
    }

    return (LPBYTE) KerberosFrame + BytesLeft;

}


//==============================================================================
//  FUNCTION: KerberosFormatProperties()
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//==============================================================================

DWORD WINAPI KerberosFormatProperties(HFRAME         hFrame,
                                 LPBYTE         MacFrame,
                                 LPBYTE         FrameData,
                                 DWORD          nPropertyInsts,
                                 LPPROPERTYINST p)
{
    
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

// kf Doing a check here for TCP packets.  If it's the first packet,
// we increment FrameData by 4 to get past the length header

    if(*FrameData == 0x00 && *(FrameData+1) == 0x00)
        FrameData+=4;

    while (nPropertyInsts--)
    {
        
	switch (*FrameData & 0x1F)
        {
            case ASN1_KRB_AS_REQ:
                strcpy(MsgType, "KRB_AS_REQ");
                break;
            case ASN1_KRB_AS_REP:
                strcpy(MsgType, "KRB_AS_REP");
                break;
            case ASN1_KRB_TGS_REQ:
                strcpy(MsgType, "KRB_TGS_REQ");
                break;
            case ASN1_KRB_TGS_REP:
                strcpy(MsgType, "KRB_TGS_REP");
                break;
            case ASN1_KRB_AP_REQ:
                strcpy(MsgType, "KRB_AP_REQ");
                break;
            case ASN1_KRB_AP_REP:
                strcpy(MsgType, "KRB_AP_REP");
                break;
            case ASN1_KRB_SAFE:
                strcpy(MsgType, "KRB_SAFE");
                break;
            case ASN1_KRB_PRIV:
                strcpy(MsgType, "KRB_PRIV");
                break;
            case ASN1_KRB_CRED:
                strcpy(MsgType, "KRB_CRED");
                break;
 
            case ASN1_KRB_ERROR:
                strcpy(MsgType, "KRB_ERROR");
                break;
            default:
                strcpy(MsgType, "Didn't recognize");
                break;
        }

        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}

LPBYTE EntryFrame(HFRAME hFrame, LPBYTE KerberosFrame, DWORD BytesLeft)
{
    int LenVal = 0;

    TempFrame=KerberosFrame;
        
        AttachPropertyInstance(hFrame,
                               KerberosDatabase[KerberosSummary].hProperty,
                               BytesLeft,
                               TempFrame,
                               0, 0, 0);


        AttachPropertyInstance(hFrame,
                               KerberosDatabase[KerberosIDSummary].hProperty,
                               sizeof(BYTE),
                               TempFrame,
                               0, 1, 0);
// Adding Code here to display Summary, thus letting us indent the ASN breakdown of the
// Identifier Octets to where the user won't initially see this.

    AttachPropertyInstance(hFrame,
                           KerberosDatabase[DispSummary].hProperty,
                           0,
                           TempFrame,
                           0, 2, 0);

// Break down the Identifier Octet for Message Type     
    TempFrame=CalcMsgType(hFrame, TempFrame, 3, KerberosIdentifier);

// Display Length Octet
    TempFrame=CalcLengthSummary(hFrame, TempFrame, 3);

    
// Adjust TempFrame the appropriate # of octets
    LenVal=CalcLenOctet(TempFrame-1);

// This code handles incrementing to the proper octet based
// on the number of octets occupied by TempFrame.
    if(LenVal <= 1)
        return TempFrame;
    else
        return TempFrame+=(LenVal-1);

}

/*************************************************************************************
**
**
** This function handles: pa-data ::=   SEQUENCE{
**                                          padata-type[1]  INTEGER,
**                                          padata-value[2] OCTET STRING
**                                          }
** hFrame = Handle to the frame.
**
** TempFrame =  Offset we which we are at in the current packet
**
** OffSet =  The indention level to display the data within Netmon
**
** TypeVal = Variable used to identify node from KerberosDatabase[]
**
************************************************************************************/

LPBYTE HandlePaData(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
    int TempLength;
    
    int lValueReqPadata = 0;

  

//Display Padata[?] NEED TO CHANGE THIS FUNCTION TO PASS THE PARAMETERS SO THE FUNCTION
// WILL DISPLAY THE PROPER PADATA
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, KdcReqTagID, KdcReqSeq);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

//Display SEQUENCE OF
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

/*  Incrementing TempFrame based on the number of octets
    taken up by the Length octet
*/
    TempFrame = IncTempFrame(TempFrame);

//Display SEQUENCE OF
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

// Display padata-type[1]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, PaDataSummary, PaDataSeq);

// Display INTEGER value
    TempFrame =DispPadata(hFrame, TempFrame, OffSet+4, PadataTypeValID);

// Display padata-value[2]
     DispASNTypes(hFrame, TempFrame, OffSet+2, PaDataSummary, PaDataSeq);


// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, ++TempFrame, OffSet+5);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

//Display OCTET STRING
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+7);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// HERE IT LOOKS AS IF AN AS-REQ, PADATA-VALUE IS FORMATTED AS ENCRYPTEDDATA
//  AND TGS IS FORMATTED AS AP-REQ.  HOWEVER, IF A SMART CARD IS PRESENT, IT IS
// FORMATTED AS.

// Check to see if formatted as AP-REQ (6E)
    if(*(TempFrame+1) == 0x6E )
        TempFrame = HandleAPReq(hFrame, TempFrame);  // If true, handle AP-REQ traffic
    else if(*(TempFrame+1) == 0x81)
    {// Here I'm incrementing TempFrame by two to get it to the first
    // offset making up the Length Octet.
        TempFrame++;
                
    // Here I'm going to label the rest of the data as a Certificate
        TempLength = CalcMsgLength(TempFrame);

        AttachPropertyInstance(hFrame,
                   KerberosDatabase[Certificatelbl].hProperty,
                   TempLength,
                   TempFrame,
                   0, OffSet+4, 0);

    // Increment TempFrame by the length octet value returned by CalcMsgLength
        TempFrame+=TempLength;

    // Pretty sloppy hack here but hoping Dev will supply me doc
    // of how the certificate is structured in ASN.1.  For the time
    // being, CalcMsgLength doesn't take us to the end of padata and the
    // start of KDC-Req-Body.  With no idea of what the A1 and A2 tags I see
    // in the smart card sniff.  I don't know if it will possibly ever contain
    // an A4.  But at anyrate, I'm going to increase TempFrame by one until
    // a value of A4 is matched.  (This signifies the start of KDC-Req-Body.)

        while(*TempFrame != 0xA3)
        {
          ++TempFrame;
        }

    // Once TempFrame is A4, have to decrement TempFrame by one
    // in order for KDC-Req-Body to start on the correct offset.
    // Again this whole else statement is a Kludge but not much I can
    // until I get the ASN.1 layout of Certificates.
        --TempFrame;
    }
    else
    {
    //Display SEQUENCE OF
        TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4, ASN1UnivTagSumID, ASN1UnivTag);

    // Display Length Octet(s)
        TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+7);


    //  Incrementing TempFrame based on the number of octets
    //  taken up by the Length octet
        TempFrame = IncTempFrame(TempFrame);

        if(*(TempFrame+1) == 0xA0)
        {
        // Handle EncryptedData
            TempFrame = HandleEncryptedData( hFrame, TempFrame, OffSet+2);

        }
// kfrost 11/12 In smart card the value here is 0x80 or 0x81 in as-req & as-rep respectively.
// Can not find out or get Dev to produce the appropriate ASN.1 format that is being
// followed here.  Basically, whatever encoding layout that is being followed, the first
// parameter is 06 Object Identifier.  The only thing I have found is KERB-ALGORITHM-IDENTIFIER
// found in krb5.asn.  Until I get some assistance walking through the offsets, I'm going to label
// the data as PKCS and increment TempFrame past all of this and start parsing again at KDC-Req-Body

        else
        {
            if(*(TempFrame+1) == 0x80)
            {
            // Here I'm incrementing TempFrame by two to get it to the first
            // offset making up the Length Octet.
                TempFrame++;
                
            // Here I'm going to label the rest of the data as a Certificate
                TempLength = CalcMsgLength(TempFrame);

                AttachPropertyInstance(hFrame,
                           KerberosDatabase[Certificatelbl].hProperty,
                           TempLength,
                           TempFrame,
                           0, OffSet+4, 0);

            // Increment TempFrame by the length octet value returned by CalcMsgLength
                TempFrame+=TempLength;

            // Pretty sloppy hack here but hoping Dev will supply me doc
            // of how the certificate is structured in ASN.1.  For the time
            // being, CalcMsgLength doesn't take us to the end of padata and the
            // start of KDC-Req-Body.  With no idea of what the A1 and A2 tags I see
            // in the smart card sniff.  I don't know if it will possibly ever contain
            // an A4.  But at anyrate, I'm going to increase TempFrame by one until
            // a value of A4 is matched.  (This signifies the start of KDC-Req-Body.)

                while(*TempFrame != 0xA4)
                {
                  ++TempFrame;
                }

            // Once TempFrame is A4, have to decrement TempFrame by one
            // in order for KDC-Req-Body to start on the correct offset.
            // Again this whole else statement is a Kludge but not much I can
            // until I get the ASN.1 layout of Certificates.
                --TempFrame;

            }
        }

    }


// Not going to display anymore padata after this point.  padata[3] is a
// SequenceOf.  Any repetition traffic will get highlighted and TempFrame will
// be incremented to the appropriate frame which starts req-body[4]

        while(*(TempFrame+1) == 0x30)
        {
            TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4, ASN1UnivTagSumID, ASN1UnivTag);

        // Display Length Octet(s)
            TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+7);

        // Adjust TempFrame to the appropriate octet
            TempFrame+=(CalcMsgLength(--TempFrame)+1);
        }

    return TempFrame;
}

LPBYTE HandleEncryptedData(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{
    int size = 0;
    int value = 0;
// Display Encryption Type
    TempFrame = DefineEtype(hFrame, TempFrame, OffSet+2, DispSumEtype2, EncryptedDataTag, EncryptedDataTagBitF);

// Display Kvno[1] OPTIONAL 

    if(*TempFrame == 0xA1)
    {
// KF LEFT OFF HERE.  CLEAN UP CODE TO DISPLAY KVNO CORRECT
        // Display Universal Class Tag
        TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+2, EncryptedDataTag, EncryptedDataTagBitF);
    // Need to finish handling kvno[1]
    // Display INTEGER value
        TempFrame =DispPadata(hFrame, TempFrame, OffSet+4, PadataTypeValID);
    
    // The following increments TempFrame by 1 to get to the cipher[2] octet, however
    // it doesn't take into account if the integer value takes up more than one octet.
        ++TempFrame;
    }

// Display cipher[2]
    TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+2, EncryptedDataTag, EncryptedDataTagBitF);

// Determing the size of cipher[2]
    size = CalcMsgLength(TempFrame);

// Determine whether Length Octet is short or long to
// use in incrementing TempFrame in return value
    value = *(TempFrame+1);

// Display Length Octet(s) and highlight cipher text
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);


// The following return takes the offset to the end of cipher[2].  If 
//  value is  equal to 0x81 then the length octet was short form
// else it's long form so add to size to TempFrame.  If long from assumming
// length octet will be 2.

    if(value <= 0x81)
    {
        return TempFrame+=(size);
    }
    else
    {
        return TempFrame+=(size+1);
    }
}


// This function is used to break down Identifier Octets and display their types
LPBYTE CalcMsgType(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal )
{

    AttachPropertyInstance(hFrame,
                           KerberosDatabase[KerberosClassTag].hProperty,
                           sizeof(BYTE),
                           TempFrame,
                           0, OffSet, 0);

    AttachPropertyInstance(hFrame,
                           KerberosDatabase[PCIdentifier].hProperty,
                           sizeof(BYTE),
                           TempFrame,
                           0, OffSet, 0);

    AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           sizeof(BYTE),
                           TempFrame,
                           0, OffSet, 0);

    return TempFrame;
}

LPBYTE CalcLengthSummary(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{
    // Check the first bit of the length octet to see if length is short form (Value 0)
    // or Long Form (Value is 1)
    if(*(++TempFrame) & 0x80)
    {
        // This code handles long form.  Bits 7-1 of this octet give the number of additional
        // octets associated with this length octet.  We need some type of checking after the last
        // octet in length to determine if the next octet is an Identifier or Contents.
        //  The additional octets specified in bits 7-1 of the first octet give the length.
        
        
        LongSize = *(TempFrame) & 0x7F;  // Assign LongSize to the value of bits 7-1

        lValueRepMsg = CalcMsgLength(TempFrame-1);
        AttachPropertyInstance(hFrame,
                               KerberosDatabase[LengthSummary].hProperty,
                               sizeof(BYTE)+LongSize, // This highlights all bits associated with Length
                               TempFrame,
                               0, OffSet, 0);
    
        AttachPropertyInstance(hFrame,
                               KerberosDatabase[LengthFlag].hProperty, // Will display short or Long
                               sizeof(BYTE),
                               TempFrame,
                               0, OffSet+1, 0);

        AttachPropertyInstanceEx(hFrame,
                                 KerberosDatabase[LengthBits].hProperty, // Shows how many octets used in Length
                                 sizeof(BYTE),
                                 TempFrame,
                                 1,
                                 &LongSize,
                                 0, OffSet+1, 0);

        if(LongSize > 1)
            AttachPropertyInstance(hFrame,
                                   KerberosDatabase[LongLength1].hProperty,
                                   LongSize,
                                   TempFrame+=1,
                                   0, OffSet+1, 0);
        else
            AttachPropertyInstance(hFrame,
                                   KerberosDatabase[LongLength2].hProperty,
                                   LongSize,
                                   TempFrame+=1,
                                   0, OffSet+1, 0);
    }
    else
    {   // Assuming this code is to handle short form.
        
        
    lValueRepMsg = CalcMsgLength(TempFrame-1);  
    AttachPropertyInstance(hFrame,
                           KerberosDatabase[KdcReqSeqLength].hProperty,
                           sizeof(BYTE)+lValueRepMsg,
                           TempFrame,
                           0, OffSet, 0);
        
    }

    return TempFrame;
}

LPBYTE DefineValue(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
    BYTE Size[4];
    PBYTE lSize = (PBYTE)&Size;

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+2);

// Need to advance TempFrame the proper # of frames.
    TempFrame = IncTempFrame(TempFrame);

// Display Universal Class Tag
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

// Need to advance TempFrame the proper # of frames.
    TempFrame = IncTempFrame(TempFrame);
        
// Code below is used to display Integer values if they occupy more than 2 octets
    if (*(TempFrame) == 3)
    {
        memcpy(lSize, TempFrame, 4);
        *lSize = *lSize & 0xffffff00;
    // Prints out Value.  Need to change the Array to give better description
        AttachPropertyInstanceEx(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               *(TempFrame-1),
                               ++TempFrame,
                               *(TempFrame) == 3 ? 4 : *(TempFrame),
                               lSize,                       
                               0, OffSet, 0);
    }
    else
    {
    // Prints out Value.  Need to change the Array to give better description
        AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           *(TempFrame-1),
                           ++TempFrame,
                           0, OffSet+1, 0);
    }

// kf 8/16 This wasn't returning to the proper octet in some cases
    return (TempFrame-1)+*(TempFrame-1);
    
}

/* This is spinoff of DefineValue.  However, this code has been modified
    to handle displaying the ASN.1 breakdown of etype[?]
*/

LPBYTE DefineEtype(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal, DWORD TypeVal2, DWORD TypeVal3)
{
// Display Universal Class Tag
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, TypeVal2, TypeVal3);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

    while(*(++TempFrame) == 0x02)
    {
        --TempFrame;

        TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x02, OffSet, DispSumEtype2);

    // Display Unversal Class Tag
        TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);

    // Display Length Octet
        TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

    // Increment TempFrame according to length octet
        TempFrame+=CalcMsgLength(--TempFrame);
        
        ++TempFrame;

    // Display First Encryption Type
        AttachPropertyInstance(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               1,
                               TempFrame,
                               0, OffSet+4, 0);

    }


    return TempFrame;
}


int CalcMsgLength(LPBYTE TempFrame)
{
    if(*(TempFrame+1) & 0x80)
    {

        LongSize = *(TempFrame+1) & 0x7F;

        if(LongSize > 1)
            // Here we are or'd the two values of the length octets together
            // Note this could fail if the Length octet ever took up more than
            // two octets in defining a length
            return (*(TempFrame+3)) | (*(TempFrame+2) << 8);
        else
            // This is in case the length octet only had one following defining octet
            return (BYTE) *(TempFrame+2);
    }
    else
        // For a short form Length octet
        return  *(TempFrame+1) & 0x7F;


}

/***********************************************************************************************************
**
** This function will break down ASN.1 PrincipalName.
** PrincipalName ::= SEQUENCE{
**                          name-type[0]    INTEGER,  Specifies the type of name that follows.
**                                                    Pre-defined values for this field are specified in 
**                                                    section 7.2.
**                          
**                          name-string[1]  SEQUENCE OF GeneralString   Encodes a sequence of components
**                                                                      that form a name, each component
**                                                                      encoded as a GeneralString.  Taken
**                                                                      together, a PrincipalName and a Realm
**                                                                      form a principal Identifier.
**
**************************************************************************************************************/

LPBYTE DefinePrincipalName(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
//  This functions starts breaking down the A0 octet of a PrincipalName

// Print out name-type[0] of PrincipalName
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, KrbPrincipalNamelSet, KrbPrincipalNamelBitF);

// Display octets associated with INTEGER
    TempFrame = DefineValue(hFrame, TempFrame, OffSet+2, KrbPrincNameType);
// End code to display name-type[0] of PrincipalName


// Print out name-string[1] of PrincipalName
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, KrbPrincipalNamelSet, KrbPrincipalNamelBitF);

// Display Length Summary
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+2);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);       
                
// Print out Length Octet 
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);
    
// Checking for GeneralString 0x1B
    TempRepGString = *(++TempFrame) & 0x1F;
    
    while(TempRepGString == 0x1B)
    {
    //Display GeneralString
        TempFrame = DispASNTypes(hFrame, --TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);
                
    // Calculate the size of the Length Octet
        lValueRepMsg = CalcMsgLength(TempFrame);
    
    //Display Length Octet
        TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

    //  Incrementing TempFrame based on the number of octets
    //  taken up by the Length octet
        TempFrame = IncTempFrame(TempFrame);
    

        AttachPropertyInstance(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               sizeof(BYTE)+(lValueRepMsg - 1),
                               ++TempFrame,
                               0, OffSet+3, 0);
    //  Assign TempRepGString to value of octet after the string to see if another SEQUENCE OF
    //  GeneralString exists.
        
          TempRepGString = *(TempFrame+=lValueRepMsg) & 0x1F;
    
          
    }
// End Code to display name-string[1]

    return TempFrame;

}


// Function used parse Length octets in PrincipalName
int CalcLenOctet(LPBYTE TempFrame)
{
    int size = 0;
// If long form, assign size to value of bits 7-1
    if(*(TempFrame) & 0x80)
        size = (*(TempFrame) & 0x7F);
    else
// Short form, only takes one octet
        size = 1;
        
    return size;

}
/**********************************************************************************************
**
**  LPBYTE DispASNTypes(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal, DWORD TypeVal2)
**
**  This function is used to break down and display the ASN.1 Universal Tags.
**  (Universal Tag Allocations can be found at page 155 in ASN.1 by Douglas Steedman.)
**
** hFrame -  Handle to the fram
** TempFrame - Pointer to the current offset in the packet
** Offset  - Used for indenting the parser display
** TypeVal - Used to distinguish which node out of the KerberosDatbase to use
** TypeVal2 - Same use as TypeVal
**
**********************************************************************************************/

LPBYTE DispASNTypes(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal, DWORD TypeVal2)
{
    
// Assign the value of last 5 bits to TempAsnMsg
    TempAsnMsg = *(++TempFrame) & 0x1F;


// Calculates the length octet to see how many octets should be highlighted
    lValueRepMsg = CalcMsgLength(TempFrame);

// Display the Identifier and the appropriate # of octets are highlighted
    AttachPropertyInstanceEx(hFrame,
                             KerberosDatabase[TypeVal].hProperty,
                             sizeof(WORD) + lValueRepMsg,
                             TempFrame,
                             1,
                             &TempAsnMsg,
                             0, OffSet, 0);



// Adding Code here to display Summary, thus letting us indent the ASN breakdown of the
// Identifier Octets to where the user won't initially see this.

    AttachPropertyInstance(hFrame,
                           KerberosDatabase[DispSummary].hProperty,
                           0,
                           TempFrame,
                           0, OffSet+1, 0);

// Break out the identifier octet to ASN.1 format
    TempFrame=CalcMsgType(hFrame, TempFrame, OffSet+2, TypeVal2);

    return TempFrame;
}

LPBYTE DispSeqOctets(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal, DWORD TypeVal2)
{
// Display SEQUENCE (First frame we handle in this file.
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, TypeVal, TypeVal2);

// Display Length Octet 
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

    return TempFrame;

}


/***********************************************************************************************************
**
** This function will break down ASN.1 HostAddresses. P39 rfc 1510
** HostAddresses::= SEQUENCE OF SEQUENCE{
**                          addr-type[0]    INTEGER,
**                          address[1]      OCTET STRING,
**                          }
**
**
**                          
**                          
**                          
**
**************************************************************************************************************/
LPBYTE DispHostAddresses(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{
// Determine the number of octets occupied by the length ocet
    lValueRepMsg = CalcLenOctet(TempFrame);

// Checking for SEQUENCE OF 0x30
    TempReq = *(TempFrame+lValueRepMsg);
    
// while loop is calculate SEQUENCE OF SEQUENCE
while(TempReq == 0x30)
{
    // Display SEQUENCE Octets
        TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+2, ASN1UnivTagSumID, ASN1UnivTag);  

    // Display addr-type[0]
        TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, HostAddressesID, HostAddressesBitF);

    // Calculate the size of the Length Octet
        lValueRepMsg = CalcMsgLength(TempFrame);

    // Display INTEGER
        TempFrame = DefineValue(hFrame, TempFrame, OffSet+4, KdcContentsValue);

    // Display address[1]
        TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, HostAddressesID, HostAddressesBitF);

    // Display String value
        TempFrame = DefineValue(hFrame, TempFrame, OffSet+4, DispString);

        TempReq = *(TempFrame+lValueRepMsg);

        
}


    return TempFrame;
}


LPBYTE DispSum(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int ClassValue2, int OffSet, DWORD TypeVal)
{
    /*      Working here now to display info name at the top.  Will indent everything
            else 1 to the right.  Not sure how well this is going to work since name-string[1]
            is a SEQUENCE OF.  Writing code now to assume there is only going to be one name 
            and display the first one.

    */
    TempFrameReq = (TempFrame+1);
    TempFrameReq2 = (TempFrame+2);

    // This while statement increments TempFrameReq until 1B is reached
    // If 1B is ever used in a length octet or elsewhere this will fail.  
    // Might look at doing a memcopy later on to a global variable 
    // THINK WE CAN USE BERGETSTRING TO DISPLAY FULL SERVER NAME.  WE CAN
    // USE A STRING CONSTANTS WITH TO DISPLAY THE FULL VALUE.



// Incrementing TempFrameReq until String is found
        while(*(TempFrameReq) != ClassValue || *(TempFrameReq2) == ClassValue2)
        {
            TempFrameReq++;
            TempFrameReq2++;

        // Trying to come up with a way to make sure the Length Value doesn't == ClassValue
        // Still need some type of checking in case the length octet's value after the SEQUENCE OF
        // turns out to be equal to ClassValue.
            if(*(TempFrameReq) == ClassValue && *(TempFrameReq2) == ClassValue2)
            {
                TempFrameReq++;
                TempFrameReq2++;
                // Checking to see if Length Octet's value after SEQUENCE OF is equal to ClassValue.  If so,
                //  incrementing TempFrameReq in order to get to the correct offset.
                if(*(TempFrameReq) == ClassValue2 && *(TempFrameReq2) == ClassValue)
                {   
                    TempFrameReq++;
                    TempFrameReq2++;
                }
            }
        }
        
        if(ClassValue2 == 0x02)
        {// Put this if statement to handle highlighting the appropriate # of 
        // Octets for EType.  Don't know how valid this is going to be but trying
        // to get all the code in.  Will worry about later.
        // Calculate the value of the length octet
            lValueReq = CalcMsgLength(TempFrameReq-1);

            AttachPropertyInstance(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               1,
                               TempFrameReq+=2,
                               0, OffSet, 0);
        }
        else
        {
        // Calculate the value of the length octet
            lValueReq = CalcMsgLength(TempFrameReq);
        
        // Increment TempFrameReq to the proper Octet   
            TempFrameReq+=CalcLenOctet(TempFrameReq);

            AttachPropertyInstance(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               sizeof(BYTE)+(lValueReq-1),
                               ++TempFrameReq,
                               0, OffSet, 0);
        }
        
    return TempFrame;
}

/****************************************************************************
**
**
** This function is used to display a top level Summary description
**
**
****************************************************************************/
LPBYTE DispTopSum(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
    AttachPropertyInstance(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               0,
                               TempFrame,
                               0, OffSet, 0);

    return TempFrame;

}



/*********************************************************************************
**
**  Another Subset of DispSum.  Altering this function to gather string info
**  and reformat to print out in a Date, Time format.
**
*********************************************************************************/

LPBYTE DispSumTime(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int OffSet, DWORD TypeVal)
{
    char RawTimeBuf[16];
    char TimeFormatBuf[TIME_FORMAT_SIZE];
    LPSTR TimeFormat = TimeFormatBuf;

    TempFrameReq = (TempFrame+1);
    TempFrameReq2 = (TempFrame+2);

    // This while statement increments TempFrameReq until 1B is reached
    // If 1B is ever used in a length octet or elsewhere this will fail.  
    //  Next loop is to find 1B value and is designed to prevent mistakenly
    // going to the wrong octet in case a 1b is the value in a Length octet

// Incrementing TempFrameReq until String is found
    while(*(TempFrameReq) != ClassValue || *(TempFrameReq2) == 0x30)
    {
	TempFrameReq++;
	TempFrameReq2++;

	// Trying to come up with a way to make sure the Length Value doesn't == ClassValue
        // Still need some type of checking in case the length octet's value after the SEQUENCE OF
        // turns out to be equal to ClassValue.
	if(*(TempFrameReq) == ClassValue && *(TempFrameReq2) == 0x30)
        {
	    TempFrameReq++;
	    TempFrameReq2++;
	    // Checking to see if Length Octet's value after SEQUENCE OF is equal to ClassValue.  If so,
	    //  incrementing TempFrameReq in order to get to the correct offset.
	    if(*(TempFrameReq) == 0x30 && *(TempFrameReq2) == ClassValue)
            {   
		TempFrameReq++;
		TempFrameReq2++;
	    }
	}
    }
        
        
    // Calculate the value of the length octet 
    lValueReq = CalcMsgLength(TempFrameReq);

    if( lValueReq > ((sizeof RawTimeBuf) / (sizeof RawTimeBuf[0])) )
    {
	memcpy( RawTimeBuf, (TempFrameReq+2), sizeof RawTimeBuf / sizeof RawTimeBuf[0] );
    }
    else
    {
	memcpy(RawTimeBuf, (TempFrameReq+2), lValueReq);	    	    
    }
	    
    sprintf( TimeFormat, TIME_FORMAT_STRING, 
	     RawTimeBuf[4],  RawTimeBuf[5],                               // month
	     RawTimeBuf[6],  RawTimeBuf[7],                               // day
	     RawTimeBuf[0],  RawTimeBuf[1], RawTimeBuf[2], RawTimeBuf[3], // year
	     RawTimeBuf[8],  RawTimeBuf[9],                               // hours
	     RawTimeBuf[10], RawTimeBuf[11],                              // minutes
	     RawTimeBuf[12], RawTimeBuf[13] );                            // seconds

    // Increment TempFrameReq to the proper Octet   
    TempFrameReq+=CalcLenOctet(TempFrameReq);
    
    // Display initial Time
    AttachPropertyInstanceEx( hFrame,
			      KerberosDatabase[TypeVal].hProperty,
			      lValueReq,
			      ++TempFrameReq,
			      TIME_FORMAT_SIZE,
			      TimeFormat,
			      0, 
			      OffSet, 
			      0 );

    return TempFrame;
}

/******************************************************************************
**
**  Created this function to address displaying the FQDN of the server name (under KDC-Options)
**  at the top level.  
**
*******************************************************************************/

LPBYTE DispSumString(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int OffSet, DWORD TypeVal)
{
    LPBYTE TempFrameSname, TempFrameSnameB;
    int segments = 0;
    int j = 0; 
    int ServNameCount = 0;
    int lValueStr = 0;
    int sizeAsString = 0;
    LPSTR cServName = NULL;
    LPSTR ServNameBuf[MAX_SERVER_NAME_SEGMENTS];
    memset( ServNameBuf, 0, sizeof ServNameBuf );
    
    TempFrameSname = (TempFrame+1);
    TempFrameSnameB = (TempFrame+2);

    // This while statement increments TempFrameReq until ClassValue is reached

    // Incrementing TempFrameReq until ClassValue
    while(*(TempFrameSname) != ClassValue || *(TempFrameSnameB) == 0x30)
    {
	TempFrameSname++;
	TempFrameSnameB++;

	// Trying to come up with a way to make sure the Length Value doesn't == ClassValue
	// Still need some type of checking in case the length octet's value after the SEQUENCE OF
	// turns out to be equal to ClassValue. 11/18.  Found a situation where the first part of 
	// of a principal name had the length of 1B.  Added the || *(TempFrameSnameB) == 0xA0 to
	// handle this problem  The 0xA0 is the first tag of Principal Name
	if(*(TempFrameSname) == ClassValue && *(TempFrameSnameB) == 0x30 || *(TempFrameSnameB) == 0xA0)
        {
	    TempFrameSname++;
	    TempFrameSnameB++;
	    // Checking to see if Length Octet's value after SEQUENCE OF is equal to ClassValue.  If so,
	    //  incrementing TempFrameReq in order to get to the correct offset.
	    if(*(TempFrameSname) == 0x30 && *(TempFrameSnameB) == ClassValue)
	    {   
		TempFrameSname++;
		TempFrameSnameB++;
	    }
	}
    }


    TempFrameSnameB = TempFrameSname;

    while(*(TempFrameSnameB) == ClassValue)
    {
	if( segments >= MAX_SERVER_NAME_SEGMENTS ) 
	{
	    break;
	}

	lValueStr = CalcMsgLength(TempFrameSnameB);
	sizeAsString = lValueStr + sizeof '\0';

	ServNameCount += lValueStr;
	ServNameBuf[ segments ] = (LPSTR) malloc( sizeAsString );

	if( ServNameBuf[ segments ] == NULL )
        {	   
	    for( ; segments > 0; segments-- )
	    { 
		free( ServNameBuf[segments - 1] );
	    }
	    return TempFrame;
	}

	ZeroMemory( ServNameBuf[ segments ], sizeAsString );
	memcpy( ServNameBuf[ segments ], TempFrameSnameB+2, lValueStr );

	// Use the Length Octet to progress TempFrameReq
	TempFrameSnameB+=CalcMsgLength(TempFrameSnameB);

	// Need to Increment TempFrameSnameB by number of ASN.1 octets
	// Increasing by two here.  This could be wrong if the Length octet
	// were ever in Long Form.
	TempFrameSnameB+=2;

	segments++;
    }

    cServName = (LPSTR) malloc( ServNameCount + segments );    
    if (NULL == cServName)
    {
	for( ; segments > 0; segments-- )
	{ 
	    free( ServNameBuf[segments - 1] );
	}
	return TempFrame;
    }

    ZeroMemory(cServName, ServNameCount + segments );
    strcpy(cServName, ServNameBuf[0]);

    for( j = 1; j < segments; j++ )
    {
	strcat(cServName, "/");
	strcat(cServName, ServNameBuf[j]);
    }

    AttachPropertyInstanceEx(hFrame,
                             KerberosDatabase[TypeVal].hProperty,
                             ServNameCount + 2*segments,
                             TempFrameSname+=2,
                             ServNameCount + segments,
                             cServName,
                             0, OffSet, 0);

    for( ; segments > 0; segments-- )
    { 
	free( ServNameBuf[segments - 1] );
    }
    
    if (NULL != cServName)
    {
	free(cServName);
    }                    

    return TempFrame;
}

/*********************************************************************************
**
**
** This function was copied from DefineValue but was created to display the 
**  Ticket Flags for KDC-Options in the KDC-Req packet.
**
*********************************************************************************/

LPBYTE DefineKdcOptions(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{


    AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           sizeof(DWORD),
                           TempFrame,
                           0, OffSet, 0);

    return (TempFrame);
}


/*****************************************************************************
*  This function is used to display the initial values of padata-type[1] & 
* padata-value[2] found in the AS-REQ packet
*  NOTE: I LEFT *INTVAL AND THE OTHER LINES COMMENTED AS FOR IF THE INT VALUE
*   TAKES UP TWO OCTETS, WE ONLY DISPLAY THE # INSTEAD OF ENCRYPTION TYPE. NOT
* WORRYING WITH THIS AT THIS TIME BUT LEAVING THE CODE IN PLACE SHOULD IT NEED
* TO BE IMPLEMENTED.
*****************************************************************************/
LPBYTE DispPadata(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
// Calculate Length Octet and highligh the # of octets
//  BYTE *intval;
    int size = 0;

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+1);


//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display Universal Class Tag
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

//Assumming the Integer value will always be contained in
// either 1 or 2 octets.

    size = *TempFrame;

// Here need to check the length octet and determine whether 
// it is short or long form
    
    if(size == 1)
    {
//      intval = malloc(2);
//      memcpy(intval, (TempFrame+1), 2);

    // Prints out Value.  Need to change the Array to give better description
            AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           1,
                           ++TempFrame,
                           0, OffSet+1, 0);
                            

/*      AttachPropertyInstanceEx(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           1,
                           ++TempFrame,
                           4,
                           intval,
                           0, OffSet, 0);
*/
    }
    else
    {
//      intval = malloc(4);
//      memcpy(intval, (TempFrame+1), 4);
//      *intval = *(intval) & 0xffff;
            AttachPropertyInstance(hFrame,
                           KerberosDatabase[PaDataSummaryMulti].hProperty,
                           1,
                           ++TempFrame,
                           0, OffSet+1, 0);
/*
    // Prints out Value.  Need to change the Array to give better description
        AttachPropertyInstanceEx(hFrame,
                           KerberosDatabase[PaDataSummaryMulti].hProperty,
                           2,
                           ++TempFrame,
                           4,
                           intval,
                           0, OffSet, 0);
*/
    // Incrementing TempFrame by an extra Octet because the Integer here takes
    // up 2 octets instead of one.
        ++TempFrame;
    }

    return (TempFrame);
}

LPBYTE IncTempFrame(LPBYTE TempFrame)
{
    if(*(TempFrame-1) >= 0x81 && *(TempFrame-1) <= 0x84)
        TempFrame+=CalcLenOctet(--TempFrame);
    else
        TempFrame;

    return TempFrame;
}

LPBYTE HandleTicket(HFRAME hFrame, LPBYTE TempFrame, int OffSet)
{

// Display Summary ASN.1
    TempFrame = DispASNSum(hFrame, TempFrame, OffSet+1, DispSummary);

//Display Ticket[3]
    // Display msg-type[2]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, KrbApReqID, KrbApReqBitF);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display Ticket (61)
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, ApTicketID, ApTicketBitF);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE
    TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+3, ASN1UnivTagSumID, ASN1UnivTag);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display Ticket Version value at the Top level
    TempFrame = DispSum(hFrame, TempFrame, 0x02, 0x30, OffSet+2, DispSumTixVer);

// Display tvt-vno[0]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+3, TicketStructID, TicketStructBitF);

// Break Down INTEGER values    
    TempFrame = DefineValue(hFrame, TempFrame, OffSet+4, KdcContentsValue);

// Display Realm name value at the Top level
    TempFrame = DispSum(hFrame, TempFrame, 0x1B, 0x30, OffSet+2, DispStringRealmName);

// Display realm[1]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+3, TicketStructID, TicketStructBitF);
    TempFrame = DefineValue(hFrame, TempFrame, OffSet+5, DispStringRealmName);

// Display Server name value at the Top level
    TempFrame = DispSumString(hFrame, TempFrame, 0x1B, OffSet+2, DispStringServNameGS);

// Display sname[2]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+3, TicketStructID, TicketStructBitF);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE Octets
    TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+4, ASN1UnivTagSumID, ASN1UnivTag);

// Display sname[2]  
    TempFrame = DefinePrincipalName(hFrame, TempFrame, OffSet+3, DispStringServerName);

    --TempFrame;

    
// Display enc-part[3]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, TicketStructID, TicketStructBitF);
    
// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+4);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

// Display SEQUENCE Octets
    TempFrame = DispSeqOctets(hFrame, TempFrame, OffSet+4, ASN1UnivTagSumID, ASN1UnivTag);
    
//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

//Display EncryptedData
    TempFrame = HandleEncryptedData(hFrame, TempFrame, OffSet+1);

    return TempFrame;

}

LPBYTE DispASNSum(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
        AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           0,
                           TempFrame,
                           0, OffSet, 0);
    return TempFrame;

}

/************************************************************************************
**
**This function is a spinoff of DispSum. I created this one separately for the sole
**purpose of displaying the full value of susec and cusec at the top levels
**
*************************************************************************************/
LPBYTE DispSumSec(HFRAME hFrame, LPBYTE TempFrame, int ClassValue, int ClassValue2, int OffSet, DWORD TypeVal)
{
    /*      Working here now to display info name at the top.  Will indent everything
            else 1 to the right.  Not sure how well this is going to work since name-string[1]
            is a SEQUENCE OF.  Writing code now to assume there is only going to be one name 
            and display the first one.

    */

    BYTE SizeSec[4];
    PBYTE lSizeSec = (PBYTE)&SizeSec;

    TempFrameReq = (TempFrame+1);
    TempFrameReq2 = (TempFrame+2);

    // This while statement increments TempFrameReq until 1B is reached
    // If 1B is ever used in a length octet or elsewhere this will fail.  
    // Might look at doing a me mcopy later on to a global variable 
    // THINK WE CAN USE BERGETSTRING TO DISPLAY FULL SERVER NAME.  WE CAN
    // USE A STRING CONSTANTS WITH TO DISPLAY THE FULL VALUE.



// Incrementing TempFrameReq until String is found
        while(*(TempFrameReq) != ClassValue || *(TempFrameReq2) == ClassValue2)
        {
            TempFrameReq++;
            TempFrameReq2++;

        // Trying to come up with a way to make sure the Length Value doesn't == ClassValue
        // Still need some type of checking in case the length octet's value after the SEQUENCE OF
        // turns out to be equal to ClassValue.
            if(*(TempFrameReq) == ClassValue && *(TempFrameReq2) == ClassValue2)
            {
                TempFrameReq++;
                TempFrameReq2++;
                // Checking to see if Length Octet's value after SEQUENCE OF is equal to ClassValue.  If so,
                //  incrementing TempFrameReq in order to get to the correct offset.
                if(*(TempFrameReq) == ClassValue2 && *(TempFrameReq2) == ClassValue)
                {   
                    TempFrameReq++;
                    TempFrameReq2++;
                }
            }
        }

        memcpy(lSizeSec, (TempFrameReq2++), 4);
        *lSizeSec = *(lSizeSec) & 0xffffff00;


    // Prints out Value.  Need to change the Array to give better description
        AttachPropertyInstanceEx(hFrame,
                               KerberosDatabase[TypeVal].hProperty,
                               3,
                               TempFrameReq2,
                               4,
                               lSizeSec,                        
                               0, OffSet, 0);

        
    return TempFrame;
}

/*******************************************************************************************
*   LPBYTE DispEdata(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
*
* This function is a spinoff of DefineValue.  Problem is, e-data for Kerb error can be
* displayed in two different formats.  Even though this does present duplicate code,
* it does make it more convenenient and cleaner to have specific functions to handle specific data.
*
*******************************************************************************************/
LPBYTE DispEdata(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{
 
// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+2);

// Need to advance TempFrame the proper # of frames.
    TempFrame = IncTempFrame(TempFrame);

// Display Universal Class Tag
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet, ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+3);

// Need to advance TempFrame the proper # of frames.
    TempFrame = IncTempFrame(TempFrame);


// This if statement is checking to see if e-data is a Sequence of PA-DATA's.  If so
// we send the data to function to handle padata, if not, we display the Octet String.

    if (*((TempFrame)+1) == 0x30)
    {
    // Display padata
        TempFrame = HandlePadataKrbErr(hFrame, TempFrame, 2, PaDataSummary);
        

    // 1/18/00  LEFT OFF HERE.  NEED TO DISPLAY E-DATA WHEN IT'S FORMATTED AS PA-DATA.  LOOK AT
    // ADDING THE IF STATEMENT IN HANDLEPADATA AS YOU DID YESTERDAY.
    }
    else
    {
        AttachPropertyInstance(hFrame,
                           KerberosDatabase[TypeVal].hProperty,
                           *(TempFrame-1),
                           ++TempFrame,
                           0, OffSet+1, 0);
    }



  return (TempFrame-1)+*(TempFrame-1);
    
}

/*******************************************************************************************
**  LPBYTE HandlePadataKrbErr(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
**  This function handles the initial display of padata include in Kerb-Error
**
*******************************************************************************************/

LPBYTE HandlePadataKrbErr(HFRAME hFrame, LPBYTE TempFrame, int OffSet, DWORD TypeVal)
{

//Display SEQUENCE OF
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

//Display SEQUENCE OF
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+5);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

// Display padata-type[1]
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+2, PaDataSummary, PaDataSeq);

// Display INTEGER value
    TempFrame =DispPadata(hFrame, TempFrame, OffSet+4, PadataTypeValID);

// Display padata-value[2]
     DispASNTypes(hFrame, TempFrame, OffSet+2, PaDataSummary, PaDataSeq);


// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, ++TempFrame, OffSet+5);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

//Display OCTET STRING
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+7);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet
    TempFrame = IncTempFrame(TempFrame);

//Display SEQUENCE OF
    TempFrame = DispASNTypes(hFrame, TempFrame, OffSet+4,  ASN1UnivTagSumID, ASN1UnivTag);

// Display Length Octet(s)
    TempFrame = CalcLengthSummary(hFrame, TempFrame, OffSet+7);

//  Incrementing TempFrame based on the number of octets
//  taken up by the Length octet

    TempFrame = IncTempFrame(TempFrame);

// Handle MethodData
    TempFrame = HandleMethodData(hFrame, TempFrame);

    return(TempFrame);

}

/******************************************************************************************
**
**  LPBYTE HandleMethodData(HFRAME hFrame, LPBYTE TempFrame)
**
**  This function displays METHOD-DATA as described in kerb-error
**
******************************************************************************************/
LPBYTE HandleMethodData(HFRAME hFrame, LPBYTE TempFrame)
{
    int iStringLength = 0;
    int inc = 0;
// METHOD-DATA :: = SEQUENCE of PA-DATA.  This is a Sequence of, thus creating a loop to display 
// all info.  Added the inc variable so that the look will only go through twice.  In the sniff
// I was going by, the 3rd sequence of looked to be formatted in a whole different form than
// METHOD-DATA.  Even if this is by design, off-hand, I don't see how to code this to break
// out a different data format without any type of signifier in the frame.
    while(*(TempFrame+1) == 0x30 && inc <= 1)
    {
    //Display SEQUENCE OF
        TempFrame = DispASNTypes(hFrame, TempFrame, 6,  ASN1UnivTagSumID, ASN1UnivTag);

    // Display Length Octet(s)
        TempFrame = CalcLengthSummary(hFrame, TempFrame, 8);

        
    //  Incrementing TempFrame based on the number of octets
    //  taken up by the Length octet
        TempFrame = IncTempFrame(TempFrame);

    // Display method-type[0]
        TempFrame = DispASNTypes(hFrame, TempFrame, 5, MethodDataSummary, MethodDataBitF);


    // Break Down INTEGER values    
        TempFrame = DefineValue(hFrame, TempFrame, 7, DispSumEtype2);

    // Display method-data[1]
        TempFrame = DispASNTypes(hFrame, TempFrame, 5, MethodDataSummary, MethodDataBitF);

    // Display Length Octet(s)
        TempFrame = CalcLengthSummary(hFrame, TempFrame, 8);

    //  Incrementing TempFrame based on the number of octets
    //  taken up by the Length octet
        TempFrame = IncTempFrame(TempFrame);

    //Display OCTET STRING
        TempFrame = DispASNTypes(hFrame, TempFrame, 7,  ASN1UnivTagSumID, ASN1UnivTag);

    // Calculate the size of the Length Octet
        iStringLength = CalcMsgLength(TempFrame);
        
    //Display Length Octet
        TempFrame = CalcLengthSummary(hFrame, TempFrame, 10);

    //  Incrementing TempFrame based on the number of octets
    //  taken up by the Length octet
        TempFrame = IncTempFrame(TempFrame);
        

            AttachPropertyInstance(hFrame,
                                   KerberosDatabase[DispReqAddInfo].hProperty,
                                   sizeof(BYTE)+(iStringLength - 1),
                                   ++TempFrame,
                                   0, 9, 0);

    // Increment TempFrame to the end of the string so we can check for another Sequence
        TempFrame += (iStringLength - 1);

        ++inc;

    }

// LEFT OFF HERE 1/19/00  THIS IS A SEQUENCE OF, SO YOU NEED TO INCREMENT TEMPFRAME APPROPRIATELY
//  AND THEN CHECK FOR 0x30.  IF PRESENT, KEEP LOOPING.


    return(TempFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbparser.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\parser\krberr.h ===
//=============================================================================
//  MODULE: krberr.h
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost	Date: 06/04/99
//=============================================================================


LPBYTE KrbError(HFRAME hFrame, LPBYTE TempFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\crackpac.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        crackpac.cxx
//
// Contents:    Helper routines to pull privileges and groups
//              out of a PAC
//
//
// History:     20-Jul-1994     MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

#include <tokenutl.hxx>


//+-------------------------------------------------------------------------
//
//  Function:   CrackPac2
//
//  Synopsis:   Pulls privileges, user sid, and groups out of a new PAC.
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      SID is allocated with MIDL_user_allocate because
//              PrivateSidFromGuidAndRid uses that allocator.
//
//              UNICODE_STRING in pTokenProxyData is allocated with 'new'.
//
//--------------------------------------------------------------------------
HRESULT
CrackPac_2( IN  PACTYPE                    * pPac,
            OUT PTokenGroups                 pTokenGroups,
            OUT PTokenPrivs                  pTokenPrivs,
            OUT PSID                       * ppUserSid,
            OUT PSECURITY_TOKEN_PROXY_DATA   pTokenProxyData OPTIONAL)
{

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\gettime.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        gettime.c
//
// Contents:    Getting time
//
//
// History:     Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#include <security.h>
#include <secmisc.h>



//+-------------------------------------------------------------------------
//
//  Function:   GetCurrentTimeStamp
//
//  Synopsis:   Gets current time, UTC format.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
GetCurrentTimeStamp(    PLARGE_INTEGER      ptsCurrentTime)
{
    (void) NtQuerySystemTime(ptsCurrentTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\credlist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       credlist.cxx
//
//  Contents:   CredentialList class which has operations and data
//              common to both the NTLM and Kerberos security packages.
//
//  Classes:    CredentialList
//
//  Functions:  CredentialList::LocateCredentialByName(...)
//              CredentialList::LocateCredentialByID(...)
//              CredentialList::AddCredential(...)
//              CredentialList::~CredentialList()
//              CredentialList::CredentialList()
//
//  History:    12-Jan-94   MikeSw      reCreated from Kerberos code
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop


#include <credlist.hxx>
#include "debug.hxx"

DECLARE_INFOLEVEL(CRED);
//+---------------------------------------------------------------------------
//
//  Function:   InitializeCredMgr
//
//  Synopsis:   Initializes credmgr stuff.
//
//  Arguments:  (none)
//
//  Returns:    TRUE for success, FALSE otherwise.
//
//  History:    10-17-93   richardw   Created
//
//  Notes:      Always returns true now, but allows for extensibility.
//
//----------------------------------------------------------------------------
BOOLEAN
CCredentialList::Initialize(void)
{

    hCredLockSemaphore = CreateSemaphore(   NULL,
                                            MAX_CRED_LOCKS,
                                            MAX_CRED_LOCKS,
                                            NULL );
    if (!hCredLockSemaphore)
    {
        return(FALSE);
    }

    pcChain = NULL;
    cCredentials = 0;

    //
    // Set dwCredID to 1 so credential 0 is always invalid
    //

    dwCredID = 1;

    InitCredLocks();
    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   CCredentialList::AddCredential
//
//  Synopsis:   Adds a credential to the list
//
//  Effects:    Updates a few global structures.  Grabs the Credential mutex.
//
//  Arguments:  pcNewCred - credential to add
//
//  Requires:
//
//  Returns:    pointer to credential record
//
//  Notes:      THE CREDENTIAL RECORD IS SET TO LOCKED ON RETURN.
//
//--------------------------------------------------------------------------

PCredential
CCredentialList::AddCredential(PCredential pcNewCred)
{



    //
    // Always lock new credentials so that the creator gets exclusive
    // access.
    //

    pcNewCred->Lock();

    rCredentials.GetWrite();

    pcNewCred->_dwCredID        = dwCredID++;
    pcNewCred->_pcNext          = pcChain;
    pcChain = pcNewCred;

    cCredentials++;

    rCredentials.Release();

    return(pcNewCred);

}

//+-------------------------------------------------------------------------
//
//  Function:   CCredentialList::LocateCredential()
//
//  Synopsis:   Locates a credential record by its ID
//
//  Effects:
//
//  Arguments:  dwID    - ID of credential to locate
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PCredential
CCredentialList::LocateCredential(  ULONG       dwID,
                                    BOOLEAN     fLock)
{
    PCredential    pcSearch;


    rCredentials.GetRead();

    pcSearch = pcChain;
    while (pcSearch && (pcSearch->_dwCredID != dwID))
    {
        pcSearch = pcSearch->_pcNext;
    }

    rCredentials.Release();

    if (fLock && pcSearch)
    {
        if (!pcSearch->Lock())
            pcSearch = NULL;
    }

    return(pcSearch);
}



//+-------------------------------------------------------------------------
//
//  Function:   CCredentialList::LocateCredentialByName()
//
//  Synopsis:   Locates a credential record by a name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PCredential
CCredentialList::LocateCredentialByName(    PUNICODE_STRING pName,
                                            BOOLEAN fLock)
{
    PCredential    pcSearch;


    rCredentials.GetRead();

    pcSearch = pcChain;
    while (pcSearch &&
           !RtlEqualUnicodeString(&pcSearch->_Name, pName, TRUE) )
    {
        pcSearch = pcSearch->_pcNext;
    }

    rCredentials.Release();

    if (fLock && pcSearch)
    {
        if (!pcSearch->Lock())
            pcSearch = NULL;
    }

    return(pcSearch);
}


//+-------------------------------------------------------------------------
//
//  Function:   LocateCredentialByLogonId()
//
//  Synopsis:   Locates a credential record by LogonId, ProcessID
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PCredential
CCredentialList::LocateCredentialByLogonId(
                            PLUID    pLogonId,
                            ULONG    dwProcessID,
                            BOOLEAN  fLock)
{
    PCredential    pcSearch;
    PCredential    pcDefault = NULL;


    rCredentials.GetRead();

    pcSearch = pcChain;
    while (pcSearch)
    {
        while ( pcSearch &&
                !RtlEqualLuid(&pcSearch->_LogonId, pLogonId) )
        {
            pcSearch = pcSearch->_pcNext;
        }

        if (!pcSearch)
        {
            break;      // If null, exit loop and return
        }

        // Okay, at this point, we have found a credential that matches
        // the logon session.  However, there may be more than one of these.
        // However, the credentials created by LogonUser() have dwProcessID
        // set to 0, so we will use that one if we can't find a perfect match.
        // However, during logoff we call this with ProcessID set to 0, so
        // special case that.

        // Is it a perfect match?


        if (!dwProcessID || (pcSearch->_dwProcessID == dwProcessID) )
        {
            break;
        }

        // No, so check if these are the default credentials

        if (pcSearch->_dwProcessID == 0)
        {
            pcDefault = pcSearch;
        }

        pcSearch = pcSearch->_pcNext;
    }

    //
    // Only one of pcSearch,pcDefault can be non-null
    //

    if (!pcSearch)
    {
        pcSearch = pcDefault;
    }

    rCredentials.Release();

    if (fLock && pcSearch)
    {
        if (!pcSearch->Lock())
        {
            pcSearch = NULL;
        }
    }

    return(pcSearch);
}


//+-------------------------------------------------------------------------
//
//  Function:   CCredentialList::FreeCredential
//
//  Synopsis:   Does the work of freeing a credential record.
//
//  Effects:    pCred   -- Credential to blow away
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
CCredentialList::FreeCredential( PCredential    pCred)
{
    PCredential     pSearch;
    BOOLEAN         fFoundCred = TRUE;

    if (!pCred->Lock())
    {
        DebugOut((DEB_ERROR,"Credential must be locked before freeing!\n"));
        return(FALSE);
    }

    DebugOut((DEB_TRACE,"Freeing credential 0x%x:%wS\n",pCred->_dwCredID,&pCred->_Name));

    //
    // Check if this record is unlinked from the main list:
    //

    rCredentials.GetWrite();

    //
    // If this is the lead credential, we're set
    //

    if (pcChain == pCred)
    {
        pcChain = pCred->_pcNext;
    }
    else
    {
        pSearch = pcChain;
        while ((pSearch->_pcNext) && (pSearch->_pcNext != pCred))
        {
            pSearch = pSearch->_pcNext;
        }
        if (pSearch->_pcNext == NULL)
        {
            DebugOut((DEB_TRACE, "Credential %wS not in list.\n", &pCred->_Name));
            fFoundCred = FALSE;
        }
        else
        {
            pSearch->_pcNext = pCred->_pcNext;
        }
    }

    if (fFoundCred)
    {
        cCredentials --;
    }


    rCredentials.Release();

    return(TRUE);

}

//+---------------------------------------------------------------------------
//
//  Function:   CCredentialList::EnumerateCredentials
//
//  Synopsis:   Gets an array of all the credentials, so that someone else
//              can walk through them.  The credentials may vanish, so it
//              it is required to attempt a LockCred() before using them
//
//  Effects:
//
//  Arguments:  [pcCreds]  -- Receives number of creds
//              [pppCreds] -- Receives a pointer to an array of pointers to
//                              credentials.
//
//  History:    10-17-93   richardw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
CCredentialList::EnumerateCredentials(  ULONG *         pcCreds,
                                        PCredential *   *pppCreds)
{
    PCredential *  ppCreds;
    PCredential    pCreds;
    ULONG          i;

    rCredentials.GetRead();

    ppCreds = new PCredential[cCredentials];

    for (pCreds = pcChain, i = 0 ; pCreds ; pCreds = pCreds->_pcNext )
    {
        ppCreds[i++] = pCreds;
    }

    DsysAssert(i == cCredentials);

    *pcCreds = cCredentials;

    rCredentials.Release();

    *pppCreds = ppCreds;

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\authdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       authdata.cxx
//
//  Contents:
//
//  Classes:    CAuthData, CAuthDataArray
//
//  Functions:  CAuthDataArray::Create  (static function)
//
//  History:    30-Sep-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

#include <authdata.hxx>

#define PAGE_SIZE 0x1000

//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::Add
//
//  Synopsis:   Adds a new element to the list
//
//  Effects:
//
//  Arguments:  [adtType] -- Type of new elemebt
//              [pbSrc]   -- data for new element
//              [cbSrc]   -- size of new element
//
//  Returns:    0 or size required to do this.
//
//  History:    30-Sep-93   WadeR   Created
//
//  Notes:      If pbSrc is NULL, it only allocates space and doesn't copy.
//
//----------------------------------------------------------------------------

CAuthData*
CAuthDataList::Add( const AuthDataType adtType,
                    const BYTE * pbSrc,
                    ULONG cbSrc )
{
    ULONG cbRequired = SizeOfAuthData( cbSrc );
    ULONG cbAvail = _cbSize - _cbUsed;

    if (cbRequired > cbAvail)
    {
        return(NULL);
    }

    CAuthData* padNewElement = (CAuthData*) ((PBYTE) this + _cbUsed );
    padNewElement->adtDataType = adtType;
    padNewElement->cbData = cbSrc;
    if (pbSrc)
        RtlCopyMemory( padNewElement->abData, pbSrc, cbSrc );

    _cbUsed += cbRequired;

    return(padNewElement);
};


//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::Add
//
//  Synopsis:   Adds the contents of a CAuthDataList to this CAuthDataList
//
//  Effects:
//
//  Arguments:  [cadlList] -- List to add from.
//
//  Requires:   this list be large enough.
//
//  Returns:    TRUE if there's room, FALSE otherwise.
//
//  Signals:    none
//
//  History:    01-Apr-94   wader   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
CAuthDataList::Add( const CAuthDataList& cadlList )
{

    // Don't need to copy the new header.  If CAuthDataList's header
    // changes, this must change as well.
    DsysAssert( 2*sizeof( ULONG ) == (PBYTE) &cadlList._adData[0] - (PBYTE) &cadlList );
    ULONG cbRequired = cadlList._cbUsed - 2 * sizeof( ULONG );
    ULONG cbAvail = _cbSize - _cbUsed;

    if (cbRequired > cbAvail)
    {
        return(FALSE);
    }
    PBYTE pbEnd = ((PBYTE)this) + _cbUsed;
    RtlCopyMemory( pbEnd, &cadlList._adData[0], cbRequired );
    _cbUsed += cbRequired;
    return(TRUE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::Create
//
//  Synopsis:   Creates a new CAuthDataList
//
//  Effects:    may allocate memory
//
//  Arguments:  [cbList]    -- Size of the list to create (see SizeOfAuthDataList)
//              [pbStorage] -- (optional) memory to create it in.
//
//  Returns:    pointer to newly created list, or NULL if no memory
//
//  History:    01-Apr-94   wader   Created
//
//  Notes:      If pnStorage is non-NULL, it builds the list in pbStorage and
//              returns pbStorage.  If it's null, it allocates space with NEW
//              and builds the list there.
//
//----------------------------------------------------------------------------

CAuthDataList *
CAuthDataList::Create( ULONG cbList, PBYTE pbStorage )
{
    DsysAssert( cbList >= SizeOfAuthDataList( SizeOfAuthData( 1 )) );

    if (pbStorage == NULL)
        pbStorage = new BYTE [ cbList ];

    CAuthDataList *padlNewList = (CAuthDataList*)pbStorage;

    padlNewList->_cbSize = cbList;
    padlNewList->_cbUsed = SizeOfAuthDataList(0);

    return(padlNewList);
}



//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::FindFirst
//
//  Synopsis:   Finds the first CAuthData in the CAuthDataList
//
//  Arguments:  [adtType] -- Type of CAuthData to find.
//
//  Returns:    pointer to CAuthData, or NULL
//
//  History:    01-Apr-94   wader   Created
//
//  Notes:      See header for CAuthDataList for usage.
//
//----------------------------------------------------------------------------

PAuthData
CAuthDataList::FindFirst( AuthDataType adtType ) const
{

    //
    // Don't need to check that the list contains anything, because
    // if the list is empty, padTemp == padTheEnd, and the loop is skipped.
    //

    const CAuthData *const padTheEnd = (CAuthData *)((PBYTE) this + _cbUsed);
    const CAuthData * padTemp = &_adData[0];

    if (adtType != Any)
    {
        while ( (padTemp < padTheEnd ) && (padTemp->adtDataType != adtType) )
        {
            padTemp = (CAuthData*) ( ((PBYTE) padTemp) +
                                     SizeOfAuthData(padTemp->cbData) );
        }
    }

    if ( padTemp == padTheEnd )
    {
        return(NULL);
    }
    else
    {
        return((PAuthData)padTemp);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::FindNext
//
//  Synopsis:   Finds the next CAuthData in the CAuthDataList
//
//  Effects:
//
//  Arguments:  [padCurrent] -- Starting CAuthData to search from
//              [adtType]    -- type to look for
//
//  Returns:    pointer to CAuthData, or NULL
//
//  History:    01-Apr-94   wader   Created
//
//  Notes:      See header for CAuthDataList for usage.
//
//----------------------------------------------------------------------------

PAuthData
CAuthDataList::FindNext( PAuthData padCurrent, AuthDataType adtType ) const
{
    //
    // Don't need to check that the list contains anything, because
    // if the list is empty, padTemp == padTheEnd, and the loop is skipped.
    //

    const CAuthData *const padTheEnd = (CAuthData *)((PBYTE) this + _cbUsed);
    const CAuthData * padTemp = padCurrent;

    DsysAssert( padCurrent >= &_adData[0] && padCurrent < padTheEnd );

    if (adtType == Any)
    {
        padTemp = (CAuthData*) ( ((PBYTE) padTemp) +
                                 SizeOfAuthData(padTemp->cbData) );
    }
    else
    {
        do
        {
            padTemp = (CAuthData*) ( ((PBYTE) padTemp) +
                                     SizeOfAuthData(padTemp->cbData) );
        } while ( (padTemp < padTheEnd ) && (padTemp->adtDataType != adtType) );
    }

    if ( padTemp == padTheEnd )
    {
        return(NULL);
    }
    else
    {
        return((PAuthData)padTemp);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAuthDataList::IsValid
//
//  Synopsis:   Checks to see if this is a valid CAuthDataList.
//
//  Effects:    none.
//
//  Arguments:  (none)
//
//  Returns:    TRUE iff this is valid.
//
//  History:    17-May-94   wader   Created
//
//  Notes:      IsBadReadPtr
//
//----------------------------------------------------------------------------

BOOLEAN
CAuthDataList::IsValid() const
{
    BOOLEAN fResult = TRUE;
    __try
    {
        const BYTE * p;

        //
        // Does the size make sense?
        //

        if (_cbUsed > _cbSize)
        {
            fResult = FALSE;
        }

        //
        // Probe the end of the data
        //

        p = ((PBYTE)this) + _cbSize;
        (volatile) *p;

        //
        // Check each entry
        //

        const CAuthData * const padTheEnd = (CAuthData *)((PBYTE) this + _cbUsed);
        const CAuthData * padTemp = &_adData[0];

        while ( (padTemp < padTheEnd ) && fResult == TRUE )
        {

            //
            //  In the extremely unlikely event that an AuthData spans several
            //  pages, and some of the pages are missing in the middle, we'll
            //  probe the middle of it.
            //

            if (padTemp->cbData > PAGE_SIZE )
            {
                for (p = padTemp->abData;
                     p < &padTemp->abData[padTemp->cbData];
                     p += PAGE_SIZE)
                {
                    (volatile ULONG) *(PULONG) (p);
                }
            }

            padTemp = (CAuthData*) ( ((PBYTE) padTemp) +
                                     SizeOfAuthData(padTemp->cbData) );
        }

        if (padTemp != padTheEnd)
        {
            fResult = FALSE;
        }

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        fResult = FALSE;
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\credlock.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       credlock.cxx
//
//  Contents:   routines to manage CredLocks
//
//
//  Functions:  InitCredLocks
//              AllocateCredLock
//              BlockOnCredLock
//              FreeCredLock
//
//
//  History:    12-Jan-94   MikeSw      Created
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop


#include <credlist.hxx>
#include "debug.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   InitCredLocks
//
//  Synopsis:   Initialize credential lock events
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
CCredentialList::InitCredLocks(void)
{
    ULONG i;

    for (i = 0; i < MAX_CRED_LOCKS ; i++ )
    {
        LockEvents[i].hEvent     = 0;
        LockEvents[i].fInUse     = 0;
        LockEvents[i].cRecursion = 0;
        LockEvents[i].cWaiters   = 0;
    }

    (void) RtlInitializeCriticalSection(&csLocks);
    cLocks = 0;
}



//+-------------------------------------------------------------------------
//
//  Function:   AllocateCredLock
//
//  Synopsis:   Allocates and returns a pointer to a credlock.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
PCredLock
CCredentialList::AllocateCredLock(void)
{
    NTSTATUS    scRet;
    ULONG       i = 0;

    //
    // We enter the semaphore here, guarateeing that when we
    // exit this wait, there are enough credlocks for Tom's tests
    //
    WaitForSingleObject(hCredLockSemaphore, INFINITE);

    scRet = RtlEnterCriticalSection(&csLocks);
    if (!NT_SUCCESS(scRet))
    {
        DebugOut((DEB_ERROR, "failed allocating a CredLock, %x\n", scRet));
        return(NULL);
    }

    if (cLocks)
    {
        for (i = 0; i < cLocks ; i++ )
        {
            if (!(LockEvents[i].fInUse & CREDLOCK_IN_USE))
            {
                ResetEvent(LockEvents[i].hEvent);
                LockEvents[i].fInUse |= CREDLOCK_IN_USE;
                LockEvents[i].cRecursion = 0;
                (void) RtlLeaveCriticalSection(&csLocks);
                return(&LockEvents[i]);
            }
        }
    }

    // No free locks, so we create a new one.

    if (cLocks == MAX_CRED_LOCKS)
    {
        DebugOut((DEB_ERROR, "Ran out of CredLocks?\n"));
        (void) RtlLeaveCriticalSection(&csLocks);
        return(NULL);
    }

    // This entails creating an event that is anonymous, auto-reset,
    // initally not signalled.

    LockEvents[cLocks].hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (LockEvents[cLocks].hEvent == NULL)
    {
        DebugOut((DEB_ERROR, "Failed creating event, %d\n", GetLastError()));
    }
    else
    {
        i = cLocks;
        LockEvents[cLocks++].fInUse = CREDLOCK_IN_USE;
    }

    (void) RtlLeaveCriticalSection(&csLocks);
    return(&LockEvents[i]);
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeCredLock
//
//  Synopsis:   Releases a credlock
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE - Remove the lock record from the credential record
//              FALSE - Threads waiting; don't remove from cred
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
CCredentialList::FreeCredLock(  PCredLock   pLock,
                                BOOLEAN     fFreeCred)
{
    NTSTATUS    Status;
    BOOL        bRet = TRUE;

    Status = RtlEnterCriticalSection(&csLocks);
    DsysAssert( NT_SUCCESS( Status ) );

    //
    // The trick:  If there is a waiter, then the lock is *not* free
    // and we set the flag saying the credential is pending delete, so
    // their Lock will fail.
    //

    if (pLock->cWaiters)
    {
        SetEvent(pLock->hEvent);
        bRet = FALSE;

        //
        // If the credential has been freed, mark that too
        //

        if (fFreeCred)
        {
            pLock->fInUse |= CREDLOCK_FREE_PENDING;
        }
    } else
    {
        pLock->fInUse &= ~CREDLOCK_IN_USE;
    }

    // And clear up the thread id field:

    pLock->dwThread = 0;

    (void) RtlLeaveCriticalSection(&csLocks);

    //
    // This is true if the lock has actually been freed
    // back to the credlock pool.
    //

    if (bRet)
    {
        ReleaseSemaphore(hCredLockSemaphore, 1, NULL);
    }

    return(bRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   BlockOnCredLock
//
//  Synopsis:   Blocks a thread on a credlock.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   credentials be blocked for write
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
CCredentialList::BlockOnCredLock(PCredLock   pLock)
{
    NTSTATUS    Status;
    DWORD       WaitRet;
    BOOLEAN     bRet = TRUE;

    Status = RtlEnterCriticalSection(&csLocks);
    DsysAssertMsg(Status == STATUS_SUCCESS, "Critical section csLocks") ;

    DebugOut((DEB_TRACE,"Blocking for lock on thread 0x%x\n",pLock->dwThread));
#if DBG
    if (pLock->cWaiters < 4)
        pLock->WaiterIds[pLock->cWaiters++] = GetCurrentThreadId();
    else
        pLock->cWaiters++;
#else

    pLock->cWaiters++;
#endif

    (void) RtlLeaveCriticalSection(&csLocks);

    //
    // Unlock the list, so that other threads can unlock the credentials
    //

    rCredentials.Release();

    //
    // Wait for 100s, or until signalled:
    //

    WaitRet = WaitForSingleObject(pLock->hEvent, 600000L);

    //
    // Reacquire exclusive access to the credlock
    //

    RtlEnterCriticalSection(&csLocks);

    if (WaitRet)
    {
        if (WaitRet == WAIT_TIMEOUT)
        {

#if DBG

            DebugOut((DEB_ERROR, "Timeout waiting for credlock %x (600s)\n",
                        pLock));
            DebugOut((DEB_ERROR, "Thread 0x%x still owns the lock, revoking\n",
                        pLock->dwThread));
            pLock->dwThread = 0;

#endif // DBG

            //
            // Blow away any recursion
            //
            pLock->cRecursion = 0;

        }
    }

#if DBG

    //
    // Remove our thread ID from the waiter list:
    //

    {
        int i;
        for (i = 0 ; i < 4 ; i++ )
        {
            if (pLock->WaiterIds[i] == GetCurrentThreadId())
            {
                int j;
                for (j = i; j < 4 - 1 ; j++ )
                {
                    pLock->WaiterIds[j] = pLock->WaiterIds[j+1];
                }
                pLock->WaiterIds[4 - 1] = 0;
            }
        }
    }

#endif // DBG

    pLock->cWaiters--;


    if (pLock->fInUse & CREDLOCK_FREE_PENDING)
    {
        if (pLock->cWaiters == 0)
        {
            pLock->fInUse &= ~(CREDLOCK_IN_USE | CREDLOCK_FREE_PENDING);
        }

        bRet = FALSE;

    }

    //
    // Done partying with locks
    //

    RtlLeaveCriticalSection(&csLocks);


    //
    // If the credlock needs to be freed, signal the semaphore to
    // put it back in the pool.
    //

    if (!bRet && (pLock->cWaiters == 0))
    {
        ReleaseSemaphore(hCredLockSemaphore, 1, NULL);
    }

    //
    // Regain exclusive access to the credential list
    //

    rCredentials.GetWrite();

    return(bRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\domain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       domain.cxx
//
//  Contents:   GuidToUlong - converts Cairo GUID into a ULONG
//
//
//  Functions:
//
//  History:    6-28-93   MikeSw        Created
//
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop



extern "C"
VOID
DomainGroupName(PWCHAR pwszDomain,
                PCHAR  psGroup)
{
    LONG cDomLen;
    CHAR  szDom[MAX_PATH];
    PCHAR psSep;

    (VOID)wcstombs(szDom, pwszDomain, MAX_PATH * sizeof(WCHAR));

    strlwr(szDom);              // eliminate case mismatches

    *psGroup = szDom[0];        // copy the first

    psSep = strrchr(szDom, '\\');

    if(!psSep)
    {
        psSep = szDom;
    }
    else
    {
        psSep++;
    }

    cDomLen = min(14, strlen(psSep));   // fill bytes if necessary

    memset(&psGroup[cDomLen + 1], 0x20, 14 - cDomLen);

    memcpy(&psGroup[1], psSep, cDomLen);

    psGroup[15] = 0x1c;        // make it an internet group
}

//
// Get an internet group name for a GUID.
// The strategy is to drop of high-byte of the time field. This changes
// infrequently (every 50 years or so) so it likely won't cause a problem.
//

#if 0
extern "C"
VOID
SqueezeGUID(    GUID * pgGUID,
                PCHAR  psGroup)
{
/*
 * Turn a GUID into an internet group name
 */

    PCHAR psGUID = (PCHAR)pgGUID;

    memcpy(psGroup, psGUID, 7);
    memcpy(&psGroup[7], &psGUID[8], 8);
    psGroup[15] = 0x1c;
}


#else
//
// Get an internet group name for a GUID.
// The strategy is to form a binary string made up of the adapter address
// plus a XSUM byye, ASCIIZE it, and append a " <1c>". Ta da.
//

extern "C"
VOID
SqueezeGUID(  GUID * pgGUID,
               PCHAR  psGroup)
{
/*
 * Turn a GUID into an internet group name
 */

    PCHAR psGUID = (PCHAR)pgGUID;
    UCHAR  bXSUM;
    ULONG ulX;

    //
    // compute XSUM
    //

    for(bXSUM = 0, ulX = 0; ulX <= 15; psGUID++, ulX++)
    {
        bXSUM += (UCHAR)((ULONG)*psGUID + ulX);
    }

    sprintf(psGroup, "Z%02X%02X%02X%02X%02X%02X%02x",
            pgGUID->Data4[2], pgGUID->Data4[3], pgGUID->Data4[4],
            pgGUID->Data4[5], pgGUID->Data4[6], pgGUID->Data4[7],
            bXSUM);
    psGroup[15] = 0x1c;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\cred.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cred.cxx
//
//  Contents:   Credential class used to store common security credential
//              for NTLM and Kerberos
//
//  Classes:    CCredential
//
//  Functions:  CCredential::CCredential()
//              CCredential::~CCredential()
//
//
//  History:    12-Jan-94   MikeSw      Created
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop


// NT Headers


#include <credlist.hxx>
#include "debug.hxx"


//
// Global Data
//



//+-------------------------------------------------------------------------
//
//  Function:   CCredential::Credential()
//
//  Synopsis:   Constructor.
//
//  Effects:
//
//--------------------------------------------------------------------------

CCredential::CCredential(CCredentialList *pOwningList)

{
    DebugOut((CRED_FUNC, "CCredential()\n"));

    _Check = CRED_CHECK_VALUE;
    _dwCredID = 0;
    _dwProcessID = 0;
    _pOwningList = pOwningList;
    _pLock = NULL;


}


//+-------------------------------------------------------------------------
//
//  Function:   CCredential::~CCredential()
//
//  Synopsis:   Destructor.
//
//  Notes:      Credential should be locked to delete it.  An implemenation
//              should write a real destructor that cleans up all the
//              other data, such as user name.
//
//
//--------------------------------------------------------------------------

CCredential::~CCredential()
{
//    DsysAssert(_pLock);

    DebugOut((DEB_TRACE,"Deleting credential %p\n",this));
    _Check = 0;
    if (_pLock != NULL)
    {
        if (!_pOwningList->FreeCredLock(_pLock,TRUE))
        {
            DebugOut((DEB_ERROR,"Lock conflict in freed credential - thread still waiting\n"));
        }
    }
   _pOwningList = NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   CCredential::Lock()
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
CCredential::Lock()
{
    DWORD   checkvalue;
    HRESULT hrRet;
    BOOLEAN fLockedList = FALSE;
    BOOLEAN bRet = TRUE;
    CCredentialList * pCredList = NULL;

    //
    // Verify that this credential is valid:
    //

    __try
    {
        hrRet = SEC_E_INVALID_HANDLE;

        if (_pOwningList)
        {
            //
            // First check the _Check value. This isn't sufficient, since
            // by the time we lock the list it may change, so we check
            // again afterwards.
            //

            if (_Check == CRED_CHECK_VALUE)
            {

                //
                // Copy on pCredList just in case it gets changed on us
                // so we can still unlock it.
                //

                pCredList = _pOwningList;
                pCredList->rCredentials.GetWrite();
                fLockedList = TRUE;
                checkvalue = _Check;

                //
                // Now check the check value.
                //

                if (checkvalue == CRED_CHECK_VALUE)
                {
                    hrRet = S_OK;
                }
            }
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hrRet = SEC_E_INVALID_HANDLE;

    }

    if (FAILED(hrRet))
    {
        if (fLockedList)
        {
            pCredList->rCredentials.Release();
        }
        DebugOut((DEB_WARN,"Invalid cred passed to lock: %p\n",this));
        return(FALSE);
    }

    DebugOut((DEB_TRACE,"Going to lock creds for 0x%x:%wS\n",
                _dwCredID,&_Name));


    // If the pLock field is non-null, then there is an active user of
    // the credentials.

    if (_pLock)
    {
        // If we already own this lock, bump the recursion count:

        if (_pLock->dwThread == GetCurrentThreadId())
        {
            // Null body
        }
        else
        {

            //
            // Otherwise, we block on the CredLock.
            //
            // Note:  BlockOnCredLock will release the CredList exclusive lock
            // for the duration of its wait, and re-obtain it before it
            // returns.
            //

            bRet = pCredList->BlockOnCredLock(_pLock);

        }

    }
    else
    {
        _pLock = _pOwningList->AllocateCredLock();
        if (!_pLock)
            DebugOut((DEB_ERROR, "AllocateCredLock failed\n"));
    }

    if (bRet)
    {
        _pLock->dwThread = GetCurrentThreadId();
        _pLock->cRecursion++;
        DebugOut((DEB_TRACE,"Locked creds for %wS\n",
                &_Name));
    }
#if DBG
    else
    {
        DebugOut((DEB_WARN,"Failed to lock creds, cred was freed while waiting\n"));
    }
#endif


    pCredList->rCredentials.Release();

    return(bRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   CCredentials::Release
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
CCredential::Release()
{

#if DBG
    if (!_pLock)
    {
        DebugOut((DEB_WARN, "UnlockCredentials - Creds for %wS aren't locked\n",
                    &_Name));
        return(TRUE);
    }
#endif

    if (_pLock->dwThread != GetCurrentThreadId())
    {
        DebugOut((DEB_ERROR, "UnlockCredentials:  Not owner of creds for %wS\n",
                    &_Name));
        return(FALSE);
    }

    _pOwningList->rCredentials.GetWrite();

    DebugOut((DEB_TRACE, "Unlocking credentials of 0x%x:%wS(%d,%d)\n",
                        _dwCredID,
                        &_Name,
                        _pLock->cRecursion,
                        _pLock->cWaiters));


    //
    // First, decrement the recusion count.  If it is not zero, then
    // this thread has multiple locks on this credential.  So, this unlock
    // is successful, but the credentials are still locked.
    //

    if (--_pLock->cRecursion)
    {
        _pOwningList->rCredentials.Release();

        return(TRUE);
    }

    if (_pOwningList->FreeCredLock(_pLock,FALSE))
    {
        _pLock = NULL;
    }

    DebugOut((DEB_TRACE,"Released creds for %wS\n",
                &_Name));

    _pOwningList->rCredentials.Release();

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\pacndr_c_stub.c ===
#include "pacndr_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\mapsecer.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       mapsecer.cxx
//
//  Contents:   Map security error codes to NTSTATUS value
//
//  Classes:
//
//  Functions:  SRtlMapErrorToString
//
//  History:    18-Feb-93  PeterWi      Created
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

NTSTATUS ErrorTable[] = {
    SEC_E_INSUFFICIENT_MEMORY, STATUS_INSUFFICIENT_RESOURCES,
    SEC_E_INVALID_HANDLE, STATUS_INVALID_HANDLE,
    SEC_E_UNSUPPORTED_FUNCTION, STATUS_NOT_IMPLEMENTED,
    SEC_E_TARGET_UNKNOWN, STATUS_BAD_NETWORK_PATH,
    SEC_E_INTERNAL_ERROR, STATUS_INTERNAL_ERROR,
    SEC_E_SECPKG_NOT_FOUND, STATUS_NO_SUCH_PACKAGE,
    SEC_E_NOT_OWNER, STATUS_INVALID_OWNER,
    SEC_E_CANNOT_INSTALL, STATUS_NO_SUCH_PACKAGE,
    SEC_E_INVALID_TOKEN, STATUS_INVALID_PARAMETER,
    SEC_E_CANNOT_PACK, STATUS_INVALID_PARAMETER,
    SEC_E_QOP_NOT_SUPPORTED, STATUS_NOT_IMPLEMENTED,
    SEC_E_NO_IMPERSONATION, STATUS_CANNOT_IMPERSONATE,
    SEC_E_LOGON_DENIED, STATUS_LOGON_FAILURE,
    SEC_E_UNKNOWN_CREDENTIALS, STATUS_INVALID_PARAMETER,
    SEC_E_NO_CREDENTIALS, STATUS_NO_SUCH_LOGON_SESSION,
    SEC_E_MESSAGE_ALTERED, STATUS_ACCESS_DENIED,
    SEC_E_OUT_OF_SEQUENCE, STATUS_ACCESS_DENIED,
    SEC_E_NO_AUTHENTICATING_AUTHORITY, STATUS_NO_LOGON_SERVERS,
    SEC_E_BAD_PKGID, STATUS_NO_SUCH_PACKAGE,
    0xffffffff,0xffffffff };

extern "C"
NTSTATUS
MapSecError(HRESULT hrValue)
{

    ULONG Index;

    //
    // Only map error codes
    //

    if (NT_SUCCESS(hrValue))
    {
        return(hrValue);
    }

    //
    // Check for straight NT status codes
    //

    if ((hrValue & 0xf0000000) == 0xc0000000)
    {
        return(hrValue);
    }

    //
    // Then check for a masked NTSTATUS
    //

    if ((hrValue & 0xf0000000) == 0xd0000000)
    {
        return(hrValue & 0xcfffffff);
    }

    //
    // Next check for a masked Win32 error - convert them all to
    // STATUS_ACCESS_DENIED
    //

    if ((hrValue & 0xffff) == 0x80070000)
    {
        return(STATUS_ACCESS_DENIED);
    }

    //
    // Now map all the ISSP errors
    //

    for (Index = 0;
         ErrorTable[Index] != 0xffffffff ;
         Index+= 2 )
    {
        if (ErrorTable[Index] == hrValue)
        {
            return(ErrorTable[Index+1]);
        }
    }

    //
    // Return the old standby.
    //

    return(STATUS_ACCESS_DENIED);


}

extern "C"
NTSTATUS
SecMapHresult(
    HRESULT hrRet
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    if (SUCCEEDED(hrRet))
    {
        Status = STATUS_SUCCESS;
    }
    else if ((hrRet & 0xc0000000) == 0xc0000000)
    {
        //
        // This was a NTSTATUS code at some point
        //

        Status = hrRet & 0xcfffffff;
    }
    else if (hrRet == E_OUTOFMEMORY)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else if (hrRet == STG_E_FILENOTFOUND)
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    else if (hrRet == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
    {
        Status = STATUS_INVALID_PARAMETER;
    }
    else if (hrRet == STG_E_FILEALREADYEXISTS)
    {
        Status = STATUS_OBJECT_NAME_COLLISION;
    }
    else if (hrRet == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    else
    {
        Status = STATUS_INTERNAL_ERROR;
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\pac.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1996
//
// File:        pac.cxx
//
// Contents:    Implementation of routines to manipulate new PACs
//
// Description:
//
//
// History:     23-Jan-96   MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

#include <pac.hxx>
#include <sectrace.hxx>
#include <tostring.hxx>
#include <ntlmsp.h>

extern "C"
{
#include <align.h>
#include <ntsam.h>
#include <lmaccess.h>
#include <midles.h>
#include <pacndr.h>
}


//+-------------------------------------------------------------------------
//
//  Function:   Helper Functions for NDR encoding data types
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


typedef struct _PAC_BUFFER_STATE {
    PBYTE   BufferPointer;
    ULONG   BufferSize;
} PAC_BUFFER_STATE, *PPAC_BUFFER_STATE;

VOID NTAPI
PacAllocFcn(
    IN OUT  PVOID pvState,
    OUT PCHAR * ppbOut,
    IN PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size of the object
    // obtained by _GetSize(). This routine must return a buffer in
    // ppbOut with at least *pulSize bytes.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}

VOID NTAPI
PacWriteFcn(
    IN OUT PVOID pvState,
    OUT PCHAR pbOut,
    IN UINT32 ulSize
    )
{
    //
    // Since the data was pickled directly to the target buffer, don't
    // do anything here.
    //
}

VOID NTAPI
PacReadFcn(
    IN OUT PVOID pvState,
    OUT PCHAR * ppbOut,
    IN OUT PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size to read.
    // This routine must return a buffer in ppbOut which contains the
    // encoded data.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeValidationInformation
//
//  Synopsis:   NDR encodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeValidationInformation(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = PPAC_IDL_VALIDATION_INFO_AlignSize(
                                PickleHandle,
                                &ValidationInfo
                                );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_VALIDATION_INFO_Encode(
        PickleHandle,
        &ValidationInfo
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeValidationInformation
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeValidationInformation(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_VALIDATION_INFO_Decode(
            PickleHandle,
            ValidationInfo
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeCredentialData
//
//  Synopsis:   NDR encodes the credential data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeCredentialData(
    IN PSECPKG_SUPPLEMENTAL_CRED_ARRAY CredentialData,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = PPAC_IDL_CREDENTIAL_DATA_AlignSize(
                                PickleHandle,
                                &CredentialData
                                );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_CREDENTIAL_DATA_Encode(
        PickleHandle,
        &CredentialData
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeCredentialData
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeCredentialData(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CredentialData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_CREDENTIAL_DATA_Decode(
            PickleHandle,
            CredentialData
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeTokenRestrictions
//
//  Synopsis:   NDR encodes the token restrictions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = PKERB_TOKEN_RESTRICTIONS_AlignSize(
                                PickleHandle,
                                &TokenRestrictions
                                );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PKERB_TOKEN_RESTRICTIONS_Encode(
        PickleHandle,
        &TokenRestrictions
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeTokenRestrictions
//
//  Synopsis:   NDR decodes the token restrictions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C"
NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PKERB_TOKEN_RESTRICTIONS_Decode(
            PickleHandle,
            TokenRestrictions
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_GetSize
//
//  Synopsis:   Determines the number of bytes required to marshal the
//              given PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
PAC_GetSize( IN  PACTYPE  *pPac )
{
    ULONG cbSize = 0;

    if (pPac != NULL)
    {
        cbSize += sizeof( PACTYPE );
        cbSize += (pPac->cBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
        cbSize = ROUND_UP_COUNT( cbSize, ALIGN_QUAD );
        for (ULONG i = 0; i < pPac->cBuffers; i++ )
        {
            cbSize += ROUND_UP_COUNT(pPac->Buffers[i].cbBufferSize, ALIGN_QUAD);
        }
    }

    return (cbSize);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Marshal
//
//  Synopsis:   Marshals the given PAC into the provided buffer.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//              Returns the number of bytes used or 0 if an error
//              occurred.
//
//----------------------------------------------------------------------------

ULONG
PAC_Marshal( IN  PACTYPE   *pPac,
             IN  ULONG      cbBuffer,
             OUT PBYTE      pBufferOut)
{
    DsysAssert( pPac != NULL && pBufferOut != NULL );

    ULONG PacLen = PAC_GetSize( pPac );

    if (cbBuffer < PacLen)
    {
        return 0;
    }

    //
    // Copy into pBufferOut and then change the pointers of each
    // PAC_INFO_BUFFER to be offsets from pPac.
    //

    CopyMemory( pBufferOut, pPac, PacLen );

    PPACTYPE pPacTemp = (PPACTYPE) pBufferOut;

    for (ULONG i = 0; i < pPacTemp->cBuffers; i++ )
    {
        pPacTemp->Buffers[i].Offset = (ULONG) (pPacTemp->Buffers[i].Data -
                                             (PBYTE)pPac);
    }

    return PacLen;
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_UnMarshal
//
//  Synopsis:   Does in place unmarshalling of the marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place unmarshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

ULONG
PAC_UnMarshal( IN PPACTYPE  pPac,
               IN ULONG cbSize )
{
    ULONG i;
    ULONG cbUnmarshalled = 0;
    PBYTE pEnd = (PBYTE)pPac + cbSize;
    PBYTE pBufferAddress;

    DsysAssert( pPac != NULL );


    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    if ((pPac->cBuffers * sizeof(PAC_INFO_BUFFER) + sizeof(PACTYPE)) > cbSize)
    {
        return(0);
    }

    if (pPac->Version != PAC_VERSION)
    {
        return(0);
    }
    for (i = 0; i < pPac->cBuffers; i++)
    {
        pBufferAddress = (ULONG)pPac->Buffers[i].Offset + (PBYTE)pPac;

        if ( (pBufferAddress >= pEnd ) || (pBufferAddress < (PBYTE) pPac) ||
             (pBufferAddress + pPac->Buffers[i].cbBufferSize > pEnd))
        {
            //
            // Invalid offset or length
            //
            return (0);
        }
    }

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        cbUnmarshalled += pPac->Buffers[i].cbBufferSize;
        pPac->Buffers[i].Data = pPac->Buffers[i].Offset +
                                    (PBYTE)pPac;
    }

    return (cbUnmarshalled);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_ReMarshal
//
//  Synopsis:   Does in place re-marshalling of an un-marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place re-marshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_UnMarshal. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

BOOLEAN
PAC_ReMarshal( IN PPACTYPE  pPac,
               IN ULONG cbSize )
{
    ULONG Offset;
    ULONG i;

    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        Offset = (ULONG) (pPac->Buffers[i].Data - (PBYTE) pPac);
        if ( Offset >= cbSize )
        {
            //
            // Invalid offset or length
            //

            return (FALSE);
        }
        pPac->Buffers[i].Offset = Offset;
    }

    return (TRUE);
}


VOID
PAC_PutString(
    IN PVOID Base,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    DsysAssert( OutString != NULL );
    DsysAssert( InString != NULL );
    DsysAssert( Where != NULL && *Where != NULL);
    DsysAssert( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        //
        // Rest the pointer to be an offset.
        //
        OutString->Buffer = (PWCH) (*Where - (PUCHAR) Base);

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_MarshallValidationInfo
//
//  Synopsis:   marshals a NETLOGON_VALIDATION_SAM_INFO2
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_MarshallValidationInfo
(
    IN PSAMPR_USER_ALL_INFORMATION UserAll,
    IN PSAMPR_GET_GROUPS_BUFFER GroupsBuffer,
    IN PSID_AND_ATTRIBUTES_LIST ExtraGroups,
    IN PSID LogonDomainId,
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING LogonServer,
    IN BOOLEAN IncludeUserParms,
    IN BOOLEAN NetworkProfile,
    OUT PBYTE * ValidationInfo,
    OUT PULONG ValidationInfoSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO3 ValidationSam = {0};
    PNETLOGON_SID_AND_ATTRIBUTES MarshalledSids = NULL;
    SID ServerSid =  {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVER_LOGON_RID };
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE SidBuffer[sizeof(SID) + SID_MAX_SUB_AUTHORITIES * sizeof(ULONG)];
    PSID BuiltinSid = SidBuffer;
    PUCHAR Where;
    ULONG ExtraGroupSize = 0;
    ULONG ExtraGroupCount = 0;
    ULONG Index;

    //
    // Allocate a return buffer for validation information.
    //  (Return less information for a network logon)
    //  (Return UserParameters for a MNS logon)
    //

    //
    // First calculate the space needed for the extra groups.
    //

    if (ARGUMENT_PRESENT(ExtraGroups))
    {
        ExtraGroupCount += ExtraGroups->Count;
    }

    //
    // Add the enterprise server's sids
    //

    if ((UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) != 0)
    {
        ExtraGroupCount += 1;
    }

    //
    // Set the UF_SMARTCARD_REQUIRED flag
    //
    if ((UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED) != 0)
    {
        ValidationSam.UserFlags |= UF_SMARTCARD_REQUIRED;
    }


    //
    // Copy the scalars to the validation buffer.
    //


    ValidationSam.LogonTime = UserAll->LastLogon;

    //
    // BUG 455821: need logoff time & kickoff time
    //
#ifdef notdef
    NEW_TO_OLD_LARGE_INTEGER( LogoffTime, ValidationSam.LogoffTime );
    NEW_TO_OLD_LARGE_INTEGER( KickoffTime, ValidationSam.KickOffTime );
#else
    ValidationSam.LogoffTime.LowPart = 0xffffffff;
    ValidationSam.LogoffTime.HighPart = 0x7fffffff;
    ValidationSam.KickOffTime.LowPart = 0xffffffff;
    ValidationSam.KickOffTime.HighPart = 0x7fffffff;
#endif

    ValidationSam.PasswordLastSet = UserAll->PasswordLastSet;
    ValidationSam.PasswordCanChange = UserAll->PasswordCanChange;
    ValidationSam.PasswordMustChange = UserAll->PasswordMustChange;

    ValidationSam.LogonCount = UserAll->LogonCount;
    ValidationSam.BadPasswordCount = UserAll->BadPasswordCount;
    ValidationSam.UserId = UserAll->UserId;
    ValidationSam.PrimaryGroupId = UserAll->PrimaryGroupId;
    if (ARGUMENT_PRESENT( GroupsBuffer) )
    {
        ValidationSam.GroupCount = GroupsBuffer->MembershipCount;
        ValidationSam.GroupIds = GroupsBuffer->Groups;
    }
    else
    {
        ValidationSam.GroupCount = 0;
        ValidationSam.GroupIds = NULL;
    }


    ValidationSam.ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] = UserAll->UserAccountControl;
    //
    // If the client asked for extra information, return that
    // we support it
    //

    ValidationSam.UserFlags |= LOGON_EXTRA_SIDS;

    //
    // Copy ULONG aligned data to the validation buffer.
    //

    if (ExtraGroupCount != 0)
    {

        ValidationSam.SidCount = ExtraGroupCount;
        MarshalledSids = (PNETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(ExtraGroupCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES));
        if (MarshalledSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        ValidationSam.ExtraSids = MarshalledSids;
        Index = 0;

        if (ARGUMENT_PRESENT(ExtraGroups))
        {
            //
            // Now marshall each sid into the buffer
            //
            DsysAssert(sizeof(SID_AND_ATTRIBUTES) == sizeof(NETLOGON_SID_AND_ATTRIBUTES));

            RtlCopyMemory(
                &MarshalledSids[Index],
                ExtraGroups->SidAndAttributes,
                ExtraGroups->Count * sizeof(SID_AND_ATTRIBUTES)
                );
            Index += ExtraGroups->Count;
        }

        //
        // Add in special sids for domain controllers
        //

        if ((UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) != 0)
        {
            //
            // Add in the constant server logon sid
            //

            MarshalledSids[Index].Attributes = SE_GROUP_MANDATORY |
                                               SE_GROUP_ENABLED |
                                               SE_GROUP_ENABLED_BY_DEFAULT;


            MarshalledSids[Index].Sid = &ServerSid;
            Index++;


        }
    }


    ValidationSam.LogonDomainId = LogonDomainId;


    //
    // Copy WCHAR aligned data to the validation buffer.
    //  (Return less information for a network logon)
    //


    if ( ! NetworkProfile ) {

        ValidationSam.EffectiveName = *(PUNICODE_STRING)&UserAll->UserName;
        ValidationSam.FullName = *(PUNICODE_STRING)&UserAll->FullName;
        ValidationSam.LogonScript = *(PUNICODE_STRING)&UserAll->ScriptPath;

        ValidationSam.ProfilePath = *(PUNICODE_STRING)&UserAll->ProfilePath;

        ValidationSam.HomeDirectory = *(PUNICODE_STRING)&UserAll->HomeDirectory;

        ValidationSam.HomeDirectoryDrive = *(PUNICODE_STRING)&UserAll->HomeDirectoryDrive;

    }

    ValidationSam.LogonServer = *LogonServer;


    ValidationSam.LogonDomainName = *LogonDomainName;


    //
    // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
    // can't change the NETLOGON_VALIDATION_SAM_INFO2 structure between
    // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
    // so we'll use that field.
    //

    if ( IncludeUserParms && NetworkProfile ) {
        ValidationSam.HomeDirectoryDrive = *(PUNICODE_STRING)&UserAll->Parameters;
    }

    Status = PAC_EncodeValidationInformation(
                &ValidationSam,
                ValidationInfo,
                ValidationInfoSize
                );

Cleanup:

    if (MarshalledSids != NULL)
    {
        MIDL_user_free(MarshalledSids);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_MarshallValidationInfoWithGroups
//
//  Synopsis:   marshals a NETLOGON_VALIDATION_SAM_INFO2
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_ReMarshallValidationInfoWithGroups(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo,
    IN  PSAMPR_PSID_ARRAY ResourceGroups,
    OUT PBYTE * ValidationInfo,
    OUT PULONG ValidationInfoSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO3 ValidationSam = {0};
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    ULONG ExtraSidCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index, Index2;

    //
    // Copy the original validation information
    //

    ValidationSam = *OldValidationInfo;
    ValidationSam.UserFlags &= ~LOGON_RESOURCE_GROUPS;

    //
    // Clear any old resource groups
    //

    ValidationSam.ResourceGroupDomainSid = NULL;
    ValidationSam.ResourceGroupIds = NULL;
    ValidationSam.ResourceGroupCount = 0;

    //
    // Set the flag indicating resource groups may be present
    //

    if (ResourceGroups->Count != 0)
    {
        ExtraSidCount = ValidationSam.SidCount + ResourceGroups->Count;
        ValidationSam.UserFlags |= LOGON_EXTRA_SIDS;
        ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * ExtraSidCount);
        if (ExtraSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Add in all the extra sids that are not resource groups
        //

        Index2 = 0;
        for (Index = 0; Index < OldValidationInfo->SidCount; Index++ )
        {
            if ((OldValidationInfo->ExtraSids[Index].Attributes & SE_GROUP_RESOURCE) == 0)
            {
                ExtraSids[Index2] = OldValidationInfo->ExtraSids[Index];
                Index2++;
            }
        }

        //
        // Copy all the resource group SIDs
        //


        for (Index = 0; Index < ResourceGroups->Count ; Index++ )
        {
            ExtraSids[Index2].Sid = ResourceGroups->Sids[Index].SidPointer;
            ExtraSids[Index2].Attributes =  SE_GROUP_MANDATORY |
                                            SE_GROUP_ENABLED |
                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                            SE_GROUP_RESOURCE;
            Index2++;
        }
        ValidationSam.ExtraSids = ExtraSids;
        ValidationSam.SidCount = Index2;
    }

    Status = PAC_EncodeValidationInformation(
                &ValidationSam,
                ValidationInfo,
                ValidationInfoSize
                );

Cleanup:

    if (ExtraSids != NULL)
    {
        MIDL_user_free(ExtraSids);
    }
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallValidationInfo
//
//  Synopsis:   un marshals a NETLOGON_VALIDATION_SAM_INFO3
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallValidationInfo(
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo,
    IN PBYTE MarshalledInfo,
    IN ULONG ValidationInfoSize
    )
{
    NTSTATUS Status;

    *ValidationInfo = NULL;
    Status = PAC_DecodeValidationInformation(
                MarshalledInfo,
                ValidationInfoSize,
                ValidationInfo
                );
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_BuildCredentials
//
//  Synopsis:   Builds the buffer containing supplemental credentials for
//              the pac.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_BuildCredentials(
    IN PSAMPR_USER_ALL_INFORMATION UserAll,
    OUT PBYTE * Credentials,
    OUT PULONG CredentialSize
    )
{
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY PacCreds = NULL;
    PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredentials;
    PUCHAR Where;
    ULONG CredSize;
    NTSTATUS Status = STATUS_SUCCESS;

    *Credentials = NULL;

    //
    // The size of the credentials is the overhead for the structures
    // plus the name "msv1_0"
    //

    CredSize = sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) +
                     sizeof(SECPKG_SUPPLEMENTAL_CRED) +
                     sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL) +
                     NTLMSP_NAME_SIZE;
    PacCreds = (PSECPKG_SUPPLEMENTAL_CRED_ARRAY) MIDL_user_allocate(CredSize);
    if (PacCreds == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Build the PAC credential
    //

    Where = (PBYTE) PacCreds;

    PacCreds->CredentialCount = 1;

    Where += sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) + sizeof(SECPKG_SUPPLEMENTAL_CRED) - (ANYSIZE_ARRAY * sizeof(SECPKG_SUPPLEMENTAL_CRED));

    //
    // Build the secpkg creds
    //

    RtlCopyMemory(
        Where,
        NTLMSP_NAME,
        NTLMSP_NAME_SIZE
        );

    PacCreds->Credentials[0].PackageName.Buffer = (LPWSTR) Where;
    Where += ROUND_UP_COUNT(NTLMSP_NAME_SIZE,sizeof(ULONG));

    PacCreds->Credentials[0].PackageName.Length = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].PackageName.MaximumLength = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].CredentialSize = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);
    PacCreds->Credentials[0].Credentials = Where;

    MsvCredentials = (PMSV1_0_SUPPLEMENTAL_CREDENTIAL) Where;
    Where += sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);

    RtlZeroMemory(
        MsvCredentials,
        sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL)
        );

    MsvCredentials->Version = MSV1_0_CRED_VERSION;

    if (UserAll->NtPasswordPresent)
    {
        DsysAssert(UserAll->NtOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_NT_PRESENT;
        RtlCopyMemory(
            MsvCredentials->NtPassword,
            UserAll->NtOwfPassword.Buffer,
            UserAll->NtOwfPassword.Length
            );
    }
    if (UserAll->LmPasswordPresent)
    {
        DsysAssert(UserAll->LmOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_LM_PRESENT;
        RtlCopyMemory(
            MsvCredentials->LmPassword,
            UserAll->LmOwfPassword.Buffer,
            UserAll->LmOwfPassword.Length
            );
    }

    Status = PAC_EncodeCredentialData(
                PacCreds,
                Credentials,
                CredentialSize
                );

    if (PacCreds != NULL)
    {
        MIDL_user_free(PacCreds);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallCredentials
//
//  Synopsis:   un marshals a SECPKG_SUPPLEMENTAL_CRED_ARRAY
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallCredentials(
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * Credentials,
    IN PBYTE MarshalledInfo,
    OUT ULONG CredentialInfoSize
    )
{
    NTSTATUS Status;

    *Credentials = NULL;
    Status = PAC_DecodeCredentialData(
                MarshalledInfo,
                CredentialInfoSize,
                Credentials
                );
    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Init
//
//  Synopsis:   Creates a new PAC with the provided info
//
//  Arguments:  UserAll - UserAllInformation for the user
//              GroupsBuffer - The buffer returned from a call to
//                      SamrGetGroupsForUser, contains all global groups
//              LogonDomainId - Domain SID for the domain of this DC
//              SignatureSize - Space to reserve for signatures. If zero,
//                      no signatures are added.
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_Init(
    IN  PSAMPR_USER_ALL_INFORMATION UserAll,
    IN  OPTIONAL PSAMPR_GET_GROUPS_BUFFER GroupsBuffer,
    IN  OPTIONAL PSID_AND_ATTRIBUTES_LIST ExtraGroups,
    IN  PSID LogonDomainId,
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING LogonServer,
    IN  ULONG SignatureSize,
    IN  ULONG AdditionalDataCount,
    IN  PPAC_INFO_BUFFER * AdditionalData,
    OUT PPACTYPE * ppPac
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    ULONG cbProxyData = 0;
    PBYTE ValidationInfo = NULL;
    ULONG ValidationInfoSize;
    NTSTATUS Status;
    PBYTE pDataStore;
    ULONG Index;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the provided
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    //
    // First we will create the validation info buffer. We can copy it into
    // the PAC later.
    //

    Status = PAC_MarshallValidationInfo(
                UserAll,
                GroupsBuffer,
                ExtraGroups,
                LogonDomainId,
                LogonDomainName,
                LogonServer,
                FALSE,          // don't include user parms
                FALSE,          // not a network logon
                &ValidationInfo,
                &ValidationInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // We need a PAC_INFO_BUFFER to store the validation info.
    //

    cbBytes += ROUND_UP_COUNT(ValidationInfoSize, ALIGN_QUAD);
    cPacBuffers += 1;

    for (Index = 0; Index < AdditionalDataCount ; Index++ )
    {
        cbBytes += ROUND_UP_COUNT(AdditionalData[Index]->cbBufferSize,ALIGN_QUAD);
        cPacBuffers++;
    }

    //
    // If signature size is non-zero, add in space for signatures.
    //

    if (SignatureSize != 0)
    {
        cPacBuffers += 2;
        cbBytes += 2 * (ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD));
    }

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //
    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory( pNewPac, cbBytes );

    pNewPac->Version = PAC_VERSION;
    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Save the PAC identity ...
    //

    pNewPac->Buffers[iBuffer].ulType = PAC_LOGON_INFO;
    pNewPac->Buffers[iBuffer].cbBufferSize = ValidationInfoSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    CopyMemory(
        pDataStore,
        ValidationInfo,
        ValidationInfoSize
        );


    pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
    iBuffer ++;

    //
    // Store the additional data
    //

    for (Index = 0; Index < AdditionalDataCount ; Index++ )
    {
        pNewPac->Buffers[iBuffer].ulType = AdditionalData[Index]->ulType;
        pNewPac->Buffers[iBuffer].cbBufferSize = AdditionalData[Index]->cbBufferSize;
        pNewPac->Buffers[iBuffer].Data = pDataStore;

        CopyMemory(
            pDataStore,
            AdditionalData[Index]->Data,
            AdditionalData[Index]->cbBufferSize
            );


        pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
        pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
        iBuffer ++;
    }

    //
    // Store the signatures
    //

    if (SignatureSize != 0)
    {
        pNewPac->Buffers[iBuffer].ulType = PAC_SERVER_CHECKSUM;
        pNewPac->Buffers[iBuffer].cbBufferSize = PAC_SIGNATURE_SIZE(SignatureSize);
        pNewPac->Buffers[iBuffer].Data = pDataStore;
        pDataStore += ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize),ALIGN_QUAD);
        iBuffer ++;

        pNewPac->Buffers[iBuffer].ulType = PAC_PRIVSVR_CHECKSUM;
        pNewPac->Buffers[iBuffer].cbBufferSize = PAC_SIGNATURE_SIZE(SignatureSize);
        pNewPac->Buffers[iBuffer].Data = pDataStore;
        pDataStore += ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD);
        iBuffer ++;
    }

    *ppPac = pNewPac;
    pNewPac = NULL;
Cleanup:
    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }
    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_InitAndUpdateGroups
//
//  Synopsis:   Creates a new PAC from old validation info and a list of
//              resource groupss.
//
//  Arguments:  OldValidationInfo - Old info from a previous PAC
//              ResourceGroups - Resource groups in this domain
//              OldPac - OldPac to copy data from
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_InitAndUpdateGroups(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo,
    IN  PSAMPR_PSID_ARRAY ResourceGroups,
    IN  PPACTYPE OldPac,
    OUT PPACTYPE * ppPac
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    ULONG cbProxyData = 0;
    PBYTE ValidationInfo = NULL;
    ULONG ValidationInfoSize;
    NTSTATUS Status;
    PBYTE pDataStore;
    ULONG Index;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the provided
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    //
    // First we will create the validation info buffer. We can copy it into
    // the PAC later.
    //

    Status = PAC_ReMarshallValidationInfoWithGroups(
                OldValidationInfo,
                ResourceGroups,
                &ValidationInfo,
                &ValidationInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We need a PAC_INFO_BUFFER to store the PAC_IDENTITY which
    // contain the principal RID and the principal's domain GUID.
    //

    cbBytes += ROUND_UP_COUNT(ValidationInfoSize, ALIGN_QUAD);
    cPacBuffers += 1;

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_LOGON_INFO)
        {
            cbBytes += ROUND_UP_COUNT(OldPac->Buffers[Index].cbBufferSize,ALIGN_QUAD);
            cPacBuffers++;
        }
    }


    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //
    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory( pNewPac, cbBytes );

    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Save the PAC identity ...
    //
    pNewPac->Buffers[iBuffer].ulType = PAC_LOGON_INFO;
    pNewPac->Buffers[iBuffer].cbBufferSize = ValidationInfoSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    CopyMemory(
        pDataStore,
        ValidationInfo,
        ValidationInfoSize
        );


    pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
    iBuffer ++;

    //
    // Store the additional data
    //

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_LOGON_INFO)
        {
            pNewPac->Buffers[iBuffer].ulType = OldPac->Buffers[Index].ulType;
            pNewPac->Buffers[iBuffer].cbBufferSize = OldPac->Buffers[Index].cbBufferSize;
            pNewPac->Buffers[iBuffer].Data = pDataStore;

            CopyMemory(
                pDataStore,
                OldPac->Buffers[Index].Data,
                OldPac->Buffers[Index].cbBufferSize
                );


            pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
            pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
            iBuffer ++;
        }

    }

    *ppPac = pNewPac;
    pNewPac = NULL;
Cleanup:
    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }
    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_Find
//
//  Synopsis:   Finds a type of PAC info buffer in the given PAC.
//              If pElem is NULL, the first buffer found matching the
//              specified type is returned. Otherwise, the next buffer
//              after pElem found matching that type is returned.
//
//  Arguments:
//
//  History:    01-June-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PPAC_INFO_BUFFER
PAC_Find( IN  PPACTYPE     pPac,
          IN  ULONG        ulType,
          PPAC_INFO_BUFFER pElem)
{
    PAC_INFO_BUFFER *pTemp = NULL, *pEnd;

    if (pPac)
    {
        pEnd = &(pPac->Buffers[pPac->cBuffers]);
        if (pElem)
        {
            pTemp = pElem + 1;
        }
        else
        {
            pTemp = &(pPac->Buffers[0]);
        }

        while ( pTemp < pEnd && pTemp->ulType != ulType )
        {
            pTemp++;
        }

        if (pTemp >= pEnd)
        {
            // element not found in the PAC
            pTemp = NULL;
        }
    }

    return (pTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\pacndr_s_stub.c ===
#include "pacndr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\trnsport.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        trnsport.cxx
//
// Contents:    GetRpcTransports        Returns bitmap of supported transports
//
//
// History:
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop



HRESULT
GetRpcTransports(PDWORD         pTransports)
{

    PWKSTA_TRANSPORT_INFO_0 pstiTransports;
    ULONG                   EntriesRead,TotalEntries;
    ULONG                   hResume;
    ULONG                   err;
    DWORD                   SupportedProtseqs = 0;
    ULONG                   cIndex;

    // find what transports are supported


    err = NetWkstaTransportEnum(NULL,0,(PBYTE *) &pstiTransports,5000,
                    &EntriesRead,&TotalEntries,&hResume);
    if (!err)
    {
        for (cIndex = 0; cIndex < EntriesRead ; cIndex++ )
        {
            if (wcsstr(pstiTransports[cIndex].wkti0_transport_name,L"Nbf"))
            {
                SupportedProtseqs |= 1 << TRANS_NB;
            }
            if (wcsstr(pstiTransports[cIndex].wkti0_transport_name,L"NBT"))
            {
                SupportedProtseqs |= 1 << TRANS_TCPIP;
            }
            if (wcsstr(pstiTransports[cIndex].wkti0_transport_name,L"Xns") ||
                wcsstr(pstiTransports[cIndex].wkti0_transport_name,L"UB"))
            {
                SupportedProtseqs |= 1 << TRANS_XNS;
            }
        }
        NetApiBufferFree((PBYTE) pstiTransports);
        if (SupportedProtseqs)
        {
            SupportedProtseqs |= 1 << TRANS_NP;
        }
        *pTransports = SupportedProtseqs;
    }

    if (err)
    {
        return(HRESULT_FROM_WIN32(err));
    }
    return(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\timeserv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       timeserv.cxx
//
//  Contents:   C++ utilties for the time serve C code
//
//  Classes:
//
//
//  History:    19-May-94  ArnoldM Created
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop


// A class for initing the critical section needed by the time set
// code in gettime.c. The code there relies on a critical section to
// serialize the time slew settings. Rather than require each exe
// that uses this library to put in calls to initialize the section and
// to undo any time slew settings on exit, we create this class and use
// a static constructor to do the appropriate calls. It's one of the
// times that using C++ is a pleasure.
//
// The class also winds up owning the Critical Section. This is to create
// the proper dependence on this code module so that the loader loads all of
// the required pieces. Doing this adds a bit more overhead to Enter and
// Leave the critical section, but it's done rarely enough that it shouldn't
// matter.

class _TimeSlew
{
public:
    ~_TimeSlew();
     _TimeSlew();

// The two wrappers for entering and leaving the critical section.

     VOID EnterCS();
     VOID LeaveCS();

private:

     CRITICAL_SECTION csAdjSection;
};


// No one needs to look at this, ever. Since the class has no state, the
// instance memory consumption should be nil (wonder if it really is?).

static
class _TimeSlew TimeSlew;

// reference the routines in gettime.c we exist to serve

extern "C"
{
VOID
SecMiscTimeSettingInit();
VOID
SecMiscTimeSettingDone();
}

//+--------------------------------------------------------------------------
//
// _TimeSlew::_TimeSlew -- constructor
// and
// _TimeSlew::~_TimeSlew -- destructor
//
// These are simply class wrappers for the C routines in gettime.c
// They provide a way to avoid having to put explicit calls
// into .exes
//
//---------------------------------------------------------------------------
_TimeSlew::_TimeSlew()
{
    InitializeCriticalSection(&csAdjSection);
    SecMiscTimeSettingInit();
}
_TimeSlew::~_TimeSlew()
{
    SecMiscTimeSettingDone();
    DeleteCriticalSection(&csAdjSection);
}

//-----------------------------------------------------------------------------
//
// and the rest of the cast
//
//-----------------------------------------------------------------------------
inline
VOID
_TimeSlew::EnterCS()
{
    EnterCriticalSection(&csAdjSection);
}

inline
VOID
_TimeSlew::LeaveCS()
{
    LeaveCriticalSection(&csAdjSection);
}

//----------------------------------------------------------------------------
//
// API wrappers for the above
//
//----------------------------------------------------------------------------
extern "C"
VOID
SMEnterCriticalSection()
{
    TimeSlew.EnterCS();
}

extern "C"
VOID
SMLeaveCriticalSection()
{
    TimeSlew.LeaveCS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\rtl\string.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       string.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    13-May-92 PeterWi       Created string.c
//              16-Mar-93 WadeR         ported to C++
//
//--------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

// Local Headers

//
//  String manipulation routines

//+---------------------------------------------------------------------------
//
//  Function:   SRtlInitStringX
//
//  Synopsis:   Initializes a string to a passed pointer
//
//  Arguments:  [pDest] --
//              [pSrc]  --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:      Here for Win32 compatibility
//
//----------------------------------------------------------------------------
extern "C"
void
SRtlInitStringX(
    PSECURITY_STRING    pDest,
    LPWSTR              pSrc)
{
    pDest->Buffer = pSrc;
    pDest->Length = wcslen(pSrc) * sizeof(WCHAR);
    pDest->MaximumLength = pDest->Length + sizeof(WCHAR);
}

//+-------------------------------------------------------------------------
//
//  Function:   SRtlDuplicateString
//
//  Synopsis:   Makes a copy of the string referenced by pSrc
//
//  Effects:    Memory is allocated from the process heap.
//              An exact copy is made, except that:
//                  Buffer is zero'ed
//                  Length bytes are copied
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Will null terminate the string, growing it if needed.
//
//--------------------------------------------------------------------------
void
SRtlDuplicateString(PSECURITY_STRING    pDest,
                    PSECURITY_STRING    pSrc)
{
    ULONG cb = max( pSrc->MaximumLength, pSrc->Length + sizeof(WCHAR));

    pDest->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (pDest->Buffer)
    {
        pDest->MaximumLength = (USHORT) cb;
        CopyMemory(pDest->Buffer, pSrc->Buffer, pSrc->Length);
        pDest->Length = pSrc->Length;
        pDest->Buffer[pDest->Length/sizeof(WCHAR)] = L'\0';
    }
    else
    {
        pDest->MaximumLength = pDest->Length = 0;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SRtlDuplicateBuffer
//
//  Synopsis:   Makes a copy of the buffer referenced by pSrc
//
//  Effects:    Memory is allocated from the process heap.
//              An exact copy is made, except that:
//                  Buffer is zero'ed
//                  Length bytes are copied
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

void
SRtlDuplicateBuffer(PSTRING    pDest,
                    PSTRING    pSrc)
{
    pDest->Length = 0;

    pDest->Buffer = (PCHAR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                        pSrc->MaximumLength);

    if (pDest->Buffer)
    {
        ZeroMemory(pDest->Buffer, pSrc->MaximumLength);
        pDest->MaximumLength = pSrc->MaximumLength;
        pDest->Length = pSrc->Length;
        CopyMemory(pDest->Buffer, pSrc->Buffer, pSrc->Length);
    } else
    {
        pDest->MaximumLength = 0;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SRtlNewString
//
//  Synopsis:   Creates a COPY of the wide character string pointer pSrc
//              and sets up a SECURITY_STRING appropriately
//
//
//  Effects:    Memory is allocated off of the process heap
//              The string remains null terminated.
//
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
SRtlNewString(  PSECURITY_STRING pDest,
                LPWSTR pSrc)
{
    SECURITY_STRING Source;

    Source.Length = wcslen((wchar_t *) pSrc) * sizeof(wchar_t);
    Source.MaximumLength = Source.Length + 2;
    Source.Buffer = pSrc;
    SRtlDuplicateString(pDest, &Source);
}


//+-------------------------------------------------------------------------
//
//  Function:   SRtlNewStringFromNarrow
//
//  Synopsis:   Takes a ansi string and (1) unicodes it, (2) copies it
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
SRtlNewStringFromNarrow(PSECURITY_STRING    pDest,
                        char *              pszString)
{
    int cbNewString;
    DWORD cbOriginalString;

    cbOriginalString = strlen(pszString);

    cbNewString = cbOriginalString * sizeof(WCHAR);

    SRtlAllocateString( pDest, cbNewString + sizeof( WCHAR ) );
    if (pDest->Buffer)
    {
        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                pszString, cbOriginalString + 1,
                                pDest->Buffer, cbOriginalString + 1))
        {
            pDest->Length = cbNewString;
        }
        else
        {
            LocalFree(pDest->Buffer);
            pDest->Buffer = NULL;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SRtlAllocateString
//
//  Synopsis:   Allocates space for a Unicode string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This is useful to later append to the string.
//
//--------------------------------------------------------------------------
void
SRtlAllocateString(PSECURITY_STRING pString, USHORT cbSize )
{
    pString->Buffer = (PWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbSize);

    if (pString->Buffer)
    {
        pString->MaximumLength = cbSize;
    }
    else
    {
        pString->MaximumLength = 0;
    }
    pString->Length = 0;
}



//+-----------------------------------------------------------------
//
//  Name:       SRtlFreeString
//
//  Synopsis:   Frees a string.
//
//  Effects:    .
//
//  Arguments:  [pString] -- String to be freed.
//
//  Requires:   .
//
//  Returns:    .
//
//  Notes:      .
//
//------------------------------------------------------------------
void
SRtlFreeString( PSECURITY_STRING    pString)
{
    LocalFree(pString->Buffer);
#if DBG
    pString->Buffer = NULL;
#endif

}


void
SRtlInitStringOfSize(
    PSECURITY_STRING DestinationString,
    USHORT Size,
    PWSTR str
    )
{
    DestinationString->MaximumLength = DestinationString->Length = Size;
    DestinationString->Buffer = str;
}

void
SRtlInitBufferOfSize(
    PSTRING DestinationString,
    USHORT Size,
    PUCHAR buffer
    )
{
    DestinationString->MaximumLength = DestinationString->Length = Size;
    DestinationString->Buffer = (PCHAR) buffer;
}

LONG
SRtlCompareString(
    PSECURITY_STRING String1,
    PSECURITY_STRING String2,
    BOOLEAN CaseInSensitive
    )
{
    return( RtlCompareUnicodeString((PUNICODE_STRING) String1,
                                    (PUNICODE_STRING) String2,
                                    CaseInSensitive));
}

void
SRtlCopyString(
     PSECURITY_STRING DestinationString,
     PSECURITY_STRING SourceString
     )
{
    RtlCopyUnicodeString(   (PUNICODE_STRING) DestinationString,
                            (PUNICODE_STRING) SourceString);
}

void
SRtlCopyBuffer(
     PSTRING DestinationString,
     PSTRING SourceString
     )
{
    RtlCopyString(      (PSTRING)DestinationString,
                        (PSTRING)SourceString);
}

//+-------------------------------------------------------------------------
//
//  Function:   SRtlCatString
//
//  Synopsis:   Concatenates pSrc into pDest->Buffer. It is assumed that
//              pDest->Buffer is pointing to enough memory.
//
//
//  Effects:    The string will be null terminated.
//
//
//  Arguments:
//
//  Requires:   pDest->Buffer must point to enough memory.
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
SRtlCatString(  PSECURITY_STRING pDest,
                LPWSTR pSrc)
{

   wcscat(pDest->Buffer, pSrc);

   pDest->Length = wcslen( pDest->Buffer ) * sizeof( WCHAR );
   pDest->Buffer[pDest->Length / sizeof( WCHAR )] = UNICODE_NULL;
}


#if 0
//+-----------------------------------------------------------------
//
//  Name:       SRtlStrContains
//
//  Synopsis:   Looks for a needle in a haystack.
//
//  Effects:    .
//
//  Arguments:  [pNeedle]        --
//              [pHaystack]      --
//              [fCaseInSensitiv --
//
//  Requires:   .
//
//  Returns:    .
//
//  Notes:      This is not a clever algorithm.
//
//------------------------------------------------------------------
BOOLEAN
SRtlStrContains(
    const PSECURITY_STRING pNeedle,
    const PSECURITY_STRING pHaystack,
    BOOLEAN                fCaseInSensitive)
{
    WCHAR   *pNeed = pNeedle->Buffer;
    WCHAR   *pHay  = pHaystack->Buffer;
    WCHAR   *pHayEnd = pHay +
                        (pHaystack->Length - pNeedle->Length)/sizeof(WCHAR);


    // Pre-compute some things that are used in the loop.
    int (__cdecl * CmpFcn)(const WCHAR*,const WCHAR*,unsigned int);
    CmpFcn = (fCaseInSensitive) ? wcsnicmp : wcsncmp;

    int cchNeed = pNeedle->Length/sizeof(WCHAR);

    while ( pHay <= pHayEnd )
    {
        if ( (*pNeed == *pHay) &&
             (CmpFcn( pNeed, pHay, cchNeed ) == 0) )
        {
            // Found a match!
            return(TRUE);
        }
        pHay++;
    }
    return(FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\debug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.cxx
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    19-Nov-92 WadeR     Created
//
//  Notes:      If you change or add a debug level, also fix debug.hxx
//              This is only compiled if DBG > 0
//
//--------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include <kdcdbg.h>
#include "debug.hxx"
#include <tostring.hxx>



//
// The "#pragma hdrstop" causes the preprocessor to forget any "#if"s
// is is processing.  Therefore you can't have it inside an "#if" block.
// So the includes will always compile, and the rest of this code becomes
// conditional.
//


#include <stddef.h>

#ifdef RETAIL_LOG_SUPPORT

//
// Variables for heap checking and used by sectrace.hxx:
//

// Set following to HEAP_CHECK_ON_ENTER | HEAP_CHECK_ON_EXIT for heap checking.
DWORD dwHeapChecking = 0;

// This keeps a registry key handle to the HKLM\System\CCSet\Control\LSA\
// Kerberoskey
HKEY hKeyParams = NULL; 
HANDLE hWait = NULL;


// Set following to address of a function which takes 0 arguments and returns
// a void for arbitrary run time checking.
VOID (*debugFuncAddr)() = NULL;


//
// Tons and tons of global data to get debugging params from the ini file.
//
// Note: For every trace bit, there must be a label in this array matching
//       that trace bit and only that trace bit.  There can be other labels
//       matching combinations of trace bits.
//


DEBUG_KEY   KdcDebugKeys[] = {  {DEB_ERROR,     "Error"},
                                {DEB_WARN,      "Warning"},
                                {DEB_TRACE,     "Trace"},
                                {DEB_T_KDC,     "Kdc"},
                                {DEB_T_TICKETS, "Tickets"},
                                {DEB_T_DOMAIN,  "Domain"},
                                {DEB_T_SOCK,    "Sock"},
                                {DEB_T_TRANSIT, "Transit"},
                                {DEB_T_PERF_STATS, "Perf"},
                                {DEB_T_PKI, "PKI"},
                                {0, NULL},
                            };



DEFINE_DEBUG2(KDC);
extern DWORD KSuppInfoLevel; // needed to adjust values for common2 dir


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKDCRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry 
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/Kerberos
//
//  Notes:      Sets KDCInfolevel for debug spew
//
void
KerbGetKDCRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = KDCInfoLevel, cbSize = sizeof(DWORD);
    DWORD       dwErr;
 
    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_DEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize      
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults


            // NOTE:  Since SCLogon sux so badly, we're going to log all PKI events for now.
            // FESTER:  Pull for server B3.


#if DBG

            KSuppInfoLevel = KDCInfoLevel = DEB_ERROR | DEB_T_PKI;
            
#else // fre
            KSuppInfoLevel = KDCInfoLevel = DEB_T_PKI;
#endif
        }else{
            DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));        
        }      

        
    }

    // TBD:  Validate flags?
                      
    KSuppInfoLevel = KDCInfoLevel = tmpInfoLevel;
    
    return;
}

//
// Tempo?
//
/*void FillExtError(PKERB_EXT_ERROR p,NTSTATUS s,ULONG f,ULONG l) 
{                                                               
   if (EXT_ERROR_ON(KDCInfoLevel))                                                  \
   {                                                            
      p->status = s;                                            
      p->klininfo = KLIN(f,l);                                  
   }                                                            
                                                                
   sprintf(xx, "XX File-%i, Line-%i", f,l);                   
   OutputDebugStringA(xx);                                      
                                                                 
} */



////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
KerbWatchParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{
       
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
   
    if (NULL == hKeyParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    KERB_PARAMETER_PATH,
                    0,
                    KEY_READ,
                    &hKeyParams);
 
        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hWait) 
    {
        Status = RtlDeregisterWait(hWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKeyParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes) 
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }
                   
    KerbGetKDCRegParams(hKeyParams);
    
Reregister:
    
    Status = RtlRegisterWait(&hWait,
                             (HANDLE) pCtxt,
                             KerbWatchParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);

}
////////////////////////////////////////////////////////////////////
//
//  Name:       WaitCleanup
//
//  Synopsis:   Cleans up for KerbWatchParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID 
WaitCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hWait) {
        Status = RtlDeregisterWait(hWait);
        hWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}
        


////////////////////////////////////////////////////////////////////
//
//  Name:       GetDebugParams
//
//  Synopsis:   Gets the debug paramaters from the ini file.
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
GetDebugParams() {

    CHAR   chBuf[128];
    DWORD   cbBuf;

    KDCInitDebug(KdcDebugKeys);
}






#if DBG // moved here to utilize debug logging in free builds.


NTSTATUS
KDC_GetState(   handle_t    hBinding,
                DWORD *     KDCFlags,
                DWORD *     MaxLifespan,
                DWORD *     MaxRenewSpan,
                PTimeStamp  FudgeFactor)
{
    *FudgeFactor = SkewTime;

    TimeStamp tsLife, tsRenew;

    NTSTATUS hr = SecData.DebugGetState(KDCFlags, &tsLife, &tsRenew );
    tsLife.QuadPart = (tsLife.QuadPart / ulTsPerSecond);
    *MaxLifespan =tsLife.LowPart;
    tsRenew.QuadPart = (tsRenew.QuadPart / ulTsPerSecond);
    *MaxRenewSpan = tsRenew.LowPart;
    return(hr);
}

NTSTATUS
KDC_SetState(   handle_t    hBinding,
                DWORD       KdcFlags,
                DWORD       MaxLifespan,
                DWORD       MaxRenewSpan,
                TimeStamp  FudgeFactor)
{
    NTSTATUS hr;
    TimeStamp tsLife = {0,0};
    TimeStamp tsRenew = {0,0};
    UNICODE_STRING ss;

    if (FudgeFactor.QuadPart != 0)
    {
        SkewTime = FudgeFactor;
        Authenticators->SetMaxAge( SkewTime );
    }

    tsLife.QuadPart = (LONGLONG) MaxLifespan * 10000000;
    tsRenew.QuadPart = (LONGLONG) MaxRenewSpan * 10000000;

    if (KdcFlags == 0)
    {
        KdcFlags = SecData.KdcFlags();
    }
    if (MaxLifespan == 0)
    {
        tsLife = SecData.KdcTgtTicketLifespan();
    }

    if (MaxRenewSpan == 0)
    {
        tsLife = SecData.KdcTicketRenewSpan();
    }

    hr = SecData.DebugSetState(KdcFlags, tsLife, tsRenew);

    SecData.DebugShowState();



    return(hr);
}


void PrintIntervalTime (
        ULONG DebugFlag,
        LPSTR Message,
        PLARGE_INTEGER Interval )
{
    LONGLONG llTime = Interval->QuadPart;
    LONG lSeconds = (LONG) ( llTime / 10000000 );
    LONG lMinutes = ( lSeconds / 60 ) % 60;
    LONG lHours = ( lSeconds / 3600 );
    DebugLog(( DebugFlag, "%s %d:%2.2d:%2.2d \n", Message, lHours, lMinutes, lSeconds % 60 ));
}

void PrintTime (
        ULONG DebugFlag,
        LPSTR Message,
        PLARGE_INTEGER Time )
{
    SYSTEMTIME st;

    FileTimeToSystemTime ( (PFILETIME) Time, & st );
    DebugLog((DebugFlag, "%s %d-%d-%d %d:%2.2d:%2.2d\n", Message, st.wMonth, st.wDay, st.wYear,
                st.wHour, st.wMinute, st.wSecond ));
}





#else // DBG

NTSTATUS
KDC_GetState(   handle_t    hBinding,
                DWORD *     KDCFlags,
                DWORD *     MaxLifespan,
                DWORD *     MaxRenewSpan,
                PTimeStamp  FudgeFactor)
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS
KDC_SetState(   handle_t    hBinding,
                DWORD       KDCFlags,
                DWORD       MaxLifespan,
                DWORD       MaxRenewSpan,
                TimeStamp  FudgeFactor)
{
    return(STATUS_NOT_SUPPORTED);
}




#endif
#endif

BOOLEAN
KdcSetPassSupported(
    VOID
    )
{
    NET_API_STATUS NetStatus;
    ULONG SetPassUnsupported = 0;
    LPNET_CONFIG_HANDLE ConfigHandle = NULL;

    NetStatus = NetpOpenConfigData(
                    &ConfigHandle,
                    NULL,               // noserer name
                    L"kdc",
                    TRUE                // read only
                    );
    if (NetStatus != NO_ERROR)
    {
        return(TRUE);
    }
    NetStatus = NetpGetConfigDword(
                    ConfigHandle,
                    L"SetPassUnsupported",
                    0,
                    &SetPassUnsupported
                    );

    NetpCloseConfigData( ConfigHandle );
    if ((NetStatus == NO_ERROR) && (SetPassUnsupported == 1))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KDC_SetPassword
//
//  Synopsis:   Sets password for an account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KDC_SetPassword(
    IN handle_t hBinding,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Password,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    SECPKG_SUPPLEMENTAL_CRED Credentials;
    KDC_TICKET_INFO TicketInfo;
    SAMPR_HANDLE UserHandle = NULL;
    UNICODE_STRING NewUserName;
    KERB_EXT_ERROR ExtendedError; // dummy var.


    Credentials.Credentials = NULL;

    if (!KdcSetPassSupported())
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Make sure we can impersonate the caller.
    //

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    else
    {
        RpcRevertToSelf();
    }

    // According to bug 228139, rpc definition of unicode strings allow
    // for odd lengths. We will set them to even (1 less) so that we
    // don't av in the lsa.

    if (ARGUMENT_PRESENT(UserName) && UserName->Buffer)
    {
        UserName->Length = (UserName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KdcGetTicketInfo(
                    UserName,
                    0,                  // no flags
                    NULL,
                    NULL,
                    &TicketInfo,
                    &ExtendedError,
                    &UserHandle,
                    0L,                 // no fields to fetch
                    0L,                 // no extended fields
                    NULL,               // no user all
                    NULL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to get ticket info for %wZ: 0x%x\n",
                UserName, KerbErr ));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }
    FreeTicketInfo(&TicketInfo);

    if (ARGUMENT_PRESENT(Password) && Password->Buffer)
    {
        Password->Length = (Password->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Buffer)
    {
        PrincipalName->Length = (PrincipalName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = KdcBuildPasswordList(
                Password,
                PrincipalName,
                SecData.KdcDnsRealmName(),
                UnknownAccount,
                NULL,               // no stored creds
                0,                  // no stored creds
                TRUE,               // marshall
                FALSE,              // don't include builtins
                Flags,
                Unknown,
                (PKERB_STORED_CREDENTIAL *) &Credentials.Credentials,
                &Credentials.CredentialSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &Credentials.PackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    Status = SamIStorePrimaryCredentials(
                UserHandle,
                &Credentials
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to store primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }

Cleanup:
    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }
    if (Credentials.Credentials != NULL)
    {
        MIDL_user_free(Credentials.Credentials);
    }
    return(Status);
}


NTSTATUS
KDC_GetDomainList(
    IN handle_t hBinding,
    OUT PKDC_DBG_DOMAIN_LIST * DomainList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DBG_DOMAIN_LIST TempList;
    PKDC_DBG_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO Domain;
    ULONG DomainCount = 0;
    PLIST_ENTRY ListEntry;
    ULONG Index = 0;

    *DomainList = NULL;

    KdcLockDomainListFn();

    TempList = (PKDC_DBG_DOMAIN_LIST) MIDL_user_allocate(sizeof(KDC_DBG_DOMAIN_LIST));
    if (TempList == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    for (ListEntry = KdcDomainList.Flink;
         ListEntry != &KdcDomainList ;
         ListEntry = ListEntry->Flink )
    {
        DomainCount++;
    }

    DomainInfo = (PKDC_DBG_DOMAIN_INFO) MIDL_user_allocate(DomainCount * sizeof(KDC_DBG_DOMAIN_INFO));
    if (DomainInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(
        DomainInfo,
        DomainCount * sizeof(KDC_DBG_DOMAIN_INFO)
        );

    Index = 0;
    for (ListEntry = KdcDomainList.Flink;
         ListEntry != &KdcDomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        KerbDuplicateString(
            &DomainInfo[Index].DnsName,
            &Domain->DnsName
            );
        KerbDuplicateString(
            &DomainInfo[Index].NetbiosName,
            &Domain->NetbiosName
            );
        if (Domain->ClosestRoute != NULL)
        {
            KerbDuplicateString(
                &DomainInfo[Index].ClosestRoute,
                &Domain->ClosestRoute->DnsName
                );
        }
        DomainInfo->Type = Domain->Type;
        DomainInfo->Attributes = Domain->Attributes;
        Index++;
    }

    TempList->Count = DomainCount;
    TempList->Domains = DomainInfo;
    *DomainList = TempList;
    TempList = NULL;
    DomainInfo = NULL;

Cleanup:
    KdcUnlockDomainListFn();

    if (TempList != NULL)
    {
        MIDL_user_free(TempList);
    }
    if (DomainInfo != NULL)
    {
        MIDL_user_free(DomainInfo);
    }

    return(Status);
}

VOID
KdcCopyKeyData(
    OUT PKERB_KEY_DATA NewKey,
    IN PKERB_KEY_DATA OldKey,
    IN OUT PBYTE * Where,
    IN LONG_PTR Offset
    )
{
    //
    // Copy the key
    //

    NewKey->Key.keytype = OldKey->Key.keytype;
    NewKey->Key.keyvalue.length = OldKey->Key.keyvalue.length;
    NewKey->Key.keyvalue.value = (*Where) - Offset;
    RtlCopyMemory(
        (*Where),
        OldKey->Key.keyvalue.value,
        OldKey->Key.keyvalue.length
        );
    (*Where) += OldKey->Key.keyvalue.length;

    //
    // Copy the salt
    //

    if (OldKey->Salt.Buffer != NULL)
    {
        NewKey->Salt.Length =
            NewKey->Salt.MaximumLength =
                OldKey->Salt.Length;
        NewKey->Salt.Buffer = (LPWSTR) ((*Where) - Offset);
        RtlCopyMemory(
            (*Where),
            OldKey->Salt.Buffer,
            OldKey->Salt.Length
            );
        (*Where) += OldKey->Salt.Length;

    }

}

//+-------------------------------------------------------------------------
//
//  Function:   KDC_SetAccountKeys
//
//  Synopsis:   Set the keys for an account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KDC_SetAccountKeys(
    IN handle_t hBinding,
    IN PUNICODE_STRING UserName,
    IN ULONG Flags,
    IN PKERB_STORED_CREDENTIAL Keys
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_EXT_ERROR ExtendedError; // dummy var
    SECPKG_SUPPLEMENTAL_CRED Credentials = {0};
    KDC_TICKET_INFO TicketInfo= {0};
    SAMPR_HANDLE UserHandle = NULL;
    PKERB_STORED_CREDENTIAL StoredCreds = NULL;
    PKERB_STORED_CREDENTIAL Passwords = NULL;
    ULONG StoredCredSize = 0;
    ULONG CredentialCount = 0;
    ULONG CredentialIndex = 0;
    ULONG Index;
    PBYTE Where;
    UNICODE_STRING DefaultSalt;
    LONG_PTR Offset;



    if (!KdcSetPassSupported())
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Make sure we can impersonate the caller.
    //

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    else
    {
        RpcRevertToSelf();
    }

    // According to bug 228139, rpc definition of unicode strings allow
    // for odd lengths. We will set them to even (1 less) so that we
    // don't av in the lsa.

    if (ARGUMENT_PRESENT(UserName) && UserName->Buffer)
    {
        UserName->Length = (UserName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KdcGetTicketInfo(
                    UserName,
                    0,                  // no flags
                    NULL,
                    NULL,
                    &TicketInfo,
                    &ExtendedError, 
                    &UserHandle,
                    0L,                 // no fields to fetch
                    0L,                 // no extended fields
                    NULL,               // no user all
                    NULL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to get ticket info for %wZ: 0x%x\n",
                UserName, KerbErr ));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }


    //
    // If the caller asks us to replace keys, then clobber all supplemental
    // creds with the new ones. Otherwise, just replace the current ones
    // with the old ones
    //

    Passwords = TicketInfo.Passwords;

    if ((Flags & KERB_SET_KEYS_REPLACE) ||
        (Passwords == NULL))
    {
        KerbErr = KdcDuplicateCredentials(
                    &StoredCreds,
                    &StoredCredSize,
                    Keys,
                    TRUE                // marshall
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }
    else
    {

        if (Keys->OldCredentialCount != 0)
        {
            DebugLog((DEB_ERROR,"OldCredentialCount supplied with merge-in keys - illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        //
        // Calculate the size of the stored creds.
        //

        StoredCredSize = FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials) +
                            Keys->CredentialCount * sizeof(KERB_KEY_DATA) +
                            Keys->DefaultSalt.Length;

        for (Index = 0; Index < Keys->CredentialCount; Index++ )
        {
            StoredCredSize += Keys->Credentials[Index].Salt.Length +
                                Keys->Credentials[Index].Key.keyvalue.length;
            CredentialCount++;
        }

        //
        // Add in the keys that aren't in the supplied ones
        //

        if (Keys->DefaultSalt.Buffer == NULL)
        {
            StoredCredSize += Passwords->DefaultSalt.Length;
        }

        //
        // Add the size for all the keys in the passwords that weren't
        // in the passed in keys
        //

        for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
        {
            if (KerbGetKeyFromList(Keys, Passwords->Credentials[Index].Key.keytype) == NULL)
            {
                //
                // Make sure it is not a builtin
                //

                if ((Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_LM) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_MD4) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_NULL))
                {
                    continue;
                }
                StoredCredSize += Passwords->Credentials[Index].Salt.Length
                                + Passwords->Credentials[Index].Key.keyvalue.length
                                + sizeof(KERB_KEY_DATA);
                CredentialCount++;
            }
        }


        //
        // Add in the old keys
        //

        for (Index = 0; Index < Passwords->OldCredentialCount; Index++ )
        {
            StoredCredSize += sizeof(KERB_KEY_DATA) +
                        Passwords->Credentials[Index + Passwords->OldCredentialCount].Salt.Length +
                        Passwords->Credentials[Index + Passwords->OldCredentialCount].Key.keyvalue.length;
        }

        //
        // Allocate a new buffer to contain the marshalled keys
        //

        StoredCreds = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(StoredCredSize);
        if (StoredCreds == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory(
            StoredCreds,
            StoredCredSize
            );
        //
        // Set the standard bits
        //

        StoredCreds->Revision = KERB_PRIMARY_CRED_REVISION;
        StoredCreds->Flags = 0;

        Offset = (LONG_PTR) StoredCreds;
        Where = (PBYTE) &(StoredCreds->Credentials[CredentialCount + Passwords->OldCredentialCount]);

        //
        // Copy in the default salt.
        //

        if (Keys->DefaultSalt.Buffer != NULL)
        {
            DefaultSalt = Keys->DefaultSalt;
        }
        else
        {
            DefaultSalt = Passwords->DefaultSalt;
        }
        if (DefaultSalt.Buffer != NULL)
        {
            StoredCreds->DefaultSalt.Length =
                StoredCreds->DefaultSalt.MaximumLength =  DefaultSalt.Length;
            StoredCreds->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
            RtlCopyMemory(
                Where,
                DefaultSalt.Buffer,
                DefaultSalt.Length
                );
            Where += DefaultSalt.Length;
        }

        //
        // Copy in all the new keys
        //


        for (Index = 0; Index < Keys->CredentialCount ; Index++ )
        {
            KdcCopyKeyData(
                &StoredCreds->Credentials[CredentialIndex],
                &Keys->Credentials[Index],
                &Where,
                Offset
                );
            CredentialIndex++;

        }

        //
        // Copy in the existing keys
        //

        for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
        {
            if (KerbGetKeyFromList(Keys, Passwords->Credentials[Index].Key.keytype) == NULL)
            {
                if ((Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_LM) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_MD4) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_NULL))
                {
                    continue;
                }

                KdcCopyKeyData(
                    &StoredCreds->Credentials[CredentialIndex],
                    &Passwords->Credentials[Index],
                    &Where,
                    Offset
                    );
                CredentialIndex++;
            }
        }
        StoredCreds->CredentialCount = (USHORT) CredentialIndex;

        //
        // Copy in the old keys from the existing keys
        //

        for (Index = 0; Index < Passwords->OldCredentialCount; Index++ )
        {
            KdcCopyKeyData(
                &StoredCreds->Credentials[CredentialIndex],
                &Passwords->Credentials[Index + Passwords->OldCredentialCount],
                &Where,
                Offset
                );
            CredentialIndex++;
        }

        StoredCreds->OldCredentialCount = Passwords->OldCredentialCount;


    }

    RtlInitUnicodeString(
        &Credentials.PackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    Credentials.Credentials = (PBYTE) StoredCreds;
    Credentials.CredentialSize = StoredCredSize;
    Status = SamIStorePrimaryCredentials(
                UserHandle,
                &Credentials
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to store primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }

Cleanup:
    FreeTicketInfo(&TicketInfo);

    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }
    if (StoredCreds != NULL)
    {
        MIDL_user_free(StoredCreds);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\dgutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        dgutil.cxx
//
// Contents:    Server support routines for datagram sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "sockutil.h"
extern "C"
{
#include <atq.h>
#include <nlrepl.h>
}
#include <issched.hxx>
#include "fileno.h"
#define FILENO FILENO_DGUTIL

#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      5
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
#define KDC_CONTEXT_TIMEOUT             50

extern BOOLEAN KdcSocketsInitialized;

typedef struct _KDC_DATAGRAM_ENDPOINT {
    SOCKADDR LocalAddress;
    PKDC_GET_TICKET_ROUTINE EndpointFunction;
    PVOID Endpoint;
} KDC_DATAGRAM_ENDPOINT, *PKDC_DATAGRAM_ENDPOINT;

PKDC_DATAGRAM_ENDPOINT DatagramEndpoints = NULL;
ULONG DatagramEndpointCount = 0;
RTL_CRITICAL_SECTION DatagramEndpointLock;

SOCKET KdcWinsockPnpSocket = INVALID_SOCKET;
HANDLE KdcWinsockPnpEvent = NULL;
HANDLE KdcPnpEventChangeHandle = NULL;



//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDgIoCompletion
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqDgIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{

    PVOID Buffer;
    SOCKADDR * RemoteAddress = NULL;
    INT AddressSize;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    ULONG_PTR KdcContext;
    WSABUF SocketBuffer;
    PKDC_DATAGRAM_ENDPOINT Endpoint;

    TRACE(KDC,KdcAtqDgIoCompletion, DEB_FUNCTION);

    if (Context == NULL)
    {
        return;
    }

    KdcContext = AtqContextGetInfo(
                    AtqContext,
                    ATQ_INFO_COMPLETION_CONTEXT
                    );

    //
    // If the context is 1, then this is the completion from a write, so close
    // this down.
    //

    if (KdcContext == 1)
    {
        lpo = NULL;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }


    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK,"IoCompletion: CompletionStatus = 0x%x\n",CompletionStatus));
        D_DebugLog((DEB_T_SOCK,"IoCompletion: lpo = %p\n",lpo));
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",AtqContext));

        if (CompletionStatus == ERROR_OPERATION_ABORTED)
        {
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, FALSE );
        }
        else
        {
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        }

        return;
    }

    AtqGetDatagramAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &Endpoint,
        &RemoteAddress,
        &AddressSize
        );

    //
    // If the remote address is port 88, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((AddressSize >= sizeof(SOCKADDR_IN) &&
        ((((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KPASSWD_PORT))))
    {
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        return;
    }




    //fester
    D_DebugLog((DEB_T_SOCK, "Bytes written - %x\n", BytesWritten));

    //
    // There is a buffer, so use it to do the KDC thang.
    //

    InputMessage.BufferSize = BytesWritten;
    InputMessage.Buffer = (PUCHAR) Buffer;
    OutputMessage.Buffer = NULL;

    
    //
    // This assert is here to help locate bug 154963.
    // If it fires, contact Todds
    //
    DsysAssert(DatagramEndpointCount != 0);


    Endpoint->EndpointFunction(
        NULL,           // no atq context for retries
        RemoteAddress,
        &Endpoint->LocalAddress,
        &InputMessage,
        &OutputMessage
        );

    //
    // If there is a response, write it back to the sender.
    //

    if (OutputMessage.Buffer != NULL)
    {
        DsysAssert(OutputMessage.BufferSize < KDC_MAX_ACCEPT_BUFFER);

        RtlCopyMemory(
            Buffer,
            OutputMessage.Buffer,
            OutputMessage.BufferSize
            );

        KdcFreeEncodedData(OutputMessage.Buffer);

        SocketBuffer.buf = (char *) Buffer;
        SocketBuffer.len = OutputMessage.BufferSize;

        AtqContextSetInfo(
            AtqContext,
            ATQ_INFO_COMPLETION_CONTEXT,
            1       
            );

        AtqWriteDatagramSocket(
            (PATQ_CONTEXT) AtqContext,
            &SocketBuffer,
            1,              // 1 buffer
            NULL            // no OVERLAPPED
            );
    }
    else
    {
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcCreateDgAtqEndpoint
//
//  Synopsis:   Sets up a datagram endpoint
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcCreateDgAtqEndpoint(
    IN USHORT Port,
    IN PVOID EndpointContext,
    IN ULONG IpAddress,
    OUT PVOID * Endpoint
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    SOCKET EndpointSocket = INVALID_SOCKET;
    int RecvBufSize;

    //
    // Create the endpoint config
    //

    EndpointConfig.ListenPort = Port;
    EndpointConfig.IpAddress = IpAddress;
    EndpointConfig.cbAcceptExRecvBuffer = KDC_MAX_ACCEPT_BUFFER;
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = KDC_ACCEPT_TIMEOUT;

    EndpointConfig.pfnConnect = NULL;
    EndpointConfig.pfnConnectEx = KdcAtqDgIoCompletion;
    EndpointConfig.pfnIoCompletion = KdcAtqDgIoCompletion;

    EndpointConfig.fDatagram = TRUE;
    EndpointConfig.fLockDownPort = TRUE;

    EndpointConfig.fReverseQueuing = FALSE;
    EndpointConfig.cbDatagramWSBufSize = 0;  // means use the default.

    *Endpoint = AtqCreateEndpoint(
                    &EndpointConfig,
                    EndpointContext
                    );
    if (*Endpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Get the socket so we can change the recieve buffer size
    //

    EndpointSocket = (SOCKET) AtqEndpointGetInfo(
                                *Endpoint,
                                EndpointInfoListenSocket
                                );


    RecvBufSize = 0x8000;       // 32 k buffers
    if (setsockopt(
            EndpointSocket,
            SOL_SOCKET,
            SO_RCVBUF,
            (const char *) &RecvBufSize,
            sizeof(int)
            ))
    {
        DebugLog((DEB_ERROR,"Failed to set recv buf size to 32k: 0x%x, %d\n",
        WSAGetLastError(),WSAGetLastError()));
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(*Endpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetAddressListFromWinsock
//
//  Synopsis:   gets the list of addresses from a winsock ioctl
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcGetAddressListFromWinsock(
    OUT LPSOCKET_ADDRESS_LIST * SocketAddressList
    )
{
    ULONG BytesReturned = 150;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    INT i,j;
    ULONG NetStatus = STATUS_SUCCESS;

    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( AddressList != NULL ) {
            MIDL_user_free( AddressList );
        }

        AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate( BytesReturned );

        if ( AddressList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( KdcWinsockPnpSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) AddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            DebugLog((DEB_ERROR,"LdapUdpPnpBind: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld\n",
                      NetStatus, BytesReturned));
            goto Cleanup;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i = 0, j = 0; i < AddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        AddressList->Address[j] = AddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &AddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        } else {

            //
            // Otherwise keep it.
            //

            j++;
        }
    }
    AddressList->iAddressCount = j;
    *SocketAddressList = AddressList;
    AddressList = NULL;
Cleanup:
    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }
    if (NetStatus != ERROR_SUCCESS)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    else
    {
        return(STATUS_SUCCESS);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAddressesWorker
//
//  Synopsis:   Updates the IP addresses used for datagram sockest by
//              stopping the endpoints and then starting them with the
//              new addresses
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KdcUpdateAddressesWorker(
    IN PVOID IgnoredParameter
    )
{
    ULONG Index;
    INT IntIndex;
    ULONG EndpointIndex = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    DWORD NetStatus;
    DWORD BytesReturned ;

    RtlEnterCriticalSection(&DatagramEndpointLock);

    D_DebugLog(( DEB_TRACE, "KdcUpdateAddressesWorker\n" ));

    //
    // Tell winsock we want address list changes on this socket:
    //
    if ( KdcWinsockPnpSocket != INVALID_SOCKET )
    {
        NetStatus = WSAIoctl(
                        KdcWinsockPnpSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL,
                        NULL );

        if ( NetStatus != 0 )
        {
            NetStatus = WSAGetLastError();
            if ( NetStatus != WSAEWOULDBLOCK )
            {
                DebugLog((DEB_ERROR,"WSASocket failed with %ld\n", NetStatus ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }
        }
    }
    //
    // Cleanup any old endpoints
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
            }
        }
        MIDL_user_free(DatagramEndpoints);
        DatagramEndpoints = NULL;
        DatagramEndpointCount = 0;
    }

    //
    // Get the list of socket addresses
    //

    Status = KdcGetAddressListFromWinsock(
                &AddressList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Create new endpoints
    //

    DatagramEndpoints = (PKDC_DATAGRAM_ENDPOINT) MIDL_user_allocate(
                            sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
                            );
    if (DatagramEndpoints == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(
        DatagramEndpoints,
        sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
        );

    //
    // Create an endpoint for the KDC and for KPASSWD for each transport
    //


    for (IntIndex = 0; IntIndex < AddressList->iAddressCount ; IntIndex++ )
    {
        RtlCopyMemory(
            &DatagramEndpoints[EndpointIndex].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[EndpointIndex].EndpointFunction = KdcGetTicket;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KDC_PORT,
                    &DatagramEndpoints[EndpointIndex],
                    ((PSOCKADDR_IN) &DatagramEndpoints[EndpointIndex].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[EndpointIndex].Endpoint
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        EndpointIndex++;

        //
        // Create the KPASSWD endpoint
        //

        RtlCopyMemory(
            &DatagramEndpoints[EndpointIndex].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[EndpointIndex].EndpointFunction = KdcChangePassword;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KPASSWD_PORT,
                    &DatagramEndpoints[EndpointIndex],
                    ((PSOCKADDR_IN) &DatagramEndpoints[EndpointIndex].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[EndpointIndex].Endpoint
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        EndpointIndex++;

    }

    DatagramEndpointCount = EndpointIndex;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (DatagramEndpoints != NULL)
        {
            for (Index = 0; Index < EndpointIndex ; Index++ )
            {
                if (DatagramEndpoints[Index].Endpoint != NULL)
                {
                    (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                    (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
                }
            }
            MIDL_user_free(DatagramEndpoints);
            DatagramEndpoints = NULL;
            DatagramEndpointCount = 0;
        }

    }

    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }
    RtlLeaveCriticalSection(&DatagramEndpointLock);
    return((ULONG) Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD NetStatus;
    PATQ_CONTEXT EndpointContext = NULL;
    DWORD BytesReturned ;


    TRACE(KDC,KdcDatagramInitializeSockets, DEB_FUNCTION);


    Status = RtlInitializeCriticalSection(&DatagramEndpointLock);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the asynchronous thread queue.
    
    //

    if (!AtqInitialize(0))
    {
        DebugLog((DEB_ERROR,"Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //

    KdcWinsockPnpSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( KdcWinsockPnpSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"WSASocket failed with %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // Open an event to wait on.
    //

    KdcWinsockPnpEvent = CreateEvent(
                                  NULL,     // No security ettibutes
                                  FALSE,    // Auto reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( KdcWinsockPnpEvent == NULL ) {
        NetStatus = GetLastError();
        DebugLog((DEB_ERROR,"Cannot create Winsock PNP event %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Associate the event with new addresses becoming available on the socket.
    //

    NetStatus = WSAEventSelect( KdcWinsockPnpSocket, KdcWinsockPnpEvent, FD_ADDRESS_LIST_CHANGE );

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"Can't WSAEventSelect %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    Status = (NTSTATUS) KdcUpdateAddressesWorker( NULL );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to udpate datagram addresses\n"));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening\n"));


    if ( KdcPnpEventChangeHandle == NULL ) {

        KdcPnpEventChangeHandle = LsaIRegisterNotification(
                                    KdcUpdateAddressesWorker,
                                    NULL,               // no parameter,
                                    NOTIFIER_TYPE_HANDLE_WAIT,
                                    0,                  // no class
                                    0,                  // no flags
                                    0,                  // no interval
                                    KdcWinsockPnpEvent
                                    );
        if (KdcPnpEventChangeHandle == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to register KDC pnp event change handle.\n"));
        }
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KdcShutdownSockets();
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownDatagramSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    )
{
    PKDC_ATQ_CONTEXT Context;
    PLIST_ENTRY ListEntry;
    ULONG Index;

    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);

    RtlEnterCriticalSection(&DatagramEndpointLock);


    if ( KdcPnpEventChangeHandle != NULL ) {
        LsaICancelNotification(KdcPnpEventChangeHandle);
        KdcPnpEventChangeHandle = NULL;
    }

    if ( KdcWinsockPnpEvent != NULL ) {
        CloseHandle(KdcWinsockPnpEvent);
        KdcWinsockPnpEvent = NULL;
    }

    if ( KdcWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket(KdcWinsockPnpSocket);
        KdcWinsockPnpSocket = INVALID_SOCKET;
    }

    //
    // Go through the list of contexts and close them all.
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
            }
        }
        MIDL_user_free(DatagramEndpoints);
        DatagramEndpoints = NULL;
        DatagramEndpointCount = 0;
    }

    if (!AtqTerminate())
    {
        DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
    }

    RtlLeaveCriticalSection(&DatagramEndpointLock);
    RtlDeleteCriticalSection(&DatagramEndpointLock);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\getas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       getas.cxx
//
//  Contents:   GetASTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdctrace.h"
#include "krb5p.h"
#include <userall.h>
                                                      
#include "fileno.h"
#define FILENO FILENO_GETAS


LARGE_INTEGER tsInfinity = {0xffffffff,0x7fffffff};
LONG lInfinity = 0x7fffffff;

enum {
    SubAuthUnknown,
    SubAuthNoFilter,
    SubAuthYesFilter
} KdcSubAuthFilterPresent = SubAuthUnknown;

extern "C"
NTSTATUS NTAPI
Msv1_0ExportSubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN ULONG DllNumber,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

extern "C"
BOOLEAN NTAPI
Msv1_0SubAuthenticationPresent(
    IN ULONG DllNumber
    );

ULONG
NetpDcElapsedTime(
    IN ULONG StartTime
)
/*++

Routine Description:

    Returns the time (in milliseconds) that has elapsed is StartTime.

Arguments:

    StartTime - A time stamp from GetTickCount()

Return Value:

    Returns the time (in milliseconds) that has elapsed is StartTime.

--*/
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcForwardLogonToPDC
//
//  Synopsis:   Forwards a failed-password logon to the PDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcForwardLogonToPDC(
    IN PKERB_MESSAGE_BUFFER InputMessage,
    IN PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    BOOLEAN CalledPDC;
    KERB_MESSAGE_BUFFER Reply = {0};
    DOMAIN_SERVER_ROLE ServerRole;

    Status = SamIQueryServerRole(
                GlobalAccountDomainHandle,
                &ServerRole
                );

    if (!KdcGlobalAvoidPdcOnWan && 
        NT_SUCCESS(Status) && 
        (ServerRole == DomainServerRoleBackup))
    {
        Status = KerbMakeKdcCall(
                    SecData.KdcDnsRealmName(),
                    NULL,                           // no account name
                    TRUE,                           // call the PDC
                    TRUE,                           // use TCP/IP, not UDP
                    InputMessage,
                    &Reply,
                    0, // no additional flags
                    &CalledPDC
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        else
        {
            OutputMessage->Buffer = (PBYTE) MIDL_user_allocate(Reply.BufferSize);
            if (OutputMessage->Buffer != NULL)
            {
                OutputMessage->BufferSize = Reply.BufferSize;

                RtlCopyMemory(
                    OutputMessage->Buffer,
                    Reply.Buffer,
                    OutputMessage->BufferSize
                    );
            }
            else
            {
                KerbErr = KRB_ERR_GENERIC;
            }
            KerbFree(Reply.Buffer);
        }
    }
    else
    {
        KerbErr = KRB_ERR_GENERIC;
    }
    return(KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcAsRep
//
//  Synopsis:   Verifies that our AS_REP came from a KDC, as opposed to a malicious 
//              attacker by evaluating the TGT embedded in response
//
//  Arguments:  Reply   PKERB_KDC_REPLY
//
//  Returns:    Boolean to client.
//
//  History:    12-June-2000   Todds   Created
//
//----------------------------------------------------------------------------
BOOLEAN 
KdcVerifyKdcAsRep(
   PKERB_KDC_REPLY Reply,
   PKERB_PRINCIPAL_NAME RequestBodyClientName
   )
{

   BOOLEAN                 fRet = FALSE; 
   KERBERR                 KerbErr;
   KERB_EXT_ERROR          ExtendedError;
   KDC_TICKET_INFO         KrbtgtTicketInfo = {0};
   UNICODE_STRING          ServerNames[3];
   UNICODE_STRING          ClientName;
   ULONG                   NameType;
   PKERB_ENCRYPTION_KEY    EncryptionKey = NULL;
   PKERB_ENCRYPTED_TICKET  DecryptedTicket = NULL;
   KERB_REALM              LocalRealm;
   PKERB_INTERNAL_NAME     ReplyClientName = NULL;
   PKERB_INTERNAL_NAME     TicketClientName = NULL;


   // Get the server key for krbtgt
   KerbErr = SecData.GetKrbtgtTicketInfo(&KrbtgtTicketInfo);
   
   if (!KERB_SUCCESS(KerbErr))
   {
      D_DebugLog((DEB_WARN, "SecData.Getkrbtgtticketinfo failed!\n"));
      goto Cleanup;
   }

   ServerNames[0] = *SecData.KdcFullServiceKdcName();
   ServerNames[1] = *SecData.KdcFullServiceDnsName();
   ServerNames[2] = *SecData.KdcFullServiceName();
   
   LocalRealm = SecData.KdcKerbDnsRealmName();
   //
   // Verify the realm of the ticket
   //
   if (!KerbCompareRealmNames(
         &LocalRealm,
         &Reply->ticket.realm
         ))
   {
      D_DebugLog((DEB_ERROR,"KLIN(%x) Tgt reply is not for our realm: %s instead of %s\n",
                KLIN(FILENO, __LINE__), Reply->ticket.realm, LocalRealm));
      KerbErr = KRB_AP_ERR_NOT_US;
      goto Cleanup;
   }   

   EncryptionKey = KerbGetKeyFromList(
                     KrbtgtTicketInfo.Passwords,
                     Reply->ticket.encrypted_part.encryption_type
                     );

   if (EncryptionKey == NULL)
   {
      D_DebugLog((DEB_ERROR, "Couldn't get key for decrypting krbtgt\n"));
      KerbErr = KRB_AP_ERR_NOKEY;
      goto Cleanup;
   }

   KerbErr = KerbVerifyTicket(
               &Reply->ticket,
               3,                              // 3 names
               ServerNames,
               SecData.KdcDnsRealmName(),
               EncryptionKey,
               &SkewTime,
               &DecryptedTicket
               );

   if (!KERB_SUCCESS(KerbErr))
   {
      D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to verify ticket - %x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
      goto Cleanup;
   }                    

   //
   // Verify the realm of the client is the same as our realm
   //
   if (!KerbCompareRealmNames(
         &LocalRealm,
         &DecryptedTicket->client_realm
         ))
   {
      D_DebugLog((DEB_ERROR,"KLIN(%x) Verified ticket client realm is wrong: %s instead of %s\n",
                KLIN(FILENO, __LINE__),DecryptedTicket->client_realm, LocalRealm));
      KerbErr = KRB_AP_ERR_NOT_US;
      goto Cleanup;
   }

   //
   // Verify the client name in the ticket matches the request body, and
   // reply body.
   //
   if (!KerbComparePrincipalNames(
            &DecryptedTicket->client_name,
            RequestBodyClientName
            ) ||
       !KerbComparePrincipalNames(
            &Reply->client_name,
            RequestBodyClientName
            ))
   {
      D_DebugLog((DEB_ERROR, "KLIN(%x) Client name AS_REP from PDC doesn't match request\n",
                KLIN(FILENO,__LINE__)));
      KerbErr = KRB_AP_ERR_MODIFIED;
      goto Cleanup;                                                                                       
   }                                                                                                      

   fRet = TRUE; 

Cleanup:

   if (DecryptedTicket != NULL)
   {
       KerbFreeTicket(DecryptedTicket);
   }            

   if (!fRet)
   {               
      ClientName.Buffer = NULL;
      KerbConvertPrincipalNameToString(
            &ClientName,
            &NameType,
            RequestBodyClientName
            ); 
      
      ReportServiceEvent(
             EVENTLOG_ERROR_TYPE,
             KDCEVENT_INVALID_FORWARDED_AS_REQ,
             sizeof(ULONG),                              
             &KerbErr,
             1,                              // number of strings
             ClientName.Buffer
             );
      
      if (ClientName.Buffer != NULL)
      {
         MIDL_user_free(ClientName.Buffer);
      }            
   }

   return fRet;                                                                                        
}
   


//+---------------------------------------------------------------------------
//
//  Function:   FailedLogon
//
//  Synopsis:   Processes a failed logon.
//
//  Effects:    May raise an exception, audit, event, lockout, etc.
//
//  Arguments:  [UserHandle] -- [in] Client who didn't log on.
//              [ClientAddress] -- Address of client making request
//              [Client] -- [in optional] Sid of the client requesting logon
//              [ClientSize] -- [in] Length of the sid
//              [Reason] -- [in] the reason this logon failed.
//
//  Requires:
//
//  Returns:    HRESULT to return to client.
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      This usually returns hrReason, but it may map it to
//              something else.
//
//----------------------------------------------------------------------------

KERBERR
FailedLogon( IN  SAMPR_HANDLE UserHandle,
             IN  OPTIONAL PSOCKADDR ClientAddress,
             IN  PKERB_PRINCIPAL_NAME RequestBodyClientName,
             IN  OPTIONAL UCHAR *Client,
             IN  ULONG ClientSize,
             IN  PKERB_MESSAGE_BUFFER InputMessage,
             IN  PKERB_MESSAGE_BUFFER OutputMessage,
             IN  PUNICODE_STRING ClientNetbiosAddress,
             IN  KERBERR Reason )
{
    NTSTATUS Status;
    SAM_LOGON_STATISTICS LogonStats;
    LARGE_INTEGER CurrentTime;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_KDC_REPLY Reply = NULL;

    TRACE(KDC, FailedLogon, DEB_FUNCTION);


    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    //
    // It's important to know why the logon can fail.  For each possible
    // reason, decide if that is a reason to lock out the account.
    //

    //
    // Check to see if we've seen this request before recently
    //

    if (KDC_ERR_NONE == FailedRequests->Check(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            NULL,
                            0,
                            &CurrentTime,
                            TRUE))
    {
        KERBERR KerbErr;
        KERBERR ForwardKerbErr;
        //
        // If the password was bad then we want to update the sam information
        //

        if (Reason == KDC_ERR_PREAUTH_FAILED)
        {

            RtlZeroMemory(&LogonStats, sizeof(LogonStats));
            LogonStats.StatisticsToApply =
                USER_LOGON_BAD_PASSWORD | USER_LOGON_BAD_PASSWORD_WKSTA | USER_LOGON_TYPE_KERBEROS;
            LogonStats.Workstation = *ClientNetbiosAddress;
            if ( (ClientAddress == NULL)
              || (ClientAddress->sa_family == AF_INET) ) {
                // Set to local address (known to be 4 bytes) or IP address
                LogonStats.ClientInfo.Type = SamClientIpAddr;
                LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
            }
            Status = SamIUpdateLogonStatistics(
                        UserHandle,
                        &LogonStats
                        );

            if ((NULL == Client) || (0 == ClientSize) ||
                (KDC_ERR_NONE == FailedRequests->Check(
                                    Client,
                                    ClientSize,
                                    ClientNetbiosAddress->Buffer,
                                    ClientNetbiosAddress->Length,
                                    &CurrentTime,
                                    FALSE)))
            {
                    //
                    // Pass this request to the KDC
                    //

                    KerbErr = KdcForwardLogonToPDC(
                                InputMessage,
                                OutputMessage
                                );

                    //
                    // Return an better error if it wasn't generic.
                    //

                    if (KERB_SUCCESS(KerbErr))
                    {  
                       ForwardKerbErr =  KerbUnpackKerbError(
                                                OutputMessage->Buffer,
                                                OutputMessage->BufferSize,
                                                &ErrorMessage
                                                );

                        if (KERB_SUCCESS(ForwardKerbErr))
                        {
                           if (ErrorMessage->error_code == KDC_ERR_PREAUTH_FAILED)
                           {
                              FailedRequests->Check(
                                                Client,
                                                ClientSize,
                                                ClientNetbiosAddress->Buffer,
                                                ClientNetbiosAddress->Length,
                                                &CurrentTime,
                                                TRUE
                                                );
                           }

                        } else {
                           
                           //   
                           // This may have been a successful, forwarded AS_REQ.  If so,
                           // reset bad password count on this BDC...
                           //
                           ForwardKerbErr = KerbUnpackAsReply(
                                             OutputMessage->Buffer,
                                             OutputMessage->BufferSize,
                                             &Reply
                                             );                                 
                           
                           if (KERB_SUCCESS(ForwardKerbErr) &&  KdcVerifyKdcAsRep(
                                                                              Reply,
                                                                              RequestBodyClientName
                                                                              ))
                           {  

                              RtlZeroMemory(&LogonStats, sizeof(LogonStats));
                              LogonStats.StatisticsToApply = 
                                 USER_LOGON_INTER_SUCCESS_LOGON | USER_LOGON_TYPE_KERBEROS;
                              if ( (ClientAddress == NULL)
                                || (ClientAddress->sa_family == AF_INET) ) {
                                    // Set to local address (known to be 4 bytes) or IP address
                                    LogonStats.ClientInfo.Type = SamClientIpAddr;
                                    LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
                              }
                              Status = SamIUpdateLogonStatistics(
                                          UserHandle,
                                          &LogonStats
                                          ); 
                              
                              if (!NT_SUCCESS(Status))
                              {
                                 D_DebugLog((DEB_ERROR,"Could not reset user bad pwd count - %x\n", Status));
                              }  

                           } else {
                              DebugLog((DEB_ERROR, "Got reply from fwd'd request to PDC, but wasn't valid!\n"));
                           }
                        }
                    }
                    else
                    {
                        if (KerbErr != KRB_ERR_GENERIC)
                        {
                            Reason = KerbErr;
                            goto Cleanup;
                        }
                    }
            }

        }
    }
Cleanup:
    if (NULL != ErrorMessage)
    {
        KerbFreeKerbError(ErrorMessage);
    }

    if (NULL != Reply)
    {
       KerbFreeAsReply(Reply);
    }

    return(Reason);
}






//+---------------------------------------------------------------------------
//
//  Function:   KdcHandleNoLogonServers
//
//  Synopsis:   If a password has verified, and we've got no GCs against which
//              to validate logon restrictions, then go ahead and set the 
//              sam info level to include the new USER_LOGON_NO_LOGON_SERVERS 
//              flag
//
//  Effects:    
//
//  Arguments:  [UserHandle] -- Client who logged on.
//              [ClientAddress] -- Address of client making request
//
//
//  Algorithm:
//
//  History:    24-Aug-2000   Todds   Created
//
//  Notes:      On successful logon w/ no GC, update SAM user flag
//
//----------------------------------------------------------------------------
KERBERR    
KdcHandleNoLogonServers(
   SAMPR_HANDLE UserHandle,
   PSOCKADDR ClientAddress  OPTIONAL
   )
{      
    SAM_LOGON_STATISTICS LogonStats;
    
    TRACE(KDC, KdcHandleNoLogonServers, DEB_FUNCTION);

    RtlZeroMemory(&LogonStats, sizeof(LogonStats));
    LogonStats.StatisticsToApply =  
        USER_LOGON_NO_LOGON_SERVERS | USER_LOGON_TYPE_KERBEROS;
    if ( (ClientAddress == NULL)
      || (ClientAddress->sa_family == AF_INET) ) {
        // Set to local address (known to be 4 bytes) or IP address
        LogonStats.ClientInfo.Type = SamClientIpAddr;
        LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
    }

    (VOID) SamIUpdateLogonStatistics(
            UserHandle,
            &LogonStats
            );

    return(KDC_ERR_NONE);
}

//+---------------------------------------------------------------------------
//
//  Function:   SuccessfulLogon
//
//  Synopsis:   Processes a successful logon.
//
//  Effects:    May raise an event, create an audit, throw a party.
//
//  Arguments:  [UserHandle] -- Client who logged on.
//              [ClientAddress] -- Address of client making request
//
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      On successful logon, we discard the history of failed logons
//              (as far as lockout is concerned).
//
//----------------------------------------------------------------------------

KERBERR
SuccessfulLogon(
    IN SAMPR_HANDLE UserHandle,
    PSOCKADDR OPTIONAL ClientAddress,
    IN PKERB_MESSAGE_BUFFER Request,
    IN PUSER_INTERNAL6_INFORMATION UserInfo
    )
{
    SAM_LOGON_STATISTICS LogonStats;
    KERB_MESSAGE_BUFFER Reply = {0};
    NTSTATUS   Status = STATUS_UNKNOWN_REVISION;

    TRACE(KDC, SuccessfulLogon, DEB_FUNCTION);

    RtlZeroMemory(&LogonStats, sizeof(LogonStats));
    LogonStats.StatisticsToApply =
        USER_LOGON_INTER_SUCCESS_LOGON | USER_LOGON_TYPE_KERBEROS;

    if ( (ClientAddress == NULL)
      || (ClientAddress->sa_family == AF_INET) ) {
        // Set to local address (known to be 4 bytes) or IP address
        LogonStats.ClientInfo.Type = SamClientIpAddr;
        LogonStats.ClientInfo.Data.IpAddr =  *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
    }

    (VOID) SamIUpdateLogonStatistics(
                UserHandle,
                &LogonStats
                );

    //
    // if this logon reset the bad password count, notify the PDC
    //

    if (UserInfo->I1.BadPasswordCount != 0)
    {
       Status = SamIResetBadPwdCountOnPdc(UserHandle);

       if (!NT_SUCCESS(Status))
       {
          if (Status == STATUS_UNKNOWN_REVISION)
          {
             D_DebugLog((DEB_ERROR, "SamIResetBadPwdCount not implemented on pdc.\n"));

             // W2k behavior, in case we have an old PDC
             (VOID) KdcForwardLogonToPDC(
                         Request,
                         &Reply
                         );

             if (Reply.Buffer != NULL)
             {
                MIDL_user_free(Reply.Buffer);
             }
          }
          else
          {
             D_DebugLog((DEB_ERROR, "SamIResetBadPwdCount failed - %x.\n", Status));
          }
       }
    }

    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsSubAuthFilterPresent
//
//  Synopsis:   Figures out whether the MSV1_0 subauthentication filter is present
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE or FALSE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
IsSubAuthFilterPresent()
{
    if ( KdcSubAuthFilterPresent == SubAuthUnknown ) {

        if ( Msv1_0SubAuthenticationPresent( KERB_SUBAUTHENTICATION_FLAG )) {

            KdcSubAuthFilterPresent = SubAuthYesFilter;

        } else {

            KdcSubAuthFilterPresent = SubAuthNoFilter;
        }
    }

    if ( KdcSubAuthFilterPresent == SubAuthNoFilter ) {

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCallSubAuthRoutine
//
//  Synopsis:   Calls the MSV1_0 subauthentication filter, if it is present
//
//  Effects:    If the filter returns an error, returns that error
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCallSubAuthRoutine(
    IN PKDC_TICKET_INFO TicketInfo,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PUNICODE_STRING ClientNetbiosAddress,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    NETLOGON_INTERACTIVE_INFO LogonInfo = {0};
    //
    // Subauth parameters
    //
    ULONG WhichFields = 0;
    ULONG UserFlags = 0;
    BOOLEAN Authoritative = TRUE;
    LARGE_INTEGER KickoffTime;
    PUSER_ALL_INFORMATION UserAll = &UserInfo->I1;

    //
    // Check if Msv1_0 has a subauth filter loaded
    //

    if ( !IsSubAuthFilterPresent()) {

        return KDC_ERR_NONE;
    }

    LogonInfo.Identity.LogonDomainName = *SecData.KdcRealmName();
    LogonInfo.Identity.ParameterControl = 0; // this can be set to use a particular package
    LogonInfo.Identity.UserName = TicketInfo->AccountName;
    LogonInfo.Identity.Workstation = *ClientNetbiosAddress;

    //
    // Leave logon id field blank
    //

    if (UserAll->NtPassword.Length == NT_OWF_PASSWORD_LENGTH)
    {
        RtlCopyMemory(
            &LogonInfo.NtOwfPassword,
            UserAll->NtPassword.Buffer,
            NT_OWF_PASSWORD_LENGTH
            );
    }

    if (UserAll->LmPassword.Length == LM_OWF_PASSWORD_LENGTH)
    {
        RtlCopyMemory(
            &LogonInfo.LmOwfPassword,
            UserAll->LmPassword.Buffer,
            NT_OWF_PASSWORD_LENGTH
            );
    }

    //
    // Make sure logoff time is intialized to something interesting
    //

    *LogoffTime = KickoffTime = UserAll->AccountExpires;

    //
    // Make the call
    //

    Status = Msv1_0ExportSubAuthenticationRoutine(
                NetlogonInteractiveInformation,
                &LogonInfo,
                MSV1_0_PASSTHRU,
                KERB_SUBAUTHENTICATION_FLAG,
                UserAll,
                &WhichFields,
                &UserFlags,
                &Authoritative,
                LogoffTime,
                &KickoffTime
                );

    //
    // If the kickoff time is more restrictive, use it.
    //

    if (KickoffTime.QuadPart < LogoffTime->QuadPart)
    {
        LogoffTime->QuadPart = KickoffTime.QuadPart;
    }

    //
    // Map the error code
    //

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,
                  "(KLIN:%x) Subauth failed the logon: 0x%x\n",
                  KLIN(FILENO, __LINE__),
                  Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KDC_ERR_POLICY;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildEtypeInfo
//
//  Synopsis:   Builds a list of supported etypes & salts
//
//  Effects:
//
//  Arguments:  TicketInfo - client's ticket info
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    kerberr
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildEtypeInfo(
    IN PKDC_TICKET_INFO TicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PKERB_PA_DATA_LIST * OutputPreAuth
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    BOOLEAN FoundEtype = FALSE;
    ULONG Index;
    PKERB_ETYPE_INFO NextEntry = NULL;
    PKERB_ETYPE_INFO EtypeInfo = NULL;
    PKERB_PA_DATA_LIST OutputList = NULL;
    UNICODE_STRING TempSalt = {0};
    STRING TempString = {0};
    
    *OutputPreAuth = NULL;                                                                               
    //
    // Build the array of etypes, in reverse order because we are adding
    // to the front of the list
    //
    
    for ( Index = TicketInfo->Passwords->CredentialCount; Index > 0; Index-- )
    {
        //
        // Only return types that the client supports.
        //

        if (!KdcCheckForEtype(
                RequestBody->encryption_type,
                TicketInfo->Passwords->Credentials[Index-1].Key.keytype
                ))
        {
            continue;
        }
        FoundEtype = TRUE;
        NextEntry = (PKERB_ETYPE_INFO) MIDL_user_allocate(sizeof(KERB_ETYPE_INFO));
        if (NextEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        RtlZeroMemory(
            NextEntry,
            sizeof(KERB_ETYPE_INFO)
            );

        //
        // Copy in the etype
        //

        NextEntry->value.encryption_type =
            TicketInfo->Passwords->Credentials[Index-1].Key.keytype;

        //
        // add the salt - check the per-key salt and then the default salt.
        //

        if (TicketInfo->Passwords->Credentials[Index-1].Salt.Buffer != NULL)
        {
            TempSalt = TicketInfo->Passwords->Credentials[Index-1].Salt;
        }
        else if (TicketInfo->Passwords->DefaultSalt.Buffer != NULL)
        {
            TempSalt = TicketInfo->Passwords->DefaultSalt;
        }
        else
        {
            TempSalt.Buffer = NULL ;
            TempSalt.Length = 0 ;
            TempSalt.MaximumLength = 0 ;
        }

        //
        // If we have a salt, convert it to ansi & return it.
        //

        if (TempSalt.Buffer != NULL)
        {
            TempString.Buffer = NULL;
            TempString.Length = 0;
            TempString.MaximumLength = 0;

            KerbErr = KerbUnicodeStringToKerbString(
                        &TempString,
                        &TempSalt
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            NextEntry->value.bit_mask |= salt_present;
            NextEntry->value.salt.length = TempString.Length;
            NextEntry->value.salt.value = (PUCHAR) TempString.Buffer;
        }

        NextEntry->next = EtypeInfo;
        EtypeInfo = NextEntry;

    }
    
    //
    // If we can't find a matching etype, then we've got to return an error
    // to the client...  
    if (FoundEtype)
    {

       OutputList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
       if (OutputList == NULL)
          {
          KerbErr = KRB_ERR_GENERIC;
          goto Cleanup;
       }

       RtlZeroMemory(
          OutputList,
          sizeof(KERB_PA_DATA_LIST)
          );

       OutputList->value.preauth_data_type = KRB5_PADATA_ETYPE_INFO;
       OutputList->next = NULL;

       KerbErr = KerbPackData(
          &EtypeInfo,
          PKERB_ETYPE_INFO_PDU,
          (PULONG) &OutputList->value.preauth_data.length,
          &OutputList->value.preauth_data.value
          );

       if (!KERB_SUCCESS(KerbErr))
          {
          goto Cleanup;
       }

       *OutputPreAuth = OutputList;
       OutputList = NULL;

    } 
    else // did not find etype from request that we support, warn the admin
    {
       KerbErr = KDC_ERR_ETYPE_NOTSUPP;
       DebugLog((DEB_ERROR,"There is no union between client and server Etypes!\n")); 

       KdcReportKeyError(
           &(TicketInfo->AccountName),
           NULL,
           KDCEVENT_NO_KEY_UNION_AS,
           RequestBody->encryption_type,                               
           TicketInfo->Passwords
           );

    }
    

Cleanup:

    //
    // Cleanup the etype list, as it is returned in marshalled form.
    //

    while (EtypeInfo != NULL)
    {
        NextEntry = EtypeInfo->next;
        if (EtypeInfo->value.salt.value != NULL)
        {

            TempString.Buffer = (PCHAR) EtypeInfo->value.salt.value;
            TempString.Length = (USHORT) EtypeInfo->value.salt.length;
            KerbFreeString((PUNICODE_STRING) &TempString);
        }

        MIDL_user_free(EtypeInfo);
        EtypeInfo = NextEntry;
    }
    if (OutputList != NULL)
    {
        KerbFreePreAuthData( OutputList);
    }

    return KerbErr;
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPreauthTypeList
//
//  Synopsis:   For returning with a PREAUTH-REQUIRED message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPreauthTypeList(
    OUT PKERB_PA_DATA_LIST *  PreauthTypeList
    )
{
    PKERB_PA_DATA_LIST DataList = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Allocate and fill in the first item
    //

    DataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    DataList->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;

    //
    // Even if we fail the allocation, we can still return this value.
    //

    *PreauthTypeList = DataList;

    DataList->next = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList->next == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList->next,
        sizeof(KERB_PA_DATA_LIST)
        );
    DataList = DataList->next;

    DataList->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

Cleanup:

    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPwSalt
//
//  Synopsis:   builds the pw-salt pa data type
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPwSalt(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN PKERB_ENCRYPTION_KEY ReplyKey,
    IN OUT PKERB_PA_DATA_LIST * OutputPreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST DataList = NULL;
    PKERB_KEY_DATA KeyData = NULL;
    STRING Salt = {0};
    UNICODE_STRING SaltUsed = {0};
    ULONG Index;

    //
    // Find the key use for encryption.
    //

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) ReplyKey->keytype)
        {
            KeyData = &Passwords->Credentials[Index];
            break;
        }
    }

    if (KeyData == NULL)
    {
        goto Cleanup;
    }

    //
    // Locate the salt used
    //

    if (KeyData->Salt.Buffer != NULL)
    {
        SaltUsed = KeyData->Salt;
    }
    else if (Passwords->DefaultSalt.Buffer != NULL)
    {
        SaltUsed = Passwords->DefaultSalt;
    }

    //
    // Convert the salt to a kerb string
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &Salt,
                &SaltUsed
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Allocate and fill in the first item
    //

    DataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    DataList->value.preauth_data_type = KRB5_PADATA_PW_SALT;
    DataList->value.preauth_data.length = Salt.Length;
    DataList->value.preauth_data.value = (PUCHAR) Salt.Buffer;
    Salt.Buffer = NULL;

    DataList->next = *OutputPreAuthData;
    *OutputPreAuthData = DataList;
    DataList = NULL;
Cleanup:

    if (DataList != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST)DataList);
    }
    if (Salt.Buffer != NULL)
    {
        MIDL_user_free(Salt.Buffer);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyEncryptedTimeStamp
//
//  Synopsis:   Verifies an encrypted time stamp pre-auth data
//
//  Effects:
//
//  Arguments:  PreAuthData - preauth data from client
//              TicketInfo - client's ticket info
//              UserHandle - handle to client's account
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_FAILED - the password was bad
//              Other errors - preauth failed but shouldn't trigger lockout
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyEncryptedTimeStamp(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN PKDC_TICKET_INFO TicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN SAMPR_HANDLE UserHandle,
    OUT PKERB_PA_DATA_LIST * OutputPreAuth
    )
{
    KERBERR KerbErr;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    PKERB_ENCRYPTED_TIMESTAMP EncryptedTime = NULL;
    PKERB_ENCRYPTION_KEY UserKey = NULL;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ClientTime;

    if ((TicketInfo->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        goto Cleanup;
    }

    //
    // Unpack the pre-auth data into an encrypted data first.
    //

    KerbErr = KerbUnpackEncryptedData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                &EncryptedData
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now decrypt the encrypted data (in place)
    //

    UserKey = KerbGetKeyFromList(
                TicketInfo->Passwords,
                EncryptedData->encryption_type
                );

    if (UserKey == NULL)
    {

        // fakeit
        KERB_CRYPT_LIST FakeList;
        FakeList.next = NULL;
        FakeList.value = EncryptedData->encryption_type ;

        KdcReportKeyError(
            &(TicketInfo->AccountName),
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            &FakeList,
            TicketInfo->Passwords
            );

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = KerbDecryptDataEx(
                EncryptedData,
                UserKey,
                KERB_ENC_TIMESTAMP_SALT,
                (PULONG) &EncryptedData->cipher_text.length,
                EncryptedData->cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,
                  "KLIN(%x) Failed to decrypt timestamp pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__),
                  KerbErr));
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // unpack the decrypted data into a KERB_ENCRYPTED_TIMESTAMP
    //

    KerbErr = KerbUnpackData(
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                KERB_ENCRYPTED_TIMESTAMP_PDU,
                (PVOID *) &EncryptedTime
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to unpack preauth data to encrpyted_time\n",
                  KLIN(FILENO,__LINE__)));                    

        goto Cleanup;
    }

    //
    // Now verify the time.
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &EncryptedTime->timestamp,
        ((EncryptedTime->bit_mask & KERB_ENCRYPTED_TIMESTAMP_usec_present) != 0) ?
            EncryptedTime->KERB_ENCRYPTED_TIMESTAMP_usec : 0
        );

    GetSystemTimeAsFileTime(
        (PFILETIME) &CurrentTime
        );

    //
    // We don't want to check too closely, so allow for skew
    //

    if ((CurrentTime.QuadPart + SkewTime.QuadPart < ClientTime.QuadPart) ||
        (CurrentTime.QuadPart - SkewTime.QuadPart > ClientTime.QuadPart))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Client %wZ time is incorrect:\n",
                  KLIN(FILENO,__LINE__),
                  &TicketInfo->AccountName));
        PrintTime(DEB_ERROR, "Client Time is", &ClientTime );
        PrintTime(DEB_ERROR, "KDC Time is", &CurrentTime );

        //
        // We don't want to lockout the account if the time is off
        //

        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    //
    // Build an ETYPE_INFO structure to return
    //

    if ((KerbErr == KDC_ERR_PREAUTH_FAILED) || (KerbErr == KDC_ERR_ETYPE_NOTSUPP))
    {
       KERBERR TmpErr; 

       TmpErr  = KdcBuildEtypeInfo(
                     TicketInfo,
                     RequestBody,
                     OutputPreAuth
                     );

       //
       // In this case, we can't find any ETypes that both the client and
       // server support, so we've got to bail w/ proper error
       // message...
       //
       if (TmpErr == KDC_ERR_ETYPE_NOTSUPP)
       {
          KerbErr = KDC_ERR_ETYPE_NOTSUPP;
       }                                                       
    }

    if (EncryptedData != NULL)
    {
        KerbFreeEncryptedData(EncryptedData);
    }
    if (EncryptedTime != NULL)
    {
        KerbFreeData(KERB_ENCRYPTED_TIMESTAMP_PDU, EncryptedTime);
    }

    return(KerbErr);


}


typedef enum _BUILD_PAC_OPTIONS {
    IncludePac,
    DontIncludePac,
    DontCare
} BUILD_PAC_OPTIONS, *PBUILD_PAC_OPTIONS;

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacRequestPreAuthData
//
//  Synopsis:   Gets the status of whether the client wants a PAC from the
//              pre-auth data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcCheckPacRequestPreAuthData(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN OUT PBUILD_PAC_OPTIONS BuildPac
    )
{
    PKERB_PA_PAC_REQUEST PacRequest = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    DsysAssert(PreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST);

    KerbErr = KerbUnpackData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                KERB_PA_PAC_REQUEST_PDU,
                (PVOID *) &PacRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    if (PacRequest->include_pac)
    {
        *BuildPac = IncludePac;
    }
    else
    {
        *BuildPac = DontIncludePac;
    }

    D_DebugLog((DEB_T_TICKETS,"Setting BuildPac from pa-data to %d\n",*BuildPac));

Cleanup:
    if (PacRequest != NULL)
    {
        KerbFreeData(
            KERB_PA_PAC_REQUEST_PDU,
            PacRequest
            );
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPreAuthData
//
//  Synopsis:   Checks the pre-auth data in an AS request. This routine
//              may return pre-auth data to caller on both success and
//              failure.
//
//  Effects:
//
//  Arguments:  ClientTicketInfo - client account's ticket info
//              UserHandle - Handle to client's user object
//              PreAuthData - Pre-auth data supplied by client
//              PreAuthType - The type of pre-auth used
//              OutputPreAuthData - pre-auth data to return to client
//              BuildPac - TRUE if we should build a PAC for this client
//
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_REQUIRED, KDC_ERR_PREAUTH_FAILED
//
//  Notes:      This routine should be more extensible - at some point
//              it should allow DLLs to be plugged in that implement
//              preauth.
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PULONG PreAuthType,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PBOOLEAN BuildPac,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealms,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST OutputElement = NULL;
    PKERB_PA_DATA_LIST ListElement = NULL;
    BOOLEAN ValidPreauthPresent = FALSE;
    BUILD_PAC_OPTIONS PacOptions = DontCare;

    *OutputPreAuthData = NULL;
    *BuildPac = FALSE;

    //
    // Loop through the supplied pre-auth data elements and handle each one
    //

    for (ListElement = PreAuthData;
         ListElement != NULL ;
         ListElement = ListElement->next )
    {
        switch(ListElement->value.preauth_data_type) {
        case KRB5_PADATA_ENC_TIMESTAMP:

            *PreAuthType = ListElement->value.preauth_data_type;

            KerbErr = KdcVerifyEncryptedTimeStamp(
                        ListElement,
                        ClientTicketInfo,
                        RequestBody,
                        UserHandle,
                        &OutputElement
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                ValidPreauthPresent = TRUE;
            }

            break;
        case KRB5_PADATA_PK_AS_REP:
            *PreAuthType = ListElement->value.preauth_data_type;

            KerbErr = KdcCheckPkinitPreAuthData(
                        ClientTicketInfo,
                        UserHandle,
                        ListElement,
                        RequestBody,
                        &OutputElement,
                        Nonce,
                        EncryptionKey,
                        TransitedRealms,
                        pExtendedError
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                ValidPreauthPresent = TRUE;
            }

            break;
        case KRB5_PADATA_PAC_REQUEST:
            KerbErr = KdcCheckPacRequestPreAuthData(
                        ListElement,
                        &PacOptions
                        );
            break;
        default:
            break;


        } // switch
        if (OutputElement != NULL)
        {
            OutputElement->next = *OutputPreAuthData;
            *OutputPreAuthData = OutputElement;
            OutputElement = NULL;
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


    } // for

    // We need to check preauth data by default, unless, the account tells
    // us not to.
    //

    if (!(UserInfo->I1.UserAccountControl & USER_DONT_REQUIRE_PREAUTH) &&
        !ValidPreauthPresent &&
        KERB_SUCCESS(KerbErr))
    {
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;

        //
        // Return the list of supported types, if we don't have other
        // data to return.
        //

        if (*OutputPreAuthData == NULL)
        {
            (VOID) KdcBuildPreauthTypeList(OutputPreAuthData);
            if (*OutputPreAuthData != NULL)
            {
                PKERB_PA_DATA_LIST EtypeInfo = NULL;
                KERBERR TmpErr;
                TmpErr = KdcBuildEtypeInfo(
                             ClientTicketInfo,
                             RequestBody,
                             &EtypeInfo
                             );
                //
                // In this case, we can't find any ETypes that both the client and
                // server support, so we've got to bail w/ proper error
                // message...
                //
                if (TmpErr == KDC_ERR_ETYPE_NOTSUPP)
                {
                   KerbErr = KDC_ERR_ETYPE_NOTSUPP;
                }
                 
                if (EtypeInfo != NULL)
                {
                        EtypeInfo->next = *OutputPreAuthData;
                        *OutputPreAuthData = EtypeInfo;
                        EtypeInfo = NULL;
                }
            }

        }
    }

    //
    // Set the final option for including the pac- if the pac_request was
    // included, honor it. Otherwise build the pac if valid preauth
    // was supplied.
    //

    switch(PacOptions) {

    case DontCare:
        *BuildPac = ValidPreauthPresent;
        break;

    case IncludePac:
        *BuildPac = TRUE;
        break;

    case DontIncludePac:
        *BuildPac = FALSE;
        break;
    }

Cleanup:

    return(KerbErr);

}






//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketAS
//
//  Synopsis:   Builds an AS ticket, including filling inthe name fields
//              and flag fields.
//
//  Arguments:  [ClientTicketInfo]      -- client asking for the ticket
//              [ClientName]  -- name of client
//              [ServiceTicketInfo]     -- service ticket is for
//              [ServerName] -- name of service
//              [RequestBody]   -- ticket request
//              [NewTicket]    -- (out) ticket
//
//  History:    24-May-93   WadeR   Created
//
//  Notes:      See 3.1.3, A.2 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR
BuildTicketAS(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN PKERB_PRINCIPAL_NAME ClientName,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN OPTIONAL PKERB_HOST_ADDRESSES HostAddresses,
    IN PLARGE_INTEGER LogoffTime,
    IN PLARGE_INTEGER AccountExpiry,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN ULONG CommonEType,
    IN ULONG PreAuthType,
    IN PUNICODE_STRING TransitedRealm,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    ULONG KdcOptions = 0;


    TRACE(KDC, BuildTicketAS, DEB_FUNCTION);

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    NewTicket->ticket_version = KERBEROS_VERSION;

    D_DebugLog(( DEB_T_TICKETS, "Building an AS ticket to %wZ for %wZ\n",
                &ClientTicketInfo->AccountName, &ServiceTicketInfo->AccountName ));


    //  Since this is the AS ticket, we fake the TGTFlags parameter to be the
    //  maximum the client is allowed to have.


    TicketLifespan = SecData.KdcTgtTicketLifespan();
    TicketRenewspan = SecData.KdcTicketRenewSpan();

    Status = KdcBuildTicketTimesAndFlags(
                ClientTicketInfo->fTicketOpts,
                ServiceTicketInfo->fTicketOpts,
                &TicketLifespan,
                &TicketRenewspan,
                LogoffTime,
                AccountExpiry,
                RequestBody,
                NULL,           // no source ticket
                EncryptedTicket,
                pExtendedError 
                );

    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
                  KLIN(FILENO,__LINE__), Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }


    *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_initial);

    //
    // Turn on preauth flag if necessary
    //

    if (PreAuthType != 0)
    {
        *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_pre_authent);
    }


    Status = KerbMakeKey(
                CommonEType,
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }


    //
    // Insert the service names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //

    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        PKERB_INTERNAL_NAME TempServiceName = NULL;
        //
        // Build the service name for the ticket. For interdomain trust
        // accounts, this is "krbtgt / domain name"
        //

        if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
        {

            Status = KerbBuildFullServiceKdcName(
                        SecData.KdcDnsRealmName(),
                        SecData.KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0)
        {

            Status = KerbBuildFullServiceKdcName(
                        &ServiceTicketInfo->AccountName,
                        SecData.KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__); 
               goto Cleanup;
            }
        }
        else
        {
            Status = KerbConvertStringToPrincipalName(
                        &NewTicket->server_name,
                        &ServiceTicketInfo->AccountName,
                        KRB_NT_PRINCIPAL
                        );
            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__); 
               goto Cleanup;
            }
        }

    }
    else
    {
        //
        // No canonicalzation, so copy in all the names as the client
        // requested them.
        //

        Status = KerbDuplicatePrincipalName(
                    &NewTicket->server_name,
                    ServerName
                    );
        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    NewTicket->realm = SecData.KdcKerbDnsRealmName();

    //
    // Insert the client names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //


    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        ((ClientTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        Status = KerbConvertStringToPrincipalName(
                    &EncryptedTicket->client_name,
                    &ClientTicketInfo->AccountName,
                    KRB_NT_PRINCIPAL
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__); 
           goto Cleanup;                                            
        }

    }
    else
    {
        Status = KerbDuplicatePrincipalName(
                    &EncryptedTicket->client_name,
                    ClientName
                    );
        if (!KERB_SUCCESS(Status))
        {
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            goto Cleanup;
        }
    }
    EncryptedTicket->client_realm = SecData.KdcKerbDnsRealmName();


    if (HostAddresses != NULL)
    {
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = HostAddresses;
    }
    else
    {
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
    }

    if (TransitedRealm->Length > 0)
    {
        STRING TempString;
        Status = KerbUnicodeStringToKerbString(
                    &TempString,
                    TransitedRealm
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__); 
           goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {
        RtlZeroMemory(
            &EncryptedTicket->transited,
            sizeof(KERB_TRANSITED_ENCODING)
            );
    }

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;

#if DBG
    PrintTicket( DEB_T_TICKETS, "BuildTicketAS: Final ticket", NewTicket );
#endif

Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KdcFreeInternalTicket(NewTicket);
    }
    return(Status);
}


//
// String defines of the service names for the change PW SPNs
// for use with the KerbCheckIfSPNIsChangePW function
//

#define KERB_KADMIN_CHG_PW      L"kadmin/changepw"

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckIfSPNIsChangePW
//
//  Synopsis:   Check if the service name is kadmin/changepw.
//
//  Arguments:  pServerName - Contains the service name
//              pLogonRestrictionsFlags - Output flags value.
//
//  Requires:
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCheckIfSPNIsChangePW(
    IN PUNICODE_STRING pServerName,
    IN ULONG *pLogonRestrictionsFlags)
{
    if ((pServerName->Length == (sizeof(KERB_KADMIN_CHG_PW) - sizeof(WCHAR))) &&
        RtlCompareMemory(pServerName->Buffer,
            KERB_KADMIN_CHG_PW,
            sizeof(KERB_KADMIN_CHG_PW) - sizeof(WCHAR)))
    {
        *pLogonRestrictionsFlags |= KDC_RESTRICT_IGNORE_PW_EXPIRATION;
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   I_GetASTicket
//
//  Synopsis:   Gets an authentication service ticket to the requested
//              service.
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  RequestMessage - Contains the AS request message
//              Pdu - PDU to pack the reply body with.
//              InputMessage - buffer client sent, used for replay detection
//              OutputMessage - Contains the AS reply message
//              ErrorData - contains any error data for an error message
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
I_GetASTicket(
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN PKERB_AS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    IN ULONG Pdu,
    IN ULONG ReplyPdu,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PUNICODE_STRING ClientRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS LogonStatus = STATUS_SUCCESS;

    KDC_TICKET_INFO ClientTicketInfo = {0};
    KDC_TICKET_INFO ServiceTicketInfo = {0};

    SAMPR_HANDLE UserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST GroupMembership = {0};

    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PKERB_ENCRYPTION_KEY ServerKey = NULL;
    PKERB_ENCRYPTION_KEY ClientKey = NULL ;

    KERB_TICKET Ticket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    KERB_KDC_REPLY Reply = {0};
    PKERB_KDC_REQUEST_BODY RequestBody = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;

    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;

    UNICODE_STRING ClientNetbiosAddress = {0};
    UNICODE_STRING ServerStringName = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING ServerRealm = {0};
    UNICODE_STRING MappedClientName = {0};
    UNICODE_STRING TransitedRealm = {0};

    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER AccountExpiry;
    ULONG NameFlags = 0;
    ULONG PreAuthType = 0;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;
    ULONG CommonEType;
    ULONG ClientEType;
    ULONG Nonce = 0;
    ULONG LogonRestrictionsFlags = 0;
    ULONG WhichFields = 0;

    BOOLEAN AuditedFailure = FALSE;
    BOOLEAN BuildPac = FALSE;
    BOOLEAN ClientReferral = FALSE;
    BOOLEAN ServerReferral = FALSE;
    BOOLEAN LoggedFailure = FALSE;
    BOOLEAN PasswordCorrect = FALSE;

    KDC_AS_EVENT_INFO ASEventTraceInfo = {0};

    TRACE(KDC, I_GetASTicket, DEB_FUNCTION);

    //
    //  Initialize local variables
    //

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;
    RtlInitUnicodeString( ClientRealm, NULL );
    Ticket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Assume that this isn't a logon request.  If we manage to fail before
    // we've determined it's a logon attempt, we won't mark it as a failed
    // logon.
    //

    RequestBody = &RequestMessage->request_body;

    //
    // There are many options that are invalid for an AS ticket.
    //

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Start event tracing (capture error cases too)
    //

    if (KdcEventTraceFlag){

        ASEventTraceInfo.EventTrace.Guid = KdcGetASTicketGuid;
        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        ASEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        ASEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }

    if (KdcOptions &
        (KERB_KDC_OPTIONS_forwarded |
         KERB_KDC_OPTIONS_proxy |
         KERB_KDC_OPTIONS_unused7 |
         KERB_KDC_OPTIONS_unused9 |
         KERB_KDC_OPTIONS_renew |
         KERB_KDC_OPTIONS_validate |
         KERB_KDC_OPTIONS_reserved |
         KERB_KDC_OPTIONS_enc_tkt_in_skey ) )
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    if (( RequestBody->bit_mask & addresses_present ) &&
        ( RequestBody->addresses == NULL ))
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure a client name was supplied
    //


    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_client_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        KerbErr = KerbConvertKdcNameToString(
                    &ClientStringName,
                    ClientName,
                    NULL
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No principal name supplied to AS request - not allowed\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }


    //
    // Copy out the service name. This is not an optional field.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) == 0)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Client %wZ sent AS request with no server name\n",
                  KLIN(FILENO,__LINE__),
                  &ClientStringName));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_NAME_CHECK_GC;
    }
    else
    {
        //
        // canonicalize bit is not set so we want to check if the service
        // name is kadmin/changepw, if it is we set the flag to indicate
        // that we will ignore password expiration checking
        //

        KerbCheckIfSPNIsChangePW(
            &ServerStringName,
            &LogonRestrictionsFlags);
    }

    D_DebugLog((DEB_TRACE, "Getting an AS ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServerName );
    D_DebugLog((DEB_TRACE, "\tfor " ));
    D_KerbPrintKdcName( DEB_TRACE, ClientName );

    //
    // Get the client's NETBIOS address.
    //

    if ((RequestBody->bit_mask & addresses_present) != 0)
    {
        KerbErr = KerbGetClientNetbiosAddress(
                    &ClientNetbiosAddress,
                    RequestBody->addresses
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Normalize the client name.
    //

    if ( !IsSubAuthFilterPresent()) {

        WhichFields = USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS |
                      USER_ALL_KDC_CHECK_PREAUTH_DATA |
                      USER_ALL_ACCOUNTEXPIRES |
                      USER_ALL_KDC_GET_PAC_AUTH_DATA |
                      USER_ALL_SUCCESSFUL_LOGON;

    } else {

        //
        // We do not know what the subauth routine needs, so get everything
        //

        WhichFields = 0xFFFFFFFF & ~USER_ALL_UNDEFINED_MASK;
    }

    KerbErr = KdcNormalize(
                  ClientName,
                  NULL,
                  RequestRealm,
                  NameFlags | KDC_NAME_CLIENT | KDC_NAME_FOLLOW_REFERRALS,
                  &ClientReferral,
                  ClientRealm,
                  &ClientTicketInfo,
                  pExtendedError,
                  &UserHandle,
                  WhichFields,
                  0L,
                  &UserInfo,
                  &GroupMembership
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name ",KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    // If Credential count is zero and there was no error, we do not have
    // NT_OWF info so return Error since Kerb can not auth

    if (ClientTicketInfo.Passwords->CredentialCount <= CRED_ONLY_LM_OWF)
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name - no creds ", KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    // If the UserHandle was NULL and there was no error, this must be
    // a cross realm trust account logon. Fail it, we have no account
    // to work with.

    if (!UserHandle || !UserInfo)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name", KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //

    if (ClientReferral)
    {
        KerbErr = KDC_ERR_WRONG_REALM;
        D_DebugLog((DEB_WARN,
                  "KLIN(%x) Client tried to logon to account in another realm\n", 
                  KLIN(FILENO,__LINE__)));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Error getting client ticket info for %wZ: 0x%x \n",
                  KLIN(FILENO,__LINE__), &MappedClientName, KerbErr));
        goto Cleanup;
    }

    //
    // The below function will return true for pkinit
    //

    if (KerbFindPreAuthDataEntry(
                    KRB5_PADATA_PK_AS_REP,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data) != NULL)
    {
        LogonRestrictionsFlags = KDC_RESTRICT_PKINIT_USED | KDC_RESTRICT_IGNORE_PW_EXPIRATION;
    }

    //
    // Check logon restrictions before preauth data, so we don't accidentally
    // leak information about the password.
    //

    KerbErr = KerbCheckLogonRestrictions(
                UserHandle,
                &ClientNetbiosAddress,
                &UserInfo->I1,
                LogonRestrictionsFlags,
                &LogoffTime,
                &LogonStatus
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_KEY_EXPIRED == KerbErr || LogonStatus == STATUS_NO_LOGON_SERVERS)
        {
            KERBERR TmpKerbErr;

            //
            // Unpack the pre-auth data.
            //

            TmpKerbErr = KdcCheckPreAuthData(
                             &ClientTicketInfo,
                             UserHandle,
                             UserInfo,
                             RequestMessage->KERB_KDC_REQUEST_preauth_data,
                             RequestBody,
                             &PreAuthType,
                             &OutputPreAuthData,
                             &BuildPac,
                             &Nonce,
                             &EncryptionKey,
                             &TransitedRealm,
                             ErrorData,
                             pExtendedError
                             );

            if (!KERB_SUCCESS(TmpKerbErr))
            {
                BYTE ClientSid[MAX_SID_LEN];

                KerbErr = TmpKerbErr;

                RtlZeroMemory(ClientSid, MAX_SID_LEN);
                KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

                if (SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
                {
                    KdcLsaIAuditKdcEvent(
                        SE_AUDITID_PREAUTH_FAILURE,
                        &ClientTicketInfo.AccountName,
                        NULL,                   // no domain name
                        ClientSid,
                        &ServerStringName,
                        NULL,                   // no server sid
                        &PreAuthType,
                        (PULONG) &KerbErr,
                        NULL,
                        NULL,
                        GET_CLIENT_ADDRESS(ClientAddress),
                        NULL                    // no logon guid
                        );

                    AuditedFailure = TRUE;
                }

                //
                // Only handle failed logon if pre-auth fails. Otherwise the error
                // was something the client couldn't control, such as memory
                // allocation or clock skew.
                //

                if (KerbErr == KDC_ERR_PREAUTH_FAILED)
                {
                    FailedLogon(
                        UserHandle,
                        ClientAddress,
                        &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                        ClientSid,
                        MAX_SID_LEN,
                        InputMessage,
                        OutputMessage,
                        &ClientNetbiosAddress,
                        KerbErr
                        );
                }
                LoggedFailure = TRUE;
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to check pre-auth data: 0x%x\n",
                          KLIN(FILENO,__LINE__), KerbErr));
                goto Cleanup;
            }
            else if (LogonStatus == STATUS_NO_LOGON_SERVERS)
            {
               D_DebugLog((DEB_WARN, "KLIN(%x) Logon Restriction check failed due to no logon servers\n",
                     KLIN(FILENO,__LINE__)));

               KdcHandleNoLogonServers(UserHandle,
                                       ClientAddress);
               goto Cleanup;
            }
            else
            {
                DebugLog((DEB_WARN,"KLIN(%x) Logon restriction check failed: NTSTATUS: 0x%x KRB: 0x%x\n",
                          KLIN(FILENO,__LINE__),LogonStatus, KerbErr));
                // Here's one case where we want to return errors to the client, so use EX
                FILL_EXT_ERROR_EX(pExtendedError, LogonStatus, FILENO, __LINE__);
                goto Cleanup;
            } 

        }
        else
        {
           DebugLog((DEB_WARN,"KLIN(%x) Logon restriction check failed: NTSTATUS: 0x%x KRB: 0x%x\n",
                     KLIN(FILENO,__LINE__),LogonStatus, KerbErr));
           // Here'  s one case where we want to return errors to the client, so use EX
           FILL_EXT_ERROR_EX(pExtendedError, LogonStatus, FILENO, __LINE__);
        }

        goto Cleanup;
    }

    //
    // Unpack the pre-auth data.
    //

    KerbErr = KdcCheckPreAuthData(
                &ClientTicketInfo,
                UserHandle,
                UserInfo,
                RequestMessage->KERB_KDC_REQUEST_preauth_data,
                RequestBody,
                &PreAuthType,
                &OutputPreAuthData,
                &BuildPac,
                &Nonce,
                &EncryptionKey,
                &TransitedRealm,
                ErrorData,
                pExtendedError
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        BYTE ClientSid[MAX_SID_LEN];

        RtlZeroMemory(ClientSid, MAX_SID_LEN);
        KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

        if (SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
        {
            KdcLsaIAuditKdcEvent(
                SE_AUDITID_PREAUTH_FAILURE,
                &ClientTicketInfo.AccountName,
                NULL,                   // no domain name
                ClientSid,
                &ServerStringName,
                NULL,                   // no server sid
                &PreAuthType,
                (PULONG) &KerbErr,
                NULL,
                NULL,
                GET_CLIENT_ADDRESS(ClientAddress),
                NULL                    // no logon guid
                );

            AuditedFailure = TRUE;
        }

        //
        // Only handle failed logon if pre-auth fails. Otherwise the error
        // was something the client couldn't control, such as memory
        // allocation or clock skew.
        //
        if (KerbErr == KDC_ERR_PREAUTH_FAILED)
        {
            FailedLogon(
                UserHandle,
                ClientAddress,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                ClientSid,
                MAX_SID_LEN,
                InputMessage,
                OutputMessage,
                &ClientNetbiosAddress,
                KerbErr
                );
        }
        LoggedFailure = TRUE;
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to check pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Check for subauthentication
    //

    KerbErr = KdcCallSubAuthRoutine(
                &ClientTicketInfo,
                UserInfo,
                &ClientNetbiosAddress,
                &LogoffTime,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) Subuath  restriction check failed: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Figure out who the ticket is for. First break the name into
    // a local name and a referral realm
    //

    //
    //  Note:   We don't allow referrals here, because we should only get AS 
    //          requests for our realm, and the krbtgt\server should always be
    //          in our realm.  

    KerbErr = KdcNormalize(
                ServerName,
                NULL,
                NULL,                   // don't use requested realm for the server - use our realm
                NameFlags | KDC_NAME_SERVER,   
                &ServerReferral,
                &ServerRealm,
                &ServiceTicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                0L,                     // no additional fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name 0x%x ",
                  KLIN(FILENO,__LINE__), KerbErr ));
        KerbPrintKdcName(DEB_ERROR, ServerName);
        goto Cleanup;
    }



    //
    // Find a common crypto system.  Do it now in case we need
    // to return the password for a service.
    //
    if (EncryptionKey.keyvalue.value == NULL)
    {
        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ClientTicketInfo.Passwords,
                    NULL, //ServiceTicketInfo.Passwords,
                    &ClientEType,
                    &ClientKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            KdcReportKeyError(
                &ClientTicketInfo.AccountName,
                NULL,
                KDCEVENT_NO_KEY_UNION_AS,
                RequestBody->encryption_type,
                ClientTicketInfo.Passwords                   
                );

            DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                      KLIN(FILENO,__LINE__),KerbErr));
            goto Cleanup;
        }
    }
    else
    {
        //
        // BUG 453284: this doesn't take into account the service ticket
        // info. If the PKINIT code generated a key that the service
        // doesn't suport, this key may not be usable by the client &
        // server. However, in the pkinit code it is hard to know what
        // types the server supports.
        //

        ClientEType = EncryptionKey.keytype;
    }

    //
    // Get the etype to use for the ticket itself from the server's
    // list of keys
    //

    KerbErr = KerbFindCommonCryptSystem(
                RequestBody->encryption_type,
                ServiceTicketInfo.Passwords,
                NULL,   // no additional passwords
                &CommonEType,
                &ServerKey
                );
    
    
    if (!KERB_SUCCESS(KerbErr))
    {
        KdcReportKeyError(
            &ServiceTicketInfo.AccountName,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS, 
            RequestBody->encryption_type,
            ServiceTicketInfo.Passwords
            );

        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }


    //
    // We need to save the full domain name of the service regardless
    // of whether it was provided or not. This is so name changes
    // can be detected. Instead of creating a mess of trying to figure out
    // which deallocator to use, allocate new memory and copy data.
    //

    AccountExpiry = UserInfo->I1.AccountExpires;

    KerbErr = BuildTicketAS(
                &ClientTicketInfo,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &ServiceTicketInfo,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                ((RequestBody->bit_mask & addresses_present) != 0) ? RequestBody->addresses : NULL,
                &LogoffTime,
                &AccountExpiry,
                RequestBody,
                CommonEType,
                PreAuthType,
                &TransitedRealm,
                &Ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN , "KLIN(%x) Failed to build AS ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // If the user requested a PAC (via pre-auth data) build one now.
    //

    if (BuildPac)
    {
        //
        // Now build a PAC to stick in the authorization data
        //

        KerbErr = KdcGetPacAuthData(
                    UserInfo,
                    &GroupMembership,
                    ServerKey,
                    &EncryptionKey,
                    ((ServiceTicketInfo.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0) &&
                        (ServiceTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT),
                        // add resource groups if server is not an interdomain trust account
                    &EncryptedTicket,
                    NULL, // no S4U info here...
                    &PacAuthData,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to get pac auth data for %wZ : 0x%x\n",
                      KLIN(FILENO,__LINE__),&ClientTicketInfo.AccountName,KerbErr));
            goto Cleanup;
        }

        //
        // Stick the auth data into the AS ticket
        //

        EncryptedTicket.KERB_ENCRYPTED_TICKET_authorization_data = PacAuthData;
        PacAuthData = NULL;
        EncryptedTicket.bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
    }

    //
    // Now build the reply
    //

    KerbErr = BuildReply(
                &ClientTicketInfo,
                (Nonce != 0) ? Nonce : RequestBody->nonce,
                &Ticket.server_name,
                Ticket.realm,
                ((RequestBody->bit_mask & addresses_present) != 0) ? RequestBody->addresses : NULL,
                &Ticket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    Reply.client_realm = EncryptedTicket.client_realm;

    //
    // Build pw-salt if we used a user's key
    //
    
    if (ClientKey != NULL)
    {
         KerbErr = KdcBuildPwSalt(
            ClientTicketInfo.Passwords,
            ClientKey,
            &OutputPreAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (OutputPreAuthData != NULL)
    {
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }


    //
    // Copy in the ticket
    //


    KerbErr = KerbPackTicket(
                &Ticket,
                ServerKey,
                CommonEType,
                &Reply.ticket
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Note: these are freed elsewhere, so zero them out after
    // using them
    //

    Reply.client_name = EncryptedTicket.client_name;

    //
    // Copy in the encrypted part
    //

    KerbErr = KerbPackKdcReplyBody(
                &ReplyBody,
                (EncryptionKey.keyvalue.value != NULL) ? &EncryptionKey : ClientKey,
                ClientEType,
                Pdu,
                &Reply.encrypted_part
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack KDC reply body: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Add in PW-SALT if we used a client key
    //

    if (SecData.AuditKdcEvent(KDC_AUDIT_AS_SUCCESS))
    {
        BYTE ClientSid[MAX_SID_LEN];
        BYTE ServerSid[MAX_SID_LEN];

        KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);
        KdcMakeAccountSid(ServerSid, ServiceTicketInfo.UserId);

        KdcLsaIAuditKdcEvent(
            SE_AUDITID_AS_TICKET,
            &ClientTicketInfo.AccountName,
            RequestRealm,
            ClientSid,
            &ServiceTicketInfo.AccountName,
            ServerSid,
            (PULONG) &KdcOptions,
            NULL,                    // success
            &CommonEType,
            &PreAuthType,
            GET_CLIENT_ADDRESS(ClientAddress),
            NULL                     // no logon guid
            );
    }

    //
    // Pack the reply
    //

    KerbErr = KerbPackData(
                &Reply,
                ReplyPdu,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        DsysAssert(RequestBody != NULL);

        if (!AuditedFailure && SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
        {
            if (ClientName != NULL)
            {
                KdcLsaIAuditKdcEvent(
                    SE_AUDITID_AS_TICKET,
                    &ClientName->Names[0],
                    RequestRealm,
                    NULL,
                    &ServerStringName,
                    NULL,
                    &KdcOptions,
                    (PULONG) &KerbErr,          // failure
                    NULL,                       // no common etype
                    NULL,                       // no preauth type
                    GET_CLIENT_ADDRESS(ClientAddress),
                    NULL                        // no logon guid
                    );

            }
        }
        //
        // If there was any preath data to return, pack it for return now.
        //

        if (OutputPreAuthData != NULL)
        {
            if (ErrorData->Buffer != NULL)
            {
                D_DebugLog((DEB_ERROR,
                          "KLIN(%x) Freeing return error data to return preauth data\n",
                          KLIN(FILENO,__LINE__)));
                MIDL_user_free(ErrorData->Buffer);
                ErrorData->Buffer = NULL;
                ErrorData->BufferSize = 0;
            }

            (VOID) KerbPackData(
                    &OutputPreAuthData,
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    &ErrorData->BufferSize,
                    &ErrorData->Buffer
                    );
        }

    }
    if (UserHandle != NULL)
    {
        if (!KERB_SUCCESS(KerbErr))
        {
            if (!LoggedFailure)
            {
                KerbErr = FailedLogon(
                            UserHandle,
                            ClientAddress,
                            &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                            NULL,
                            0,
                            InputMessage,
                            OutputMessage,
                            &ClientNetbiosAddress,
                            KerbErr
                            );
            }
        }
        else
        {
            SuccessfulLogon(
                UserHandle,
                ClientAddress,
                InputMessage,
                UserInfo
                );
        }
        SamrCloseHandle(&UserHandle);
    }

    //
    // Complete the WMI event
    //

    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                            WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        ASEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        ASEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        ASEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }


        ASEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (RequestRealm->Buffer != NULL &&
            RequestRealm->Length > 0)
        {
            pStringToCopy = RequestRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) (pStringToCopy->Buffer);
        ASEventTraceInfo.eventInfo[6].Length =
            (pStringToCopy->Length);
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }

    SamIFree_UserInternal6Information( UserInfo );
    SamIFreeSidAndAttributesList( &GroupMembership );
    KerbFreeAuthData( PacAuthData );
    FreeTicketInfo( &ClientTicketInfo );
    FreeTicketInfo( &ServiceTicketInfo );
    KdcFreeInternalTicket( &Ticket );
    KerbFreeKey( &EncryptionKey );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &ClientStringName );
    KerbFreeString( &TransitedRealm );
    KerbFreeString( &ServerStringName );
    KerbFreeString( &ServerRealm );
    KerbFreeKdcName( &ServerName );
    KerbFreeString( &ClientNetbiosAddress );
    KdcFreeKdcReplyBody( &ReplyBody );
    KdcFreeKdcReply( &Reply );
    KerbFreePreAuthData( OutputPreAuthData );

    D_DebugLog(( DEB_TRACE, "I_GetASTicket() returning 0x%x\n", KerbErr ));

    return KerbErr;
}





//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicket
//
//  Synopsis:   Generic ticket getting entrypoint to get a ticket from the KDC
//
//  Effects:
//
//  Arguments:  Context - ATQ context - only present for TCP/IP callers
//              ClientAddress - Client's IP addresses. Only present for UDP & TPC callers
//              ServerAddress - address the client used to contact this KDC.
//                      Only present for UDP & TPC callers
//              InputMessage - the input KDC request message, in ASN.1 format
//              OutputMessage - Receives the KDC reply message