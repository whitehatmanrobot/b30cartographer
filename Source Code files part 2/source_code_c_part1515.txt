                // first check whether the dmo supports this natively and cache the interface pointer if so
                // BUGBUG needs to be per output stream!!
                // for now fail only ask if 1st output stream
                CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
                if( pVideoCompressionOnDMO )
                {
                    // so it is supported natively, but we must release it since it winds up addref'ing the filter
                    m_bUseIAMVideoCompressionOnDMO = true;
                    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::NonDelegatingQI - DMO supports IAMVideoCompression natively")));
                }
            }
            // either way it'll go through us
            return GetInterface( static_cast<IAMVideoCompression *> (this), ppv);
        }            
    }
             
    return E_NOINTERFACE;
}

HRESULT CWrapperOutputPin::CheckMediaType(const CMediaType *pmt)
{
    return Filter()->OutputCheckMediaType(m_Id, pmt);
}
HRESULT CWrapperOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock l(&m_csStream);
    HRESULT hr = Filter()->OutputSetMediaType(m_Id, pmt);
    if (SUCCEEDED(hr)) {
        hr = CBaseOutputPin::SetMediaType(pmt);
        if (SUCCEEDED(hr)) {
            m_fVideo = pmt->majortype == MEDIATYPE_Video ? true : false;
        }
    }
    return hr;
}

HRESULT CWrapperOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if( m_pmtFromSetFormat )
    {
        // our SetFormat has been called so only offer that type from now on
        if( iPosition != 0 )
            return E_INVALIDARG;

        *pMediaType = *m_pmtFromSetFormat;
        return S_OK;
    }
    else
    {
        return Filter()->OutputGetMediaType(m_Id, (ULONG)iPosition, pMediaType);
    }
}

//
// override primarily for the case where we're a wm dmo video encoder connecting directly 
// to the ASF writer, in a desparate attempt to get an output type which a wm video encoder
// will accept in the default connection case
//
STDMETHODIMP CWrapperOutputPin::Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::Connect")));
    CAutoLock lck(&(Filter()->m_csFilter));
    //
    // if connecting to the asf writer try getting a default type from the writer
    //
    // note that, although we'd like to do this only if SetFormat hasn't been called,
    // we have no guarantee that the writer format hasn't changed, so we need to 
    // continually call SetFormat with the type we get from the downstream pin's GetFormat
    bool bSetFormatOnConnect = false;

    if( !pmt && !m_pmtFromSetFormat && IsVideoEncoder() )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfig( pReceivePin );
        if( pStreamConfig )
        {
            AM_MEDIA_TYPE *pmt2;
            HRESULT hrInt = pStreamConfig->GetFormat( &pmt2 );
            if( SUCCEEDED( hrInt ) )
            {
                // now we'll only offer this type!
                hrInt = SetFormat( pmt2 );
                if( SUCCEEDED( hrInt ) )
                {
                    bSetFormatOnConnect = true; 
                }
            }
        }
    }
    // call the base class connect
    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if( bSetFormatOnConnect )
    {
        // whether we failed or not, unset the format if we set one here in connect
        if( m_pmtFromSetFormat )
        {
            // clean up any media type we might have cached from a SetFormat call
            DeleteMediaType( m_pmtFromSetFormat );
            m_pmtFromSetFormat = NULL;
        }
    }
    return hr; 
}

//  Remove any media type when breaking a connection
HRESULT CWrapperOutputPin::BreakConnect()
{
    HRESULT hr = CBaseOutputPin::BreakConnect();
    Filter()->m_pMediaObject->SetOutputType(m_Id, &CMediaType(), DMO_SET_TYPEF_CLEAR);
    return hr;
}

HRESULT CWrapperOutputPin::DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES * ppropInputRequest
)
{
    return Filter()->OutputDecideBufferSize(m_Id, pAlloc, ppropInputRequest);
}

HRESULT CWrapperOutputPin::Notify(IBaseFilter * pSender, Quality q)
{
   LogPublicEntry(LOG_STREAM,"Quality Notify");
   HRESULT hr;

   // If quality sink set, forward the quality request to it
   if (m_pQSink) {
      hr = m_pQSink->Notify(Filter(), q);
      LogHResult(hr, LOG_STREAM, "Quality Notify", "m_pQSink->Notify");
      return hr;
   }

   // This will try the DMO, then the upstream pin
   return Filter()->QualityNotify(m_Id, q);
}

//
// IAMStreamConfig
//
HRESULT CWrapperOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat")));
    CAutoLock lck(&(Filter()->m_csFilter));
    HRESULT hr = S_OK;
    if (NULL == pmt)
    {
        // I'd rather use this to "unset" the type, but that's not how other encoders work
        // previously they returned E_POINTER for this
        // can we break tradition?
        DeleteMediaType( m_pmtFromSetFormat );
        m_pmtFromSetFormat = NULL;
        return S_OK;
    }

    if (Filter()->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // ensure inputs connected to this output are connected
    // since our possible output formats depend on the input format
    if( !IsInputConnected() )
    {
        return VFW_E_NOT_CONNECTED;
    }

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->SetFormat( pmt );
    }
    
#ifdef DEBUG
    if(pmt->pbFormat && pmt->cbFormat > 0 )
    {    
        if( IsVideoEncoder() )
        {
            DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat %x %dbit %dx%d"),
                HEADER(pmt->pbFormat)->biCompression,
                HEADER(pmt->pbFormat)->biBitCount,
                HEADER(pmt->pbFormat)->biWidth,
                HEADER(pmt->pbFormat)->biHeight));
        }
        else
        {
            DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin - IAMStreamConfig::SetFormat to tag:%d %dbit %dchannel %dHz"),
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
                ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
        }
    }        
#endif

    // If this is the same format as we already are using, don't bother
    CMediaType cmt;
    hr = GetMediaType(0,&cmt);
    if (S_OK != hr)
        return hr;
    
    if (cmt == *pmt) 
    {
        return NOERROR;
    }

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) 
    {
        DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
        return hr;
    }

    // if we're connected, ask downstream
    if (IsConnected()) 
    {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
        {
            return VFW_E_INVALIDMEDIATYPE;
        }
    }

    // this is now the preferred type (type 0)
    hr = SetMediaType((CMediaType *)pmt);
    if( S_OK == hr )
    {
        // only offer this type from now on!
        if( m_pmtFromSetFormat )
            DeleteMediaType( m_pmtFromSetFormat );

        m_pmtFromSetFormat = CreateMediaType( ( AM_MEDIA_TYPE * ) pmt );
        if( !m_pmtFromSetFormat )
            return E_OUTOFMEMORY;
    }
    ASSERT(hr == S_OK);

    // Changing the format means reconnecting if necessary
    if (IsConnected())
        Filter()->m_pGraph->Reconnect(this);

    return NOERROR;
}


HRESULT CWrapperOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin - IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
        return E_POINTER;

    CAutoLock lck(&(Filter()->m_csFilter));
    
    // ensure inputs connected to this output are connected
    // since our possible output formats depend on the input format
    if( !IsInputConnected() )
    {
        return VFW_E_NOT_CONNECTED;
    }
    
    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetFormat( ppmt );
    }

    // type 0 is always the preferred type 
    // actually this isn't the case for at least wm encoders, but we'll fake it
    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) 
    {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }
    return NOERROR;
}


HRESULT CWrapperOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::GetNumberOfCapabilities")));
    if (piCount == NULL || piSize == NULL)
        return E_POINTER;

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetNumberOfCapabilities( piCount, piSize );
    }

    // find out how many output types the dmo enumerates
    // note that it's ok to show possible output types before connecting input
    int iType = 0;
    HRESULT hr = S_OK;
    while( S_OK == hr )
    {
        // just enumerating, no need to get mt
        hr = GetMediaType( iType, NULL ); 
        if( S_OK == hr )
            iType++;
    }
    *piCount = iType;

    if( IsVideoEncoder() )
    {
        *piSize = sizeof(VIDEO_STREAM_CONFIG_CAPS);
    }
    else
    {
        ASSERT( IsAudioEncoder() );
        *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);
    }
    return NOERROR;
}

HRESULT CWrapperOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMStreamConfig::GetStreamCaps")));

    if (i < 0)
        return E_INVALIDARG;

    if (NULL == pSCC || NULL == ppmt)
        return E_POINTER;

    if( m_bUseIAMStreamConfigOnDMO )
    {
        CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
        ASSERT( pStreamConfigOnDMO );
        return pStreamConfigOnDMO->GetStreamCaps( i, ppmt, pSCC );
    }

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (NULL == *ppmt)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(i, (CMediaType *)*ppmt);
    if (hr != NOERROR) 
    {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;

        if( DMO_E_NO_MORE_ITEMS == hr || E_INVALIDARG == hr )
        {
            // is this spec'd to return S_FALSE if too high a type? Seems so from other encoders.
            return S_FALSE;
        }
        else
        {
            return hr;
        }
    }

    if( IsVideoEncoder() )
    {
        VIDEO_STREAM_CONFIG_CAPS *pVSCC = (VIDEO_STREAM_CONFIG_CAPS *)pSCC;

        ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));
        pVSCC->guid = MEDIATYPE_Video;

        if( (*ppmt)->pbFormat && (*ppmt)->cbFormat > 0 )
        {        
            BITMAPINFOHEADER *pbmih = HEADER((*ppmt)->pbFormat);
            pVSCC->InputSize.cx = pbmih->biWidth;
            pVSCC->InputSize.cy = pbmih->biHeight;
            pVSCC->MinCroppingSize.cx = pbmih->biWidth;
            pVSCC->MinCroppingSize.cy = pbmih->biHeight;
            pVSCC->MaxCroppingSize.cx = pbmih->biWidth;
            pVSCC->MaxCroppingSize.cy = pbmih->biHeight;
        }            
    }
    else
    {
        AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

        ZeroMemory(pASCC, sizeof(AUDIO_STREAM_CONFIG_CAPS));
        pASCC->guid = MEDIATYPE_Audio;

        if( (*ppmt)->pbFormat && (*ppmt)->cbFormat > 0 )
        {        
            LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)(*ppmt)->pbFormat;
            // rather let's just offer exactly what the dmo offers (if filled in?)        
        
            pASCC->MinimumChannels = pwfx->nChannels;
            pASCC->MaximumChannels = pwfx->nChannels;
            pASCC->ChannelsGranularity = 1;
            pASCC->MinimumBitsPerSample = pwfx->wBitsPerSample;
            pASCC->MaximumBitsPerSample = pwfx->wBitsPerSample;
            pASCC->BitsPerSampleGranularity = 8;
            pASCC->MinimumSampleFrequency = pwfx->nSamplesPerSec;
            pASCC->MaximumSampleFrequency = pwfx->nSamplesPerSec;
            pASCC->SampleFrequencyGranularity = 1; //?
        }
    }
    return hr;    
}


//
// IAMVideoCompression
//

#define DMO_COMPRESSION_QUALITY_MAX 10000  // is this set in stone? Check this.

// make key frames this often
//
HRESULT CWrapperOutputPin::put_KeyFrameRate(long KeyFrameRate)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_KeyFrameRate")));
    CAutoLock lck(&(Filter()->m_csFilter));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_KeyFrameRate( KeyFrameRate );
    }
    
    HRESULT hr = S_OK;
    if( KeyFrameRate < 0 )
    {
        // used to set default key frame rate, which we don't know
        // do nothing
    }
    else 
    {
        // check whether units match!
        hr = SetCompressionParamUsingIPropBag( g_wszWMVCKeyframeDistance, KeyFrameRate );
        if( SUCCEEDED( hr ) )
        {
            // update our internal copy 
            m_lKeyFrameRate = KeyFrameRate;
        }
    }        
    return hr;
}

// make key frames this often
//
HRESULT CWrapperOutputPin::get_KeyFrameRate(long FAR* pKeyFrameRate)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_KeyFrameRate")));
    if( NULL == pKeyFrameRate )
        return E_POINTER;
        
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_KeyFrameRate( pKeyFrameRate );
    }
    
    // wm codecs don't support a get, so just return the current internal value
    *pKeyFrameRate = m_lKeyFrameRate;

    return NOERROR;
}

// compress with this quality
//
HRESULT CWrapperOutputPin::put_Quality(double Quality)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_Quality")));

    CAutoLock lck(&(Filter()->m_csFilter));
    
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_Quality( Quality );
    }
    
    HRESULT hr = S_OK;
    if (Quality < 0)
    {
        // used to set default quality, except we don't know how to find out what this is!
        // so do nothing, for now
    }        
    else if (Quality >= 0. && Quality <= 1.)
    {    
        // check whether units match!
        long lQuality = (long)( Quality * DMO_COMPRESSION_QUALITY_MAX );
        hr = SetCompressionParamUsingIPropBag( g_wszWMVCCrisp, lQuality );
        if( SUCCEEDED( hr ) )
        {
            // update our internal copy 
            m_lQuality = lQuality;
        }
    }        
    else
    {    
        hr = E_INVALIDARG;
    }        
    return hr;
}

// compress with this quality
//
HRESULT CWrapperOutputPin::get_Quality(double FAR* pQuality)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_Quality")));
    if( NULL == pQuality )
        return E_POINTER;
        
    CAutoLock lck(&(Filter()->m_csFilter));
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_Quality( pQuality );
    }
        
    // scale the dmo encoder's bounds to 0-1, hmm...?
    if( m_lQuality < 0 )
    {
        // assume default
        *pQuality = -1.;
    }
    else
    {
        // wm codecs don't support a get, so just return the current internal value
        *pQuality = m_lQuality / (double)DMO_COMPRESSION_QUALITY_MAX; // ?
    }
    return NOERROR;
}


// every frame must fit in the data rate...
//
HRESULT CWrapperOutputPin::put_WindowSize(DWORDLONG WindowSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::put_WindowSize")));

    CAutoLock lck(&(Filter()->m_csFilter));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->put_WindowSize( WindowSize );
    }
    
    return E_NOTIMPL;
}


// every frame must fit in the data rate... we don't do the WindowSize thing
//
HRESULT CWrapperOutputPin::get_WindowSize(DWORDLONG FAR* pWindowSize)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::get_WindowSize")));

    if (pWindowSize == NULL)
        return E_POINTER;

    CAutoLock lck(&(Filter()->m_csFilter));
    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->get_WindowSize( pWindowSize );
    }
    
    *pWindowSize = 1;   // we don't do windows
    return NOERROR;
}


// make this frame a key frame, whenever it comes by
//
HRESULT CWrapperOutputPin::OverrideKeyFrame(long FrameNumber)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::OverrideKeyFrame")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->OverrideKeyFrame( FrameNumber );
    }
    
    // not needed currently
    return E_NOTIMPL;
}

// make this frame this size, whenever it comes by
//
HRESULT CWrapperOutputPin::OverrideFrameSize(long FrameNumber, long Size)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::OverrideFrameSize")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->OverrideFrameSize( FrameNumber, Size );
    }
    
    // not needed currently
    return E_NOTIMPL;
}


// Get some information about the codec
//
HRESULT CWrapperOutputPin::GetInfo
(   
    LPWSTR pstrVersion, 
    int *pcbVersion, 
    LPWSTR pstrDescription, 
    int *pcbDescription, 
    long FAR* pDefaultKeyFrameRate, 
    long FAR* pDefaultPFramesPerKey, 
    double FAR* pDefaultQuality, 
    long FAR* pCapabilities
)
{
    DbgLog((LOG_TRACE,5,TEXT("CWrapperOutputPin - IAMVideoCompression::GetInfo")));

    if( m_bUseIAMVideoCompressionOnDMO )
    {
        CComQIPtr< IAMVideoCompression, &IID_IAMVideoCompression > pVideoCompressionOnDMO( Filter()->m_pMediaObject );
        ASSERT( pVideoCompressionOnDMO );
        return pVideoCompressionOnDMO->GetInfo(
                                                pstrVersion, 
                                                pcbVersion, 
                                                pstrDescription, 
                                                pcbDescription, 
                                                pDefaultKeyFrameRate, 
                                                pDefaultPFramesPerKey, 
                                                pDefaultQuality, 
                                                pCapabilities );
    }
    
    // there's no way to query default settings for wm codecs currently?
    return E_NOTIMPL;
    
#if 0    
    CAutoLock lck(&(Filter()->m_csFilter));

    // for ICM we did this...
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = ICGetDefaultKeyFrameRate(hic);
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        // scale this 0-1
        *pDefaultQuality = ICGetDefaultQuality(hic) / (double)ICQUALITY_HIGH;
    if (pCapabilities) 
    {
        *pCapabilities = 0;
            if (dw > 0) 
        {
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_QUALITY) ?
                CompressionCaps_CanQuality : 0);
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_CRUNCH) ?
                CompressionCaps_CanCrunch : 0);
            *pCapabilities |= ((icinfo.dwFlags & VIDCF_TEMPORAL) ?
                CompressionCaps_CanKeyFrame : 0);
            // we don't do b frames
        }
    }

    // We have no version string, but we have a description
    if (pstrVersion)
        *pstrVersion = 0;
    if (pcbVersion)
        *pcbVersion = 0;
    if (dw > 0) 
    {
        if (pstrDescription && pcbDescription)
            lstrcpynW(pstrDescription, (LPCWSTR)&icinfo.szDescription,
            min(*pcbDescription / 2,
            lstrlenW((LPCWSTR)&icinfo.szDescription) + 1));
        if (pcbDescription)
            // string length in bytes, incl. NULL
            *pcbDescription = lstrlenW((LPCWSTR)&icinfo.szDescription) * 2 + 2;
    } 
    else 
    {
        if (pstrDescription) 
        {
            *pstrDescription = 0;
            if (pcbDescription)
                *pcbDescription = 0;
        }
    }

    return NOERROR;
#endif    
}

HRESULT CWrapperOutputPin::SetCompressionParamUsingIPropBag
( 
    const WCHAR * wszParam,
    const LONG    lValue
)
{
    HRESULT hr = E_NOTIMPL;
    
    //
    // wm codecs support setting of compression properties through IPropertyBag, try this first
    //
    CComQIPtr< IPropertyBag, &IID_IPropertyBag > pPropBag( Filter()->m_pMediaObject );
    if( !pPropBag )
    {
        DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin::SetCompressionParamUsingIPropBag - DMO doesn't support IPropertyBag for compression setting") ) );
    }
    else
    {
        // attempt to set the property
        VARIANT var;
        
        V_VT( &var ) = VT_I4;
        V_I4( &var ) = lValue; 
    
        hr = pPropBag->Write( wszParam, &var );
#ifdef DEBUG
        if( FAILED( hr ) )
        {
            DbgLog((LOG_TRACE,
                3,
                TEXT("CWrapperOutputPin::SetCompressionParamUsingIPropBag - DMO supports IPropertyBag but not %ls setting"),
                wszParam ) );
        }
#endif        
    }
    return hr;
}

bool CWrapperOutputPin::IsAudioEncoder()
{
    if(Filter()->m_guidCat == DMOCATEGORY_AUDIO_ENCODER)
        return true;
    else 
        return false;
}
bool CWrapperOutputPin::IsVideoEncoder()
{
    if(Filter()->m_guidCat == DMOCATEGORY_VIDEO_ENCODER)
        return true;
    else 
        return false;
}

bool CWrapperOutputPin::IsInputConnected()
{
    for (DWORD cIn = 0; cIn < Filter()->m_cInputPins; cIn++) 
    {
        if (Filter()->InputMapsToOutput(cIn, m_Id) &&
            !(Filter()->m_pInputPins[cIn]->IsConnected())) 
        { 
            // some input not connected
            return false;
        }
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\wmcodecstrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmcodecids.h
//
//--------------------------------------------------------------------------

#ifndef __WMCODECSTRS_H_
#define __WMCODECSTRS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// Configuration options for Windows Media Video Codecs
//

static const WCHAR *g_wszWMVCDatarate = L"_DATARATE";
static const WCHAR *g_wszWMVCKeyframeDistance = L"_KEYDIST";
static const WCHAR *g_wszWMVCCrisp = L"_CRISP";
static const WCHAR *g_wszWMVCTotalWindow = L"_TOTALWINDOW";
static const WCHAR *g_wszWMVCVideoWIndow = L"_VIDEOWINDOW";
static const WCHAR *g_wszWMVCFrameCount = L"_FRAMECOUNT";
static const WCHAR *g_wszWMVCLiveEncode = L"_LIVEENCODE";
static const WCHAR *g_wszWMVCComplexityMode = L"_COMPLEXITY";
static const WCHAR *g_wszWMVCPacketOverhead = L"_ASFOVERHEADPERFRAME";

#endif  // !defined(__WMCODECSTRS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfread\asfread.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.


/* This goes in the factory template table to create new instances */
CUnknown *CreateASFReaderInstance(LPUNKNOWN, HRESULT *);

extern const AMOVIESETUP_FILTER sudWMAsfRead;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\outpin.h ===
#ifndef __OUTPIN_H__
#define __OUTPIN_H__

#include "filter.h"

//   Almost nothing to override
class CWrapperOutputPin : public CBaseOutputPin, 
                          public IAMStreamConfig,
                          public IAMVideoCompression
{
    friend class CMediaWrapperFilter; // stuff at the bottom is owned by the filter

public:
    DECLARE_IUNKNOWN

    CWrapperOutputPin(CMediaWrapperFilter *pFilter,
                           ULONG Id,
                           BOOL bOptional,
                           HRESULT *phr);
    ~CWrapperOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);

    HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
    );

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    //  Override to unset media type
    HRESULT BreakConnect();

    // override to work around broken wm encoders which need a bitrate to connect, for
    // use when connecting directly to the ASF writer filter
    STDMETHODIMP Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
    
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // IAMStreamConfig methods
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    // IAMVideoCompression methods 
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate);
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate);
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality);
    STDMETHODIMP get_Quality(double FAR* pQuality);
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize);
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize);
    STDMETHODIMP OverrideKeyFrame(long FrameNumber);
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size);
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);


protected:
    CMediaWrapperFilter *Filter() const
    {
        return static_cast<CMediaWrapperFilter *>(m_pFilter);
    }
    ULONG m_Id;
    CCritSec m_csStream;

    BOOL m_fNoPosPassThru;
    CPosPassThru* m_pPosPassThru;
    CCritSec m_csPassThru;

    // This stuff is owned by the filter and is declared here for allocation convenience
    IMediaSample*      m_pMediaSample;
    CStaticMediaBuffer m_MediaBuffer;
    bool m_fStreamNeedsBuffer;  // per-output-stream flag local to SuckOutOutput()
    bool m_fEOS;                // indicates we have already delivered an EOS on this stream
    bool m_fNeedsPreviousSample;
    bool m_fAllocatorHasOneBuffer;

    //  Only valid between GetDeliveryBuffer and Deliver for video
    bool m_fNeedToRelockSurface;

    //  Set when OutputSetType is called
    bool m_fVideo;

    // IAMStreamConfig helpers
    bool IsAudioEncoder();
    bool IsVideoEncoder();
    bool IsInputConnected();
    // used for dmo encoders that natively support these interfaces
    bool m_bUseIAMStreamConfigOnDMO;
    bool m_bUseIAMVideoCompressionOnDMO;

    HRESULT SetCompressionParamUsingIPropBag(const WCHAR * wszParam, const LONG lValue);
    
    // compression params for IAMVideoCompression, move to struct eventually
    long m_lKeyFrameRate;
    long m_lQuality;
    
    AM_MEDIA_TYPE       *m_pmtFromSetFormat;

};

#endif //__OUTPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfcopy\asfcopy.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <wmsdk.h>
#include <atlbase.h>

#include <atlimpl.cpp>

#include <stdio.h>

#include <dshowasf.h>


void ListProfiles()
{
    USES_CONVERSION;
    
    int wextent = 0 ;
    int Loop = 0 ;
    SIZE extent ;
    DWORD cProfiles = 0 ;

    printf("Standard system profiles:\n");
    
    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = WMCreateProfileManager( &pIWMProfileManager );
    if( FAILED( hr ) )
    {   
        return; // return error!
    }        
        
    hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    if( FAILED( hr ) )
    {
        return;
    }
        
    //    
    // now load the profile strings
    //    
    LRESULT ix;
    DWORD cchName, cchDescription;
    for (int i = 0; i < (int)cProfiles; ++i) {
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( i, &pIWMProfile );
        if( FAILED( hr ) )
            return;
            
        hr = pIWMProfile->GetName( NULL, &cchName );
        if( FAILED( hr ) )
            return;
            
        WCHAR *wszProfile = new WCHAR[ cchName + 1 ]; // + 1? check
        if( NULL == wszProfile )
            return;
            
        hr = pIWMProfile->GetName( wszProfile, &cchName );
        if( FAILED( hr ) )
            return;
        
        hr = pIWMProfile->GetDescription( NULL, &cchDescription );
        if( FAILED( hr ) )
            return;
            
        WCHAR *wszDescription = new WCHAR[ cchDescription + 1 ]; // + 1? assume so, check
        if( NULL == wszDescription )
            return;
            
        
        hr = pIWMProfile->GetDescription( wszDescription, &cchDescription );
        if( FAILED( hr ) )
            return;
        

        // print the string to the list box.
        //
//        printf("  %3d:  %ls - %ls\n", i, wszProfile, wszDescription);
        printf("  %3d:  %ls\n", i, wszProfile);
        
        delete[] wszProfile;
        delete[] wszDescription;
    }

}



//=======================
// CreateFilterGraph
//=======================

BOOL CreateFilterGraph(IGraphBuilder **pGraph)
{
    HRESULT hr; // return code

    hr = CoCreateInstance(CLSID_FilterGraph, // get the graph object
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IGraphBuilder,
			  (void **) pGraph);

    if (FAILED(hr)) {
	*pGraph = NULL;
	return FALSE;
    }

    return TRUE;
}


BOOL CreateFilter(REFCLSID clsid, IBaseFilter **ppFilter)
{
    HRESULT hr;

    hr = CoCreateInstance(clsid,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IBaseFilter,
			  (void **) ppFilter);

    if (FAILED(hr)){
	*ppFilter = NULL;
	return FALSE;
    }

    return TRUE;
}


HRESULT SetNoClock(IFilterGraph *graph)
{
    // Keep a useless clock from being instantiated....
    IMediaFilter *graphF;
    HRESULT hr = graph->QueryInterface(IID_IMediaFilter, (void **) &graphF);

    if (SUCCEEDED(hr)) {
	hr = graphF->SetSyncSource(NULL);
	graphF->Release();
    }

    return hr;
}



class CKeyProvider : public IServiceProvider {
public:
    //
    // IUnknown interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    CKeyProvider();

    // IServiceProvider
    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv);
    
private:
    ULONG m_cRef;
};

CKeyProvider::CKeyProvider() : m_cRef(0)
{
}


//////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//
//////////////////////////////////////////////////////////////////////////

//
// AddRef
//
ULONG CKeyProvider::AddRef()
{
    return ++m_cRef;
}

//
// Release
//
ULONG CKeyProvider::Release()
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef == 0) {
        delete this;

        // don't return m_cRef, because the object doesn't exist anymore
        return((ULONG) 0);
    }

    return(m_cRef);
}

//
// QueryInterface
//
// We only support IUnknown and IServiceProvider
//
HRESULT CKeyProvider::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
        *ppv = (void *) static_cast<IServiceProvider *>(this);
        AddRef();
        return NOERROR;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP CKeyProvider::QueryService(REFIID siid, REFIID riid, void **ppv)
{
    if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {
        IUnknown *punkCert;
        
        HRESULT hr = WMCreateCertificate(&punkCert);

        if (SUCCEEDED(hr)) {
            *ppv = (void *) punkCert;
        }

        return hr;
    }
    return E_NOINTERFACE;
}




HRESULT GetPin(IBaseFilter *pFilter, DWORD dwPin, IPin **ppPin)
{
    IEnumPins *pins;

    HRESULT hr = pFilter->EnumPins(&pins);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("EnumPins failed!  (%x)\n"), hr));

	return hr;
    }

    if (dwPin > 0) {
	hr = pins->Skip(dwPin);
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) failed!  (%x)\n"), dwPin, hr));

	    return hr;
	}

	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) ran out of pins!\n"), dwPin));

	    return hr;
	}

    }

    DWORD n;
    hr = pins->Next(1, ppPin, &n);

    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("Next() failed!  (%x)\n"), hr));
    }

    if (hr == S_FALSE) {
	DbgLog((LOG_ERROR,1,TEXT("Next() ran out of pins!  \n")));

	return hr;
    }

    pins->Release();

    return hr;
}


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    WCHAR SourceFile[256];
    WCHAR TargetFile[256];

    BOOL fVerbose = FALSE;
    BOOL fListProfiles = TRUE;
    DWORD dwProfile;

    int i = 1;
    while (i < argc && (argv[i][0] == '-' || argv[i][0] == '/')) {
	// options

        if (lstrcmpiA(argv[i] + 1, "v") == 0) {
            fVerbose = TRUE;
        } else if ((i+1 < argc) && lstrcmpiA(argv[i] + 1, "p") == 0) {
            fListProfiles = FALSE;
            dwProfile = atoiA(argv[i+1]);
            i++;  // skip two args here
        } 

	i++;
    }

    if (fListProfiles) {
        printf("usage: copyfile [/v] /p profnum file1 [ file2 ...] target\n");
        HRESULT hr = CoInitialize(NULL);

        ListProfiles();

        CoUninitialize();
        
        return -1;
    }
        
    if (argc < i+2) {
        printf("usage: copyfile [/v] /p profnum file1 [ file2 ...] target\n");
        return -1;
    }

    HRESULT hr = CoInitialize(NULL);

    MultiByteToWideChar(CP_ACP, 0, argv[argc - 1], -1,
				    TargetFile, 256);

    IGraphBuilder *pGraph;
    hr = CreateFilterGraph(&pGraph);
    if (FAILED(hr)) {
        printf("couldn't create filter graph, hr=%x", hr);
        return -1;
    }
    
    CKeyProvider prov;
    prov.AddRef();  // don't let COM try to free our static object

    // give the graph a pointer to us for callbacks & QueryService
    IObjectWithSite* pObjectWithSite = NULL;
    hr = pGraph->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
    if (SUCCEEDED(hr))
    {
	pObjectWithSite->SetSite((IUnknown *) (IServiceProvider *) &prov);
	pObjectWithSite->Release();
    }

    
    IBaseFilter *pMux, *pWriter = NULL;
    
    hr = CreateFilter(CLSID_WMAsfWriter, &pMux);

    IFileSinkFilter *pFS;
    hr = pMux->QueryInterface(IID_IFileSinkFilter, (void **) &pFS);

    if (FAILED(hr)) {
        // I guess we need a writer also!
        hr = CreateFilter(CLSID_FileWriter, &pWriter);

        hr = pWriter->QueryInterface(IID_IFileSinkFilter, (void **) &pFS);
    }

    hr = pFS->SetFileName(TargetFile, NULL);

    pFS->Release();
    
    hr = pGraph->AddFilter(pMux, L"Mux");

    // set interleaving mode to FULL (should this be a command line option?)
    // !!! ASF won't support this, that's okay
    IConfigInterleaving * pConfigInterleaving;
    hr = pMux->QueryInterface(IID_IConfigInterleaving, (void **) &pConfigInterleaving);
    if (SUCCEEDED(hr)) {
	printf("Setting interleaving mode to INTERLEAVE_FULL\r\n");
	hr = pConfigInterleaving->put_Mode(INTERLEAVE_FULL);
	pConfigInterleaving->Release();
    }


    // !!! we should only require a profile if we're using a filter which needs it
    IConfigAsfWriter * pConfigAsfWriter;
    hr = pMux->QueryInterface(IID_IConfigAsfWriter, (void **) &pConfigAsfWriter);
    if (SUCCEEDED(hr)) {
	printf("Setting profile to %d\r\n");
	hr = pConfigAsfWriter->ConfigureFilterUsingProfileId(dwProfile);
	pConfigAsfWriter->Release();

        // !!! print out the long description of the profile?
    }
    
    pMux->Release();

    if (pWriter) {
        hr = pGraph->AddFilter(pWriter, L"Writer");
        IPin *pMuxOut, *pWriterIn;
        hr = GetPin(pMux, 0, &pMuxOut);
        hr = GetPin(pWriter, 0, &pWriterIn);

        hr = pGraph->ConnectDirect(pMuxOut, pWriterIn, NULL);

        pMuxOut->Release(); pWriterIn->Release();

        pWriter->Release();

        if (fVerbose)
            printf("Connected Mux and writer, hr = %x\n", hr);
    }
    
    SetNoClock(pGraph);


    // !!! use RenderEx here?
    while (i < argc - 1) {
	MultiByteToWideChar(CP_ACP, 0, argv[i], -1,
					SourceFile, 256);

	printf("Copying %ls to %ls\n", SourceFile, TargetFile);

	hr = pGraph->RenderFile(SourceFile, NULL);

	if (fVerbose)
	    printf("RenderFile('%ls') returned %x\n", SourceFile, hr);

	++i;
    }

    IMediaControl *pGraphC;
    pGraph->QueryInterface(IID_IMediaControl, (void **) &pGraphC);
    
    pGraphC->Run();

    // now wait for completion....
    IMediaEvent *pEvent;
    pGraph->QueryInterface(IID_IMediaEvent, (void **) &pEvent);

    printf("Waiting for completion....\n");
    LONG lEvCode = 0;
    do {
        {
            MSG Message;

            while (PeekMessage(&Message, NULL, 0, 0, TRUE))
            {
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            }
        }
	hr = pEvent->WaitForCompletion(10, &lEvCode);

    } while (lEvCode == 0);
    if (fVerbose)
	printf("Done, event = %x  hr = %x\n", lEvCode, hr);
	
    pEvent->Release();

    pGraphC->Stop();
    pGraphC->Release();
	
    pGraph->Release();

    CoUninitialize();
    printf("all done.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfread\asfread.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// more things to do:
//
// Use IAMStreamSelect to allow turning on multiple video streams from an MBR file
// turn on user-provided clock, proxy DShow clock to WMSDK somehow
//      something to look at: if graph is paused, does SDK just run far ahead and eat memory?
//
// Get SetReceiveStreamSamples(TRUE) to work..... ok, it works, should we use it?
//                                      yes, currently on always.  allow turning it off somehow?
//
// implement additional interfaces for statistics, stream switch notifications?
// also support for markers--fire EC_MARKER_HIT?
// script commands? or will they just work?
//
// how to handle DRM properly?  -- fix when there are real certificates?
//
// test for non-local file playback--a few examples tried, live ones seem to work
//
// handle fast-forward/fast-rewind
//
// what about playlists?  additional support needed?  EC_EOS_SOON?
//
// need to pass client info down for logging...
//
// !!! check that timestamps are good for live stream
//
// probably need to pause the graph when we're buffering?
//
// also may need to return VFW_S_CANT_CUE from GetState....
//
// MBR currently completely broken.
//
// is it correct that we never let the WMSDK handle decompression?
//
// HTTP authentication won't work because we don't support the
// Credential interface
//
// report buffering progress
//
// ICustomSaveAs?  probably not necessary
//
// need new code to not do "user clock" for network sources, or,
// equivalently, to fall back to non-user-clock on failure
//

#include <streams.h>
#include <wmsdk.h>
#include <evcodei.h>
#include <wmsdkdrm.h>
#include <atlbase.h>

#include <initguid.h>
#include <qnetwork.h>



#include "asfreadi.h"

#pragma warning(disable:4355)

// if we have only one pin connected, we only need 1 or 2 buffers. any more,
// and we waste time every seek in paused state sending a bunch of frames that
// will never be used.
// But to avoid hanging, if >1 outpin is connected, we seem to need lots of
// buffering
//
#define LOW_BUFFERS 2
#define HIGH_BUFFERS 50

const int TIMEDELTA = 1000; // 1 sec clock tick if no clock
const int TIMEOFFSET = 1000; // 1 sec delta between DShow and ASF clock

#define PREROLL_SEEK_WINDOW 660000

// The WM ASF Reader does not alter the media samples time stamps.
// Another words, it does not speed up or slow down the audio or 
// video.
extern const double NORMAL_PLAYBACK_SPEED = 1.0;

WM_GET_LICENSE_DATA * CloneGetLicenseData( WM_GET_LICENSE_DATA * pGetLicenseData );
WM_INDIVIDUALIZE_STATUS * CloneIndividualizeStatusData( WM_INDIVIDUALIZE_STATUS * pIndStatus );

/*  Internal classes */

void CASFReader::_IntSetStart( REFERENCE_TIME Start )
{
    m_rtStart = Start;
}

CASFReader::CASFReader(LPUNKNOWN pUnk, HRESULT   *phr) :
           CBaseFilter(NAME("CASFReader"), pUnk, &m_csFilter, CLSID_WMAsfReader),
           m_OutputPins(NAME("CASFReader output pin list")),
           m_bAtEnd(FALSE),
           m_fSentEOS( FALSE ),
           m_hrOpen( S_OK ),
           m_fGotStopEvent( FALSE ),
           m_pFileName(NULL),
           m_Rate(NORMAL_PLAYBACK_SPEED),
           m_pReader(NULL),
           m_pReaderAdv(NULL),
           m_pReaderAdv2(NULL),
           m_pWMHI(NULL),
           m_pCallback(NULL),
           m_qwDuration(0),
           m_pStreamNums(NULL),
           m_lStopsPending( -1 ),
           m_bUncompressedMode( FALSE )
{
    m_pCallback = new CASFReaderCallback(this);

    if (!m_pCallback)
        *phr = E_OUTOFMEMORY;
    else
        m_pCallback->AddRef();
}

CASFReader::~CASFReader()
{
    delete [] m_pFileName;
    delete [] m_pStreamNums;
    RemoveOutputPins();
}

/* CBaseFilter */
int CASFReader::GetPinCount()
{
    CAutoLock lck(m_pLock);
    int n = 0;
    
    if( m_bUncompressedMode )
    {
        // we don't disable any outputs in uncompressed mode
        n = m_OutputPins.GetCount();
    }
    else
    {    
        POSITION pos = m_OutputPins.GetHeadPosition();
        while (pos) {
            CASFOutput *pPin = m_OutputPins.GetNext(pos);

            WMT_STREAM_SELECTION sel = WMT_OFF;
            m_pReaderAdv->GetStreamSelected((WORD) pPin->m_idStream, &sel);
    
            if (sel != WMT_OFF)
                ++n;
        }                
    }

    return n;
}

CBasePin *CASFReader::GetPin(int n) {
    CAutoLock lck(m_pLock);

    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        CASFOutput *pPin = m_OutputPins.GetNext(pos);
        
        WMT_STREAM_SELECTION sel = WMT_ON;
        if( !m_bUncompressedMode )
        {        
            // just count streams that are on
            m_pReaderAdv->GetStreamSelected((WORD) pPin->m_idStream, &sel);
        }
        if (sel != WMT_OFF) 
        {
            if (n-- == 0) 
            {
                return pPin;
            }
        }
    }
    return NULL;
}

// override Stop to sync with inputpin correctly
STDMETHODIMP
CASFReader::Stop()
{
    DbgLog((LOG_TRACE, 1, TEXT("*** CASFReader STOP ***")));

    if( !m_pReader )
        return E_FAIL;

    if (m_State != State_Stopped) 
    {
        HRESULT hr = CallStop(); // StopPushing();
        ASSERT(SUCCEEDED(hr));
    }
    return CBaseFilter::Stop();
}


// override Pause?
STDMETHODIMP
CASFReader::Pause()
{
    if( !m_pReader )
        return E_FAIL;

    HRESULT hr = S_OK;
    if (m_State == State_Stopped) {
        
        DbgLog((LOG_TRACE, 1, TEXT("*** CASFReader PAUSE ***")));
    
        // and do the normal active processing
        POSITION pos = m_OutputPins.GetHeadPosition();
        while (pos) {
            CASFOutput *pPin = m_OutputPins.GetNext(pos);
            if (pPin->IsConnected()) {
                pPin->Active();
            }
        }

        hr = StartPushing();

        if (SUCCEEDED(hr)) {
            m_State = State_Paused;
        }
        
    } else if (m_State == State_Running) {
        // !!! don't pause the reader!
	// !!! or should we???
        m_State = State_Paused;
    } else {



    }

    return hr;
}


// override Run to only start timers when we're really running
STDMETHODIMP
CASFReader::Run(REFERENCE_TIME tStart)
{
    if( !m_pReader )
        return E_FAIL;

    // !!! Resume the reader if we were paused?
    
    // should we need to care here?
    return CBaseFilter::Run(tStart);
}


// Override GetState to signal Pause failures
STDMETHODIMP
CASFReader::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    return CBaseFilter::GetState(dwMSecs, State);
}


/* Overriden to say what interfaces we support and where */
STDMETHODIMP
CASFReader::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we have this interface? */

    if (riid == IID_IFileSourceFilter) {
        return GetInterface(static_cast<IFileSourceFilter *>(this), ppv);
    }

    if (riid == IID_IAMExtendedSeeking) {
        return GetInterface(static_cast<IAMExtendedSeeking *>(this), ppv);
    }

    if (riid == IID_IWMHeaderInfo) {
        return GetInterface(static_cast<IWMHeaderInfo *>(this), ppv);
    }

    if (riid == IID_IWMReaderAdvanced) {
        return GetInterface(static_cast<IWMReaderAdvanced *>(this), ppv);
    }
    
    if (riid == IID_IWMReaderAdvanced2) {
        return GetInterface(static_cast<IWMReaderAdvanced2 *>(this), ppv);
    }

    if (riid == IID_IServiceProvider) {
        return GetInterface(static_cast<IServiceProvider *>(this), ppv);
    }
    
    return CBaseFilter::NonDelegatingQueryInterface(riid,ppv);
}


/*  Remove our output pins */
void CASFReader::RemoveOutputPins(BOOL fReleaseStreamer)
{
    for (;;) {
        CASFOutput *pPin = m_OutputPins.RemoveHead();
        if (pPin == NULL) {
            break;
        }
        IPin *pPeer = pPin->GetConnected();
        if (pPeer != NULL) {
            pPeer->Disconnect();
            pPin->Disconnect();
        }
        pPin->Release();
    }
    IncrementPinVersion();

    if (fReleaseStreamer) {
        if (m_pWMHI) {
            m_pWMHI->Release();
            m_pWMHI = NULL;
        }
        if (m_pReaderAdv) {
            m_pReaderAdv->Release();
            m_pReaderAdv = NULL;
        }
        if (m_pReaderAdv2) {
            m_pReaderAdv2->Release();
            m_pReaderAdv2 = NULL;
        }
        
        if (m_pReader) {
            DbgLog((LOG_TRACE, 1, TEXT("Closing reader, waiting for callback")));
            HRESULT hrClose = m_pReader->Close();

            if (hrClose == S_OK) 
            {
                m_evOpen.Wait();
            }
            m_pReader->Release();
            m_pReader = NULL;
        }
        if (m_pCallback) {
            m_pCallback->Release();
            m_pCallback = NULL;
        }
    }
}


HRESULT DumpAttributes(IWMHeaderInfo *pHeader)
{
    HRESULT hr = S_OK;
#ifdef DEBUG
    WORD i, wAttrCnt;

    hr = pHeader->GetAttributeCount( 0, &wAttrCnt );
    if ( FAILED( hr ) )
    {
        DbgLog((LOG_TRACE, 2, TEXT(" GetAttributeCount Failed %x\n"), hr ));
        return( hr );
    }

    for ( i = 0; i < wAttrCnt ; i++ )
    {
        WORD wStream = 0xffff;
        WCHAR  wName[512];
        WORD cbNamelen = sizeof(wName) / sizeof(wName[0]);
        WMT_ATTR_DATATYPE type;
        BYTE pValue[512];
        WORD cbLength = sizeof(pValue);

        hr = pHeader->GetAttributeByIndex( i, &wStream, wName, &cbNamelen, &type, pValue, &cbLength );
        if ( FAILED( hr ) && (hr != ASF_E_BUFFERTOOSMALL) ) 
        {
            DbgLog((LOG_TRACE, 2,  TEXT("GetAttributeByIndex (%d/%d) Failed %x"), i, wAttrCnt, hr ));
            return( hr );
        }

        switch ( type )
        {
        case WMT_TYPE_DWORD:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:  %d"), wName, *((DWORD *) pValue) ));
            break;
        case WMT_TYPE_STRING:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   %ls"), wName, (WCHAR *) pValue ));
            break;
        case WMT_TYPE_BINARY:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   Type = Binary of Length %d"), wName, cbLength));
        {
            char achHex[65];
            for (int j = 0; j < cbLength; j+= 32) {
                for (int k = 0; k < 32 && j + k < cbLength; k++) {
                    wsprintfA(achHex+k*2, "%02x", pValue[j+k]);
                }

                DbgLog((LOG_TRACE, 2, TEXT("     %hs"), achHex));
            }
        }
            break;
        case WMT_TYPE_BOOL:
            DbgLog((LOG_TRACE, 2, TEXT("%ls:   %hs"), wName, ( * ( ( BOOL * ) pValue) ? "true" : "false" ) ));
            break;
        default:
            break;
        }
    }
#endif

    return hr;
}


// Override JoinFilterGraph so that we can delay loading a file until we're in a graph
STDMETHODIMP
CASFReader::JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    if (SUCCEEDED(hr) && m_pGraph && m_pFileName && !m_pReader) {
        hr = LoadInternal();
        if( FAILED( hr ) )
        {
            // uh-oh, we'll fail to join, but the base class thinks we did, so we 
            // need to unjoin the base class
            CBaseFilter::JoinFilterGraph(NULL, NULL);
        }            
    }
    
    return hr;
}


STDMETHODIMP
CASFReader::Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(pszFileName, E_POINTER);

    // is there a file loaded at the moment ?
    if (m_pFileName)
        return E_FAIL;

    //
    // Record the file name for GetCurFile
    //
    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName==NULL) {
        return E_OUTOFMEMORY;
    }
    
    lstrcpyW(m_pFileName, pszFileName);

    if (!m_pGraph)
        return S_OK;

    return LoadInternal();
}

HRESULT CASFReader::LoadInternal()
{
    ASSERT(m_pGraph);

    HRESULT hr = S_OK;
    if( !m_pReader )
    {
        IObjectWithSite *pSite;
        
        hr = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
        if (SUCCEEDED(hr)) {
            IServiceProvider *pSP;
            hr = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
            pSite->Release();
            
            if (SUCCEEDED(hr)) {
                IUnknown *pUnkCert;
                hr = pSP->QueryService(IID_IWMReader, IID_IUnknown, (void **) &pUnkCert);
                pSP->Release();
                if (SUCCEEDED(hr)) {
                    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
                    __try 
                    {
                        hr = WMCreateReader(pUnkCert, WMT_RIGHT_PLAYBACK, &m_pReader);
                        if( FAILED( hr ) )
                        {
                            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CASFReader::LoadInternal WMCreateReader returned %x"), hr));
                        }                    
                    }
                    __except (  EXCEPTION_EXECUTE_HANDLER ) 
                    {
                        DbgLog(( LOG_TRACE, 1,
                            TEXT("CASFReader - Exception calling WMCreateReader, probably due to wmvcore.dll not present. Aborting. ")));
                        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
                    }
                
                    pUnkCert->Release();
                    if( SUCCEEDED( hr ) )
                    {                    
                        DbgLog((LOG_TRACE, 3, TEXT("WMCreateReader succeeded")));
                    }
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: CASFReader::LoadInternal QueryService for certification returned %x"), hr));

                    // return dshow cert error
                    hr = VFW_E_CERTIFICATION_FAILURE;
                }
            }
            else
            {
                // return dshow cert error
                hr = VFW_E_CERTIFICATION_FAILURE;
            }        
        }
        else
        {
            hr = VFW_E_CERTIFICATION_FAILURE;
        }    
    }
    if ( !m_pReaderAdv && SUCCEEDED(hr)) {
        hr = m_pReader->QueryInterface(IID_IWMReaderAdvanced, (void **) &m_pReaderAdv);
    }
    
    HRESULT hrTmp;    
    if ( !m_pReaderAdv2 && SUCCEEDED(hr)) {
        hrTmp = m_pReader->QueryInterface(IID_IWMReaderAdvanced2, (void **) &m_pReaderAdv2);
    }
    
    if ( !m_pWMHI && SUCCEEDED(hr)) {
        // get header info, but it's okay if it's not there
        HRESULT hrWMHI = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &m_pWMHI);
    }
    
    if (SUCCEEDED(hr)) {
        hr = m_pReader->Open(m_pFileName, m_pCallback, NULL);

        DbgLog((LOG_TRACE, 2, TEXT("IWMReader::Open(%ls) returned %x"), m_pFileName, hr));
    } else if (m_pReader) {
        m_pReader->Release();
        m_pReader = NULL; // !!! work around bug #1365
    }

    if (SUCCEEDED(hr)) {
        m_evOpen.Wait();
        hr = m_hrOpen;
        DbgLog((LOG_TRACE, 2, TEXT("Finished waiting, callback returned %x"), hr));
    }
    
    m_bUncompressedMode = FALSE; // reset on new file
    
    if (SUCCEEDED(hr)) {        
        // get duration of file
        IWMHeaderInfo *pHeaderInfo;

        HRESULT hr2 = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
        if (SUCCEEDED(hr2)) {

            // random debug spew
            DumpAttributes(pHeaderInfo);
            
            WORD wStreamNum = 0xffff;
            WMT_ATTR_DATATYPE Type;
            WORD cbLength = sizeof(m_qwDuration);

            hr2 = pHeaderInfo->GetAttributeByName(&wStreamNum,
                                                    g_wszWMDuration,
                                                    &Type,
                                                    (BYTE *) &m_qwDuration,
                                                    &cbLength);

            if (SUCCEEDED(hr2)) {
                ASSERT(Type == WMT_TYPE_QWORD);

                DbgLog((LOG_TRACE, 2, TEXT("file duration = %dms"), (DWORD) (m_qwDuration / 10000)));

                m_rtStop = m_qwDuration;
                
                m_rtStart = 0;
            } else {
                DbgLog((LOG_TRACE, 2, TEXT("couldn't get duration of file, hr=%x"), hr2));
            }

            BOOL bIsDRM = FALSE;
            wStreamNum = 0xffff;
            cbLength = sizeof( BOOL );

            hr2 = pHeaderInfo->GetAttributeByName(&wStreamNum, // any DRM streams?
                                                    g_wszWMProtected,
                                                    &Type,
                                                    (BYTE *) &bIsDRM,
                                                    &cbLength);

            if (SUCCEEDED(hr2)) {
                ASSERT(Type == WMT_TYPE_BOOL);

                DbgLog((LOG_TRACE, 2, TEXT("Is this DRM'd content? %hs"), bIsDRM ? "true" : "false" ));
                if( bIsDRM )
                {
                    m_bUncompressedMode = TRUE;
                }
                
            } else {
                DbgLog((LOG_TRACE, 2, TEXT("couldn't get DRM attribute, hr=%x"), hr2));
            }

            pHeaderInfo->Release();
        }


        // error check?
        hr2 = m_pReaderAdv->SetReceiveSelectionCallbacks(TRUE);

    }
    
    if (SUCCEEDED(hr)) {
        IWMProfile *pProfile;
        hr = m_pReader->QueryInterface(IID_IWMProfile, (void **) &pProfile);
        if (SUCCEEDED(hr)) {
            DWORD cStreams;

            hr = pProfile->GetStreamCount(&cStreams);

            if (SUCCEEDED(hr)) {

                if( m_pStreamNums ) delete [] m_pStreamNums;
                m_pStreamNums = new WORD[cStreams];

                if( !m_pStreamNums ) 
                    hr = E_OUTOFMEMORY;
                else
                for (DWORD dw = 0; dw < cStreams; dw++) {
                    IWMStreamConfig *pConfig;

                    hr = pProfile->GetStream(dw, &pConfig);

                    if (FAILED(hr))
                        break;

                    WORD wStreamNum;
                    hr = pConfig->GetStreamNumber(&wStreamNum);
                    DbgLog((LOG_TRACE, 2, TEXT("Stream(%d) #%d"), dw, wStreamNum));
                    m_pStreamNums[dw] = wStreamNum;

                    WM_MEDIA_TYPE *pStreamType = NULL;
                    IWMMediaProps *pProps;
                    hr = pConfig->QueryInterface(IID_IWMMediaProps, (void **) &pProps);
                    if (SUCCEEDED(hr)) {
                        DWORD cbMediaType = 0;
                        hr = pProps->GetMediaType( NULL, &cbMediaType );
                        pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
                        if (pStreamType) {
                            hr = pProps->GetMediaType( pStreamType, &cbMediaType );

                            if (SUCCEEDED(hr)) {
                                DisplayType(TEXT("Media Type"), (AM_MEDIA_TYPE *) pStreamType);
                            }
                        }
                        
                        pProps->Release();
                    }
                    
                    if( !m_bUncompressedMode )
                    {                    
                        if (SUCCEEDED(hr)) {
                            hr  = m_pReaderAdv->SetReceiveStreamSamples(wStreamNum, TRUE);

                            DbgLog((LOG_TRACE, 2, TEXT("SetReceiveStreamSamples(%d) returned %x"), wStreamNum, hr));


                            WCHAR wszName[20];
                            if (pStreamType->majortype == MEDIATYPE_Video) {
                                wsprintfW(wszName, L"Raw Video %d", dw);
                            } else if (pStreamType->majortype == MEDIATYPE_Audio) {
                                wsprintfW(wszName, L"Raw Audio %d", dw);
                            } else {
                                wsprintfW(wszName, L"Raw Stream %d", dw);
                            }

                            // create new output pin, append to list
                            CASFOutput *pPin = new CASFOutput( this, wStreamNum, pStreamType, &hr, wszName );

                            if (pPin == NULL) {
                                hr = E_OUTOFMEMORY;
                            }

                            if (SUCCEEDED(hr)) {
                                pPin->m_cToAlloc = LOW_BUFFERS; // !!!                        
                                hr = m_pReaderAdv->GetMaxStreamSampleSize(wStreamNum, &pPin->m_cbToAlloc);
                                DbgLog((LOG_TRACE, 2, TEXT("Stream %d: \"%ls\"  max size = %d"),
                                        wStreamNum, wszName, pPin->m_cbToAlloc));

                                if (pPin->m_cbToAlloc <= 32) {
                                    DbgLog((LOG_TRACE, 2, TEXT("Got back really small number, using 64K instead")));
                                    pPin->m_cbToAlloc = 65536; // !!!
                                }
                            }

                            if (FAILED(hr)) {
                                delete[] pStreamType;
                                pConfig->Release();
                                delete pPin;
                                break;
                            }

                            /* Release() is called when the pin is removed from the list */
                            pPin->AddRef();
                            POSITION pos = m_OutputPins.AddTail(pPin);
                            if (pos == NULL) {
                                delete pPin;
                                hr = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hr)) {
                            hr = m_pReaderAdv->SetAllocateForStream(wStreamNum, TRUE);

                            DbgLog((LOG_TRACE, 2, TEXT("SetAllocateForStream(%d) returned %x"), wStreamNum, hr));
                        }
                    }                        

                    delete[] pStreamType;
                    pConfig->Release();
                }
            }

            pProfile->Release();
        }

        DWORD cOutputs;
        hr = m_pReader->GetOutputCount(&cOutputs);

        if (SUCCEEDED(hr)) 
        {
            for (DWORD dw = 0; dw < cOutputs; dw++) 
            {
                if( !m_bUncompressedMode )
                {                
                    // call SetOutputProps(NULL) to ask the WMSDK not to
                    // load any codecs for us, since we expose compressed
                    // data
                    hr = m_pReader->SetOutputProps(dw, NULL);
                    DbgLog((LOG_TRACE, 2, TEXT("SetOutputProps(%d, NULL) returned %x"), dw, hr));
                }
                else
                {
                    IWMOutputMediaProps *pOutProps;

                    hr = m_pReader->GetOutputProps(dw, &pOutProps);

                    if (FAILED(hr))
                        break;

#ifdef DEBUG
                    WCHAR wszStreamGroupName[256];
                    WCHAR wszConnectionName[256];

                    WORD wSize = 256;
                    HRESULT hrDebug = pOutProps->GetStreamGroupName(wszStreamGroupName, &wSize);
                    if (FAILED(hrDebug)) 
                    {
                        DbgLog((LOG_ERROR, 1, "Error calling GetStreamGroupName(%d)", dw));
                    } 
                    else 
                    {
                        wSize = 256;
                        hrDebug = pOutProps->GetConnectionName(wszConnectionName, &wSize);
                        DbgLog((LOG_TRACE, 2, "Stream %d: StreamGroup '%ls', Connection '%ls'",
                                dw, wszStreamGroupName, wszConnectionName));
                    }
#endif

                    DWORD cbMediaType = 0;
                    HRESULT hr = pOutProps->GetMediaType( NULL, &cbMediaType );
                    if (FAILED(hr)) {
                        pOutProps->Release();
                        break;
                    }
                
                    WM_MEDIA_TYPE *pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
                    if( NULL == pStreamType )
                    {
                        pOutProps->Release();
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    hr = pOutProps->GetMediaType( pStreamType, &cbMediaType );
                    if( FAILED( hr ) )
                    {
                        pOutProps->Release();
                        break;
                    }

                    WCHAR wszName[20];
                    if (pStreamType->majortype == MEDIATYPE_Video) 
                    {
                        wsprintfW(wszName, L"Video %d", dw);
                    } 
                    else if (pStreamType->majortype == MEDIATYPE_Audio) 
                    {
                        wsprintfW(wszName, L"Audio %d", dw);
                    } 
                    else 
                    {
                        wsprintfW(wszName, L"Stream %d", dw);
                    }

                    // create new output pin, append to list
                    CASFOutput *pPin = new CASFOutput( this, dw, pStreamType, &hr, wszName );

                    delete[] pStreamType;
                
                    if (pPin == NULL) {
                        hr = E_OUTOFMEMORY;
                    }

                    pOutProps->Release();
                    
                    if (SUCCEEDED(hr)) 
                    {
                        pPin->m_cToAlloc = LOW_BUFFERS; // !!!                        
                        hr = m_pReaderAdv->GetMaxOutputSampleSize(dw, &pPin->m_cbToAlloc);
                        DbgLog((LOG_TRACE, 2, "Stream %d: \"%ls\"  max size = %d",
                                dw, wszName, pPin->m_cbToAlloc));
                        
                        if (pPin->m_cbToAlloc <= 32) 
                        {
                            DbgLog((LOG_TRACE, 2, TEXT("Got back really small number, using 64K instead")));
                            pPin->m_cbToAlloc = 65536; // !!!
                        }
                    }

                    if (FAILED(hr)) 
                    {
                        delete pPin;
                        break;
                    }

                    /* Release() is called when the pin is removed from the list */
                    pPin->AddRef();
                    POSITION pos = m_OutputPins.AddTail(pPin);
                    if (pos == NULL) 
                    {
                        delete pPin;
                        hr = E_OUTOFMEMORY;
                    }
                    
                    if (SUCCEEDED(hr)) 
                    {
                        hr = m_pReaderAdv->SetAllocateForOutput((WORD)dw, TRUE);

                        DbgLog((LOG_TRACE, 2, TEXT("SetAllocateForOutput(%d) returned %x"), dw, hr));
                    }
                    
                }                    
            }
        }
    }

    if (SUCCEEDED(hr)) {
        HRESULT hrClock = m_pReaderAdv->SetUserProvidedClock(TRUE);

        DbgLog((LOG_TRACE, 2, TEXT("Setting user-provided clock (TRUE) returned %x"), hrClock));

        if (FAILED(hr)) {
            // !!! this is documented to not work with some sources, presumably network ones?
        }
    }
    
    // if it didn't work, clean up
    if ( NS_E_LICENSE_REQUIRED == hr) 
    {
        //
        // if we failed because a license is required don't release reader interfaces
        // to give app a chance to do license acquisition using this same reader instance
        //
        // but clear filename so that the app can recall Load after acquiring license
        //
        delete [] m_pFileName;
        m_pFileName = NULL;
    }
    else if (FAILED(hr) ) {
        RemoveOutputPins();
    }
    
    return hr;
}


STDMETHODIMP
CASFReader::GetCurFile(
		    LPOLESTR * ppszFileName,
		    AM_MEDIA_TYPE *pmt)
{
    // return the current file name

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        }
    }

    if (pmt) {
	pmt->majortype = GUID_NULL;   // Later!
	pmt->subtype = GUID_NULL;     // Later!
	pmt->pUnk = NULL;             // Later!
	pmt->lSampleSize = 0;         // Later!
	pmt->cbFormat = 0;            // Later!
    }

    return NOERROR;

}


/*  Send BeginFlush() downstream */
HRESULT CASFReader::BeginFlush()
{
    DbgLog((LOG_TRACE, 2, TEXT("Sending BeginFlush to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        HRESULT hr = pPin->DeliverBeginFlush();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 2, TEXT("Got %x from DeliverBeginFlush"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    return NOERROR;
}


    /*  Send EndFlush() downstream */
HRESULT CASFReader::EndFlush()
{
    DbgLog((LOG_TRACE, 2, TEXT("Sending EndFlush to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        HRESULT hr = pPin->DeliverEndFlush();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 2, TEXT("Got %x from DeliverEndFlush"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    return NOERROR;
}


HRESULT CASFReader::SendEOS()
{
    HRESULT hr;

    if (m_fSentEOS)
        return S_OK;

    m_fSentEOS = TRUE;
    
    DbgLog((LOG_TRACE, 1, TEXT("Sending EOS to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);

        hr = pPin->DeliverEndOfStream();

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 1, TEXT("Got %x from DeliverEndOfStream"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

#if 0
    //
    // See if we can already send the EC_EOS_SOON event so that the control can pre-load the next 
    // playlist element, if any. We don't want to send it too early, or else the next stream will
    // have to wait in its nssplit filter until this stream actually ends rendering
    // In other words, we try to return the codec to a position of zero credit, or otherwise 
    // we'll keep on accumulating early data at the client.
    // 
    m_fPendingEOSNotify = TRUE;
    ConsiderSendingEOSNotify();
#endif

    return NOERROR;
}

    
HRESULT CASFReader::CallStop()
{
    HRESULT hr = StopReader();    
    if (hr == S_OK) {
        m_evStartStop.Wait();
        hr = m_hrStartStop;
        DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() wait for StartStop event completed (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hr));
        if( SUCCEEDED( hr ) )
        {        
            // 
            // restore default streams selection state on successful stop, so unconnected pins don't 
            // disappear, in case we want to reconnect them next time
            //
            if( !m_bUncompressedMode )
            {    
                HRESULT hrTmp = SetupActiveStreams( TRUE ); 
#ifdef DEBUG        
                if( FAILED( hrTmp ) )
                {
                    DbgLog((LOG_TRACE, 1, TEXT("!!ERROR IWMReader::CallStop() SetupActiveStreams() failed (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hrTmp));
                }
#endif
            }
        }        
    }
    else
    {    
        DbgLog((LOG_TRACE, 1, TEXT("!!ERROR IWMReader::CallStop() failed with (m_pReader = 0x%08lx, hr = 0x%08lx)"), m_pReader, hr));
    }        
    return hr;
}

HRESULT CASFReader::StopReader()
{
    HRESULT hr = S_OK;
    if( 0 == InterlockedIncrement( &m_lStopsPending ) )
    {    
        hr = m_pReader->Stop();
        if( FAILED( hr ) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR - IWMReader::Stop() returned %x (m_pReader = 0x%08lx)"), hr, m_pReader));
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() returned %x (m_pReader = 0x%08lx)"), hr, m_pReader));
        }        
    }
    else
    {    
        DbgLog((LOG_TRACE, 5, TEXT("IWMReader::Stop() already pending (m_pReader = 0x%08lx)"), m_pReader));
    }
    return hr;
}

HRESULT CASFReader::SetupActiveStreams( BOOL bReset = FALSE )
{
    HRESULT hr = 0;

    ASSERT( !m_bUncompressedMode );

    CComPtr<IWMProfile> pProfile;
    hr = m_pReader->QueryInterface(IID_IWMProfile, (void **) &pProfile);
    if( FAILED( hr ) )
    {
        return hr;
    }

    DWORD cStreams;
    hr = pProfile->GetStreamCount(&cStreams);
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( cStreams == 0 )
    {
        return E_FAIL;
    }

    WORD * pAry = new WORD[cStreams];
    if( !pAry )
    {
        return E_OUTOFMEMORY;
    }

    WMT_STREAM_SELECTION * pSel = new WMT_STREAM_SELECTION[cStreams];
    if( !pSel )
    {
        delete [] pAry;
        return E_OUTOFMEMORY;
    }

    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();

    for( DWORD dw = 0 ; dw < cStreams ; dw++ )
    {
        pPin = (CASFOutput *) m_OutputPins.Get(pos);
        if( bReset )
        {
            pSel[dw] = pPin->m_selDefaultState;
        }
        else
        {        
            if( pPin->IsConnected( ) )
            {
                pSel[dw] = WMT_ON;
            }
            else
            {
                pSel[dw] = WMT_OFF;
            }
        }            
        pAry[dw] = m_pStreamNums[dw];
        pos = m_OutputPins.Next(pos);
    }
    if( !m_bUncompressedMode )
    {    
        hr = m_pReaderAdv->SetManualStreamSelection( TRUE );
        hr = m_pReaderAdv->SetStreamsSelected( (WORD) cStreams, pAry, pSel );
    }
            
    delete [] pSel;
    delete [] pAry;

    return hr;
}

HRESULT CASFReader::StopPushing()
{
    BeginFlush();

    CallStop();

    EndFlush();
    
    return S_OK;
}

HRESULT CASFReader::StartPushing()
{
    ASSERT( m_pReader );
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("Sending NewSegment to all outputs")));
    CASFOutput *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
	pPin = (CASFOutput *) m_OutputPins.Get(pos);
        pPin->m_bFirstSample = TRUE;
        pPin->m_nReceived = 0;
        pPin->m_bNonPrerollSampleSent = FALSE;

        hr = pPin->DeliverNewSegment(m_rtStart, m_rtStop, GetRate());

	if (hr != S_OK) {

	    // !!! handle return values
	    DbgLog((LOG_ERROR, 1, TEXT("Got %x from DeliverNewSegment"), hr));
	}	    

	pos = m_OutputPins.Next(pos);
    }

    m_fSentEOS = FALSE;
    if( !m_bUncompressedMode )
    {    
        hr = SetupActiveStreams( );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }        
    m_lStopsPending = -1; // ensure only 1 stop gets called
    
    hr = m_pReader->Start(m_rtStart, 0, (float) GetRate(), NULL);

    DbgLog((LOG_TRACE, 1, TEXT("IWMReader::Start(%s, %d) returns %x"), (LPCTSTR) CDisp(m_rtStart), 0, hr));

    if (SUCCEEDED(hr)) {
        m_evStartStop.Wait();

        // !!! delayed HRESULT?
        hr = m_hrStartStop;
    }
    return hr;
}

//
// IServiceProvider
//
STDMETHODIMP CASFReader::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (NULL == ppv) 
    {
        return E_POINTER;
    }
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;
    
    if (IID_IWMDRMReader == guidService) 
    {
        // !! return IWMDRMReader to allow license acquisition to work on same reader instance
        if( m_pReader )
        {
            //
            // For this interface we pass out the reader's interface directly. 
            //
            hr = m_pReader->QueryInterface( riid, (void **) ppv );
        }
        else
        {
            hr = E_FAIL;
        }            
    }
    return hr;
}


CASFOutput::CASFOutput(CASFReader *pFilter, DWORD dwID, WM_MEDIA_TYPE *pStreamType, HRESULT *phr, WCHAR *pwszName) :
       CBaseOutputPin(NAME("CASFOutput"),   // Object name
                      pFilter,
                      &pFilter->m_csFilter,               // CCritsec *
                      phr,
                      pwszName),
       m_Seeking(pFilter, this, GetOwner(), phr),
       m_pFilter(pFilter),
       m_idStream(dwID),
       m_pOutputQueue(NULL),
       m_bNonPrerollSampleSent( FALSE )
{

    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::CASFOutput - stream id %d"), m_idStream));

    m_mt.majortype = pStreamType->majortype;
    m_mt.subtype = pStreamType->subtype;
    if (m_mt.majortype == MEDIATYPE_Video) {
        ASSERT(m_mt.subtype == GetBitmapSubtype(HEADER(pStreamType->pbFormat)));
        m_mt.subtype = GetBitmapSubtype(HEADER(pStreamType->pbFormat));
	if ((HEADER(pStreamType->pbFormat))->biSizeImage == 0) {
	    HRESULT hr = m_pFilter->m_pReaderAdv->GetMaxStreamSampleSize((WORD) dwID, &(HEADER(pStreamType->pbFormat))->biSizeImage);
	    DbgLog((LOG_TRACE, 2, TEXT("Adjusting biSizeImage from 0 to %d"), (HEADER(pStreamType->pbFormat))->biSizeImage));
	}
    }

    if (m_mt.majortype == MEDIATYPE_Audio) {
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pStreamType->pbFormat;
        // ASSERT(m_mt.subtype.Data1 == wfx->wFormatTag);
        m_mt.subtype.Data1 = pwfx->wFormatTag;
        m_mt.lSampleSize = pwfx->nBlockAlign;
    }

    m_mt.bFixedSizeSamples = pStreamType->bFixedSizeSamples;
    m_mt.bTemporalCompression = pStreamType->bTemporalCompression;
    m_mt.lSampleSize = pStreamType->lSampleSize;
    m_mt.formattype = pStreamType->formattype;
    m_mt.SetFormat(pStreamType->pbFormat, pStreamType->cbFormat);

    //
    // cache stream's original select state (picked by wmsdk reader), 
    // since we deselect unconnected pin streams on pause/run 
    // and use this to restore the original stream select state on stop
    //
    m_selDefaultState = WMT_OFF;
    m_pFilter->m_pReaderAdv->GetStreamSelected( (WORD)m_idStream, &m_selDefaultState);

    // !!! *phr = hr;
}


/*  Destructor */

CASFOutput::~CASFOutput()
{
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::~CASFOutput - stream id %d"), m_idStream));
}

// override say what interfaces we support where
STDMETHODIMP CASFOutput::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if( riid == IID_IMediaSeeking )
    {
        return( GetInterface( (IMediaSeeking *)&m_Seeking, ppv ) );
    }
    else
    {
        return( CBaseOutputPin::NonDelegatingQueryInterface( riid, ppv ) );
    }
}

/* Override revert to normal ref counting
   These pins cannot be finally Release()'d while the input pin is
   connected */

STDMETHODIMP_(ULONG)
CASFOutput::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CASFOutput::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}


// currently each output pin only supports one media type....
HRESULT CASFOutput::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    CAutoLock lck(m_pLock);

    if (iPosition < 0)  {
        return E_INVALIDARG;
    }

    if( m_pFilter->m_bUncompressedMode )
    {
        DWORD dwFormats;
        HRESULT hr = m_pFilter->m_pReader->GetOutputFormatCount(m_idStream, &dwFormats);
        if (iPosition >= (int) dwFormats) {
            return VFW_S_NO_MORE_ITEMS;
        }
    
        IWMOutputMediaProps *pOutProps;
        hr = m_pFilter->m_pReader->GetOutputFormat(m_idStream, iPosition, &pOutProps);

        DbgLog((LOG_TRACE, 2, "GetOutputFormat(%d  %d/%d)) returns %x", m_idStream, iPosition, dwFormats, hr));
        
        if (SUCCEEDED(hr)) {
            DWORD cbMediaType = 0;
            hr = pOutProps->GetMediaType( NULL, &cbMediaType );
            WM_MEDIA_TYPE *pStreamType = (WM_MEDIA_TYPE*)new BYTE[cbMediaType];
            if (pStreamType) {
                hr = pOutProps->GetMediaType( pStreamType, &cbMediaType );

                ASSERT(pStreamType->pUnk == NULL);
            
                if (SUCCEEDED(hr)) {
                    DisplayType(TEXT("Possible output mediatype"), (AM_MEDIA_TYPE *) pStreamType);
                    *pMediaType = *(AM_MEDIA_TYPE *) pStreamType;
                }
                delete[] pStreamType;
            }
            pOutProps->Release();
        
        }
        return hr; // no!
    }
    else
    {    
        if (iPosition > 0) {
            return VFW_S_NO_MORE_ITEMS;
        }

        *pMediaType = m_mt;
    }
    return S_OK;
}

HRESULT CASFOutput::CheckMediaType(const CMediaType *pmt)
{
    if( !m_pFilter->m_bUncompressedMode )
    {    
        if (*pmt == m_mt)
	    return S_OK;
    }
    else
    {
        int i = 0;

        while (1) {
            CMediaType mt;

            HRESULT hr = GetMediaType(i++, &mt);

            if (hr != S_OK)
                break;
                
            if (*pmt == mt)
            {                
                return S_OK;
            }                    
        }
    }    
    return S_FALSE;
}

HRESULT CASFOutput::SetMediaType(const CMediaType *mt)
{
    HRESULT hr = S_OK;
    if( m_pFilter->m_bUncompressedMode )
    {    
        IWMOutputMediaProps *pOutProps;
        HRESULT hr = m_pFilter->m_pReader->GetOutputProps(m_idStream, &pOutProps);
        if (SUCCEEDED(hr)) 
        {
            hr = pOutProps->SetMediaType((WM_MEDIA_TYPE *) mt);
            if (SUCCEEDED(hr)) 
            {
                hr = m_pFilter->m_pReader->SetOutputProps(m_idStream, pOutProps);
                if (SUCCEEDED(hr)) 
                {
                    CBaseOutputPin::SetMediaType(mt);
                }
            }
            pOutProps->Release();
        }            
    }
    
    // !!! override, don't let value change??? (in compressed case at least)
    return hr;
}

HRESULT CASFOutput::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    return CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
}

HRESULT CASFOutput::DecideBufferSize(IMemAllocator * pAlloc,
				     ALLOCATOR_PROPERTIES * pProp)
{
    HRESULT hr = NOERROR;

    if (m_cToAlloc != HIGH_BUFFERS) {
        POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
        while (pos) 
        {
            CASFOutput *pPin = m_pFilter->m_OutputPins.GetNext(pos);
            if (pPin && pPin != this && pPin->IsConnected())
            {
                // we only send 2 buffers when one pin's connected but because
                // of WMSDK limitations, we need to send 50 (or more) per pin when
                // we have 2 pins connected. (the reason is because audio or video could
                // have gaps in it, which without having 50 buffers per pin would cause a WMSDK
                // reader deadlock).

                ASSERT( pPin->m_pAllocator );

                if( pPin->m_pAllocator )
                {
                    ALLOCATOR_PROPERTIES Props;
                    ZeroMemory( &Props, sizeof( Props ) );
                    hr = pPin->m_pAllocator->GetProperties( &Props );
                    if( !FAILED( hr ) )
                    {
                        Props.cBuffers = max( Props.cBuffers, HIGH_BUFFERS );
                        ALLOCATOR_PROPERTIES Actual;
                        hr = pPin->m_pAllocator->SetProperties( &Props, &Actual );
                    }
                }

                m_cToAlloc = HIGH_BUFFERS;
            }
        }
    }

    if( FAILED( hr ) )
    {
        return hr;
    }

    if (pProp->cBuffers < (LONG) m_cToAlloc)
        pProp->cBuffers = m_cToAlloc;

    if (pProp->cbBuffer < (LONG) m_cbToAlloc)
        pProp->cbBuffer = m_cbToAlloc;

    if (pProp->cbAlign < 1)
        pProp->cbAlign = 1;

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProp, &Actual);

    if( SUCCEEDED( hr ) )
    {
        if (pProp->cBuffers > Actual.cBuffers || pProp->cbBuffer > Actual.cbBuffer)
        {
            hr = E_FAIL;
        }
    }

    return hr;    
};

//  Return TRUE if we're the pin being used for seeking
//  !!!! do we need something intelligent here?
BOOL CASFOutput::IsSeekingPin()
{
    //  See if we're the first connected pin

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
    for (;;) {
        CASFOutput *pPin;
        pPin = m_pFilter->m_OutputPins.GetNext(pos);
        if (pPin == NULL) {
            break;
        }

        if (pPin->IsConnected()) {
	    return this == pPin;
        }
    }

    // we seem to get here sometimes while the graph is being rebuilt....
    DbgLog((LOG_ERROR, 1, TEXT("All pins disconnected in IsSeekingPin??")));
    return TRUE;
}


//
// Active
//
// This is called when we start running or go paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CASFOutput::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
        m_pOutputQueue = new COutputQueue(m_Connected, &hr, TRUE, FALSE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Active, about to commit allocator")));
    CBaseOutputPin::Active();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Active, back from committing allocator")));
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CASFOutput::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queus associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Inactive, about to decommit allocator")));
    CBaseOutputPin::Inactive();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::Inactive, back from decommitting allocator")));
    return NOERROR;

} // Inactive


//
// Deliver
//
HRESULT CASFOutput::Deliver(IMediaSample *pMediaSample)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    pMediaSample->AddRef();
    return m_pOutputQueue->Receive(pMediaSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CASFOutput::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CASFOutput::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();

    // decommit the allocator so the WMSDK push thread will stop
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverBeginFlush, about to decommit allocator")));
    m_pAllocator->Decommit();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverBeginFlush, back from decommitting allocator")));
    
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CASFOutput::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    // re-commit the allocator now that it's safe
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverEndFlush, about to re-commit allocator")));
    m_pAllocator->Commit();
    DbgLog((LOG_TRACE, 2, TEXT("CASFOutput::DeliverEndFlush, back from re-committing allocator")));
    
    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CASFOutput::DeliverNewSegment(REFERENCE_TIME tStart, 
                                         REFERENCE_TIME tStop,  
                                         double dRate)          
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


STDMETHODIMP CASFReader::get_ExSeekCapabilities(long FAR* pExCapabilities)
{
    if (!pExCapabilities)
	return E_INVALIDARG;

    long c = 0;

    c |= AM_EXSEEK_BUFFERING;

    // !!! is this right?
    c |= AM_EXSEEK_NOSTANDARDREPAINT;


    // !!! fix these?
    if (0)
	c |= AM_EXSEEK_SENDS_VIDEOFRAMEREADY;
    
    if (0)
        c |= AM_EXSEEK_CANSCAN | AM_EXSEEK_SCANWITHOUTCLOCK;

    if (1)
        c |= AM_EXSEEK_CANSEEK;

    if (0) 
        c |= AM_EXSEEK_MARKERSEEK;

    *pExCapabilities = c;

    return S_OK;
}

STDMETHODIMP CASFReader::get_MarkerCount(long FAR* pMarkerCount)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        WORD wMarkers;

        hr = pHeaderInfo->GetMarkerCount(&wMarkers);

        if (SUCCEEDED(hr))
            *pMarkerCount = (long) wMarkers;

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::get_CurrentMarker(long FAR* pCurrentMarker)
{
    if( !m_pReader )
        return E_FAIL;
        
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetMarkerTime(long MarkerNum, double FAR* pMarkerTime)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        QWORD qwTime;
        WORD cchMarkerName;

        hr = pHeaderInfo->GetMarker((WORD) MarkerNum, NULL, &cchMarkerName, &qwTime);

        if (SUCCEEDED(hr))
            *pMarkerTime = ((double) (LONGLONG) qwTime / 10000000.0);

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::GetMarkerName(long MarkerNum, BSTR FAR* pbstrMarkerName)
{
    if( !m_pReader )
        return E_FAIL;
        
    IWMHeaderInfo *pHeaderInfo;

    HRESULT hr = m_pReader->QueryInterface(IID_IWMHeaderInfo, (void **) &pHeaderInfo);
    if (SUCCEEDED(hr)) {
        QWORD qwTime;
        WORD cchMarkerName;

        hr = pHeaderInfo->GetMarker((WORD) MarkerNum, NULL, &cchMarkerName, &qwTime);

        if (SUCCEEDED(hr)) {
            *pbstrMarkerName = SysAllocStringLen(NULL, cchMarkerName);

            if (!*pbstrMarkerName)
                hr = E_OUTOFMEMORY;
            else {
                hr = pHeaderInfo->GetMarker((WORD) MarkerNum, *pbstrMarkerName, &cchMarkerName, &qwTime);
            }
        }

        pHeaderInfo->Release();
    }

    return hr;
}

STDMETHODIMP CASFReader::put_PlaybackSpeed(double Speed)
{
    if (!IsValidPlaybackRate(Speed)) {
        return E_INVALIDARG;
    }

    ASSERT(0);
    SetRate(Speed);

    return S_OK;
}

STDMETHODIMP CASFReader::get_PlaybackSpeed(double *pSpeed)
{
    *pSpeed = GetRate();

    return S_OK;
}

/* Overriden to say what interfaces we support and where */
STDMETHODIMP
CASFReaderCallback::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we have this interface? */

    if (riid == IID_IWMReaderCallback) {
	return GetInterface(static_cast<IWMReaderCallback *>(this), ppv);
    }

    if (riid == IID_IWMReaderCallbackAdvanced) {
	return GetInterface(static_cast<IWMReaderCallbackAdvanced *>(this), ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid,ppv);
}




// IWMReaderCallback
//
// qwSampleDuration will be 0 for most media types.
//
STDMETHODIMP CASFReaderCallback::OnSample(DWORD dwOutputNum,
                 QWORD qwSampleTime,
                 QWORD qwSampleDuration,
                 DWORD dwFlags,
                 INSSBuffer *pSample,
                 void *pvContext)
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnSample  %d   %d  %d  %d"),
            dwOutputNum, (DWORD) (qwSampleTime / 10000), (DWORD) (qwSampleDuration / 10000), dwFlags));

    if (m_pFilter->m_fSentEOS) {
	DbgLog((LOG_TRACE, 1, TEXT("Received sample after EOS....")));
	return S_OK; // !!! error?
    }
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();
        
    while( pos )
    {
        pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

        if( pPin->m_idStream == dwOutputNum )
        {
            break;
        }

        pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) {
        return S_OK;
    }

    CWMReadSample *pWMS = (CWMReadSample *) pSample;
    IMediaSample *pMS = pWMS->m_pSample;

    pMS->AddRef();
    if (pMS) {
        // qwSampleTime is from the start of the file, our time units are from the middle
        REFERENCE_TIME rtStart = qwSampleTime - m_pFilter->m_rtStart;
        REFERENCE_TIME rtStop = rtStart + qwSampleDuration;

        //
        // no delivering past where we were told.
        //
        
        // m_pFilter->m_rtStop is where we've been told to seek to, relative to the start of the file
        if( (REFERENCE_TIME) qwSampleTime >= m_pFilter->m_rtStop &&
            !( MEDIATYPE_Video == pPin->m_mt.majortype && !pPin->m_bNonPrerollSampleSent ) )
        {
            // but make sure we've delivered at least one non-prerolled video frame on a seek
            DbgLog((LOG_TRACE, 8, TEXT("OnSample: Finished delivering, since past where we were told( qwSampleTime = %ld, m_pFilter->m_rtStop = %ld"),
                    (long)( qwSampleTime/10000 ), (long) ( m_pFilter->m_rtStop/10000 ) ));
            pMS->Release();
            return S_OK;
        }
        
        pPin->m_nReceived++;

        DbgLog((LOG_TRACE, 2, TEXT("AsfRead:Setting sample #%ld's times to %ld %ld"), pPin->m_nReceived, long( rtStart / 10000 ), long( rtStop / 10000 ) ));

        pMS->SetTime(&rtStart, &rtStop);

        BOOL SyncPoint = dwFlags & WM_SF_CLEANPOINT;
        BOOL Discont = dwFlags & WM_SF_DISCONTINUITY;
        BOOL ShouldPreroll = ( rtStop <= 0 );
        if( MEDIATYPE_Video == pPin->m_mt.majortype )
        {        
            //
            // the following is a workaround, not an ideal solution...
            //
            // for video stop marking preroll if we get close enough to the seek window
            //
            if( 10000 == qwSampleDuration )
            {            
                // up to now durations of 10000 for video are used by the wmsdk reader erroneously
                ShouldPreroll = ( ( rtStart + PREROLL_SEEK_WINDOW ) <= 0 );
            }
#ifdef DEBUG            
            else
            {
                DbgLog((LOG_TRACE, 3, "!! HEADS UP - we're getting video samples with durations != 1, something's either fixed or more broken than before!!" ));
            }            
#endif            
        }

        // if we're to deliver the first sample downstream after a seek, we
        // HAVE to deliver a keyframe or guess what? We'll blow out a decompressor!
        //
        if( pPin->m_bFirstSample )
        {
            if( !SyncPoint )
            {
                DbgLog((LOG_TRACE, 1, TEXT("      Was seeked, but not key, exiting..." )));
                DbgLog((LOG_ERROR, 1, TEXT("      Was seeked, but not key, exiting..." )));
                pMS->Release();
                return S_OK;
            }
            pPin->m_bFirstSample = FALSE;

            // always set a discont after a seek
            //
            Discont = TRUE;
        }
        else
        {
            if( Discont )
            {
                DbgLog((LOG_TRACE, 0, TEXT("AsfRead:DISCONT DISCONT DISCONT DISCONT" )));
                if (pPin->m_mt.majortype == MEDIATYPE_Audio) 
                {
//                    ASSERT( !Discont );
                }
                Discont = FALSE;
            }
        }

#ifdef DEBUG
        if( Discont && !SyncPoint )
        {
            DbgLog((LOG_ERROR, 1, TEXT("      Got discont without sync..." )));
            DbgLog((LOG_TRACE, 1, TEXT("      Got discont without sync..." )));
        }
        if( SyncPoint )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Sample was a sync point" )));
        }
        if( Discont )
        {
            DbgLog((LOG_TRACE, 1, TEXT("Sample is a discontinuity" )));
        }
        if( ShouldPreroll )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Sample is prerolled" )));
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("sample is normal, no reroll" )));
        }
#endif
        if( !ShouldPreroll )
        {
            pPin->m_bNonPrerollSampleSent = TRUE;
        }        

        // don't allow a discont unless there's a key
        //
        Discont = Discont && SyncPoint;

        pMS->SetSyncPoint(SyncPoint);
        pMS->SetDiscontinuity(Discont);
        pMS->SetPreroll(ShouldPreroll); // !!! different if striding?

        HRESULT hr = pPin->Deliver(pMS);

        pMS->Release();
        
        DbgLog((LOG_TRACE, 5, TEXT("      Receive returns %x"), hr));

        if (hr != S_OK) {

            // was told to stop pushing
            //
            DbgLog((LOG_TRACE, 15, TEXT("      Calling stop in callback (m_pReader = 0x%08lx)"), m_pFilter->m_pReader));
            hr = m_pFilter->StopReader();
        }
    }

    
    return S_OK;
}


//
// The contents pParam depends on the Status.
//
STDMETHODIMP CASFReaderCallback::OnStatus(WMT_STATUS Status, 
                 HRESULT hrStatus,
                 WMT_ATTR_DATATYPE dwType,
                 BYTE *pValue,
                 void *pvContext)
{
    HRESULT hr = S_OK;
    AM_WMT_EVENT_DATA * pWMTEventInfo = NULL;
    ULONG ulCount = 0;
    BOOL bSent = FALSE;

    // !!! ignore if context doesn't match?
    
    switch (Status) {
        case WMT_ERROR:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_ERROR): %x"), hrStatus));
            m_pFilter->NotifyEvent( EC_ERRORABORT, hrStatus, 0 );
            break;
            
        case WMT_OPENED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_OPENED): %x"), hrStatus));
            m_pFilter->m_hrOpen = hrStatus;
            m_pFilter->m_evOpen.Set();
            break;
            
        case WMT_BUFFERING_START:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_BUFFERING_START): %x"), hrStatus));
            //
            // Tell the upper layer to show the BUFFERING msg in the UI,
            //
            m_pFilter->NotifyEvent( EC_BUFFERING_DATA, TRUE, 0 );
            break;
            
        case WMT_BUFFERING_STOP:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_BUFFERING_STOP): %x"), hrStatus));
            //
            // Tell the upper layer to show the BUFFERING msg in the UI,
            //
            m_pFilter->NotifyEvent( EC_BUFFERING_DATA, FALSE, 0 );
            break;
            
        case WMT_EOF:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_EOF): %x"), hrStatus));

            m_pFilter->SendEOS();
            
            break;
            
        case WMT_END_OF_SEGMENT:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_END_OF_SEGMENT): %x"), hrStatus));

            // !!! what is this for?
            ASSERT(0);
            
            break;
            
        case WMT_END_OF_STREAMING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_END_OF_STREAMING): %x"), hrStatus));

            // !!! send EC_EOS_SOON?
            break;
            
        case WMT_LOCATING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_LOCATING): %x"), hrStatus));

            m_pFilter->NotifyEvent(EC_LOADSTATUS, AM_LOADSTATUS_LOCATING, 0L); 
            break;
            
        case WMT_CONNECTING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_CONNECTING): %x"), hrStatus));

            m_pFilter->NotifyEvent(EC_LOADSTATUS, AM_LOADSTATUS_CONNECTING, 0L); 
            break;
            
        case WMT_NO_RIGHTS:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NO_RIGHTS): %x"), hrStatus));

            if( pValue )
            {            
                ulCount = 2 * (wcslen( (WCHAR *)pValue ) + 1 );

                pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
                if( SUCCEEDED( hr ) )
                {            
                    pWMTEventInfo->hrStatus = hrStatus;
                    pWMTEventInfo->pData = (void *) CoTaskMemAlloc( ulCount );
                    
                    if( pWMTEventInfo->pData )
                    {                
                        CopyMemory( pWMTEventInfo->pData, pValue, ulCount );
                        m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS, (LONG_PTR) pWMTEventInfo );
                        bSent = TRUE;
                    }
                    else
                    {
                        CoTaskMemFree( pWMTEventInfo );
                    }                
                }
            }
            if( !bSent )
            {            
                // use a null param struct to indicate out of mem error
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS, NULL ); 
            }
            
            break;

        case WMT_ACQUIRE_LICENSE:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_ACQUIRE_LICENSE): %x"), hrStatus));

    	    //
            // means we've acquired the license, tell app
            //
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {   
                pWMTEventInfo->hrStatus = hrStatus;
                if( SUCCEEDED( hrStatus ) )
                {                
                    pWMTEventInfo->pData = CloneGetLicenseData( (WM_GET_LICENSE_DATA *) pValue );
                    if( pWMTEventInfo->pData )
                    {                
                        m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, (LONG_PTR) pWMTEventInfo );
                        bSent = TRUE;
                    }
                    else
                    {
                        CoTaskMemFree( pWMTEventInfo );
                    }                
                }
                else
                {
                    bSent = TRUE;
                    pWMTEventInfo->pData = NULL;
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, (LONG_PTR) pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_ACQUIRE_LICENSE, NULL ); // use a null param struct to indicate out of mem error
            }
            break;
            
        case WMT_MISSING_CODEC:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_MISSING_CODEC): %x"), hrStatus));
            // !!! call the unabletorender callback???
            // !!! if we're doing compressed pins, we should actually be okay, since we'll
            // expose the right pin, and the graph can make the right thing happen.
            break;
            
        case WMT_STARTED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STARTED): %x"), hrStatus));
            m_pFilter->m_hrStartStop = hrStatus;
            {
                // !!! hack hack hack, in my opinion.
                // start the clock going
                REFERENCE_TIME tInitial = m_pFilter->m_rtStart + TIMEOFFSET * 10000;
                hr = m_pFilter->m_pReaderAdv->DeliverTime( tInitial );
                DbgLog((LOG_TIMING, 1, TEXT("   calling DeliverTime(%s) returns %x"), (LPCTSTR) CDisp(CRefTime(tInitial)), hr));
            }
            m_pFilter->m_evStartStop.Set();
            break;
            
        case WMT_STOPPED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STOPPED): %x"), hrStatus));
            m_pFilter->m_hrStartStop = hrStatus;
            m_pFilter->m_evStartStop.Set();
            break;
            
        case WMT_CLOSED:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_CLOSED): %x"), hrStatus));
            m_pFilter->m_hrOpen = hrStatus;
            m_pFilter->m_evOpen.Set();
            break;
            
        case WMT_STRIDING:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_STRIDING): %x"), hrStatus));
            break;
            
        case WMT_TIMER:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_TIMER): %x"), hrStatus));
            ASSERT(!"got WMT_TIMER, why?");
            break;

        case WMT_INDIVIDUALIZE:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_INDIVIDUALIZE): %x"), hrStatus));
            
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {            
                pWMTEventInfo->hrStatus = hrStatus;
                pWMTEventInfo->pData = CloneIndividualizeStatusData( (WM_INDIVIDUALIZE_STATUS *) pValue );
                if( pWMTEventInfo->pData )
                {                
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_INDIVIDUALIZE, (LONG_PTR) pWMTEventInfo );
                    bSent = TRUE;
                }
                else
                {
                    CoTaskMemFree( pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_INDIVIDUALIZE, NULL ); // use a null param struct to indicate out of mem error
            }
            break;

        case WMT_NEEDS_INDIVIDUALIZATION:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NEEDS_INDIVIDUALIZATION): %x"), hrStatus));
            m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NEEDS_INDIVIDUALIZATION, NULL ); // use a null param struct to indicate out of mem error
            break;

        case WMT_NO_RIGHTS_EX:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NO_RIGHTS_EX): %x"), hrStatus));
            
            pWMTEventInfo = (AM_WMT_EVENT_DATA *) CoTaskMemAlloc( sizeof( AM_WMT_EVENT_DATA ) );
            if( pWMTEventInfo )
            {            
                pWMTEventInfo->hrStatus = hrStatus;
                pWMTEventInfo->pData = CloneGetLicenseData( (WM_GET_LICENSE_DATA *) pValue );
                if( pWMTEventInfo->pData )
                {                
                    m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS_EX, (LONG_PTR) pWMTEventInfo );
                    bSent = TRUE;
                }
                else
                {
                    CoTaskMemFree( pWMTEventInfo );
                }
            }            
            if( !bSent )
            {            
                m_pFilter->NotifyEvent( EC_WMT_EVENT, WMT_NO_RIGHTS_EX, NULL ); // use a null param struct to indicate out of mem error
            }
            
            break;

#ifdef WMT_NEW_FORMAT
        case WMT_NEW_FORMAT:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(WMT_NEW_FORMAT): %x"), hrStatus));
            ASSERT(!"got WMT_NEW_FORMAT, why?");
            break;
#endif
            
        default:
            DbgLog((LOG_TRACE, 2, TEXT("OnStatus(UNKNOWN %d): %x"), Status, hrStatus));
            ASSERT(!"got unknown WMT_ status code");
            break;
    }

    return hr;
}

WM_GET_LICENSE_DATA * CloneGetLicenseData( WM_GET_LICENSE_DATA * pGetLicenseData )
{
    if( NULL == pGetLicenseData )
        return NULL;

    WM_GET_LICENSE_DATA * pClonedGetLicenseData = ( WM_GET_LICENSE_DATA *) CoTaskMemAlloc( sizeof( WM_GET_LICENSE_DATA ) );
    if( pClonedGetLicenseData )
    {            
        CopyMemory( pClonedGetLicenseData, pGetLicenseData, sizeof( WM_GET_LICENSE_DATA ) );

        ULONG ulCount1 = 0;
        ULONG ulCount2 = 0;
        ULONG ulCount3 = 0;
        if( pGetLicenseData->wszURL )
        {        
            ulCount1 = 2 * ( wcslen( (WCHAR *)pGetLicenseData->wszURL ) + 1 );
            pClonedGetLicenseData->wszURL = ( WCHAR *) CoTaskMemAlloc( ulCount1 );
        }
        if( pGetLicenseData->wszLocalFilename )
        {        
            ulCount2 = 2 * ( wcslen( (WCHAR *)pGetLicenseData->wszLocalFilename ) + 1 );
            pClonedGetLicenseData->wszLocalFilename = ( WCHAR *) CoTaskMemAlloc( ulCount2 );
        }
        if( pGetLicenseData->dwPostDataSize > 0 )
        {        
            ulCount3 = pGetLicenseData->dwPostDataSize;
            pClonedGetLicenseData->pbPostData = ( BYTE *) CoTaskMemAlloc( ulCount3 );
        }
        else
        {
            pClonedGetLicenseData->pbPostData = NULL;
        }        
        
        if( ( ulCount1 > 0 && !pClonedGetLicenseData->wszLocalFilename ) ||
            ( ulCount2 > 0 && !pClonedGetLicenseData->wszURL ) ||
            ( ulCount3 > 0 && !pClonedGetLicenseData->pbPostData ) )
        {
            // if we failed due to out of memory release all allocations
            CoTaskMemFree( pClonedGetLicenseData->wszURL );
            CoTaskMemFree( pClonedGetLicenseData->wszLocalFilename );
            CoTaskMemFree( pClonedGetLicenseData->pbPostData );
            CoTaskMemFree( pClonedGetLicenseData );
            pClonedGetLicenseData = NULL;
        }
        else 
        {
            CopyMemory( pClonedGetLicenseData->wszURL, pGetLicenseData->wszURL, ulCount1 );
            CopyMemory( pClonedGetLicenseData->wszLocalFilename, pGetLicenseData->wszLocalFilename, ulCount2 );
            CopyMemory( pClonedGetLicenseData->pbPostData, pGetLicenseData->pbPostData, ulCount3 );
        }                
    }            
    return pClonedGetLicenseData;
}

WM_INDIVIDUALIZE_STATUS * CloneIndividualizeStatusData( WM_INDIVIDUALIZE_STATUS * pIndStatus )
{
    if( NULL == pIndStatus )
        return NULL;

    WM_INDIVIDUALIZE_STATUS * pClonedIndStatus = ( WM_INDIVIDUALIZE_STATUS *) CoTaskMemAlloc( sizeof( WM_INDIVIDUALIZE_STATUS ) );
    if( pClonedIndStatus )
    {            
        CopyMemory( pClonedIndStatus, pIndStatus, sizeof( WM_INDIVIDUALIZE_STATUS ) );

        ULONG ulCount1 = 0;
        if( pIndStatus->pszIndiRespUrl )
        {
            ulCount1 = strlen( (LPSTR)pIndStatus->pszIndiRespUrl ) + 1;
            pIndStatus->pszIndiRespUrl = ( LPSTR ) CoTaskMemAlloc( ulCount1 );

            if( ulCount1 > 0 && !pIndStatus->pszIndiRespUrl )
            {
                CoTaskMemFree( pClonedIndStatus );
                pClonedIndStatus = NULL;
            }
            else if( ulCount1 > 0 )
            {
                CopyMemory( pClonedIndStatus->pszIndiRespUrl, pIndStatus->pszIndiRespUrl, ulCount1 );
            }                
        }            
    }            
    return pIndStatus;
}

// IWMReaderCallbackAdvanced

//
// Receive a sample directly from the ASF. To get this call, the user
// must register himself to receive samples for a particular stream.
//
STDMETHODIMP CASFReaderCallback::OnStreamSample(WORD wStreamNum,
                       QWORD qwSampleTime,
                       QWORD qwSampleDuration,
                       DWORD dwFlags,
                       INSSBuffer *pSample,
                       void *pvContext )
{
    DbgLog((LOG_TRACE, 5, TEXT("Callback::OnStreamSample(%d, %d, %d, %d)"),
           wStreamNum, (DWORD) (qwSampleTime / 10000), (DWORD) (qwSampleDuration / 10000), dwFlags));

    HRESULT hr = S_OK;

    ASSERT( !m_pFilter->m_bUncompressedMode );
    
    hr = OnSample((DWORD) wStreamNum, qwSampleTime, qwSampleDuration, dwFlags, pSample, pvContext);
    
    // find output pin, make IMediaSample, deliver

    // !!! why not just call OnSample?
    // !!! need to map wStreamNum back to an output #?


    return hr;
}


//
// In some cases, the user may want to get callbacks telling what the
// reader thinks the current time is. This is interesting in 2 cases:
// - If the ASF has gaps in it; say no audio for 10 seconds. This call
//   will continue to be called, while OnSample won't be called.
// - If the user is driving the clock, the reader needs to communicate
//   back to the user its time, to avoid the user overrunning the reader.
//
STDMETHODIMP CASFReaderCallback::OnTime(QWORD qwCurrentTime, void *pvContext )
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnTime(%d)"),
           (DWORD) (qwCurrentTime / 10000)));

    HRESULT hr = S_OK;

    if (qwCurrentTime >= (QWORD) m_pFilter->m_rtStop) {
	DbgLog((LOG_TRACE, 1, TEXT("OnTime value past the duration, we must be done")));
	
	m_pFilter->SendEOS();

	return S_OK;
    }
    
    QWORD qwNewTime = qwCurrentTime + TIMEDELTA * 10000;
    // if no clock, free-run the time forward

    hr = m_pFilter->m_pReaderAdv->DeliverTime(qwNewTime);
    DbgLog((LOG_TIMING, 2, TEXT("   calling DeliverTime(%d) returns %x"), (DWORD) (qwNewTime / 10000), hr));
    
    return hr;
}

//
// The user can also get callbacks when stream selection occurs.
//
STDMETHODIMP CASFReaderCallback::OnStreamSelection(WORD wStreamCount,
                          WORD *pStreamNumbers,
                          WMT_STREAM_SELECTION *pSelections,
                          void *pvContext)
{
    DbgLog((LOG_TRACE, 2, TEXT("Callback::OnStreamSelect(%d)"),
           wStreamCount));


    for (WORD w = 0; w < wStreamCount; w++) {
        DbgLog((LOG_TRACE, 2, TEXT("   StreamSelect(%d): %d"),
           pStreamNumbers[w], pSelections[w]));

        // send media type change downstream?

        // if we're using compressed pins, we need to switch which pin is in use.... 


    }

    return S_OK;
}

//
// If the user has registered to allocate buffers, this is where he must
// do it.
//
STDMETHODIMP CASFReaderCallback::AllocateForOutput(DWORD dwOutputNum,
                           DWORD cbBuffer,
                           INSSBuffer **ppBuffer,
                           void *pvContext )
{
    ASSERT( m_pFilter->m_bUncompressedMode );
    if( !m_pFilter->m_bUncompressedMode )
    {
        return E_NOTIMPL;
    }            
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();

    while( pos )
    {
        pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

        if( pPin->m_idStream == dwOutputNum )
        {
            break;
        }
        pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) 
    {
        return E_FAIL;  // !!! better return code?
    }

    IMediaSample *pMS;

    DbgLog((LOG_TRACE, 25, TEXT("CASFReaderCallback::AllocateForOutput(%d), getting %d byte buffer"), dwOutputNum, cbBuffer));
    HRESULT hr = pPin->m_pAllocator->GetBuffer(&pMS, NULL, NULL, 0);
    DbgLog((LOG_TRACE, 25, TEXT("CASFReaderCallback::AllocateForOutput(%d), GetBuffer returned %x"), dwOutputNum, hr));
    if (SUCCEEDED(hr)) 
    {
        // make INSSBuffer, put it into *ppBuffer

        // SDK shouldn't have asked for a buffer bigger than the max size
        ASSERT(cbBuffer <= (DWORD) pMS->GetSize());

        *ppBuffer = new CWMReadSample(pMS);

        if (!*ppBuffer)
        {        
            hr = E_OUTOFMEMORY;
        }            
        else 
        {
            (*ppBuffer)->AddRef();
            // WMSDK will assume buffer length has been set
            pMS->SetActualDataLength(cbBuffer);
        }            
	    pMS->Release();  // WMReadSample holds buffer now
    } 
    else 
    {
        DbgLog((LOG_ERROR, 4, TEXT("GetBuffer failed in AllocateForOutput, hr = %x"), hr));
    }

    return hr;
}

STDMETHODIMP CASFReaderCallback::OnOutputPropsChanged(DWORD dwOutputNum,
                            WM_MEDIA_TYPE *pMediaType,
                            void *pvContext)
{
    ASSERT(0);
    return E_NOTIMPL;
}

STDMETHODIMP CASFReaderCallback::AllocateForStream(WORD wStreamNum,
                            DWORD cbBuffer,
                            INSSBuffer **ppBuffer,
                            void *pvContext)
{
    if( m_pFilter->m_bUncompressedMode )
    {
        ASSERT( FALSE );
        return E_NOTIMPL;
    }
    
    CASFOutput * pPin = NULL;

    POSITION pos = m_pFilter->m_OutputPins.GetHeadPosition();

    while( pos )
    {
	pPin = (CASFOutput *) m_pFilter->m_OutputPins.Get( pos );

	if( pPin->m_idStream == wStreamNum )
	{
	    break;
	}

	pos = m_pFilter->m_OutputPins.Next( pos );
    }

    ASSERT(pPin);

    if (!pPin || !pPin->IsConnected()) {
	return E_FAIL;  // !!! better return code?
    }

    IMediaSample *pMS;

    DbgLog((LOG_TRACE, 4, TEXT("CASFReaderCallback::AllocateForStream(%d), getting %d byte buffer"), wStreamNum, cbBuffer));
    HRESULT hr = pPin->m_pAllocator->GetBuffer(&pMS, NULL, NULL, 0);
    DbgLog((LOG_TRACE, 4, TEXT("CASFReaderCallback::AllocateForStream(%d), GetBuffer returned %x"), wStreamNum, hr));

    if (SUCCEEDED(hr)) {
	// make INSSBuffer, put it into *ppBuffer

	// SDK shouldn't have asked for a buffer bigger than the max size
        ASSERT(cbBuffer <= (DWORD) pMS->GetSize());

        *ppBuffer = new CWMReadSample(pMS);

        if (!*ppBuffer)
            hr = E_OUTOFMEMORY;
        else {
            (*ppBuffer)->AddRef();
	    // WMSDK will assume buffer length has been set
	    pMS->SetActualDataLength(cbBuffer);
	}

	pMS->Release();  // WMReadSample holds buffer now
    } else {
	DbgLog((LOG_ERROR, 4, TEXT("GetBuffer failed in AllocateForStream, hr = %x"), hr));
    }

    return hr;
}


// IWMHeaderInfo forwarded to WMSDK
STDMETHODIMP CASFReader::GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeCount(wStreamNum, pcAttributes);
}


STDMETHODIMP CASFReader::GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByIndex(wIndex, pwStreamNum, pwszName,
                                        pcchNameLen, pType, pValue, pcbLength);
}


STDMETHODIMP CASFReader::GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByName(pwStreamNum, pszName, pType,
                                       pValue, pcbLength);
}


STDMETHODIMP CASFReader::SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->SetAttribute(wStreamNum, pszName, Type, pValue, cbLength);
}


STDMETHODIMP CASFReader::GetMarkerCount( WORD *pcMarkers )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarkerCount(pcMarkers);
}


STDMETHODIMP CASFReader::GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarker(wIndex, pwszMarkerName, pcchMarkerNameLen, pcnsMarkerTime);
}


STDMETHODIMP CASFReader::AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddMarker(pwszMarkerName, cnsMarkerTime);
}

STDMETHODIMP CASFReader::RemoveMarker( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveMarker(wIndex);
}

STDMETHODIMP CASFReader::GetScriptCount( WORD *pcScripts )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScriptCount(pcScripts);
}

STDMETHODIMP CASFReader::GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScript(wIndex, pwszType, pcchTypeLen, pwszCommand,
                              pcchCommandLen, pcnsScriptTime);
}

STDMETHODIMP CASFReader::AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddScript(pwszType, pwszCommand, cnsScriptTime);
}

STDMETHODIMP CASFReader::RemoveScript( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveScript(wIndex);
}


//
// IWMReaderAdvanced2 
// 
// Note that we only allow outside access to some of these methods,
// particularly the informational ones to provide download progress, etc...
// We don't allow an app access to any streaming or control methods.
//
STDMETHODIMP CASFReader::SetPlayMode( WMT_PLAY_MODE Mode )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->SetPlayMode( Mode );
}

STDMETHODIMP CASFReader::GetPlayMode( WMT_PLAY_MODE *pMode )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetPlayMode( pMode );
}

STDMETHODIMP CASFReader::GetBufferProgress( DWORD *pdwPercent, QWORD *pcnsBuffering )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetBufferProgress( pdwPercent, pcnsBuffering );
}

STDMETHODIMP CASFReader::GetDownloadProgress( DWORD *pdwPercent,
                                              QWORD *pqwBytesDownloaded,
                                              QWORD *pcnsDownload )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetDownloadProgress( pdwPercent, pqwBytesDownloaded, pcnsDownload );
}                             
                             
STDMETHODIMP CASFReader::GetSaveAsProgress( DWORD *pdwPercent )
{
    //
    // probably useful to apps, but then we'd need to forward 
    // WMT_SAVEAS_START and WMT_SAVEAS_STOP status as well...
    // so for later
    //
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SaveFileAs( const WCHAR *pwszFilename )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetProtocolName( WCHAR *pwszProtocol, DWORD *pcchProtocol )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->GetProtocolName( pwszProtocol, pcchProtocol );
}
STDMETHODIMP CASFReader::StartAtMarker( WORD wMarkerIndex, 
                       QWORD cnsDuration, 
                       float fRate, 
                       void *pvContext )
{
    return E_NOTIMPL;
}
                       
STDMETHODIMP CASFReader::GetOutputSetting( 
                DWORD dwOutputNum,
                LPCWSTR pszName,
                WMT_ATTR_DATATYPE *pType,
                BYTE *pValue,
                WORD *pcbLength )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetOutputSetting(
                DWORD dwOutputNum,
                LPCWSTR pszName,
                WMT_ATTR_DATATYPE Type,
                const BYTE *pValue,
                WORD cbLength )
{
    return E_NOTIMPL;
}
                
STDMETHODIMP CASFReader::Preroll( QWORD cnsStart, QWORD cnsDuration, float fRate )
{
    return E_NOTIMPL;
}
            
STDMETHODIMP CASFReader::SetLogClientID( BOOL fLogClientID )
{
    if (!m_pReaderAdv2)
        return E_FAIL;

    return m_pReaderAdv2->SetLogClientID( fLogClientID );
}

STDMETHODIMP CASFReader::GetLogClientID( BOOL *pfLogClientID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::StopBuffering( )
{
    return E_NOTIMPL;
}


// IWMReaderAdvanced forwarded to WMSDK
STDMETHODIMP CASFReader::SetUserProvidedClock( BOOL fUserClock )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetUserProvidedClock( BOOL *pfUserClock )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::DeliverTime( QWORD cnsTime )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetManualStreamSelection( BOOL fSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetManualStreamSelection( BOOL *pfSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetStreamsSelected( WORD cStreamCount, 
                            WORD *pwStreamNumbers,
                            WMT_STREAM_SELECTION *pSelections )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetStreamSelected( WORD wStreamNum, WMT_STREAM_SELECTION *pSelection )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetReceiveSelectionCallbacks( BOOL fGetCallbacks )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetReceiveSelectionCallbacks( BOOL *pfGetCallbacks )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetReceiveStreamSamples( WORD wStreamNum, BOOL fReceiveStreamSamples )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetReceiveStreamSamples( WORD wStreamNum, BOOL *pfReceiveStreamSamples )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetAllocateForOutput( DWORD dwOutputNum, BOOL fAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetAllocateForOutput( DWORD dwOutputNum, BOOL *pfAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::SetAllocateForStream( WORD dwStreamNum, BOOL fAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetAllocateForStream( WORD dwStreamNum, BOOL *pfAllocate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetStatistics( WM_READER_STATISTICS *pStatistics )
{
    if (!m_pReaderAdv)
        return E_FAIL;

    return m_pReaderAdv->GetStatistics( pStatistics );
}

STDMETHODIMP CASFReader::SetClientInfo( WM_READER_CLIENTINFO *pClientInfo )
{
    if (!m_pReaderAdv)
        return E_FAIL;

    return m_pReaderAdv->SetClientInfo( pClientInfo );
}

STDMETHODIMP CASFReader::GetMaxOutputSampleSize( DWORD dwOutput, DWORD *pcbMax )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::GetMaxStreamSampleSize( WORD wStream, DWORD *pcbMax )
{
    return E_NOTIMPL;
}

STDMETHODIMP CASFReader::NotifyLateDelivery( QWORD cnsLateness )
{
    return E_NOTIMPL;
}


// ------------------------------------------------------------------------
//
// CWMReadSample methods
//
CWMReadSample::CWMReadSample(IMediaSample  * pSample) :
        CUnknown(NAME("CWMReadSample"), NULL ),
        m_pSample( pSample )
{
    // !!!! addref sample here?
    m_pSample->AddRef();
}

CWMReadSample::~CWMReadSample()
{
    m_pSample->Release();
}


// override say what interfaces we support where
STDMETHODIMP CWMReadSample::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if (riid == IID_INSSBuffer) {
        return GetInterface( (INSSBuffer *)this, ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

// ------------------------------------------------------------------------
//
// methods to make our wrapped IMediaSample look like an INSSBuffer sample
//
STDMETHODIMP CWMReadSample::GetLength( DWORD *pdwLength )
{
    if (NULL == pdwLength) {
        return( E_INVALIDARG );
    }
    
    *pdwLength = m_pSample->GetActualDataLength();

    return( S_OK );
}

STDMETHODIMP CWMReadSample::SetLength( DWORD dwLength )
{
    return m_pSample->SetActualDataLength( dwLength );
} 

STDMETHODIMP CWMReadSample::GetMaxLength( DWORD * pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }

    *pdwLength = m_pSample->GetSize();
    return( S_OK );
} 

STDMETHODIMP CWMReadSample::GetBufferAndLength(
    BYTE  ** ppdwBuffer,
    DWORD *  pdwLength )
{
    HRESULT hr = m_pSample->GetPointer(ppdwBuffer);

    if( SUCCEEDED( hr ) )
        *pdwLength = m_pSample->GetActualDataLength();
    
    return hr;        
} 

STDMETHODIMP CWMReadSample::GetBuffer( BYTE ** ppdwBuffer )
{
    return m_pSample->GetPointer( ppdwBuffer );
} 





// filter creation junk
CUnknown * CreateASFReaderInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CreateASFReaderInstance")));
    return new CASFReader(pUnk, phr);
}


// setup data
const AMOVIESETUP_FILTER sudWMAsfRead =
{ &CLSID_WMAsfReader        // clsID
, L"WM ASF Reader"      // strName
, MERIT_UNLIKELY        // dwMerit
, 0                     // nPins
, NULL   };             // lpPin


#ifdef FILTER_DLL

/*****************************************************************************/
// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    { L"WM ASF Reader"
    , &CLSID_WMAsfReader
    , CreateASFReaderInstance
    , NULL
    , &sudWMAsfRead }
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfread\seeking.cpp ===
// Copyright (c) Microsoft Corporation 1996-2000. All Rights Reserved

/*

    seeking.cpp

    Implementation of IMediaSeeking for the ASF reader source filter

*/

#include <streams.h>
#include <wmsdk.h>
#include <qnetwork.h>
#include "asfreadi.h"

//
//  IMediaSeeking stuff
//
/*  Constructor and Destructor */
CImplSeeking::CImplSeeking(CASFReader *pFilter,
                                               CASFOutput *pPin,
                                               LPUNKNOWN pUnk,
                                               HRESULT *phr) :
    CUnknown(NAME("CImplSeeking"),pUnk),
    m_pFilter(pFilter),
    m_pPin(pPin)
{
}

STDMETHODIMP
CImplSeeking::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface(static_cast<IMediaSeeking *>(this), ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

// returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP CImplSeeking::IsFormatSupported(const GUID * pFormat)
{
#if 0 // !!! bad things happen if we don't say we support at least TIME_FORMAT_MEDIA_TIME
    //  Only support seeking on one pin
    if (!m_pPin->IsSeekingPin()) {
        return S_FALSE;
    }
#endif

    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP CImplSeeking::QueryPreferredFormat(GUID *pFormat)
{
    /*  Don't care - they're all just as bad as one another */
    *pFormat = m_pPin->IsSeekingPin()
               ? TIME_FORMAT_MEDIA_TIME
               : TIME_FORMAT_NONE;
    return S_OK;
}

// can only change the mode when stopped
// (returns VFE_E_WRONG_STATE otherwise)
STDMETHODIMP CImplSeeking::SetTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pFilter->m_csFilter);
    if (!m_pFilter->IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (S_OK != IsFormatSupported(pFormat)) {
        return E_INVALIDARG;
    }

    return S_OK;
}

//
//  Returns the current time format
//
STDMETHODIMP CImplSeeking::GetTimeFormat(GUID *pFormat)
{
    CAutoLock lck(&m_pFilter->m_csPosition);
    if (m_pPin->IsSeekingPin()) {
        *pFormat = TIME_FORMAT_MEDIA_TIME;
    } else {
        *pFormat = TIME_FORMAT_NONE;
    }

    return S_OK;
}

//
//  Returns the current time format
//
STDMETHODIMP CImplSeeking::IsUsingTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    return ( m_pPin->IsSeekingPin() ? *pFormat == TIME_FORMAT_MEDIA_TIME :
				     *pFormat == TIME_FORMAT_NONE )
           ? S_OK
           : S_FALSE;
}

// return current properties
STDMETHODIMP CImplSeeking::GetDuration(LONGLONG *pDuration)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    // !!! is this the proper error code to return?  Is this check a good idea at all?
    if (m_pFilter->m_qwDuration == 0) {
	DbgLog((LOG_TRACE, 1, TEXT("AsfReadSeek:GetDuration returning E_FAIL for a live stream")));
	return E_FAIL;
    }

#if 0
    if (m_pFilter->m_pMsProps && (SPF_BROADCAST & m_pFilter->m_pMsProps->dwFlags)) {
	DbgLog((LOG_TRACE, 4, TEXT("AsfReadSeek:GetDuration returning E_FAIL for a broadcast stream")));
	return E_FAIL;
    }
#endif

    DbgLog((LOG_TRACE, 8, TEXT("AsfReadSeek:GetDuration returning %ld"), (long) m_pFilter->m_qwDuration / 10000 ));

    *pDuration = m_pFilter->m_qwDuration;
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetStopPosition(LONGLONG *pStop)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

    if (m_pFilter->m_qwDuration == 0 && m_pFilter->m_rtStop == 0) {
	DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetStopPosition returning E_FAIL for a live stream with no duration set")));
	return E_FAIL;
    }
    
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetStopPosition returning %ld"), (long) m_pFilter->m_rtStop / 10000 ));

    *pStop = m_pFilter->m_rtStop;
    
    return S_OK;
}

//  Return the start position if we get asked for the current position on
//  the basis that we'll only be asked if we haven't sent any position data
//  yet in any samples.  The time needs to be relative to the segment we are
//  playing, therefore 0.
STDMETHODIMP CImplSeeking::GetCurrentPosition(LONGLONG *pCurrent)
{
    CAutoLock lck(&m_pFilter->m_csPosition);

#if 0 // !!!!
    // We only want to report the current position when they ask through the
    // seeking interface of the video pin.
    if (m_pPin != m_pFilter->m_pVideoPin)
	return E_FAIL;
#endif
    
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetCurrentPosition returning %ld"), (long) 0 ));

    // BUGBUG Bogus

    *pCurrent = 0;
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetCapabilities( DWORD * pCapabilities )
{
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:GetCapabilities IS NOT IMPLEMENTED") ));

    // BUGBUG do this

    HRESULT hr = E_NOTIMPL;
    return hr;
}

STDMETHODIMP CImplSeeking::CheckCapabilities( DWORD * pCapabilities )
{
    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:CheckCapabilities IS NOT IMPLEMENTED") ));

    // BUGBUG do this

    HRESULT hr = E_NOTIMPL;
    return hr;
}

STDMETHODIMP CImplSeeking::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                                             LONGLONG    Source, const GUID * pSourceFormat )
{
    // !!! we only support one time format....
    // perhaps we should still check what we're being asked to do

    // BUGBUG do this

    *pTarget = Source;
    return S_OK;
}

STDMETHODIMP CImplSeeking::SetPositions
( LONGLONG * pCurrent, DWORD CurrentFlags
, LONGLONG * pStop, DWORD StopFlags )
{
    CAutoLock Lock( &m_pFilter->m_csFilter );

    LONGLONG Current, CurrentMarker, Stop ;
    DWORD CurrentMarkerPacket = 0xffffffff;

    HRESULT hr;

    const DWORD PosCurrentBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;
    const DWORD PosStopBits    = StopFlags & AM_SEEKING_PositioningBitsMask;

    if (PosCurrentBits == AM_SEEKING_AbsolutePositioning) {
        Current = *pCurrent;
    } else if (PosCurrentBits || (PosStopBits == AM_SEEKING_IncrementalPositioning)) {
        hr = GetCurrentPosition( &Current );
        if (FAILED(hr)) {
            return hr;
        }
        if (PosCurrentBits == AM_SEEKING_RelativePositioning) Current += *pCurrent;
    }

    if (PosStopBits == AM_SEEKING_AbsolutePositioning) {
        Stop = *pStop;
    } else if (PosStopBits == AM_SEEKING_IncrementalPositioning) {
        Stop = Current + *pStop;
    } else {
	Stop = 0;
        hr = GetStopPosition( &Stop );
        if (FAILED(hr)) {
	    // fails for live streams, but ignore that for now...
	    // !!! return hr;
        }
        if (PosStopBits == AM_SEEKING_RelativePositioning) Stop += *pStop;
    }

    //  if this is the preferred pin, actually do the seek
    if (m_pPin->IsSeekingPin()) {
	{
	    CAutoLock lck(&m_pFilter->m_csPosition);
	    LONGLONG llDuration = 0;

	    //  Check limits
	    HRESULT hrDuration = GetDuration(&llDuration);
	    
	    if (PosCurrentBits) {
		if (Current < 0 || PosStopBits && Current > Stop) {
		    return E_INVALIDARG;
		}

#if 0
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
                // !!!!!!!!!!!!!!!!!!!!!!!!!1
		VARIANT_BOOL	fCan;

		m_pFilter->get_CanSeek(&fCan);

		if (Current > 0 &&			// Not seeking to the beginning
		    Current != m_pFilter->m_rtStop &&	// Not seeking to the end
		    fCan == OAFALSE)			// Can't seek to just any old position
		{
		    m_pFilter->get_CanSeekToMarkers(&fCan);

		    if (fCan == OAFALSE) {
			// can't seek at all, sorry

			if (!m_pFilter->IsStopped()) {

			    // give it a good swift kick in the head
			    m_pFilter->BeginFlush();

			    m_pFilter->m_msDispatchTime = 0;
			    m_pFilter->m_dwFirstSCR = 0xffffffff;

			    m_pFilter->EndFlush();

			    return S_OK;
			}
			
			return E_FAIL;
		    }

		    // ok, they're planning to seek to a marker, which one?

		    // find the marker, set CurrentMarker, CurrentMarkerPacket

		    hr = m_pFilter->GetMarkerOffsets(Current, &CurrentMarker, &CurrentMarkerPacket);
		    if (FAILED(hr))
			return hr;
		} else {
		    // !!! if we're near enough to a marker, we could try
		    // to do marker-specific things....
		    CurrentMarker = Current;
		}
#endif
                
	    }

	    if (PosStopBits)
	    {
		if (SUCCEEDED(hrDuration) && (Stop > llDuration)) {
		    Stop = llDuration;
		}
		m_pFilter->m_rtStop = Stop;
	    }
	}


	REFERENCE_TIME rt;

	if (PosCurrentBits)
	{
	    if (!m_pFilter->IsStopped())
		m_pFilter->StopPushing();

            m_pFilter->_IntSetStart( Current );

	    if (!m_pFilter->IsStopped())
		m_pFilter->StartPushing();
	}        
    }
    
    if (CurrentFlags & AM_SEEKING_ReturnTime)
    {
	*pCurrent = m_pFilter->m_rtStart;
    }
    if (StopFlags & AM_SEEKING_ReturnTime)
    {
	*pStop = m_pFilter->m_rtStop;
    }

    DbgLog((LOG_TRACE, 2, TEXT("AsfReadSeek:SetPositions to %ld %ld, this = %lx"), long( m_pFilter->m_rtStart / 10000 ), long( m_pFilter->m_rtStop / 10000 ), this ));
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hrResult = S_OK;

    if (pCurrent)
    {
        hrResult = GetCurrentPosition( pCurrent );
        if (FAILED(hrResult)) {
            return hrResult;
        }
    }

    if (pStop)
    {
        hrResult = GetStopPosition( pStop );
    }

    return hrResult;
}

STDMETHODIMP CImplSeeking::SetRate(double dRate)
{
    CAutoLock lck2(&m_pFilter->m_csPosition);
    if (!m_pFilter->IsValidPlaybackRate(dRate)) {  
        DbgLog((LOG_TRACE, 2, TEXT("WARNING in CImplSeeking::SetRate(): The user attempted to set an unsupported playback rate.") ));
        return E_INVALIDARG;
    }

    if (dRate != m_pFilter->GetRate()) {
	// !!! is this sufficient, do we need to remember the current position?
	if (!m_pFilter->IsStopped())
	    m_pFilter->StopPushing();

	m_pFilter->SetRate(dRate);

	if (!m_pFilter->IsStopped())
	    m_pFilter->StartPushing();
    }

    return S_OK;
}

STDMETHODIMP CImplSeeking::GetRate(double * pdRate)
{
    CAutoLock lck(&m_pFilter->m_csPosition);
    *pdRate = m_pFilter->GetRate();
    
    return S_OK;
}

STDMETHODIMP CImplSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    HRESULT hr = S_OK;

    if (pEarliest != NULL) {
        *pEarliest = 0;
    }

    if (pLatest != NULL) {
        hr = GetDuration(pLatest);
    }
    return hr;
}


#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfread\asfreadi.h ===
#include "asfread.h"

//
// Our sample class which takes an input IMediaSample and makes it look like
// an INSSBuffer buffer for the wmsdk
//
class CWMReadSample : public INSSBuffer, public CUnknown
{

public:

    CWMReadSample(IMediaSample * pSample);
    ~CWMReadSample();

    DECLARE_IUNKNOWN
            
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // INSSBuffer
    STDMETHODIMP GetLength( DWORD *pdwLength );
    STDMETHODIMP SetLength( DWORD dwLength );
    STDMETHODIMP GetMaxLength( DWORD * pdwLength );
    STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
    STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

public: // !!!!
    IMediaSample *m_pSample;
};


class CASFReader;
class CASFOutput;

// ------------------------------------------------------------------------

//  Implementation of IMediaSeeking
class CImplSeeking : public CUnknown, public IMediaSeeking
{
private:
    CASFReader * const m_pFilter;
    CASFOutput * const m_pPin;

public:
    CImplSeeking(CASFReader *, CASFOutput *, LPUNKNOWN, HRESULT *);
    DECLARE_IUNKNOWN

    //  IMediaSeeking methods
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // returns S_OK if mode is supported, S_FALSE otherwise
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);

    // can only change the mode when stopped
    // (returns VFE_E_WRONG_STATE otherwise)
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);

    // return current properties
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);

    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP SetRate(double dRate);
    STDMETHODIMP GetRate(double * pdRate);
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll) { return E_NOTIMPL; }
};


// ------------------------------------------------------------------------
// output pin
//
//  CASFOutput defines the output pin
//
class CASFOutput : public CBaseOutputPin, /* ISplitterTiming, */ public CCritSec
{
    friend class CASFReaderCallback;
    friend class CASFReader;

public:
    // we use this to prohibit the WMSDK delivering us a VIDEO non-keyframe as the 1st sample
    BOOL m_bFirstSample;

    DECLARE_IUNKNOWN

    // Constructor and Destructor

    CASFOutput( CASFReader   * pFilter,
                DWORD           dwID,
                WM_MEDIA_TYPE  *pStreamType,
                HRESULT        * phr,
                WCHAR *pwszName);

    ~CASFOutput();

    // CUnknown methods

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();

    // CBasePin methods

    // returns the preferred formats for a pin
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // check if the pin can support this specific proposed type and format
    HRESULT CheckMediaType(const CMediaType *);

    // set the connection to use this format (previously agreed)
    HRESULT SetMediaType(const CMediaType *);

#if 0 // !!! not important for the moment....
    // override to call Commit and Decommit
    HRESULT BreakConnect();
#endif

    // CBaseOutputPin methods

    // Force our allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                         ALLOCATOR_PROPERTIES * ppropInputRequest);

        
    // Override to handle quality messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {    return E_NOTIMPL;   // We do NOT handle this
    }

    // Are we the pin being used for seeking
    BOOL IsSeekingPin();

#if 0
    //
    // ISplitterTiming methods
    //
    STDMETHODIMP GetLastPacketTime( LONGLONG *pTime );
    STDMETHODIMP_(BOOL) IsBroadcast();
#endif

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);
    
    //
    // Get an interface via QI on connected filter, if any
    //
    STDMETHODIMP QIConnectedFilter( REFIID riid, void **ppv );

    CASFReader * const m_pFilter;

    DWORD                m_idStream;
    WMT_STREAM_SELECTION m_selDefaultState; // reader's default stream selection state

    DWORD       m_cbToAlloc; // output buffer size
    long        m_nReceived;
    DWORD       m_cToAlloc;
    BOOL        m_bNonPrerollSampleSent; // we went to be sure to send at least one non-preroll video frame on a seek

    /*  Position stuff */
    CImplSeeking       m_Seeking;

    COutputQueue *m_pOutputQueue;  // Streams data to the peer pin
};


class CASFReaderCallback : public CUnknown, public IWMReaderCallback,
            public IWMReaderCallbackAdvanced
{
public:
    DECLARE_IUNKNOWN

    /* Overriden to say what interfaces we support and where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    CASFReader * const m_pFilter;
    
    CASFReaderCallback(CASFReader * pReader) : CUnknown(NAME("ASF reader callback"), NULL),
                                                m_pFilter(pReader)
            {}
                        
public:

    // IWMReaderCallback
    //
    // dwSampleDuration will be 0 for most media types.
    //
    STDMETHODIMP OnSample(DWORD dwOutputNum,
                     QWORD qwSampleTime,
                     QWORD qwSampleDuration,
                     DWORD dwFlags,
                     INSSBuffer *pSample,
                     void *pvContext);

    //
    // The contents pParam depends on the Status.
    //
    STDMETHODIMP OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext);

    // IWMReaderCallbackAdvanced

    //
    // Receive a sample directly from the ASF. To get this call, the user
    // must register himself to receive samples for a particular stream.
    //
    STDMETHODIMP OnStreamSample(WORD wStreamNum,
                           QWORD qwSampleTime,
                           QWORD qwSampleDuration,
                           DWORD dwFlags,
                           INSSBuffer *pSample,
                           void *pvContext);

    //
    // In some cases, the user may want to get callbacks telling what the
    // reader thinks the current time is. This is interesting in 2 cases:
    // - If the ASF has gaps in it; say no audio for 10 seconds. This call
    //   will continue to be called, while OnSample won't be called.
    // - If the user is driving the clock, the reader needs to communicate
    //   back to the user its time, to avoid the user overrunning the reader.
    //
    STDMETHODIMP OnTime(QWORD qwCurrentTime, void *pvContext );

    //
    // The user can also get callbacks when stream selection occurs.
    //
    STDMETHODIMP OnStreamSelection(WORD wStreamCount,
                              WORD *pStreamNumbers,
                              WMT_STREAM_SELECTION *pSelections,
                              void *pvContext );

    //
    // If the user has registered to allocate buffers, this is where he must
    // do it.
    //
    STDMETHODIMP AllocateForOutput(DWORD dwOutputNum,
                               DWORD cbBuffer,
                               INSSBuffer **ppBuffer,
                               void *pvContext );

    STDMETHODIMP OnOutputPropsChanged(DWORD dwOutputNum, WM_MEDIA_TYPE *pMediaType,
                           void *pvContext);

    STDMETHODIMP AllocateForStream(WORD wStreamNum,
                               DWORD cbBuffer,
                               INSSBuffer **ppBuffer,
                               void *pvContext );

};


class CASFReader : public CBaseFilter, public IFileSourceFilter,
                public IAMExtendedSeeking, public IWMHeaderInfo,
                public IWMReaderAdvanced2, public IServiceProvider
#if 0
   ,IAMMediaContent, IMediaPositionBengalHack,
                        IAMNetworkStatus, IAMNetShowExProps,
                        IAMChannelInfo, IAMNetShowConfig,
                        ISpecifyPropertyPages, IAMNetShowThinning, IMediaStreamSelector,
                        IAMOpenProgress, IAMNetShowPreroll, ISplitterTiming, IAMRebuild,
                        IBufferingTime
#endif
{
    
public:
    DECLARE_IUNKNOWN

public:
    // global critical section
    CCritSec    m_csFilter;

    // Lock on setting and getting position values
    //
    CCritSec    m_csPosition;  // Integrity of values set

    /*  Internal classes */

    CASFReader(LPUNKNOWN  pUnk,
              HRESULT   *phr);
    ~CASFReader();

    /* CBaseFilter */
    int GetPinCount();
    CBasePin *GetPin(int n);

    /* IBaseFilter */

    // override Stop to sync with inputpin correctly
    STDMETHODIMP Stop();

    // override Pause to stop ourselves starting too soon
    STDMETHODIMP Pause();

    // override Run to only start timers when we're really running
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // Override GetState to signal Pause failures
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    void _IntSetStart( REFERENCE_TIME Start );

    // Helper
    BOOL IsStopped()
    {
        return m_State == State_Stopped;
    };

public:

    /* Overriden to say what interfaces we support and where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /*  Remove our output pins */
    void RemoveOutputPins(BOOL fReleaseStreamer = TRUE);

    // Override JoinFilterGraph so that we can delay loading a file until we're in a graph
    STDMETHODIMP JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName);

    HRESULT LoadInternal();

    double GetRate();
    void SetRate(double dNewRate);
    bool IsValidPlaybackRate(double dRate);

public: // IFileSourceFilter methods
    STDMETHODIMP Load(
                    LPCOLESTR pszFileName,
                    const AM_MEDIA_TYPE *pmt);

    STDMETHODIMP GetCurFile(
                    LPOLESTR * ppszFileName,
                    AM_MEDIA_TYPE *pmt);

    LPOLESTR      m_pFileName;  // set by Load, used by GetCurFile

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    /*  Send BeginFlush() downstream */
    HRESULT BeginFlush();

    /*  Send EndFlush() downstream */
    HRESULT EndFlush();

    HRESULT SendEOS();
    
    double m_Rate;
    
    CRefTime m_rtStart;
//    CRefTime m_rtMarkerStart;  // equal to m_rtStart, unless starting from a marker....
public:							// Making the Stop time accessible
    CRefTime m_rtStop;

private:
    DWORD    m_dwPacketIDStart;

    HRESULT CallStop();
    HRESULT StopReader();
    HRESULT StopPushing();
    HRESULT StartPushing();
    HRESULT SetupActiveStreams( BOOL bReset ); // if bReset is TRUE, restore default,
                                               // otherwise disable unconnected streams

private:
    //  Allow our internal classes to see our private data 
    friend class CASFOutput;
    friend class CImplSeeking;
    friend class CASFReaderCallback;
    
    CGenericList<CASFOutput> m_OutputPins;

    /*  At end of data so EndOfStream sent for all pins */
    BOOL                     m_bAtEnd;

    // NetShow - specific stuff
private:
    IWMReader          *m_pReader;
    IWMReaderAdvanced  *m_pReaderAdv;
    IWMReaderAdvanced2 *m_pReaderAdv2;
    IWMHeaderInfo      *m_pWMHI;
    IWMReaderCallback  *m_pCallback;
    QWORD               m_qwDuration;  // duration in ms
    BOOL                m_fSeekable;
    WORD                * m_pStreamNums;

    CAMEvent            m_evOpen;
    HRESULT             m_hrOpen;
    CAMEvent            m_evStartStop;  // !!! eliminate or combine with above?
    HRESULT             m_hrStartStop;
    LONG                m_lStopsPending;     // to ensure the reader's only stopped once
    BOOL                m_bUncompressedMode; // used for DRM content

    // !!! needed?
    BOOL                m_fGotStopEvent;
    BOOL                m_fSentEOS;


    // !!! bogus IDispatch impl
    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }
    // !!! end bogosity

    /* IAMExtendedSeeking methods */
    STDMETHODIMP get_ExSeekCapabilities(long FAR* pExCapabilities);
    STDMETHODIMP get_MarkerCount(long FAR* pMarkerCount);
    STDMETHODIMP get_CurrentMarker(long FAR* pCurrentMarker);
    STDMETHODIMP GetMarkerTime(long MarkerNum, double FAR* pMarkerTime);
    STDMETHODIMP GetMarkerName(long MarkerNum, BSTR FAR* pbstrMarkerName);
    STDMETHODIMP put_PlaybackSpeed(double Speed);
    STDMETHODIMP get_PlaybackSpeed(double *pSpeed);

    // IWMHeaderInfo
    STDMETHODIMP GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes );
    STDMETHODIMP GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength );
    STDMETHODIMP GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength );
    STDMETHODIMP SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength );
    STDMETHODIMP GetMarkerCount( WORD *pcMarkers );
    STDMETHODIMP GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime );
    STDMETHODIMP AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime );
    STDMETHODIMP RemoveMarker( WORD wIndex );
    STDMETHODIMP GetScriptCount( WORD *pcScripts );
    STDMETHODIMP GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime );
    STDMETHODIMP AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime );
    STDMETHODIMP RemoveScript( WORD wIndex );

    //
    // IWMReaderAdvanced2
    //
    STDMETHODIMP SetPlayMode( WMT_PLAY_MODE Mode );
    STDMETHODIMP GetPlayMode( WMT_PLAY_MODE *pMode );
    STDMETHODIMP GetBufferProgress( DWORD *pdwPercent, QWORD *pcnsBuffering );
    STDMETHODIMP GetDownloadProgress( DWORD *pdwPercent, QWORD *pqwBytesDownloaded, QWORD *pcnsDownload );
    STDMETHODIMP GetSaveAsProgress( DWORD *pdwPercent );
    STDMETHODIMP SaveFileAs( const WCHAR *pwszFilename );
    STDMETHODIMP GetProtocolName( WCHAR *pwszProtocol, DWORD *pcchProtocol );
    STDMETHODIMP StartAtMarker( WORD wMarkerIndex, 
                                QWORD cnsDuration, 
                                float fRate, 
                                void *pvContext );
    STDMETHODIMP GetOutputSetting( 
                    DWORD dwOutputNum,
                    LPCWSTR pszName,
                    WMT_ATTR_DATATYPE *pType,
                    BYTE *pValue,
                    WORD *pcbLength );
    STDMETHODIMP SetOutputSetting(
                    DWORD dwOutputNum,
                    LPCWSTR pszName,
                    WMT_ATTR_DATATYPE Type,
                    const BYTE *pValue,
                    WORD cbLength );
    STDMETHODIMP Preroll( 
                QWORD cnsStart,
                QWORD cnsDuration,
                float fRate );
    STDMETHODIMP SetLogClientID( BOOL fLogClientID );
    STDMETHODIMP GetLogClientID( BOOL *pfLogClientID );
    STDMETHODIMP StopBuffering( );

    //
    // IWMReaderAdvanced 
    //
    STDMETHODIMP SetUserProvidedClock( BOOL fUserClock );
    STDMETHODIMP GetUserProvidedClock( BOOL *pfUserClock );
    STDMETHODIMP DeliverTime( QWORD cnsTime );
    STDMETHODIMP SetManualStreamSelection( BOOL fSelection );
    STDMETHODIMP GetManualStreamSelection( BOOL *pfSelection );
    STDMETHODIMP SetStreamsSelected( WORD cStreamCount,
                                WORD *pwStreamNumbers,
                                WMT_STREAM_SELECTION *pSelections );
    STDMETHODIMP GetStreamSelected( WORD wStreamNum,
                                    WMT_STREAM_SELECTION *pSelection );
    STDMETHODIMP SetReceiveSelectionCallbacks( BOOL fGetCallbacks );
    STDMETHODIMP GetReceiveSelectionCallbacks( BOOL *pfGetCallbacks );
    STDMETHODIMP SetReceiveStreamSamples( WORD wStreamNum, BOOL fReceiveStreamSamples );
    STDMETHODIMP GetReceiveStreamSamples( WORD wStreamNum, BOOL *pfReceiveStreamSamples );
    STDMETHODIMP SetAllocateForOutput( DWORD dwOutputNum, BOOL fAllocate );
    STDMETHODIMP GetAllocateForOutput( DWORD dwOutputNum, BOOL *pfAllocate );
    STDMETHODIMP SetAllocateForStream( WORD dwStreamNum, BOOL fAllocate );
    STDMETHODIMP GetAllocateForStream( WORD dwSreamNum, BOOL *pfAllocate );
    STDMETHODIMP GetStatistics( WM_READER_STATISTICS *pStatistics );
    STDMETHODIMP SetClientInfo( WM_READER_CLIENTINFO *pClientInfo );
    STDMETHODIMP GetMaxOutputSampleSize( DWORD dwOutput, DWORD *pcbMax );
    STDMETHODIMP GetMaxStreamSampleSize( WORD wStream, DWORD *pcbMax );
    STDMETHODIMP NotifyLateDelivery( QWORD cnsLateness );
    // end of IWMReaderAdvanced methods

#if 0

    // IMediaPositionBengalHack

    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }

    /* IAMMediaContent methods */
    STDMETHODIMP get_AuthorName(THIS_ BSTR FAR* strAuthorName);
    STDMETHODIMP get_Title(THIS_ BSTR FAR* strTitle);
    STDMETHODIMP get_Copyright(THIS_ BSTR FAR* strCopyright);
    STDMETHODIMP get_Description(THIS_ BSTR FAR* strDescription);
    STDMETHODIMP get_Rating(THIS_ BSTR FAR* strRating);
    STDMETHODIMP get_BaseURL(THIS_ BSTR FAR* strBaseURL);
    STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL);
    STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL);
    STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL);
    STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL);
    STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

    /* IMediaPositionBengalHack methods */
    STDMETHODIMP get_CanSetPositionForward(THIS_ long FAR* plCanSetPositionForward);
    STDMETHODIMP get_CanSetPositionBackward(THIS_ long FAR* plCanSetPositionBackward);
    STDMETHODIMP get_CanGoToMarker(THIS_ long lMarkerIndex, long FAR* plCanGoToMarker);
    // !!! why not just use marker times?
    STDMETHODIMP GoToMarker(THIS_ long lMarkerIndex);
//    STDMETHODIMP get_CurrentMarker(THIS_ long FAR* plMarkerIndex);


    // additional methods to define:
    // get current play statistics
    
    /* IAMNetworkStatus methods */
    STDMETHODIMP get_ReceivedPackets(long FAR* pReceivedPackets);
    STDMETHODIMP get_RecoveredPackets(long FAR* pRecoveredPackets);
    STDMETHODIMP get_LostPackets(long FAR* pLostPackets);
    STDMETHODIMP get_ReceptionQuality(long FAR* pReceptionQuality);
    STDMETHODIMP get_BufferingCount(long FAR* pBufferingCount);
    STDMETHODIMP get_IsBroadcast(VARIANT_BOOL FAR* pIsBroadcast);
    STDMETHODIMP get_BufferingProgress(long FAR* pBufferingProgress);

    /* IAMNetShowExProps methods */
    STDMETHODIMP get_SourceProtocol(long FAR* pSourceProtocol);
    STDMETHODIMP get_Bandwidth(long FAR* pBandwidth);
    STDMETHODIMP get_ErrorCorrection(BSTR FAR* pbstrErrorCorrection);
    STDMETHODIMP get_CodecCount(long FAR* pCodecCount);
    STDMETHODIMP GetCodecInstalled(long CodecNum, VARIANT_BOOL FAR* pCodecInstalled);
    STDMETHODIMP GetCodecDescription(long CodecNum, BSTR FAR* pbstrCodecDescription);
    STDMETHODIMP GetCodecURL(long CodecNum, BSTR FAR* pbstrCodecURL);
    STDMETHODIMP get_CreationDate(DATE FAR* pCreationDate);
    STDMETHODIMP get_SourceLink(BSTR FAR* pbstrSourceLink);


    // !!! former IAMExtendedSeeking methods
    STDMETHODIMP put_CurrentMarker(long CurrentMarker);
    STDMETHODIMP get_CanScan(VARIANT_BOOL FAR* pCanScan);
    STDMETHODIMP get_CanSeek(VARIANT_BOOL FAR* pCanSeek);
    STDMETHODIMP get_CanSeekToMarkers(VARIANT_BOOL FAR* pCanSeekToMarkers);

    /* IAMChannelInfo methods */
    STDMETHODIMP get_ChannelName(BSTR FAR* pbstrChannelName);
    STDMETHODIMP get_ChannelDescription(BSTR FAR* pbstrChannelDescription);
    STDMETHODIMP get_ChannelURL(BSTR FAR* pbstrChannelURL);
    STDMETHODIMP get_ContactAddress(BSTR FAR* pbstrContactAddress);
    STDMETHODIMP get_ContactPhone(BSTR FAR* pbstrContactPhone);
    STDMETHODIMP get_ContactEmail(BSTR FAR* pbstrContactEmail);

    /* IAMNetShowConfig methods */
    STDMETHODIMP get_BufferingTime(double FAR* pBufferingTime);
    STDMETHODIMP put_BufferingTime(double BufferingTime);
    STDMETHODIMP get_UseFixedUDPPort(VARIANT_BOOL FAR* pUseFixedUDPPort);
    STDMETHODIMP put_UseFixedUDPPort(VARIANT_BOOL UseFixedUDPPort);
    STDMETHODIMP get_FixedUDPPort(LONG FAR* pFixedUDPPort);
    STDMETHODIMP put_FixedUDPPort(LONG FixedUDPPort);
    STDMETHODIMP get_UseHTTPProxy(VARIANT_BOOL FAR* pUseHTTPProxy);
    STDMETHODIMP put_UseHTTPProxy(VARIANT_BOOL UseHTTPProxy);
    STDMETHODIMP get_EnableAutoProxy( VARIANT_BOOL FAR* pEnableAutoProxy );
    STDMETHODIMP put_EnableAutoProxy( VARIANT_BOOL EnableAutoProxy );
    STDMETHODIMP get_HTTPProxyHost(BSTR FAR* pbstrHTTPProxyHost);
    STDMETHODIMP put_HTTPProxyHost(BSTR bstrHTTPProxyHost);
    STDMETHODIMP get_HTTPProxyPort(LONG FAR* pHTTPProxyPort);
    STDMETHODIMP put_HTTPProxyPort(LONG HTTPProxyPort);
    STDMETHODIMP get_EnableMulticast(VARIANT_BOOL FAR* pEnableMulticast);
    STDMETHODIMP put_EnableMulticast(VARIANT_BOOL EnableMulticast);
    STDMETHODIMP get_EnableUDP(VARIANT_BOOL FAR* pEnableUDP);
    STDMETHODIMP put_EnableUDP(VARIANT_BOOL EnableUDP);
    STDMETHODIMP get_EnableTCP(VARIANT_BOOL FAR* pEnableTCP);
    STDMETHODIMP put_EnableTCP(VARIANT_BOOL EnableTCP);
    STDMETHODIMP get_EnableHTTP(VARIANT_BOOL FAR* pEnableHTTP);
    STDMETHODIMP put_EnableHTTP(VARIANT_BOOL EnableHTTP);

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMRebuild
    STDMETHODIMP RebuildNow();

    // --- IAMOpenProgress methods ---
    STDMETHODIMP QueryProgress(LONGLONG* pllTotal, LONGLONG* pllCurrent);
    STDMETHODIMP AbortOperation();

    //
    // IAMNetShowThinning
    //
    STDMETHODIMP GetLevelCount( long *pcLevels );
    STDMETHODIMP GetCurrentLevel( long *pCurrentLevel );
    STDMETHODIMP SetNewLevel( long NewLevel );
    STDMETHODIMP GetAutoUpdate( long *pfAutoUpdate );
    STDMETHODIMP SetAutoUpdate( long fAutoUpdate );

    //
    // IMediaStreamSelector
    //
    STDMETHODIMP ReduceBandwidth( IMediaStream *pStream, long RecvRate );
    STDMETHODIMP IncreaseBandwidth( IMediaStream *pStream, long RecvRate );

    //
    // IAMNetShowPreroll
    //
    STDMETHODIMP put_Preroll( VARIANT_BOOL fPreroll );
    STDMETHODIMP get_Preroll( VARIANT_BOOL *pfPreroll );

    //
    // ISplitterTiming Methods
    //
    STDMETHODIMP GetLastPacketTime(LONGLONG *pTime);
    STDMETHODIMP_(BOOL) IsBroadcast();

    //
    // IBufferingTime Methods
    //
    STDMETHODIMP GetBufferingTime( DWORD *pdwMilliseconds );
    STDMETHODIMP SetBufferingTime( DWORD dwMilliseconds );
#endif
};

extern const double NORMAL_PLAYBACK_SPEED;

inline double CASFReader::GetRate()
{
    ASSERT( IsValidPlaybackRate(m_Rate) );

    return m_Rate;
}

inline void CASFReader::SetRate(double dNewRate)
{
    // IWMReader::Start() only accepts rates between 1 and 10 and between -1 and -10.
    // See the documentation for IWMReader::Start() for more information.
    ASSERT(((-10.0 <= dNewRate) && (dNewRate <= -1.0)) || ((1.0 <= dNewRate) && (dNewRate <= 10.0)));

    ASSERT( IsValidPlaybackRate(dNewRate) );
    
    m_Rate = dNewRate;
}

inline bool CASFReader::IsValidPlaybackRate(double dRate)
{
    // The WM ASF Reader only supports normal playback speeds.  It does 
    // not support fast forward or rewind.
    return (NORMAL_PLAYBACK_SPEED == dRate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\asfwrite.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <atlbase.h>
#include <wmsdk.h>
#include <wmsysprf.h>
#include "asfwrite.h"
#include "proppage.h"
#include <initguid.h>

// put a pin to sleep if it gets this far ahead of another
#define BLOCKINGSIZE (1*UNITS/2) 

//
// wake blocking pins up when the slower pin is within this range
// use a value that's something less than BLOCKINGSIZE to avoid oscillating back and
// forth too much
//
// NOTE!!! - the wmsdk requires that we don't let the video time get too close to
//           a blocking audio thread. Currently they'll start blocking video when it 
//           gets within at least 66ms of the audio, so make sure this is at least 
//           greater than that.
//
#define WAKEUP_RANGE ( BLOCKINGSIZE - 200 * (UNITS/MILLISECONDS) )


// setup data
const AMOVIESETUP_FILTER sudWMAsfWriter =
{ &CLSID_WMAsfWriter       // clsID
, L"WM ASF Writer"      // strName
, MERIT_UNLIKELY        // dwMerit
, 0                     // nPins
, NULL   };             // lpPin

// need a way to keep track of whether the filter asf profile was configured 
// using a profile id or guid (or neither, since an app can give us just us a profile too)
enum CONFIG_FLAGS {
    CONFIG_F_BY_GUID = 1,
    CONFIG_F_BY_ID 
};

#ifdef FILTER_DLL

/*****************************************************************************/
// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    { L"WM ASF Writer"
    , &CLSID_WMAsfWriter
    , CWMWriter::CreateInstance
    , NULL
    , &sudWMAsfWriter },
    
    { L"WM ASF Writer Properties"
    , &CLSID_WMAsfWriterProperties
    , CWMWriterProperties::CreateInstance }
    
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif


/******************************Public*Routine******************************\
* CreateInstance
*
* This goes in the factory template table to create new instances
*
\**************************************************************************/
CUnknown * CWMWriter::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::CreateInstance")));
    return new CWMWriter(TEXT("WMWriter filter"), pUnk, CLSID_WMAsfWriter, phr);
}

// ------------------------------------------------------------------------
//
// NonDelegatingQueryInterface
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IMediaSeeking) {
        return GetInterface((IMediaSeeking *)this, ppv);
    } else if(riid == IID_IAMFilterMiscFlags) {
        return GetInterface((IAMFilterMiscFlags *)this, ppv);
    } else if(riid == IID_IFileSinkFilter2) {     
        return GetInterface((IFileSinkFilter2 *) this, ppv);
    } else if(riid == IID_IFileSinkFilter) {
        return GetInterface((IFileSinkFilter *) this, ppv);
    } else if (IID_ISpecifyPropertyPages == riid) {
        return GetInterface ((ISpecifyPropertyPages *) this, ppv);
    } else if (IID_IConfigAsfWriter == riid) {
        return GetInterface ((IConfigAsfWriter *) this, ppv);
    } else if (IID_IPersistStream == riid) {
        return GetInterface ((IPersistStream *) this, ppv);
    } else if (IID_IWMHeaderInfo == riid) {
        return GetInterface ((IWMHeaderInfo *) this, ppv);
    } else if (IID_IServiceProvider == riid) {
        return GetInterface ((IServiceProvider *) this, ppv);
    } else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
//
// CWMWriter::CWMWriter
//
// ------------------------------------------------------------------------
CWMWriter::CWMWriter( 
    TCHAR     *pName,
    LPUNKNOWN pUnk,
    CLSID     clsid,
    HRESULT   *phr )
    : CBaseFilter(pName, pUnk, &m_csFilter, clsid)
    , m_TimeFormat(FORMAT_TIME)
    , m_fErrorSignaled(0)
    , m_cInputs( 0 )
    , m_cAudioInputs( 0 )
    , m_cVideoInputs( 0 )
    , m_cConnections( 0 )
    , m_cConnectedAudioPins( 0 )
    , m_cActiveAudioStreams( 0 )
    , m_wszFileName( 0 )
    , m_pWMWriter( NULL )
    , m_pWMWriterAdvanced( NULL )
    , m_pWMHI( NULL )
    , m_pWMProfile( NULL )
    , m_fdwConfigMode( CONFIG_F_BY_GUID ) // initialize using a hand-picked guid
    , m_guidProfile( WMProfile_V70_256Video ) // default 7.0 profile
    , m_lstRecycledPins(NAME("List of recycled input pins"))
    , m_lstInputPins(NAME("List of input pins"))
    , m_dwProfileId( PROFILE_ID_NOT_SET )
    , m_hrIndex( S_OK )
    , m_bIndexFile( TRUE )
    , CPersistStream(pUnk, phr)
    , m_pUnkCert( NULL )
    , m_dwOpenFlags( AM_FILE_OVERWRITE ) // only mode we support currently
    , m_bResetFilename( TRUE )
{
    ASSERT(phr != NULL);
    
    if( FAILED( *phr ) )
        return ;

    DbgLog((LOG_TRACE, 5, TEXT("CWMWriter: constructed")));
}

// ------------------------------------------------------------------------
//
// destructor
//
// ------------------------------------------------------------------------
CWMWriter::~CWMWriter()
{
    // delete the profile
    DeleteProfile();
        
    // close file (doesn't really do anything, but just in case it needs to later)
    Close();

    // free the writer
    ReleaseWMWriter();
    
    // free the certification object
    if( m_pUnkCert )
        m_pUnkCert->Release();
            
    // delete the pins
    DeletePins();

    // delete recycled pins
    CWMWriterInputPin * pwp;
    while ( pwp = m_lstRecycledPins.RemoveHead() )
    {
        delete pwp;
    }

    // sanity check that we've really cleaned up everything
    ASSERT( 0 == m_lstRecycledPins.GetCount() );
    ASSERT( 0 == m_lstInputPins.GetCount() );
    ASSERT( 0 == m_cAudioInputs );
    ASSERT( 0 == m_cVideoInputs );
    ASSERT( 0 == m_cInputs );
    
    delete[] m_wszFileName;
    m_wszFileName = 0;
}

void CWMWriter::DeletePins( BOOL bRecycle )
{
    CWMWriterInputPin * pwp;
    while ( pwp = m_lstInputPins.RemoveHead() )
    {
        m_cInputs--;
        ASSERT( !pwp->IsConnected() );
        if( PINTYPE_AUDIO == pwp->m_fdwPinType )
            m_cAudioInputs--;
        else if( PINTYPE_VIDEO == pwp->m_fdwPinType )
            m_cVideoInputs--;
        
        if( bRecycle )    
            m_lstRecycledPins.AddTail( pwp );
        else
            delete pwp;            
    }
}


void CWMWriter::ReleaseWMWriter()
{
    if( m_pWMHI )
    {
        m_pWMHI->Release();
        m_pWMHI = NULL;
    }    

    if( m_pWMWriterAdvanced )
    {
        m_pWMWriterAdvanced->Release();
        m_pWMWriterAdvanced = NULL;
    }    

    if( m_pWMWriter )
    {
        m_pWMWriter->Release();
        m_pWMWriter = NULL;
    }
}    

// ------------------------------------------------------------------------
//
// CreateWMWriter - create the WMWriter and advanced writer, release old
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CreateWMWriter()
{
    ReleaseWMWriter(); // in case we already have one
        
    ASSERT( m_pUnkCert );
    if( !m_pUnkCert )
        return E_FAIL;
   

    HRESULT hr = S_OK;

    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateWriter( m_pUnkCert, &m_pWMWriter );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("CWMWriter::CreateWMWriter - WMCreateWriter failed ( hr = 0x%08lx)."), 
                hr));
            return hr;
        }
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateWriter probably due to wmvcore.dll not present. Aborting. ")));
        return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }

    //
    // also grab the advanced writer interface here as well in case we need
    // to send data directly to writer
    //
    hr = m_pWMWriter->QueryInterface( IID_IWMWriterAdvanced, (void **) &m_pWMWriterAdvanced );
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
            TEXT("CWMWriter::CreateWMWriter - Unable to create IWMWriterAdvanced(0x%08lx)."), 
            hr));
        return hr;
    }
     
    hr = m_pWMWriter->QueryInterface( IID_IWMHeaderInfo, (void **) &m_pWMHI );
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
            TEXT("CWMWriter::CreateWMWriter - Unable to create IWMHeaderInfo(0x%08lx)."), 
            hr));
        return hr;
    }
    
    hr = Open();
    if( FAILED( hr ) )
    {
        return hr;
    }
                
    ASSERT( m_pWMWriter );
    ASSERT( m_pWMWriterAdvanced );
    ASSERT( m_pWMHI );
    
    return hr;
}

// ------------------------------------------------------------------------
//
// Open - give the WMWriter the filename
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::Open()
{
    ASSERT( m_pWMWriter );
    
    HRESULT hr = S_OK;

    if( !m_pWMWriter )
    {    
        return E_FAIL;
    }
    
    if( !m_wszFileName )
    {    
        return S_OK;
    }
    
    // !!! support filenames like http://8080.asf to mean "use HTTP
    // with port 8080"

    // !!! will also need code to look for msbd:// once that's added to
    // Artemis
    if (
      ((m_wszFileName[0] == _T('H')) || (m_wszFileName[0] == _T('h'))) &&
      ((m_wszFileName[1] == _T('T')) || (m_wszFileName[1] == _T('t'))) &&
      ((m_wszFileName[2] == _T('T')) || (m_wszFileName[2] == _T('t'))) &&
      ((m_wszFileName[3] == _T('P')) || (m_wszFileName[3] == _T('p'))) &&
      (m_wszFileName[4] == _T(':')) &&
      (m_wszFileName[5] == _T('/')) &&
      (m_wszFileName[6] == _T('/'))
       )
    {
        DWORD dwPortNumber = atoiW(m_wszFileName + 7);

	
        if (dwPortNumber == 0)
            dwPortNumber = 80;
	
        IWMWriterNetworkSink*   pNetSink = NULL;
        
        // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
        __try 
        {
            hr = WMCreateWriterNetworkSink( &pNetSink );
            if( FAILED( hr ) )
            {
                DbgLog(( LOG_TRACE, 1,
                    TEXT("CWMWriter::Open - WMCreateWriterNetworkSink failed ( hr = 0x%08lx)."), 
                    hr));
                return hr;
            }
        }
        __except (  EXCEPTION_EXECUTE_HANDLER ) 
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("CWMWriter::Open - Exception calling WMCreateWriterNetworkSink probably due to wmvcore.dll not present. Aborting. ")));
            return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
        }
            
        
        // !!! call SetNetworkProtocol?
	
        hr = pNetSink->Open( &dwPortNumber );
        if( SUCCEEDED( hr ) )
        {
            hr = m_pWMWriterAdvanced->AddSink( pNetSink );
            if( FAILED( hr ) )
            {
                DbgLog((LOG_TRACE, 1, TEXT("AddSink failed, hr = %x"), hr));
            }
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("Couldn't open the net sink, hr = %x"), hr ));
        }
        pNetSink->Release();
    } 
    else
    {
        // for files, we configure the wmsdk writer on Pause
        m_bResetFilename = TRUE;
    }    
    return hr;
}

// ------------------------------------------------------------------------
//
// Close - close file 
//
// ------------------------------------------------------------------------
void CWMWriter::Close( void )
{
    // note that Close doesn't delete m_wszFileName, SetFilename and destructor do
}

// ------------------------------------------------------------------------
//
// DeleteProfile 
//
// Delete profile and anything dependent on one, like the input 
// media type list for each pin.
//
// ------------------------------------------------------------------------
void CWMWriter::DeleteProfile()
{
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        if( pwp->m_pWMInputMediaProps )
        {
            pwp->m_pWMInputMediaProps->Release();
            pwp->m_pWMInputMediaProps = NULL;
        }
    }

    if( m_pWMProfile )
    {
        m_pWMProfile->Release();
        m_pWMProfile = NULL;
    }
}

// ------------------------------------------------------------------------
//
// AddNextPin - Create or recycle a pin
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::AddNextPin
(
    unsigned callingPin, 
    DWORD dwPinType, 
    IWMStreamConfig * pWMStreamConfig
)
{
    CAutoLock lock(&m_csFilter);
    HRESULT hr;
    WCHAR wsz[20];
    
    switch( dwPinType )
    {
        case PINTYPE_AUDIO:
            lstrcpyW(wsz, L"Audio Input 00");
            wsz[12] = (WCHAR)(L'0' + (m_cAudioInputs + 1) / 10);
            wsz[13] = (WCHAR)(L'0' + (m_cAudioInputs + 1) % 10);
            break;

        case PINTYPE_VIDEO:
            lstrcpyW(wsz, L"Video Input 00");
            wsz[12] = (WCHAR)(L'0' + (m_cVideoInputs + 1) / 10);
            wsz[13] = (WCHAR)(L'0' + (m_cVideoInputs + 1) % 10);
            break;
            
        default:
            ASSERT( FALSE ); 
            return E_FAIL;
    }            
        
    hr = S_OK;
    
    // see if there's a pin on the recycle or whether we need to create a new one
    CWMWriterInputPin * pwp = m_lstRecycledPins.RemoveHead();
    if( !pwp )
    {
        // oh well, we tried
        pwp = new CWMWriterInputPin(this, &hr, wsz, m_cInputs, dwPinType, pWMStreamConfig);
        if( NULL == pwp )
            return E_OUTOFMEMORY;
    }
    else
    {
        // for recycled pins update their internals (could just always require this, even for new pins?)
        pwp->Update( wsz, m_cInputs, dwPinType, pWMStreamConfig );
        DbgLog(( LOG_TRACE, 3,
                 TEXT("CWMWriter::AddNextPin recycling a pin")));
    }
    
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::AddNextPin create pin failed")));
    }
    else
    { 
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::added 1 pin")));
    
        m_lstInputPins.AddTail( pwp );
    
        m_cInputs++;
        if( PINTYPE_AUDIO == dwPinType )
            m_cAudioInputs++;
        else if( PINTYPE_VIDEO == dwPinType )
            m_cVideoInputs++;
    }

    ASSERT( m_cConnections <= m_cInputs );
    ASSERT( m_cConnections <= m_lstInputPins.GetCount() );

    return hr;
}

// ------------------------------------------------------------------------
//
// LoadInternal
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::LoadInternal()
{
    ASSERT( m_pUnkCert );
        
    HRESULT hr = S_OK;
    
    //
    // Do we already have a writer object? If so, use it and don't re-create one.
    //
    // This perf fix was made for MovieMaker to allow them to more quickly transition
    // from a preview graph to a record graph, by not releasing and recreating the writer 
    // on a graph rebuild.
    //
    if( !m_pWMWriter )
    {    
        // create the wmsdk writer objects
        hr = CreateWMWriter();
        if( SUCCEEDED( hr ) )
        {                    
            DbgLog((LOG_TRACE, 8, TEXT("CWMWriter::LoadInternal - created wmsdk writer object")));
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::LoadInternal failed to create wmsdk writer object(0x%08lx)"),hr));
        }                    
                
        //
        // now configure the filter...
        //
        // initialize to a default profile guid
        // user can override at any time by calling ConfigureFilterUsingProfile (or ProfileId)
        //
        if( SUCCEEDED( hr ) )
        {        
            ASSERT( m_pWMWriter );
            // first try our default or persisted profile
            hr = ConfigureFilterUsingProfileGuid( m_guidProfile );
            if( FAILED( hr ) )
            {
                // if that didn't work try a 4.0 (apollo) in case this is a legacy wmsdk platform
                hr = ConfigureFilterUsingProfileGuid( WMProfile_V40_250Video );
            }
        }
    }        
    return hr;
}

// ------------------------------------------------------------------------
// CBaseFilter methods
// ------------------------------------------------------------------------


// ------------------------------------------------------------------------
//
// JoinFilterGraph - need to be in graph to initialize keying mechanism
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if(FAILED( hr ) )
        return hr;
    
    if( !pGraph )
    {
        // if filter is removed from the graph, release the certification object.
        // we don't want to be run outside of a graph
        if( m_pUnkCert )
        {        
            m_pUnkCert->Release();
            m_pUnkCert = NULL;
        }            
    }    
    else
    {
        ASSERT( !m_pUnkCert );
        
        // unlock writer
        IObjectWithSite *pSite;
        hr = pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
        if (SUCCEEDED(hr)) 
        {
            IServiceProvider *pSP;
            hr = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
            pSite->Release();
            
            if (SUCCEEDED(hr)) 
            {
                // !!! should I pass IID_IWMWriter?  any purpose to letting app see the difference?
                hr = pSP->QueryService(IID_IWMReader, IID_IUnknown, (void **) &m_pUnkCert);
                pSP->Release();
                if (SUCCEEDED(hr)) 
                {
                    DbgLog((LOG_TRACE, 8, TEXT("CWMWriter::JoinFilterGraph got wmsdk certification (m_pUnkCert = 0x%08lx)"), m_pUnkCert));
                    hr = LoadInternal();
                    if( FAILED( hr ) )
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::JoinFilterGraph LoadInternal failed (0x%08lx)"), hr));
                    }                    
                }
                else
                {
                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::JoinFilterGraph QueryService for certification failed (0x%08lx)"), hr));
                    
                    // change error to certification error
                    hr = VFW_E_CERTIFICATION_FAILURE;
                }                
            }
            else
            {
                hr = VFW_E_CERTIFICATION_FAILURE;
            }                            
            if( FAILED( hr ) )
            {
                // up-oh, we failed to join, but the base class thinks we did, 
                // so we need to unjoin the base class
                CBaseFilter::JoinFilterGraph(NULL, NULL);
            }            
        }
        else
        {
            hr = VFW_E_CERTIFICATION_FAILURE;
        }            
    }
    return hr;
}


// ------------------------------------------------------------------------
//
// GetPin
//
// ------------------------------------------------------------------------
CBasePin* CWMWriter::GetPin(int n)
{
    if(n < (int)m_cInputs && n >= 0)
        return GetPinById( n );
    else
        return 0;
}

// ------------------------------------------------------------------------
//
// GetPinCount
//
// ------------------------------------------------------------------------
int CWMWriter::GetPinCount()
{
  return m_cInputs;
}

// ------------------------------------------------------------------------
//
// CompleteConnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CompleteConnect( int numPin )
{
    CAutoLock lock(&m_csFilter);
    HRESULT hr = S_OK;
    
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriterInputPin::CompleteConnect") ));

    CWMWriterInputPin * pwp = GetPinById( numPin );
    if( NULL == pwp )
        return E_INVALIDARG;
       
    m_cConnections++;
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriter::CompleteConnect %i"), m_cConnections ));
    
    if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        m_cConnectedAudioPins++;
        
    ASSERT(m_cConnections <= m_cInputs);
    ASSERT( m_cConnectedAudioPins < 2 );
    
    return hr;
}

// ------------------------------------------------------------------------
//
// GetPinById
//
// ------------------------------------------------------------------------
CWMWriterInputPin * CWMWriter::GetPinById( int numPin )
{
    POSITION Pos = m_lstInputPins.GetHeadPosition();
    CWMWriterInputPin * pwp;
    while( Pos != NULL ) 
    {
        pwp = m_lstInputPins.GetNext(Pos); 
        if( numPin == pwp->m_numPin )
            return pwp;
    }
    return NULL;
}

// ------------------------------------------------------------------------
//
// BreakConnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::BreakConnect( int numPin )
{
    CAutoLock lock(&m_csFilter);

    CWMWriterInputPin * pwp = GetPinById( numPin );
    if( NULL == pwp )
        return E_INVALIDARG;

    ASSERT(m_cConnections > 0);
    m_cConnections--;

    if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        m_cConnectedAudioPins--;
    
    ASSERT( m_cConnectedAudioPins >= 0 );
        
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriter::BreakConnect %i"), m_cConnections ));
             
    return S_OK;
}

// ------------------------------------------------------------------------
//
// StartStreaming
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::StartStreaming()
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::StartStreaming()")));
   
    // first check if we're writing live data
    BOOL bLive = FALSE;
        
    ASSERT( m_pGraph );
    IAMGraphStreams *pgs;
    HRESULT hr = m_pGraph->QueryInterface( IID_IAMGraphStreams, (void **) &pgs );
    if( SUCCEEDED( hr ) )
    {   
        // go through each of our input pins and see if any is being sourced by live data
        // stop when we find any live source
        for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos && !bLive ; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

            IAMPushSource *pPushSource = NULL;
            HRESULT hrInt = pgs->FindUpstreamInterface( pwp
                                                      , IID_IAMPushSource
                                                      , (void **) &pPushSource
                                                      , AM_INTF_SEARCH_OUTPUT_PIN ); 
            if( SUCCEEDED( hrInt ) )
            {
                ULONG ulPushSourceFlags = 0;
                hrInt = pPushSource->GetPushSourceFlags(&ulPushSourceFlags);
                ASSERT( SUCCEEDED( hrInt ) );
                if( SUCCEEDED( hrInt ) )
                {
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found push source (ulPushSourceFlags = 0x%08lx)")
                          , ulPushSourceFlags ) );
                    if( 0 == ( AM_PUSHSOURCECAPS_NOT_LIVE & ulPushSourceFlags ) )
                    {
                        // yes, this is live data
                        bLive = TRUE;
                    }                    
                }
                pPushSource->Release();         
            }
            else
            {
                // workaround for live graphs where the audio capture pin doesn't yet
                // support IAMPushSource
                IKsPropertySet * pKs;
                hrInt = pgs->FindUpstreamInterface( pwp
                                                  , IID_IKsPropertySet
                                                  , (void **) &pKs
                                                  , AM_INTF_SEARCH_OUTPUT_PIN ); // search output pins
                // this will only find the first one so beware!!
                if( SUCCEEDED( hrInt ) )             
                {   
                    GUID guidCategory;
                    DWORD dw;
                    hrInt = pKs->Get( AMPROPSETID_Pin
                                    , AMPROPERTY_PIN_CATEGORY
                                    , NULL
                                    , 0
                                    , &guidCategory
                                    , sizeof(GUID)
                                    , &dw );
                    if( SUCCEEDED( hrInt ) )
                    {
                        DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found IKsPropertySet pin. Checking pin category...") ) );
                        if( guidCategory == PIN_CATEGORY_CAPTURE )
                        {
                        
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found capture pin even though no IAMPushSource support") ) );
                            bLive = TRUE;
                        } 
                    }                    
                    pKs->Release();
                }                
            }
        }            
        pgs->Release();
    }            
    
    HRESULT hrInt2 = m_pWMWriterAdvanced->SetLiveSource( bLive );
    DbgLog( ( LOG_TRACE, 3, TEXT("CWMWriter:StartStreaming SetLiveSource( bLive = %2d )"), bLive ) );
    ASSERT( SUCCEEDED( hrInt2 ) );
   
    // 
    // set WMSDK sync tolerance to 0 to avoid sample blocking problems
    //
    hr = m_pWMWriterAdvanced->SetSyncTolerance( 0 );
    ASSERT( SUCCEEDED( hr ) );
#ifdef DEBUG    
    if( SUCCEEDED( hr ) )
    {    
        DWORD dwSyncTolInMS;
        hr = m_pWMWriterAdvanced->GetSyncTolerance( &dwSyncTolInMS );
        if( SUCCEEDED( hr ) )
        {
            DbgLog((LOG_TRACE, 5, TEXT("CWMWriter::Pause WMSDK writer's sync tolerance = %ldms"), dwSyncTolInMS));
        }
    }        
#endif        

    // finally, take a count of active audio streams before running
    m_cActiveAudioStreams = 0;
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos ; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        if( PINTYPE_AUDIO == pwp->m_fdwPinType )
        {
            m_cActiveAudioStreams++;
        }        
    }            
    
    // then the wmsdk writer should be ready to roll...
    hr = m_pWMWriter->BeginWriting();
    if( FAILED( hr ) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("CWMWriter::Pause WMWriter::BeginWriting failed [hr=0x%08lx]"), hr));
        return( hr );
    }
    
    return hr;
}

// ------------------------------------------------------------------------
//
// StopStreaming
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::StopStreaming()
{
    DbgLog((LOG_TRACE, 2, TEXT("CWMWriter::StopStreaming()")));
   
    // first wake all input streams, in case any are blocked
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos ; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        pwp->WakeMeUp();
    }            
     
    //
    // tell the wm writer we're done
    //
    HRESULT hr = m_pWMWriter->EndWriting();
    if( FAILED( hr ) )
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::StopStreaming IWMWriter::EndWriting failed [hr=0x%08lx]"), hr));
    }
    if( SUCCEEDED( hr ) && m_bIndexFile )
    {    
        hr = IndexFile();
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2,
                     TEXT("CWMWriter::StopStream IWMWriter::IndexFile failed [hr=0x%08lx]"), hr));
        }        
    }
    m_cActiveAudioStreams = 0;
    return hr;
}

// ------------------------------------------------------------------------
//
// Receive
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::Receive( CWMWriterInputPin * pPin, IMediaSample * pSample, REFERENCE_TIME *prtStart, REFERENCE_TIME *prtEnd )
{
    HRESULT hr = S_OK;

    if(m_State != State_Stopped)
    {
        if(!m_fErrorSignaled)
        {
            hr = S_OK;

            if( 0 == m_cActiveAudioStreams )
            {
                ASSERT( PINTYPE_AUDIO != pPin->m_fdwPinType );
                
                //
                // !Important: If there's no active audio stream make sure we don't deliver a video 
                // (or non-audio) sample with a sample time later than the end time of the last audio 
                // sample passed to the wmsdk, since they may never release it!!
                //
                REFERENCE_TIME rtLastAudioTimeExtent = 0;
                for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
                {   
                    CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

                    if( pwp == pPin ) // skip ourself
                        continue;
                        
                    if( pwp->m_fdwPinType == PINTYPE_AUDIO )
                    {
                        ASSERT( pwp->m_fEOSReceived );
                        
                        // this audio stream ended
                        if( pwp->m_rtLastDeliveredEndTime > rtLastAudioTimeExtent )
                            rtLastAudioTimeExtent = pwp->m_rtLastDeliveredEndTime;
                            
                    }
                }
                if( *prtStart > rtLastAudioTimeExtent )    
                {
                    //
                    // this sample starts later than the end time of the last audio queued. 
                    // don't send it!
                    //
                    DbgLog((LOG_TRACE, 5,
                            TEXT("CWMWriter::Receive WARNING: Rejecting a non-audio sample starting beyond the last audio time (last audio time %dms)! Forcing EOS"),
                            (DWORD)(rtLastAudioTimeExtent / 10000 ) ) );
                    //                            
                    // force EOS for this pin
                    //
                    if( !pPin->m_fEOSReceived )
                        pPin->EndOfStream();                            
    
                    return S_OK;                            
                }                                    
            }   
            
            INSSBuffer * pNSSBuffer = NULL;
            if( pPin->m_bCompressedMode )
            {
                //
                // the compressed input case - have the WMSDK writer do a copy
                // deadlock problems may result otherwise. 
                // for example, we've noticed uncompressed audio needs 3 seconds of
                // buffering before the writer gets moving
                //
                // this block has the WMSDK allocate a new INSSBuffer sample that we 
                // copy our sample into
                //
                BYTE * pbBuffer;
                DWORD  cbBuffer;
        
                hr = m_pWMWriter->AllocateSample( pSample->GetSize(), &pNSSBuffer );
                if( SUCCEEDED( hr ) )
                {
                    hr = CopyOurSampleToNSBuffer( pNSSBuffer, pSample );
                }
            }
            else
            {
                //
                // the uncompressed input case - avoid unnecessary copy
                // this block takes the IMediaSample that we've been given and wraps
                // with our private class to make it look like an INSSBuffer, thus
                // avoiding the extra copy
                //
                CWMSample *pWMSample = new CWMSample(NAME("WMSample"),pSample) ;
                if( pWMSample )
                {
                    hr = pWMSample->QueryInterface( IID_INSSBuffer, (void **) &pNSSBuffer );
                    ASSERT( SUCCEEDED( hr ) );
                }
            }

            if( pNSSBuffer && SUCCEEDED( hr ) )
            {
                // prepare sample flags
                DWORD dwSampleFlags = 0;
                if( S_OK == pSample->IsDiscontinuity() )
                {
                    dwSampleFlags |= WM_SF_DISCONTINUITY;
                }                
                if( S_OK == pSample->IsSyncPoint() )
                {
                    dwSampleFlags |= WM_SF_CLEANPOINT;
                }                
                
                if( pPin->m_bCompressedMode )
                {
                    ASSERT( m_pWMWriterAdvanced );
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive calling WriteStreamSample (adjusted rtStart = %dms)"),
                            (LONG) (*prtStart / 10000) ) );
                    // for now assume each input pin maps to 1 output stream (which are 1-based)
                    hr = m_pWMWriterAdvanced->WriteStreamSample(  (WORD) (pPin->m_numPin+1), // assume 1-1 in-out mapping
                                                                  *prtStart,     // presentation time
                                                                  0xFFFFFFFF,    // not yet supported by wmdsdk
                                                                  0xFFFFFFFF,    // ditto
                                                                  dwSampleFlags,
                                                                  pNSSBuffer );  // the data
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive back from WriteStreamSample") ) );
                }
                else
                {                    
                    DbgLog((LOG_TRACE, 15,
                            TEXT("CWMWriter::Receive calling WriteSample (adjusted rtStart = %dms)"),
                            (LONG) (*prtStart / 10000) ) );
                    hr = m_pWMWriter->WriteSample(  pPin->m_numPin,// input number
                                                    *prtStart,    // presentation time
                                                    dwSampleFlags,
                                                    pNSSBuffer );  // the data
                    DbgLog((LOG_TRACE, 15, 
                            TEXT("CWMWriter::Receive back from WriteSample") ) );
                }                            
                pNSSBuffer->Release(); 
                pPin->m_rtLastDeliveredStartTime = *prtStart;
                pPin->m_rtLastDeliveredEndTime = *prtEnd; // not necessarily known, but guaranteed >= prtStart
                
                if(hr != S_OK)
                {
                    DbgLog((LOG_TRACE, 1,
                            TEXT("CWMWriter::Receive IWMWriter::WriteSample returned error %08x on pin %d. refusing everything"),
                            hr, pPin->m_numStream));
                    m_fErrorSignaled = TRUE;
                    if(FAILED(hr))
                    {
                        NotifyEvent(EC_ERRORABORT, hr, 0);
                    }
                }
#if 0
#ifdef DEBUG  // !!! experimental debug code to see if we're dropping samples while writing,
                // !!! especially to the net
                else
                {
                    WM_WRITER_STATISTICS stats;

                    HRESULT hrStat = m_pWMWriterAdvanced->GetStatistics(0, &stats);  // stream-specific samples?

                    if (SUCCEEDED(hrStat)) {
                        DbgLog((LOG_TIMING, 2, TEXT("Dropped samples: %d / %d, Sample rate = %d"),
                        (DWORD) stats.qwDroppedSampleCount, (DWORD) stats.qwSampleCount,
                        stats.dwCurrentSampleRate));

                    }
                }
#endif
#endif
            }
            else
            {            
                m_fErrorSignaled = TRUE;
                NotifyEvent(EC_ERRORABORT, hr, 0);
            }
        }
        else
        {
            DbgLog((LOG_TRACE, 1,
                    TEXT("CWMWriter:: Error signaled or output not connected %d"),
                    pPin->m_numStream));
            hr = S_FALSE;
        }
    }
    else
    {
        DbgLog((LOG_TRACE,1, TEXT("CWMWriter: Receive when stopped!")));
        hr = VFW_E_NOT_RUNNING;
    }
    return NOERROR;
}

HRESULT CWMWriter::CopyOurSampleToNSBuffer(
    INSSBuffer     *pNSDest,
    IMediaSample   *pSource)
{

    if( !pNSDest || !pSource )
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // Copy the sample data
    BYTE *pSourceBuffer, *pDestBuffer;
    long lDataLength = pSource->GetActualDataLength();
    DWORD dwDestSize;
    
    HRESULT hr = pNSDest->GetBufferAndLength(&pDestBuffer, &dwDestSize);
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
    {
        // make sure it fits!
        ASSERT(dwDestSize >= (DWORD)lDataLength);
        if( dwDestSize < (DWORD) lDataLength )
        {
            // uh oh... could try and copy as much as would fit, but probably pointless
            DbgLog((LOG_TRACE, 1, "ERROR: CWMWriter::CopyOurSampleToNSBuffer dwDestSize < lDataLength (returning %08lx)", hr));
            hr = E_UNEXPECTED;
        }
        else
        {
            pSource->GetPointer(&pSourceBuffer);

            CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lDataLength );

            // set the data length
            HRESULT hrInt = pNSDest->SetLength( lDataLength );
            ASSERT( SUCCEEDED( hrInt ) ); // shouldn't fail right?
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// IndexFile
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::IndexFile()
{
    DbgLog((LOG_TRACE, 15, "CWMWriter::IndexFile()"));
    CWMWriterIndexerCallback * pCallback = new CWMWriterIndexerCallback(this);
    if( !pCallback )
        return E_OUTOFMEMORY;
        
    pCallback->AddRef();        
    
    IWMIndexer *pWMIndexer;
    
    HRESULT hr = S_OK;
    
    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateIndexer( &pWMIndexer );
        if( FAILED( hr ) )
        {        
            DbgLog((LOG_TRACE, 1, "ERROR: CWMWriter::IndexFile WMCreateIndexer failed (0x%08lx)", hr));
            return hr;
        }        
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::IndexFile - Exception calling WMCreateIndexer probably due to wmvcore.dll not present. Aborting. ")));
        return HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
    
    //
    // create indexing event
    //
    HANDLE hIndexEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( !hIndexEvent )
    {
        DbgLog((LOG_TRACE, 1, TEXT("ERROR - failed to create index event")));
        hr = E_OUTOFMEMORY;
    }
    else
    {        
        DbgLog((LOG_TRACE, 2, TEXT("Starting file indexing")));
        hr = pWMIndexer->StartIndexing(m_wszFileName, pCallback, &hIndexEvent);
        if (SUCCEEDED(hr)) 
        {
            m_hrIndex = S_OK;
            DWORD dw = WaitForSingleObject( hIndexEvent, INFINITE );
            hr = m_hrIndex;
            DbgLog((LOG_TRACE, 2, TEXT("Finished indexing, callback returned 0x%08lx"), hr));
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: CWMWriter::IndexFile StartIndexing failed (0x%08lx)"), hr));
        }        
        CloseHandle( hIndexEvent );     
    }
    
    pWMIndexer->Release();
    if( pCallback )
    {
        pCallback->Release();
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// Stop
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Stop()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Stop(...)")));
    CAutoLock lock(&m_csFilter);


    FILTER_STATE state = m_State;

    HRESULT hr = CBaseFilter::Stop();
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriter::Stop failed.")));
        return hr;
    }

    if(state != State_Stopped ) 
    {
        // close and clean up the file data
        hr = StopStreaming();
        if (FAILED(hr)) {
            return hr;
        }
    }        

    if(m_fErrorSignaled)
        return S_OK;

    return hr;
}

// ------------------------------------------------------------------------
//
// Pause
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Pause()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Pause(...)")));
    CAutoLock l(&m_csFilter);

    if( m_State == State_Stopped )
    {
        m_fErrorSignaled = TRUE;

        // make sure we've been given a filename
        HRESULT hr = CanPause();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = StartStreaming();
        if(FAILED(hr))
        {
            DbgLog(( LOG_TRACE, 2,
                TEXT("CWMWriter::Pause: StartStreaming failed.")));
            return hr;
        }
        
        m_fErrorSignaled = FALSE;
    }

    return CBaseFilter::Pause();
}

// ------------------------------------------------------------------------
//
// CanPause
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::CanPause()
{
    HRESULT hr = S_OK;
    
    // can't run without a filename and a wmsdk writer
    if( !m_pWMWriter || 0 == m_wszFileName )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }
    
    // also, we currently don't support running if all our inputs aren't connected
    ASSERT( m_cConnections == m_lstInputPins.GetCount() );
    if( m_cConnections != m_lstInputPins.GetCount() )
        return E_FAIL;    
    
    if( !m_pWMProfile )
    {
        // need to have a valid profile
        return E_FAIL;
    }
    
    //    
    // delay the SetOutputFilename until we pause from stop, since the wmsdk writer
    // will overwrite the file on this call
    //
    if( m_bResetFilename )
    {    
        hr = m_pWMWriter->SetOutputFilename( m_wszFileName );
        if( SUCCEEDED( hr ) )
        {
            m_bResetFilename = FALSE;
        }        
        else
        {   
            DbgLog(( LOG_TRACE, 2, TEXT("IWMWriter::SetOutputFilename failed [0x%08lx]"), hr ));
            return hr;
        }    
    }        
    
#if DEBUG
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
        ASSERT( pwp->IsConnected() );
    }

#endif

    return S_OK;
}

// ------------------------------------------------------------------------
//
// Run
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::Run(...)")));
    CAutoLock l(&m_csFilter);
    
    // Is there any change needed
    if (m_State == State_Running) {
        return NOERROR;
    }
    
    return CBaseFilter::Run(tStart);
}

// ------------------------------------------------------------------------
//
// EndOfStream
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::EndOfStream()
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter: EOS")));
    CAutoLock lock(&m_csFilter);

    if(!m_fErrorSignaled)
    {
        if(m_State == State_Running)
        {
            NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
        }
        else if(m_State == State_Paused)
        {
            // m_fEosSignaled set, so will be signaled on run
        }
        else
        {
            ASSERT(m_State == State_Stopped);
            // we could have stopped already; ignore EOS
        }
    }
    return S_OK;
}

// ------------------------------------------------------------------------
//
// EndOfStreamFromPin
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::EndOfStreamFromPin(int pinNum)
{
    CAutoLock lock(&m_csFilter);

    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 3, TEXT("CWMWriter::EndOfStreamFromPin EOS pin %d"), pinNum));

    int cEos = 0;
    for ( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {   
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

        // wake up the other streams since this one is done
        //
        pwp->WakeMeUp();

        if( pwp->m_fEOSReceived ) 
        {
            cEos++;
        }            
            
        if( pwp->m_numPin == pinNum && PINTYPE_AUDIO == pwp->m_fdwPinType )
        {
            //
            // decrement number of active audio streams
            //
            ASSERT( m_cActiveAudioStreams > 0 );
            m_cActiveAudioStreams--;
            DbgLog((LOG_TRACE, 3, TEXT("CWMWriter - active audio streams %d"), m_cActiveAudioStreams));
        }            
    }
    
    if(cEos == m_cConnections)
    {
        EndOfStream(); // tell filter to send EC_COMPLETE        
        DbgLog((LOG_TRACE, 3, TEXT("asf: final eos")));
    }

    return hr;
}


// ------------------------------------------------------------------------
// IConfigAsfWriter
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
//
// ConfigureFilterUsingProfile
//
// Set the writer to use the passed in profile
//
// ------------------------------------------------------------------------

STDMETHODIMP CWMWriter::ConfigureFilterUsingProfile( IWMProfile * pWMProfile )
{
    CAutoLock lock(&m_csFilter);

    ASSERT( pWMProfile );
    if( !pWMProfile )
        return E_POINTER;
   
    if( !m_pWMWriter )
        return E_FAIL;
         
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    PinList lstReconnectPins(NAME("List of reconnect pins"));
    
    // if we're currently connected, remember connections before disconnecting
    PrepareForReconnect( lstReconnectPins );
    
    // move all input pins to the recycle list and reset the pin count, so that
    // we effectively hide them from view
    ASSERT( m_cInputs == m_lstInputPins.GetCount() );
    
    // clean up any previous one, profile must be deleted before deleting pins!
    DeleteProfile();
    
    DeletePins( TRUE ); // Recycle deleted pins
    
    ASSERT( 0 == m_cInputs );
    ASSERT( 0 == m_lstInputPins.GetCount() );

    // first configure wmsdk for this profile
    ASSERT( m_pWMWriter );
    
    HRESULT hr = m_pWMWriter->SetProfile( pWMProfile );
    if( SUCCEEDED( hr ) )
    {   
        // save off the guid for this profile in case filter gets persisted
        IWMProfile2* pWMProfile2;
        HRESULT hrInt = pWMProfile->QueryInterface( IID_IWMProfile2, (void **) &pWMProfile2 );
        ASSERT( SUCCEEDED( hrInt ) );
        if( SUCCEEDED( hrInt ) )
        {
            hrInt = pWMProfile2->GetProfileID( &m_guidProfile );
            if( FAILED( hrInt ) )
            {
                m_guidProfile = GUID_NULL;
            }
            else
            {
                // make sure filter profile config is set to config by guid mode
                m_fdwConfigMode = CONFIG_F_BY_GUID;
            }   
                                 
            pWMProfile2->Release();        
        }        
    
        m_pWMProfile = pWMProfile; 
        m_pWMProfile->AddRef(); // keep a hold on it
        
        DWORD cInputs;
        hr = m_pWMWriter->GetInputCount( &cInputs );
        if( SUCCEEDED( hr ) )
        { 
            // check output stream count as well
            // for now if the 2 are equal than assume there's a 1-to-1
            // correspondence between streams and set input types based
            // on the output stream types
            DWORD cStreams;
            hr = pWMProfile->GetStreamCount( &cStreams );
            if( SUCCEEDED( hr ) )
            { 
                if( cStreams == cInputs )
                {
                    // use output streams to configure inputs
                    for( int i = 0; i < (int)cStreams; i++ )
                    {            
                        CComPtr<IWMStreamConfig> pConfig;
                        hr = pWMProfile->GetStream( i, &pConfig );
                        if( SUCCEEDED( hr ) )
                        {
                            CLSID MajorType;
                            hr = pConfig->GetStreamType( &MajorType );
                            if( SUCCEEDED( hr ) )
                            {
                        
                                if( MEDIATYPE_Audio == MajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need an audio pin") ) );
                                    hr = AddNextPin(0, PINTYPE_AUDIO, pConfig);
                                    if(FAILED( hr ) )
                                        break;
                                }                            
                                else if( MEDIATYPE_Video == MajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need a video pin") ) );
                                    hr = AddNextPin(0, PINTYPE_VIDEO, pConfig);
                                    if(FAILED( hr ) )
                                        break;
                                }
                            }                        
                        }
                    }
                }
                else
                {
                    // use input info to configure inputs
                    for( int i = 0; i < (int)cInputs; i++ )
                    {            
                        CComPtr<IWMInputMediaProps> pInputMediaProps;
                        
                        // use the major type of the first media type enumerated for this 
                        // pin's creation (used for naming pin)
                        hr = m_pWMWriter->GetInputFormat( i
                                                        , 0 // we want the 0-th type
                                                        , (IWMInputMediaProps ** )&pInputMediaProps );
                        if( SUCCEEDED( hr ) )
                        {
                            GUID guidMajorType;
                            hr = pInputMediaProps->GetType( &guidMajorType );
                            ASSERT( SUCCEEDED( hr ) );
                            if( SUCCEEDED( hr ) )
                            {
                                if( MEDIATYPE_Audio == guidMajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need an audio pin") ) );
                                    
                                    // use NULL for output stream's config info, since we 
                                    // don't know which output stream this input flows to
                                    hr = AddNextPin(0, PINTYPE_AUDIO, NULL); 
                                    if(FAILED( hr ) )
                                        break;
                                }                            
                                else if( MEDIATYPE_Video == guidMajorType )
                                {
                                    DbgLog( ( LOG_TRACE
                                          , 3
                                          , TEXT("CWMWriter::ConfigureFilterUsingProfile: need a video pin") ) );
                                    
                                    // use NULL for output stream's config info, since we 
                                    // don't know which output stream this input flows to
                                    hr = AddNextPin(0, PINTYPE_VIDEO, NULL);
                                    if(FAILED( hr ) )
                                        break;
                                }
                            }                        
                        }
                        else
                        {
                            // don't continue
                            break;
                        }                            
                    }

                }
            }
        }
    }
    if( SUCCEEDED( hr ) )
    {
        // attempt to restore previous connections
        ReconnectPins( lstReconnectPins );
    }    
    
    // free any remaining reconnect pins
    IPin * pPin;
    while ( pPin = lstReconnectPins.RemoveHead() )
    {
        pPin->Release();
    }

    NotifyEvent( EC_GRAPH_CHANGED, 0, 0 ); 
    return hr;
}

// ------------------------------------------------------------------------
//
// ReconnectPins
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::ReconnectPins( PinList & lstReconnectPins )
{
    HRESULT hr = S_OK;
    for ( POSITION Pos1 = lstReconnectPins.GetHeadPosition(); Pos1 ;  )
    {
        POSITION Pos1Orig = Pos1;
        IPin * pReconnectPin = lstReconnectPins.GetNext( Pos1 );
        
        for (POSITION Pos2 = m_lstInputPins.GetHeadPosition(); Pos2; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos2 );
            
            hr = pReconnectPin->Connect( pwp, NULL );
            if( SUCCEEDED( hr ) )
            {
                // pull it off the reconnect list and release our hold on it
                pReconnectPin->Release();
                lstReconnectPins.Remove( Pos1Orig );
                
                break;
            }                
        }
    }
    // what to return for partial connections?    
    return S_OK;
}    

// ------------------------------------------------------------------------
//
// PreparePinsForReconnect
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::PrepareForReconnect( PinList & lstReconnectPins )
{
    if( m_cConnections )
    {
        ASSERT( 0 == lstReconnectPins.GetCount() );
     
        // at least one pin is connected, so remember connected pins before disconnecting
        for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            IPin * pPeer;
            HRESULT hr = pwp->ConnectedTo( &pPeer );
            if( SUCCEEDED( hr ) )
            {
                // Note that we want to make sure the pin doesn't go away after adding it to the list
                // Since it already has a refcount on it from the ConnectedTo call, we just don't 
                // call Release on the pin
                
                lstReconnectPins.AddTail( pPeer );
                
                pwp->Disconnect();
                pPeer->Disconnect();
                
                // Don't call Release, per comment above!                
                //pPeer->Release(); 
            }
        }
    }
    return S_OK;
}    

// ------------------------------------------------------------------------
//
// ConfigureFilterUsingProfile
//
// Set the writer to use a system profile id
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriter::ConfigureFilterUsingProfileId( DWORD dwProfileId )
{
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    CAutoLock lock(&m_csFilter);

    // if this is a different profile than the current remove all input pins
            
    // now create input pins according to this profile

    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = S_OK;
    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateProfileManager( &pIWMProfileManager );
        
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateProfileManager probably due to wmvcore.dll not present. Aborting. ")));
        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
   
    //
    // for now (DX8 and Millennium) this method assumes legacy 4_0 version profiles
    //        
#ifdef  USE_7_0_PROFILES_IN_CONFIGBYID
    if( SUCCEEDED( hr ) )
    {    
        // this code is provide for internally building the filter to instead have this method use 7_0 profiles
        IWMProfileManager2*	pIPM2 = NULL;
        HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                                            ( void ** )&pIPM2 );
        if( SUCCEEDED( hrInt ) )
        {
            pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
            pIPM2->Release();
        }
#ifdef DEBUG        
        else
        {
            ASSERT( SUCCEEDED( hrInt ) );
        
            // else if IWMProfileManager2 isn't supported I guess we assume that we're 
            // running on Apollo bits and the hack isn't needed?  
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::ConfigureFilterUsingProfileId failed [0x%08lx]"), hrInt ));
        }        
#endif                
    }
#endif      

    if( SUCCEEDED( hr ) )
    {   
        // to validate the id passed in we could re-query for this or cache it the first time
        // re-querying for now
        DWORD cProfiles;
        hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
        if( SUCCEEDED( hr ) )
        {
            if( dwProfileId >= cProfiles )
            {
                DbgLog( ( LOG_TRACE
                      , 3
                      , TEXT("CWMWriter::ConfigureFilterUsingProfileId: ERROR - invalid profile id (%d)")
                      , dwProfileId ) );
                      
                hr = E_FAIL;   
            }
        }
    }
    if( SUCCEEDED( hr ) )
    {                    
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( dwProfileId, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            hr = ConfigureFilterUsingProfile( pIWMProfile );
        }            
    }    

    if( SUCCEEDED( hr ) )
    {    
        m_dwProfileId = dwProfileId;
        m_fdwConfigMode = CONFIG_F_BY_ID;
    }        
    else        
    {    
        m_dwProfileId = PROFILE_ID_NOT_SET;
    }    
    return hr;
}


// ------------------------------------------------------------------------
//
// ConfigureFilterUsingGuid
//
// Set the writer to use a wm profile guid
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::ConfigureFilterUsingProfileGuid( REFGUID guidProfile )
{
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    CAutoLock lock(&m_csFilter);

    // if this is a different profile than the current remove all input pins
            
    // now create input pins according to this profile

    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = S_OK;

    // remember, we delay load wmvcore.dll, so protect against the case where it's not present    
    __try 
    {
        hr = WMCreateProfileManager( &pIWMProfileManager );
    }
    __except (  EXCEPTION_EXECUTE_HANDLER ) 
    {
        DbgLog(( LOG_TRACE, 1,
            TEXT("CWMWriter::CreateWMWriter - Exception calling WMCreateProfileManager probably due to wmvcore.dll not present. Aborting. (0x%08lx)")));
        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    }
    
    if( SUCCEEDED( hr ) )
    {                    
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadProfileByID( guidProfile, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            hr = ConfigureFilterUsingProfile( pIWMProfile );
        }            
#ifdef DEBUG
        else
        {
            DbgLog(( LOG_TRACE, 2,
                     TEXT("CWMWriter::CreateWMWriter - IWMProfileManager::LoadProfileByID failed (0x%08lx)"), 
                     hr));
        }        
#endif        
    }    
    // hmm... what do we do here?? now we've picked a profile directly, so we don't
    // know whether/which profile id it matches.
    
    // then try just not setting it    
    m_dwProfileId = PROFILE_ID_NOT_SET;
    if( SUCCEEDED( hr ) )
    {    
        m_fdwConfigMode = CONFIG_F_BY_GUID;
        m_guidProfile = guidProfile;
        
    }    
    return hr;
}

// ------------------------------------------------------------------------
//
// GetCurrentProfileGuid
//
// Get the current profile guid
//
// ------------------------------------------------------------------------
HRESULT CWMWriter::GetCurrentProfileGuid( GUID *pProfileGuid )
{
    if( NULL == pProfileGuid )
    {
        return E_POINTER;
    }

    *pProfileGuid = m_guidProfile;

    return S_OK;
}    


// ------------------------------------------------------------------------
// IFileSinkFilter

STDMETHODIMP CWMWriter::SetFileName 
(
    LPCOLESTR wszFileName,
    const AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(wszFileName, E_POINTER);
    CAutoLock lock(&m_csFilter);

    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;

    HRESULT hr = S_OK;

    // do we need to release current WMWriter object to change name?
    Close(); // when to open??

    long cLetters = lstrlenW(wszFileName);
    // rely on the wmsdk for this type of validation?
    //if(cLetters > MAX_PATH)
    //    return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

    m_wszFileName = new WCHAR[cLetters + 1];
    if(m_wszFileName == 0)
        return E_OUTOFMEMORY;

    lstrcpyW(m_wszFileName, wszFileName);

    if(pmt)
    {
        ASSERT( FALSE ); // we don't support this
    }

    if( !m_pGraph )
        return S_OK; // can't do much more until we've been added to the graph

    if( !m_pWMWriter )
    {
        // need to create writer and configure output filename
        hr = LoadInternal();
    }
    else
    {        
        // else just configure wmsdk writer for output filename
        hr = Open();
    }        
    if( FAILED( hr ) )
    {   
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::Open file failed [0x%08lx]"), hr ));
        return hr;
    }    

    return S_OK;
}

STDMETHODIMP CWMWriter::SetMode( DWORD dwFlags )
{
    // refuse flags we don't know 
    if(dwFlags & ~AM_FILE_OVERWRITE)
    {
        return E_INVALIDARG;
    }
    
    CAutoLock lock(&m_csFilter);

    HRESULT hr = S_OK;

    if(m_State == State_Stopped)
    {
        m_dwOpenFlags = dwFlags;
    }
    else
    {
        hr = VFW_E_WRONG_STATE;
    }

    return hr;
}

STDMETHODIMP CWMWriter::GetCurFile
(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(ppszFileName, E_POINTER);

    *ppszFileName = NULL;
    if(m_wszFileName!=NULL)
    {
        *ppszFileName = (LPOLESTR)QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_wszFileName)));
        if (*ppszFileName != NULL)
            lstrcpyW(*ppszFileName, m_wszFileName);
        else
            return E_OUTOFMEMORY;
    }

    if(pmt)
    {
        // not really supported, but fill in something I guess
        pmt->majortype = GUID_NULL;
        pmt->subtype = GUID_NULL;
    }

    return S_OK;
}

STDMETHODIMP CWMWriter::GetMode( DWORD *pdwFlags )
{
    CheckPointer(pdwFlags, E_POINTER);
    *pdwFlags = m_dwOpenFlags;
    return S_OK;
}



//-----------------------------------------------------------------------------
//                  ISpecifyPropertyPages implementation
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// GetPages
//
// Returns the clsid's of the property pages we support
//
//-----------------------------------------------------------------------------
STDMETHODIMP CWMWriter::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_WMAsfWriterProperties;

    return NOERROR;

} // GetPages

//-----------------------------------------------------------------------------
//
// CPersistStream
//
//-----------------------------------------------------------------------------
STDMETHODIMP CWMWriter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

HRESULT CWMWriter::WriteToStream(IStream *pStream)
{
    FilterPersistData fpd;
    fpd.dwcb = sizeof(fpd);
    HRESULT hr = S_OK;
    
    fpd.guidProfile   = m_guidProfile;
    fpd.fdwConfigMode = m_fdwConfigMode;
        
    if( PROFILE_ID_NOT_SET == m_dwProfileId )
    {
        fpd.dwProfileId = 0;
    }
    else
    {
        fpd.dwProfileId = m_dwProfileId;
    }    
        
    hr = pStream->Write(&fpd, sizeof(fpd), 0);

    return hr;
}

HRESULT CWMWriter::ReadFromStream(IStream *pStream)
{
    FilterPersistData fpd;
    HRESULT hr = S_OK;

    hr = pStream->Read(&fpd, sizeof(fpd), 0);
    if(FAILED(hr))
        return hr;

    if(fpd.dwcb != sizeof(fpd))
        return VFW_E_INVALID_FILE_VERSION;

    if( CONFIG_F_BY_GUID == fpd.fdwConfigMode )
        hr = ConfigureFilterUsingProfileGuid( fpd.guidProfile );
    else
        hr = ConfigureFilterUsingProfileId( fpd.dwProfileId );
    
    return hr;
}

int CWMWriter::SizeMax()
{
    return sizeof(FilterPersistData);
}

//-----------------------------------------------------------------------------
// IMediaSeeking
//-----------------------------------------------------------------------------

HRESULT CWMWriter::IsFormatSupported(const GUID * pFormat)
{
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CWMWriter::QueryPreferredFormat(GUID *pFormat)
{
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CWMWriter::SetTimeFormat(const GUID * pFormat)
{
    HRESULT hr = S_OK;
    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
        m_TimeFormat = FORMAT_TIME;
    
    return hr;
}

HRESULT CWMWriter::IsUsingTimeFormat(const GUID * pFormat)
{
    HRESULT hr = S_OK;
    if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME) {
        ;
    } else {
        hr = S_FALSE;
    }
    
    return hr;
}

HRESULT CWMWriter::GetTimeFormat(GUID *pFormat)
{
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    
    return S_OK;
}

HRESULT CWMWriter::GetDuration(LONGLONG *pDuration)
{
    HRESULT hr = S_OK;
    CAutoLock lock(&m_csFilter);
    
    if(m_TimeFormat == FORMAT_TIME)
    {
        *pDuration = 0;
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if(pwp->IsConnected())
            {
                IPin *pPinUpstream;
                if(pwp->ConnectedTo(&pPinUpstream) == S_OK)
                {
                    IMediaSeeking *pIms;
                    hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
                    if(SUCCEEDED(hr))
                    {
                        LONGLONG dur = 0;
                        hr = pIms->GetDuration(&dur);
                        
                        if(SUCCEEDED(hr))
                            *pDuration = max(dur, *pDuration);
                        
                        pIms->Release();
                    }
                    
                    pPinUpstream->Release();
                }
            }            
            if(FAILED(hr))
                break;
        }
    } 
    else 
    {
        *pDuration = 0;
        return E_UNEXPECTED;
    }
            
    return hr;
}


HRESULT CWMWriter::GetStopPosition(LONGLONG *pStop)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    
    REFERENCE_TIME rtLastTime = 0;    
    if( FORMAT_TIME == m_TimeFormat )
    {    
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if( pwp->m_rtLastTimeStamp > rtLastTime )
            {
                rtLastTime = pwp->m_rtLastTimeStamp;
            }
        }
        *pCurrent = rtLastTime;
    }        
    
    return S_OK;
}

HRESULT CWMWriter::GetCapabilities( DWORD * pCapabilities )
{
    CAutoLock lock(&m_csFilter);
    *pCapabilities = 0;
    
    // for the time format, we can get a duration by asking the upstream
    // filters
    if(m_TimeFormat == FORMAT_TIME)
    {
        *pCapabilities |= AM_SEEKING_CanGetDuration;
        for( POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
        {   
            CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );
            if(pwp->IsConnected())
            {
                IPin *pPinUpstream;
                if(pwp->ConnectedTo(&pPinUpstream) == S_OK)
                {
                    IMediaSeeking *pIms;
                    HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
                    if(SUCCEEDED(hr))
                    {
                        hr = pIms->CheckCapabilities(pCapabilities);
                        pIms->Release();
                    }
                    
                    pPinUpstream->Release();
                }
            }            
        }
    }
    
    // we always know the current position
    *pCapabilities |= AM_SEEKING_CanGetCurrentPos ;
    
    return S_OK;
}

HRESULT CWMWriter::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCapabilities &= dwMask;
    
    return S_OK;
}


HRESULT CWMWriter::ConvertTimeFormat(
                                     LONGLONG * pTarget, const GUID * pTargetFormat,
                                     LONGLONG    Source, const GUID * pSourceFormat )
{
    return E_NOTIMPL;
}


HRESULT CWMWriter::SetPositions(
                                LONGLONG * pCurrent,  DWORD CurrentFlags,
                                LONGLONG * pStop,  DWORD StopFlags )
{
    // not yet implemented. this might be how we append to a file. and
    // how we write less than an entire file.
    return E_NOTIMPL;
}


HRESULT CWMWriter::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hr;
    //if( pCurrent )
    //    *pCurrent = m_LastVidTime;
    
    hr = GetDuration( pStop);
    
    return hr;
}

HRESULT CWMWriter::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::SetRate( double dRate)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetRate( double * pdRate)
{
    return E_NOTIMPL;
}

HRESULT CWMWriter::GetPreroll(LONGLONG *pPreroll)
{
    return E_NOTIMPL;
}



// IWMHeaderInfo forwarded to WMSDK 
STDMETHODIMP CWMWriter::GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeCount(wStreamNum, pcAttributes);
}


STDMETHODIMP CWMWriter::GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByIndex(wIndex, pwStreamNum, pwszName,
                                        pcchNameLen, pType, pValue, pcbLength);
}


STDMETHODIMP CWMWriter::GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetAttributeByName(pwStreamNum, pszName, pType,
                                       pValue, pcbLength);
}


STDMETHODIMP CWMWriter::SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->SetAttribute(wStreamNum, pszName, Type, pValue, cbLength);
}


STDMETHODIMP CWMWriter::GetMarkerCount( WORD *pcMarkers )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarkerCount(pcMarkers);
}


STDMETHODIMP CWMWriter::GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetMarker(wIndex, pwszMarkerName, pcchMarkerNameLen, pcnsMarkerTime);
}


STDMETHODIMP CWMWriter::AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddMarker(pwszMarkerName, cnsMarkerTime);
}

STDMETHODIMP CWMWriter::RemoveMarker( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveMarker(wIndex);
}

STDMETHODIMP CWMWriter::GetScriptCount( WORD *pcScripts )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScriptCount(pcScripts);
}

STDMETHODIMP CWMWriter::GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->GetScript(wIndex, pwszType, pcchTypeLen, pwszCommand,
                              pcchCommandLen, pcnsScriptTime);
}

STDMETHODIMP CWMWriter::AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->AddScript(pwszType, pwszCommand, cnsScriptTime);
}

STDMETHODIMP CWMWriter::RemoveScript( WORD wIndex )
{
    if (!m_pWMHI)
        return E_FAIL;

    return m_pWMHI->RemoveScript(wIndex);
}

// if the current time of the pin is 1/2 second greater than any other pin
// then wake the slower pin up. This happens for all slower pins, not just
// one. This algorithm is self-regulating. If you have more than 2 pins,
// the faster one will always slow down for any of the slower pins. Then,
// slower pins catch up and the fastest of THOSE pins will then stall out.
// This will keep things approximately interleaved within a second...
//
BOOL CWMWriter::HaveIDeliveredTooMuch( CWMWriterInputPin * pPin, REFERENCE_TIME Start )
{
    // !!! this routine isn't threadsafe on the pin's m_rtLastTimeStamp, does it
    // matter? I can't tell. I think it's all okay.

    DbgLog((LOG_TRACE, 3, TEXT("Pin %ld, Have I delivered too much?"), pPin->m_numPin ));

#ifdef DEBUG
    REFERENCE_TIME MaxLag = 0;
#endif

    BOOL bSleep = FALSE;
    
    for (POSITION Pos = m_lstInputPins.GetHeadPosition(); Pos; )
    {
        CWMWriterInputPin * const pwp = m_lstInputPins.GetNext( Pos );

        // if this pin has received an EOS, then don't look at it
        //
        if( pwp->m_fEOSReceived )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %ld is at EOS"), pwp->m_numPin ));
            continue;
        }

        // if we're ourself, then don't look at us
        //
        if( pPin == pwp )
        {
            continue;
        }

#ifdef DEBUG
        if( Start - pwp->m_rtLastTimeStamp > MaxLag )
        {
            MaxLag = Start - pwp->m_rtLastTimeStamp;
        }
#endif
        //
        // IF we've caught up to this pin (within our blocking range) AND if no other
        // pins need it to stay blocked (i.e. its m_rtLastTimeStamp is less than
        // BLOCKINGSIZE + every other pin's time stamp)
        // THEN wake this pin up
        //
        BOOL bWakeUpPin = FALSE;
        
        //
        // Unblock other pin whenever we're just within blocking range
        //
        // Remember the wmsdk depends on audio for clocking and this design requires 
        // that the audio also be somewhat ahead of video, so we can't leave an audio 
        // pin blocked until the video catches up, because they'll cause us to deadlock.
        //
        if( Start >= pwp->m_rtLastDeliveredEndTime - WAKEUP_RANGE )
        {
            bWakeUpPin = TRUE;
            
            //
            // we've caught up to this pin (within our block range)
            // now make sure it doesn't need to stay blocked for another pin
            //
            for ( POSITION Pos2 = m_lstInputPins.GetHeadPosition(); Pos2; )
            {
                CWMWriterInputPin * const pwp2 = m_lstInputPins.GetNext( Pos2 );
                if( pwp2->m_fEOSReceived )
                {
                    continue;
                }
                //
                // skip ourself and the pin we'd like to wake up
                //
                if( pwp2 == pPin || pwp2 == pwp )
                {
                    continue;
                }
            
                DbgLog( ( LOG_TRACE
                      , 15
                      , TEXT("Checking with other pins whether its ok to wake up pin %ld. Is it ok with you pin %ld?")
                      , pwp->m_numPin
                      , pwp2->m_numPin ) );
                
                if( pwp->m_rtLastTimeStamp > BLOCKINGSIZE + pwp2->m_rtLastDeliveredStartTime )
                {
                    //
                    // this pin is too far ahead of some other pin, so don't wake it up
                    // no need to continue this loop
                    //
                    bWakeUpPin = FALSE;
                    DbgLog( ( LOG_TRACE
                          , 15
                          , TEXT("No, waking pin %ld up isn't ok with pin %ld.")
                          , pwp->m_numPin
                          , pwp2->m_numPin ) );
                    break;
                }
            }
        }            
        
        if( bWakeUpPin )
        {
            //
            // we've caught up to this pin and so have all other pins 
            // so wake it up in case it was sleeping
            //
            pwp->WakeMeUp();
        }
        
        //        
        // now see if we're too far ahead of this pin and we need to rest to let others catch up
        //
        if( Start > pwp->m_rtLastDeliveredEndTime + BLOCKINGSIZE )
        {
            DbgLog((LOG_TRACE, 3, TEXT("Pin %ld is lagging by %ldms, YES"), pwp->m_numPin, long( ( Start - pwp->m_rtLastTimeStamp ) / 10000 ) ));

            // yep, we're over
            //
            bSleep = TRUE;
        }
    }

#ifdef DEBUG
    if( !bSleep )
    {    
        DbgLog((LOG_TRACE, 3, TEXT("No, I haven't, max lag = %ld"), long( MaxLag / 10000 ) ));
    }        
#endif

    return bSleep;
}

//
// IServiceProvider
//
STDMETHODIMP CWMWriter::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (NULL == ppv) 
    {
        return E_POINTER;
    }
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;
    
    if (IID_IWMWriterAdvanced2 == guidService) 
    {
        if( m_pWMWriter )
        {
            //
            // For this interface we pass out the writer's interface directly. 
            //
            // In general, we'd like most calls to pass through our filter, to keep the user from 
            // overriding our control on the writer. However, for the 2 methods on the IWMWriterAdvanced2 
            // interface its less of an issue. 
            // However the user could still get at the writer's IWMWriterAdvanced interface pointer from this 
            // interface, so this exposes that risk.
            //
            hr = m_pWMWriter->QueryInterface( riid, (void **) ppv );
        }
        else
        {
            hr = E_FAIL;
        }            
    }
    return hr;
}


//
// CWMWriterIndexerCallback
//
HRESULT CWMWriterIndexerCallback::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IWMStatusCallback) 
    {
	    return GetInterface(static_cast<IWMStatusCallback *>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid,ppv);
}


STDMETHODIMP CWMWriterIndexerCallback::OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext )
{
    switch (Status) {
        case WMT_INDEX_PROGRESS:
            ASSERT(dwType == WMT_TYPE_DWORD);
            DbgLog((LOG_TRACE, 15, TEXT("Indexing: OnStatus(WMT_INDEX_PROGRESS - %d%% done)"), *(DWORD *) pValue));
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, *(DWORD *)pValue );
            break;

        case WMT_OPENED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_OPENED)")));
            break;

        case WMT_STARTED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_STARTED)")));
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, 0 );
            break;

        case WMT_STOPPED:
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_STOPPED)")));
            // don't set event until we get closed?
            break;

        case WMT_CLOSED:
            // how to handle? should we wait for this after the stop??
            ASSERT( pvContext );
            DbgLog((LOG_TRACE, 3, TEXT("Indexing: OnStatus(WMT_CLOSED) (*pvContext = 0x%08lx)"), *(HANDLE *)pvContext));
            m_pFilter->m_hrIndex = hr;
            SetEvent( *(HANDLE *)pvContext );
            m_pFilter->NotifyEvent( EC_WMT_INDEX_EVENT, Status, 0 );
            break;

        case WMT_ERROR:
            DbgLog((LOG_TRACE, 1, TEXT("ERROR Indexing: OnStatus(WMT_ERROR) - 0x%lx"), hr));
            m_pFilter->m_hrIndex = hr; // pointless really
            // still need to wait for a WMT_CLOSED message, 
            // which means we'll lose the failure as well
            break;
            
        default:
            DbgLog((LOG_TRACE, 1, TEXT("Indexing: OnStatus() Unknown callback! (Status = %ld)"), (DWORD)Status));
            break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\inpin.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <wmsdk.h>
#include "asfwrite.h"

#ifdef RECONNECT_FOR_POS_YUV
#include <ks.h>
#include <ksproxy.h>
#endif

BOOL IsCompressed( DWORD biCompression );
BOOL IsAmTypeEqualWmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE * pwmt);
BOOL IsPackedYUVType( BOOL bNegBiHeight, AM_MEDIA_TYPE * pmt );

#ifdef OFFER_INPUT_TYPES
void CopyWmTypeToAmType( AM_MEDIA_TYPE * pmt,  WM_MEDIA_TYPE * pwmt);
#endif

#ifdef DEBUG
void LogMediaType( AM_MEDIA_TYPE * pmt );
#endif

// ------------------------------------------------------------------------
// 
// CWMWriterInputPin class constructor
//
// ------------------------------------------------------------------------
CWMWriterInputPin::CWMWriterInputPin(
                            CWMWriter *pWMWriter,
                            HRESULT * phr,
                            LPCWSTR pName,
                            int numPin,
                            DWORD dwPinType,
                            IWMStreamConfig * pWMStreamConfig)
    : CBaseInputPin(NAME("AsfWriter Input"), pWMWriter, &pWMWriter->m_csFilter, phr, pName)
    , m_pFilter(pWMWriter)
    , m_numPin( numPin )
    , m_numStream( numPin+1 ) // output stream nums are 1-based, for now assume
                              // a 1-to-1 relationship between input pins and asf streams
    , m_bConnected( FALSE )
    , m_fEOSReceived( FALSE )
    , m_pWMInputMediaProps( NULL )
    , m_fdwPinType( dwPinType )
    , m_pWMStreamConfig( pWMStreamConfig ) // not add ref'd currently
    , m_lpInputMediaPropsArray( NULL )
    , m_cInputMediaTypes( 0 )
    , m_bCompressedMode( FALSE )
    , m_rtFirstSampleOffset( 0 )
    , m_cSample( 0 )
    , m_rtLastTimeStamp( 0 )
    , m_rtLastDeliveredStartTime( 0 )
    , m_rtLastDeliveredEndTime( 0 )
    , m_bNeverSleep( FALSE )
{
    DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::CWMWriterInputPin")));

    // create the sync object for interleaving
    //
    m_hWakeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( !m_hWakeEvent )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    *phr = BuildInputTypeList(); // build input media type list based on current profile
}

// ------------------------------------------------------------------------
//
// Update - initialize a recycled pin
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::Update
(   
    LPCWSTR pName, 
    int numPin, 
    DWORD dwPinType, 
    IWMStreamConfig * pWMStreamConfig 
)
{
    HRESULT hr = S_OK;
    m_numPin = numPin;
    m_numStream = numPin + 1;
    m_fdwPinType = dwPinType;
    m_pWMStreamConfig = pWMStreamConfig; // no ref count currently
    m_bCompressedMode = FALSE;
    
    // need to update the name
    if (pName) {
        delete[] m_pName;    
        
        DWORD nameLen = lstrlenW(pName)+1;
        m_pName = new WCHAR[nameLen];
        if (m_pName) {
            CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
        }
    }
    hr = BuildInputTypeList(); // build list of input types we'll offer
    return hr;
}

// ------------------------------------------------------------------------
//
// destructor
//
// ------------------------------------------------------------------------
CWMWriterInputPin::~CWMWriterInputPin()
{
    DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::~CWMWriterInputPin")));
    if( m_lpInputMediaPropsArray )
    {    
        for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
        {
            // release our type list
            m_lpInputMediaPropsArray[i]->Release();
            m_lpInputMediaPropsArray[i] = NULL;
        }
        QzTaskMemFree( m_lpInputMediaPropsArray );
    }    
    m_cInputMediaTypes = 0;

    if( m_hWakeEvent ) 
    {
        CloseHandle( m_hWakeEvent );
        m_hWakeEvent = NULL;
    }
}


// ------------------------------------------------------------------------
//
// NonDelegatingQueryInterface
//
// ------------------------------------------------------------------------
STDMETHODIMP CWMWriterInputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IAMStreamConfig) {
        // supported for compressed input mode
        return GetInterface((IAMStreamConfig *)this, ppv);
    } else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
//
// BuildInputTypeList
// 
// Build a list of media types using wmsdk enumeration of input streams. First 
// element of list will be the same as the output type for this pin, to allow
// for supporting compressed stream writing.
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::BuildInputTypeList()
{
    if( m_lpInputMediaPropsArray )
    {    
        // release any previous type list
        for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
        {
            // release our type list
            m_lpInputMediaPropsArray[i]->Release();
            m_lpInputMediaPropsArray[i] = NULL;
        }
        
        // release any previous prop array
        QzTaskMemFree( m_lpInputMediaPropsArray );
    }
    
    // now rebuild list
    m_cInputMediaTypes = 0; 

    // first ask wmsdk for count of supported input types
    DWORD cTypesNotIncCompressed;
    HRESULT hr = m_pFilter->m_pWMWriter->GetInputFormatCount( m_numPin, &cTypesNotIncCompressed );
    if(SUCCEEDED( hr ) )
    {
        ASSERT( cTypesNotIncCompressed > 0 );
        
        DWORD cTotalTypes = cTypesNotIncCompressed;
        BOOL bIncludeCompressedType = FALSE;        
        if( m_pWMStreamConfig )
        {        
            // its not a mrb profile so now add one for the compressed input which matches 
            // this pin's output
            bIncludeCompressedType = TRUE;
            cTotalTypes++; // add one for compressed input
        }
        
        DbgLog((LOG_TRACE,4,TEXT("CWMWriterInputPin::BuildInputTypeList input types for pin %d (supports %d types, not including compressed type)"),
                m_numPin,
                cTypesNotIncCompressed ) );
                
        m_lpInputMediaPropsArray = (IWMMediaProps ** ) QzTaskMemAlloc(cTotalTypes * sizeof(IWMMediaProps *) );
        if( !m_lpInputMediaPropsArray )
            return E_OUTOFMEMORY;
            
        if( bIncludeCompressedType )
        {        
            // now put the output type into position 0
            hr = m_pWMStreamConfig->QueryInterface( IID_IWMMediaProps, (void **) &m_lpInputMediaPropsArray[0] );
            ASSERT( SUCCEEDED( hr ) );
            if( SUCCEEDED( hr ) )
            {
                m_cInputMediaTypes++;
            }
            else
            {
                DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList QI for IWMWMediaProps failed for pin %d (hr = 0x%08lx"),
                        m_numPin,
                        hr ) );
            }            
        }
                    
        for( int i = 0; i < (int) cTypesNotIncCompressed; ++i )
        {
            hr = m_pFilter->m_pWMWriter->GetInputFormat( m_numPin
                                                       , i
                                                       , (IWMInputMediaProps ** )&m_lpInputMediaPropsArray[m_cInputMediaTypes] );
            ASSERT( SUCCEEDED( hr ) );
            if( FAILED( hr ) )
            {
                DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList GetInputFormat failed for pin %d, index %d (hr = 0x%08lx"),
                        m_numPin,
                        i,                        
                        hr ) );
                break;
            }
            else
            {
#ifdef DEBUG            
                //
                //  dbglog enumerated input types
                //
                DWORD cbType = 0;
                HRESULT hr2 =  m_lpInputMediaPropsArray[m_cInputMediaTypes]->GetMediaType( NULL, &cbType );
                if( SUCCEEDED( hr2 ) || ASF_E_BUFFERTOOSMALL == hr2 )
                {        
                    WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbType];
                    if( pwmt )
                    {                    
                        hr2 =  m_lpInputMediaPropsArray[m_cInputMediaTypes]->GetMediaType( pwmt, &cbType );
                        if( SUCCEEDED( hr2 ) )
                        {
                            DbgLog((LOG_TRACE, 8
                                  , TEXT("WMWriter::BuildInputTypeList WMSDK media type #%i (stream %d)") 
                                  , i, m_numPin ) );
                            LogMediaType( ( AM_MEDIA_TYPE * )pwmt );                                 
                    
                        }                                                       
                    }
                    delete pwmt;              
                }  
#endif            
                m_cInputMediaTypes++; // only increment after we've debug logged
            }
        }
    }
    else
    {
        DbgLog((LOG_TRACE,3,TEXT("CWMWriterInputPin::BuildInputTypeList GetInputFormatCount failed for pin %d (hr = 0x%08lx"),
                m_numPin,
                hr ) );
    }    
    
    return hr;    
}

// ------------------------------------------------------------------------
//
// SetMediaType
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::SetMediaType(const CMediaType *pmt)
{
    // Set the base class media type (should always succeed)
    HRESULT hr = CBasePin::SetMediaType(pmt);
    if( SUCCEEDED( hr ) )
    {       
        hr = m_pFilter->m_pWMWriter->GetInputProps( m_numPin
                                                  , &m_pWMInputMediaProps );
        ASSERT( SUCCEEDED( hr ) );
        if( FAILED( hr ) )
        {            
            DbgLog((LOG_TRACE
                   , 1
                   , TEXT("WMWriter::SetMediaType GetInputProps failed for input %d [hr = 0x%08lx]") 
                   , m_numPin
                   , hr));
            return hr;                   
        }
        
        if( IsPackedYUVType( TRUE, &m_mt ) ) // look for negative biHeight
        {   
            // wmsdk codecs can't handle SetInputProps with negative height (wmsdk bug 6656)
            CMediaType cmt( m_mt );
            HEADER(cmt.Format())->biHeight = -HEADER(m_mt.pbFormat)->biHeight;
        
            // now set the input type to the wmsdk writer
            hr = m_pWMInputMediaProps->SetMediaType( (WM_MEDIA_TYPE *) &cmt );
        }
        else
        {        
            // now set the input type to the wmsdk writer
            hr = m_pWMInputMediaProps->SetMediaType( (WM_MEDIA_TYPE *) pmt );
        }
        ASSERT( SUCCEEDED( hr ) );
        if( FAILED( hr ) )
        {            
            DbgLog((LOG_TRACE
                  , 1
                  , TEXT("CWMWriterInputPin::SetMediaType SetMediaType failed for input %d [hr = 0x%08lx]") 
                  , m_numPin
                  , hr));
            return hr;                  
        }
        if( !m_bCompressedMode )
        {
            hr = m_pFilter->m_pWMWriter->SetInputProps( m_numPin
                                                      , m_pWMInputMediaProps );
                                                                      
            ASSERT( SUCCEEDED( hr ) );
            if( FAILED( hr ) )
            {            
                DbgLog((LOG_TRACE
                      , 1
                      , TEXT("CWMWriterInputPin::SetMediaType SetInputProps failed for input %d [hr = 0x%08lx]")
                      , m_numPin
                      , hr));
            }
        }
    }
    return hr;
}

//
//  Disconnect 
//
STDMETHODIMP CWMWriterInputPin::Disconnect()
{
    HRESULT hr = CBaseInputPin::Disconnect();
    
    return hr;
}


HRESULT CWMWriterInputPin::CompleteConnect(IPin *pReceivePin)
{
    DbgLog(( LOG_TRACE, 2,
             TEXT("CWMWriterInputPin::CompleteConnect") ));
             
#ifdef RECONNECT_FOR_POS_YUV
    //
    // #ifdef'ing out to just get out of the YUV +biHeight reconnect business for now 
    //
    //
    // if we're using a packed YUV type which doesn't have a negative biHeight then make a last attempt
    // to reset the current type to use a negative height, to avoid mpeg4 encoder and possible decoder
    // problems with the vertical orientation. Currently mpeg4 and Duck decoders have this bug.
    //
    if( IsPackedYUVType( FALSE, &m_mt ) ) // look for positive biHeight
    { 
        BOOL bIsUpstreamFilterKs = FALSE;
        if( pReceivePin )
        {
            //
            // HACK!
            // oops, this workaround breaks kswdmcap filters like
            // the bt829 video capture filter because it has a bug which
            // causes it to succeed QueryAccept but fail the reconnection 
            // so, don't reconnect to a KsProxy pin!
            //
            IKsObject * pKsObject = NULL;
            HRESULT hrKsQI = pReceivePin->QueryInterface( _uuidof( IKsObject ), ( void ** ) &pKsObject );
            if( SUCCEEDED( hrKsQI ) )
            {
                bIsUpstreamFilterKs = TRUE;
                pKsObject->Release();
            }                            
        }
        
        if( !bIsUpstreamFilterKs )
        {        
            CMediaType cmt( m_mt );
            HEADER(cmt.Format())->biHeight = -HEADER(m_mt.pbFormat)->biHeight;
        
            HRESULT hrInt = QueryAccept( &cmt );
            if( SUCCEEDED( hrInt ) )
            {        
                hrInt = m_pFilter->ReconnectPin(this, &cmt);
                ASSERT( SUCCEEDED( hrInt ) );
            }            
        }            
    }
#endif       
                                 
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
    {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriterInputPin::CompleteConnect CompleteConnect")));
        return hr;
    }

    if(!m_bConnected)
    {
        m_pFilter->CompleteConnect(m_numPin);
    }
    m_bConnected = TRUE;

    DumpGraph( m_pFilter->m_pGraph, 1 );

    return hr;
}

HRESULT CWMWriterInputPin::BreakConnect()
{
    if(m_bConnected)
    {
        m_pFilter->BreakConnect( m_numPin );
        ASSERT(m_pFilter->m_cConnections < m_pFilter->m_cInputs);
    }
    m_bConnected = FALSE;

    return CBaseInputPin::BreakConnect();
}

// 
// GetMediaType
// 
// Override to offer any custom types
//
HRESULT CWMWriterInputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
#ifndef OFFER_INPUT_TYPES // the default now is to NOT define OFFER_INPUT_TYPES
    
    HRESULT hr = VFW_S_NO_MORE_ITEMS;
    if( 0 == iPosition )
    {
        //
        // try to give at least a hint of what kind of pin we are by offering
        // 1 partial type
        //
        if( !pmt )
        {
            hr = E_POINTER;
        }                    
        else if(PINTYPE_AUDIO == m_fdwPinType) 
        {        
            pmt->SetType(&MEDIATYPE_Audio);
            hr = S_OK;
        }            
        else if(PINTYPE_VIDEO == m_fdwPinType) 
        {
            pmt->SetType(&MEDIATYPE_Video);
            hr = S_OK;
        }        
    }    
    return hr;
#else
    // 
    // NOTE:
    // This path is currently turned off, mostly due to problems found in the mp3 audio decoder,
    // where its output pin would accept types offered by our input pin, but then not do the 
    // format rate conversion correctly.
    //
    if( iPosition < 0 || iPosition >= (int) m_cInputMediaTypes )
        return VFW_S_NO_MORE_ITEMS;
        
    if( !pmt )
        return E_POINTER;        

    DWORD cbSize = 0;
    HRESULT hr =  m_lpInputMediaPropsArray[iPosition]->GetMediaType( NULL, &cbSize );

    WM_MEDIA_TYPE * pwmt = (WM_MEDIA_TYPE *) new BYTE[cbSize];

    if( !pwmt )
        return E_OUTOFMEMORY;

    if( SUCCEEDED( hr ) || ASF_E_BUFFERTOOSMALL == hr )
    {
        hr =  m_lpInputMediaPropsArray[iPosition]->GetMediaType( pwmt, &cbSize );
        if( SUCCEEDED( hr ) )
        {
            CopyWmTypeToAmType( pmt, pwmt );
        }
    }
    delete pwmt;
    return hr;         
#endif    
}

// ------------------------------------------------------------------------
//
// CheckMediaType
//
// check whether we can support a given input media type using our 
// type list
//
// ------------------------------------------------------------------------
HRESULT CWMWriterInputPin::CheckMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE, 3, TEXT("CWMWriterWriteInputPin::CheckMediaType")));

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    HRESULT hr2 = S_OK; // for internal errors
    
    m_bCompressedMode = FALSE;
    
    for( int i = 0; i < (int) m_cInputMediaTypes; ++i )
    {
        DWORD cbType = 0;
        hr2 =  m_lpInputMediaPropsArray[i]->GetMediaType( NULL, &cbType );
        if( SUCCEEDED( hr2 ) || ASF_E_BUFFERTOOSMALL == hr2 )
        {        
            WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbType];
            if( !pwmt )
                return E_OUTOFMEMORY;
                
            hr2 =  m_lpInputMediaPropsArray[i]->GetMediaType( pwmt, &cbType );
            if(SUCCEEDED( hr2 ) && ( pmt->majortype == pwmt->majortype ) )
            {
                if( IsAmTypeEqualWmType( (AM_MEDIA_TYPE *)pmt, pwmt ) )
                {
                    if( 0 == i )
                    {
                        //
                        // i = 0 which is the type that matches the output type to allow in compressed inputs
                        // require an exact match, right?
                        // accept only if it's a compressed input
                        // if so, we use advanced writer interface to write sample directly, 
                        //
                        // !! For compressed inputs make sure format matches profile format exactly
                        // 
                        if( pmt->majortype == MEDIATYPE_Video &&
                            pwmt->pbFormat && pwmt->cbFormat && // wmsdk workaround for DuplicateMediaType bug with dmo
                            IsCompressed (HEADER(pwmt->pbFormat)->biCompression) &&
		                    ( HEADER(pmt->pbFormat)->biWidth     == HEADER( pwmt->pbFormat)->biWidth ) &&
		                    ( HEADER(pmt->pbFormat)->biHeight    == HEADER( pwmt->pbFormat)->biHeight ) &&
		                    ( HEADER(pmt->pbFormat)->biSize      == HEADER( pwmt->pbFormat)->biSize ) &&
		                    ( HEADER(pmt->pbFormat)->biBitCount  == HEADER( pwmt->pbFormat)->biBitCount ) )
                        {
                            hr = S_OK;
                            m_bCompressedMode = TRUE;
                            break;
                        }   
                        else if( pmt->majortype == MEDIATYPE_Audio &&
                            pwmt->pbFormat &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->wFormatTag      !=  WAVE_FORMAT_PCM ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nChannels       ==  ((WAVEFORMATEX *)pmt->pbFormat)->nChannels ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nSamplesPerSec  ==  ((WAVEFORMATEX *)pmt->pbFormat)->nSamplesPerSec ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nAvgBytesPerSec ==  ((WAVEFORMATEX *)pmt->pbFormat)->nAvgBytesPerSec ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->nBlockAlign     ==  ((WAVEFORMATEX *)pmt->pbFormat)->nBlockAlign ) &&
                            (((WAVEFORMATEX *)pwmt->pbFormat)->wBitsPerSample  ==  ((WAVEFORMATEX *)pmt->pbFormat)->wBitsPerSample ) )
                        {
                            hr = S_OK;
                            m_bCompressedMode = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        hr = S_OK;
                        break;
                    }                                                       
                }
            }  
            delete pwmt;              
        }            
    }
    return SUCCEEDED( hr2 ) ? hr : hr2;
}

//
// IAMStreamConfig 
//
// GetFormat() is the only method we support on this interface.
// 
// It's used to query the asf writer's input pin for it's destination 
// compression format, which is defined in the current profile.
// If an upstream pin wants to avoid wmsdk recompression for this stream
// then it should query us for this format and use that format when connecting
// to this pin.
//
HRESULT CWMWriterInputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("CWrapperOutputPin - IAMStreamConfig::GetFormat")));

    if( !ppmt )
        return E_POINTER;        

    if( !m_lpInputMediaPropsArray )
        return E_FAIL;

    // make sure we don't get reconfigured to a new profile in the middle of this
    CAutoLock lock(&m_pFilter->m_csFilter);
    
    // allocate the buffer, the output format is stored in position 0
    DWORD cbSize = 0;
    HRESULT hr =  m_lpInputMediaPropsArray[0]->GetMediaType( NULL, &cbSize );
    if( SUCCEEDED( hr ) || ASF_E_BUFFERTOOSMALL == hr )
    {
        WM_MEDIA_TYPE *pwmt = (WM_MEDIA_TYPE * ) new BYTE[cbSize];
        if( pwmt )
        {
            hr = m_lpInputMediaPropsArray[0]->GetMediaType( pwmt, &cbSize );
            if( S_OK == hr )
            {
                // now we must copy this to a dshow-type media type, so that our FreeMediaType
                // function won't crash when it tries to free the format block first!

                // allocate a new copy of the wm media type
                *ppmt = CreateMediaType( (AM_MEDIA_TYPE *) pwmt );
                if( !*ppmt )
                {
                    delete pwmt;
                    return E_OUTOFMEMORY;
                }
            }
            delete pwmt;
        }
    }
    return hr;         
}



// handle dynamic format changes
HRESULT CWMWriterInputPin::QueryAccept( const AM_MEDIA_TYPE *pmt )
{
    HRESULT hr = S_FALSE;
    {
        CAutoLock lock(&m_pFilter->m_csFilter);
        if( m_pFilter->m_State != State_Stopped )
        {
            // accept only audio format changes even when running
            if( m_mt.majortype == MEDIATYPE_Audio &&
                pmt->majortype == MEDIATYPE_Audio &&
                pmt->formattype == FORMAT_WaveFormatEx &&
                pmt->cbFormat == pmt->cbFormat)
            {
	            hr = S_OK;
            }
            else if(m_mt.majortype == MEDIATYPE_Interleaved &&
                pmt->majortype == MEDIATYPE_Interleaved &&
                pmt->formattype == FORMAT_DvInfo &&
                m_mt.cbFormat == pmt->cbFormat &&
                pmt->pbFormat != NULL)
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }        
    }
    if( S_OK == hr )
    {    
        hr = CBaseInputPin::QueryAccept(pmt);
    } 
    DbgLog( ( LOG_TRACE
          , 3
          , TEXT("CWMWriterInputPin::QueryAccept() returning 0x%08lx")
          , hr ) );
        
    return hr;
}

// =================================================================
// Implements IMemInputPin interface
// =================================================================

//
// EndOfStream
//
// Tell filter this pin's done receiving
//
STDMETHODIMP CWMWriterInputPin::EndOfStream(void)
{
    HRESULT hr;
    {
        CAutoLock lock(&m_pFilter->m_csFilter);

        // call CheckStreaming instead??
        if(m_bFlushing)
            return S_OK;

        if(m_pFilter->m_State == State_Stopped)
            return S_FALSE;

        //ASSERT( !m_fEOSReceived ); // can this happen legally? Yes, if we force it in Receive
        if( m_fEOSReceived )
        {        
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterInputPin::EndOfStream Error - already received EOS for pin" ) ) );
            return E_UNEXPECTED;
        }
        m_fEOSReceived = TRUE;            
        hr = m_pFilter->EndOfStreamFromPin(m_numPin);
    }

    return hr;
}

//
// HandleFormatChange
//
HRESULT CWMWriterInputPin::HandleFormatChange( const CMediaType *pmt )
{
    // CBaseInputPin::Receive only calls CheckMediaType, so it doesn't
    // check the additional constraints put on on-the-fly format changes
    // (handled through QueryAccept).
    HRESULT hr = QueryAccept( pmt );   
    
    // upstream filter should have checked
    ASSERT(hr == S_OK);
    
    if(hr == S_OK)
    {
        hr = SetMediaType( pmt );
        DbgLog( ( LOG_TRACE
              , 3
              , TEXT("CWMWriterInputPin::HandleFormatChange SetMediaType() returned 0x%08lx for dynamic change")
              , hr ) );
    }
    return hr;
}


// receive on sample from upstream
HRESULT CWMWriterInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;
    CAutoLock lock(&m_csReceive);
    
    // check all is well with the base class
    hr = CBaseInputPin::Receive(pSample);
    if( S_OK != hr )
        return hr;

    REFERENCE_TIME rtStart, rtStop;
    AM_SAMPLE2_PROPERTIES * pSampleProps = SampleProps();
    if(pSampleProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
    {
        hr = HandleFormatChange( (CMediaType *) pSampleProps->pMediaType );
        if(FAILED(hr)) {
            return hr;
        }
    }
    
    long len = pSample->GetActualDataLength( );
    
    hr = pSample->GetTime(&rtStart, &rtStop);
    if( SUCCEEDED( hr ) )
    {    
#ifdef DEBUG 
        if( VFW_S_NO_STOP_TIME == hr )
        {
            DbgLog(( LOG_TRACE, 5,
                     TEXT("CWMWriterInputPin::Receive GetTime on sample returned VFW_S_NO_STOP_TIME") ) ); 
        }        
#endif
    
        m_rtLastTimeStamp = rtStart;
        
        DbgLog(( LOG_TRACE, 15,
                 TEXT("CWMWriterInputPin::Receive %s sample (#%ld) with timestamp %dms, discontinuity %2d"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid"), 
                 m_cSample,
                 (LONG) ( rtStart/10000 ),
                 ( S_OK == pSample->IsDiscontinuity() ) ));

        if( 0 == m_cSample && rtStart < 0 )
        {
            // with 10ms pre-roll a timestamp should never be < -10ms, right?
            // It may be necessary to offset other streams at end of writing to account for
            // any offset necessary for pre-0 times of individual streams.
            
            // save timestamp offset to use to 0-base sample times in case of pre-roll
            m_rtFirstSampleOffset = rtStart;
        }        
        m_cSample++;
           
        rtStart -= m_rtFirstSampleOffset;
        rtStop -= m_rtFirstSampleOffset;
        ASSERT( rtStart >= 0 );

        if( len == 0 )
        {
            //
            // ??? 0 length?
            // usb video capture occassionally sends 0-length sample with valid timestamps
            //
            DbgLog(( LOG_TRACE, 3,
                     TEXT("CWMWriterInputPin::Receive %s got a 0-length sample"), 
                     (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid") ) );

            hr = S_OK;
        }
        else
        {
            if( m_pFilter->HaveIDeliveredTooMuch( this, rtStart ) )
            {
                DbgLog( (LOG_TRACE, 3, TEXT("Pin %ld has delivered too much at %ld"), m_numPin, long( rtStart / 10000 ) ) );
                SleepUntilReady( );
            }
            
            ASSERT( rtStop >= rtStart );
            if( rtStop < rtStart )
                rtStop = rtStart+1; // ??
            
            hr = m_pFilter->Receive(this, pSample, &rtStart, &rtStop );
        }
    }    
    else if( 0 == len )
    {
        //
        // lookout, the bt829 video capture driver occassionally gives 0-length sample 
        // with no timestamps during transitions!
        //
        DbgLog(( LOG_TRACE, 3,
                 TEXT("CWMWriterInputPin::Receive Received 0-length %s sample (#%ld) with no timestamp...Passing on it"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid"), 
                 m_cSample ) );
        hr = S_OK;  // don't fail receive because of this
    }    
    else
    {
        // uh-oh, we require timestamps on every sample for asf writer!
        m_pFilter->m_fErrorSignaled = TRUE;
        m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CWMWriterInputPin::Receive Error: %s sample has no timestamp!"), 
                 (PINTYPE_AUDIO == m_fdwPinType) ? TEXT("Aud") : TEXT("Vid") ) );
    }    
    return hr;
}


STDMETHODIMP CWMWriterInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    /*  Go for 64 0.5 second buffers - 8 byte aligned */
    pProps->cBuffers = 64;
    pProps->cbBuffer = 1024*8;
    pProps->cbAlign = 1;
    pProps->cbPrefix = 0;
    
    return S_OK;
}

/* Get told which allocator the upstream output pin is actually going to use */
STDMETHODIMP CWMWriterInputPin::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
#ifdef DEBUG        
    if(pAllocator) {
        ALLOCATOR_PROPERTIES propActual, Prop;
        
        HRESULT hr = pAllocator->GetProperties( &Prop );
        if( SUCCEEDED( hr ) )
        {        
            hr = GetAllocatorRequirements( &propActual );
            ASSERT( SUCCEEDED( hr ) );
        
            if( Prop.cBuffers < propActual.cBuffers ||
                Prop.cbBuffer < propActual.cbBuffer )
            {            
                //
                // hmm, we either need to run with less or do a copy
                // what if cBuffers = 1? this is the case for the avi dec
                // so far it looks like we'll be ok with just using the upstream 
                // allocator, even if cBuffers is 1
                //
                DbgLog(( LOG_TRACE, 2,
                         TEXT("CWMWriterInputPin::NotifyAllocator upstream allocator is smaller then we'd prefer (cBuffers = %ld, cbBuffers = %ld)"), 
                         Prop.cBuffers,
                         Prop.cbBuffer ) ); 
            }                         
        }
    }
#endif        
    
    return  CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
} // NotifyAllocator

HRESULT CWMWriterInputPin::Active()
{
    ASSERT(IsConnected());        // base class

    if(m_pAllocator == 0)
        return E_FAIL;

    m_fEOSReceived = FALSE;
    
    // reset sample counter, timestamp offset    
    m_cSample = 0;
    m_rtFirstSampleOffset = 0;
    m_rtLastTimeStamp = 0;
    m_rtLastDeliveredStartTime = 0;
    m_rtLastDeliveredEndTime = 0;
    m_bNeverSleep = FALSE;

    return S_OK;
}


HRESULT CWMWriterInputPin::Inactive()
{
    ASSERT(IsConnected());        // base class

    return CBaseInputPin::Inactive();
}

#ifdef OFFER_INPUT_TYPES

// ------------------------------------------------------------------------
//
// CopyWmTypeToAmType
//
// ------------------------------------------------------------------------
void CopyWmTypeToAmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE *pwmt )
{
    pmt->majortype             = pwmt->majortype;
    pmt->subtype               = pwmt->subtype;
    pmt->bFixedSizeSamples     = pwmt->bFixedSizeSamples;
    pmt->bTemporalCompression  = pwmt->bTemporalCompression;
    pmt->lSampleSize           = pwmt->lSampleSize;
    pmt->formattype            = pwmt->formattype;
    ((CMediaType *)pmt)->SetFormat(pwmt->pbFormat, pwmt->cbFormat);
}
#endif

// ------------------------------------------------------------------------
//
// IsAmTypeEqualWmType - compare WM_MEDIA_TYPE and AM_MEDIA_TYPEs
//
// Note that "Equal" here is to be taken as "does the input typed offered
// look enough like a type acceptable to the WMSDK?"
//
// ------------------------------------------------------------------------
BOOL IsAmTypeEqualWmType( AM_MEDIA_TYPE * pmt, WM_MEDIA_TYPE * pwmt)
{

#ifdef DEBUG
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: Checking whether types match" )));
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: Type offered to input pin:" )));
    LogMediaType( pmt );
    DbgLog((LOG_TRACE,15,TEXT("WMWriter:IsAmTypeEqualWmType: WMSDK enumerated type:" )));
    LogMediaType( (AM_MEDIA_TYPE * ) pwmt ); // in debug assume they're defined the same
#endif
        
    // assume for now that formats will always need to match for valid connections to the writer
    if( pmt->majortype  == pwmt->majortype  && 
        pmt->formattype == pwmt->formattype )
    {
#ifdef DEBUG    
        if( pmt->majortype == MEDIATYPE_Audio )
        {        
            // need to fix other things if this changes
            ASSERT( pwmt->pbFormat && 0 != pwmt->cbFormat );
        }   
#endif
        if ( ( pmt->majortype   == MEDIATYPE_Video &&
               pmt->cbFormat    >= sizeof( VIDEOINFOHEADER ) &&
               pmt->subtype     == pwmt->subtype ) ||
             ( pmt->majortype   == MEDIATYPE_Audio &&
               pmt->cbFormat   == pwmt->cbFormat &&
               ((WAVEFORMATEX *) pmt->pbFormat)->wFormatTag      == ((WAVEFORMATEX *) pwmt->pbFormat)->wFormatTag  &&
               ((WAVEFORMATEX *) pmt->pbFormat)->nBlockAlign     == ((WAVEFORMATEX *) pwmt->pbFormat)->nBlockAlign  &&
               // oops, the wmsdk can't resample odd rate pcm audio so ensure sample rates match!
               //
               // note that this has one very bad side effect, which is if the sample rate
               // isn't supported directly and we pull in acmwrap, acmwrap will always connect
               // with it's 2nd enumerated output type, which is 44k, stereo!!!!
               //
               ((WAVEFORMATEX *) pmt->pbFormat)->nSamplesPerSec  == ((WAVEFORMATEX *) pwmt->pbFormat)->nSamplesPerSec ) )
        {
        
            DbgLog( ( LOG_TRACE,15,TEXT("WMWriter: IsAmTypeEqualWmType - types match") ) );
            return TRUE;
        }                                                                                 
    }
    DbgLog( ( LOG_TRACE,15,TEXT("WMWriter: IsAmTypeEqualWmType - types don't match") ) );
    return FALSE;
}

#ifdef DEBUG
void LogMediaType( AM_MEDIA_TYPE * pmt )
{
    ASSERT( pmt );
    if( !pmt ) 
        return;
        
    if( !pmt->pbFormat || 0 == pmt->cbFormat )
    {    
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  partial media type only, format data not supplied" )));
        return;
    }    
    
    if( pmt->majortype == MEDIATYPE_Audio )
    { 
        WAVEFORMATEX * pwfx = (WAVEFORMATEX *) pmt->pbFormat;
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  wFormatTag      %u" ), pwfx->wFormatTag));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nChannels       %u" ), pwfx->nChannels));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nSamplesPerSec  %lu"), pwfx->nSamplesPerSec));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  nBlockAlign     %u" ), pwfx->nBlockAlign));
        DbgLog((LOG_TRACE,15,TEXT("WMWriter:  wBitsPerSample  %u" ), pwfx->wBitsPerSample));
    }
    else if( pmt->majortype == MEDIATYPE_Video )
    {    
        LPBITMAPINFOHEADER pbmih = HEADER( pmt->pbFormat );
        
        DbgLog((LOG_TRACE,15,TEXT("WMWriter: biComp: %lx bitDepth: %d"),
        		pbmih->biCompression,
        		pbmih->biBitCount ) );
        DbgLog((LOG_TRACE,15,TEXT("WMWriter: biWidth: %ld biHeight: %ld biSize: %ld"),
				pbmih->biWidth,
				pbmih->biHeight,
				pbmih->biSize ) );
    }
    else
    {                                
        DbgLog((LOG_TRACE,15,TEXT("  non video or audio media type" )));
    }                                
}
#endif

// ------------------------------------------------------------------------
//
// IsCompressed - compressed video?
//
// ------------------------------------------------------------------------
BOOL IsCompressed( DWORD biCompression )
{
    switch( biCompression )
    {
        case BI_RGB:
            return( FALSE );
    };
    
    return( TRUE );
}

// ------------------------------------------------------------------------
//
// CWMSample methods
//
CWMSample::CWMSample(
    TCHAR *pName,
    IMediaSample  * pSample ) :
        CBaseObject( pName ),
        m_pSample( pSample ),
        m_cOurRef( 0 )
{
    DbgLog(( LOG_TRACE, 100,
    
             TEXT("CWMSample::CWMSample constructor this = 0x%08lx, m_pSample = 0x%08lx "), 
             this, m_pSample ) );

}

// override say what interfaces we support where
STDMETHODIMP CWMSample::NonDelegatingQueryInterface(
                                            REFIID riid,
                                            void** ppv )
{
    if( riid == IID_INSSBuffer )
    {
        return( GetInterface( (INSSBuffer *)this, ppv ) );
    }
    else
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWMSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    DbgLog(( LOG_TRACE, 100,
             TEXT("CWMSample::Release entered with m_cOurRef = %ld (this = 0x%08lx, m_pSample = 0x%08lx)"), 
             m_cOurRef, this, m_pSample ) );
    if (m_cOurRef == 1) {
        lRef = 0;
        m_cOurRef = 0;
        m_pSample->Release();
        DbgLog(( LOG_TRACE, 100,
                 TEXT("CWMSample::Release releasing sample and deleting object (this = 0x%08lx, m_pSample = 0x%08lx)"), 
                 this, m_pSample ) );
        delete this;
    } else {
        lRef = InterlockedDecrement(&m_cOurRef);
    }
    ASSERT(lRef >= 0);
    return lRef;
}

STDMETHODIMP_(ULONG) CWMSample::AddRef()
{
    DbgLog(( LOG_TRACE, 100,
             TEXT("CWMSample::AddRef entered with m_cOurRef = %ld (this = 0x%08lx, m_pSample = 0x%08lx)"), 
             m_cOurRef, this, m_pSample ) );
    // if this is the first addref grab a hold on the media sample we've wrapped
    if (m_cOurRef == 0) {
        m_pSample->AddRef();
    }        
    return InterlockedIncrement(&m_cOurRef);
}

STDMETHODIMP CWMSample::QueryInterface( REFIID riid, void **ppvObject )
{
    return NonDelegatingQueryInterface( riid, ppvObject );
} 

// ------------------------------------------------------------------------
//
// methods to make our wrapped IMediaSample look like an INSSBuffer sample
//
STDMETHODIMP CWMSample::GetLength( DWORD *pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }
    *pdwLength = m_pSample->GetActualDataLength();

    return( S_OK );
}

STDMETHODIMP CWMSample::SetLength( DWORD dwLength )
{
    return m_pSample->SetActualDataLength( dwLength );
} 

STDMETHODIMP CWMSample::GetMaxLength( DWORD * pdwLength )
{
    if( NULL == pdwLength )
    {
        return( E_INVALIDARG );
    }

    *pdwLength = m_pSample->GetSize();
    return( S_OK );
} 

STDMETHODIMP CWMSample::GetBufferAndLength(
    BYTE  ** ppdwBuffer,
    DWORD *  pdwLength )
{
    if( !ppdwBuffer || !pdwLength )
        return E_POINTER;
        
    HRESULT hr = m_pSample->GetPointer( ppdwBuffer );
    if( SUCCEEDED( hr ) )
        *pdwLength = m_pSample->GetActualDataLength();
    
    return hr;        
} 

STDMETHODIMP CWMSample::GetBuffer( BYTE ** ppdwBuffer )
{
    if( !ppdwBuffer )
        return E_POINTER;

    return m_pSample->GetPointer( ppdwBuffer );
} 

void
CWMWriterInputPin::SleepUntilReady( )
{
    DbgLog((LOG_TRACE, 5, "Pin %ld Going to sleep...", m_numPin ));
    
    DWORD dw = WaitForSingleObject( m_hWakeEvent, INFINITE );
    
    DbgLog((LOG_TRACE, 5, "Pin %ld Woke up!", m_numPin ));
}

void
CWMWriterInputPin::WakeMeUp( )
{
    DbgLog((LOG_TRACE, 5, "Waking Pin %ld", m_numPin  ));
    SetEvent( m_hWakeEvent );
}

// 
// Helper to determine whether a media type is a packed YUV format
// that will require us to do a reconnect for. State of bNegBiHeight
// arg determines whether we look for a positive or negative height
// type.
//
BOOL IsPackedYUVType( BOOL bNegBiHeight, AM_MEDIA_TYPE * pmt )
{
    ASSERT( pmt );
    if( pmt &&
        pmt->majortype == MEDIATYPE_Video &&
        pmt->pbFormat && 
        0 != pmt->cbFormat && // wmsdk workaround for DuplicateMediaType bug with dmo
        ( MEDIASUBTYPE_YUY2 == pmt->subtype ||
          MEDIASUBTYPE_UYVY == pmt->subtype ||
          MEDIASUBTYPE_CLJR == pmt->subtype ) )
    {
        if( bNegBiHeight )
        {
            if( 0 > HEADER(pmt->pbFormat)->biHeight )
            {
                return TRUE;
            }
        }            
        else if( 0 < HEADER(pmt->pbFormat)->biHeight )
        {
            return TRUE;
        }                    
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\asfwrite.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __WMWrite__
#define __WMWrite__

#include "dshowasf.h"

////////////////////////////////////////////////////////////////////////////////

extern const AMOVIESETUP_FILTER sudWMAsfWriter;

#define PROFILE_ID_NOT_SET 0xFFFFFFFF

enum WMWRITE_PINTYPE {
    PINTYPE_NONE  = 0,
    PINTYPE_AUDIO, 
    PINTYPE_VIDEO
};

class CWMWriterIndexerCallback;
class CWMWriter;
class CWMWriterInputPin;

typedef CGenericList<IPin> PinList;

//
// Our sample class which takes an input IMediaSample and makes it look like
// an INSSBuffer buffer for the wmsdk
//
class CWMSample : public INSSBuffer, public CBaseObject
{

public:
    CWMSample(
        TCHAR *pName,
        IMediaSample * pSample );

    // IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHOD( QueryInterface )( REFIID riid, void **ppvObject );
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP_(ULONG) AddRef();

    // INSSBuffer
    STDMETHODIMP GetLength( DWORD *pdwLength );
    STDMETHODIMP SetLength( DWORD dwLength );
    STDMETHODIMP GetMaxLength( DWORD * pdwLength );
    STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
    STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

private:
    IMediaSample *m_pSample;
    LONG         m_cOurRef;
};

//
// Indexing class
//
class CWMWriterIndexerCallback : 
    public CUnknown, public IWMStatusCallback 
{
public:
    DECLARE_IUNKNOWN

    // we support some interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    CWMWriterIndexerCallback(CWMWriter * pWriter) : 
        CUnknown(NAME("CWMWriterIndexerCallback"), NULL), m_pFilter(pWriter) {}

    // IWMStatusCallback
    STDMETHODIMP OnStatus(WMT_STATUS Status, 
                     HRESULT hr,
                     WMT_ATTR_DATATYPE dwType,
                     BYTE *pValue,
                     void *pvContext );
    
    CWMWriter * m_pFilter;
    
};


// 
// Writer input pin class
// 
class CWMWriterInputPin : 
    public CBaseInputPin,
    public IAMStreamConfig
{
    friend class CWMWriter;

protected:

    // interleave stuff
    //
    HANDLE m_hWakeEvent;
    void SleepUntilReady( );
    void WakeMeUp();
    BOOL m_bNeverSleep;

    HRESULT HandleFormatChange( const CMediaType *pmt );

    // owning filter
    CWMWriter *m_pFilter;

public:

    // input pin supports an interface
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);
    
    CWMWriterInputPin(
      CWMWriter *pWMWriter,     // used to enumerate pins
      HRESULT *pHr,             // OLE failure return code
      LPCWSTR szName,           // pin identification
      int numPin,               // number of this pin
      DWORD dwPinType,
      IWMStreamConfig * pWMStreamConfig );


    ~CWMWriterInputPin();

    // update pin info, used to make a recycled pin current
    HRESULT Update( LPCWSTR pName, int numPin, DWORD dwPinType, IWMStreamConfig * pWMStreamConfig );

    // build a list of input media acceptable to the wmsdk for the current profile
    HRESULT BuildInputTypeList();

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* pmt);
    
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType); 

    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
    STDMETHODIMP Disconnect();

    // set the connection media type, as well as the input type for wmsdk
    HRESULT SetMediaType(const CMediaType *pmt);

    STDMETHODIMP NotifyAllocator (IMemAllocator *pAllocator, BOOL bReadOnly);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    // for dynamic format changes
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );


    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream
    STDMETHODIMP EndOfStream(void);
    
    // Called when the stream goes active/inactive
    HRESULT Active(void);
    HRESULT Inactive(void);

    // IAMStreamConfig methods
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt) {return E_NOTIMPL;} ;
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt); // used to return default compressed format
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize){return E_NOTIMPL;} ;
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC){return E_NOTIMPL;} ;


   // Attributes
protected:
    CCritSec m_csReceive;      	// input wide receive lock
    
public:

    BOOL m_bConnected;          // CompleteConnect/BreakConnect pairs
    int m_numPin;               // pin number
    int m_numStream;            // stream #, valid while running
    
    IWMInputMediaProps * m_pWMInputMediaProps;

protected:

    DWORD   m_fdwPinType;       // audio, video,...
    BOOL    m_fEOSReceived;     // Received an EOS yet?
    DWORD   m_cInputMediaTypes; // count of input types offered by our input pin
    IWMMediaProps ** m_lpInputMediaPropsArray; // list of types we offer, based on current profile
    IWMStreamConfig * m_pWMStreamConfig;
    BOOL    m_bCompressedMode;	// this pin's getting compressed data and using advanced writer intf

    DWORD    m_cSample;         // sample counter
    REFERENCE_TIME m_rtFirstSampleOffset;   // first sample time offset if timestamp < 0

    REFERENCE_TIME m_rtLastTimeStamp;
    REFERENCE_TIME m_rtLastDeliveredStartTime;
    REFERENCE_TIME m_rtLastDeliveredEndTime;
};

//
// Define our WMWriter
//
class CWMWriter : 
    public CBaseFilter, 
    public IMediaSeeking,
    public IAMFilterMiscFlags,
    public IFileSinkFilter2,
    public ISpecifyPropertyPages,
    public IConfigAsfWriter,
    public CPersistStream,
    public IWMHeaderInfo,
    public IServiceProvider
{
    friend class CWMWriterInputPin;

public:
    //
    // --- COM Stuff ---
    //
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  
    // map getpin/getpincount for base enum of pins to owner
    // override this to return more specialised pin objects
    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // override state changes to allow derived filters
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP EndOfStream();

    // tell filter this pin's done
    HRESULT EndOfStreamFromPin(int pinNum);
	
    // helper to ensure we're ready for Pause->Run
    HRESULT      CanPause();

    // IMediaSeeking. currently used for a progress bar (how much have
    // we written?)
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat(
        LONGLONG * pTarget, const GUID * pTargetFormat,
        LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions(
        LONGLONG * pCurrent,  DWORD CurrentFlags,
        LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

    //  IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IConfigAsfWriter interface
    //
    STDMETHODIMP ConfigureFilterUsingProfileId( DWORD dwProfileId );
    STDMETHODIMP GetCurrentProfileId( DWORD *pdwProfileId )
    {
        if( NULL == pdwProfileId )
            return E_POINTER;

        *pdwProfileId = 0;
        if( m_dwProfileId != PROFILE_ID_NOT_SET )
        {
            *pdwProfileId = m_dwProfileId;
             return S_OK;
        }
        else
            return E_FAIL;
    }
    STDMETHODIMP ConfigureFilterUsingProfileGuid( REFGUID guidProfile );
    STDMETHODIMP GetCurrentProfileGuid( GUID *pProfileGuid );

    STDMETHODIMP SetIndexMode( BOOL bIndexFile )
    {
        m_bIndexFile = bIndexFile;
        return S_OK;
    }

    STDMETHODIMP GetIndexMode( BOOL *pbIndexFile )
    {
        ASSERT( pbIndexFile );
        if( !pbIndexFile )
            return E_POINTER;

        *pbIndexFile = m_bIndexFile;
        return S_OK; 
    }

    //
    // Use these methods when a custom profile setup is preferred
    //
    STDMETHODIMP ConfigureFilterUsingProfile(IWMProfile * pWMProfile);
    STDMETHODIMP GetCurrentProfile( IWMProfile **ppProfile )
    {
        if( !ppProfile )
            return E_POINTER;

        *ppProfile = m_pWMProfile;
        if( m_pWMProfile )
        {
            // caller must release
            m_pWMProfile->AddRef();    
       	} else {
            // indicative of some unexpected error
            return E_FAIL;
       	}
   
        return S_OK;
    }

    //
    // CPersistStream
    //
    STDMETHODIMP GetClassID(CLSID *pClsid);
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    //
    // --- IFileSinkFilter interface ---
    //
    STDMETHODIMP SetFileName( LPCOLESTR pszFileName, const AM_MEDIA_TYPE *pmt );
    STDMETHODIMP SetMode( DWORD dwFlags );
    STDMETHODIMP GetCurFile( LPOLESTR * ppszFileName, AM_MEDIA_TYPE *pmt );
    STDMETHODIMP GetMode( DWORD *pdwFlags );

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID *pPages);


    // IWMHeaderInfo
    STDMETHODIMP GetAttributeCount( WORD wStreamNum,
                               WORD *pcAttributes );
    STDMETHODIMP GetAttributeByIndex( WORD wIndex,
                                 WORD *pwStreamNum,
                                 WCHAR *pwszName,
                                 WORD *pcchNameLen,
                                 WMT_ATTR_DATATYPE *pType,
                                 BYTE *pValue,
                                 WORD *pcbLength );
    STDMETHODIMP GetAttributeByName( WORD *pwStreamNum,
                                LPCWSTR pszName,
                                WMT_ATTR_DATATYPE *pType,
                                BYTE *pValue,
                                WORD *pcbLength );
    STDMETHODIMP SetAttribute( WORD wStreamNum,
                          LPCWSTR pszName,
                          WMT_ATTR_DATATYPE Type,
                          const BYTE *pValue,
                          WORD cbLength );
    STDMETHODIMP GetMarkerCount( WORD *pcMarkers );
    STDMETHODIMP GetMarker( WORD wIndex,
                       WCHAR *pwszMarkerName,
                       WORD *pcchMarkerNameLen,
                       QWORD *pcnsMarkerTime );
    STDMETHODIMP AddMarker( WCHAR *pwszMarkerName,
                       QWORD cnsMarkerTime );
    STDMETHODIMP RemoveMarker( WORD wIndex );
    STDMETHODIMP GetScriptCount( WORD *pcScripts );
    STDMETHODIMP GetScript( WORD wIndex,
                       WCHAR *pwszType,
                       WORD *pcchTypeLen,
                       WCHAR *pwszCommand,
                       WORD *pcchCommandLen,
                       QWORD *pcnsScriptTime );
    STDMETHODIMP AddScript( WCHAR *pwszType,
                       WCHAR *pwszCommand,
                       QWORD cnsScriptTime );
    STDMETHODIMP RemoveScript( WORD wIndex );


    //
    // wmsdk helpers
    //

    // release current profile on deletion or reset
    void    DeleteProfile();
    void    DeletePins( BOOL bRecycle = FALSE ); // delete input pins (or recycle if TRUE)
    void    ReleaseWMWriter();
    HRESULT CreateWMWriter();   // create the wmsdk objects
    HRESULT LoadInternal();     // given a certification, open the wmsdk and configure the filter

    // tell wmsdk where to write
    HRESULT Open(); 
    void    Close();

    HRESULT      m_hrIndex;             // indexer object status
    BOOL         m_bIndexFile;          // indicates whether to index file
    BOOL         m_bResetFilename;      // does wmsdk need to be told the output filename?

public:
    // Construction / destruction
    CWMWriter(TCHAR *, LPUNKNOWN, CLSID clsid, HRESULT * );
    ~CWMWriter();

// Definitions
protected:
    CCritSec m_csFilter;                // filter wide lock
    
    // control streaming ?
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // chance to customize the Muxing process
    HRESULT Receive(
                CWMWriterInputPin * pPin, 
                IMediaSample * pSample, 
                REFERENCE_TIME *prtStart,
                REFERENCE_TIME *prtEnd );

    HRESULT CopyOurSampleToNSBuffer( INSSBuffer *pNSDest, IMediaSample *pSource );
    HRESULT IndexFile();

private:
    enum TimeFormat
    {
        FORMAT_TIME
    } m_TimeFormat;

    // cache file name
    OLECHAR*    m_wszFileName;

    BOOL        m_MediaTypeChanged;
    BOOL        m_fErrorSignaled;

    DWORD       m_dwOpenFlags;      // file open mode

    // wmsdk writer members
    IWMWriter*          m_pWMWriter;
    IWMWriterAdvanced*  m_pWMWriterAdvanced;
    IWMHeaderInfo*      m_pWMHI;
    IWMProfile*         m_pWMProfile;
    DWORD               m_dwProfileId; 
    GUID                m_guidProfile; 
    DWORD               m_fdwConfigMode; 
    IUnknown*           m_pUnkCert;

    // pin lists
    CGenericList<CWMWriterInputPin> m_lstInputPins;
    CGenericList<CWMWriterInputPin> m_lstRecycledPins;
  
    // number of inputs filter has currently
    int m_cInputs;           // count of total input pins
    int m_cAudioInputs;      // count of audio input pins
    int m_cVideoInputs;      // count of video input pins
    int m_cConnections;      // connected pins
    int m_cConnectedAudioPins;  // connected audio pins (need at least 1 to run, for now)
    int m_cActiveAudioStreams;  // # of audio streams which haven't receive EOS

    // create a pin 
    HRESULT AddNextPin(unsigned callingPin, DWORD dwPinType, IWMStreamConfig * pWMStreamConfig);

    CWMWriterInputPin * GetPinById( int numPin );

    HRESULT CompleteConnect( int numPin );
    HRESULT BreakConnect( int numPin );
    HRESULT PrepareForReconnect( PinList & lstReconnectPins ); // cache connected pins
    HRESULT ReconnectPins( PinList & lstReconnectPins );       // attempt to reconnect previously connected pins

    // we're a renderer
    STDMETHODIMP_(ULONG) GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_RENDERER; }

    // persistent data
    struct FilterPersistData
    {
        DWORD	dwcb;
        DWORD	dwProfileId;
        DWORD   fdwConfigMode;
        GUID    guidProfile;
    };

    // interleave stuff
    //
    BOOL HaveIDeliveredTooMuch( CWMWriterInputPin * pPin, REFERENCE_TIME Start );
};

#endif /* __WMWrite__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\proppage.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  proppage.cpp - property page for ASF writer filter
//
//--------------------------------------------------------------------------;


#include <streams.h>
#include <wmsdk.h>
#include <atlbase.h>

#include "asfwrite.h"
#include "resource.h"
#include "proppage.h"
#include <atlimpl.cpp>


//
// CreateInstance
//
CUnknown * WINAPI CWMWriterProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CWMWriterProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


//
// CWMWriterProperties::Constructor
//
CWMWriterProperties::CWMWriterProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("CWMWriter Property Page"),pUnk,
        IDD_ASFWRITERPROPS, IDS_TITLE),
        m_pIConfigAsfWriter( NULL ),
        m_hwndProfileCB( 0 ),
        m_hwndIndexFileChkBox( 0 )
{
} 

CWMWriterProperties::~CWMWriterProperties()
{   
    ASSERT( NULL == m_pIConfigAsfWriter );
    if( m_pIConfigAsfWriter )
    {
        m_pIConfigAsfWriter->Release();
        m_pIConfigAsfWriter = NULL;
    }            

}

//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CWMWriterProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

} // SetDirty


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR CWMWriterProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // get the hWnd of the list box
            m_hwndProfileCB       = GetDlgItem (hwnd, IDC_PROFILE_LIST) ;
            m_hwndIndexFileChkBox = GetDlgItem (hwnd, IDC_INDEX_FILE) ;
            
            FillProfileList();
            
            // init Index File check box
            BOOL bIndex = TRUE; 
            
            HRESULT hr = m_pIConfigAsfWriter->GetIndexMode( &bIndex );
            ASSERT( SUCCEEDED( hr ) );
           
            Button_SetCheck(m_hwndIndexFileChkBox, bIndex);

            return (LRESULT) 1;
        }

        case WM_COMMAND:
        {
            if( HIWORD(wParam) == CBN_SELCHANGE ||
                LOWORD(wParam) == IDC_INDEX_FILE )
            {
                SetDirty();
            }
            return (LRESULT) 1;
        }

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
HRESULT CWMWriterProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIConfigAsfWriter == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IConfigAsfWriter, (void **) &m_pIConfigAsfWriter);
    ASSERT( SUCCEEDED( hr ) );
    if (FAILED(hr))
    {
        return hr;
    }

    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface, release the upstream pin.
//
HRESULT CWMWriterProperties::OnDisconnect()
{
    if( m_pIConfigAsfWriter )
    {
        m_pIConfigAsfWriter->Release();
        m_pIConfigAsfWriter = NULL;
    }            
    return NOERROR;

} // OnDisconnect


//
// Activate
//
// We are being activated
//
HRESULT CWMWriterProperties::OnActivate()
{
    DWORD dwProfileId;
    
    GUID guidProfile;
    
    // get the current profile guid and try to find the index that matches it
    HRESULT hr = m_pIConfigAsfWriter->GetCurrentProfileGuid( &guidProfile );
    if( SUCCEEDED( hr ) )
    {
        // now try to find which system profile index is associated with this profile guid
        hr = GetProfileIndexFromGuid( &dwProfileId, guidProfile );
    }        
    
    if( SUCCEEDED( hr ) )
        SendMessage (m_hwndProfileCB, CB_SETCURSEL, dwProfileId, 0) ;
            
    return NOERROR;
    
} // Activate

//
// GetProfileIndexFromGuid
//
// given a profile guid attempt to the matching system profile and return its index
//
HRESULT CWMWriterProperties::GetProfileIndexFromGuid( DWORD *pdwProfileIndex, GUID guidProfile )
{
    ASSERT( pdwProfileIndex );
    
    USES_CONVERSION;
    
    if( !pdwProfileIndex ) 
        return E_POINTER;
            
    CComPtr <IWMProfileManager> pIWMProfileManager;
    WCHAR *wszProfileCurrent = NULL; 
    DWORD cProfiles = 0;
    *pdwProfileIndex = 0; // default in case we don't find it
    
    HRESULT hr = WMCreateProfileManager( &pIWMProfileManager );
    if( SUCCEEDED( hr ) )
    {   
        // only need to check new profiles since that's all we enumerate
        IWMProfileManager2*	pIPM2 = NULL;
        HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                    ( void ** )&pIPM2 );
        if( SUCCEEDED( hrInt ) )
        {
            pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
            pIPM2->Release();
        }
#ifdef DEBUG        
        else
        {
            // else if IWMProfileManager2 isn't supported I guess we assume that we're 
            // running on Apollo bits and the hack isn't needed?  
            DbgLog(( LOG_TRACE, 2, TEXT("CWMWriter::GetProfileIndexFromGuid QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
        }        
#endif                
                     
        hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    }

    if( SUCCEEDED( hr ) )
    {        
        //    
        // load each system profile and compare guid's until we find a match
        //    
        BOOL bDone = FALSE;
        for (int i = 0; !bDone && i < (int)cProfiles; ++i)
        {
            CComPtr <IWMProfile> pIWMProfileTemp;
    
            hr = pIWMProfileManager->LoadSystemProfile( i, &pIWMProfileTemp );
            if( SUCCEEDED( hr ) )
            {   
                CComPtr <IWMProfile2> pWMProfile2;
                hr = pIWMProfileTemp->QueryInterface( IID_IWMProfile2, (void **) &pWMProfile2 );
                ASSERT( SUCCEEDED( hr ) );
                if( SUCCEEDED( hr ) )
                {              
                    GUID guidProfileTemp;
                    hr = pWMProfile2->GetProfileID( &guidProfileTemp );
                    if( SUCCEEDED( hr ) )
                    {
                        if( guidProfileTemp == guidProfile )
                        {
                            // we've found the profile we wanted, exit
                            *pdwProfileIndex = i;
                            bDone = TRUE;
                        }
                    }
                }
            }                                    
        }
    }
        
    return hr;
}

//
// OnApplyChanges
//
// Changes made should be kept.
//
HRESULT CWMWriterProperties::OnApplyChanges()
{
    ASSERT( m_pIConfigAsfWriter );
    HRESULT hr = S_OK;

    //
    // get the current selection of the profile? maybe...
    //
    int iIndex = (int) SendMessage(m_hwndProfileCB, CB_GETCURSEL, 0, 0) ;
    if( iIndex <= 0 )
        iIndex = 0 ;

    m_bDirty = FALSE;            // the page is now clean
    
    CComPtr <IWMProfileManager> pIWMProfileManager;

    hr = WMCreateProfileManager( &pIWMProfileManager );

    //
    // we only use 7_0 profiles
    //        
    IWMProfileManager2*	pIPM2 = NULL;
    HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                ( void ** )&pIPM2 );
    if( SUCCEEDED( hrInt ) )
    {
        pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
        pIPM2->Release();
    }
#ifdef DEBUG        
    else
    {
        // else if IWMProfileManager2 isn't supported I guess we assume that we're 
        // running on Apollo bits and the hack isn't needed?  
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterProperties::OnApplyChanges QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
    }        
#endif                
      
    // to validate the id passed in we could re-query for this or cache it the first time
    // re-querying for now
    DWORD cProfiles;
    hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    if( SUCCEEDED( hr ) )
    {
        ASSERT( (DWORD)iIndex < cProfiles );
        if( (DWORD)iIndex >= cProfiles )
        {
            DbgLog( ( LOG_TRACE
                  , 3
                  , TEXT("CWMWriter::ConfigureFilterUsingProfileId: ERROR - invalid profile id (%d)")
                  , iIndex ) );
                  
            hr = E_FAIL;   
        }
    }
    if( SUCCEEDED( hr ) )
    {   
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( iIndex, &pIWMProfile );
        if( SUCCEEDED( hr ) )
        {
            // now reconfigure filter
            hr = m_pIConfigAsfWriter->ConfigureFilterUsingProfile( pIWMProfile );
            ASSERT( SUCCEEDED( hr ) );
        }            
    }    
    
    // update the indexing mode
    int iState = (int) SendMessage( m_hwndIndexFileChkBox, BM_GETCHECK, 0, 0 ) ;
    m_pIConfigAsfWriter->SetIndexMode( iState == BST_CHECKED ? TRUE : FALSE );
    
    return hr;

} // OnApplyChanges


//
// FillProfileList
//
// Fill the list box with an enumeration of the media type that our
//
void CWMWriterProperties::FillProfileList()
{
    USES_CONVERSION;
    
    int wextent = 0 ;
    int Loop = 0 ;
    SIZE extent ;
    DWORD cProfiles = 0 ;
    
    CComPtr <IWMProfileManager> pIWMProfileManager;

    HRESULT hr = WMCreateProfileManager( &pIWMProfileManager );
    if( FAILED( hr ) )
    {   
        return; // return error!
    }        
        
    // only show 7_0 profiles
    IWMProfileManager2*	pIPM2 = NULL;
    HRESULT hrInt = pIWMProfileManager->QueryInterface( IID_IWMProfileManager2,
                                ( void ** )&pIPM2 );
    if( SUCCEEDED( hrInt ) )
    {
        pIPM2->SetSystemProfileVersion( WMT_VER_7_0 );
        pIPM2->Release();
    }
#ifdef DEBUG        
    else
    {
        // else if IWMProfileManager2 isn't supported I guess we assume that we're 
        // running on Apollo bits and the hack isn't needed?  
        DbgLog(( LOG_TRACE, 2, TEXT("CWMWriterProperties::FillProfileList QI for IWMProfileManager2 failed [0x%08lx]"), hrInt ));
    }        
#endif                
        
    hr = pIWMProfileManager->GetSystemProfileCount(  &cProfiles );
    if( FAILED( hr ) )
    {
        return;
    }
        
    //
    // get a dc for the control
    //
    HDC hdc = GetDC( m_hwndProfileCB );
    if( NULL == hdc )
        return;
        
    //    
    // now load the profile strings
    //    
    LRESULT ix;
    DWORD cchName, cchDescription;
    for (int i = 0; i < (int)cProfiles && SUCCEEDED( hr ) ; ++i)
	{
        CComPtr <IWMProfile> pIWMProfile;
        
        hr = pIWMProfileManager->LoadSystemProfile( i, &pIWMProfile );
        if( FAILED( hr ) )
            break;
            
        hr = pIWMProfile->GetName( NULL, &cchName );
        if( FAILED( hr ) )
            break;
            
        WCHAR *wszProfile = new WCHAR[ cchName + 1 ]; 
        if( NULL == wszProfile )
            break;
            
        hr = pIWMProfile->GetName( wszProfile, &cchName );
        if( FAILED( hr ) )
            break;
        
        hr = pIWMProfile->GetDescription( NULL, &cchDescription );
        if( FAILED( hr ) )
            break;
            
        WCHAR *wszDescription = new WCHAR[ cchDescription + 1 ]; // + 1? assume so, check
        if( NULL == wszDescription )
            break;
            
        
        hr = pIWMProfile->GetDescription( wszDescription, &cchDescription );
        if( FAILED( hr ) )
            break;
        
        const WCHAR *cwszDivider = L" - ";
        
        WCHAR *wszDisplayString = new WCHAR[ cchDescription +
                                             cchName +
                                             wcslen(cwszDivider) + 1 ];
        if( NULL == wszDisplayString )
            break;
            
        wcscpy( wszDisplayString, wszProfile );
        wcscat( wszDisplayString, cwszDivider );
        wcscat( wszDisplayString, wszDescription );
                
        TCHAR *szDisplayString = W2T( wszDisplayString );

                
        //
        // get the extent of the string and save the max extent
        //
        GetTextExtentPoint( hdc, szDisplayString, _tcslen(szDisplayString), &extent ) ;
        if (extent.cx > wextent)
            wextent = extent.cx ;

        //
        // add the string to the list box.
        //
        ix = SendMessage (m_hwndProfileCB, CB_INSERTSTRING, i, (LPARAM)(LPCTSTR)szDisplayString) ;

        ASSERT (CB_ERR != ix);
        
        delete[] wszProfile;
        delete[] wszDescription;
        delete[] wszDisplayString;
    }
    SendMessage (m_hwndProfileCB, CB_SETHORIZONTALEXTENT, wextent, 0) ;
    SendMessage (m_hwndProfileCB, CB_SETCURSEL, 0, 0) ;

    ReleaseDC( m_hwndProfileCB, hdc );
    
} // FillProfileListBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\proppage.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// proppage.h
//----------------------------------------------------------------------------

// {D9F9C262-6231-11d3-8B1D-00C04FB6BD3D}
EXTERN_GUID(CLSID_WMAsfWriterProperties, 
0xd9f9c262, 0x6231, 0x11d3, 0x8b, 0x1d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d);

class CProfileSelectDlg;

class CWMWriterProperties : public CBasePropertyPage
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    DECLARE_IUNKNOWN;

private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    HRESULT GetProfileIndexFromGuid( DWORD *pdwProfileIndex, GUID guidProfile );

    void SetDirty();
    void FillProfileList();

    CWMWriterProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CWMWriterProperties();

    HWND        m_hwndProfileCB ;       // Handle of the profile combo box
    HWND        m_hwndIndexFileChkBox ; // Handle of the index filter check box

    IConfigAsfWriter * m_pIConfigAsfWriter;

};  // class WMWriterProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\asfwrite\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// resource ids 
//
#define ASFWRITER_BASE                  100

// dialog
#define IDD_ASFWRITERPROPS              ASFWRITER_BASE

// strings
#define IDS_TITLE                       ASFWRITER_BASE+1

// controls
#define IDC_PROFILE_LIST                ASFWRITER_BASE+2
#define IDC_INDEX_FILE                  ASFWRITER_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\asferr.h ===
//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================
///////////////////////////////////////////////////////////////////////////
//
// ASFErr.h - definition of ASF HRESULT codes
//
// Copyright (c) 1997  Microsoft Corporation
//
// This file is generated by the MC tool from ASFErr.mc
//

#ifndef _ASFERR_H
#define _ASFERR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Errors (2000 - 2999)
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ASF_E_BUFFEROVERRUN
//
// MessageText:
//
//  An attempt was made to seek or position past the end of a buffer.%0
//
#define ASF_E_BUFFEROVERRUN              0xC00D07D0L

//
// MessageId: ASF_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The supplied input or output buffer was too small.%0
//
#define ASF_E_BUFFERTOOSMALL             0xC00D07D1L

//
// MessageId: ASF_E_BADLANGUAGEID
//
// MessageText:
//
//  The language ID was not found.%0
//
#define ASF_E_BADLANGUAGEID              0xC00D07D2L

//
// MessageId: ASF_E_NOPAYLOADLENGTH
//
// MessageText:
//
//  The multiple payload packet is missing the payload length.%0
//
#define ASF_E_NOPAYLOADLENGTH            0xC00D07DBL

//
// MessageId: ASF_E_TOOMANYPAYLOADS
//
// MessageText:
//
//  The packet contains too many payloads.%0
//
#define ASF_E_TOOMANYPAYLOADS            0xC00D07DCL

//
// MessageId: ASF_E_PACKETCONTENTTOOLARGE
//
// MessageText:
//
//  ASF_E_PACKETCONTENTTOOLARGE
//
#define ASF_E_PACKETCONTENTTOOLARGE      0xC00D07DEL

//
// MessageId: ASF_E_UNKNOWNPACKETSIZE
//
// MessageText:
//
//  Expecting a fixed packet size but min. and max. are not equal.%0
//
#define ASF_E_UNKNOWNPACKETSIZE          0xC00D07E0L

//
// MessageId: ASF_E_INVALIDHEADER
//
// MessageText:
//
//  ASF_E_INVALIDHEADER
//
#define ASF_E_INVALIDHEADER              0xC00D07E2L

//
// MessageId: ASF_E_NOCLOCKOBJECT
//
// MessageText:
//
//  The object does not have a valid clock object.%0
//
#define ASF_E_NOCLOCKOBJECT              0xC00D07E6L

//
// MessageId: ASF_E_UNKNOWNCLOCKTYPE
//
// MessageText:
//
//  ASF_E_UNKNOWNCLOCKTYPE
//
#define ASF_E_UNKNOWNCLOCKTYPE           0xC00D07EBL

//
// MessageId: ASF_E_OPAQUEPACKET
//
// MessageText:
//
//  An attempt was made to restore or access an opaque packet.%0
//
#define ASF_E_OPAQUEPACKET               0xC00D07EDL

//
// MessageId: ASF_E_WRONGVERSION
//
// MessageText:
//
//  ASF_E_WRONGVERSION
//
#define ASF_E_WRONGVERSION               0xC00D07EEL

//
// MessageId: ASF_E_OVERFLOW
//
// MessageText:
//
//  An attempt was made to store a value which was larger than then destination's maximum value.%0
//
#define ASF_E_OVERFLOW                   0xC00D07EFL

//
// MessageId: ASF_E_NOTFOUND
//
// MessageText:
//
//  The object was not found.%0
//
#define ASF_E_NOTFOUND                   0xC00D07F0L

//
// Someone else is using MessageIds 2033 & 2034, so we skip them
// 
// 2033 = NS_E_NOTHING_TO_DO
// 2034 = NS_E_NO_MULTICAST

//
// MessageId: ASF_E_OBJECTTOOBIG
//
// MessageText:
//
//  The object is too large to be processed in the requested manner.%0
//
#define ASF_E_OBJECTTOOBIG               0xC00D07F3L

//
// MessageId: ASF_E_UNEXPECTEDVALUE
//
// MessageText:
//
//  A value was not set as expected.%0
//
#define ASF_E_UNEXPECTEDVALUE            0xC00D07F4L

//
// MessageId: ASF_E_INVALIDSTATE
//
// MessageText:
//
//  The request is not valid in the object's current state.%0
//
#define ASF_E_INVALIDSTATE               0xC00D07F5L

//
// MessageId: ASF_E_NOLIBRARY
//
// MessageText:
//
//  This object does not have a valid library pointer; it was not properly created or it has been Shutdown().%0
//
#define ASF_E_NOLIBRARY                  0xC00D07F6L

//
// MessageId: ASF_E_ALREADYINITIALIZED
//
// MessageText:
//
//  This object has already been initialized; the setting cannot be changed.%0
//
#define ASF_E_ALREADYINITIALIZED         0xC00D07F7L

//
// MessageId: ASF_E_INVALIDINIT
//
// MessageText:
//
//  This object has not been initialized properly; that operation cannot be performed.%0
//
#define ASF_E_INVALIDINIT                0xC00D07F8L

//
// MessageId: ASF_E_NOHEADEROBJECT
//
// MessageText:
//
//  The ASF Header object could not be found.%0
//
#define ASF_E_NOHEADEROBJECT             0xC00D07F9L

//
// MessageId: ASF_E_NODATAOBJECT
//
// MessageText:
//
//  The ASF Data object could not be found.%0
//
#define ASF_E_NODATAOBJECT               0xC00D07FAL

//
// MessageId: ASF_E_NOINDEXOBJECT
//
// MessageText:
//
//  The ASF Index object could not be found.%0
//
#define ASF_E_NOINDEXOBJECT              0xC00D07FBL

//
// MessageId: ASF_E_NOSTREAMPROPS
//
// MessageText:
//
//  A Stream Properties object with the correct stream number could not be found.%0
//
#define ASF_E_NOSTREAMPROPS              0xC00D07FCL

//
// MessageId: ASF_E_NOFILEPROPS
//
// MessageText:
//
//  The File Properties object could not be found.%0
//
#define ASF_E_NOFILEPROPS                0xC00D07FDL

//
// MessageId: ASF_E_NOLANGUAGELIST
//
// MessageText:
//
//  The Language List object could not be found.%0
//
#define ASF_E_NOLANGUAGELIST             0xC00D07FEL

//
// MessageId: ASF_E_NOINDEXPARAMETERS
//
// MessageText:
//
//  The Index Parameters object could not be found.%0
//
#define ASF_E_NOINDEXPARAMETERS          0xC00D07FFL

//
// MessageId: ASF_E_UNSUPPORTEDERRORCONCEALMENT
//
// MessageText:
//
//  The requested error concealment strategy is not supported by this component.%0
//
#define ASF_E_UNSUPPORTEDERRORCONCEALMENT 0xC00D0800L

//
// MessageId: ASF_E_INVALIDFLAGS
//
// MessageText:
//
//  The flags for this object or set of objects are not properly set.%0
//
#define ASF_E_INVALIDFLAGS               0xC00D0801L

//
// MessageId: ASF_E_BADDATADESCRIPTOR
//
// MessageText:
//
//  One or more data descriptors is not properly set.%0
//
#define ASF_E_BADDATADESCRIPTOR          0xC00D0802L

//
// MessageId: ASF_E_BADINDEXTIMEINTERVAL
//
// MessageText:
//
//  The index has an invalid time interval (probably zero).%0
//
#define ASF_E_BADINDEXTIMEINTERVAL       0xC00D0803L

//
// MessageId: ASF_E_INVALIDTIME
//
// MessageText:
//
//  The given time value is not valid.%0
//
#define ASF_E_INVALIDTIME                0xC00D0804L

//
// MessageId: ASF_E_INVALIDINDEX
//
// MessageText:
//
//  The given index value is not valid.%0
//
#define ASF_E_INVALIDINDEX               0xC00D0805L

//
// MessageId: ASF_E_STREAMNUMBERINUSE
//
// MessageText:
//
//  The specified stream number is already in use.%0
//
#define ASF_E_STREAMNUMBERINUSE          0xC00D0806L

//
// MessageId: ASF_E_BADMEDIATYPE
//
// MessageText:
//
//  The specified media type does not work with this component.%0
//
#define ASF_E_BADMEDIATYPE               0xC00D0807L

//
// MessageId: ASF_E_WRITEFAILED
//
// MessageText:
//
//  The object could not be written as specified.%0
//
#define ASF_E_WRITEFAILED                0xC00D0808L

//
// MessageId: ASF_E_NOTENOUGHDESCRIPTORS
//
// MessageText:
//
//  The given data unit requires a larger number of descriptors to be fully parsed.%0
//
#define ASF_E_NOTENOUGHDESCRIPTORS       0xC00D0809L

//
// MessageId: ASF_E_INDEXBLOCKUNLOADED
//
// MessageText:
//
//  The index entries for the specified index block have been unloaded from memory and are not available.%0
//
#define ASF_E_INDEXBLOCKUNLOADED         0xC00D080AL

//
// MessageId: ASF_E_NOTENOUGHBANDWIDTH
//
// MessageText:
//
//  The specified bandwidth is not large enough.%0
//
#define ASF_E_NOTENOUGHBANDWIDTH         0xC00D080BL

//
// MessageId: ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE
//
// MessageText:
//
//  The object has exceeded its maximum size.%0
//
#define ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE  0xC00D080CL

//
// MessageId: ASF_E_BADDATAUNIT
//
// MessageText:
//
//  The given data unit is corrupted, badly formatted, or otherwise not valid.%0
//
#define ASF_E_BADDATAUNIT                0xC00D080DL

//
// MessageId: ASF_E_HEADERSIZE
//
// MessageText:
//
//  The ASF header has exceeded the specified maximum size.%0
//
#define ASF_E_HEADERSIZE                 0xC00D080EL


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Success Codes (2000 - 2999)
//

//
// MessageId: ASF_S_OPAQUEPACKET
//
// MessageText:
//
//  ASF_S_OPAQUEPACKET
//
#define ASF_S_OPAQUEPACKET               0x000D07F0L


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Warnings (2000 - 2999)
//


#endif // _ASFERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\qasf\qasf.cpp ===
//
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//

#include <streams.h>
#undef SubclassWindow

#include <initguid.h>
#define INITGUID

// If FILTER_LIB is defined then the component filters
// are being built as filter libs, to link into this dll,
// hence we need all these gubbins!

#include <wmsdk.h>
#include <qnetwork.h>
#include <wmsdkdrm.h>
#include <wmsecure.h>
#ifndef _WIN64
#include <asfread.h>
#include <asfwrite.h>
#include <proppage.h>
#endif
#include "..\..\..\dmo\wrapper\filter.h"

// individual source filter's includes
CFactoryTemplate g_Templates[] =
{
#ifndef _WIN64
    { L"WM ASF Reader", &CLSID_WMAsfReader, CreateASFReaderInstance, NULL, &sudWMAsfRead },
    { L"WM ASF Writer", &CLSID_WMAsfWriter, CWMWriter::CreateInstance, NULL, &sudWMAsfWriter },
    { L"WM ASF Writer Properties", &CLSID_WMAsfWriterProperties, CWMWriterProperties::CreateInstance },
#endif
    { L"DMO Wrapper Filter", &CLSID_DMOWrapperFilter, CMediaWrapperFilter::CreateInstance, NULL, NULL }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

extern "C" BOOL QASFDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

BOOL QASFDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    BOOL f = DllEntryPoint(hInstance, ulReason, pv);

    // if loading this dll, we want to call the 2nd dll entry point
    // only if the first one succeeded. if unloading, always call
    // both. if the second one fails, undo the first one.  HAVE NOT
    // verified that failing DllEntryPoint for ATTACH does not cause
    // the loader to call in again w/ DETACH. but that seems silly
    if(f || ulReason == DLL_PROCESS_DETACH)
    {
        if (ulReason == DLL_PROCESS_ATTACH)
        {
            DisableThreadLibraryCalls(hInstance);
        }
        else if (ulReason == DLL_PROCESS_DETACH)
        {
            // We hit this ASSERT in NT setup
            // ASSERT(_Module.GetLockCount()==0 );
        }
    }

    return f;
}

//
// stub entry points
//

STDAPI
QASF_DllRegisterServer( void )
{
#if 0 // !!! register ASF stuff here???
  // register the still video source filetypes
  HKEY hkey;
  OLECHAR wch[80];
  char ch[80];
  StringFromGUID2(CLSID_ASFRead, wch, 80);
  LONG l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.asf"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
  l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.wma"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
  l = RegCreateKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.nsc"),
						&hkey);
  if (l == ERROR_SUCCESS) {
#ifdef UNICODE
	l = RegSetValueEx(hkey, L"Source Filter", 0, REG_SZ, (BYTE *)wch,
								_tcslen(wch));
#else
  	WideCharToMultiByte(CP_ACP, 0, wch, -1, ch, sizeof(ch), NULL, NULL);
	l = RegSetValueEx(hkey, "Source Filter", 0, REG_SZ, (BYTE *)ch,
								_tcslen(ch));
#endif
	RegCloseKey(hkey);
	if (l != ERROR_SUCCESS) {
	    ASSERT(0);
	    return E_UNEXPECTED;
	}
  }
#endif

  HRESULT hr =  AMovieDllRegisterServer2( TRUE );

  return hr;
}

STDAPI
QASF_DllUnregisterServer( void )
{
  HRESULT hr = AMovieDllRegisterServer2( FALSE );

  return hr;
}

//  BOOL WINAPI
//  DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
//  {
//      return QASFDllEntry(hInstance, ulReason, pv);
//  }

STDAPI
QASF_DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **ppv)
{
    HRESULT hr = DllGetClassObject(rClsID, riid, ppv);

    return hr;
}

STDAPI QASF_DllCanUnloadNow(void)
{
    HRESULT hr = DllCanUnloadNow();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdk.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:        wmsdk.h
//
//  Description: WMSDK global include file
//
//============================================================================

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT (\"EULA\").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================

#include "wmsdkidl.h"
#include "asferr.h"
#include "nserror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 24 07:28:47 2000
 */
/* Compiler settings for .\wmsbuffer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdkdrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       WMAudioDRM.h
//
//--------------------------------------------------------------------------

#ifndef _WMSDKDRM_H
#define _WMSDKDRM_H

#include "wmsdk.h"

///////////////////////////////////////////////////////////////////////////////
//
// WMCreateDRMReader:
//     Called to create DRM-enabled writer
//     Implementation linked in from WMSDKDRM.lib.
//
HRESULT STDMETHODCALLTYPE WMCreateDRMReader(
                            /* [in] */  IUnknown*   pUnkDRM,
                            /* [in] */  DWORD       dwRights,
                            /* [out] */ IWMReader **ppDRMReader );


///////////////////////////////////////////////////////////////////////////////
//
// WMCreateDRMWriter:
//     Called to create DRM-enabled writer
//     Implementation linked in from WMSDKDRM.lib.
//
//
HRESULT STDMETHODCALLTYPE WMCreateDRMWriter(
                            /* [in] */  IUnknown*   pUnkDRM,
                            /* [out] */ IWMWriter** ppDRMWriter );




#endif  // _WMSDKDRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsecure.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 21 15:21:55 2000
 */
/* Compiler settings for .\wmsecure.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsecure_h__
#define __wmsecure_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMAuthorizer_FWD_DEFINED__
#define __IWMAuthorizer_FWD_DEFINED__
typedef interface IWMAuthorizer IWMAuthorizer;
#endif 	/* __IWMAuthorizer_FWD_DEFINED__ */


#ifndef __IWMSecureChannel_FWD_DEFINED__
#define __IWMSecureChannel_FWD_DEFINED__
typedef interface IWMSecureChannel IWMSecureChannel;
#endif 	/* __IWMSecureChannel_FWD_DEFINED__ */


#ifndef __IWMGetSecureChannel_FWD_DEFINED__
#define __IWMGetSecureChannel_FWD_DEFINED__
typedef interface IWMGetSecureChannel IWMGetSecureChannel;
#endif 	/* __IWMGetSecureChannel_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsecure_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
EXTERN_GUID( IID_IWMAuthorizer,     0xd9b67d36, 0xa9ad, 0x4eb4, 0xba, 0xef, 0xdb, 0x28, 0x4e, 0xf5, 0x50, 0x4c );
EXTERN_GUID( IID_IWMSecureChannel,  0x2720598a, 0xd0f2, 0x4189, 0xbd, 0x10, 0x91, 0xc4, 0x6e, 0xf0, 0x93, 0x6f );
EXTERN_GUID( IID_IWMGetSecureChannel, 0x94bc0598, 0xc3d2, 0x11d3, 0xbe, 0xdf, 0x00, 0xc0, 0x4f, 0x61, 0x29, 0x86 );


extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0000_v0_0_s_ifspec;

#ifndef __IWMAuthorizer_INTERFACE_DEFINED__
#define __IWMAuthorizer_INTERFACE_DEFINED__

/* interface IWMAuthorizer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMAuthorizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9B67D36-A9AD-4eb4-BAEF-DB284EF5504C")
    IWMAuthorizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCertCount( 
            /* [out] */ DWORD __RPC_FAR *pcCerts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCert( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharedData( 
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMAuthorizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMAuthorizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMAuthorizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertCount )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCerts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCert )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSharedData )( 
            IWMAuthorizer __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);
        
        END_INTERFACE
    } IWMAuthorizerVtbl;

    interface IWMAuthorizer
    {
        CONST_VTBL struct IWMAuthorizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMAuthorizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMAuthorizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMAuthorizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMAuthorizer_GetCertCount(This,pcCerts)	\
    (This)->lpVtbl -> GetCertCount(This,pcCerts)

#define IWMAuthorizer_GetCert(This,dwIndex,ppbCertData)	\
    (This)->lpVtbl -> GetCert(This,dwIndex,ppbCertData)

#define IWMAuthorizer_GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)	\
    (This)->lpVtbl -> GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetCertCount_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCerts);


void __RPC_STUB IWMAuthorizer_GetCertCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetCert_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);


void __RPC_STUB IWMAuthorizer_GetCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMAuthorizer_GetSharedData_Proxy( 
    IWMAuthorizer __RPC_FAR * This,
    /* [in] */ DWORD dwCertIndex,
    /* [in] */ const BYTE __RPC_FAR *pbSharedData,
    /* [in] */ BYTE __RPC_FAR *pbCert,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);


void __RPC_STUB IWMAuthorizer_GetSharedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMAuthorizer_INTERFACE_DEFINED__ */


#ifndef __IWMSecureChannel_INTERFACE_DEFINED__
#define __IWMSecureChannel_INTERFACE_DEFINED__

/* interface IWMSecureChannel */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMSecureChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2720598A-D0F2-4189-BD10-91C46EF0936F")
    IWMSecureChannel : public IWMAuthorizer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WMSC_AddCertificate( 
            /* [in] */ IWMAuthorizer __RPC_FAR *pCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_AddSignature( 
            /* [in] */ BYTE __RPC_FAR *pbCertSig,
            /* [in] */ DWORD cbCertSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Connect( 
            /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_IsConnected( 
            /* [out] */ BOOL __RPC_FAR *pfIsConnected) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_GetValidCertificate( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
            /* [out] */ DWORD __RPC_FAR *pdwSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Encrypt( 
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Decrypt( 
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Lock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_Unlock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WMSC_SetSharedData( 
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSecureChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSecureChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertCount )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCerts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCert )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSharedData )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData,
            /* [in] */ BYTE __RPC_FAR *pbCert,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbSharedData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_AddCertificate )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ IWMAuthorizer __RPC_FAR *pCert);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_AddSignature )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbCertSig,
            /* [in] */ DWORD cbCertSig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Connect )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_IsConnected )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsConnected);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Disconnect )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_GetValidCertificate )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
            /* [out] */ DWORD __RPC_FAR *pdwSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Encrypt )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Decrypt )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Lock )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_Unlock )( 
            IWMSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WMSC_SetSharedData )( 
            IWMSecureChannel __RPC_FAR * This,
            /* [in] */ DWORD dwCertIndex,
            /* [in] */ const BYTE __RPC_FAR *pbSharedData);
        
        END_INTERFACE
    } IWMSecureChannelVtbl;

    interface IWMSecureChannel
    {
        CONST_VTBL struct IWMSecureChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSecureChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSecureChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSecureChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSecureChannel_GetCertCount(This,pcCerts)	\
    (This)->lpVtbl -> GetCertCount(This,pcCerts)

#define IWMSecureChannel_GetCert(This,dwIndex,ppbCertData)	\
    (This)->lpVtbl -> GetCert(This,dwIndex,ppbCertData)

#define IWMSecureChannel_GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)	\
    (This)->lpVtbl -> GetSharedData(This,dwCertIndex,pbSharedData,pbCert,ppbSharedData)


#define IWMSecureChannel_WMSC_AddCertificate(This,pCert)	\
    (This)->lpVtbl -> WMSC_AddCertificate(This,pCert)

#define IWMSecureChannel_WMSC_AddSignature(This,pbCertSig,cbCertSig)	\
    (This)->lpVtbl -> WMSC_AddSignature(This,pbCertSig,cbCertSig)

#define IWMSecureChannel_WMSC_Connect(This,pOtherSide)	\
    (This)->lpVtbl -> WMSC_Connect(This,pOtherSide)

#define IWMSecureChannel_WMSC_IsConnected(This,pfIsConnected)	\
    (This)->lpVtbl -> WMSC_IsConnected(This,pfIsConnected)

#define IWMSecureChannel_WMSC_Disconnect(This)	\
    (This)->lpVtbl -> WMSC_Disconnect(This)

#define IWMSecureChannel_WMSC_GetValidCertificate(This,ppbCertificate,pdwSignature)	\
    (This)->lpVtbl -> WMSC_GetValidCertificate(This,ppbCertificate,pdwSignature)

#define IWMSecureChannel_WMSC_Encrypt(This,pbData,cbData)	\
    (This)->lpVtbl -> WMSC_Encrypt(This,pbData,cbData)

#define IWMSecureChannel_WMSC_Decrypt(This,pbData,cbData)	\
    (This)->lpVtbl -> WMSC_Decrypt(This,pbData,cbData)

#define IWMSecureChannel_WMSC_Lock(This)	\
    (This)->lpVtbl -> WMSC_Lock(This)

#define IWMSecureChannel_WMSC_Unlock(This)	\
    (This)->lpVtbl -> WMSC_Unlock(This)

#define IWMSecureChannel_WMSC_SetSharedData(This,dwCertIndex,pbSharedData)	\
    (This)->lpVtbl -> WMSC_SetSharedData(This,dwCertIndex,pbSharedData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_AddCertificate_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ IWMAuthorizer __RPC_FAR *pCert);


void __RPC_STUB IWMSecureChannel_WMSC_AddCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_AddSignature_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbCertSig,
    /* [in] */ DWORD cbCertSig);


void __RPC_STUB IWMSecureChannel_WMSC_AddSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Connect_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ IWMSecureChannel __RPC_FAR *pOtherSide);


void __RPC_STUB IWMSecureChannel_WMSC_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_IsConnected_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsConnected);


void __RPC_STUB IWMSecureChannel_WMSC_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Disconnect_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_GetValidCertificate_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppbCertificate,
    /* [out] */ DWORD __RPC_FAR *pdwSignature);


void __RPC_STUB IWMSecureChannel_WMSC_GetValidCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Encrypt_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IWMSecureChannel_WMSC_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Decrypt_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IWMSecureChannel_WMSC_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Lock_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_Unlock_Proxy( 
    IWMSecureChannel __RPC_FAR * This);


void __RPC_STUB IWMSecureChannel_WMSC_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSecureChannel_WMSC_SetSharedData_Proxy( 
    IWMSecureChannel __RPC_FAR * This,
    /* [in] */ DWORD dwCertIndex,
    /* [in] */ const BYTE __RPC_FAR *pbSharedData);


void __RPC_STUB IWMSecureChannel_WMSC_SetSharedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSecureChannel_INTERFACE_DEFINED__ */


#ifndef __IWMGetSecureChannel_INTERFACE_DEFINED__
#define __IWMGetSecureChannel_INTERFACE_DEFINED__

/* interface IWMGetSecureChannel */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMGetSecureChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94bc0598-c3d2-11d3-bedf-00c04f612986")
    IWMGetSecureChannel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPeerSecureChannelInterface( 
            /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMGetSecureChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMGetSecureChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMGetSecureChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMGetSecureChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPeerSecureChannelInterface )( 
            IWMGetSecureChannel __RPC_FAR * This,
            /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer);
        
        END_INTERFACE
    } IWMGetSecureChannelVtbl;

    interface IWMGetSecureChannel
    {
        CONST_VTBL struct IWMGetSecureChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMGetSecureChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMGetSecureChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMGetSecureChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMGetSecureChannel_GetPeerSecureChannelInterface(This,ppPeer)	\
    (This)->lpVtbl -> GetPeerSecureChannelInterface(This,ppPeer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMGetSecureChannel_GetPeerSecureChannelInterface_Proxy( 
    IWMGetSecureChannel __RPC_FAR * This,
    /* [out] */ IWMSecureChannel __RPC_FAR *__RPC_FAR *ppPeer);


void __RPC_STUB IWMGetSecureChannel_GetPeerSecureChannelInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMGetSecureChannel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsecure_0246 */
/* [local] */ 

HRESULT STDMETHODCALLTYPE WMCreateSecureChannel( IWMSecureChannel** ppChannel );


extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsecure_0246_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for NetShow events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
//  The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 0x000D0000L

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
//  The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 0x000D0001L

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
//  The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            0x000D0002L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum file bitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      0x800D0003L

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        0x800D0004L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                0xC00D0005L

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
//  Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               0xC00D0006L

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
//  Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          0xC00D0007L

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
//  Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           0xC00D0008L

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
//  Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           0xC00D0009L

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
//  Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            0xC00D000AL

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
//  There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          0xC00D000BL

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
//  There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    0xC00D000CL

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
//  Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                0xC00D000DL

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.%0
//
#define NS_E_NETWORK_BUSY                0xC00D000EL

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
//  The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               0xC00D000FL

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
//  The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           0xC00D0010L

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
//  Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               0xC00D0011L

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
//  There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           0xC00D0012L

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
//  There was no timely response from the server.%0
//
#define NS_E_TIMEOUT                     0xC00D0013L

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
//  Error writing to the network.%0
//
#define NS_E_NET_WRITE                   0xC00D0014L

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
//  Error reading from the network.%0
//
#define NS_E_NET_READ                    0xC00D0015L

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
//  Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  0xC00D0016L

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
//  Error reading from a disk.%0
//
#define NS_E_DISK_READ                   0xC00D0017L

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
//  Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  0xC00D0018L

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
//  Error reading from a file.%0
//
#define NS_E_FILE_READ                   0xC00D0019L

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              0xC00D001AL

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
//  The file already exists.%0
//
#define NS_E_FILE_EXISTS                 0xC00D001BL

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
//  The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                0xC00D001CL

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
//  Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            0xC00D001DL

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
//  Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      0xC00D001EL

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
//  Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            0xC00D001FL

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
//  Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            0xC00D0020L

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
//  Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         0xC00D0021L

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
//  An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     0xC00D0022L

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
//  Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 0xC00D0023L

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
//  An unknown error occurred.%0
//
#define NS_E_INTERNAL                    0xC00D0024L

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
//  The requested resource is in use.%0
//
#define NS_E_BUSY                        0xC00D0025L

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
//  The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    0xC00D0026L

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
//  The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     0xC00D0027L

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
//  An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    0xC00D0028L

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
//  The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          0xC00D0029L

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
//  The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    0xC00D002AL

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
//  The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             0xC00D002BL

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
//  There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      0xC00D002CL

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
//  The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              0xC00D002DL

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
//  An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              0xC00D002EL

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                0xC00D002FL

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        0xC00D0030L

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
//  The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             0xC00D0031L

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
//  The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            0xC00D0032L

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
//  There is no stream available.%0
//
#define NS_E_NO_STREAM                   0xC00D0033L

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
//  There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  0xC00D0034L

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            0xC00D0035L

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
//  The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              0xC00D0036L

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
//  The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           0xC00D0037L

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
//  The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       0xC00D0038L

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
//  The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         0xC00D0039L

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
//  The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           0xC00D003AL

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
//  The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             0xC00D003BL

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
//  The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              0xC00D003CL

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
//  The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             0xC00D003DL

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
//  The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    0xC00D003EL

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
//  The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              0xC00D003FL

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
//  The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   0xC00D0040L

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
//  The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         0xC00D0041L

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
//  The specified key is not valid.
//
#define NS_E_INVALID_KEY                 0xC00D0042L

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
//  The specified port is not valid.
//
#define NS_E_INVALID_PORT                0xC00D0043L

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
//  The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 0xC00D0044L

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
//  The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              0xC00D0045L

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
//  Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER 0xC00D0046L

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
//  Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 0xC00D0047L

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
//  Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               0xC00D0048L

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
//  Cannot exceed the maximum client limit.%0
//  
//
#define NS_E_MAX_CLIENTS                 0xC00D0049L

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
//  Log File Size too small.%0
//  
//
#define NS_E_LOG_FILE_SIZE               0xC00D004AL

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
//  Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                0xC00D004BL

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
//  Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              0xC00D004CL

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
//  The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               0xC00D004DL

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
//  There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                0xC00D004EL


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
//  The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 0x400D004FL

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
//  The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  0xC00D0050L


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
//  Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   0x400D0051L

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
//  Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 0x400D0052L

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
//  Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    0xC00D0053L


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  0x400D0054L

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   0xC00D0055L

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
//  Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        0x400D0056L

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
//  Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       0x400D0057L

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
//  Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        0x400D0058L


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               0x400D0059L

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  0x400D005AL

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   0x400D005BL

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    0x400D005CL

//
// MessageId: NS_I_KILL_VIEWER
//
// MessageText:
//
//  A NetShow administrator at network location %1 disconnected viewer %2 from the system.%0
//
#define NS_I_KILL_VIEWER                 0x400D005DL

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                0x400D005EL

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
//  Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               0x800D005FL


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
//  The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           0xC00D0060L

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
//  The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          0xC00D0061L

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
//  A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                0xC00D0062L

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
//  Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          0xC00D0063L

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
//  Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                0xC00D0064L

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
//  Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         0xC00D0065L

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
//  Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             0xC00D0066L

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
//  Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      0xC00D0067L

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
//  EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            0xC00D0068L


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
//  Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               0x400D0069L

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
//  The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        0xC00D006AL

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
//  No stream formats were found in an NSC file.%0
//
#define NS_E_NO_FORMATS                  0xC00D006BL

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
//  No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               0xC00D006CL

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
//  Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   0xC00D006DL

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
//  The logging operation failed.
//
#define NS_I_LOGGING_FAILED              0x400D006EL

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
//  Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         0xC00D006FL

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             0x400D0070L

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
//  No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   0xC00D0071L

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
//  No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         0xC00D0072L


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               0xC00D07F1L

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
//  Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                0xC00D07F2L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
//  Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              0xC00D00C8L

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
//  Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             0xC00D00C9L

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
//  Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           0xC00D00CAL

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
//  %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      0xC00D00CBL

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
//  The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            0xC00D00CCL

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
//  The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                0xC00D00CDL

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
//  Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           0xC00D00CEL

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
//  Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             0xC00D00CFL

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
//  Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         0xC00D00D0L

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
//  UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                0xC00D00D1L

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
//  TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                0xC00D00D2L

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
//  HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               0xC00D00D3L

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
//  The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             0xC00D00D4L

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
//  Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               0xC00D00D5L

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
//  The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          0xC00D00D6L

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
//  Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             0xC00D00D7L

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
//  You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 0xC00D00D8L


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which 
// takes an index value for the error message string.  For some application
// obtain the index value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
//  The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              0xC00D00D9L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               0xC00D0190L

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             0x400D0191L

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
//  Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 0xC00D0192L

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
//  Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              0x400D0193L

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
//  Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               0x400D0194L

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
//  Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 0xC00D0195L

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
//  Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           0x400D0196L

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
//  Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            0x400D0197L

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   0x400D0198L

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           0x800D0199L

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       0x800D019AL

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
//  Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           0xC00D019BL


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
//  The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        0xC00D0BB8L

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
//  The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       0xC00D0BB9L

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    0xC00D0BBAL

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
//  The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       0xC00D0BBBL

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
//  The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              0xC00D0BBCL

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           0xC00D0BBDL

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            0xC00D0BBEL

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
//  This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            0xC00D0BBFL

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
//  The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           0xC00D0BC0L

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
//  You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    0xC00D0BC1L

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   0xC00D0BC2L

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           0xC00D0BC3L

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   0xC00D0BC4L

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           0xC00D0BC5L

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
//  The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              0xC00D0BC6L

//
// MessageId: NS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
//  A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        0xC00D0BC7L

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
//  The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 0x000D0BC8L

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
//  The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           0x000D0BC9L

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
//  The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                0xC00D0BCAL

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
//  The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               0xC00D0BCBL

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
//  The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               0xC00D0BCCL

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        0xC00D0BCDL

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
//  Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       0xC00D0BCEL



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
//  There is no CD in the CD-ROM drive. Insert a CD, and try again.%0
//
#define NS_E_NO_CD                       0xC00D0FA0L

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
//  Unable to perform digital reads on this compact disc drive.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_CANT_READ_DIGITAL           0xC00D0FA1L

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try downloading the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         0xC00D0FA2L

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
//  Your Music Player does not support this song's format.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   0xC00D0FA3L

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
//  Digital reads on this compact disc drive are too slow.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_SLOW_READ_DIGITAL           0xC00D0FA4L

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
//  An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          0xC00D0FA5L

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
//  An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       0xC00D0FA6L

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
//  An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         0xC00D0FA7L

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
//  An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      0xC00D0FA8L

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
//  User has stopped the operation.%0
//
#define NS_E_USER_STOP                   0xC00D0FA9L

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file cannot be found.%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        0xC00D0FAAL

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
//  Windows Media Player cannot read the CD. It may contain flaws. Turn on error correction, and try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION 0xC00D0FABL

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
//  Windows Media Player cannot read the CD. Be sure the CD is free of dirt and scratches and the CD-ROM drive is functioning properly.%0
//
#define NS_E_CD_READ_ERROR               0xC00D0FACL

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
//  To speed up the copy process, do not play CD tracks while copying.%0
//
#define NS_E_CD_SLOW_COPY                0xC00D0FADL

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
//  Cannot copy directly from a CDROM to a CD drive.%0
//
#define NS_E_CD_COPYTO_CD                0xC00D0FAEL

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
//  Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              0xC00D0FAFL

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
//  Windows Media Player has detected that a setting for the CD-ROM drive will cause audio CDs to copy incorrectly; no audio is copied. Change the CD-ROM drive setting in Device Manager, and then try again.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING 0xC00D0FB0L

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
//  Trying to refresh the CD playlist.%0
//
#define NS_E_CD_REFRESH                  0xC00D0FB1L

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
//  Windows Media Player must switch to analog  mode  because there is a problem reading the CD-ROM drive in digital mode. Verify that the CD-ROM drive is installed correctly or try to update the drivers for the CD-ROM drive, and then try to use digital mode again.%0
//
#define NS_E_CD_DRIVER_PROBLEM           0xC00D0FB2L

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
//  Windows Media Player must switch to analog mode because there is a problem reading the CD-ROM drive  in digital mode.%0
//
#define NS_E_WONT_DO_DIGITAL             0xC00D0FB3L

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
//  A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              0xC00D0FB4L

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
//  The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            0xC00D0FB5L

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
//  A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           0xC00D0FB6L

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
//  A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    0xC00D0FB7L

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
//  A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           0xC00D0FB8L

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
//  Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             0xC00D0FB9L

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
//  A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       0xC00D0FC8L

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
//  Windows Media Player cannot copy the file. Either the license restricts copying, or you must obtain a license to copy the file.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   0xC00D0FC9L

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and try again.%0
//
#define NS_E_DEVICE_NOT_READY            0xC00D0FCAL

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
//  Windows Media Player cannot play the file because it is either damaged or corrupt.%0
//
#define NS_E_DAMAGED_FILE                0xC00D0FCBL

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
//  An error occurred when the Player was attempting to access information in your media library. Try closing and then reopening the Player.%0
//
#define NS_E_MPDB_GENERIC                0xC00D0FCCL

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
//  The file cannot be added to Media Library because it is smaller than the minimum-size requirement. Adjust the size requirements, and then try again.%0
//
#define NS_E_FILE_FAILED_CHECKS          0xC00D0FCDL

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
//  Windows Media Player could not create Media Library. Check with your system administrator to get the necessary permissions to create Media Library on your computer, and then try installing the Player again.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        0xC00D0FCEL

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
//  The file is already in use. Close other programs that may be using the file, or stop playing the file, and try again.%0
//
#define NS_E_SHARING_VIOLATION           0xC00D0FCFL

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
//  The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED 0xC00D0FDEL

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      0xC00D0FDFL

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
//  The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        0xC00D0FE0L

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
//  The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   0xC00D0FE1L

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
//  An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         0xC00D0FE2L

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
//  The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       0xC00D0FE3L

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
//  This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          0xC00D0FE4L

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
//  Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       0xC00D0FE5L

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
//  The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        0xC00D0FE6L

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
//  No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          0xC00D0FE7L

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  An upgrade may be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      0x000D0FE8L

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
//  An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               0x000D0FE9L

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
//  Windows Media Player cannot download the file. Check the path to the server, and then try again. For example, if you specified "mms://" in the file name, and the file was actually located on a path beginning with "http://" the file cannot be downloaded, even though it can be played.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       0xC00D0FEAL

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     0xC00D1004L

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
//  JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         0xC00D1005L

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
//  The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         0xC00D1009L

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
//  The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         0xC00D100AL

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     0xC00D100EL

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
//  The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   0xC00D100FL

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
//  The ZIP reader opened a file and its signature didn't match that of ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          0xC00D1018L

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
//  The ZIP reader has detected that the file is corrupt.%0
//
#define NS_E_WMPZIP_CORRUPT              0xC00D1019L

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
//  GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a filename that was not found in the zip file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         0xC00D101AL

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
//  Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED 0xC00D1022L

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
//  Image file may be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    0xC00D1023L

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file. GIF file may be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE 0xC00D1024L

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
//  Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      0xC00D1025L

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  0xC00D1026L

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    0xC00D1027L

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
//  Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       0xC00D1028L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
//  PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH 0xC00D1029L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION 0xC00D102AL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
//  Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  0xC00D102BL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
//  Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE 0xC00D102CL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
//  Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC 0xC00D102DL

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
//  Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     0xC00D102EL

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
//  Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED 0xC00D102FL

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
//  Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  0xC00D1030L

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
//  Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED 0xC00D1031L

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
//  Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      0xC00D1032L

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
//  JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL 0xC00D1033L

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      0xC00D1034L

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         0xC00D1035L

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  0xC00D1036L

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
//  Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       0xC00D1037L

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
//  JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     0xC00D1038L

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    0xC00D1039L

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
//  Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          0xC00D103AL

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
//  JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL 0xC00D103BL

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
//  JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       0xC00D103CL

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE 0xC00D103DL

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
//  Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     0xC00D103EL

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
//  Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      0xC00D103FL

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
//  Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        0x000D1040L

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
//  Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        0x000D1041L

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
//  Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        0x000D1042L

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
//  Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        0x000D1043L

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
//  Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            0xC00D1054L

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
//  A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       0xC00D1055L

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
//  A necessary WM SDK interface to complete the operation doesn't exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          0xC00D1056L

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Player could not download the codec.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   0xC00D1057L

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
//  Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       0xC00D1059L

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
//  An operation was attempted on a pin that doesn't exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             0xC00D105AL

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
//  Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   0xC00D105BL

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
//  The format of this file was not recognized as a valid playlist format.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT 0xC00D1068L

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
//  This file was believed to be an ASX playlist, but the format was not recognized.%0
//
#define NS_E_ASX_INVALIDFORMAT           0xC00D1069L

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
//  The version of this playlist is not supported. Click Details to go to the microsoft web site and see if there is a newer version of the player to install.%0
//
#define NS_E_ASX_INVALIDVERSION          0xC00D106AL

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
//  Format of a REPEAT loop within the current playlist file is invalid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    0xC00D106BL

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
//  Windows Media Player cannot export the playlist because it is empty.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        0xC00D106CL

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
//  Windows Media Player does not recognize this file as a supported playlist.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       0xC00D106DL

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST 0xC00D106EL

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
//  The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS 0xC00D106FL

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
//  Can not retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE 0xC00D1070L

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     0xC00D1071L

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
//  Items of the specified type can not be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       0xC00D1072L

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
//  The specified item can not be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         0xC00D1073L

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
//  Windows Media Player cannot find the file. Be sure the path is typed correctly. If it is, the file may not exist in the specified location, or the computer where the file is stored may be offline.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   0xC00D107CL

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
//  Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT 0xC00D107DL

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
//  Failed to get the marshalled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE 0xC00D107EL

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      0xC00D107FL

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
//  Current state of the player does not allow the operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         0xC00D1080L

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
//  Playlist manager does not understand the current play mode (shuffle, normal etc).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE 0xC00D1081L

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
//  The item is not in the playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   0xC00D1086L

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
//  There are no items in this playlist. Add items to the playlist, and try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       0xC00D1087L

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
//  The Web site cannot be accessed. A Web browser is not detected on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           0xC00D1088L

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL 0xC00D1089L

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
//  Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   0xC00D108AL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
//  Operation could not be performed because the playlist does not have more than one item.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA 0xC00D108BL

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
//  An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED 0xC00D108CL

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
//  The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE 0xC00D108DL

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
//  Failed launching WebHelp URL.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       0xC00D108EL

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
//  Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED 0xC00D108FL

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
//  No URL specified in the Ref attribute in playlist file.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     0xC00D1090L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY 0xC00D1091L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An invalid playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL 0xC00D1092L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY 0xC00D1093L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL 0xC00D1094L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY 0xC00D1095L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL 0xC00D1096L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY 0xC00D1097L

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
//  No entries found in the playlist file.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   0xC00D1098L

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
//  The codec downloaded for this media does not appear to be properly signed. Installation is not possible.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   0xC00D109AL

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     0xC00D109BL

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
//  Some of the codecs required by this media are not installed on your system. Since the option for automatic codec acquisition is disabled, no codecs will be downloaded.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED 0xC00D109CL

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
//  Failed to download the playlist file.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST 0xC00D109DL

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
//  Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST 0xC00D109EL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
//  Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE 0xC00D109FL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
//  No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED 0xC00D10A0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
//  Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND 0xC00D10A1L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
//  Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED 0xC00D10A2L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED 0xC00D10A3L

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
//  No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY 0xC00D10A4L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
//  Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME 0xC00D10A5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
//  A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT 0xC00D10A6L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
//  No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY 0xC00D10A7L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
//  No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY 0xC00D10A8L

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
//  The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE 0xC00D10A9L

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
//  Open was aborted by user.%0
//
#define NS_E_WMPCORE_USER_CANCEL         0xC00D10ABL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
//  No items were found inside the playlist repeat block.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY 0xC00D10ACL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE 0xC00D10ADL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE 0xC00D10AEL

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
//  Playlist URL supplied to the playlist manager is invalid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL 0xC00D10AFL

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
//  Player is selecting a runtime that is not valid for this media file type.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  0xC00D10B0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot import the playlist to Media Library because the playlist is empty.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS 0xC00D10B1L

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
//  An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION 0xC00D10B2L

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
//  Windows Media Player cannot play this file. Connect to the Internet or insert the removable media on which the file is located, and then try to play the file again.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   0xC00D10B3L

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
//  The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF 0xC00D10B4L

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
//  Windows Media Player cannot play any items in this playlist. For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST 0xC00D10B5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot play some or all of the playlist items.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS 0xC00D10B6L

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
//  Windows Media Player could not handle your request for digital media content in a timely manner. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                0xC00D10B7L

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
//  There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE 0xC00D10B8L

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
//  There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST 0xC00D10B9L

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play one or more files. Right-click the file, and then click Error Details to view information about the error.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      0xC00D10BAL

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
//  The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND 0xC00D10BBL

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
//  Windows Media Player cannot transfer media to the portable device without an update.  Please click details to find out how to update your device.%0
//
#define NS_E_WMDM_REVOKED                0xC00D10BCL

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
//  Windows Media Player cannot play the video stream because of a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               0xC00D10BDL

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
//  Windows Media Player failed to change the screen mode for fullscreen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  0xC00D10BEL

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
//  One or more items in the playlist cannot be played. For more details, right-click an item in the playlist, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    0xC00D10BFL

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
//  Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  0x000D10FEL

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
//  Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT 0x000D10FFL

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
//  Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING 0x000D1102L

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
//  Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING 0x000D1103L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
//  Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED 0x000D1104L

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
//  Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE 0x000D1105L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
//  Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED 0x000D1106L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
//  The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS 0x000D1107L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
//  The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA 0x000D1108L

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
//  The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING 0x000D1109L

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
//  Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           0xC00D1126L

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
//  User cancelled attempt to connect to the Internet.%0
//
#define NS_E_WMPIM_USERCANCELED          0xC00D1127L

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
//  Attempt to dial connection to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          0xC00D1128L

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
//  No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            0xC00D1130L

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
//  Backup of your licenses has been cancelled.  Please try again to ensure license backup.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          0xC00D1131L

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
//  The licenses were not restored because the restoration was cancelled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         0xC00D1132L

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
//  An error occurred during the backup or restore operation that requires a web page be displayed to the user.%0
//
#define NS_E_WMPBR_ERRORWITHURL          0xC00D1133L

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
//  The licenses were not backed up because the backup was cancelled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         0xC00D1134L

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
//  Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               0x000D1135L

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
//  Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        0x000D1136L

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
//  Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       0x000D1144L

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
//  Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            0x000D1145L

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
//  The requested application pane is performing an operation and will not be relased.%0
//
#define NS_S_OPERATION_PENDING           0x000D114EL

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
//  Windows Media Player cannot display subtitles or highlights in menus. Reinstall the DVD decoder or contact your device manufacturer to obtain an updated decoder, and then try again.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    0xC00D1162L

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with digital copyright protection.%0
//
#define NS_E_DVD_COPY_PROTECT            0xC00D1163L

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc is incompatible with the Player.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       0xC00D1164L

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     0xC00D1165L

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   0xC00D1166L

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with analog copyright protection.%0
//
#define NS_E_DVD_MACROVISION             0xC00D1167L

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   0xC00D1168L

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. To play the disc by using the Player, you must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     0xC00D1169L

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
//  Windows Media Player is currently unable to play DVD video. Close any open files and quit any other running programs, and then try again.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         0xC00D116AL

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
//  Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         0xC00D116BL

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Close any open files and quit any other running programs, and then try again. If the problem continues, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          0xC00D116CL

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              0xC00D116DL

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
//  Windows Media Player cannot play this DVD segment because the segment has a parental rating higher than the rating you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                0xC00D116EL

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
//  Windows Media Player cannot skip to the requested location in the DVD at this time.%0
//
#define NS_E_DVD_CANNOT_JUMP             0xC00D116FL

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try to play it again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       0xC00D1170L

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Double-click Display in Control Panel to lower your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         0xC00D1171L

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
//  A CD recorder (burner) was not detected. Connect a CD recorder, and try copying again.%0
//
#define NS_E_NO_CD_BURNER                0xC00D1176L

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
//  Windows Media Player does not detect any removable media in your portable device. Insert the media in the device or check the connection between the device and your computer, and then press F5 to refresh.%0
//
#define NS_E_DEVICE_IS_NOT_READY         0xC00D1177L

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the specified file. Your portable device does not support the specified format.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      0xC00D1178L

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
//  Windows Media Player cannot detect a connected portable device. Connect your portable device, and try again.%0
//
#define NS_E_NO_PDA                      0xC00D1179L

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
//  Windows Media Player could not open the specified URL. Be sure Windows Media Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        0xC00D1194L

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
//  Windows Media Player cannot open the file because there is not enough disk space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           0xC00D1195L

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
//  The user name or password is incorrect. Type your user name or password again.%0
//
#define NS_E_WMP_LOGON_FAILURE           0xC00D1196L

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        0xC00D1197L

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
//  Windows Media Player cannot connect to the server. The server name may be incorrect or the server is busy. Try again later.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     0xC00D1198L

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file is either corrupt or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      0xC00D1199L

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Internet security setting on your computer is set too high. Lower your browser's security setting, and then try again.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT 0xC00D119AL

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
//  Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         0xC00D119BL

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
//  Windows Media Player could not delete the playlist because it contains non-digital media files. Any digital media files in the playlist were deleted. Use Windows Explorer to delete non-digital media files, and then try deleting the playlist again.%0
//
#define NS_E_WMP_NONMEDIA_FILES          0xC00D119CL

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
//  Windows Media Player cannot play the selected playlist.  The format of the playlist is either invalid or is not recognized.%0
//
#define NS_E_WMP_INVALID_ASX             0xC00D119DL

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
//  Windows Media Player is already in use. Stop playing any content and close all Player dialog boxes and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          0xC00D119EL

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
//  Windows Media Player encountered an error when reading the CD-ROM drive in digital mode. You can try to use digital mode again, or you can switch the Player to analog mode.%0
//
#define NS_E_CD_NO_BUFFERS_READ          0xC00D11F8L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
//  The client is redirected to another server.%0
//
#define NS_E_REDIRECT                    0xC00D1388L

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
//  The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          0xC00D1389L


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
//  Attempt to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     0xC00D138AL

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
//  Unable to store a value in a namespace node of different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        0xC00D138BL

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
//  Unable to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     0xC00D138CL

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
//  Could not find the specified namespace node.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    0xC00D138DL

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  0xC00D138EL

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
//  Callback list on a namespace node is at maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS 0xC00D138FL

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
//  Attempt to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK 0xC00D1390L

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
//  Could not find callback in namespace when attempting to remove callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND 0xC00D1391L

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
//  The length of a namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     0xC00D1392L

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
//  Cannot create a namespace node which already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    0xC00D1393L

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
//  The name of a namespace node cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        0xC00D1394L

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
//  Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   0xC00D1395L

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
//  The name supplied for a namespace node is not valid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          0xC00D1396L


 // Cache Errors

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
//  Archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      0xC00D1397L

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND 0xC00D1398L

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
//  The specified origin server does not respond.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT 0xC00D1399L

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
//  The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         0xC00D139AL

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
//  The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      0xC00D139BL

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
//  The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          0xC00D139CL


// Object Model Errors

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy cannot be removed.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT 0xC00D139DL

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
//  Cannot remove last instance of plugin.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        0xC00D139EL

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE 0xC00D139FL

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
//  The Plugin does not support the specified Load Type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       0xC00D13A0L

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
//  The Plugin does not support any Load Types.  The Plugin must support at least one Load Type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION 0xC00D13A1L


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
//  The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING 0xC00D14B4L


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
//  The datapath does not have a sink.%0
//
#define NS_E_DATAPATH_NO_SINK            0xC00D1518L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
//  The Mark In time should be greater than 0 and less than Mark Out time.%0
//
#define NS_E_BAD_MARKIN                  0xC00D1B58L

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
//  The Mark Out time should be greater than Mark In time and less than file duration.%0
//
#define NS_E_BAD_MARKOUT                 0xC00D1B59L

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
//  No matching media source is found in source group %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      0xC00D1B5AL

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
//  Unsupported source type.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      0xC00D1B5BL

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
//  No more than 1 audio input is allowed.%0
//
#define NS_E_TOO_MANY_AUDIO              0xC00D1B5CL

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
//  No more than 2 video inputs are allowed.%0
//
#define NS_E_TOO_MANY_VIDEO              0xC00D1B5DL

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
//  No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          0xC00D1B5EL

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
//  The profile's media content doesn't match the media content defined in the source group.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     0xC00D1B5FL

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  Cannot remove an active source group from the source group collection while encoder is currently running.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP 0xC00D1B60L

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified audio capture device because it is in use right now.%0
//
#define NS_E_AUDIODEVICE_BUSY            0xC00D1B61L

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified audio capture device because unexpected error occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      0xC00D1B62L

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
//  Audio capture device doesn't support specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       0xC00D1B63L

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified video capture device because it is in use right now.%0
//
#define NS_E_VIDEODEVICE_BUSY            0xC00D1B64L

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified video capture device because unexpected error occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      0xC00D1B65L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
//  This operation is not allowed while encoder is running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING 0xC00D1B66L

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
//  No profile is set in source group.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   0xC00D1B67L

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
//  The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        0xC00D1B68L

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
//  The video input device could not be started.%0
//
#define NS_E_VIDCAPSTARTFAILED           0xC00D1B69L

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
//  The video input source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        0xC00D1B6AL

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
//  The video input source does not support the request capture size.%0
//
#define NS_E_VIDSOURCESIZE               0xC00D1B6BL

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
//  Unable to obtain output information from video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              0xC00D1B6CL

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
//  Unable to create video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          0xC00D1B6DL

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
//  There already is a running stream active on this video input device.%0
//
#define NS_E_VIDCAPDRVINUSE              0xC00D1B6EL

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
//  No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    0xC00D1B6FL

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
//  Cannot find valid output stream from source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      0xC00D1B70L

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
//  Cannot find valid source plugin to support specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      0xC00D1B71L

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  No source group is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       0xC00D1B72L

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
//  No script stream is set in current active source group.%0
//
#define NS_E_NO_SCRIPT_STREAM            0xC00D1B73L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
//  This operation is not allowed when file archival is started.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING 0xC00D1B74L

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
//  The MaxPacketSize value specified is invalid.%0
//
#define NS_E_INVALIDPACKETSIZE           0xC00D1B75L

//
// MessageId: NS_E_PLUGIN_CLSID_NOTINVALID
//
// MessageText:
//
//  The plugin CLSID specified is invalid.%0
//
#define NS_E_PLUGIN_CLSID_NOTINVALID     0xC00D1B76L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
//  This Archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     0xC00D1B77L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
//  This Archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION 0xC00D1B78L

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
//  The local archive filename was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     0xC00D1B79L

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
//  The SourceGroup is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     0xC00D1B7AL

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
//  Profiles on the sourcegroups do not match.%0
//
#define NS_E_PROFILE_MISMATCH            0xC00D1B7BL

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
//  The clip settings specified on the source are incorrect.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       0xC00D1B7CL

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
//  No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            0xC00D1B7DL

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
//  Encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                0xC00D1B7EL

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
//  This operation is not allowed while encoder is not running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED 0xC00D1B7FL

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
//  This SourceGroupCollection does not contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              0xC00D1B80L

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
//  Because this source group does not have a frame rate of 30 frames per second, you cannot use the inverse telecine feature.%0
//
#define NS_E_INVALIDINPUTFPS             0xC00D1B81L

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
//  Internal problems are preventing the preview or postview of your content.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         0xC00D1B82L

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
//  One or more codecs required to open this media could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           0xC00D1B83L

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
//  The output archive file specified is the same as an input source in one of the source groups.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       0xC00D1B84L

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
//  The input source has not been setup completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         0xC00D1B85L

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
//  Cannot apply time compression transform plug-in to a real time broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION 0xC00D1B86L

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
//  The Encoder was unable to open this device. Please see the system requirements for more information.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  0xC00D1B87L

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
//  Encoding cannot start because the display size or color setting has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS 0xC00D1B88L

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
//  No audio data has been received for multiple seconds.  Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                0xC00D1B89L

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
//  One or all of your specified input sources are not working properly. Make sure your input sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         0xC00D1B8AL

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
//  The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        0xC00D1B8BL

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used with real-time encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      0xC00D1B8CL

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used when source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        0xC00D1B8DL


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     0xC00D2711L

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     0xC00D2712L

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
//  Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      0xC00D2713L

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR 0xC00D2714L

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR 0xC00D2715L

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         0xC00D2716L

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  0xC00D2717L

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
//  The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         0xC00D2718L

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
//  Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         0xC00D2719L

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     0xC00D271BL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST 0xC00D271CL

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    0xC00D271DL

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
//  The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE 0xC00D271EL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED 0xC00D271FL

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
//  The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               0xC00D2720L

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_KEY_ERROR               0xC00D2721L

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           0xC00D2722L

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           0xC00D2723L

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     0xC00D2725L

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
//  Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        0x000D2726L

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
//  Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          0x000D2727L

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION 0xC00D2728L

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
//  The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      0xC00D272AL

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
//  You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       0xC00D272BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
//  You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         0xC00D272CL

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   0xC00D272FL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
//  A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT 0xC00D2730L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT 0xC00D2731L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT 0xC00D2732L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT 0xC00D2733L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT 0xC00D2734L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT 0xC00D2735L

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
//  The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     0xC00D2736L

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      0xC00D2737L

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     0xC00D2738L

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       0xC00D2739L

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             0xC00D273AL

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            0xC00D273BL

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR 0xC00D273CL

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR 0xC00D273DL

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           0xC00D273EL

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
//  The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER 0xC00D273FL

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         0xC00D2740L

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION 0xC00D2741L

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
//  Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           0xC00D2742L

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
//  One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          0xC00D2743L

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
//  You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      0xC00D2744L

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
//  Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       0x000D2746L

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
//  Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       0x000D2747L

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
//  The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        0xC00D2748L

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
//  A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        0xC00D2749L

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  0xC00D274AL

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
//  A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    0xC00D274BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
//  A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE 0xC00D274CL

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
//  Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     0xC00D274DL

//
// MessageId: NS_E_DRM_NEED_UPGRADE
//
// MessageText:
//
//  A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE            0xC00D274EL

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
//  Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          0xC00D274FL

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
//  Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  0xC00D2750L

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD 0xC00D2751L

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         0xC00D2752L

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
//  You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           0xC00D2753L

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
//  The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   0xC00D2754L

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
//  To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            0xC00D2755L

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
//  You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       0xC00D2756L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT 0xC00D2757L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT 0xC00D2758L

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
//  Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     0xC00D2759L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT 0xC00D275AL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT 0xC00D275BL

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        0xC00D275CL

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    0xC00D275DL

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      0xC00D275EL

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
//  Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      0xC00D275FL

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
//  The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID 0xC00D2760L

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            0xC00D2761L

//
// MessageId: NS_E_DRM_UNABLE_TO_CONTACT_SERVER
//
// MessageText:
//
//  Unable to contact the server for the requested operation.%0
//
#define NS_E_DRM_UNABLE_TO_CONTACT_SERVER 0xC00D2762L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT 0xC00D2763L

;// License Reasons Section
;// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
;// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
//  The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         0xC00D27D8L

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
//  The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      0xC00D27D9L

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       0xC00D27DAL

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
//  The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          0xC00D27DBL

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
//  Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        0xC00D27DCL

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
//  The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  0xC00D27DDL

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION 0x000D27DEL

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
//  The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    0xC00D27DFL

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          0xC00D27E0L

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
//  The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED 0xC00D27E1L

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           0xC00D280AL

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           0xC00D280BL

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
//  The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           0xC00D280CL

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  0xC00D280DL

;// End of License Reasons Section


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation is successful.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_S_REBOOT_RECOMMENDED          0x000D2AF8L

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  The system will not function correctly until the system is rebooted.%0
//
#define NS_S_REBOOT_REQUIRED             0x000D2AF9L

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation failed.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_E_REBOOT_RECOMMENDED          0xC00D2AFAL

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation failed.  The system will not function correctly until the system is rebooted.%0
//
#define NS_E_REBOOT_REQUIRED             0xC00D2AFBL


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
//  The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            0xC00D2EE0L

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
//  The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           0xC00D2EE1L

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
//  The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       0xC00D2EE2L

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
//  The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 0xC00D2EE3L

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
//  The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            0xC00D2EE4L

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
//  The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               0xC00D2EE5L

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          0xC00D2EE6L

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
//  The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           0xC00D2EE7L

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
//  The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         0xC00D2EE8L

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          0xC00D2EE9L

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
//  The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            0xC00D2EEAL

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      0xC00D2EEBL

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
//  The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    0xC00D2EECL

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
//  The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             0xC00D2EEDL

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
//  Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     0xC00D2EEEL

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          0xC00D2EEFL

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           0xC00D2EF0L

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
//  Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           0xC00D2EF1L


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\avisrc\avisrc.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

//
// prototype stream handler for avi files
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

extern const AMOVIESETUP_FILTER sudAVIDoc;

// forward declarations

class CAVIStream;       // owns a particular stream
class CAVIDocument;     // overall container class

#include <dynlink.h>	// implements dynamic linking

// worker thread object
class CAVIWorker : public CAMThread DYNLINKAVI
{

    CAVIStream * m_pPin;

    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart
		);

public:
    CAVIWorker();

    BOOL Create(CAVIStream * pStream);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};


//
// CAVIDocument represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
// supports (via nested implementations)
//  -- IBaseFilter
//  -- IMediaFilter
//  -- IFileSourceFilter
//

class CAVIDocument : public CUnknown, public CCritSec DYNLINKAVI
{

public:

    // constructors etc
    CAVIDocument(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVIDocument();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // pin enumerator calls this
    int GetPinCount() {
	return m_nStreams;
    };

    CBasePin * GetPin(int n);
    HRESULT FindPin(LPCWSTR Id, IPin **ppPin);
    int FindPinNumber(IPin *iPin);


public:


    /* Nested implementation classes */


    /* Implements the IBaseFilter and IMediaFilter interfaces */

    class CImplFilter : public CBaseFilter
    {

    private:

	CAVIDocument *m_pAVIDocument;

    public:

	CImplFilter(
	    TCHAR *pName,
	    CAVIDocument *pAVIDocument,
	    HRESULT *phr);

	~CImplFilter();

	// map getpin/getpincount for base enum of pins to owner
	int GetPinCount() {
	    return m_pAVIDocument->GetPinCount();
	};

	CBasePin * GetPin(int n) {
	    return m_pAVIDocument->GetPin(n);
	};

        STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin)
            {return m_pAVIDocument->FindPin(Id, ppPin);};

    };


    /* Implements the IFileSourceFilter interface */


    class CImplFileSourceFilter : public CUnknown,
			     public IFileSourceFilter DYNLINKAVI
    {

    private:

	CAVIDocument *m_pAVIDocument;
        LPOLESTR      m_pFileName;  // set by Load, used by GetCurFile

    public:

	CImplFileSourceFilter(
	    TCHAR *pName,
	    CAVIDocument *pAVIDocument,
	    HRESULT *phr);

	~CImplFileSourceFilter();

	DECLARE_IUNKNOWN

	/* Override this to say what interfaces we support and where */
	STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

	STDMETHODIMP Load(
			LPCOLESTR pszFileName,
			const AM_MEDIA_TYPE *pmt);

	/* Free any resources acquired by Load */
	STDMETHODIMP Unload();

	STDMETHODIMP GetCurFile(
			LPOLESTR * ppszFileName,
                        AM_MEDIA_TYPE *pmt);
    };

    /* End of nested interfaces */


// implementation details

private:

    /* Let the nested interfaces access our private state */

    friend class CImplFilter;
    friend class CImplFileSourceFilter;
    friend class CAVIStream;

    // stream's worker thread can get private state
    friend class CAVIWorker;

    CImplFilter        *m_pFilter;          /* IBaseFilter */
    CImplFileSourceFilter   *m_pFileSourceFilter;     /* IFileSourceFilter */

    CAVIStream ** m_paStreams;
    int m_nStreams;
    PAVIFILE m_pFile;

    void CloseFile(void);
};


// CAVIStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CAVIDocument object and
// returned via the EnumPins interface.
//

class CAVIStream : public CBaseOutputPin DYNLINKAVI
{

public:

    CAVIStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CAVIDocument * pDoc,
	PAVISTREAM pStream,
	AVISTREAMINFOW * pSI);

    ~CAVIStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    STDMETHODIMP QueryId(LPWSTR *Id);

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // where is the key frame preceding sample ?
    LONG StartFrom(LONG sample);

    // returns the sample number starting at or after time t
    LONG RefTimeToSample(CRefTime t);

    // returns the RefTime for s (media time)
    CRefTime SampleToRefTime(LONG s);

    // override to receive Notification messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        return m_dRate;
    }
    void SetRate(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        return m_tStopAt;
    }
    void SetStopAt(LONG sStopAt, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_Worker.m_WorkerLock);
        m_tStopAt = tStop;
        m_sStopAt = sStopAt;
    }


private:

    friend class CAVIWorker;

    PAVISTREAM m_pStream;
    CAVIWorker m_Worker;
    CAVIDocument * m_pDoc;

    LONG m_Start;       // stream start position from header
    LONG m_Length;      // stream duration from header

    // store the type/subtype classids
    FOURCCMap m_fccType;
    FOURCCMap m_fccSubtype;

    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;
    REFERENCE_TIME m_tStopAt;
    double m_dRate;

    // implementation of IMediaPosition
    class CImplPosition : public CSourcePosition, public CCritSec
    {
    protected:
	CAVIStream * m_pStream;
	HRESULT ChangeStart();
	HRESULT ChangeStop();
	HRESULT ChangeRate();
    public:
	CImplPosition(TCHAR*, CAVIStream*, HRESULT*);
	double Rate() {
	    return m_Rate;
	};
	CRefTime Start() {
	    return m_Start;
	};
	CRefTime Stop() {
	    return m_Stop;
	};
    };

    // stream header - passed in constructor
    AVISTREAMINFOW m_info;

    // It would be good to allocate a block of memory specific to
    // each stream rather than loading up ALL stream types with video
    // information.  However to save time these two LONGs can exist
    // in all stream types.
    LONG	m_lLastPaletteChange;
    LONG 	m_lNextPaletteChange;

    friend class CImplPosition;
    CImplPosition * m_pPosition;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsdkidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 24 07:28:46 2000
 */
/* Compiler settings for .\wmsdkidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsdkidl_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;






























////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 14;
static const WCHAR *g_wszWMDuration = L"Duration";
static const WCHAR *g_wszWMBitrate = L"Bitrate";
static const WCHAR *g_wszWMSeekable = L"Seekable";
static const WCHAR *g_wszWMStridable = L"Stridable";
static const WCHAR *g_wszWMBroadcast = L"Broadcast";
static const WCHAR *g_wszWMProtected = L"Is_Protected";
static const WCHAR *g_wszWMTrusted = L"Is_Trusted";
static const WCHAR *g_wszWMSignature_Name = L"Signature_Name";
static const WCHAR *g_wszWMHasAudio = L"HasAudio";
static const WCHAR *g_wszWMHasImage = L"HasImage";
static const WCHAR *g_wszWMHasScript = L"HasScript";
static const WCHAR *g_wszWMHasVideo = L"HasVideo";
static const WCHAR *g_wszWMCurrentBitrate = L"CurrentBitrate";
static const WCHAR *g_wszWMOptimalBitrate = L"OptimalBitrate";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR *g_wszWMTitle = L"Title";
static const WCHAR *g_wszWMAuthor = L"Author";
static const WCHAR *g_wszWMDescription = L"Description";
static const WCHAR *g_wszWMRating = L"Rating";
static const WCHAR *g_wszWMCopyright = L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to set DRM properties.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR *g_wszWMAlbumTitle = L"WM/AlbumTitle";
static const WCHAR *g_wszWMTrack = L"WM/Track";
static const WCHAR *g_wszWMPromotionURL = L"WM/PromotionURL";
static const WCHAR *g_wszWMAlbumCoverURL = L"WM/AlbumCoverURL";
static const WCHAR *g_wszWMGenre = L"WM/Genre";
static const WCHAR *g_wszWMYear = L"WM/Year";
static const WCHAR *g_wszWMGenreID = L"WM/GenreID";
static const WCHAR *g_wszWMMCDI = L"WM/MCDI";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR *g_wszWMBannerImageType = L"BannerImageType";
static const WCHAR *g_wszWMBannerImageData = L"BannerImageData";
static const WCHAR *g_wszWMBannerImageURL = L"BannerImageURL";
static const WCHAR *g_wszWMCopyrightURL = L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR *g_wszWMNSCName = L"NSC_Name";
static const WCHAR *g_wszWMNSCAddress = L"NSC_Address";
static const WCHAR *g_wszWMNSCPhone = L"NSC_Phone";
static const WCHAR *g_wszWMNSCEmail = L"NSC_Email";
static const WCHAR *g_wszWMNSCDescription = L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEarlyDataDelivery = L"EarlyDataDelivery";
static const WCHAR *g_wszJustInTimeDecode = L"JustInTimeDecode";
static const WCHAR *g_wszSingleOutputBuffer = L"SingleOutputBuffer";
static const WCHAR *g_wszSoftwareScaling = L"SoftwareScaling";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR *g_wszDeinterlaceMode = L"DeinterlaceMode";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2
    };

enum __MIDL___MIDL_itf_wmsdkidl_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2
    };
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33
    }	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    }	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    }	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    }	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    }	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000
    }	WMT_VERSION;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    }	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    }	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    }	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    }	WMT_CODEC_INFO_TYPE;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= HTTP_NOTINITIATED + 1,
	HTTP_REQUESTING	= HTTP_CONNECTING + 1,
	HTTP_RECEIVING	= HTTP_REQUESTING + 1,
	HTTP_COMPLETED	= HTTP_RECEIVING + 1
    }	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    }	DRM_INDIVIDUALIZATION_STATUS;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4
    };
typedef struct  _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    }	WM_WRITER_STATISTICS;

typedef struct  _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    }	WM_READER_STATISTICS;

typedef struct  _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR __RPC_FAR *wszLang;
    WCHAR __RPC_FAR *wszBrowserUserAgent;
    WCHAR __RPC_FAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM __RPC_FAR *pReserved;
    WCHAR __RPC_FAR *wszHostExe;
    QWORD qwHostVersion;
    }	WM_READER_CLIENTINFO;

typedef struct  _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    }	WM_INDIVIDUALIZE_STATUS;

typedef struct  _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR __RPC_FAR *wszURL;
    WCHAR __RPC_FAR *wszLocalFilename;
    BYTE __RPC_FAR *pbPostData;
    DWORD dwPostDataSize;
    }	WM_GET_LICENSE_DATA;

typedef struct  _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    }	WM_CLIENT_PROPERTIES;

typedef struct  _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    }	WM_PORT_NUMBER_RANGE;

typedef struct  _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown __RPC_FAR *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE __RPC_FAR *pbFormat;
    }	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Audio, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31            WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
    /* [out][in] */ DWORD __RPC_FAR *pcbType);


void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);


void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG __RPC_FAR *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD __RPC_FAR *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMVideoMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMVideoMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime)

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime)

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    (This)->lpVtbl -> GetQuality(This,pdwQuality)

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    (This)->lpVtbl -> SetQuality(This,dwQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pllTime);


void __RPC_STUB IWMVideoMediaProps_GetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ LONGLONG llTime);


void __RPC_STUB IWMVideoMediaProps_SetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwQuality);


void __RPC_STUB IWMVideoMediaProps_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ DWORD dwQuality);


void __RPC_STUB IWMVideoMediaProps_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD __RPC_FAR *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfileByID )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfile )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputFilename )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputCount )( 
            IWMWriter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormatCount )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormat )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMWriter __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    (This)->lpVtbl -> SetProfileByID(This,guidProfile)

#define IWMWriter_SetProfile(This,pProfile)	\
    (This)->lpVtbl -> SetProfile(This,pProfile)

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    (This)->lpVtbl -> SetOutputFilename(This,pwszFilename)

#define IWMWriter_GetInputCount(This,pcInputs)	\
    (This)->lpVtbl -> GetInputCount(This,pcInputs)

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput)

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput)

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats)

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)

#define IWMWriter_BeginWriting(This)	\
    (This)->lpVtbl -> BeginWriting(This)

#define IWMWriter_EndWriting(This)	\
    (This)->lpVtbl -> EndWriting(This)

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample)

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriter_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriter_SetProfileByID_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IWMWriter_SetProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetProfile_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pProfile);


void __RPC_STUB IWMWriter_SetProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetOutputFilename_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriter_SetOutputFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcInputs);


void __RPC_STUB IWMWriter_GetInputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);


void __RPC_STUB IWMWriter_GetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);


void __RPC_STUB IWMWriter_SetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormatCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriter_GetInputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormat_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IWMWriter_GetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_BeginWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_BeginWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_EndWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_EndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_AllocateSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwSampleSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);


void __RPC_STUB IWMWriter_AllocateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_WriteSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriter_WriteSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_Flush_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGroupName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMInputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMInputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMInputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetConnectionName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetGroupName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD __RPC_FAR *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputCount )( 
            IWMReader __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormatCount )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext)

#define IWMReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats)

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext)

#define IWMReader_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMReader_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMReader_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcOutputs);


void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroupName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMOutputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMOutputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName)

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy( 
    IWMStatusCallback __RPC_FAR * This,
    /* [in] */ WMT_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSample )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy( 
    IWMReaderCallback __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireCredentials )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCredentialCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCredentialCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCredentialCallback_AcquireCredentials_Proxy( 
    IWMCredentialCallback __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszRealm,
    /* [in] */ WCHAR __RPC_FAR *pwszSite,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
    /* [in] */ DWORD cchUser,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
    /* [in] */ DWORD cchPassword,
    /* [in] */ HRESULT hrStatus,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IWMCredentialCallback_AcquireCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy( 
    IWMMetadataEditor __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD __RPC_FAR *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD __RPC_FAR *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WORD __RPC_FAR *pcAttributes);


void __RPC_STUB IWMHeaderInfo_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByIndex_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByName_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_SetAttribute_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMHeaderInfo_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarkerCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcMarkers);


void __RPC_STUB IWMHeaderInfo_GetMarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
    /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_GetMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [in] */ QWORD cnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_AddMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScriptCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcScripts);


void __RPC_STUB IWMHeaderInfo_GetScriptCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszType,
    /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
    /* [out] */ WCHAR __RPC_FAR *pwszCommand,
    /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
    /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);


void __RPC_STUB IWMHeaderInfo_GetScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszType,
    /* [in] */ WCHAR __RPC_FAR *pwszCommand,
    /* [in] */ QWORD cnsScriptTime);


void __RPC_STUB IWMHeaderInfo_AddScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfo )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos)

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfoCount_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCodecInfos);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfo_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [in] */ DWORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pcchName,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchDescription,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
    /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
    /* [out] */ BYTE __RPC_FAR *pbCodecInfo);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD __RPC_FAR *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager_CreateEmptyProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ WMT_VERSION dwVersion,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_CreateEmptyProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByID_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByData_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_SaveProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
    /* [in] */ WCHAR __RPC_FAR *pwszProfile,
    /* [out][in] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMProfileManager_SaveProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_GetSystemProfileCount_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProfiles);


void __RPC_STUB IWMProfileManager_GetSystemProfileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadSystemProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ DWORD dwProfileIndex,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadSystemProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion)

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager2_GetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfileManager2_GetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager2_SetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION dwVersion);


void __RPC_STUB IWMProfileManager2_SetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR __RPC_FAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD __RPC_FAR *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile_GetVersion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfile_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszName);


void __RPC_STUB IWMProfile_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszDescription);


void __RPC_STUB IWMProfile_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMProfile_GetStreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwStreamIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMProfile_RemoveStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_ReconfigStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_ReconfigStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ REFGUID guidStreamType,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_CreateNewStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusionCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcME);


void __RPC_STUB IWMProfile_GetMutualExclusionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwMEIndex,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_GetMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_RemoveMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_AddMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_CreateNewMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID __RPC_FAR *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfileID )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile2_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile2_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile2_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile2_GetProfileID_Proxy( 
    IWMProfile2 __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidID);


void __RPC_STUB IWMProfile2_GetProfileID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID __RPC_FAR *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD __RPC_FAR *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR __RPC_FAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD __RPC_FAR *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamType )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamType_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidStreamType);


void __RPC_STUB IWMStreamConfig_GetStreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNum);


void __RPC_STUB IWMStreamConfig_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamConfig_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
    /* [out][in] */ WORD __RPC_FAR *pcchStreamName);


void __RPC_STUB IWMStreamConfig_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszStreamName);


void __RPC_STUB IWMStreamConfig_SetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszInputName,
    /* [out][in] */ WORD __RPC_FAR *pcchInputName);


void __RPC_STUB IWMStreamConfig_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszInputName);


void __RPC_STUB IWMStreamConfig_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBitrate);


void __RPC_STUB IWMStreamConfig_GetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD pdwBitrate);


void __RPC_STUB IWMStreamConfig_SetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);


void __RPC_STUB IWMStreamConfig_GetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMStreamConfig_SetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPacketSize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPacketSize __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize_GetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);


void __RPC_STUB IWMPacketSize_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize_SetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IWMPacketSize_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMStreamList __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMStreamList_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamList_GetStreams_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
    /* [out][in] */ WORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMStreamList_GetStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_AddStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_RemoveStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion_GetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMutualExclusion_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion_SetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMMutualExclusion_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD __RPC_FAR *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD __RPC_FAR *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSinkCount_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcSinks);


void __RPC_STUB IWMWriterAdvanced_GetSinkCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwSinkNum,
    /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);


void __RPC_STUB IWMWriterAdvanced_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_AddSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_AddSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_RemoveSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_RemoveSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_WriteStreamSample_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD msSampleSendTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriterAdvanced_WriteStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetLiveSource_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    BOOL fIsLiveSource);


void __RPC_STUB IWMWriterAdvanced_SetLiveSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_IsRealTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterAdvanced_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetWriterTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);


void __RPC_STUB IWMWriterAdvanced_GetWriterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetStatistics_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);


void __RPC_STUB IWMWriterAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD msWindow);


void __RPC_STUB IWMWriterAdvanced_SetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsWindow);


void __RPC_STUB IWMWriterAdvanced_GetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_GetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMWriterAdvanced2_GetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_SetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMWriterAdvanced2_SetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostViewSample )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForPostView )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostViewCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostViewCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_OnPostViewSample_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_OnPostViewSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_AllocateForPostView_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_AllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewCallback )( 
            IWMWriterPostView __RPC_FAR * This,
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormatCount )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormat )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext)

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput)

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput)

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats)

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate)

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewCallback_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    IWMWriterPostViewCallback __RPC_FAR *pCallback,
    void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostView_SetPostViewCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_SetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_GetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMWriterPostView_GetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ IWMMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMWriterPostView_SetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormatCount_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriterPostView_GetPostViewFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormat_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMWriterPostView_GetPostViewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMWriterPostView_SetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMWriterPostView_GetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer __RPC_FAR *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterSink_OnHeader_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pHeader);


void __RPC_STUB IWMWriterSink_OnHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_IsRealTime_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterSink_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_AllocateDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ DWORD cbDataUnit,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);


void __RPC_STUB IWMWriterSink_AllocateDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);


void __RPC_STUB IWMWriterSink_OnDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnEndWriting_Proxy( 
    IWMWriterSink __RPC_FAR * This);


void __RPC_STUB IWMWriterSink_OnEndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRegisterCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRegisterCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Advise(This,pCallback,pvContext)

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Unadvise(This,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Advise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Unadvise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink_Open_Proxy( 
    IWMWriterFileSink __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriterFileSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL __RPC_FAR *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD __RPC_FAR *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD __RPC_FAR *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL __RPC_FAR *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsStopped )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileDuration )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileSize )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClosed )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink2_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Start_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStartTime);


void __RPC_STUB IWMWriterFileSink2_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Stop_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStopTime);


void __RPC_STUB IWMWriterFileSink2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsStopped_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfStopped);


void __RPC_STUB IWMWriterFileSink2_IsStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileDuration_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsDuration);


void __RPC_STUB IWMWriterFileSink2_GetFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileSize_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcbFile);


void __RPC_STUB IWMWriterFileSink2_GetFileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Close_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This);


void __RPC_STUB IWMWriterFileSink2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsClosed_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfClosed);


void __RPC_STUB IWMWriterFileSink2_IsClosed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostURL )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterNetworkSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterNetworkSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients)

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients)

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    (This)->lpVtbl -> SetNetworkProtocol(This,protocol)

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol)

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL)

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    (This)->lpVtbl -> Open(This,pdwPortNum)

#define IWMWriterNetworkSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterNetworkSink_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ DWORD dwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_SetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_GetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ WMT_NET_PROTOCOL protocol);


void __RPC_STUB IWMWriterNetworkSink_SetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);


void __RPC_STUB IWMWriterNetworkSink_GetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetHostURL_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszURL,
    /* [out][in] */ DWORD __RPC_FAR *pcchURL);


void __RPC_STUB IWMWriterNetworkSink_GetHostURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Open_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);


void __RPC_STUB IWMWriterNetworkSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Disconnect_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Close_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD __RPC_FAR *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMClientConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMClientConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientCount )( 
            IWMClientConnections __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientProperties )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMClientConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMClientConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    (This)->lpVtbl -> GetClientCount(This,pcClients)

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientCount_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcClients);


void __RPC_STUB IWMClientConnections_GetClientCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientProperties_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [in] */ DWORD dwClientNum,
    /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);


void __RPC_STUB IWMClientConnections_GetClientProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL __RPC_FAR *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL __RPC_FAR *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced __RPC_FAR * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL __RPC_FAR *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
    /* [out] */ QWORD __RPC_FAR *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStreamEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutputEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TryOutputProps )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSample )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTime )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSelection )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStream )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutput )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD __RPC_FAR *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireLicense )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Individualize )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelIndividualization )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD __RPC_FAR *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [out][in] */ DWORD __RPC_FAR *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszHostName,
    /* [out][in] */ DWORD __RPC_FAR *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
    /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD __RPC_FAR *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD __RPC_FAR *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD __RPC_FAR *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KillTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD __RPC_FAR *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void __RPC_FAR *pvParam,
    /* [out] */ DWORD __RPC_FAR *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer __RPC_FAR * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer __RPC_FAR * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BackupLicenses )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseBackup )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup __RPC_FAR * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreLicenses )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseRestore )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore __RPC_FAR * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD __RPC_FAR *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByIndex )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByName )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllProps )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD __RPC_FAR *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD __RPC_FAR *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\avisrc\avisrc.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// AVIFile Source filter
//
// A Quartz source filter. We read avi files using the AVIFile apis, and
// push the data into streams. Supports IFileSourceFilter through which the
// filename is passed in. Exposes one pin per stream in the file. Creates one
// worker thread per connected pin. The worker thread pushes the data into
// the stream when active - it does not distinguish between running and paused
// mode.
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include <vfw.h>

#include "avisrc.h"

// setup data

const AMOVIESETUP_MEDIATYPE
sudAVIVidType = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
sudAVIAudType = { &MEDIATYPE_Audio      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudAVIDocPins[] = { { L"VideoOutput"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , TRUE                 // bZero
                     , TRUE                 // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L""                  // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIVidType }     // lpTypes
                   , { L"AudioOutput"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , TRUE                 // bZero
                     , TRUE                 // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L""                  // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIAudType } };  // lpTypes

const AMOVIESETUP_FILTER
sudAVIDoc = { &CLSID_AVIDoc            // clsID
            , L"AVI/WAV File Source"   // strName
            , MERIT_UNLIKELY           // dwMerit
            , 2                        // nPins
            , psudAVIDocPins };        // lpPin

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"AVI/WAV File Source"
    , &CLSID_AVIDoc
    , CAVIDocument::CreateInstance
    , NULL
    , &sudAVIDoc }
  ,
    { L""
    , &CLSID_AVIDocWriter
    , CAVIDocWrite::CreateInstance
    , NULL
    , NULL }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

/* Implements the CAVIDocument public member functions */


// constructors etc
CAVIDocument::CAVIDocument(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CUnknown(pName, pUnk),
      m_nStreams(0),
      m_paStreams(NULL),
      m_pFile(NULL)
{
    // need to do this before any avifile apis
    if (*phr == S_OK) {
        AVIFileInit();
        // should we check the return value?

        /* Create the interfaces we own */

        m_pFilter = new CImplFilter( NAME("Filter interfaces"), this, phr );
        if (m_pFilter == NULL) {
	    *phr = E_OUTOFMEMORY;
	    // no point in trying to create m_pFileSourceFilter, but we better null out
	    // the pointer to stop the destructor trying to free it
	    m_pFileSourceFilter = NULL;
	}
        else {
            m_pFileSourceFilter = new CImplFileSourceFilter( NAME("IFileSourceFilter interface"), this, phr );
            if (m_pFileSourceFilter == NULL) {
		delete m_pFilter;
		m_pFilter = NULL;
		*phr = E_OUTOFMEMORY;
            }
        }
    } else {
	m_pFilter = NULL;
	m_pFileSourceFilter = NULL;
    }

}

CAVIDocument::~CAVIDocument()
{
    CloseFile();

    /* Delete the interfaces we own */

    /* IBaseFilter */

    if (m_pFilter) {
	delete m_pFilter;
    }

    /* IFileSourceFilter */

    if (m_pFileSourceFilter) {
	delete m_pFileSourceFilter;
    }

    // need to do one of these for each AVIFileInit
    AVIFileExit();
}


// create a new instance of this class
CUnknown *
CAVIDocument::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CAVIDocument(NAME("AVI core document"), pUnk, phr);
}


// override this to say what interfaces we support where
STDMETHODIMP
CAVIDocument::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{

    /* See if we have the interface */
    /* try each of our interface supporting objects in turn */

    HRESULT hr;
    hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    if (SUCCEEDED(hr)) {
        return hr;	// ppv has been set appropriately
    }

    hr = m_pFilter->NonDelegatingQueryInterface(riid, ppv);
    if (SUCCEEDED(hr)) {
        return hr;	// ppv has been set appropriately
    }

    return m_pFileSourceFilter->NonDelegatingQueryInterface(riid, ppv);
}


// return a non-addrefed pointer to the CBasePin.
CBasePin *
CAVIDocument::GetPin(int n)
{
    if ((m_nStreams > 0) && (n < m_nStreams) && m_paStreams[n]) {
	return m_paStreams[n];
    }
    return NULL;
}

//
// FindPin
//
// Set *ppPin to the IPin* that has the id Id.
// or to NULL if the Id cannot be matched.
//
HRESULT CAVIDocument::FindPin(LPCWSTR pwszPinId, IPin **ppPin)
{
    WCHAR szBuf [8] ;

    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));

    int ii = WstrToInt(pwszPinId);    // in sdk\classes\base\util

    // validate that string passed is valid.

    IntToWstr(ii, szBuf);
    if (0 != lstrcmpW(pwszPinId, szBuf))
    {
        //  They don't match.
        *ppPin = NULL;
        return VFW_E_NOT_FOUND;
    }

    *ppPin = GetPin(ii);
    if (*ppPin!=NULL) {
        (*ppPin)->AddRef();
        return S_OK;
    } else {
        return VFW_E_NOT_FOUND;
    }
}

//
// FindPinNumber
//
// return the number of the pin with this IPin* or -1 if none
int CAVIDocument::FindPinNumber (IPin * pPin){
   for (int ii = 0; ii < m_nStreams; ++ii)
      {
      if ((IPin *)m_paStreams[ii] == pPin)
          return ii;
      }
   return -1;
}


//
// QueryId
//
// Set ppwsz to point to a QzTaskMemAlloc'd pin id
//
STDMETHODIMP CAVIStream::QueryId (
   LPWSTR *ppwsz)
{
    CheckPointer(ppwsz, E_POINTER);
    ValidateReadWritePtr(ppwsz, sizeof(LPWSTR));


    int ii = m_pDoc->FindPinNumber(this);
    ASSERT(ii>=0);

    *ppwsz = (LPWSTR)QzTaskMemAlloc(8);
    if (*ppwsz==NULL) return E_OUTOFMEMORY;

    IntToWstr(ii, *ppwsz);
    return NOERROR;
}



// close all references to a file opened by m_ImplFileSourceFilter::Load
// called when loading another file, and by destructor.
void
CAVIDocument::CloseFile(void)
{
    // ensure that all streams are inactive
    m_pFilter->Stop();

    if (m_paStreams) {
	for (int i = 0; i < m_nStreams; i++) {
	    if (m_paStreams[i]) {
		delete m_paStreams[i];
	    }
	}
	delete[] m_paStreams;
	m_paStreams = NULL;
	m_nStreams = 0;
    }

    if (m_pFile) {
	m_pFile->Release();
	m_pFile = NULL;
    }
}


/* Implements the CImplFilter class */


/* Constructor */

CAVIDocument::CImplFilter::CImplFilter(
    TCHAR *pName,
    CAVIDocument *pAVIDocument,
    HRESULT *phr)
    : CBaseFilter(pName, pAVIDocument->GetOwner(), pAVIDocument, CLSID_AVIDoc)
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFilter::CImplFilter")));
    m_pAVIDocument = pAVIDocument;
}

/* Destructor */

CAVIDocument::CImplFilter::~CImplFilter()
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFilter::~CImplFilter")));
}


/* Implements the CImplFileSourceFilter class */


/* Constructor */

CAVIDocument::CImplFileSourceFilter::CImplFileSourceFilter(
    TCHAR *pName,
    CAVIDocument *pAVIDocument,
    HRESULT *phr)
    : CUnknown(pName, pAVIDocument->GetOwner())
    , m_pFileName(NULL)
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFileSourceFilter::CImplFileSourceFilter")));
    m_pAVIDocument = pAVIDocument;
}

/* Destructor */

CAVIDocument::CImplFileSourceFilter::~CImplFileSourceFilter()
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDocument::CImplFileSourceFilter::~CImplFileSourceFilter")));
    Unload();
}

/* Override this to say what interfaces we support and where */

STDMETHODIMP CAVIDocument::CImplFileSourceFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    /* Do we have this interface */

    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::Unload()
{
    if (m_pFileName) {
	delete[] m_pFileName;
	m_pFileName = NULL;
    }
    return S_OK;
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::Load(
    LPCOLESTR pszFileName,
    const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(pszFileName, E_POINTER);

    // is there a file loaded at the moment ?

    ASSERT(m_pAVIDocument);
    if (m_pAVIDocument->m_pFile) {
	// get rid of it
	m_pAVIDocument->CloseFile();
    }

    // Remove previous name
    Unload();

    //
    // do the init of the file and streams within it
    //

    DbgLog((LOG_TRACE,1,TEXT("File name to load %ls"),pszFileName));
    DbgLog((LOG_TRACE,1,TEXT("Owning document %d and AVIFILE pointer %d"),
	   m_pAVIDocument,m_pAVIDocument->m_pFile));

    HRESULT hr = AVIFileOpenW(
		    &m_pAVIDocument->m_pFile,
		    pszFileName,
		    MMIO_READ | OF_SHARE_DENY_WRITE,
		    NULL);

    if (FAILED(hr)) {
	m_pAVIDocument->m_pFile = NULL;
	return hr;
    }

    // count the streams and create a stream object for each
    AVIFILEINFOW fi;
    m_pAVIDocument->m_pFile->Info(&fi, sizeof(fi));

    m_pAVIDocument->m_paStreams = new CAVIStream *[fi.dwStreams];
    if (NULL == m_pAVIDocument->m_paStreams) {
        return E_OUTOFMEMORY;
    }
    m_pAVIDocument->m_nStreams = fi.dwStreams;

    for (int i = 0; i < m_pAVIDocument->m_nStreams; i++) {
	PAVISTREAM ps;
	hr = m_pAVIDocument->m_pFile->GetStream(&ps, 0, i);

	if (!FAILED(hr)) {
	    AVISTREAMINFOW si;
	    ps->Info(&si, sizeof(si));

	    m_pAVIDocument->m_paStreams[i] =
		new CAVIStream(
			NAME("AVI stream"),     //TCHAR *pName,
			&hr,                    //HRESULT * phr,
			m_pAVIDocument,         //CAVIDocument *
			ps,                     //PAVISTREAM pStream,
			&si                     //stream info (incl. name)
		    );

	    if (FAILED(hr)) {
		delete m_pAVIDocument->m_paStreams[i];
		m_pAVIDocument->m_paStreams[i] = NULL;
	    }

	    // release our copy of this pointer. Pin will have addrefed if
	    // it wants to keep it
	    ps->Release();

	} else {
	    m_pAVIDocument->m_paStreams[i] = NULL;
	}
    }

    //
    // Record the file name for GetCurFile
    //
    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName!=NULL) {
        lstrcpyW(m_pFileName, pszFileName);
    }

    return NOERROR;
}

STDMETHODIMP
CAVIDocument::CImplFileSourceFilter::GetCurFile(
		LPOLESTR * ppszFileName,
                AM_MEDIA_TYPE *pmt)
{
    // return the current file name from avifile

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        } else {
            return E_OUTOFMEMORY;
        }
    }

    if (pmt) {
        ZeroMemory(pmt, sizeof(*pmt));
    }

    return NOERROR;
}


/* Implements the CAVIStream class */


CAVIStream::CAVIStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CAVIDocument * pDoc,
    PAVISTREAM pStream,
    AVISTREAMINFOW* pSI)
    : CBaseOutputPin(pObjectName, pDoc->m_pFilter, pDoc, phr, pSI->szName)
    , m_pPosition(0)
    , m_pDoc(pDoc)
    , m_pStream(pStream)
    , m_lLastPaletteChange(-1)
{
    m_pStream->AddRef();

    // read the info and set duration, start pos.
    // note that if all the streams in the movie are authored to start
    // at a time > 0, we will still play the movie from 0 and expect everyone
    // to enjoy the subsequent period of silence.
    m_info = *pSI;

    m_Start = m_info.dwStart;
    m_Length = m_info.dwLength;
    m_lNextPaletteChange = m_Length+1;
}

CAVIStream::~CAVIStream()
{
    if (m_pPosition) {
	delete m_pPosition;
    }

    m_pStream->Release();
}

STDMETHODIMP
CAVIStream::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
    if (riid == IID_IMediaPosition) {
	if (!m_pPosition) {
	    HRESULT hr = S_OK;
	    m_pPosition = new CImplPosition(NAME("avi stream CImplPosition"),
					    this,
					    &hr);
	    if (m_pPosition == NULL) {
		return E_OUTOFMEMORY;
	    }
	    if (FAILED(hr)) {
		delete m_pPosition;
		m_pPosition = NULL;
		return hr;
	    }
	}
	return m_pPosition->NonDelegatingQueryInterface(riid, pv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, pv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CAVIStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    m_fccType.SetFOURCC(m_info.fccType);
    pt->SetType(&m_fccType);
    if (m_info.fccType == streamtypeVIDEO) {

	pt->SetType(&MEDIATYPE_Video);
	m_fccSubtype.SetFOURCC(m_info.fccHandler);
	pt->SetSubtype(&m_fccSubtype);
        pt->SetFormatType(&FORMAT_VideoInfo);

    } else if (m_info.fccType == streamtypeAUDIO) {

	pt->SetType(&MEDIATYPE_Audio);
        pt->SetFormatType(&FORMAT_WaveFormatEx);
	// set subtype for audio ??
    }

    // set samplesize
    if (m_info.dwSampleSize) {
	pt->SetSampleSize(m_info.dwSampleSize);
    } else {
	pt->SetVariableSize();
    }

    // is this stream temporally compressed ?

    // if there are any non-key frames, then there is no temporal
    // compression. Unfortunately we can't search for non-key frames, so
    // we simply ask if each of the first N are key, and if any is not,
    // then we set the temporal compression flag. For now, N is 5.
    // If N is too big then we take forever to start up...

    // assume no temporal compression
    pt->SetTemporalCompression(FALSE);
    for (LONG n = 0; n < 5; n++) {


	LONG sNextKey = AVIStreamFindSample(
			    m_pStream,
			    n,
			    FIND_NEXT|FIND_KEY);

	if (sNextKey > n) {
	    // this sample is not key, therefore there is temporal compression
    	    pt->SetTemporalCompression(TRUE);
    	    break;
	}
    }


    long cb = 0;        // number of bytes this format requires
    BYTE *pF = NULL;    // pointer to memory containing format
    long offset = 0;    // offset into block to read format

    // find out the size of the format info

    HRESULT hr = m_pStream->ReadFormat(0, NULL, &cb);
    if (FAILED(hr)) {
	return hr;
    }

    long cbReal = cb;

    // map an AVIFILE video format into VIDEOINFOHEADER structures

    if (m_info.fccType == streamtypeVIDEO) {
	ASSERT(cb >= sizeof(BITMAPINFOHEADER));
	offset = SIZE_PREHEADER;
	cbReal += offset;
    }
    if (m_info.fccType == streamtypeAUDIO && cbReal < sizeof(WAVEFORMATEX)) {
        cbReal = sizeof(WAVEFORMATEX);
    }

    pF = new BYTE[cbReal];
    if (pF == NULL) {
	return E_OUTOFMEMORY;
    }
    ZeroMemory(pF,cbReal);		// slightly timeconsuming...

    // set the frame rate for video streams
    if (m_info.fccType == streamtypeVIDEO) {
	ASSERT(m_info.dwRate);
	// if the frame rate is 0 then we have a problem about to occur
        ((VIDEOINFOHEADER *)pF)->AvgTimePerFrame =
			(LONGLONG)m_info.dwScale * (LONGLONG)10000000 /
						(LONGLONG)m_info.dwRate;
    }

    // read the actual stream format
    // it would be quicker and more efficient to call
    // pt->AllocFormat and read the format directly into that buffer
    // rather than allocating our own, reading, and calling SetFormat
    // which will do a copy, remembering of course the offset at the
    // front of the buffer

    hr = m_pStream->ReadFormat(0,pF + offset,&cb);
    if (SUCCEEDED(hr)) {
	if (!pt->SetFormat(pF, cbReal)) {
	    hr = E_OUTOFMEMORY;
	}
	else
        if (m_info.fccType == streamtypeAUDIO) {
	    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pF;

	    pt->SetSubtype(&FOURCCMap(pwfx->wFormatTag));

	    if (0 == m_info.dwSuggestedBufferSize) {
		// Set up an approx 0.125 seconds of buffer with a
		// minimum of 4K
                m_info.dwSuggestedBufferSize = max(2048, pwfx->nAvgBytesPerSec/8);

		// N.B.: This has NOT set the number of buffers.
		// That will be decided later
	    }
        } else if (m_info.fccType == streamtypeVIDEO) {

	    GUID subtype = GetBitmapSubtype((BITMAPINFOHEADER *)(pF + offset));
	    pt->SetSubtype(&subtype);
	    if (m_info.dwFlags && AVISF_VIDEO_PALCHANGES) {
		m_lNextPaletteChange = AVIStreamFindSample(m_pStream, m_info.dwStart, FIND_NEXT | FIND_FORMAT);
		if (m_lNextPaletteChange == -1) {
                    m_lNextPaletteChange = m_info.dwLength+1;
		}
	    }

	} else {
	    DbgLog((LOG_ERROR, 1, "Unknown fcctype from AVIFILE %4hs", &m_info.fccType));
	}

    }

    delete[] pF;
    return hr;
}

// check if the pin can support this specific proposed type&format
HRESULT
CAVIStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CAVIStream::DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    if (m_info.fccType == streamtypeAUDIO)
	pProperties->cBuffers = 8;
    else
	pProperties->cBuffers = 4;

    ASSERT(m_info.dwSuggestedBufferSize > 0);
    // This assert is always hit when you open a wave file and it would
    // be nice if someone who understands it could fix it.
    // I'm leaving the assert in as a reminder to them.
    // To allow progress on other fronts in the meantime:

    if (m_info.dwSuggestedBufferSize <= 0)
        m_info.dwSuggestedBufferSize = 4096;

    pProperties->cbBuffer = m_info.dwSuggestedBufferSize;

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // buffers are too small - can't use this allocator
    if (Actual.cbBuffer < (long) m_info.dwSuggestedBufferSize) {
        // !!! need better error codes
	return E_INVALIDARG;
    }
    return NOERROR;
}


// returns the sample number showing at time t
LONG
CAVIStream::RefTimeToSample(CRefTime t)
{
    LONG s = AVIStreamTimeToSample(m_pStream, t.Millisecs());

    return s;
}

CRefTime
CAVIStream::SampleToRefTime(LONG s)
{
     CRefTime t(AVIStreamSampleToTime(m_pStream, s));
     return t;
}

LONG
CAVIStream::StartFrom(LONG sample)
{

    // if this stream has a start position offset then we cannot
    // ask for samples before that
    if (sample < m_Start) {
	return m_Start;
    }

    // we don't use the IsTemporalCompressed flag as we can't reliably
    // work it out.

    // if temporal compression, find prev key frame

    LONG s = AVIStreamFindSample(
	    m_pStream,
	    sample,
	    FIND_PREV | FIND_KEY);

    if (s < 0) {
	return sample;
    } else {
	return s;
    }
}


// this pin has gone active. Start the thread pushing
HRESULT
CAVIStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!m_Worker.ThreadExists()) {
	if (!m_Worker.Create(this)) {
	    return E_FAIL;
	}
    }

    return m_Worker.Run();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CAVIStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (m_Worker.ThreadExists()) {
	hr = m_Worker.Stop();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = m_Worker.Exit();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

STDMETHODIMP
CAVIStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}


/* ----- Implements the CAVIWorker class ------------------------------ */


CAVIWorker::CAVIWorker()
{
    m_pPin = NULL;
}

BOOL
CAVIWorker::Create(CAVIStream * pStream)
{
    CAutoLock lock(&m_AccessLock);

    if (m_pPin) {
	return FALSE;
    }
    m_pPin = pStream;
    return CAMThread::Create();
}


HRESULT
CAVIWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CAVIWorker::Stop()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CAVIWorker::Exit()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    m_pPin = NULL;
    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CAVIWorker::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CAVIWorker::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    if (m_pPin->m_pPosition) {
	CAutoLock lock(m_pPin->m_pPosition);

	tStart = m_pPin->m_pPosition->Start();
	tStopAt = m_pPin->m_pPosition->Stop();
	dRate = m_pPin->m_pPosition->Rate();

	// hold times in avifile sample format
	sStart = m_pPin->RefTimeToSample(tStart);
	sStopAt = m_pPin->RefTimeToSample(tStopAt);

    } else {
	// no-one has accessed the IMediaPosition - use known length
	sStart = 0;
	dRate = 1.0;

	// note that tStopAt is the time at which we stop, but
	// sStopAt is the last sample to send. So tStopAt is the end time
	// for sample sStopAt.
	sStopAt = m_pPin->m_Length - 1;
	tStart = 0;
	tStopAt = m_pPin->SampleToRefTime(m_pPin->m_Length);
    }


    // if the stream is temporally compressed, we need to start from
    // the previous key frame and play from there. All samples until the
    // actual start will be marked with negative times.
    // we send tStart as time 0, and start from tCurrent which may be
    // negative
    LONG sCurrent = m_pPin->StartFrom(sStart);

    while (TRUE) {

	ASSERT(m_pPin->m_pStream);

    	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	if (m_pPin->m_pPosition) {
	    CAutoLock lock(m_pPin->m_pPosition);

	    if (tStart != m_pPin->m_pPosition->Start()) {
		tStart = m_pPin->m_pPosition->Start();
		sStart = m_pPin->RefTimeToSample(tStart);
		sCurrent = m_pPin->StartFrom(sStart);
	    }

	    if (m_pPin->m_pPosition->Stop() != tStopAt) {
		tStopAt = m_pPin->m_pPosition->Stop();
		sStopAt = m_pPin->RefTimeToSample(tStopAt);
	    }
	    dRate = m_pPin->m_pPosition->Rate();
	}

	// check we are not going over the end
	sStopAt = min(sStopAt, m_pPin->m_Length-1);

        // set the variables checked by PushLoop - these can also be set
        // on the fly
        m_pPin->SetRate(dRate);
        m_pPin->SetStopAt(sStopAt, tStopAt);

	// tell AVIFile to start its streaming code
	AVIStreamBeginStreaming(
	    m_pPin->m_pStream,
	    sCurrent,
	    sStopAt,
	    1000);


	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart);
	if (S_OK == hr) {

	    // all done
	    // reached end of stream - notify downstream
	    m_pPin->DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
	        DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
	        m_pPin->m_pDoc->m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

	        m_pPin->DeliverEndOfStream();
	    } else {
	        DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }


    // end streaming
    AVIStreamEndStreaming(m_pPin->m_pStream);
    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CAVIWorker::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, m_pPin->GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    m_pPin->DeliverNewSegment(tStart, m_pPin->GetStopTime(), m_pPin->GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= m_pPin->GetStopAt()) {

	LONG sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	// Fake the time stamps, so DirectDraw can be used if we're connected
	// directly to the renderer (we must pass non-NULL numbers to
	// GetDeliveryBuffer).
	// We don't really know sCount yet, so we're basically guessing, but
	// we don't have a choice.. to get the same sCount as we're about to
	// calculate below, we need to have already called GetDeliveryBuffer!
	CRefTime tStartMe, tStopMe;
	IMediaSample * pSample;
	HRESULT hr;

        double dRate = m_pPin->GetRate();
        LONG sStop = m_pPin->GetStopAt();

	if (dRate) {
	    tStartMe = m_pPin->SampleToRefTime(sCurrent) - tStart;
	    if (m_pPin->m_mt.IsFixedSize())
	        sCount = (sStop+1) - sCurrent;  // real answer may be smaller
	    else
	        sCount = 1;

	    tStopMe = m_pPin->SampleToRefTime(sCurrent + sCount) - tStart;

	    if (dRate != 1.0) {
		tStartMe = LONGLONG( tStartMe.GetUnits() / dRate);
		tStopMe = LONGLONG( tStopMe.GetUnits() / dRate);
	    }

	    hr = m_pPin->GetDeliveryBuffer((IMediaSample **) &pSample,
                                           (REFERENCE_TIME *) &tStartMe,
                                           (REFERENCE_TIME *) &tStopMe,
                                           0);
	}
	else
	    hr = m_pPin->GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	if (m_pPin->m_mt.IsFixedSize()) {
	    // package all fixed size samples into one buffer,
	    // if they fit, except that key samples must
	    // be at the start of the buffer.

	    // allow one sample at sStopAt
	    sCount = (sStop+1) - sCurrent;

	    // how many fit ?
	    sCount = min(sCount, pSample->GetSize() / (LONG) m_pPin->m_mt.GetSampleSize());

	    if (m_pPin->m_mt.IsTemporalCompressed()) {

		// look for a sync point in a sample after the first one
		// and break before it
		LONG sNextKey = AVIStreamFindSample(
				    m_pPin->m_pStream,
				    sCurrent+1,
				    FIND_NEXT|FIND_KEY);
		if (sNextKey != -1) {
		    sCount = min(sCount, sNextKey - sCurrent);
		}
	    }
	} else {
	    // variable-size samples, therefore one per buffer
	    sCount = 1;
	}

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// mark as a sync point if the first sample is one
	if (AVIStreamFindSample(
		m_pPin->m_pStream,
		sCurrent,
		FIND_NEXT|FIND_KEY) == sCurrent) {
	    pSample->SetSyncPoint(TRUE);
	} else {
	    pSample->SetSyncPoint(FALSE);
	}

	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	PBYTE pbuf;
	hr = pSample->GetPointer(&pbuf);
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	    pSample->Release();
	    return E_OUTOFMEMORY;
	}

	LONG lBytes;

	hr = AVIStreamRead(
		    m_pPin->m_pStream,
		    sCurrent,
		    sCount,
		    pbuf,
		    pSample->GetSize(),
		    &lBytes,
		    &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("AVIStreamRead failed! hr=%lx"), hr));
	    pSample->Release();
	    return hr;
	}

	hr = pSample->SetActualDataLength(lBytes);
	ASSERT(SUCCEEDED(hr));

	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pPin->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pPin->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, m_pPin->GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
                         (REFERENCE_TIME *)&tThisEnd);

	// IF there are palette changes...

        if ((m_pPin->m_info.fccType == streamtypeVIDEO)
	   && (m_pPin->m_info.dwFlags & AVISF_VIDEO_PALCHANGES)) {

	    // if we are in the range of the current palette do nothing
	    if ((sCurrent < (m_pPin->m_lLastPaletteChange))
	      || (sCurrent >= (m_pPin->m_lNextPaletteChange)))
	    {
		HRESULT hr;
		VIDEOINFOHEADER* pFormat = (VIDEOINFOHEADER*)m_pPin->m_mt.Format();
		LONG offset = SIZE_PREHEADER;

		// Assert that the new format will fit into the old format
		LONG cb;
                hr = m_pPin->m_pStream->ReadFormat(sCurrent, NULL, &cb);
		if (!FAILED(hr)) {
		    LONG cbLength = (LONG)m_pPin->m_mt.FormatLength();
		    ASSERT(cb+offset <= cbLength);
		    // otherwise we had better reallocate the format buffer
		}

		hr = m_pPin->m_pStream->ReadFormat(sCurrent,&(pFormat->bmiHeader),&cb);
		ASSERT(hr == S_OK);	// should be as we only just checked above

		AM_MEDIA_TYPE mt;
		CopyMediaType( &mt, &(m_pPin->m_mt) );
		pSample->SetMediaType(&mt);
		FreeMediaType(mt);

		m_pPin->m_lLastPaletteChange = sCurrent;
		m_pPin->m_lNextPaletteChange = AVIStreamFindSample(m_pPin->m_pStream, sCurrent, FIND_NEXT | FIND_FORMAT);
		if (m_pPin->m_lNextPaletteChange == -1)
		    m_pPin->m_lNextPaletteChange = m_pPin->m_info.dwLength+1;
	    }
	}


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), lBytes));
	hr = m_pPin->Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.

	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    return S_OK;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CAVIStream::CImplPosition::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_pStream->m_Worker.m_AccessLock);

    if (m_pStream->m_Worker.ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	m_pStream->DeliverBeginFlush();

	// make sure we have stopped pushing
	m_pStream->m_Worker.Stop();

	// complete the flush
	m_pStream->DeliverEndFlush();

	// restart
	m_pStream->m_Worker.Run();
    }
    return S_OK;
}

HRESULT
CAVIStream::CImplPosition::ChangeRate()
{
    // changing the rate can be done on the fly

    m_pStream->SetRate(Rate());
    return S_OK;
}

HRESULT
CAVIStream::CImplPosition::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt = Stop();
    LONG sStopAt = m_pStream->RefTimeToSample(tStopAt);
    m_pStream->SetStopAt(sStopAt, tStopAt);

    return S_OK;

}

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)

CAVIStream::CImplPosition::CImplPosition(
    TCHAR* pName,
    CAVIStream* pStream,
    HRESULT* phr)
    : CSourcePosition(pName, pStream->GetOwner(), phr, (CCritSec*)this),
      m_pStream(pStream)
{
    m_Duration = (LONGLONG)m_pStream->SampleToRefTime(m_pStream->m_Length);
    m_Stop = m_Duration;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\asf\wmsdk\inc\wmsysprf.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:        wmsysprf.prx
//
//  Description: This file contains the GUIDs of the system profiles.
//
//============================================================================

///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\avisrc\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\capture.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


//
// implements Video capture using Win95 16 bit capture drivers
//

extern const AMOVIESETUP_FILTER sudVFWCapture ;

// forward declarations

class CCapStream;       // the filter's video stream output pin
class CCapOverlay;      // the filter's overlay preview pin
class CCapPreview;      // the filter's non-overlay preview pin
class CVfwCapture;      // the filter class

// this structure contains all settings of the capture
// filter that are user settable
//
typedef struct _vfwcaptureoptions {

   UINT  uVideoID;      // id of video driver to open
   DWORD dwTimeLimit;   // stop capturing at this time???

   DWORD dwTickScale;   // frame rate rational
   DWORD dwTickRate;    // frame rate = dwRate/dwScale in ticks/sec
   DWORD usPerFrame;	// frame rate expressed in microseconds per frame
   DWORD dwLatency;	// time added for latency, in 100ns units

   UINT  nMinBuffers;   // number of buffers to use for capture
   UINT  nMaxBuffers;   // number of buffers to use for capture

   UINT  cbFormat;      // sizeof VIDEOINFO stuff
   VIDEOINFOHEADER * pvi;     // pointer to VIDEOINFOHEADER (media type)

} VFWCAPTUREOPTIONS;

#define NUM_DROPPED 100				// remember 100 of them
typedef struct _capturestats {
    DWORDLONG dwlNumDropped;
    DWORDLONG dwlDropped[NUM_DROPPED];
    DWORDLONG dwlNumCaptured;
    DWORDLONG dwlTotalBytes;
    DWORDLONG msCaptureTime;
    double     flFrameRateAchieved;
    double     flDataRateAchieved;
} CAPTURESTATS;

#if 0 // -- moved to uuids.h

DEFINE_GUID(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F);

#endif

DEFINE_GUID(IID_VfwCaptureOptions,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x20);

DECLARE_INTERFACE_(IVfwCaptureOptions,IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IVfwCaptureOptions methods
   STDMETHOD(VfwCapSetOptions)(THIS_ const VFWCAPTUREOPTIONS * pOpt) PURE;
   STDMETHOD(VfwCapGetOptions)(THIS_ VFWCAPTUREOPTIONS * pOpt) PURE;
   STDMETHOD(VfwCapGetCaptureStats)(THIS_ CAPTURESTATS * pcs) PURE;
   STDMETHOD(VfwCapDriverDialog)(THIS_ HWND hwnd, UINT uDrvType, UINT uQuery) PURE;
};

#define STUPID_COMPILER_BUG

//
// CVfwCapture represents an video capture driver
//
//  -- IBaseFilter
//  -- IMediaFilter
//  -- ISpecifyPropertyPages
//  -- IVfwCaptureOptions
//

// UNTESTED code to make the h/w overlay pin support stream control
// (unnecessary since overlay is supposedly free)
// #define OVERLAY_SC


class CVfwCapture :
  public CBaseFilter,
  public IPersistPropertyBag,
  public IAMVfwCaptureDialogs,
  public CPersistStream,
  public IAMFilterMiscFlags
{
public:

   // constructors etc
   CVfwCapture(TCHAR *, LPUNKNOWN, HRESULT *);
   ~CVfwCapture();

   // create a new instance of this class
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   // override this to say what interfaces we support where
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

   DECLARE_IUNKNOWN

public:

   // IAMVfwCaptureDialogs stuff
   STDMETHODIMP HasDialog(int iDialog);
   STDMETHODIMP ShowDialog(int iDialog, HWND hwnd);
   STDMETHODIMP SendDriverMessage(int iDialog, int uMsg, long dw1, long dw2);

   // pin enumerator calls this
   //
   int GetPinCount();
   CBasePin * GetPin(int ix);

   // override RUN so that we can pass it on to the streams
   // (the base class just calls Active/Inactive for each stream)
   //
   STDMETHODIMP Run(REFERENCE_TIME tStart);

   // override PAUSE so that we can know when we transition from RUN->PAUSE
   //
   STDMETHODIMP Pause();

   // override STOP because the base class is broken
   //
   STDMETHODIMP Stop();

   // override GetState to return VFW_S_CANT_CUE when pausing
   //
   STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

   // for IAMStreamControl
   STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
   STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

   // IPersistPropertyBag methods
   STDMETHOD(InitNew)(THIS);
   STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
   STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

   STDMETHODIMP GetClassID(CLSID *pClsid);

   // CPersistStream
   HRESULT WriteToStream(IStream *pStream);
   HRESULT ReadFromStream(IStream *pStream);
   int SizeMax();
   // STDMETHODIMP GetClassID(CLSID *pClsid);

   // IAMFilterMiscFlags to indicate that we're a source (really a push source)
   ULONG STDMETHODCALLTYPE GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_SOURCE; }

   // ---------  Nested implementation classes ----------

   class CSpecifyProp : public CUnknown, public ISpecifyPropertyPages
   {
      CVfwCapture * m_pCap;           // parent CVfwCapture class

   public:
      // constructor
      //
      CSpecifyProp (CVfwCapture * pCap, HRESULT *phr) :
	 CUnknown(NAME("SpecifyPropertyPages"), pCap->GetOwner(), phr),
         m_pCap(pCap)
         {
         };

      DECLARE_IUNKNOWN

      // ISpecifyPropertyPages methods
      //
      STDMETHODIMP GetPages(CAUUID *pPages);
   };

   class COptions : public CUnknown, public IVfwCaptureOptions
   {
      CVfwCapture * m_pCap;           // parent CVfwCapture class

   public:
      // constructor
      //
      COptions (CVfwCapture * pCap, HRESULT *phr) :
	 CUnknown(NAME("Options"), pCap->GetOwner(), phr),
         m_pCap(pCap)
         {
         };

      DECLARE_IUNKNOWN

      // these interfaces allow property pages to get
      // and set the user editable settings for us
      //
      STDMETHODIMP VfwCapSetOptions(const VFWCAPTUREOPTIONS * pOpt);
      STDMETHODIMP VfwCapGetOptions(VFWCAPTUREOPTIONS * pOpt);
      STDMETHODIMP VfwCapGetCaptureStats(CAPTURESTATS * pcs);
      STDMETHODIMP VfwCapDriverDialog(HWND hwnd, UINT uType, UINT uQuery);

   };

   // -------- End of nested interfaces -------------


private:

   // Let the nested interfaces access our private state
   //
   friend class CCapStream;
   friend class CCapOverlay;
   friend class CCapPreview;
   friend class CCapOverlayNotify;
   friend class CPropPage;
   friend class CSpecifyProp;
   friend class COptions;

   // MikeCl - a way to avoid using overlay
   BOOL m_fAvoidOverlay;

   // device # of device to open
   int m_iVideoId;

   // persist stream saved from  IPersistPropertyBag::Load
   IPersistStream *m_pPersistStreamDevice;
    
   void CreatePins(HRESULT *phr);

   // property page stuff
   //
   CSpecifyProp    m_Specify;
   COptions        m_Options;

   BOOL		   m_fDialogUp;

   CCritSec        m_lock;
   CCapStream *    m_pStream;   // video data output pin
   CCapOverlay *   m_pOverlayPin; // overlay preview pin
   CCapPreview *   m_pPreviewPin; // non-overlay preview pin
   //CTimeStream * m_pTimeA;      // SMPTE timecode stream
};

#define ALIGNUP(dw,align) ((LONG_PTR)(((LONG_PTR)(dw)+(align)-1) / (align)) * (align))

class CFrameSample : public CMediaSample
{
public:
   CFrameSample(
       IMemAllocator *pAllocator,
       HRESULT *phr,
       LPTHKVIDEOHDR ptvh)
       :
       m_ptvh(ptvh),
       CMediaSample(NAME("Video Frame"),
                    (CBaseAllocator *)pAllocator,
                    phr,
                    ptvh->vh.lpData,
                    (long)ptvh->vh.dwBufferLength)
       {
       };

   LPTHKVIDEOHDR GetFrameHeader() {return m_ptvh;};

private:
   const LPTHKVIDEOHDR m_ptvh;
};

// CCapStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//

class CCapStream : public CBaseOutputPin, public IAMStreamConfig,
		   public IAMVideoCompression, public IAMDroppedFrames,
		   public IAMBufferNegotiation, public CBaseStreamControl,
		   public IKsPropertySet, public IAMPushSource
{
public:
   CCapStream(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        UINT iVideoId,
        HRESULT * phr,
        LPCWSTR pName);

    // ddraw stuff just so we can take the win16 lock
    LPDIRECTDRAWSURFACE m_pDrawPrimary; // DirectDraw primary surface
    IDirectDraw *m_pdd;         // ddraw object
    
   virtual ~CCapStream();

    DECLARE_IUNKNOWN

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt,
					LPBYTE pSCC);

    /* IAMVideoCompression methods */
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate) {return E_NOTIMPL;};
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality) {return E_NOTIMPL;};
    STDMETHODIMP get_Quality(double FAR* pQuality) {return E_NOTIMPL;};
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize) {return E_NOTIMPL;};
    STDMETHODIMP OverrideKeyFrame(long FrameNumber) {return E_NOTIMPL;};
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size)
			{return E_NOTIMPL;};
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);

    /* IAMBufferNegotiation methods */
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop);


    /* IAMDroppedFrames methods */
    STDMETHODIMP GetNumDropped(long FAR* plDropped);
    STDMETHODIMP GetNumNotDropped(long FAR* plNotDropped);
    STDMETHODIMP GetDroppedInfo(long lSize, long FAR* plArray,
			long FAR* plNumCopied);
    STDMETHODIMP GetAverageFrameSize(long FAR* plAverageSize);

    // IAMPushSource
    STDMETHODIMP GetPushSourceFlags( ULONG  *pFlags );
    STDMETHODIMP SetPushSourceFlags( ULONG   Flags );
    STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
    STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
    STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtOffset );

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   // expose our extra interfaces
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   // set the new mediatype to use
   HRESULT SetMediaType(const CMediaType*);

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties);

   // override this to force our own allocator
   HRESULT DecideAllocator(IMemInputPin *pPin,
                           IMemAllocator **ppAlloc);

   // Override to start & stop streaming
   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop
   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause

   // override to receive Notification messages
   STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

   class CAlloc : public CUnknown,
                  public IMemAllocator
      {
      private:
         CCapStream * m_pStream;     // parent stream

      protected:
         friend class CCapStream;
         ALLOCATOR_PROPERTIES parms;

      public:
          CAlloc(TCHAR *, CCapStream *, HRESULT *);
          ~CAlloc();

      DECLARE_IUNKNOWN

      STDMETHODIMP SetProperties(
  		    ALLOCATOR_PROPERTIES* pRequest,
  		    ALLOCATOR_PROPERTIES* pActual);

      // return the properties actually being used on this allocator
      STDMETHODIMP GetProperties(
  		    ALLOCATOR_PROPERTIES* pProps);

      // override Commit to allocate memory. We handle the GetBuffer
      //state changes
      STDMETHODIMP Commit();

      // override this to handle the memory freeing. We handle any outstanding
      // GetBuffer calls
      STDMETHODIMP Decommit();

      // get container for a sample. Blocking, synchronous call to get the
      // next free buffer (as represented by an IMediaSample interface).
      // on return, the time etc properties will be invalid, but the buffer
      // pointer and size will be correct. The two time parameters are
      // optional and either may be NULL, they may alternatively be set to
      // the start and end times the sample will have attached to it

      STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                             REFERENCE_TIME * pStartTime,
                             REFERENCE_TIME * pEndTime,
                             DWORD dwFlags);

      // final release of a CMediaSample will call this
      STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
      };

private:
    // methods for the helper thread
    //
    BOOL Create();
    BOOL Pause();
    BOOL Run();
    BOOL Stop();
    BOOL Destroy();

    static DWORD WINAPI ThreadProcInit(void *pv);
    DWORD ThreadProc();

    enum ThdState {TS_Not, TS_Create, TS_Init, TS_Pause, TS_Run, TS_Stop, TS_Destroy, TS_Exit};
    HANDLE   m_hThread;
    DWORD    m_tid;
    ThdState m_state;     // used to communicate state changes between worker thread and main
                          // Worker thread can make
                          //    Init->Pause, Stop->Destroy, Destroy->Exit transitions
                          // main thread(s) can make
                          //    Pause->Run, Pause->Stop, Run->Pause, Run->Stop transitions
                          // other transitions are invalid
   #ifdef DEBUG
    LPSTR StateName(ThdState state) {
       static char szState[] = "Not    \0Create \0Init   \0Pause  \0"
                               "Run    \0Stop   \0Destroy\0Exit   \0";
       if (state <= TS_Exit && state >= TS_Not)
          return szState + (int)state * 8;
       return "<Invalid>";
    };
   #endif

    void DumpState (ThdState state) ;

    ThdState ChangeState(ThdState state)
    {
        DumpState (state) ;
        return (ThdState) InterlockedExchange ((LONG *)&m_state, (LONG)state);
    } ;

    UINT *m_pBufferQueue; // what order we sent the buffers to the driver in
    UINT m_uiQueueHead;   // next buffer going to driver goes here
    UINT m_uiQueueTail;   // next buffer coming from driver is here

    HANDLE   m_hEvtPause; // Signalled when the worker is in the pause state
    HANDLE   m_hEvtRun;   // Signalled when the worker is in the run state

    BOOL ThreadExists() {return (m_hThread != NULL);};
    BOOL IsRunning() {return m_state == TS_Run;};

    // for IAMBufferNegotiation
    ALLOCATOR_PROPERTIES m_propSuggested;

    REFERENCE_TIME m_rtLatency;
    REFERENCE_TIME m_rtStreamOffset;
    REFERENCE_TIME m_rtMaxStreamOffset;

    // deal with user controllable options
    //
private:
    VFWCAPTUREOPTIONS m_user;
    HRESULT LoadOptions (void);
protected:
    CAPTURESTATS m_capstats;
public:
    HRESULT SetOptions(const VFWCAPTUREOPTIONS * pUser);
    HRESULT GetOptions(VFWCAPTUREOPTIONS * pUser);
    HRESULT DriverDialog(HWND hwnd, UINT uType, UINT uQuery);

    HRESULT Reconnect(BOOL fCapturePinToo);

private:

    // return the time of a given tick
    //
    REFERENCE_TIME TickToRefTime (DWORD nTick) {
       const DWORD dw100ns = 10 * 1000 * 1000;
       REFERENCE_TIME time =
          UInt32x32To64(dw100ns, m_user.dwTickScale)
          * nTick
          / m_user.dwTickRate;
       return time;
       };

    void ReduceScaleAndRate ();
    int ProfileInt(LPSTR pszKey, int iDefault);
    HRESULT ConnectToDriver (void);
    HRESULT DisconnectFromDriver (void);
    HRESULT InitPalette (void);
    HRESULT SendFormatToDriver(VIDEOINFOHEADER *);
    HRESULT GetFormatFromDriver (void);

    struct _cap_parms {
       // video driver stuff
       //
       HVIDEO         hVideoIn;     // video input
       HVIDEO         hVideoExtIn;  // external in (source control)
       HVIDEO         hVideoExtOut; // external out (overlay; not required)
       MMRESULT       mmr;          // open fail/success code
       BOOL           bHasOverlay;  // TRUE if ExtOut has overlay support

       // the preview buffer.  once created it persists until
       // the stream destructor because the renderer assumes
       // that it can keep a pointer to this and not crash
       // if it uses it after stopping the stream.
       // (no longer a problem)
       // !!! can we remove all this Preview still frame stuff?
       //
       UINT           cbVidHdr;       // size of a videohdr (or videohdrex)
       THKVIDEOHDR    tvhPreview;     // preview video header
       CFrameSample * pSamplePreview; // CMediaSample for preview buffer

       // video header & buffer stuff
       //
       UINT           cbBuffer;           // max size of video frame data
       UINT           nHeaders;           // number of video headers
       struct _cap_hdr {
          THKVIDEOHDR  tvh;
          } * paHdr;
       BOOL           fBuffersOnHardware; // TRUE if all video buffers are in hardware
       HANDLE         hEvtBufferDone;     // this event signalled when a buffer is ready
       DWORD_PTR      h0EvtBufferDone;    // on Win95 this is a Ring0 alias of the above event

       LONGLONG       tTick;              // duration of a single tick
       LONGLONG       llLastTick;	  // the last frame sent downstream
       DWORDLONG      dwlLastTimeCaptured;// the last driver time stamp
       DWORDLONG      dwlTimeCapturedOffset;// wraparound compensation
       UINT           uiLastAdded;	  // the last buffer AddBuffer'd
       DWORD	      dwFirstFrameOffset; // when 1st frame was captured
       LONGLONG       llFrameCountOffset; // add this to frame number
       BOOL	      fReRun;		  // went from Run->Pause->Run
       BOOL	      fLastSampleDiscarded; // due to IAMStreamControl
       CRefTime       rtThisFrameTime;  // clock time when frame was captured
       CRefTime	      rtLastStamp;	  // last frame delivered had this stamp
       CRefTime	      rtDriverStarted;	// when videoStreamStart was called
       CRefTime	      rtDriverLatency;  // how long it takes captured frame to
					// get noticed by ring 3

       } m_cs;

    // methods for capture loop
    //
    HRESULT Prepare();       // allocate resources in preparation for capture loop
    HRESULT FakePreview(BOOL); // fake a preview stream
    HRESULT Capture();       // capture loop. executes while in the run state
    HRESULT StillFrame();    // send still frame while in pause mode
    HRESULT Flush();         // flush any data in the pipe (while stopping).
    HRESULT Unprepare();     // free resources used by capture loop
    HRESULT SendFrame(LPTHKVIDEOHDR ptvh, BOOL bDiscon, BOOL bPreroll);
    BOOL    Committed() {return m_cs.paHdr != NULL;};
    HRESULT ReleaseFrame(LPTHKVIDEOHDR ptvh);

private:
   friend class CAlloc;
   friend class CVfwCapture::COptions;
   friend class CVfwCapture;
   friend class CCapOverlay;
   friend class CCapPreview;
   friend class CCapOverlayNotify;
   CAlloc        m_Alloc; // allocator
   CVfwCapture * m_pCap;  // parent
   CMediaType  * m_pmt;   // media type for this pin

#ifdef PERF
    int m_perfWhyDropped;
#endif // PERF

   CCritSec m_ReleaseLock;
};


// CCapOverlayNotify
// where the video renderer informs us of window moves/clips so we can fix
// the overlay
//
class CCapOverlayNotify : public CUnknown, public IOverlayNotify
{
    public:
        /* Constructor and destructor */
        CCapOverlayNotify(TCHAR              *pName,
                       CVfwCapture	  *pFilter,
                       LPUNKNOWN           pUnk,
                       HRESULT            *phr);
        ~CCapOverlayNotify();

        /* Unknown methods */

        DECLARE_IUNKNOWN

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        STDMETHODIMP_(ULONG) NonDelegatingRelease();
        STDMETHODIMP_(ULONG) NonDelegatingAddRef();

        /* IOverlayNotify methods */

        STDMETHODIMP OnColorKeyChange(
            const COLORKEY *pColorKey);         // Defines new colour key

        STDMETHODIMP OnClipChange(
            const RECT *pSourceRect,            // Area of video to play
            const RECT *pDestinationRect,       // Area of video to play
            const RGNDATA *pRegionData);        // Header describing clipping

        STDMETHODIMP OnPaletteChange(
            DWORD dwColors,                     // Number of colours present
            const PALETTEENTRY *pPalette);      // Array of palette colours

        STDMETHODIMP OnPositionChange(
            const RECT *pSourceRect,            // Area of video to play with
            const RECT *pDestinationRect);      // Area video goes

    private:
        CVfwCapture *m_pFilter;

} ;


// CCapOverlay
// represents the overlay output pin that connects to the renderer
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//
class CCapOverlay : public CBaseOutputPin, public IKsPropertySet
#ifdef OVERLAY_SC
					, public CBaseStreamControl
#endif
{
public:
   CCapOverlay(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

   virtual ~CCapOverlay();

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   // override this to not do anything with allocators
   HRESULT DecideAllocator(IMemInputPin *pPin,
                           IMemAllocator **ppAlloc);

   // override these to use IOverlay, not IMemInputPin
   STDMETHODIMP Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
   HRESULT BreakConnect();
   HRESULT CheckConnect(IPin *pPin);

   DECLARE_IUNKNOWN

   // expose our extra interfaces
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

#ifdef OVERLAY_SC

   STDMETHODIMP StopAt(const REFERENCE_TIME * ptStop, BOOL bBlockData, BOOL bSendExtra, DWORD dwCookie);
   STDMETHODIMP StartAt(const REFERENCE_TIME * ptStart, DWORD dwCookie);
#endif

   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop
   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties)
   {
	return NOERROR;
   };

private:
   CVfwCapture * m_pCap;     // parent
   IOverlay    * m_pOverlay; // Overlay window on output pin
   CCapOverlayNotify m_OverlayNotify; // Notify object
   BOOL         m_bAdvise;   // Advise id
   BOOL		m_fRunning;  // am I running?
#ifdef OVERLAY_SC
   HANDLE   	m_hThread;   // thread for IAMStreamControl
   DWORD    	m_tid;
   CAMEvent     m_EventAdvise;
   DWORD_PTR    m_dwAdvise;
   REFERENCE_TIME m_rtStart, m_rtEnd;	// for IAMStreamControl
   BOOL		m_fHaveThread;
   DWORD	m_dwCookieStart, m_dwCookieStop;

   static DWORD WINAPI ThreadProcInit(void *pv);
   DWORD ThreadProc();
#endif

   friend class CVfwCapture;
   friend class CCapOverlayNotify;
};


// CCapPreview
// represents the non-overlay preview pin that connects to the renderer
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CVfwCapture object and
// returned via the EnumPins interface.
//
class CCapPreview : public CBaseOutputPin, public CBaseStreamControl,
		    public IKsPropertySet, public IAMPushSource
{
public:
   CCapPreview(
        TCHAR *pObjectName,
        CVfwCapture *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

   virtual ~CCapPreview();

   DECLARE_IUNKNOWN

    /* IKsPropertySet stuff */
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

   // override this to say what interfaces we support where
   STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

   HRESULT GetMediaType(int iPosition, CMediaType* pt);

   // check if the pin can support this specific proposed type&format
   HRESULT CheckMediaType(const CMediaType*);

   HRESULT ActiveRun(REFERENCE_TIME tStart);	// Pause-->Run
   HRESULT ActivePause();	// Run-->Pause
   HRESULT Active();		// Stop-->Pause
   HRESULT Inactive();		// Pause-->Stop

   STDMETHODIMP Notify(IBaseFilter *pFilter, Quality q);

   // say how big our buffers should be and how many we want
   HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                            ALLOCATOR_PROPERTIES *pProperties);

   // IAMPushSource
   STDMETHODIMP GetPushSourceFlags( ULONG *pFlags );
   STDMETHODIMP SetPushSourceFlags( ULONG  Flags  );
   STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
   STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
   STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
   STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset );
   STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtOffset );

private:
   static DWORD WINAPI ThreadProcInit(void *pv);
   DWORD ThreadProc();
   HRESULT CapturePinActive(BOOL fActive);
   HRESULT ReceivePreviewFrame(IMediaSample * lpPrevSample, int iSize);
   HRESULT CopyPreviewFrame(LPVOID lpOutputBuffer);

   CVfwCapture * m_pCap;  // parent
   BOOL		m_fActuallyRunning; // is this filter is running state?
   BOOL		m_fThinkImRunning; // does the preview thread realize that?
   REFERENCE_TIME m_rtRun;
   HANDLE	m_hThread;
   DWORD	m_tid;
   HANDLE	m_hEventRun;
   HANDLE	m_hEventStop;
   HANDLE	m_hEventFrameValid;
   HANDLE	m_hEventActiveChanged;
   CAMEvent     m_EventAdvise;
   DWORD_PTR    m_dwAdvise;
   BOOL		m_fCapturing;	// is the streaming pin active?
   IMediaSample* m_pPreviewSample;
   int		m_iFrameSize;
   BOOL		m_fFrameValid;
   BOOL		m_fLastSampleDiscarded;	// for IAMStreamControl

   COutputQueue *m_pOutputQueue;

   REFERENCE_TIME m_rtLatency;
   REFERENCE_TIME m_rtStreamOffset;
   REFERENCE_TIME m_rtMaxStreamOffset;
   LONG m_cPreviewBuffers;

   friend class CVfwCapture;
   friend class CCapStream;
};


// this helper function creates an output pin for streaming video.
//
CCapStream * CreateStreamPin (
   CVfwCapture * pCapture,
   UINT          iVideoId,
   HRESULT    *  phr);

// this helper function creates an output pin for overlay
//
CCapOverlay * CreateOverlayPin (
   CVfwCapture * pCapture,
   HRESULT    *  phr);

// this helper function creates an output pin for non-overlay preview
//
CCapPreview * CreatePreviewPin (
   CVfwCapture * pCapture,
   HRESULT    *  phr);

// property page class to show properties of
// and object that exposes IVfwCaptureOptions
//
class CPropPage : public CBasePropertyPage
{
   IVfwCaptureOptions * m_pOpt;    // object that we are showing options from
   IPin *m_pPin;

public:

   CPropPage(TCHAR *, LPUNKNOWN, HRESULT *);

   // create a new instance of this class
   //
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\common.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#define MIN_VIDEO_BUFFERS  1		// changing this will change vidx16.dll

#define MAX_VIDEO_BUFFERS  64		// by default, as much as possible
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\driver.h ===
// Copyright (c) Microsoft Corporation 1996. All Rights Reserved

#include <mmreg.h>
#include <olectl.h>

#include "ivideo32.h" // videoXXX api's
//#include "mmdebug.h"  // JMK's debug macros
#include "capture.h"  // Filter
#include "resource.h" // dlg resource ID's (for property page)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\avisrc\shwrite.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


//
// prototype stream handler for avi files
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//


// forward declarations

class CAVIWrite;       // owns a particular stream
class CAVIDocWrite;     // overall container class

#include <dynlink.h>

//
// CAVIDocWrite represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
// supports (via nested implementations)
//  -- IBaseFilter
//  -- IMediaFilter
//  -- IFileSinkFilter
//

class CAVIDocWrite : public CUnknown, public CCritSec  DYNLINKAVI
{

public:

    // constructors etc
    CAVIDocWrite(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVIDocWrite();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // pin enumerator calls this
    int GetPinCount() {
        return m_nStreams;
    };

    CBasePin * GetPin(int n);
    HRESULT FindPin(LPCWSTR pwszPinId, IPin **ppPin);
    int FindPinNumber(IPin *iPin);

public:


    /* Nested implementation classes */


    /* Implements the IBaseFilter and IMediaFilter interfaces */

    class CImplFilter : public CBaseFilter
    {

    private:

        CAVIDocWrite *m_pAVIDocWrite;

    public:

        CImplFilter(
            TCHAR *pName,
            CAVIDocWrite *pAVIDocWrite,
            HRESULT *phr);

        ~CImplFilter();

        // map getpin/getpincount for base enum of pins to owner
        int GetPinCount() {
            return m_pAVIDocWrite->GetPinCount();
        };

        CBasePin * GetPin(int n) {
            return m_pAVIDocWrite->GetPin(n);
        };
        STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin)
            {return m_pAVIDocWrite->FindPin(Id, ppPin);};
    };


    /* Implements the IFileSinkFilter interface */


    class CImplFileSinkFilter : public CUnknown,
                             public IFileSinkFilter   DYNLINKAVI
    {

    private:

        CAVIDocWrite *m_pAVIDocWrite;

    public:

        CImplFileSinkFilter(
            TCHAR *pName,
            CAVIDocWrite *pAVIDocWrite,
            HRESULT *phr);

        ~CImplFileSinkFilter();

        DECLARE_IUNKNOWN

        /* Override this to say what interfaces we support and where */
        STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

        STDMETHODIMP SetFileName(
                        LPCOLESTR pszFileName,
                        const AM_MEDIA_TYPE *pmt);

        STDMETHODIMP GetCurFile(
                        LPOLESTR * ppszFileName,
                        AM_MEDIA_TYPE *pmt);
    };

// implementation details

private:

    /* Let the nested interfaces access our private state */

    friend class CImplFilter;
    friend class CImplFileSinkFilter;
    friend class CAVIWrite;

    CImplFilter        *m_pFilter;          /* IBaseFilter */
    CImplFileSinkFilter   *m_pFileSinkFilter;     /* IFileSinkFilter */

    CAVIWrite ** m_paStreams;
    int m_nStreams;
    PAVIFILE m_pFile;
    LPOLESTR m_pFileName;  // set by SetFileName, used by GetCurFile

    void CloseFile(void);
};


// CAVIWrite
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CAVIDocWrite object and
// returned via the EnumPins interface.
//

class CAVIWrite : public CBaseInputPin    DYNLINKAVI
{

public:

    CAVIWrite(
        TCHAR *pObjectName,
        HRESULT * phr,
        CAVIDocWrite * pDoc,
        LPCWSTR pPinName);

    ~CAVIWrite();

    // IPin

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    STDMETHODIMP Receive(IMediaSample *pSample);

    STDMETHODIMP QueryId(LPWSTR *Id);

private:

    PAVISTREAM m_pStream;
    CAVIDocWrite * m_pDoc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\capture.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


// Video Capture filter
//
//

#include <streams.h>

extern "C" {
#include "thunk.h"
};

//  #define _INC_MMDEBUG_CODE_ TRUE
//  #define MODULE_DEBUG_PREFIX "Capture\\"

#ifdef FILTER_DLL
  // define the GUIDs for streams and my CLSID in this file
  #include <initguid.h>
  #include <olectlid.h>  // to get IID_IProp...
#endif

static char pszDll16[] = "VIDX16.DLL";
static char pszDll32[] = "CAPTURE.DLL";

#include "driver.h"

// setup data now done by the class manager
#if 0

const AMOVIESETUP_MEDIATYPE
sudVFWCaptureType = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL };  // clsMinorType

const AMOVIESETUP_PIN
psudVFWCapturePins[] =  { L"Output"         // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudVFWCaptureType };// lpTypes

const AMOVIESETUP_FILTER
sudVFWCapture  = { &CLSID_VfwCapture     // clsID
                 , L"VFW Capture "       // strName
                 , MERIT_DO_NOT_USE      // dwMerit
                 , 1                     // nPins
                 , psudVFWCapturePins }; // lpPin
#endif


#ifdef FILTER_DLL

  // list of class ids and creator functions for class factory
  CFactoryTemplate g_Templates[] = {
    {L"VFW Capture Filter", &CLSID_VfwCapture, CVfwCapture::CreateInstance, NULL, NULL},
    {L"VFW Capture Filter Property Page", &CLSID_CaptureProperties, CPropPage::CreateInstance, NULL, NULL}
  };
  int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif

// define some of the X86 specific functions so that NON X86 will build correctly.

// ------ Implements the CVfwCapture public member functions --------

// disable warning about using this in initalizer list.  It could be
// a problem since 'this' is not yet fully constructed, but since all
// we are doing is passing a the 'this' pointer to be stored, it's ok.
//
#pragma warning(disable:4355)

static int cRefCount = 0;

extern "C" {
int g_IsNT;
};

// constructor
//
CVfwCapture::CVfwCapture(
   TCHAR *pName,
   LPUNKNOWN pUnk,
   HRESULT *phr)
   :
   m_lock(),
   m_pStream(NULL),
   m_pOverlayPin(NULL),
   m_pPreviewPin(NULL),
   m_Specify(this, phr),
   m_Options(this, phr),
   m_fDialogUp(FALSE),
   m_iVideoId(-1),
   m_pPersistStreamDevice(NULL),
   CBaseFilter(pName, pUnk, &m_lock, CLSID_VfwCapture),
   CPersistStream(pUnk, phr)
{
   DbgLog((LOG_TRACE,1,TEXT("*Instantiating the VfwCapture filter")));

   ASSERT(cRefCount >= 0);
   if (++cRefCount == 1) {
      DbgLog((LOG_TRACE,2,TEXT("This is the first instance")));

      OSVERSIONINFO OSVer;
      OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
      BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
      ASSERT(bRet);

      g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

      if (!g_IsNT) {
          EXECUTE_ASSERT(ThunkInit());
      }
      else {
	  NTvideoInitHandleList();
      }
   }

// old code to test IAMVfwCaptureDialogs
#if 0
	HRESULT hr;
   	DbgLog((LOG_TRACE,1,TEXT("Testing HasDialog(Format)")));
	hr = HasDialog(VfwCaptureDialog_Format);
   	DbgLog((LOG_TRACE,1,TEXT("%08x"), hr));
   	DbgLog((LOG_TRACE,1,TEXT("Testing HasDialog(Display)")));
	hr = HasDialog(VfwCaptureDialog_Display);
   	DbgLog((LOG_TRACE,1,TEXT("%08x"), hr));
   	DbgLog((LOG_TRACE,1,TEXT("Testing ShowDialog(Format)")));
	hr = ShowDialog(VfwCaptureDialog_Format, NULL);
   	DbgLog((LOG_TRACE,1,TEXT("Testing SendDriverMessage(ShowSourceDlg)")));
	hr = SendDriverMessage(VfwCaptureDialog_Source,
				DRV_USER + 100 /* DVM_DIALOG */, NULL, 0);
#endif

}

// destructor
//
CVfwCapture::~CVfwCapture()
{
   DbgLog((LOG_TRACE,1,TEXT("*Destroying the VfwCapture filter")));

   // ensure that all streams are inactive
   Stop();

   delete m_pStream;
   if (m_pOverlayPin)
	delete m_pOverlayPin;
   if (m_pPreviewPin)
	delete m_pPreviewPin;

   if (--cRefCount == 0) {
      if (!g_IsNT) {
          // disconnect the thunking stuff
          //
          ThunkTerm();
      }
      else {
	  NTvideoDeleteHandleList();
      }
   }
   ASSERT(cRefCount >= 0);

   if(m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
   }

   // free the memory associated with the streams
   //
}

// create a new instance of this class
//
CUnknown * CVfwCapture::CreateInstance (
   LPUNKNOWN pUnk,
   HRESULT * phr )
{
   return new CVfwCapture(NAME("VFW Capture"), pUnk, phr);
}

// override this to say what interfaces we support where
//
STDMETHODIMP CVfwCapture::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
   // See if we have the interface
   // try each of our interface supporting objects in turn
   //
   if (riid == IID_VfwCaptureOptions) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IVfwCaptureOptions")));
      return GetInterface((IVfwCaptureOptions *)&(this->m_Options),ppv);
   } else if (riid == IID_ISpecifyPropertyPages) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for ISpecifyPropertyPages")));
      return GetInterface((ISpecifyPropertyPages *)&(this->m_Specify),ppv);
   } else if (riid == IID_IAMVfwCaptureDialogs) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IAMVfwCaptureDialogs")));
      return GetInterface((LPUNKNOWN)(IAMVfwCaptureDialogs *)this, ppv);
   } else if (riid == IID_IPersistPropertyBag) {
      DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IPeristRegistryKey")));
      return GetInterface((IPersistPropertyBag*)this, ppv);
   } else if(riid == IID_IPersistStream) {
       DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IPersistStream")));
       return GetInterface((IPersistStream *) this, ppv);
   } else if(riid == IID_IAMFilterMiscFlags) {
       DbgLog((LOG_TRACE,9,TEXT("VfwCap::QI for IAMFilterMiscFlags")));
       return GetInterface((IAMFilterMiscFlags *) this, ppv);
   }

   // nope, try the base class.
   //
   HRESULT hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
   if (SUCCEEDED(hr))
       return hr;      // ppv has been set appropriately

   return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

STDMETHODIMP CVfwCapture::CSpecifyProp::GetPages(CAUUID *pPages)
{
   DbgLog((LOG_TRACE,2,TEXT("CSpecifyProp::GetPages")));

   pPages->cElems = 1;
   pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems);
   if ( ! pPages->pElems)
       return E_OUTOFMEMORY;

   pPages->pElems[0] = CLSID_CaptureProperties;
   return NOERROR;
}

// how many pins do we have?
//
int CVfwCapture::GetPinCount()
{
   DbgLog((LOG_TRACE,5,TEXT("CVfwCap::GetPinCount")));

   if (m_pOverlayPin || m_pPreviewPin)
	return 2;
   else if(m_pStream)
	return 1;
   else
        return 0;
}


// return a non-addrefed pointer to the CBasePin.
//
CBasePin * CVfwCapture::GetPin(int ii)
{
   DbgLog((LOG_TRACE,5,TEXT("CVfwCap::GetPin")));

   if (ii == 0 && m_pStream)
      return m_pStream;
   if (ii == 1 && m_pOverlayPin)
      return m_pOverlayPin;
   if (ii == 1 && m_pPreviewPin)
      return m_pPreviewPin;
   return NULL;
}

// ===============  Implements the ICImplFilter class ===============

// override CBaseFilter::Run
//

// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP CVfwCapture::Run(REFERENCE_TIME tStart)
{
   DbgLog((LOG_TRACE,1,TEXT("CVfwCap::Run at %d"),
			(LONG)((CRefTime)tStart).Millisecs()));

   CAutoLock cObjectLock(m_pLock);

   // remember the stream time offset before notifying the pins
   //
   m_tStart = tStart;

   // if we are in the stopped state, first
   // pause the filter.
   //
   if (m_State == State_Stopped)
      {
      // !!! If the real Pause got an error, this will try a second time
      HRESULT hr = Pause();
      if (FAILED(hr))
         return hr;
      }

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Running, tStart);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Running, tStart);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Running, tStart);

   // now put our streaming video pin into the Run state
   //
   if (m_State == State_Paused) {
	HRESULT hr;
   	int cPins = GetPinCount();

        // do we have a streaming pin?
        if (cPins > 0) {
            CCapStream *pPin = m_pStream;
            if (pPin->IsConnected()) {
                hr = pPin->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
            }
	    CCapOverlay *pPinO = m_pOverlayPin;
	    if (pPinO && pPinO->IsConnected()) {
                hr = pPinO->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
	    }
	    CCapPreview *pPinP = m_pPreviewPin;
	    if (pPinP && pPinP->IsConnected()) {
                hr = pPinP->ActiveRun(tStart);
                if (FAILED(hr))
                    return hr;
	    }
	}
   }

   m_State = State_Running;
   return S_OK;
}

// override CBaseFilter::Pause
//

// Put the filter into a paused state.

STDMETHODIMP CVfwCapture::Pause()
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Pause")));

    // We have a driver dialog up that is about to change the capture settings.
    // Now is NOT a good time to start streaming.
    if (m_State == State_Stopped && m_fDialogUp) {
        DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Pause - Dialog up. SORRY!")));
	return E_UNEXPECTED;
    }

    CAutoLock cObjectLock(m_pLock);

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Paused, 0);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Paused, 0);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Paused, 0);

    // notify the pins of the change from Run-->Pause
    if (m_State == State_Running) {
	HRESULT hr;
	int cPins = GetPinCount();

	// make sure we have pins
	if (cPins > 0) {
	    CCapStream *pPin = m_pStream;
            if (pPin->IsConnected()) {
	        hr = pPin->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	    CCapOverlay *pPinO = m_pOverlayPin;
            if (pPinO && pPinO->IsConnected()) {
	        hr = pPinO->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	    CCapPreview *pPinP = m_pPreviewPin;
            if (pPinP && pPinP->IsConnected()) {
	        hr = pPinP->ActivePause();
	        if (FAILED(hr))
		    return hr;
            }
	}
    }

    // notify all pins BACKWARDS! so the overlay pin is started first, so the
    // overlay channel is intitialized before the capture channel (this is the
    // order AVICap did things in and we have to do the same thing or buggy
    // drivers like the Broadway or BT848 based drivers won't preview while
    // capturing.
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = cPins - 1; c >=  0; c--) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }

    m_State = State_Paused;
    return S_OK;
}


STDMETHODIMP CVfwCapture::Stop()
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Stop")));

    CAutoLock cObjectLock(m_pLock);

    // Shame on the base classes
    if (m_State == State_Running) {
	HRESULT hr = Pause();
	if (FAILED(hr))
	    return hr;
    }

    // Tell the Stream Control stuff what's going on
    if (m_pPreviewPin)
	m_pPreviewPin->NotifyFilterState(State_Stopped, 0);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->NotifyFilterState(State_Stopped, 0);
#endif
    if (m_pStream)
	m_pStream->NotifyFilterState(State_Stopped, 0);

    return CBaseFilter::Stop();
}


// tell the stream control stuff what clock to use
STDMETHODIMP CVfwCapture::SetSyncSource(IReferenceClock *pClock)
{
    if (m_pStream)
	m_pStream->SetSyncSource(pClock);
    if (m_pPreviewPin)
	m_pPreviewPin->SetSyncSource(pClock);
#ifdef OVERLAY_SC
    if (m_pOverlayPin)
	m_pOverlayPin->SetSyncSource(pClock);
#endif
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the stream control stuff what sink to use
STDMETHODIMP CVfwCapture::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::JoinFilterGraph")));

    HRESULT hr = S_OK;

    // TAPI wants to create multiple filters at once, but only have one in
    // a graph at a time, so we delay taking any resources until now
    if (m_pStream == NULL && pGraph != NULL) {
	if (m_iVideoId != -1) {
            CreatePins(&hr);
            if (FAILED(hr))
	        return hr;
	    IncrementPinVersion();
            DbgLog((LOG_TRACE,1,TEXT("* Creating pins")));
	} else {
	    // we haven't been told what device to use yet!
            DbgLog((LOG_TRACE,1,TEXT("* Delay creating pins")));
	}
    } else if (pGraph != NULL) {
	// take resources only when in the filter graph
	hr = m_pStream->ConnectToDriver();
	if (FAILED(hr))
	    return hr;
	hr = m_pStream->LoadOptions();
	if (FAILED(hr))
	    return hr;
        DbgLog((LOG_TRACE,1,TEXT("* Reconnecting")));
    } else if (m_pStream) {
	// give back resources when not in graph
	m_pStream->DisconnectFromDriver();
   	delete [] m_pStream->m_cs.tvhPreview.vh.lpData;
   	m_pStream->m_cs.tvhPreview.vh.lpData = NULL;
   	delete m_pStream->m_user.pvi;
   	m_pStream->m_user.pvi = NULL;
        DbgLog((LOG_TRACE,1,TEXT("* Disconnecting")));
    }

    hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK && m_pStream)
	m_pStream->SetFilterGraph(m_pSink);
#ifdef OVERLAY_SC
    if (hr == S_OK && m_pOverlayPin)
	m_pOverlayPin->SetFilterGraph(m_pSink);
#endif
    if (hr == S_OK && m_pPreviewPin)
	m_pPreviewPin->SetFilterGraph(m_pSink);
    return hr;
}


// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
STDMETHODIMP CVfwCapture::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
	return VFW_S_CANT_CUE;
    else
        return S_OK;
}

STDMETHODIMP CVfwCapture::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::Load")));

    HRESULT hr = S_OK;
    CAutoLock cObjectLock(m_pLock);

    // We already have some pins, thank you
    if (m_pStream)
	return E_UNEXPECTED;

    m_fAvoidOverlay = FALSE;

    // Default to capture device #0
    if (pPropBag == NULL) {
        m_iVideoId = 0;
	// if we're in the graph already, we can make our pins and take
	// resources
	if (m_pGraph)
            CreatePins(&hr);
	return hr;
    }

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hrX = pPropBag->Read(L"AvoidOverlay", &var, 0);
    if(SUCCEEDED(hrX))
    {
        DbgLog((LOG_TRACE,1,TEXT("*** OVERLAYS SWITCHED OFF")));
        m_fAvoidOverlay = TRUE;
    }

    var.vt = VT_I4;
    hr = pPropBag->Read(L"VFWIndex", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = S_OK;
        m_iVideoId = var.lVal;
	if (m_pGraph)
            CreatePins(&hr);
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0);

    // save moniker with addref. ignore error if qi fails
    if(SUCCEEDED(hr)) {
        pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);
    }

    return hr;
}

STDMETHODIMP CVfwCapture::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CVfwCapture::InitNew()
{
   if(m_pStream)
   {
       ASSERT(m_iVideoId != -1);
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }
   else
   {
       return S_OK;
   }
}

STDMETHODIMP CVfwCapture::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_VfwCapture;
    return S_OK;
}

// struct CapturePersist
// {
//     DWORD dwSize;
//     LONG iVideoId;
// };

HRESULT CVfwCapture::WriteToStream(IStream *pStream)
{
    ASSERT(m_iVideoId >= -1 && m_iVideoId < 10);
    HRESULT hr = E_FAIL;

    if(m_pPersistStreamDevice)
    {
        // the size field of CapturePersist was used as a version
        // number. previously 8, now 12
        DWORD dwVersion = 12;

        hr =  pStream->Write(&dwVersion, sizeof(dwVersion), 0);
        if(SUCCEEDED(hr))
        {
            hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CVfwCapture::ReadFromStream(IStream *pStream)
{

   DbgLog((LOG_TRACE,1,TEXT("CVfwCapture::ReadFromStream")));

   if(m_pStream)
   {
       ASSERT(m_iVideoId != -1);
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   ASSERT(m_iVideoId == -1);

   DWORD dwVersion;
   HRESULT hr = pStream->Read(&dwVersion, sizeof(dwVersion), 0);
   if(FAILED(hr)) {
       return hr;
   }

   if(dwVersion != 12) {
      return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
   }

   IPersistStream *pMonPersistStream;
   hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                         IID_IPersistStream, (void **)&pMonPersistStream);
   if(SUCCEEDED(hr))
   {
       hr = pMonPersistStream->Load(pStream);
       if(SUCCEEDED(hr))
       {
           IPropertyBag *pPropBag;
           hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
           if(SUCCEEDED(hr))
           {
               hr = Load(pPropBag, 0);
               pPropBag->Release();
           }
       }

       pMonPersistStream->Release();
   }

   return hr;
}

int CVfwCapture::SizeMax()
{
    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;
    if(m_pPersistStreamDevice)
    {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK)
        {
            // space for version number
            ulicb.QuadPart += sizeof(DWORD);
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}


// ===============  Implements the COptions imbedded class ===============

STDMETHODIMP
CVfwCapture::COptions::VfwCapSetOptions (
   const VFWCAPTUREOPTIONS *pOpt)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapSetOptions")));

   if (!m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->SetOptions(pOpt);
}

STDMETHODIMP
CVfwCapture::COptions::VfwCapGetOptions (
   VFWCAPTUREOPTIONS * pOpt)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapGetOptions")));

   if ( ! m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->GetOptions(pOpt);
}

STDMETHODIMP CVfwCapture::COptions::VfwCapGetCaptureStats(CAPTURESTATS *pcs)
{
    DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapGetCaptureStats")));

    if ( ! m_pCap->m_pStream)
        return E_UNEXPECTED;

    if (pcs) {
	*pcs = m_pCap->m_pStream->m_capstats;
    	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

STDMETHODIMP
CVfwCapture::COptions::VfwCapDriverDialog (
   HWND hwnd,
   UINT uDrvType,
   UINT uQuery)
{
   DbgLog((LOG_TRACE,2,TEXT("COptions::VfwCapDriverDialog")));

   if (!m_pCap->m_pStream)
      return E_UNEXPECTED;
   return m_pCap->m_pStream->DriverDialog(hwnd, uDrvType, uQuery);
}

//======================================================================


//IAMVfwCaptureDialogs stuff

HRESULT CVfwCapture::HasDialog(int iDialog)
{
    if (!m_pStream)
        return E_UNEXPECTED;

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else
	return S_FALSE;

    if (videoDialog(hVideo, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
	return S_OK;
    else
	return S_FALSE;
}


HRESULT CVfwCapture::ShowDialog(int iDialog, HWND hwnd)
{
    if (!m_pStream)
        return E_UNEXPECTED;

    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Also make sure another dialog isn't already up (I'm paranoid)
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    m_pLock->Lock();
    if (m_State != State_Stopped || m_fDialogUp) {
        m_pLock->Unlock();
	return VFW_E_NOT_STOPPED;
    }
    m_fDialogUp = TRUE;
    m_pLock->Unlock();

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else {
	m_fDialogUp = FALSE;
	return E_INVALIDARG;
    }

    if (hwnd == NULL)
	hwnd = GetDesktopWindow();

    DWORD dw = videoDialog(hVideo, hwnd, 0);

    // this changed our output format!
    if (dw == 0 && iDialog == VfwCaptureDialog_Format) {
        DbgLog((LOG_TRACE,1,TEXT("Changed output formats")));
        // The dialog changed the driver's internal format.  Get it again.
        m_pStream->GetFormatFromDriver();
        if (m_pStream->m_user.pvi->bmiHeader.biBitCount <= 8)
	    m_pStream->InitPalette();

        // Now reconnect us so the graph starts using the new format
        HRESULT hr = m_pStream->Reconnect(TRUE);
	if (hr != S_OK)
	    dw = VFW_E_CANNOT_CONNECT;
    }

    m_fDialogUp = FALSE;

    return dw;
}


HRESULT CVfwCapture::SendDriverMessage(int iDialog, int uMsg, long dw1, long dw2)
{

    if (!m_pStream)
        return E_UNEXPECTED;

    // This could do anything!  Bring up a dialog, who knows.
    // Don't take any crit sect or do any kind of protection.
    // They're on their own

    HVIDEO hVideo;
    if (iDialog == VfwCaptureDialog_Source)
	hVideo = m_pStream->m_cs.hVideoExtIn;
    else if (iDialog == VfwCaptureDialog_Format)
	hVideo = m_pStream->m_cs.hVideoIn;
    else if (iDialog == VfwCaptureDialog_Display)
	hVideo = m_pStream->m_cs.hVideoExtOut;
    else
	return E_INVALIDARG;

    return (HRESULT)videoMessage(hVideo, uMsg, dw1, dw2);
}

void CVfwCapture::CreatePins(HRESULT *phr)
{
   if(FAILED(*phr))
       return;

   CAutoLock cObjectLock(m_pLock);

   if(m_pStream)
   {
       *phr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   // create our output pins for the video data stream, and maybe overlay
   //
   m_pStream = CreateStreamPin(this, m_iVideoId, phr);

   if (m_pStream == NULL)
	return;

   // If we can do h/w preview with overlay, great, otherwise we'll do a
   // non-overlay preview
   if (m_pStream->m_cs.bHasOverlay) {
	m_pOverlayPin = CreateOverlayPin(this,phr);
   } else {
	m_pPreviewPin = CreatePreviewPin(this,phr);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_IVIDEO32
#define _INC_IVIDEO32   50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include <vfw.h>

#define LOADDS
#define EXPORT

// unicode conversions
int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

/****************************************************************************

                        video APIs

****************************************************************************/

#include "vidx.h"

#if defined _WIN32

void NTvideoInitHandleList(void);
void NTvideoDeleteHandleList(void);

#ifdef UNICODE
  #define videoGetErrorText  videoGetErrorTextW
  #define NTvideoGetErrorText  NTvideoGetErrorTextW
#else
  #define videoGetErrorText  videoGetErrorTextA
  #define NTvideoGetErrorText  NTvideoGetErrorTextA
#endif // !UNICODE

DWORD WINAPI videoOpen(
   LPHVIDEO lphVideo,
   DWORD dwDevice,
   DWORD dwFlags);
DWORD WINAPI NTvideoOpen(
   LPHVIDEO lphVideo,
   DWORD dwDevice,
   DWORD dwFlags);

DWORD WINAPI videoClose (
   HVIDEO hVideo);
DWORD WINAPI NTvideoClose (
   HVIDEO hVideo);

DWORD WINAPI videoDialog (
   HVIDEO hVideo,
   HWND   hWndParent,
   DWORD  dwFlags);
DWORD WINAPI NTvideoDialog (
   HVIDEO hVideo,
   HWND   hWndParent,
   DWORD  dwFlags);

DWORD WINAPI videoGetChannelCaps(
   HVIDEO hVideo,
   LPCHANNEL_CAPS lpChannelCaps,
   DWORD dwSize);
DWORD WINAPI NTvideoGetChannelCaps(
   HVIDEO hVideo,
   LPCHANNEL_CAPS lpChannelCaps,
   DWORD dwSize);

DWORD WINAPI videoUpdate (
   HVIDEO hVideo,
   HWND   hWnd,
   HDC    hDC);
DWORD WINAPI NTvideoUpdate (
   HVIDEO hVideo,
   HWND   hWnd,
   HDC    hDC);

DWORD WINAPI videoConfigure (
   HVIDEO  hVideo,
   UINT    msg,
   DWORD   dwFlags,
   LPDWORD lpdwReturn,
   LPVOID  lpData1,
   DWORD   dwSize1,
   LPVOID  lpData2,
   DWORD   dwSize2);
DWORD WINAPI NTvideoConfigure (
   HVIDEO  hVideo,
   UINT    msg,
   DWORD   dwFlags,
   LPDWORD lpdwReturn,
   LPVOID  lpData1,
   DWORD   dwSize1,
   LPVOID  lpData2,
   DWORD   dwSize2);

DWORD WINAPI videoFrame (
   HVIDEO hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvideoFrame (
   HVIDEO hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI videoGetErrorTextA(
   HVIDEO hVideo,
   UINT   wError,
   LPSTR  lpText,
   UINT   wSize);
DWORD WINAPI NTvideoGetErrorTextA(
   HVIDEO hVideo,
   UINT   wError,
   LPSTR  lpText,
   UINT   wSize);
DWORD WINAPI videoGetErrorTextW(
   HVIDEO hVideo,
   UINT   wError,
   LPWSTR  lpText,
   UINT   wSize);
DWORD WINAPI NTvideoGetErrorTextW(
   HVIDEO hVideo,
   UINT   wError,
   LPWSTR  lpText,
   UINT   wSize);

DWORD WINAPI videoStreamInit (
   HVIDEO hVideo,
   DWORD  dwMicroSecPerFrame,
   DWORD_PTR  dwCallback,
   DWORD_PTR  dwCallbackInst,
   DWORD  dwFlags);
DWORD WINAPI NTvideoStreamInit (
   HVIDEO hVideo,
   DWORD  dwMicroSecPerFrame,
   DWORD_PTR  dwCallback,
   DWORD_PTR  dwCallbackInst,
   DWORD  dwFlags);

DWORD WINAPI videoStreamFini (
   HVIDEO hVideo);
DWORD WINAPI NTvideoStreamFini (
   HVIDEO hVideo);

//DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
//            LPVIDEOHDREX lpVHdr,DWORD dwSize);
//DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
//            LPVIDEOHDREX lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(
   HVIDEO     hVideo,
   LPVIDEOHDR lpVHdr,
   DWORD      dwSize);
DWORD WINAPI NTvideoStreamUnprepareHeader(
   HVIDEO     hVideo,
   LPVIDEOHDR lpVHdr,
   DWORD      dwSize);

// Added for Win95 & NT PPC
//
DWORD WINAPI videoStreamAllocBuffer(HVIDEO hVideo,
            LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI NTvideoStreamAllocBuffer(HVIDEO hVideo,
            LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI videoStreamFreeBuffer(HVIDEO hVideo,
            LPVOID lpBuffer);
DWORD WINAPI NTvideoStreamFreeBuffer(HVIDEO hVideo,
            LPVOID lpBuffer);


DWORD WINAPI videoSetRect(HVIDEO hVideo, DWORD dwMsg, RECT rc);
DWORD WINAPI NTvideoSetRect(HVIDEO hVideo, DWORD dwMsg, RECT rc);

DWORD WINAPI NTvideoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc,
				UINT cbDesc, LPTSTR lpszVer, UINT cbVer);
DWORD WINAPI videoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc,
				UINT cbDesc, LPTSTR lpszVer, UINT cbVer);

LRESULT WINAPI NTvideoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);
LRESULT WINAPI videoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);

#endif // _WIN32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_IVIDEO32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\cmeasure.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/*+ cmeasure.h
 *
 * routines to capture performance data for the capture filter
 *
 *-===============================================================*/

#ifdef JMK_HACK_TIMERS

#error JMK_HACK_TIMERS is broken, it assumes the VFWCAPTUREOPTIONS and _qc_user
#error structures are identical, and they aren't (measureInit)

#if !defined _INC_MEASURE_
#define _INC_MEASURE_

 #include "mmtimers.h"
 #ifndef FCC
  #define FCC(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))
 #endif

 #ifndef JMK_LOG_SIZE
  #define JMK_LOG_SIZE 1000
 #endif

 #ifndef JMK_MAX_STRAMS
  #define JMK_MAX_STREAMS 2
 #endif

 struct _timerstuff {
     DWORD dwStampTime;        // Stamped in the VIDEOHDR
     DWORD dwTick;             // frame stamp converted to a tick time
     DWORD dwTimeWritten;      // Time Deliver called
     DWORD dwTimeToWrite;      // Time Deliver returned
     DWORD ixBuffer;           // which buffer we used
     DWORD dwArriveTime;       // what time the frame 'arrived'
     };

 struct _qc_user {
      UINT  uVideoID;      // id of video driver to open
      DWORD dwTimeLimit;   // stop capturing at this time???
      DWORD dwTickScale;   // frame rate rational
      DWORD dwTickRate;    // frame rate = dwRate/dwScale in ticks/sec
      DWORD dwRefTimeConv; // conversion to ReferenceTime
      UINT  nHeaders;      //
      UINT  cbFormat;      // sizeof VIDEOINFOHEADER
      VIDEOINFOHEADER * pvi;
      };

 struct _qc_cap {
      CAPDRIVERCAPS  caps;        // returned capabilities from the capture driver
      HVIDEO         hVideoIn;    // video input driver
      MMRESULT       mmr;         // open fail/success code
      THKVIDEOHDR    tvhPreview;
      DWORD          pSamplePreview;
      UINT           cbBuffer;           // max size of video frame data
      UINT           nHeaders;           // number of video headers
      DWORD          paHdrs;
      BOOL           fBuffersOnHardware; // TRUE if all video buffers are in hardware
      DWORD          hEvtBufferDone;
      DWORD          h0EvtBufferDone;
      UINT           iNext;
      LONGLONG       tTick;              // duration of a single tick
      };

 struct _qcap {
     DWORD   nPrio;
     DWORD   nFramesCaptured;
     DWORD   nFramesDropped;
     DWORD   dwTimerFrequency;
     UINT    state;
     DWORD   dwElapsedTime;
     struct _qc_user user;
     VIDEOINFOHEADER       vi;
     struct _qc_cap  cs;
     };

 struct _timerriff {
     FOURCC fccRIFF;       // 'RIFF'
     DWORD  cbTotal;       // total (inclusive) size of riff data
     FOURCC fccJMKD;       // 'JMKD' data type identifier

     DWORD  fccQCAP;       // 'VCHD' capture data header
     DWORD  cbQCAP;        // sizeof qcap data
     struct _qcap qcap;

     DWORD  fccChunk;      // chunk data type tag
     DWORD  cbChunk;       // non-inclusive size of chunk data
     };

 struct _measurestate {
   HANDLE hMemTimers;
   UINT   cbMemTimers;
   UINT   ixCurrent;
   UINT   nMax;
   struct _timerriff * pTimerRiff;
   struct _timerstuff * pCurStuff;
   struct _timerstuff * pStuff;
   PCTIMER pctBase;
   };

   extern struct _measurestate ms[JMK_MAX_STREAMS];

   extern void measureBegin(UINT id);
   extern void measureEnd(UINT id);
   extern void measureFree(UINT id);
   extern void measureAllocate(
      UINT id,
      UINT nMax);
   extern void measureInit(
      UINT id,
      struct _qc_user * pUser,
      UINT           cbUser,
      struct _qc_cap *  pCap,
      UINT           cbCap);

   #define jmkAlloc  measureAllocate(m_id, JMK_LOG_SIZE);
   #define jmkInit   measureInit(m_id,              \
        (struct _qc_user *)&m_user, sizeof(m_user), \
        (struct _qc_cap *)&m_cs, sizeof(m_cs));
   #define jmkFree  measureFree(m_id);
   #define jmkBegin measureBegin(m_id);
   #define jmkEnd   measureEnd(m_id);
   #define LOGFITS(id)  (id < NUMELMS(ms) && ms[id].pTimerRiff)

   #define jmkFrameArrives(ptvh,ix) if (LOGFITS(m_id)) {    \
     ms[m_id].pCurStuff->dwArriveTime = pcGetTicks();       \
     ms[m_id].pCurStuff->ixBuffer     = ix;                 \
     ++(ms[m_id].pTimerRiff->qcap.nFramesCaptured);         \
     ms[m_id].pTimerRiff->qcap.dwElapsedTime = pcGetTime(); \
     }
   #define jmkBeforeDeliver(ptvh,dwlTick) if (LOGFITS(m_id)) {            \
     ms[m_id].pCurStuff->dwStampTime = ptvh->vh.dwTimeCaptured;           \
     ms[m_id].pCurStuff->dwTick = (DWORD)dwlTick;                         \
     ms[m_id].pCurStuff->dwTimeWritten = pcDeltaTicks(&ms[m_id].pctBase); \
     }
   #define jmkAfterDeliver(ptvh) if (LOGFITS(m_id)) {                     \
     ms[m_id].pCurStuff->dwTimeToWrite = pcDeltaTicks(&ms[m_id].pctBase); \
     if (++(ms[m_id].ixCurrent) > ms[m_id].nMax)                          \
        ms[m_id].ixCurrent = 0;                                           \
     ms[m_id].pCurStuff = ms[m_id].pStuff + ms[m_id].ixCurrent;           \
     }

#endif //_INC_MEASURE_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if (defined _INC_MEASURE_CODE_) && (_INC_MEASURE_CODE_ != FALSE)
#undef _INC_MEASURE_CODE_
#define _INC_MEASURE_CODE_ FALSE

 #define _INC_MMTIMERS_CODE_ TRUE
 #include "mmtimers.h"

 struct _measurestate ms[JMK_MAX_STREAMS];

 void measureAllocate(UINT id,
                      UINT nMaxFrames)
 {
     BOOL bCreated = FALSE; // true if we create the mapping object
     TCHAR szName[30];
     struct _timerriff * pTimer;

     wsprintf (szName, "jmkCaptureRiff%d", id);

     //assert (!ms[id].pTimerRiff);
     ms[id].cbMemTimers = sizeof(struct _timerriff)
                        + (sizeof(struct _timerstuff) * nMaxFrames);
     if ( ! ms[id].cbMemTimers)
        return;

     ms[id].hMemTimers = CreateFileMapping((HANDLE)-1, NULL,
                                           PAGE_READWRITE,
                                           0, ms[id].cbMemTimers,
                                           szName);
     if (0 == GetLastError())
        bCreated = TRUE;

     if (ms[id].hMemTimers)
        ms[id].pTimerRiff = pTimer = (struct _timerriff *)
           MapViewOfFile (ms[id].hMemTimers, FILE_MAP_WRITE, 0, 0, 0);

     if (pTimer)
        {
        // if we created the memory, initialize it.
        // otherwise, assume that it is what we expect
        //
        if (bCreated)
           {
           ZeroMemory ((LPVOID)pTimer, ms[id].cbMemTimers);
           pTimer->fccRIFF = FCC('RIFF');
           pTimer->cbTotal = ms[id].cbMemTimers - 8; // (total does not include first two fields)
           pTimer->fccJMKD = FCC('JMKD');
           pTimer->fccQCAP = FCC('QCAP');
           pTimer->cbQCAP  = sizeof(struct _qcap);
           pTimer->fccChunk = FCC('TICK');
           pTimer->cbChunk = pTimer->cbTotal - sizeof(*pTimer);
           }
        else if (pTimer->fccRIFF != FCC('RIFF')         ||
                 pTimer->cbTotal < sizeof(*pTimer) ||
                 pTimer->fccJMKD != FCC('JMKD')         ||
                 pTimer->fccQCAP != FCC('QCAP')         ||
                 pTimer->cbQCAP != sizeof(struct _qcap) ||
                 pTimer->fccChunk != FCC('TICK')        ||
                 pTimer->cbChunk < sizeof(*ms[id].pStuff)
                 )
           {
           ms[id].pTimerRiff = pTimer = NULL;
           return;
           }
        }
 }

 void measureInit (UINT id,
                   struct _qc_user * pUser,
                   UINT              cbUser,
                   struct _qc_cap *  pCap,
                   UINT              cbCap)
 {
     struct _qcap * pqc;

     //assert (cbUser = sizeof(*pUser));
     //assert (cbCap = sizeof(*pCap));

     if (LOGFITS(id))
        {
        struct _timerriff * pTimer = ms[id].pTimerRiff;

        // reset counters and stuff to 0.
        //
        ms[id].ixCurrent = 0;
        ms[id].pCurStuff = ms[id].pStuff = (struct _timerstuff *)(pTimer+1);
        ms[id].nMax = pTimer->cbChunk / sizeof(*(ms[id].pStuff));

        // fill in qcap from the contents of the capture stream
        //
        pqc = &pTimer->qcap;
        pqc->nPrio = GetThreadPriority(GetCurrentThread());
        pqc->nFramesCaptured = 0;
        pqc->nFramesDropped  = 0;
        pqc->dwTimerFrequency = pc.dwTimerKhz;
        pqc->state = 0;
        pqc->dwElapsedTime = 0;

        CopyMemory (&pqc->user, pUser, min(cbUser, sizeof(pqc->user)));
        ZeroMemory (&pqc->vi, sizeof(pqc->vi));
        if (pUser->pvi && ! IsBadReadPtr(pUser->pvi, pUser->cbFormat))
           CopyMemory (&pqc->vi, pUser->pvi,
                       min(pUser->cbFormat, sizeof(pqc->vi)));

        CopyMemory (&pqc->cs, pCap, min(cbCap, sizeof(pqc->cs)));

        // zero out the tick buffer.  this also forces it to be present...
        //
        ZeroMemory (ms[id].pStuff, pTimer->cbChunk);
        }
  }

  void measureFree(UINT id)
  {
     if (ms[id].pTimerRiff)
       UnmapViewOfFile (ms[id].pTimerRiff);
     ms[id].pTimerRiff = NULL;

     if (ms[id].hMemTimers)
        CloseHandle (ms[id].hMemTimers);
     ms[id].hMemTimers = NULL;
  }

  void measureBegin(UINT id)
  {
     // set the base for our time measurement
     // and make sure that the base for write delta times
     // is the same as the base for the capture in general
     //
     if (id == 0)
        pcBegin();
     if (LOGFITS(id))
        {
        ms[id].pctBase = pc.base;
        ms[id].pTimerRiff->qcap.state = 1;
        }
  }

  void measureEnd(UINT id)
  {
     if (LOGFITS(id))
        {
        ms[id].pTimerRiff->qcap.state = 2;
        ms[id].pTimerRiff->qcap.dwElapsedTime = pcGetTime();
        }
  }

#endif


# if 0
               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff)
                    pTimerRiff->vchd.dwDropFramesNotAppended += nDropCount;
               #endif


           #ifdef JMK_HACK_TIMERS
	    if (pTimerRiff) {
	        if (nTimerIndex == CLIPBOARDLOGSIZE)
		    nTimerIndex = 0;
	
// nTimerIndex will be OK	if ((nTimerIndex < CLIPBOARDLOGSIZE) && pTimerStuff)
		if (pTimerStuff)
		{
	
		    pCurTimerStuff = &pTimerStuff[nTimerIndex];
                    ++nTimerIndex;

		    pCurTimerStuff->nFramesAppended = 0;
		    pCurTimerStuff->nDummyFrames  = (WORD)lpcs->dwFramesDropped;
		    pCurTimerStuff->dwFrameTickTime = dwTime;
		    pCurTimerStuff->dwFrameStampTime = lpvh->dwTimeCaptured;
		    pCurTimerStuff->dwVideoChunkCount = lpcs->dwVideoChunkCount;
                    pCurTimerStuff->dwTimeWritten = pcDeltaTicks(&pctWriteBase);
		    pCurTimerStuff->dwTimeToWrite = 0;
		    pCurTimerStuff->nVideoIndex = lpcs->iNextVideo;
		    pCurTimerStuff->nAudioIndex = lpcs->iNextWave;
		}
	    } // fClipboardLogging
           #endif // JMK_HACK_TIMERS



               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff) {
                    pTimerRiff->vchd.dwDropFramesAppended += nAppendDummyFrames;
		    pCurTimerStuff->nFramesAppended = nAppendDummyFrames;
		}
               #endif


           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
                pCurTimerStuff->dwTimeToWrite = pcDeltaTicks(&pctWriteBase);
                pCurTimerStuff->bPending = *lpbPending;
            }
           #endif


   #ifdef JMK_HACK_TIMERS
    // Allocate memory for logging capture results to the clipboard if requested
    if (GetProfileIntA ("Avicap32", "ClipboardLogging", FALSE))
    {
        AuxDebugEx (2, DEBUGLINE "ClipboardLogging Enabled\r\n");
        InitPerformanceCounters();
        pcBegin(), pctWriteBase = pc.base;

	hMemTimers = GlobalAlloc(GHND | GMEM_ZEROINIT,
                             sizeof(struct _timerriff) +
                             sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE);

	if (hMemTimers && (pTimerRiff = GlobalLock (hMemTimers)))
	    ;
	else if (hMemTimers)
	{
	    GlobalFree(hMemTimers);
	    pTimerRiff = 0;
	    pTimerStuff = 0;
	    hMemTimers = 0;
	}
	nTimerIndex = 0;
	nSleepCount = 0;
    }  // if ClipboardLogging
   #endif  // JMK_HACK_TIMERS


   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
	UINT ii;

        pTimerRiff->fccRIFF = RIFFTYPE('RIFF'); //MAKEFOURCC('R','I','F','F');
	pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
	    		  sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE;
        pTimerRiff->fccJMKD = RIFFTYPE('JMKD'); //MAKEFOURCC('J','M','K','D');
        pTimerRiff->fccVCHD = RIFFTYPE('VCHD'); //MAKEFOURCC('V','C','H','D');
	
	pTimerRiff->cbVCHD  = sizeof(struct _vchd);
	pTimerRiff->vchd.nPrio = GetThreadPriority(GetCurrentThread());
	pTimerRiff->vchd.bmih = lpcs->lpBitsInfo->bmiHeader;
	pTimerRiff->vchd.cap  = lpcs->sCapParms;
	pTimerRiff->vchd.dwDropFramesAppended = 0;
	pTimerRiff->vchd.dwDropFramesNotAppended = 0;
        pTimerRiff->vchd.dwTimerFrequency = pcGetTickRate();
	
	for (ii = 0; ii < NUMELMS(pTimerRiff->vchd.atvh); ++ii)
	{
	    if (lpcs->alpVideoHdr[ii])
            {
	        struct _thkvideohdr * ptvh = (LPVOID)lpcs->alpVideoHdr[ii];
               #ifndef CHICAGO
                assert (sizeof(CAPVIDEOHDR) == sizeof(*ptvh));
               #endif
                pTimerRiff->vchd.atvh[ii] = *ptvh;
                pTimerRiff->vchd.nMaxVideoBuffers = ii;
            }
        }
	
        pTimerRiff->fccChunk = RIFFTYPE('VCAP'); //MAKEFOURCC('V','C','A','P');
	pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);
	
	pTimerStuff = (LPVOID)(pTimerRiff + 1);
	pCurTimerStuff = &pTimerStuff[0];
    }  // fClipboardLogging
   #endif  // JMK_HACK_TIMERS


           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
               pCurTimerStuff->nSleepCount = ++nSleepCount;
               pCurTimerStuff->dwSleepBegin = pcGetTicks();
            }
           #endif

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
	    {
               pCurTimerStuff->dwSleepEnd = pcGetTicks();
	    }
           #endif



   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
        UINT    ii;
	UINT	kk;
        LPSTR   psz;
        HGLOBAL hMem;

        kk = (lpcs->dwVideoChunkCount >= CLIPBOARDLOGSIZE) ?
			CLIPBOARDLOGSIZE : nTimerIndex;

        hMem = GlobalAlloc (GHND, (16 * 5 + 2) * kk + 80);
	
        if (hMem && (psz = GlobalLock (hMem)))
        {
            pTimerRiff->vchd.dwFramesCaptured = lpcs->dwVideoChunkCount;
            pTimerRiff->vchd.dwFramesDropped = lpcs->dwFramesDropped;

            pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
                                  sizeof(struct _timerstuff) * nTimerIndex;
            pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);

            lstrcpyA(psz, "Slot#, VideoIndex, ExpectedTime, DriverTime, AccumulatedDummyFrames, CurrentAppendedDummies");
            for (ii = 0; ii < kk; ++ii)
            {
                psz += lstrlenA(psz);
                wsprintfA(psz, "\r\n%d, %ld, %ld, %ld, %d, %d",
			  ii,
			  pTimerStuff[ii].dwVideoChunkCount,
                          pTimerStuff[ii].dwFrameTickTime,
                          pTimerStuff[ii].dwFrameStampTime,
                          pTimerStuff[ii].nDummyFrames,
			  pTimerStuff[ii].nFramesAppended
                          );
            }

            GlobalUnlock (hMem);
            GlobalUnlock (hMemTimers);

            if (OpenClipboard (lpcs->hwnd))
            {
                EmptyClipboard ();
                SetClipboardData (CF_RIFF, hMemTimers);
                SetClipboardData (CF_TEXT, hMem);
                CloseClipboard ();
            }
            else
            {
                GlobalFree (hMem);
                GlobalFree (hMemTimers);
            }
        }
        else
        {
            // Failed to allocate or lock hMem.  Cleanup.
            //
            if (hMem)
                GlobalFree(hMem);

            // Free off the timer block.  (We have not set the
            // clipboard data.)
            //
            if (hMemTimers)
            {
                GlobalUnlock(hMemTimers);
                GlobalFree(hMemTimers);
            }
        }

        hMemTimers = NULL;
        pTimerRiff = NULL;
	pTimerStuff = NULL;
	pCurTimerStuff = NULL;
    }
   #endif



#endif // 0

#else	// JMK_HACK_TIMERS not defined
   #define jmkAlloc
   #define jmkInit
   #define jmkFree
   #define jmkBegin
   #define jmkEnd
   #define jmkFrameArrives(ptvh,ix)
   #define jmkBeforeDeliver(ptvh,tick)
   #define jmkAfterDeliver(ptvh)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\mmtimers.h ===
/* + mmtimers.h
 *
 * Accurate timers using pentium cpu clock, QueryPerformanceCounter
 * or GetTickCount depending on what system the code is run on
 *
 * Copyright (C) 1995, Microsoft Corporation, all rights reserved
 *
 *-========================================================================*/
 
#if !defined _INC_MMTIMERS_
#define _INC_MMTIMERS_

  typedef struct {
    DWORD dwlo;
    DWORD dwhi;
    } PCTIMER, NEAR * PPCTIMER;

  struct _pctimer_global {
    DWORD    dwRawHz;
    DWORD    dwMicroAdjust;
    union {
      DWORD    dwRawKhz;
      WORD     wRawKhz;
    };
    union {
      DWORD    dwRawMhz;
      WORD     wRawMhz;
    };
    DWORD    dwTimerKhz;
    PCTIMER  base;
    DWORD (WINAPI * DifTicks     )(PCTIMER *);
    DWORD (WINAPI * DifMicrosec  )(PCTIMER *);
    DWORD (WINAPI * DifMillisec  )(PCTIMER *);
    DWORD (WINAPI * DeltaTicks   )(PCTIMER *);
    DWORD (WINAPI * DeltaMicrosec)(PCTIMER *);
    DWORD (WINAPI * DeltaMillisec)(PCTIMER *);
    UINT     uTimerType;
    };
  typedef DWORD (WINAPI * PFNPCTIMER)(PCTIMER *);
  extern struct _pctimer_global pc;

  extern VOID WINAPI InitPerformanceCounters ();

  #define pcBegin()          pc.DeltaTicks(&pc.base)
  #define pcGetTime()        pc.DifMillisec(&pc.base)
  #define pcGetTicks()       pc.DifMicrosec(&pc.base)
  #define pcGetTickRate()   (pc.dwTimerKhz * 1000)
  #define pcBeginTimer(ppt) (pc.DeltaMicrosec(ppt), 0)
  #define pcDeltaTicks(ppt)  pc.DeltaMicrosec(ppt)

#endif //_INC_MMTIMERS_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if (defined _INC_MMTIMERS_CODE_) && (_INC_MMTIMERS_CODE_ != FALSE)
#undef _INC_MMTIMERS_CODE_
#define _INC_MMTIMERS_CODE_ FALSE

  static DWORD WINAPI tgtDeltaTime (PCTIMER *pctimer)
  {
        DWORD dwTime = timeGetTime();
        DWORD dwDelta = dwTime - pctimer->dwlo;
        pctimer->dwlo = dwTime;
        return dwDelta;
  }

  static DWORD WINAPI tgtDiffTime (PCTIMER *pctimer)
  {
        return timeGetTime() - pctimer->dwlo;
  }

  struct _pctimer_global pc = {1000, 0, 1, 0, 1,
                               0, 0,
                               (PFNPCTIMER)tgtDiffTime,
                               (PFNPCTIMER)tgtDiffTime,
                               (PFNPCTIMER)tgtDiffTime,
                               (PFNPCTIMER)tgtDeltaTime,
                               (PFNPCTIMER)tgtDeltaTime,
                               (PFNPCTIMER)tgtDeltaTime,
                               0,
                               };

  #if defined WIN32 || defined _WIN32

    #if !defined _X86_
      #define Scale(value,scalar) (DWORD)((value).QuadPart / (scalar))
    #else
      //
      // c9 wants to do LARGE_INTEGER division by calling a library
      // routine. We get a link error for projects that are not
      // already using the C-runtime, so to avoid that, we do the division
      // using x86 assembler
      //
      #pragma warning(disable:4704)
      #pragma warning(disable:4035)
      DWORD _inline Scale(
          LARGE_INTEGER value,
          DWORD         scalar)
      {
          _asm {
            mov  ecx, scalar
            mov  eax, value.LowPart
            mov  edx, value.HighPart
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
          }
      }
    #endif

    static VOID WINAPI qpcInitTimer (PCTIMER * pbase)
    {
       QueryPerformanceCounter ((LARGE_INTEGER *)pbase);
    }

    static DWORD WINAPI qpcDiffTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcDeltaTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LARGE_INTEGER *)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcTimerFreq ()
    {
       LARGE_INTEGER freq;
       if (QueryPerformanceFrequency (&freq))
          return freq.LowPart;
       return 0;
    }

    #ifdef _X86_

      #pragma warning(disable:4704)
      #pragma warning(disable:4035)

      static VOID WINAPI p5InitTimer (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            mov [ebx], eax
            mov [ebx+4], edx
         }
      }

      static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]
         }
      }

      static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx
         }
      }
      static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5TimerFreq ()
      {
          SYSTEM_INFO si;

          GetSystemInfo(&si);
          if (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
          {
             PCTIMER timer;
             LARGE_INTEGER qpc1, qpc2;
             DWORD   dwTime;
             DWORD   dwTicks;
             OSVERSIONINFO osv;
             #define MS_INTERVAL 500

             // pentium timers dont work correctly on NT so
             // dont use them
             //
             {
             osv.dwOSVersionInfoSize = sizeof(osv);
             GetVersionEx (&osv);
             }

             // dont use pentium timers if they take more
             // than about 12 microsec to execute
             //
             p5InitTimer  (&timer);
             if (p5DeltaTicks (&timer) > (60 * 12) &&
                 p5DeltaTicks (&timer) > (60 * 12))
             {
                // pentium timers are too slow to try and use them.
                // just go with QueryPerformanceCounter instead
                //
                return 0;
             }

             // for some reason, if you use timeBeginPeriod
             // on NT.  it decides that my 90mhz pentium is an 88mhz
             // pentium.
             //
             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeBeginPeriod (1);

             p5InitTimer (&timer);
             QueryPerformanceCounter (&qpc1);
             Sleep(MS_INTERVAL);
             QueryPerformanceCounter (&qpc2);
             dwTicks = p5DiffTicks(&timer);

             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeEndPeriod (1);

             dwTime = (DWORD)(qpc2.QuadPart - qpc1.QuadPart);
             QueryPerformanceFrequency (&qpc1);
             dwTime = MulDiv(dwTime, 1000, qpc1.LowPart);

             if (dwTime < MS_INTERVAL * 9 / 10)
                return 0;

             pc.dwRawMhz = (dwTicks + dwTime * 1000/2) /dwTime /1000;
             pc.dwRawKhz = pc.dwRawMhz * 1000;
             pc.dwRawHz  = pc.dwRawKhz * 1000;
             pc.dwMicroAdjust = 0;
             pc.dwTimerKhz = 1000;

             return pc.dwRawHz;
          }

          return 0;
      }

    #endif

    VOID WINAPI InitPerformanceCounters (void)
    {
        DWORD dwFreq;

       #ifdef _X86_
        if (p5TimerFreq())
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
       #endif

        if (dwFreq = qpcTimerFreq())
        {
            pc.dwRawKhz = dwFreq / 1000;
            pc.dwRawMhz = pc.dwRawKhz / 1000;
            pc.dwMicroAdjust = dwFreq / pc.dwRawMhz;
            if (pc.dwMicroAdjust == 1000000)
                pc.dwMicroAdjust = 0;
            pc.dwTimerKhz = 1000;

            pc.DifTicks      = qpcDiffTicks;
            pc.DifMicrosec   = qpcDiffMicrosec;
            pc.DifMillisec   = qpcDiffMillisec;
            pc.DeltaTicks    = qpcDeltaTicks;
            pc.DeltaMicrosec = qpcDeltaMicrosec;
            pc.DeltaMillisec = qpcDeltaMillisec;
            pc.uTimerType    = 1;
        }
    }

  #else // win16

    #pragma warning(disable:4704)
    #pragma warning(disable:4035)

    static VOID WINAPI p5InitTimer (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          mov [bx], ax
          _emit 0x66
          mov [bx+4], dx
       }
    }

    static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]
       }
    }

    static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          //_emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          _emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx
       }
    }
    static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          _emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          //_emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:

       }
    }

    // 16 bit code for detecting CPU type so we can decide
    // whether or not it is ok to use the pentium timing stuff
    //
    int WINAPI pcGetCpuID ()
    {
    _asm {
        _emit 0x66
        pushf       ; save eflags

        // check for 486 by attempting to set the 0x40000 bit
        // in eflags.  if we can set it, the processor is 486 or better
        //
        _emit 0x66
        pushf               ; push eflags
        pop   ax            ; move eflags to dx:ax
        pop   dx
        or    dx, 4         ; set 0x40000 bit in eflags
        push  dx            ; put back onto stack
        push  ax
        _emit 0x66
        popf                ; pop modified flags back into eflags
        _emit 0x66
        pushf               ; push eflags back onto stack
        pop   ax            ; move eflags in to dx:bx
        pop   dx

        _emit 0x66
        popf        ; restore origonal eflags

        mov   bx, 3 ; assume 386
        test  dx, 4 ; 486 will preserve 0x40000 bit on push/pop of eflags
        jz    ret_procid
        inc   bx    ; this is a 486 or higher

        // if we get to here it is a 486 or greater

        // check for pentium or higher by attempting to toggle the
        // ID bit (0x200000) in eflags.
        // on a pentium, this bit will toggle, on 486 it will not
        //
        _emit  0x66
        pushf                   ; save eflags
        _emit  0x66
        pushf                   ; get eflags
        pop    ax               ; put eflags into dx:ax
        pop    dx
        xor    dx, 0x20         ; toggle 0x200000 bit in eflags
        push   dx
        push   ax               ; push modified eflags from dx:ax
        _emit  0x66
        popf                    ; load changed eflags
        _emit  0x66
        pushf                   ; get eflags again
        pop    ax               ; discard eflags lo
        pop    ax               ; get eflags hi
        xor    dx, ax           ; did anything change?
        _emit  0x66             ; restore old eflags
        popf

        test   dx, 0x20         ; did we change the 20 bit?
        jz     ret_procid       ; if not, bx already has 4, return that

        // if we get to here, it is a pentium or greater

        // use the pentium CPUID instruction to detect exact processor
        // type
        //
        _emit 0x0F            ; cpuid instruction
        _emit 0xA2
        shr   ax, 8           ; extract family field
        and   ax, 0x0F
        mov   bx, ax          ; 5 is pentium, others are higher

       ret_procid:
        mov   ax, bx
        }
    }

    static DWORD WINAPI p5TimerFreq ()
    {
        if (pcGetCpuID() >= 5)
        {
           DWORD   dw;
           DWORD   dwTicks;
           static PCTIMER timer;

           p5InitTimer (&timer);
           dw = timeGetTime() + 200;
           while (timeGetTime() < dw)
               ;
           dw = timeGetTime() - dw;
           dwTicks = p5DiffTicks(&timer);

           pc.dwRawMhz = (dwTicks + dw * 1000/2) /dw /1000;
           pc.dwRawKhz = pc.dwRawMhz * 1000;
           pc.dwRawHz  = pc.dwRawKhz * 1000;
           pc.dwMicroAdjust = 0;
           pc.dwTimerKhz = 1000;

           return pc.dwRawHz;
        }

        return 0;
    }

    VOID WINAPI InitPerformanceCounters (void)
    {
        if (p5TimerFreq() != 0l)
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
    }

  #endif // WIN32

#endif // _INC_MMTIMERS_CODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\mmdebug.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

#if defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        #define STATICFN

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        void FAR _cdecl AuxRip(LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        LPCTSTR WINAPI AuxMMErrText(DWORD  mmr);
        int  WINAPI DebugSetOutputLevel (int,int);
        UINT WINAPI AuxFault (DWORD dwFaultMask);

       #if defined DEBUG_RETAIL && !defined DEBUG && !defined _DEBUG
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

        #define FAULT_HERE AuxFault

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

    #else // defined(DEBUG) || defined(_DEBUG)
                      
       #define AuxDebugEx  1 ? (void)0 :
       #define AuxDebugDump(a,b,c)
       #define AuxMMErrText(m)     NULL
       #define AuxRip  1 ? (void)0 :

       #define assert(a)          ((void)0)
       #define assert2(a,b)       ((void)0)
       #define assert3(a,b,c)     ((void)0)
       #define assert4(a,b,c,d)   ((void)0)
       #define assert5(a,b,c,d,e) ((void)0)

       #define FAULT_HERE    1 ? (void)0 :
       #define INLINE_BREAK
       #define DebugSetOutputLevel(i,j)
       #define STATICFN static

   #endif // defined(DEBUG) || defined _DEBUG || defined DEBUG_RETAIL

   #ifndef DPF_CATEGORY
    #define DPF_CATEGORY 0x0100
   #endif

   // translate DPF's only in internal debug builds
   //
   #if defined DEBUG || defined _DEBUG
       #define DUMP(n,a,b) AuxDebugDump (DPF_CATEGORY | (n), a, b)
       #define RIP AuxDebugEx (0, DEBUGLINE), AuxRip
       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0
       #define DPF(n,sz) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n")
       #define DPF1(n,sz,a) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a))
       #define DPF2(n,sz,a,b) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b))
       #define DPF3(n,sz,a,b,c) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c))
       #define DPF4(n,sz,a,b,c,d) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d))
       #define DPF5(n,sz,a,b,c,d,e) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(e))
       #define DPF6(n,sz,a,b,c,d,e,f) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f))
       #define DPF7(n,sz,a,b,c,d,e,f,g) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f),(g))
   #else
       #define DUMP(n,a,b)
       #define RIP AuxRip
       #define AuxMMR(api,mmr)
       #define DPF(n,sz)
       #define DPF1(n,sz,a)
       #define DPF2(n,sz,a,b)
       #define DPF3(n,sz,a,b,c)
       #define DPF4(n,sz,a,b,c,d)
       #define DPF5(n,sz,a,b,c,d,e)
       #define DPF6(n,sz,a,b,c,d,e,f)
       #define DPF7(n,sz,a,b,c,d,e,f,g)
   #endif
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

static struct _mmerrors {
   DWORD    mmr;
   LPCTSTR  psz;
   } aMMErr[] = {
      MMSYSERR_NOERROR      ,"Success",
   #ifdef DEBUG
      MMSYSERR_ERROR        ,"unspecified error",
      MMSYSERR_BADDEVICEID  ,"device ID out of range",
      MMSYSERR_NOTENABLED   ,"driver failed enable",
      MMSYSERR_ALLOCATED    ,"device already allocated",
      MMSYSERR_INVALHANDLE  ,"device handle is invalid",
      MMSYSERR_NODRIVER     ,"no device driver present",
      MMSYSERR_NOMEM        ,"memory allocation error",
      MMSYSERR_NOTSUPPORTED ,"function isn't supported",
      MMSYSERR_BADERRNUM    ,"error value out of range",
      MMSYSERR_INVALFLAG    ,"invalid flag passed",
      MMSYSERR_INVALPARAM   ,"invalid parameter passed",
     #if (WINVER >= 0x0400)
      MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
      MMSYSERR_INVALIDALIAS ,"specified alias not found",
      MMSYSERR_BADDB        ,"bad registry database",
      MMSYSERR_KEYNOTFOUND  ,"registry key not found",
      MMSYSERR_READERROR    ,"registry read error",
      MMSYSERR_WRITEERROR   ,"registry write error",
      MMSYSERR_DELETEERROR  ,"registry delete error",
      MMSYSERR_VALNOTFOUND  ,"registry value not found",
      MMSYSERR_NODRIVERCB   ,"Never got a 32 bit callback from driver",
     #endif // WINVER >= 0x400

      WAVERR_BADFORMAT      ,"wave:unsupported wave format",
      WAVERR_STILLPLAYING   ,"wave:still something playing",
      WAVERR_UNPREPARED     ,"wave:header not prepared",
      WAVERR_SYNC           ,"wave:device is synchronous",

      MIDIERR_UNPREPARED    ,"midi:header not prepared",
      MIDIERR_STILLPLAYING  ,"midi:still something playing",
      //MIDIERR_NOMAP         ,"midi:no configured instruments",
      MIDIERR_NOTREADY      ,"midi:hardware is still busy",
      MIDIERR_NODEVICE      ,"midi:port no longer connected",
      MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
      #ifdef CHICAGO
      MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",
      #endif

      TIMERR_NOCANDO        ,"timer: request not completed",
      JOYERR_PARMS          ,"joy:bad parameters",
      JOYERR_NOCANDO        ,"joy:request not completed",
      JOYERR_UNPLUGGED      ,"joystick is unplugged",

      MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
      MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
      MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
      MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
      MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
      MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
      MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
      MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
      MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
      MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
      MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
      MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
      MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
      MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
      MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
      MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
      MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
      MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
      MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
      MCIERR_DRIVER                   ,"MCIERR_DRIVER",
      MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
      MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
      MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
      MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
      MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
      MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
      MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
      MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
      MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
      MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
      MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
      MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
      MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
      MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
      MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
      MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
      MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
      MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
      MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
      MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
      MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
      MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
      MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
      MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
      MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
      MCIERR_GET_CD                   ,"MCIERR_GET_CD",
      MCIERR_SET_CD                   ,"MCIERR_SET_CD",
      MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
      MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
      MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
      MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
      MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
      MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
      MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
      MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
      MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
      MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
      MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
      MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
      MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
      MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
      MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
      MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
      MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
      MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
      MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
      MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
      MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
      MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
      MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
      MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
      MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
      MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
     #ifdef CHICAGO
      MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

      MIXERR_INVALLINE            ,"Invalid Mixer Line",
      MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
      MIXERR_INVALVALUE           ,"Invalid Mixer Value",
     #endif // CHICAGO
   #endif // DEBUG
      0xFFFFFFFE                  , "unknown error %d"
      };

    struct _mmdebug {
        int    Level;
        int    Mask;
        int    StopOnRip;
        DWORD  TakeFault;
        struct _mmerrors *paErrs;
        BOOL   Initialized;
        HANDLE hOut;
        } mmdebug = {0, 0xFF, 0, 0xFF, aMMErr};

    /*+ AuxFault
     *
     *-=================================================================*/

     UINT WINAPI AuxFault (
         DWORD dwFaultMask)
     {
         LPUINT pData = NULL;

         if (dwFaultMask & mmdebug.TakeFault)
            return *pData;
         return 0;
     }


    /*+ AuxOut - write a string to designated debug out
     *
     *-=================================================================*/

   void WINAPI AuxOut (
      LPTSTR psz)
      {
     #ifdef WIN32
      if (mmdebug.hOut)
         {
         UINT  cb = lstrlen(psz);
         DWORD dw;
         if (INVALID_HANDLE_VALUE != mmdebug.hOut)
            WriteFile (mmdebug.hOut, psz, cb, &dw, NULL);
         }
      else
     #endif
         {
        #ifdef DbgLog
         DbgOutString (psz); // from \quartz\sdk\classes\base\debug.cpp
        #else
         OutputDebugString (psz);
        #endif
         }
      }

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       int      cb;
       va_list  va;
       LPSTR    psz;

       // mask the iLevel passed with mmdebug.Mask. if this ends up
       // clearing the high bits then iLevel has a shot being smaller
       // than mmdebug.Level.  if not, then the second test will always
       // fail.  Thus mmdebug.Mask has bits set to DISABLE that category.
       // 
       // note that we always pass messages that have an iLevel < 0.
       // this level corresponds to Asserts & Rips so we always want to see them.
       //
       if (iLevel < 0 || mmdebug.Level >= (iLevel & mmdebug.Mask))
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          // if we begin with a drive letter, strip off all but filename
          //  
          if (psz[0] && psz[1] == ':')
             {
             UINT ii = 2;
             for (ii = 2; psz[ii] != 0; ++ii)
                 if (psz[ii] == '\\')
                    psz += ii+1, ii = 0;
             }

          // write to standard out if we have a handle. otherwise write to 
          // the debugger
          //
         #ifdef MODULE_DEBUG_PREFIX
          if (psz != szBuf)
             AuxOut (MODULE_DEBUG_PREFIX);
         #endif
          AuxOut (psz);
          }

       return cb;
       }

    /*+ AuxRip
     *
     *-=================================================================*/

    void FAR _cdecl AuxRip (
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       va_list  va;
       LPSTR    psz;
                
       va_start (va, lpFormat);
       wvsprintfA (szBuf, lpFormat, va);
       va_end (va);

       // eat leading ..\..\ which we get from __FILE__ since
       // george's wierd generic makefile stuff.
       //
       psz = szBuf;
       while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
          psz += 3;

       AuxOut ("RIP: ");
       AuxOut (psz);
       AuxOut ("\r\n");

       if (mmdebug.StopOnRip)
          {
         #if !defined _WIN32 || defined _X86_
          _asm {int 3};
         #else
          DebugBreak();
         #endif
          }
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if ((mmdebug.Level < (iLevel & mmdebug.Mask)) || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          #ifdef MODULE_DEBUG_PREFIX
           AuxOut (MODULE_DEBUG_PREFIX);
          #endif

          AuxOut (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            wsprintf (szTemp, "error %d 0x%X", mmr, mmr);
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel,
        int nMask)
        {
        int nOldLevel = mmdebug.Level;

        if (!mmdebug.Initialized)
           {
          #ifdef WIN32
           TCHAR szFile[MAX_PATH];
           mmdebug.TakeFault = GetProfileInt("Debug", "FaultMask", 1);

           GetProfileString("Debug", "MMDebugTo", "", szFile, sizeof(szFile));
           if (!lstrcmpi(szFile, "Console"))
              {
              mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
              if (!mmdebug.hOut || mmdebug.hOut == INVALID_HANDLE_VALUE)
                 {
                 AllocConsole ();
                 mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
                 if (mmdebug.hOut == INVALID_HANDLE_VALUE)
                    mmdebug.hOut = NULL;
                 }
              SetConsoleTitle (MODULE_DEBUG_PREFIX " Debug Output");
              }
           else if (szFile[0] &&
                    lstrcmpi(szFile, "Debug") &&
                    lstrcmpi(szFile, "Debugger") &&
                    lstrcmpi(szFile, "Deb"))
              {
              mmdebug.hOut = CreateFile(szFile, GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
              if (INVALID_HANDLE_VALUE != mmdebug.hOut)
                 SetFilePointer (mmdebug.hOut, 0, NULL, FILE_END);
              }
          #endif
           mmdebug.Initialized = TRUE;
           }

        mmdebug.Level = (nLevel & 0xFF);
        mmdebug.Mask  = (nMask | 0xFF);
        return nOldLevel;
        }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}
#endif // _cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\mmdevldr.inc ===
;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1993 - 1995
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

MMDEVLDR_API_MMSystem_Up        equ 0			;Internal
MMDEVLDR_API_Continue		equ 1			;Internal
MMDEVLDR_API_QueryVxD           equ 2                   ;Internal
MMDEVLDR_API_QueueCallback32    equ 3                   ;Internal
MMDEVLDR_API_SetEvent           equ 4                   ;Internal
MMDEVLDR_API_PageAllocate       equ 5                   ;Internal
MMDEVLDR_API_PageFree           equ 6                   ;Internal
MMDEVLDR_APIS                   equ 7                   ;Internal
									;Internal
;;This is the only SERVICE we export. Multimedia Vxds use this SERVICE	;Internal
;;to register the PNP Configuration Handler Procedure.			;Internal
ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	MMDEVLDR_Set_Device_Presence, LOCAL
End_Service_Table MMDEVLDR	

MMDEVLDR_IOCTL_GETVERSION       equ     0		;Internal
MMDEVLDR_IOCTL_LINPAGELOCK      equ     1		;Internal
MMDEVLDR_IOCTL_LINPAGEUNLOCK    equ     2		;Internal
MMDEVLDR_IOCTL_RING0THREADHANDLE equ    3		;Internal
MMDEVLDR_IOCTL_QUEUEAPC         equ     4		;Internal
MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR equ   5		;Internal
MMDEVLDR_IOCTL_CLOSEVXDHANDLE   equ     6		;Internal
MMDEVLDR_IOCTL_PAGEALLOCATE     equ     7		;Internal
MMDEVLDR_IOCTL_PAGEFREE         equ     8		;Internal
MMDEVLDR_IOCTL_GETDEVICESTATUS  equ     9		;Internal
							;Internal
MM_DEVSTATUS_ERROR          equ 0			;Internal
MM_DEVSTATUS_STARTED        equ 1			;Internal
MM_DEVSTATUS_UNKNOWNPROB    equ 2			;Internal
MM_DEVSTATUS_DISABLED       equ 3			;Internal
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\resource.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#define IDD_PROPERTIES   300
#define IDS_NAME	 299

#define ID_SOURCE        301
#define ID_FORMAT        302
#define ID_DISPLAY       303
#define ID_FRAMESCAPTURED 304
#define ID_FRAMESDROPPED 305
#define ID_FRAMESPERSEC  306
#define ID_BYTESPERSEC   307
#define ID_MSCAPTURED    308
#define ID_XXX1		 309
#define ID_XXX2		 310
#define ID_XXX3		 311
#define ID_XXX4		 312
#define ID_XXX5		 313
#define ID_XXX6		 314
#define ID_XXX7		 315
#define ID_XXX8		 316
#define ID_XXX9		 317
#define ID_DESC		 318
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\outpin.cpp ===
/*+
 *
 * Implement CCapStream
 *
 *-== Copyright (c) Microsoft Corporation 1996. All Rights Reserved ==*/


#include <streams.h>
#include "driver.h"
#include "common.h"

// turn on performance measuring code
//
//#define JMK_HACK_TIMERS
#include "cmeasure.h"

// ============== Implements the CAviStream class ==================

CCapStream * CreateStreamPin (
   CVfwCapture * pCapture,
   UINT          iVideoId,
   HRESULT     * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::CreateStreamPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"~Capture");

   CCapStream * pStream = new CCapStream(NAME("Video Capture Stream"),
				pCapture, iVideoId, phr, wszPinName);
   if (!pStream)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pStream)
      delete pStream, pStream = NULL;

   return pStream;
}


#pragma warning(disable:4355)
CCapStream::CCapStream(TCHAR *pObjectName, CVfwCapture *pCapture, UINT iVideoId,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_Alloc(NAME("Cap stream allocator"), this, phr),
   m_pCap(pCapture),
   m_pmt(NULL),
   m_hThread(NULL),
   m_state(TS_Not),
   m_hEvtPause(NULL),
   m_hEvtRun(NULL),
   m_pBufferQueue(NULL),
   m_tid(0),
   m_rtLatency(0),
   m_rtStreamOffset(0),
   m_rtMaxStreamOffset(0),
   m_pDrawPrimary(0),
   m_pdd(0)
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream constructor")));
    ASSERT(pCapture);

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS )
   {
       HRESULT hrTmp = CoCreateInstance(
           CLSID_DirectDraw, NULL, CLSCTX_ALL, IID_IDirectDraw, (void **)&m_pdd);
       if(SUCCEEDED(hrTmp))
       {
           hrTmp = m_pdd->Initialize(0);

           if(SUCCEEDED(hrTmp)) {
               hrTmp = m_pdd->SetCooperativeLevel(0, DDSCL_NORMAL);
           }

           if(FAILED(hrTmp)) {
               m_pdd->Release();
               m_pdd = 0;
           }
       }
   }
    
   ZeroMemory (&m_user, sizeof(m_user));
   ZeroMemory (&m_cs, sizeof(m_cs));
   ZeroMemory (&m_capstats, sizeof(m_capstats));

   // initialize to no suggestion from app (IAMBufferNegotiation)
   m_propSuggested.cBuffers = -1;
   m_propSuggested.cbBuffer = -1;
   m_propSuggested.cbAlign = -1;
   m_propSuggested.cbPrefix = -1;

   // use the capture device we're told to
   m_user.uVideoID      = iVideoId;

   // !!! Is it evil to hold resource for life of filter?
   if (SUCCEEDED(*phr))
      *phr = ConnectToDriver();

   if (SUCCEEDED(*phr))
      *phr = LoadOptions();

   jmkAlloc   // allocate and init perf logging buffers
   jmkInit

   // make sure allocator doesn't get destroyed until we are ready for it to.
   // ???
   //m_Alloc.NonDelegatingAddRef();

#ifdef PERF
   m_perfWhyDropped = MSR_REGISTER(TEXT("cap why dropped"));
#endif // PERF;
}


CCapStream::~CCapStream()
{
   if(m_pdd) {
       m_pdd->Release();
   }
    
   DbgLog((LOG_TRACE,1,TEXT("CCapStream destructor")));

   // we don't let go of resources until the filter goes away
   // done when we leave the graph // DisconnectFromDriver();

   jmkFree   // free perf logging buffers

   // freed when we leave the filtergraph
   // delete [] m_cs.tvhPreview.vh.lpData;

   // freed in Unprepare
   // delete m_cs.pSamplePreview;

   // freed when we leave the filtergraph
   // delete m_user.pvi;

   if (m_hThread)
      CloseHandle (m_hThread);
   m_hThread = NULL;

   DbgLog((LOG_TRACE,2,TEXT("CCapStream destructor finished")));
}


STDMETHODIMP CCapStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
#if 0
    if (riid == IID_IMediaPosition)
	return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    if (riid == IID_IMemAllocator) {
	return GetInterface((IMemAllocator *)&m_Alloc, ppv);
#endif
    if (riid == IID_IAMStreamConfig) {
	return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else if (riid == IID_IAMDroppedFrames) {
	return GetInterface((LPUNKNOWN)(IAMDroppedFrames *)this, ppv);
    } else if (riid == IID_IAMBufferNegotiation) {
	return GetInterface((LPUNKNOWN)(IAMBufferNegotiation *)this, ppv);
    } else if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
    return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
	return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

   return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}

int CCapStream::ProfileInt(
   LPSTR pszKey,
   int   iDefault)
{
   return GetProfileIntA ("Capture", pszKey, iDefault);
}

void CCapStream::ReduceScaleAndRate (void)
{
   // this is a macro to allow the optimizer to take advantage of the
   // fact the factor is a constant at compile time
   //
   #define ReduceByFactor(factor) {                 \
      while (!(m_user.dwTickRate % (factor))) {     \
         if (!(m_user.dwTickScale % (factor)))      \
            m_user.dwTickScale /= (factor);         \
         else                                       \
            break;                                  \
         m_user.dwTickRate /= (factor);             \
         }                                          \
      }

   ReduceByFactor (5);
   ReduceByFactor (3);
   ReduceByFactor (2);

   #undef ReduceByFactor
}

// Allocates a VIDEOINFOHEADER big enough to hold the given format
static VIDEOINFOHEADER * AllocVideoinfo(LPBITMAPINFOHEADER lpbi)
{
   UINT cb = GetBitmapFormatSize(lpbi);
   VIDEOINFOHEADER * pvi = (VIDEOINFOHEADER *)(new BYTE[cb]);
   if (pvi)
      ZeroMemory(pvi, cb);
   return pvi;
}

//
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
//

HRESULT
CCapStream::LoadOptions (void)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream LoadOptions")));

   // make something (anything) valid to start with
   static BITMAPINFOHEADER bmih = {
      sizeof (BITMAPINFOHEADER),                    //biSize
      1,                                            //biWidth
      1,                                            //biHeight
      1,                                            //biPlanes
      16,                                  	    //biBitCount

      BI_RGB,                                       //biCompression
      WIDTHBYTES(160 * 16) * 120,   		    //biSizeImage
      0,                                            //biXPelsPerMeter
      0,                                            //biYPelsPerMeter
      0,                                            //biClrUsed
      0                                             //biClrImportant
   };
   LPBITMAPINFOHEADER pbih = &bmih;

// I connect earlier now
#if 0
   m_user.uVideoID      = ProfileInt("VideoID", 0);
   HRESULT hr = ConnectToDriver();
   if (FAILED(hr))
      return hr;
#endif
   HRESULT hr = S_OK;

   m_user.dwLatency   = ProfileInt("Latency", 666666);	// 1/15 second
   m_user.dwTickScale   = ProfileInt("TickScale", 100);
   m_user.dwTickRate    = ProfileInt("TickRate", 2997);	// 29.97 fps
   // !! change at your own risk... 16 bit guy won't know it
   m_user.nMinBuffers   = ProfileInt("MinBuffers", MIN_VIDEO_BUFFERS);
   m_user.nMaxBuffers   = ProfileInt("MaxBuffers", MAX_VIDEO_BUFFERS);
   DbgLog((LOG_TRACE,2,TEXT("Min # buffers=%d  Max # buffers=%d"),
				m_user.nMinBuffers, m_user.nMaxBuffers));

// !!! TEST
#if 0
    ALLOCATOR_PROPERTIES prop;
    IAMBufferNegotiation *pBN;
    prop.cBuffers = ProfileInt("cBuffers", MAX_VIDEO_BUFFERS);
    prop.cbBuffer = ProfileInt("cbBuffer", 65536);
    prop.cbAlign = ProfileInt("cbAlign", 4);
    prop.cbPrefix = ProfileInt("cbPrefix", 0);
    hr = QueryInterface(IID_IAMBufferNegotiation, (void **)&pBN);
    if (hr == NOERROR) {
	pBN->SuggestAllocatorProperties(&prop);
 	pBN->Release();
    }
#endif

   //
   // REFERENCE_TIME and dwScale & dwTickRate are both large
   // numbers, we strip off the common factors from dwRate/dwScale
   //
   ReduceScaleAndRate();
   DbgLog((LOG_TRACE,2,TEXT("Default Scale=%d Rate=%d"), m_user.dwTickScale,
							m_user.dwTickRate));

   // create a VIDEOINFOHEADER for the m_user structure
   //
   m_user.pvi = AllocVideoinfo(pbih);
   if (!m_user.pvi) {
      hr = E_OUTOFMEMORY;
   } else {

      CopyMemory(&m_user.pvi->bmiHeader, pbih, pbih->biSize);

      // start with no funky rectangles
      m_user.pvi->rcSource.top = 0; m_user.pvi->rcSource.left = 0;
      m_user.pvi->rcSource.right = 0; m_user.pvi->rcSource.bottom = 0;
      m_user.pvi->rcTarget.top = 0; m_user.pvi->rcTarget.left = 0;
      m_user.pvi->rcTarget.right = 0; m_user.pvi->rcTarget.bottom = 0;

      HRESULT hrT = GetFormatFromDriver ();
      if (FAILED(hrT))
            hr = hrT;

      // if this is a palettized mode, get the palette
      //
      if (m_user.pvi->bmiHeader.biBitCount <= 8) {
         HRESULT hrT = InitPalette ();
         if (FAILED(hrT))
            hr = hrT;
      }

      // Now send the format back to the driver, because AVICAP did, and we
      // have to do everything it does, or somebody's driver will hang...
      // ... in this case the ISVRIII NT
      SendFormatToDriver(m_user.pvi);

      // grab a frame to kick the driver in the head or preview won't work until
      // we start streaming capture
      THKVIDEOHDR tvh;
      ZeroMemory (&tvh, sizeof(tvh));
      tvh.vh.dwBufferLength = m_user.pvi->bmiHeader.biSizeImage;
      DWORD dw = vidxAllocPreviewBuffer(m_cs.hVideoIn, (LPVOID *)&tvh.vh.lpData,
                                    sizeof(tvh.vh), tvh.vh.dwBufferLength);
      if (dw == 0) {
          tvh.p32Buff = tvh.vh.lpData;
          dw = vidxFrame(m_cs.hVideoIn, &tvh.vh);
          vidxFreePreviewBuffer(m_cs.hVideoIn, (LPVOID *)&tvh.vh.lpData);
      }

      m_user.pvi->AvgTimePerFrame = TickToRefTime (1);
      // we don't know our data rate.  Sorry.  Hope nobody minds
      m_user.pvi->dwBitRate = 0;
      m_user.pvi->dwBitErrorRate = 0;

      // set the size of the VIDEOINFOHEADER to the size of valid data
      // for this format.
      //
      m_user.cbFormat = GetBitmapFormatSize(&m_user.pvi->bmiHeader);
   }

// we need to stay connected or the driver will forget what we just told it
#if 0
   DisconnectFromDriver();
#endif
   return hr;
}

// set user settings from the supplied buffer
//
HRESULT CCapStream::SetOptions (
    const VFWCAPTUREOPTIONS * pUser)
{
   if (m_user.pvi)
	delete m_user.pvi;
   m_user = *pUser;
   if (m_user.pvi)
      {
      m_user.pvi = AllocVideoinfo(&pUser->pvi->bmiHeader);
      if (m_user.pvi)
          CopyMemory (m_user.pvi, pUser->pvi, pUser->cbFormat);
      else
         return E_OUTOFMEMORY;
      }
   return S_OK;
}

// copy user settings into the supplied structure
//
HRESULT CCapStream::GetOptions (
   VFWCAPTUREOPTIONS * pUser)
{
   *pUser = m_user;
   if (m_user.pvi)
      {
	// caller will free this
      pUser->pvi = AllocVideoinfo(&m_user.pvi->bmiHeader);
      if (pUser->pvi)
         CopyMemory(pUser->pvi, m_user.pvi, m_user.cbFormat);
      else
         return E_OUTOFMEMORY;
      };

   return S_OK;
}

HRESULT CCapStream::GetMediaType(
   int          iPosition,
   CMediaType * pMediaType)
{
   DbgLog((LOG_TRACE,3,TEXT("CCapStream GetMediaType")));

   // check it is the single type they want
   if (iPosition < 0)
       return E_INVALIDARG;
   if (iPosition > 0 ||  ! m_user.pvi)
       return VFW_S_NO_MORE_ITEMS;

   pMediaType->majortype = MEDIATYPE_Video;
   pMediaType->subtype   = GetBitmapSubtype(&m_user.pvi->bmiHeader);
   // I'm trusting the driver to give me the biggest possible size
   pMediaType->SetSampleSize (m_user.pvi->bmiHeader.biSizeImage);
   // !!! This is NOT necessarily true
   pMediaType->bTemporalCompression = FALSE;
   pMediaType->SetFormat ((BYTE *)m_user.pvi, m_user.cbFormat);
   pMediaType->formattype = FORMAT_VideoInfo;

   return S_OK;
}


// check if the pin can support this specific proposed type and format
//
HRESULT CCapStream::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr;

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_POINTER;
    }

    DbgLog((LOG_TRACE,3,TEXT("CheckMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: not VIDEO")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: format not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    RECT rcS = ((VIDEOINFOHEADER *)pmt->Format())->rcSource;
    RECT rcT = ((VIDEOINFOHEADER *)pmt->Format())->rcTarget;
    if (!IsRectEmpty(&rcT) && (rcT.left != 0 || rcT.top != 0 ||
			HEADER(pmt->Format())->biWidth != rcT.right ||
			HEADER(pmt->Format())->biHeight != rcT.bottom)) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: can't use funky rcTarget")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    // We don't know what this would be relative to... reject everything
    if (!IsRectEmpty(&rcS)) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: can't use funky rcSource")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // quickly test to see if this is the current format (what we provide in
    // GetMediaType).  We accept that
    //
    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pmt) {
	DbgLog((LOG_TRACE,3,TEXT("CheckMediaType SUCCEEDED")));
	return NOERROR;
    }

   // The only other way to see if we accept something is to set the hardware
   // to use that format, and see if it worked.  (Remember to set it back)

   // This is a BAD IDEA IF WE ARE CAPTURING RIGHT NOW.  Sorry, but I'll have
   // to fail. I can't change the capture format.
   if (m_pCap->m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

   VIDEOINFOHEADER *pvi = m_user.pvi;
   if (FAILED(hr = SendFormatToDriver((VIDEOINFOHEADER *)(pmt->Format())))) {
	DbgLog((LOG_TRACE,3,TEXT("CheckMediaType FAILED")));
	return hr;
   }
   EXECUTE_ASSERT(SendFormatToDriver(pvi) == S_OK);

   DbgLog((LOG_TRACE,3,TEXT("CheckMediaType SUCCEEDED")));
   return NOERROR;
}


// set the new media type
//
HRESULT CCapStream::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("SetMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

    ASSERT(m_pCap->m_State == State_Stopped);

    if (FAILED(hr = SendFormatToDriver((VIDEOINFOHEADER *)(pmt->Format())))) {
	ASSERT(FALSE);	// we were promised this would work
	DbgLog((LOG_ERROR,1,TEXT("ACK! SetMediaType FAILED")));
	return hr;
    }

    // Now remember that this is the current format
    CopyMemory(m_user.pvi, pmt->Format(), SIZE_PREHEADER);
    CopyMemory(&m_user.pvi->bmiHeader, HEADER(pmt->Format()),
					HEADER(pmt->Format())->biSize);

    // Set the frame rate to what was in the media type, if there is one
    if (((VIDEOINFOHEADER *)(pmt->pbFormat))->AvgTimePerFrame) {
 	const LONGLONG ll = 100000000000;
	m_user.dwTickScale = 10000;
	m_user.dwTickRate = (DWORD)(ll /
			((VIDEOINFOHEADER *)(pmt->pbFormat))->AvgTimePerFrame);
	ReduceScaleAndRate();
        DbgLog((LOG_TRACE,2,TEXT("SetMediaType: New frame rate is %d/%dfps"),
				m_user.dwTickRate, m_user.dwTickScale));
    }

    // now reconnect our preview pin to use the same format as us
    Reconnect(FALSE);

    return CBasePin::SetMediaType(pmt);
}


HRESULT CCapStream::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pProperties)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream DecideBufferSize")));

   ASSERT(pAllocator);
   ASSERT(pProperties);

    // the user has requested something specific?
    if (m_propSuggested.cBuffers > 0) {
	pProperties->cBuffers = m_propSuggested.cBuffers;
    // otherwise we want all the buffers we can
    } else {
        pProperties->cBuffers = MAX_VIDEO_BUFFERS;
    }

    // the user has requested a specific prefix
    if (m_propSuggested.cbPrefix >= 0)
	pProperties->cbPrefix = m_propSuggested.cbPrefix;

    // the user has requested a specific alignment
    if (m_propSuggested.cbAlign > 0)
	pProperties->cbAlign = m_propSuggested.cbAlign;

   // don't blow up
   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 1;

   // the user has a preference for buffer size
   if (m_propSuggested.cbBuffer > 0)
       pProperties->cbBuffer = m_propSuggested.cbBuffer;
   // I'm trusting the driver to set biSizeImage to the largest possible size
   // This is how big we need each buffer to be
   else if (m_user.pvi && (long)m_user.pvi->bmiHeader.biSizeImage >
						pProperties->cbBuffer)
       pProperties->cbBuffer = (long)m_user.pvi->bmiHeader.biSizeImage;

   // I don't remember why, but this IS IMPORTANT
   pProperties->cbBuffer = (long)ALIGNUP(pProperties->cbBuffer +
   				pProperties->cbPrefix, pProperties->cbAlign) -
   				pProperties->cbPrefix;

   ASSERT(pProperties->cbBuffer);

   DbgLog((LOG_TRACE,2,TEXT("Using %d buffers, prefix %d size %d align %d"),
			pProperties->cBuffers, pProperties->cbPrefix,
			pProperties->cbBuffer,
			pProperties->cbAlign));

   //
   // note that for the capture pin we don't want to specify any default
   // latency, this way when the graph isn't doing any audio preview the
   // the most this stream's offset will ever be is the latency reported
   // by the preview pin (1 frame currently)
   //
   m_rtLatency = 0;
   m_rtStreamOffset = 0;
   m_rtMaxStreamOffset = 0;

   ALLOCATOR_PROPERTIES Actual;
   return pAllocator->SetProperties(pProperties,&Actual);

   // It's our allocator, we know we'll be happy with what it decided

}

//
//  Override DecideAllocator because we insist on our own allocator since
//  it's 0 cost in terms of bytes
//
HRESULT
CCapStream::DecideAllocator(
   IMemInputPin   *pPin,
   IMemAllocator **ppAlloc)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream DecideAllocator")));

   *ppAlloc = (IMemAllocator *)&m_Alloc;
   (*ppAlloc)->AddRef();

   // get downstream prop request
   // the derived class may modify this in DecideBufferSize, but
   // we assume that he will consistently modify it the same way,
   // so we only get it once
   ALLOCATOR_PROPERTIES prop;
   ZeroMemory(&prop, sizeof(prop));

   // whatever he returns, we assume prop is either all zeros
   // or he has filled it out.
   pPin->GetAllocatorRequirements(&prop);

   HRESULT hr = DecideBufferSize(*ppAlloc,&prop);
   if (SUCCEEDED(hr))
      {
      // our buffers are not read only
      hr = pPin->NotifyAllocator(*ppAlloc,FALSE);
      if (SUCCEEDED(hr))
         return NOERROR;
      }

   (*ppAlloc)->Release();
   *ppAlloc = NULL;
   return hr;
}

// =================== IPin interfaces ===========================
//

// all in base classes
#if 0
//
// return an qzTaskMemAlloc'd string containing the name
// of the current pin.  memory allocated by qzTaskMemAlloc
// will be freed by the caller
//
STDMETHODIMP CCapStream::QueryId (
   LPWSTR *ppwsz)
{
    int ii = m_pCap->FindPinNumber(this);
    if (ii < 0)
       return E_INVALIDARG;

    *ppwsz = (LPWSTR)QzTaskMemAlloc(sizeof(WCHAR) * 8);
    IntToWstr(ii, *ppwsz);
    return NOERROR;
}
#endif

//
// ThreadProc for a stream.
//
// General strategy for thread synchronization:
//   as much as possible we try to handle thread state transitions without
//   trying to grab any critical sections. we use InterlockedExchange of a
//   thread state variable and count on the fact that only Active and Inactive
//   and the ThreadProc can change the thread state
//
//   this works because: the caller of Active/Inactive is serialized so we
//   will never try to make two state changes simultaneously.
//   so state transitions boil down to a few simple possibilities:
//
//   Not->Create   - Create() does this. effectively serializes Create
//                   so that the first thread does the work and subsequent
//                   threads fail.
//
//   Create->Init  - worker does this when it starts up. worker will always
//                   proceed to Pause, this state exists only to make debugging
//                   easier.
//   Init->Pause   - worker does this when done with initialization.
//
//   Pause->Run    - user does  this via Run()
//   Run->Pause    - user does this via Pause()
//
//   Run->Stop     - user does this via Stop()
//   Pause->Stop   - user does this via Stop()
//
//   Stop->Destroy - another debugging state. worker sets destroy to indicate
//                   that it has noticed Stop request and is not shutting down
//                   thread always proceeds to Exit from
//   Destroy->Exit - worker does this prior to dying.  this is a debug transition
//   Exit->Not     - Destroy() does this after waiting for the worker to die.
//
//   When Active returns, worker should always be in Pause or Run state
//   When Inactive returns, worker should always be in Not state (worker does
//      not exist)
//
DWORD CCapStream::ThreadProc()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream ThreadProc")));

   ThdState state; // current state
   state = ChangeState (TS_Init);
   ASSERT (state == TS_Create);

// we connect earlier now
#if 0
   HRESULT hr = ConnectToDriver();
   if (hr)
      goto bail;
#endif

   // do the work necessary to go into the paused state
   //
   HRESULT hr = Prepare();
   if (hr) {
       DbgLog((LOG_ERROR,1,TEXT("*** Error preparing the allocator. Can't capture")));
       SetEvent(m_hEvtPause);	// main thread is blocked right now!
       goto bail;
   }

   // goto into paused state
   //
   state = ChangeState (TS_Pause);
   ASSERT (state == TS_Init);
   SetEvent(m_hEvtPause);

   while (m_state != TS_Stop) {

       // don't start capturing until we run (or stop)
       WaitForSingleObject(m_hEvtRun, INFINITE);
       ResetEvent(m_hEvtRun);

       // stream until not running, or we get an error
       Capture();

   }

   // we expect to be in the Stop state when we get to here.
   // flush any downstream buffers.
   //
   ASSERT (m_state == TS_Stop);
   ResetEvent(m_hEvtPause);	// for next time we pause
   Flush();

bail:
   // change the state to destroy to indicate that we are exiting
   //
   state = ChangeState (TS_Destroy);

   // free stuff
   //
   Unprepare();

   // stay connected now
   // DisconnectFromDriver();

   // change state to Exit and then get out of here
   //
   ChangeState (TS_Exit);
   return 0;
}

DWORD WINAPI CCapStream::ThreadProcInit (void * pv)
{
   CCapStream * pThis = (CCapStream *) pv;
   return pThis->ThreadProc();
}

// create the worker thread for this stream
//
BOOL CCapStream::Create()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Create")));

   // return fail if someone else is already creating / has created
   // the worker thread
   //
   ASSERT (m_state == TS_Not);
   if (ChangeState(TS_Create) > TS_Not)
      return FALSE;

   ASSERT (!m_hEvtPause);
   m_hEvtPause = CreateEvent(NULL, TRUE, FALSE, NULL);
   if (!m_hEvtPause)
      goto bail;
   ASSERT (!m_hEvtRun);
   m_hEvtRun = CreateEvent(NULL, TRUE, FALSE, NULL);
   if (!m_hEvtRun)
      goto bail;


   m_hThread = CreateThread (NULL, 0,
                             CCapStream::ThreadProcInit,
                             this,
                             0,
                             &m_tid);
   if ( ! m_hThread)
      goto bail;

   return m_hThread != NULL;

bail:
   if (m_hEvtPause)
      CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
   if (m_hEvtRun)
      CloseHandle(m_hEvtRun), m_hEvtRun = NULL;

   m_state = TS_Not;
   return FALSE;
}

// Wait for the worker thread to die
//
BOOL CCapStream::Destroy()
{
   // return trivial success if there is nothing to destroy
   //
   if (m_state == TS_Not)
      return TRUE;

   // Wait for the thread to die. (Destroy must be preceeded by
   // a Stop or we could deadlock here)
   //
   ASSERT (m_state >= TS_Stop);
   WaitForSingleObject (m_hThread, INFINITE);
   ASSERT (m_state == TS_Exit);

   // cleanup
   //
   CloseHandle(m_hThread), m_hThread = NULL;
   m_tid = 0;
   CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
   CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
   m_state = TS_Not;
   return TRUE;
}

// set the worker thread into the run state.  This call
// does not wait for the state transition to be complete before
// returning.
//
BOOL CCapStream::Run()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Run")));

   // a transition to run state is only valid if the current
   // state is Pause (or already Running)
   //
   ThdState state = m_state;
   if (state != TS_Run && state != TS_Pause)
      return FALSE;

   // change the state and turn on the 'run' event
   // in case the thread is blocked on it.  If state that we are
   // changing from is not Run or Pause, then something is seriously wrong!!
   //
   state = ChangeState(TS_Run);
   ASSERT(state == TS_Run || state == TS_Pause);
   SetEvent(m_hEvtRun);
   // Go capture, go! Note when we started it
   if (m_pCap->m_pClock)
       m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtDriverStarted);
   else
       m_cs.rtDriverStarted = m_pCap->m_tStart;	
   videoStreamStart(m_cs.hVideoIn);
   // these need to be zeroed every time the driver is told to stream, because
   // the driver will start counting from 0 again
   m_cs.dwlLastTimeCaptured = 0;
   m_cs.dwlTimeCapturedOffset = 0;
   return TRUE;
}

// put the stream into the paused state and wait for it to get there.
// if the current state is Pause, returns trivial success;
// if the current state is not Run or Init, returns FALSE for failure.
//
BOOL CCapStream::Pause()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Pause")));

   ThdState state = m_state;

   // that was easy
   if (state == TS_Pause)
      return TRUE;

   // it is valid to go into the pause state only if currently
   // in the Create/Init (depending on if our thread has run yet) or Run state
   //
   ASSERT (state == TS_Create || state == TS_Init || state == TS_Run);

   // if we are in the init state, we will fall into the pause state
   // naturally, we just have to wait for it to happen
   //
   if (state == TS_Create || state == TS_Init) {
      WaitForSingleObject (m_hEvtPause, INFINITE);
      state = m_state;
      DbgLog((LOG_TRACE,2,TEXT("Transition Create->Init->Pause complete")));

   } else if (state == TS_Run) {

      state = ChangeState (TS_Pause);
      ASSERT(state == TS_Run);

      // since we aren't running, stop capturing frames for now
      videoStreamStop(m_cs.hVideoIn);

      // the worker thread may hang going from run->pause in Deliver, so
      // it can't signal anything to us.
      // WaitForSingleObject(m_hEvtPause, INFINITE);

      state = m_state;
      m_cs.fReRun = TRUE;  // if we are RUN now, it will have been RUN-PAUSE-RUN
      DbgLog((LOG_TRACE,2,TEXT("Transition Run->Pause complete")));
   }

   return (state == TS_Pause);
}

// stop the worker thread
//
BOOL CCapStream::Stop()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream Thread Stop")));

   ThdState state = m_state;
   if (state >= TS_Stop)
      return TRUE;

   // Don't go from Run->Stop without Pause
   if (state == TS_Run)
      Pause();

   state = ChangeState (TS_Stop);
   SetEvent(m_hEvtRun);		// we won't be running, unblock our thread
   m_cs.fReRun = FALSE;	// next RUN is not a RUN-PAUSE-RUN
   DbgLog((LOG_TRACE,2,TEXT("Transition Pause->Stop complete")));

   // we expect that Stop can only be called when the thread is in a
   // Pause state.
   //
   ASSERT (state == TS_Pause);
   return TRUE;
}

// this pin has gone active. (transition to Paused state),
// return from this call when ready to go into run state.
//
HRESULT CCapStream::Active()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from STOP-->PAUSE")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   if ( ! IsConnected())
      return NOERROR;

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS && m_pdd)
   {
       ASSERT(m_pDrawPrimary == 0);

       DDSURFACEDESC SurfaceDesc;
       SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
       SurfaceDesc.dwFlags = DDSD_CAPS;
       SurfaceDesc.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
       m_pdd->CreateSurface(&SurfaceDesc,&m_pDrawPrimary,NULL);

       // continue on failure risking incorrect operation
   }

   // before we do anything, warn our preview pin we are going active
   if (m_pCap->m_pPreviewPin)
      m_pCap->m_pPreviewPin->CapturePinActive(TRUE);

   hr = CBaseOutputPin::Active();
   if (FAILED(hr)) {
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
      return hr;
   }

   // start the thread
   //
   ASSERT ( ! ThreadExists());
   if (!Create()) {
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
      return E_FAIL;
   }

   // wait until the worker thread is done with initialization and
   // has entered the paused state
   //
   hr = E_FAIL;
   if (Pause())
      hr = S_OK;
   else {
	Stop();		// something went wrong.  Destroy thread before we
	Destroy();	// get confused
   }

   ASSERT (hr != S_OK || m_state == TS_Pause);
   if (FAILED(hr))
      if (m_pCap->m_pPreviewPin)
         m_pCap->m_pPreviewPin->CapturePinActive(FALSE);
   return hr;
}

// this pin has gone from PAUSE to RUN mode
//
HRESULT CCapStream::ActiveRun(REFERENCE_TIME tStart)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from PAUSE-->RUN")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   ASSERT (IsConnected() && ThreadExists());

   hr = E_FAIL;
   if (Run())
      hr = S_OK;

   ASSERT (hr != S_OK || m_state == TS_Run);
   return hr;
}

// this pin has gone from RUN to PAUSE mode
//
HRESULT CCapStream::ActivePause()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from RUN-->PAUSE")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   ASSERT (IsConnected() && ThreadExists());

   hr = E_FAIL;
   if (Pause())
      hr = S_OK;

   ASSERT (hr != S_OK || m_state == TS_Pause);
   return hr;
}

//
// Inactive
//
// Pin is inactive - shut down the worker thread
// Waits for the worker to exit before returning.
//
HRESULT CCapStream::Inactive()
{
    if(m_pDrawPrimary) {
        m_pDrawPrimary->Release();
        m_pDrawPrimary = 0;
    }

   DbgLog((LOG_TRACE,2,TEXT("CCapStream pin going from PAUSE-->STOP")));
   HRESULT hr;

   // do nothing if not connected - its ok not to connect to
   // all pins of a source filter
   //
   if ( ! IsConnected())
       return NOERROR;

   // Tell our preview pin to STOP USING our buffers
   if (m_pCap->m_pPreviewPin)
      m_pCap->m_pPreviewPin->CapturePinActive(FALSE);

   // Now destroy all the capture buffers, since nobody is using them anymore
   //
   Stop();

   // need to do this before trying to stop the thread, because
   // we may be stuck waiting for our own allocator!!
   //
   hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
   if (FAILED(hr))
      return hr;

   // wait for the worker thread to die
   //
   Destroy();

   return NOERROR;
}


STDMETHODIMP
CCapStream::Notify(
   IBaseFilter * pSender,
   Quality q)
{
   DbgLog((LOG_TRACE,5,TEXT("CCapStream Notify")));
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // !!! ideas anyone?

   return NOERROR;
}

void CCapStream::DumpState(ThdState state)
{
        DbgLog((LOG_TRACE,6, TEXT("%x:CCapStream ChangeState(%d:%s) current=%d:%s"),
             this,
             (int)state, StateName(state),
             (int)m_state, StateName(m_state)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\overlay.cpp ===
// !!! Paint black in window when not running, please

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    Methods for CCapOverlay, CCapOverlayNotify

*/

#include <streams.h>
#include "driver.h"

CCapOverlay * CreateOverlayPin(CVfwCapture * pCapture, HRESULT * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapOverlay::CreateOverlayPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"Preview");

   CCapOverlay * pOverlay = new CCapOverlay(NAME("Video Overlay Stream"),
				pCapture, phr, wszPinName);
   if (!pOverlay)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pOverlay)
      delete pOverlay, pOverlay = NULL;

   return pOverlay;
}

//#pragma warning(disable:4355)


// CCapOverlay constructor
//
CCapOverlay::CCapOverlay(TCHAR *pObjectName, CVfwCapture *pCapture,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_OverlayNotify(NAME("Overlay notification interface"), pCapture, NULL, phr),
   m_pCap(pCapture),
   m_fRunning(FALSE)
#ifdef OVERLAY_SC
   ,m_hThread(NULL),
   m_tid(0),
   m_dwAdvise(0),
   m_rtStart(0),
   m_rtEnd(0),
   m_fHaveThread(FALSE)
#endif
{
   DbgLog((LOG_TRACE,1,TEXT("CCapOverlay constructor")));
   ASSERT(pCapture);
}


CCapOverlay::~CCapOverlay()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Overlay pin")));
};


// Say if we're prepared to connect to a given input pin from
// this output pin
//
STDMETHODIMP CCapOverlay::Connect(IPin *pReceivePin,
                                        const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::Connect")));

    /*  Call the base class to make sure the directions match! */
    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if (FAILED(hr)) {
        return hr;
    }
    /*  We're happy if we can get an IOverlay interface */

    hr = pReceivePin->QueryInterface(IID_IOverlay,
                                     (void **)&m_pOverlay);

    // we were promised this would work
    ASSERT(SUCCEEDED(hr));

    /*  Because we're not going to get called again - except to
        propose a media type - we set up a callback here.

        There's only one overlay pin so we don't need any context.
    */

    hr = m_pOverlay->Advise(&m_OverlayNotify,
                            ADVISE_CLIPPING | ADVISE_POSITION);

    /*
        We don't need to hold on to the IOverlay pointer
        because BreakConnect will be called before the receiving
        pin goes away.
    */


    if (FAILED(hr)) {
	// !!! Shouldn't happen, but this isn't quite right
        Disconnect();
	pReceivePin->Disconnect();
        return hr;
    } else {
        m_bAdvise = TRUE;
    }

    return hr;
}


STDMETHODIMP CCapOverlay::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    DbgLog((LOG_TRACE,99,TEXT("CCapOverlay::NonDelegatingQueryInterface")));
    if (ppv)
	*ppv = NULL;

    /* Do we have this interface */

    if (riid == IID_IKsPropertySet) {
        return GetInterface((LPUNKNOWN) (IKsPropertySet *) this, ppv);
#ifdef OVERLAY_SC
    } else if (riid == IID_IAMStreamControl) {
        return GetInterface((LPUNKNOWN) (IAMStreamControl *) this, ppv);
#endif
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


#ifdef OVERLAY_SC

// overidden because we aren't an IMemInputPin... we have no delivering
// to do to notice when to start and stop.  We need a thread. Ick. Fun.
STDMETHODIMP CCapOverlay::StopAt(const REFERENCE_TIME * ptStop, BOOL bBlockData, DWORD dwCookie)
{
    REFERENCE_TIME rt;

    CAutoLock cObjectLock(m_pCap->m_pLock);

    // we must be connected and running
    if (!IsConnected() || m_pCap->m_State != State_Running)
	return E_UNEXPECTED;

    // we are stopped!
    if (!m_fRunning)
	return NOERROR;

    // Stop now.  That's easy enough
    if (ptStop == NULL) {
	ActivePause();
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }
	
    // can't do this without a clock
    if (m_pCap->m_pClock == NULL)
	return E_FAIL;

    // cancel the stop
    if (*ptStop == MAX_TIME) {
	if (m_rtEnd > 0) {
	    m_rtEnd = 0;
	    if (m_dwAdvise) {
	        m_pCap->m_pClock->Unadvise(m_dwAdvise);
		m_EventAdvise.Set();
	    }
 	}
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }

    m_pCap->m_pClock->GetTime(&rt);
    // Stop in the past.  That's easy enough. Stop now.
    if (*ptStop <= rt) {
	ActivePause();
	return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
    }

    // stop in the future.  That's tricky.  We need a thread to notice
    // "when's later, Daddy?"

    m_rtEnd = *ptStop;	// DO THIS BEFORE m_fHaveThread test or thread 
    			// could die after we think it's staying around
    m_dwCookieStop = dwCookie;

    // we need a new thread
    if (m_fHaveThread == FALSE) {
	// we made one before that we haven't closed
	if (m_hThread) {
    	    WaitForSingleObject(m_hThread, INFINITE);
    	    CloseHandle(m_hThread);
	    m_hThread = NULL;
	    m_tid = 0;
	}
	m_EventAdvise.Reset();
	m_fHaveThread = TRUE;
	m_hThread = CreateThread(NULL, 0, CCapOverlay::ThreadProcInit, this,
				0, &m_tid);
        if (!m_hThread) {
            DbgLog((LOG_ERROR,1,TEXT("Can't create Overlay thread")));
           return E_OUTOFMEMORY;
        }
    }
    return CBaseStreamControl::StopAt(ptStop, bBlockData, dwCookie);
}


STDMETHODIMP CCapOverlay::StartAt(const REFERENCE_TIME * ptStart, DWORD dwCookie)
{
    REFERENCE_TIME rt;

    CAutoLock cObjectLock(m_pCap->m_pLock);

    // we must be connected and running
    if (!IsConnected() || m_pCap->m_State != State_Running)
	return E_UNEXPECTED;

    // we are running!
    if (m_fRunning)
	return NOERROR;

    // Start now.  That's easy enough
    if (ptStart == NULL) {
	ActiveRun(0);
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }
	
    // can't do this without a clock
    if (m_pCap->m_pClock == NULL)
	return E_FAIL;

    // cancel the start
    if (*ptStart == MAX_TIME) {
	if (m_rtStart > 0) {
	    m_rtStart = 0;
	    if (m_dwAdvise) {
	        m_pCap->m_pClock->Unadvise(m_dwAdvise);
		m_EventAdvise.Set();
	    }
 	}
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }

    m_pCap->m_pClock->GetTime(&rt);
    // Start in the past.  That's easy enough. Start now.
    if (*ptStart <= rt) {
	ActiveRun(0);
	return CBaseStreamControl::StartAt(ptStart, dwCookie);
    }

    // start in the future.  That's tricky.  We need a thread to notice
    // "when's later, Daddy?"

    m_rtStart = *ptStart;// DO THIS BEFORE m_fHaveThread test or thread 
    			 // could die after we think it's staying around
    m_dwCookieStart = dwCookie;

    // we need a new thread
    if (m_fHaveThread == FALSE) {
	// we made one before that we haven't closed
	if (m_hThread) {
    	    WaitForSingleObject(m_hThread, INFINITE);
    	    CloseHandle(m_hThread);
	    m_hThread = NULL;
	    m_tid = 0;
	}
	m_EventAdvise.Reset();
	m_fHaveThread = TRUE;
	m_hThread = CreateThread(NULL, 0, CCapOverlay::ThreadProcInit, this,
				0, &m_tid);
        if (!m_hThread) {
            DbgLog((LOG_ERROR,1,TEXT("Can't create Overlay thread")));
           return E_OUTOFMEMORY;
        }
    }
    return CBaseStreamControl::StartAt(ptStart, dwCookie);
}
#endif	// OVERLAY_SC


// !!! The base classes change all the time and I won't pick up their bug fixes!
//
HRESULT CCapOverlay::BreakConnect()
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::BreakConnect")));

    if (m_pOverlay != NULL) {
        if (m_bAdvise) {
            m_pOverlay->Unadvise();
            m_bAdvise = FALSE;
        }
        m_pOverlay->Release();
        m_pOverlay = NULL;
    }

#if 0
    // we've broken our connection, so next time we reconnect don't allow
    // repainting until we've actually drawn something in the first place
    m_pFilter->m_fOKToRepaint = FALSE;
#endif

    return CBaseOutputPin::BreakConnect();
}


// Override this because we don't want any allocator!
//
HRESULT CCapOverlay::DecideAllocator(IMemInputPin * pPin,
                        IMemAllocator ** pAlloc) {
    /*  We just don't want one so everything's OK as it is */
    return S_OK;
}


HRESULT CCapOverlay::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("NULL format, no can do")));
	return E_INVALIDARG;
    }
	
    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    // We provide a media type of OVERLAY with an 8 bit format (silly
    // renderer won't accept it if we don't set up an 8 bit format)

    BYTE aFormat[sizeof(VIDEOINFOHEADER) + SIZE_PALETTE];
    VIDEOINFOHEADER *pFormat = (VIDEOINFOHEADER *)aFormat;
    ZeroMemory(pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);

    pFormat->bmiHeader.biWidth =
			m_pCap->m_pStream->m_user.pvi->bmiHeader.biWidth;
    pFormat->bmiHeader.biHeight =
			m_pCap->m_pStream->m_user.pvi->bmiHeader.biHeight;

// we don't work with funny rectangles. Sorry
#if 0
    // I bet the renderer ignores these rectangles and I'll need to call
    // IBasicVideo::put_Source* and ::put_Destination* instead
    // The idea is to make OnClipChange's source and target match these numbers
    pFormat->rcSource = m_pCap->m_pStream->m_user.pvi->rcSource;
    pFormat->rcTarget = m_pCap->m_pStream->m_user.pvi->rcTarget;
#endif

    pFormat->bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);
    pFormat->bmiHeader.biPlanes = 1;
    pFormat->bmiHeader.biBitCount = 8;

    pmt->SetFormat((PBYTE)pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);
    pmt->SetFormatType(&FORMAT_VideoInfo);

    if (pmt->pbFormat == NULL) {
        return E_OUTOFMEMORY;
    }

    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype   = MEDIASUBTYPE_Overlay;
    pmt->bFixedSizeSamples    = FALSE;
    pmt->bTemporalCompression = FALSE;	
    pmt->lSampleSize          = 0;

    return NOERROR;
}


// We accept overlay connections only
//
HRESULT CCapOverlay::CheckMediaType(const CMediaType *pMediaType)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlay::CheckMediaType")));
    if (pMediaType->subtype == MEDIASUBTYPE_Overlay)
        return NOERROR;
    else
	return E_FAIL;
}


// Don't insist on IMemInputPin
//
HRESULT CCapOverlay::CheckConnect(IPin *pPin)
{
    // we don't connect to anyone who doesn't support IOverlay.
    // after all, we're an overlay pin
    HRESULT hr = pPin->QueryInterface(IID_IOverlay, (void **)&m_pOverlay);

    if (FAILED(hr)) {
        return E_NOINTERFACE;
    } else {
	m_pOverlay->Release();
	m_pOverlay = NULL;
    }

    return CBasePin::CheckConnect(pPin);
}


HRESULT CCapOverlay::Active()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Stop->Pause")));

    videoStreamInit(m_pCap->m_pStream->m_cs.hVideoExtOut, 0, 0, 0, 0);

    // don't let the base class Active() get called for non-IMemInput pins
    return NOERROR;
}


HRESULT CCapOverlay::Inactive()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Pause->Stop")));

    // turn off overlay
    videoStreamFini(m_pCap->m_pStream->m_cs.hVideoExtOut);

#ifdef OVERLAY_SC
    CAutoLock cObjectLock(m_pCap->m_pLock);

    // kill our thread
    m_rtStart = 0; 
    m_rtEnd = 0;
    if (m_pCap->m_pClock && m_dwAdvise) {
        m_pCap->m_pClock->Unadvise(m_dwAdvise);
	m_EventAdvise.Set();
    }

    // we haven't properly shut down our thread yet
    if (m_hThread) {
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_tid = 0;
        m_hThread = NULL;
    }
#endif

    return NOERROR;
}


HRESULT CCapOverlay::ActiveRun(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Pause->Run")));

    ASSERT(m_pCap->m_pOverlayPin->IsConnected());

    m_fRunning = TRUE;

    HVIDEO hVideoExtOut = m_pCap->m_pStream->m_cs.hVideoExtOut;
    if (hVideoExtOut == NULL || m_pOverlay == NULL)
	return NOERROR;

    HWND hwnd;
    HDC  hdc;
    m_pOverlay->GetWindowHandle(&hwnd);
    if (hwnd)
	hdc = GetDC(hwnd);
    if (hwnd == NULL || hdc == NULL)
	return NOERROR;

    RECT rcSrc, rcDst;
    rcSrc.left = 0; rcSrc.top = 0;
    rcSrc.right = HEADER(m_mt.Format())->biWidth;
    rcSrc.bottom = HEADER(m_mt.Format())->biHeight;
    GetClientRect (hwnd, &rcDst);
    ClientToScreen(hwnd, (LPPOINT)&rcDst);
    ClientToScreen(hwnd, (LPPOINT)&rcDst + 1);

    DbgLog((LOG_TRACE,2,TEXT("Starting overlay (%d,%d) to (%d,%d)"),
		rcSrc.right, rcSrc.bottom, rcDst.right - rcDst.left,
		rcDst.bottom - rcDst.top));

    // turn overlay on
    vidxSetRect(m_pCap->m_pStream->m_cs.hVideoExtOut, DVM_SRC_RECT,
		rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom);
    vidxSetRect(m_pCap->m_pStream->m_cs.hVideoExtOut, DVM_DST_RECT,
		rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
    // INIT now done in PAUSE
    videoUpdate(m_pCap->m_pStream->m_cs.hVideoExtOut, hwnd, hdc);

    ReleaseDC(hwnd, hdc);
    return NOERROR;
}


HRESULT CCapOverlay::ActivePause()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay Run->Pause")));

    DbgLog((LOG_TRACE,2,TEXT("Turning OVERLAY off")));

    m_fRunning = FALSE;

    return NOERROR;
}


#if 0
// Return the IOverlay interface we are using (AddRef'd)
//
IOverlay *CCapOverlay::GetOverlayInterface()
{
    if (m_pOverlay) {
        m_pOverlay->AddRef();
    }
    return m_pOverlay;
}
#endif



#ifdef OVERLAY_SC
DWORD WINAPI CCapOverlay::ThreadProcInit(void *pv)
{
    CCapOverlay *pThis = (CCapOverlay *)pv;
    return pThis->ThreadProc();
}


DWORD CCapOverlay::ThreadProc()
{
    DbgLog((LOG_TRACE,2,TEXT("Starting CCapOverlay ThreadProc")));

    REFERENCE_TIME rt;
    HRESULT hr;

    // protect from other people dicking with m_rtStart and m_rtEnd
    m_pCap->m_pLock->Lock();

    while (m_rtStart > 0 || m_rtEnd > 0) {

	rt = m_rtStart;
	if (m_rtEnd < rt)
	    rt = m_rtEnd;


        hr = m_pCap->m_pClock->AdviseTime(
		// this was the reference time when our stream started playing
            	(REFERENCE_TIME) m_pCap->m_tStart,
		// this is the offset from our start time when we want to
		// wake up.
            	(REFERENCE_TIME) rt,
            	(HEVENT)(HANDLE) m_EventAdvise,		// event to fire
            	&m_dwAdvise);                       	// Advise cookie

        m_pCap->m_pLock->Unlock();

        if (SUCCEEDED(hr)) {
	    m_EventAdvise.Wait();
        } else {
	    DbgLog((LOG_TRACE,1,TEXT("AdviseTime ERROR, doing it now")));
        }

        m_pCap->m_pLock->Lock();

        m_dwAdvise = 0;
	m_pCap->m_pClock->GetTime(&rt);
	if (m_rtStart < rt) {
	    m_rtStart = 0;
	    ActiveRun(0);
	}
	if (m_rtEnd < rt) {
	    m_rtEnd = 0;
	    ActivePause();
	}
    }


    DbgLog((LOG_TRACE,2,TEXT("CCapOverlay ThreadProc is dead")));

    // somebody needs to kill me officially later
    m_fHaveThread = FALSE;

    m_pCap->m_pLock->Unlock();
    return 0;
}
#endif	// OVERLAY_SC



//=========================================================================//
//***			I N T E R M I S S I O N				***//
//=========================================================================//




/*
        IOverlayNotify
*/

CCapOverlayNotify::CCapOverlayNotify(TCHAR              * pName,
                               CVfwCapture 	  * pFilter,
                               LPUNKNOWN            pUnk,
                               HRESULT            * phr) :
    CUnknown(pName, pUnk)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating CCapOverlayNotify")));
    m_pFilter = pFilter;
}


CCapOverlayNotify::~CCapOverlayNotify()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying CCapOverlayNotify")));
}


STDMETHODIMP CCapOverlayNotify::NonDelegatingQueryInterface(REFIID riid,
                                                         void ** ppv)
{
    DbgLog((LOG_TRACE,99,TEXT("CCapOverlayNotify::QueryInterface")));
    if (ppv)
	*ppv = NULL;

    /* Do we have this interface */

    if (riid == IID_IOverlayNotify) {
        return GetInterface((LPUNKNOWN) (IOverlayNotify *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP_(ULONG) CCapOverlayNotify::NonDelegatingRelease()
{
    return m_pFilter->Release();
}


STDMETHODIMP_(ULONG) CCapOverlayNotify::NonDelegatingAddRef()
{
    return m_pFilter->AddRef();
}


STDMETHODIMP CCapOverlayNotify::OnColorKeyChange(
    const COLORKEY *pColorKey)          // Defines new colour key
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlayNotify::OnColorKeyChange")));

// We expect the hardware to handle colour key stuff, so I'm really
// hoping that the renderer will never draw the colour key itself.

    return NOERROR;
}


// The calls to OnClipChange happen in sync with the window. So it's called
// with an empty clip list before the window moves to freeze the video, and
// then when the window has stabilised it is called again with the new clip
// list. The OnPositionChange callback is for overlay cards that don't want
// the expense of synchronous clipping updates and just want to know when
// the source or destination video positions change. They will NOT be called
// in sync with the window but at some point after the window has changed
// (basicly in time with WM_SIZE etc messages received). This is therefore
// suitable for overlay cards that don't inlay their data to the framebuffer

STDMETHODIMP CCapOverlayNotify::OnClipChange(
    const RECT    * pSourceRect,         // Area of source video to use
    const RECT    * pDestinationRect,    // screen co-ords of window
    const RGNDATA * pRegionData)         // Header describing clipping
{
    if (!m_pFilter->m_pOverlayPin)
	return NOERROR;

    if (!m_pFilter->m_pOverlayPin->IsConnected())
	return NOERROR;

    if (IsRectEmpty(pSourceRect) && IsRectEmpty(pDestinationRect))
	return NOERROR;

    HWND hwnd = NULL;
    HDC  hdc;
    if (m_pFilter->m_pOverlayPin->m_pOverlay)
        m_pFilter->m_pOverlayPin->m_pOverlay->GetWindowHandle(&hwnd);

    if (hwnd == NULL || !IsWindowVisible(hwnd))
	return NOERROR;
    if (hwnd)
	hdc = GetDC(hwnd);
    if (hdc == NULL)
	return NOERROR;

    DbgLog((LOG_TRACE,3,TEXT("OnClip/PositionChange (%d,%d) (%d,%d)"),
        		pSourceRect->right - pSourceRect->left,
        		pSourceRect->bottom - pSourceRect->top,
        		pDestinationRect->right - pDestinationRect->left,
        		pDestinationRect->bottom - pDestinationRect->top));

    // It's up to us to keep garbage out of the window by painting it if
    // we're not running, and the hardware has nothing to draw
    if (!m_pFilter->m_pOverlayPin->m_fRunning) {
	RECT rcC;
	GetClientRect(hwnd, &rcC);
	HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(BLACK_BRUSH));
	PatBlt(hdc, 0, 0, rcC.right, rcC.bottom, PATCOPY);
	SelectObject(hdc, hbrOld);
        ReleaseDC(hwnd, hdc);
	return NOERROR;
    }

    vidxSetRect(m_pFilter->m_pStream->m_cs.hVideoExtOut, DVM_SRC_RECT,
			pSourceRect->left, pSourceRect->top,
			pSourceRect->right, pSourceRect->bottom);
    vidxSetRect(m_pFilter->m_pStream->m_cs.hVideoExtOut, DVM_DST_RECT,
			pDestinationRect->left, pDestinationRect->top,
			pDestinationRect->right, pDestinationRect->bottom);
    videoStreamInit(m_pFilter->m_pStream->m_cs.hVideoExtOut, 0, 0, 0, 0);
    videoUpdate(m_pFilter->m_pStream->m_cs.hVideoExtOut, hwnd, hdc);

    ReleaseDC(hwnd, hdc);

    return NOERROR;
}


STDMETHODIMP CCapOverlayNotify::OnPaletteChange(
    DWORD dwColors,                     // Number of colours present
    const PALETTEENTRY *pPalette)       // Array of palette colours
{
    DbgLog((LOG_TRACE,3,TEXT("CCapOverlayNotify::OnPaletteChange")));

    return NOERROR;
}


STDMETHODIMP CCapOverlayNotify::OnPositionChange(
    const RECT *pSourceRect,            // Area of video to play with
    const RECT *pDestinationRect)       // Area video goes
{

    return OnClipChange(pSourceRect, pDestinationRect, NULL);
}



//
// PIN CATEGORIES - let the world know that we are a PREVIEW pin
//

HRESULT CCapOverlay::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapOverlay::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapOverlay::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\preview.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    Methods for CCapPreview - the preview pin that doesn't use overlay

*/

#include <streams.h>
#include "driver.h"

// when the filter graph isn't using stream offsets we'll be using
// only 1 buffer, but even when it is note that we'll generally be
// using less buffers than this since the max filter graph latency 
// can be set by the app
// in default case make high enough to not block audio capture's 
// default 500ms buffers
const DWORD MAX_PREVIEW_BUFFERS = 15; 
                                      

CCapPreview * CreatePreviewPin(CVfwCapture * pCapture, HRESULT * phr)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapPreview::CreatePreviewPin(%08lX,%08lX)"),
        pCapture, phr));

   WCHAR wszPinName[16];
   lstrcpyW(wszPinName, L"Preview");

   CCapPreview * pPreview = new CCapPreview(NAME("Video Preview Stream"),
				pCapture, phr, wszPinName);
   if (!pPreview)
      *phr = E_OUTOFMEMORY;

   // if initialization failed, delete the stream array
   // and return the error
   //
   if (FAILED(*phr) && pPreview)
      delete pPreview, pPreview = NULL;

   return pPreview;
}

//#pragma warning(disable:4355)


// CCapPreview constructor
//
CCapPreview::CCapPreview(TCHAR *pObjectName, CVfwCapture *pCapture,
        HRESULT * phr, LPCWSTR pName)
   :
   CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, phr, pName),
   m_pCap(pCapture),
   m_pOutputQueue(NULL),
   m_fActuallyRunning(FALSE),
   m_fThinkImRunning(FALSE),
   m_hThread(NULL),
   m_tid(0),
   m_hEventRun(NULL),
   m_hEventStop(NULL),
   m_dwAdvise(0),
   m_fCapturing(FALSE),
   m_hEventActiveChanged(NULL),
   m_hEventFrameValid(NULL),
   m_pPreviewSample(NULL),
   m_iFrameSize(0),
   m_fLastSampleDiscarded(FALSE),
   m_fFrameValid(FALSE),
   m_rtLatency(0),
   m_rtStreamOffset(0),
   m_rtMaxStreamOffset(0),
   m_cPreviewBuffers(1)
{
   DbgLog((LOG_TRACE,1,TEXT("CCapPreview constructor")));
   ASSERT(pCapture);
}


CCapPreview::~CCapPreview()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Preview pin")));
    ASSERT(m_pOutputQueue == NULL);
};


STDMETHODIMP CCapPreview::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
	return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
        return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
	return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

   return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}


#if 0
// Override this because we don't want any allocator!
//
HRESULT CCapPreview::DecideAllocator(IMemInputPin * pPin,
                        IMemAllocator ** pAlloc) {
    /*  We just don't want one so everything's OK as it is */
    return S_OK;
}
#endif


HRESULT CCapPreview::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapPreview::GetMediaType #%d"), iPosition));

    // we preview the same format as we capture
    return m_pCap->m_pStream->GetMediaType(iPosition, pmt);
}


// We accept overlay connections only
//
HRESULT CCapPreview::CheckMediaType(const CMediaType *pMediaType)
{
    DbgLog((LOG_TRACE,3,TEXT("CCapPreview::CheckMediaType")));

    // Only accept what our capture pin is providing.  I will not switch
    // our capture pin over to a new format just because somebody changes
    // the preview pin.
    CMediaType cmt;
    HRESULT hr = m_pCap->m_pStream->GetMediaType(0, &cmt);
    if (hr == S_OK && cmt == *pMediaType)
	return NOERROR;
    else
	return E_FAIL;
}


HRESULT CCapPreview::ActiveRun(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Pause->Run")));

    ASSERT(IsConnected());

    m_fActuallyRunning = TRUE;
    m_rtRun = tStart;

    // tell our thread to start previewing
    SetEvent(m_hEventRun);

    return NOERROR;
}


HRESULT CCapPreview::ActivePause()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Run->Pause")));

    m_fActuallyRunning = FALSE;
    
    return NOERROR;
}


HRESULT CCapPreview::Active()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Stop->Pause")));

    ASSERT(IsConnected());

    m_hEventRun = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventRun) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Run event")));
        return E_OUTOFMEMORY;
    }
    m_hEventStop = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventStop) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Stop event")));
        return E_OUTOFMEMORY;
    }

    m_hEventActiveChanged = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventActiveChanged) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create ActiveChanged event")));
        return E_OUTOFMEMORY;
    }

    m_hEventFrameValid = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventFrameValid) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create FrameValid event")));
        return E_OUTOFMEMORY;
    }

    m_EventAdvise.Reset();
    m_fFrameValid = FALSE;

    m_hThread = CreateThread(NULL, 0, CCapPreview::ThreadProcInit, this,
				0, &m_tid);
    if (!m_hThread) {
        DbgLog((LOG_ERROR,1,TEXT("Can't create Preview thread")));
       return E_OUTOFMEMORY;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }
    //  create the queue
    ASSERT(m_pOutputQueue == NULL);
    hr = S_OK;
    m_pOutputQueue = new COutputQueue(GetConnected(), // input pin
                                      &hr,            // return code
                                      (m_cPreviewBuffers == 1) ?// auto detect as long as > 1 buffer
                                         FALSE : TRUE,          // if only 1 buffer don't create separate thread
                                      FALSE,	      // ignored for >1 buffer, else don't create thread
                                      1,              // no batching
                                      FALSE,          // not used if no batching
                                      m_cPreviewBuffers); // queue size
    if (m_pOutputQueue == NULL) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    return hr;
}


HRESULT CCapPreview::Inactive()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapPreview Pause->Stop")));

    ASSERT(IsConnected());

    // tell our thread to give up and die
    SetEvent(m_hEventStop);
    SetEvent(m_hEventFrameValid);
    SetEvent(m_hEventActiveChanged);

    // We're waiting for an advise that will now never come
    if (m_pCap->m_pClock && m_dwAdvise) {
	m_pCap->m_pClock->Unadvise(m_dwAdvise);
	m_EventAdvise.Set();
    }

    WaitForSingleObject(m_hThread, INFINITE);

    CloseHandle(m_hThread);
    CloseHandle(m_hEventRun);
    CloseHandle(m_hEventStop);
    CloseHandle(m_hEventActiveChanged);
    CloseHandle(m_hEventFrameValid);
    m_hEventRun = NULL;
    m_hEventStop = NULL;
    m_hEventActiveChanged = NULL;
    m_hEventFrameValid = NULL;
    m_tid = 0;
    m_hThread = NULL;
    
    //CAutoLock lck(this); // necessary???
    HRESULT hr = CBaseOutputPin::Inactive();
    if( FAILED( hr ) )
    {    
        //  Incorrect state transition 
        return hr;
    }
            
    delete m_pOutputQueue;
    m_pOutputQueue = NULL;
    
    return S_OK;
}


HRESULT CCapPreview::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pProperties)
{
   DbgLog((LOG_TRACE,2,TEXT("CCapPreview DecideBufferSize")));

   ASSERT(pAllocator);
   ASSERT(pProperties);
   
   LONG cBuffers = 1; 
   if( m_rtMaxStreamOffset > m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame )
   {       
       cBuffers = (LONG)(m_rtMaxStreamOffset / m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame);
       cBuffers++; // align up                            
       DbgLog((LOG_TRACE,
               4,
               TEXT("buffers required for preview to cover max Graph Latency: %d"), 
               cBuffers ) );
   }   
   m_cPreviewBuffers = min( cBuffers, MAX_PREVIEW_BUFFERS );

   // !!! more preview buffers?
   if (pProperties->cBuffers < m_cPreviewBuffers)
       pProperties->cBuffers = m_cPreviewBuffers;

   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 1;

// who cares
#if 0
   // we should honour the alignment and prefix as long as they result in a
   // 4-byte aligned buffer. Note that it is the start of the prefix that
   // is aligned.

   // we want alignment of 4 bytes
   if (pProperties->cbAlign == 0)
	pProperties->cbAlign = 4;
   // they might want a different alignment
   if ((pProperties->cbAlign % 4) != 0)
      pProperties->cbAlign = ALIGNUP(pProperties->cbAlign, 4);

   // !!! cbAlign must be a power of 2, or ALIGNUP will fail - fix this
#endif

   // This is how big we need each buffer to be
   pProperties->cbBuffer = max(pProperties->cbBuffer,
		(long)(m_pCap->m_pStream->m_user.pvi ?
		m_pCap->m_pStream->m_user.pvi->bmiHeader.biSizeImage : 4096));
   // Make the prefix + buffer size meet the alignment restriction
   pProperties->cbBuffer = (long)ALIGNUP(pProperties->cbBuffer +
				pProperties->cbPrefix, pProperties->cbAlign) -
				pProperties->cbPrefix;

   ASSERT(pProperties->cbBuffer);

   DbgLog((LOG_TRACE,2,TEXT("Preview: %d buffers, prefix %d size %d align %d"),
			pProperties->cBuffers, pProperties->cbPrefix,
			pProperties->cbBuffer,
			pProperties->cbAlign));

   // assume that our latency will be 1 frame ??
   m_rtLatency = m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame;
   m_rtStreamOffset = 0;   
   DbgLog((LOG_TRACE,4,TEXT("Max stream offset for preview pin is %dms"), (LONG) (m_rtMaxStreamOffset/10000) ) );

   ALLOCATOR_PROPERTIES Actual;
   return pAllocator->SetProperties(pProperties,&Actual);

   // !!! Are we sure we'll be happy with this?

}



HRESULT CCapPreview::Notify(IBaseFilter *pFilter, Quality q)
{
    return NOERROR;
}


// The streaming pin is active ==> We can't call any video APIs anymore
// The streaming pin is inactive ==> We can
HRESULT CCapPreview::CapturePinActive(BOOL fActive)
{
    DbgLog((LOG_TRACE,2,TEXT("Capture pin says Active=%d"), fActive));

    if (fActive == m_fCapturing)
	return S_OK;
    m_fCapturing = fActive;

    // stop thread from waiting for us to send a valid frame - no more to come
    if (!fActive)
        SetEvent(m_hEventFrameValid);

    // Wait until the worker thread notices the difference - it will only set
    // this event if m_fThinkImRunning is set
    if (m_fThinkImRunning)
        WaitForSingleObject(m_hEventActiveChanged, INFINITE);

    ResetEvent(m_hEventActiveChanged);

    return S_OK;
}


// The streaming pin is sending us a frame to preview
HRESULT CCapPreview::ReceivePreviewFrame(IMediaSample* pSample, int iSize)
{
    // I'm not the least bit interested in previewing right now, or
    // we haven't used the last one yet, or we don't have a place to put it
    if (!m_fActuallyRunning || m_fFrameValid || m_pPreviewSample) {
        //DbgLog((LOG_TRACE,4,TEXT("Not interested")));
        return S_OK;
    }
    
    DbgLog((LOG_TRACE,4,TEXT("Capture pin is giving us a preview frame")));

    //
    // The preview thread won't try to get an output buffer for preview until
    // we signal that we've got one ready. We need to addref this buffer to 
    // ensure it's kept around until the preview thread has gotten a buffer
    // to put it into.
    //
    
    // any previous buffer should've been released otherwise
    // not true, this could fire occasionally if GetDeliveryBuffer fails for example.
    //ASSERT( NULL == m_pPreviewSample );
    
    // take a hold on this one until the preview thread's ready to copy it (and done)
    ULONG ulRef = pSample->AddRef();
    // something scary that I noticed: occasionally the refcount on this sample was 0 when we got it
    // it seems to happen only when the Stop/Inactive/Destroy path occurred on the CCapStream thread
    if( 2 > ulRef )
        DbgLog((LOG_TRACE,2,TEXT("CCapPreview ReceivePrevewFrame UNEXPECTED pSample->AddRef returned %d"), ulRef));
    
    // now save a pointer to this sample since we'll need it once we've gotten 
    // a buffer to put it in
    m_pPreviewSample = pSample;

    // cache the sample size
    m_iFrameSize = iSize;
    
    m_fFrameValid = TRUE;
    
    // signal that we've got a frame ready to preview
    SetEvent(m_hEventFrameValid);
    return S_OK;
}

// This is where we actually copy the preview frame into the output buffer
HRESULT CCapPreview::CopyPreviewFrame(LPVOID lpOutputBuff)
{
    ASSERT( m_pPreviewSample ); // shouldn't have gotten here otherwise!
    ASSERT( m_fFrameValid );    // ditto
    ASSERT( lpOutputBuff );
    
    // !!! can't avoid mem copy without using our own allocator
    // !!! we do this copy memory even if preview pin is OFF (IAMStreamControl)
    // because we can't risk blocking this call by calling CheckStreamState
    LPBYTE lp;
    HRESULT hr = m_pPreviewSample->GetPointer(&lp);
    if( SUCCEEDED( hr ) )
    {    
        CopyMemory(lpOutputBuff, lp, m_iFrameSize);
    }
    
    // we're done with the preview sample so release it for re-use    
    m_pPreviewSample->Release();
    m_pPreviewSample = NULL; 
    
    // should we just make void return instead?    
    return hr;
}

DWORD WINAPI CCapPreview::ThreadProcInit(void *pv)
{
    CCapPreview *pThis = (CCapPreview *)pv;
    return pThis->ThreadProc();
}


DWORD CCapPreview::ThreadProc()
{
    IMediaSample *pSample;
    CRefTime rtStart, rtEnd;
    REFERENCE_TIME rtOffsetStart, rtOffsetEnd;
    DWORD dw;
    HVIDEO hVideoIn;
    HRESULT hr;
    THKVIDEOHDR tvh;
    BOOL fCaptureActive = m_fCapturing;
    int iWait;
    HANDLE hWait[2] = {m_hEventFrameValid, m_hEventStop};
    HANDLE hWaitRunStop[2] = {m_hEventRun, m_hEventStop};

    DbgLog((LOG_TRACE,2,TEXT("CCapPreview ThreadProc")));

    // the capture pin created this when he was created
    hVideoIn = m_pCap->m_pStream->m_cs.hVideoIn;

    hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);
    if (hr != NOERROR)
	return 0;
    ZeroMemory (&tvh, sizeof(tvh));
    tvh.vh.dwBufferLength = pSample->GetSize();
    pSample->Release();

    // !!! Is this safe when capture pin is streaming?
    dw = vidxAllocPreviewBuffer(hVideoIn, (LPVOID *)&tvh.vh.lpData,
                                    sizeof(tvh.vh), tvh.vh.dwBufferLength);
    if (dw) {
        DbgLog((LOG_ERROR,1,TEXT("*** CAN'T MAKE PREVIEW BUFFER!")));
        return 0;
    }
    tvh.p32Buff = tvh.vh.lpData;

    // Send preview frames as long as we're running.  Die when not streaming
    while (1) {

        // only preview while running
        iWait = WAIT_OBJECT_0;
        if (!m_fActuallyRunning) {
       	    DbgLog((LOG_TRACE,3,TEXT("Preview thread waiting for RUN/STOP")));
	        iWait = WaitForMultipleObjects(2, hWaitRunStop, FALSE, INFINITE);
       	    DbgLog((LOG_TRACE,3,TEXT("Preview thread got RUN/STOP")));
        }
        ResetEvent(m_hEventRun);

        // if we stopped instead of ran
        if (iWait != WAIT_OBJECT_0)
	        break;

        while (m_fActuallyRunning) {

            m_fThinkImRunning = TRUE;   // we now know we're running
           
            if (m_fCapturing != fCaptureActive) {
                DbgLog((LOG_TRACE,3,TEXT("Preview thread noticed Active=%d"),
                        m_fCapturing));
                SetEvent(m_hEventActiveChanged);
                fCaptureActive = m_fCapturing;
            }
               
            if (fCaptureActive) {
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using streaming pic")));

                // m_hEventFrameValid, m_hEventStop
                iWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

                // time for our thread to die - don't reset the event because
                // we may need it to fire when we break out of this loop
                if (iWait != WAIT_OBJECT_0 ) {
                    DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort1")));
                    continue;
                }

                // the streaming pin stopped being active... switch again
                if (!m_fFrameValid) {
                    DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort2")));
                    ResetEvent(m_hEventFrameValid);
                    
                    // can we be here with an addref'd preview sample? 
                    if( m_pPreviewSample )
                    {            
                        m_pPreviewSample->Release();
                        m_pPreviewSample = NULL;
                    }                
                    continue;
                }
                //
                // !!
                // Remember if we get here we've got an addref'd m_pPreviewSample and
                // we must release it ourselves if we hit a failure and don't explicitly 
                // call CopyPreviewFrame (which does release the sample)
                //
            }
            // now get a delivery buffer           
            // (don't call WaitForMultipleObjects while we're holding the sample!)
            hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);
            if (FAILED(hr))
            {            
                if( m_pPreviewSample )
                {            
                    m_pPreviewSample->Release();
                    m_pPreviewSample = NULL;
                }                
                break;
            }            
            PBYTE lpFrame;    
            hr = pSample->GetPointer((LPBYTE *)&lpFrame);
            if (FAILED(hr))
            {            
                if( m_pPreviewSample )
                {            
                    m_pPreviewSample->Release();
                    m_pPreviewSample = NULL;
                }                
                break; 
            }  
             
            if (fCaptureActive) {
                // we must have a preview frame ready to copy
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using streaming pic - copying preview frame")));

                // Note: this will release the sample as well
                hr = CopyPreviewFrame(lpFrame); 
                if( FAILED( hr ) )
                {                
                    if( m_pPreviewSample )
                    {            
                        m_pPreviewSample->Release();
                        m_pPreviewSample = NULL;
                    }
                    break;
                }
                        
                pSample->SetActualDataLength(m_iFrameSize);
            
                // it's now ok to grab another
                ResetEvent(m_hEventFrameValid);
    	
                // done with the current preview frame
                m_fFrameValid = FALSE;
        
            } else {
                DbgLog((LOG_TRACE,4,TEXT("PREVIEW using vidxFrame")));
                dw = vidxFrame(hVideoIn, &tvh.vh);
                if (dw == 0) {
                    // !!! Inefficient unless we use our own allocator
                    // !!! Even if pin is OFF, we still do this
                    CopyMemory(lpFrame, tvh.vh.lpData, tvh.vh.dwBytesUsed);
                } else {
                    pSample->Release();
                    DbgLog((LOG_ERROR,1,TEXT("*Can't capture still frame!")));
                    break;
                }
                pSample->SetActualDataLength(tvh.vh.dwBytesUsed);
            }
            if (m_pCap->m_pClock) {
                m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&rtStart);
                rtStart = rtStart - m_pCap->m_tStart;
                // ask Danny why this driver latency isn't accounted for
                // on preview pin timestamp??
                //      - m_pCap->m_pStream->m_cs.rtDriverLatency;
                // (add stream offset to start and end times in SetTime)
                rtEnd= rtStart + m_pCap->m_pStream->m_user.pvi->AvgTimePerFrame;
                // !!! NO TIME STAMPS for preview unless we know the latency
                // of the graph... we could drop every frame needlessly!
                // We only send another preview frame when this one is done,
                // so we won't get a backup if decoding is slow.
                // Actually, adding a latency time would still be broken
                // if the latency was > 1 frame length, because the renderer
                // would hold on to the sample until past the time for the
                // next frame, and we wouldn't send out the next preview frame
                // as soon as we should, and our preview frame rate would suffer
                //     But besides all that, we really need time stamps for
                // the stream control stuff to work, so we'll have to live
                // with preview frame rates being inferior if we have an
                // oustanding stream control request.
                AM_STREAM_INFO am;
                GetInfo(&am);
                if ( m_rtStreamOffset == 0 )
                {
                    // no offset needed, use old code
                    if ( am.dwFlags & AM_STREAM_INFO_START_DEFINED ||
                         am.dwFlags & AM_STREAM_INFO_STOP_DEFINED) {
                        //DbgLog((LOG_TRACE,0,TEXT("TIME STAMPING ANYWAY")));
                        pSample->SetTime((REFERENCE_TIME *)&rtStart,
					                     (REFERENCE_TIME *)&rtEnd);
                    }                        
                }
                else
                {
                    // this is hacky, but since stream control will block we can't give it
                    // sample times which use the stream offset.
                    // Since CheckStreamState takes a sample but only needs the start and
                    // end times for it we need to call SetTime on the sample twice, once
                    // for stream control (without the offset) and again before we deliver
                    // (with the offset).
                    pSample->SetTime( (REFERENCE_TIME *) &rtStart 
                                    , (REFERENCE_TIME *) &rtEnd );
                }
            }

		    int iStreamState = CheckStreamState(pSample);
            pSample->SetDiscontinuity(FALSE);
                
            if( iStreamState != STREAM_FLOWING ) 
            {
                DbgLog((LOG_TRACE,4,TEXT("*PREVIEW Discarding frame at %d"),
							(int)rtStart));
                m_fLastSampleDiscarded = TRUE;

                // release the sample ourselves since it won't be given to the output queue
                pSample->Release();
            }
            else
            {        
                DbgLog((LOG_TRACE,4,TEXT("*PREV Sending frame at %d"), (LONG)(rtStart/10000)));
                if (m_fLastSampleDiscarded)
                    pSample->SetDiscontinuity(TRUE);
                
                if( 0 < m_rtStreamOffset )
                {
                    // we need to offset the sample time, so add the offset in
                    // now that we're about to deliver
                    rtOffsetStart = rtStart + m_rtStreamOffset;
                    rtOffsetEnd = rtEnd + m_rtStreamOffset;
                    pSample->SetTime( (REFERENCE_TIME *) &rtOffsetStart
                                    , (REFERENCE_TIME *) &rtOffsetEnd );
                }                                
                pSample->SetSyncPoint(TRUE);	// I don't know for sure
                pSample->SetPreroll(FALSE);
                DbgLog((LOG_TRACE,4,TEXT("*Delivering a preview frame")));
                m_pOutputQueue->Receive(pSample);
            }
            
            // if previewing ourself, wait for time till next frame
            // !!! streaming pin may wait on this to become active
            if (!fCaptureActive && m_pCap->m_pClock) {
                hr = m_pCap->m_pClock->AdviseTime(
                                        m_rtRun, 
                                        rtEnd, // remember, this isn't offset
                                        (HEVENT)(HANDLE) m_EventAdvise, 
                                        &m_dwAdvise);
                if (SUCCEEDED(hr)) {
                    m_EventAdvise.Wait();
                }
                m_dwAdvise = 0;
            }
        }

        m_fThinkImRunning = FALSE;

        // make sure it wasn't set again if we didn't notice a run->pause->run
        // transition
        ResetEvent(m_hEventRun);

        SetEvent(m_hEventActiveChanged);
    }

    vidxFreePreviewBuffer(hVideoIn, (LPVOID *)&tvh.vh.lpData);

    DbgLog((LOG_TRACE,2,TEXT("CCapPreview ThreadProc is dead")));
    return 0;
}

// IAMPushSource
HRESULT CCapPreview::GetPushSourceFlags( ULONG  *pFlags )
{
    *pFlags = 0 ; // we timestamp with graph clock, the default
    return S_OK;
}    

HRESULT CCapPreview::SetPushSourceFlags( ULONG  Flags )
{
    // changing mode not supported
    return E_FAIL;
}    

HRESULT CCapPreview::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}    

HRESULT CCapPreview::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    HRESULT hr = S_OK;
    //
    // if someone attempts to set an offset larger then our max 
    // assert in debug for the moment...
    //
    // it may be ok to set a larger offset than we know we can handle, if
    // there's sufficient downstream buffering. but we'll return S_FALSE
    // in that case to warn the user that they need to handle this themselves.
    //
    ASSERT( rtOffset <= m_rtMaxStreamOffset );
    if( rtOffset > m_rtMaxStreamOffset )
    {    
        DbgLog( ( LOG_TRACE
              , 1
              , TEXT("CCapPreview::SetStreamOffset trying to set offset of %dms when limit is %dms") 
              , rtOffset
              , m_rtMaxStreamOffset ) );
        hr = S_FALSE;
        // but set it anyway
    }
    m_rtStreamOffset = rtOffset;
    
    return hr;
}

HRESULT CCapPreview::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CCapPreview::GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset )
{
    *prtMaxOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CCapPreview::SetMaxStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtMaxStreamOffset = rtOffset;
    return S_OK;
}

//
// PIN CATEGORIES - let the world know that we are a PREVIEW pin
//

HRESULT CCapPreview::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapPreview::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapPreview::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\property.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "driver.h"

// !!! make a property page for capturing a palette that only legacy has and 
// so it won't conflict with standard property pages of other cap filters

// constructor
//
CPropPage::CPropPage (TCHAR * pszName, LPUNKNOWN punk, HRESULT *phr) :
   CBasePropertyPage(pszName, punk, IDD_PROPERTIES, IDS_NAME)
   ,m_pOpt(NULL)
   ,m_pPin(NULL)
{
   DbgLog((LOG_TRACE,1,TEXT("CPropPage constructor")));
}

// create a new instance of this class
//
CUnknown *CPropPage::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropPage(NAME("VFW Capture Property Page"),pUnk,phr);
}


HRESULT CPropPage::OnConnect(IUnknown *pUnknown)
{
    DbgLog((LOG_TRACE,2,TEXT("Getting IVfwCaptureOptions")));

    HRESULT hr = (pUnknown)->QueryInterface(IID_VfwCaptureOptions,
                                            (void **)&m_pOpt);
    if (FAILED(hr))
        return E_NOINTERFACE;

    // Now get our streaming pin's IPin... we want it in INITDIALOG
    IEnumPins *pins;
    IPin *pPin;
    IBaseFilter *pFilter;
    hr = pUnknown->QueryInterface(IID_IBaseFilter, (void **)&pFilter);
    if (FAILED(hr))
        return NOERROR;	// oh well
	
    hr = pFilter->EnumPins(&pins);
    pFilter->Release();
    if (SUCCEEDED(hr)) {
        DWORD n;
        hr = pins->Next(1, &pPin, &n);
	if (hr == S_OK) {
	    ASSERT(m_pPin == NULL);
	    m_pPin = pPin;
	}
        pins->Release();
    }
    return NOERROR;
}


HRESULT CPropPage::OnDisconnect()
{
    DbgLog((LOG_TRACE,2,TEXT("Releasing IVfwCaptureOptions")));
    if (m_pOpt)
        m_pOpt->Release();
    m_pOpt = NULL;
    if (m_pPin)
        m_pPin->Release();
    m_pPin = NULL;
    return NOERROR;
}


// Handles the messages for our property window
//
INT_PTR CPropPage::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   HRESULT hr = E_FAIL;
   const int versize = 40;
   const int descsize = 40;

   DbgLog((LOG_TRACE,99,TEXT("CPropPage::DialogProc  %08x %04x %08x %08x"),
				hwnd, uMsg, wParam, lParam));

   switch (uMsg)
      {
      case WM_INITDIALOG:

   // alpha compiler bug blows up if we don't encase this case in braces
   {

         DbgLog((LOG_TRACE,2,TEXT("Initializing the Dialog Box")));
	 CAPTURESTATS cs;
	 m_pOpt->VfwCapGetCaptureStats(&cs);
	 SetDlgItemInt(hwnd, ID_FRAMESCAPTURED, (int)cs.dwlNumCaptured, FALSE);
	 SetDlgItemInt(hwnd,ID_MSCAPTURED,(int)(cs.msCaptureTime / 1000),FALSE);
	 SetDlgItemInt(hwnd, ID_FRAMESDROPPED, (int)cs.dwlNumDropped, FALSE);
	 SetDlgItemInt(hwnd, ID_FRAMESPERSEC,(int)cs.flFrameRateAchieved,FALSE);
	 SetDlgItemInt(hwnd, ID_BYTESPERSEC, (int)cs.flDataRateAchieved, FALSE);

	 // Which dialog boxes does this driver have?
	 EnableWindow(GetDlgItem(hwnd, ID_SOURCE),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_EXTERNALIN, VIDEO_DLG_QUERY) == 0);
	 EnableWindow(GetDlgItem(hwnd, ID_FORMAT),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_IN, VIDEO_DLG_QUERY) == 0);
	 EnableWindow(GetDlgItem(hwnd, ID_DISPLAY),
                		m_pOpt->VfwCapDriverDialog(hwnd,
				VIDEO_EXTERNALOUT, VIDEO_DLG_QUERY) == 0);
			
	 // put the driver name in the dialog box
	 WCHAR wachVer[versize], wachDesc[descsize];
	 TCHAR tachDesc[versize + descsize + 5];
	 long lCap;
	 IAMVideoCompression *pVC;
	 if (m_pPin)
             hr = m_pPin->QueryInterface(IID_IAMVideoCompression,
								(void **)&pVC);
	 if (hr == NOERROR) {
	     LONG l1, l2;
             double l3;
	     hr = pVC->GetInfo(wachVer, (int *)&versize, wachDesc,
					(int *)&versize, &l1, &l2, &l3, &lCap);
	     if (hr == NOERROR) {
		 wsprintf(tachDesc, TEXT("%ls   %ls"), wachDesc, wachVer);
	         SetDlgItemText(hwnd, ID_DESC, tachDesc);
	     }
	     pVC->Release();
	 }

         return TRUE;
   }


      case WM_COMMAND:
         {
         UINT uID = GET_WM_COMMAND_ID(wParam,lParam);
         switch (uID)
            {
            case ID_SOURCE:
            case ID_FORMAT:
            case ID_DISPLAY:
                static UINT auType[] = {VIDEO_EXTERNALIN, VIDEO_IN,
							VIDEO_EXTERNALOUT};
                if (m_pOpt->VfwCapDriverDialog(hwnd,
				auType[uID - ID_SOURCE], FALSE) == NOERROR)
                    m_bDirty = TRUE;
                break;
            }
         }
         return TRUE;
      }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\thunk.c ===
/*****************************************************************************
 *
 *  Thunk.c
 *
 *  Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Thunking to 16-bit code without using the thunk compiler.
 *      This is important if you want your DLL to run on both Win95
 *      and Windows NT.
 *
 *****************************************************************************/

#pragma warning(disable:4054)           /* cannot cast to function ptr */
#pragma warning(disable:4055)           /* cannot cast from function ptr */

#pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
#pragma warning(disable:4201)           /* winnt.h: nameless union */
#pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
#pragma warning(disable:4514)           /* winnt.h: fiber goo */

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <pshpack1.h>                   /* Byte packing, please */

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define pvAdd(pv, cb) ((LPVOID)((LPSTR)(pv) + (DWORD)(cb)))
#define pvSub(pv1, pv2) (DWORD)((LPSTR)(pv1) - (LPSTR)(pv2))

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT_PTR ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAdd(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                                pvAdd(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAdd(pidh, pedt->AddressOfFunctions);
                fp = (FARPROC)pvAdd(pidh, peat[ord - pedt->Base]);
                if (pvSub(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  This structure starts out life as the things that we will GetProcAddress
 *  for.  And then it turns into pointers to functions.
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

static TCHAR c_tszKernel32[] = TEXT("KERNEL32");

static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "QT_Thunk",
    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
};

#pragma END_CONST_DATA

typedef struct MANUALIMPORTTABLE {  /* mit */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    void        (__cdecl *QT_Thunk)(void);
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);

} MIT;

static MIT s_mit;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *          l = a 32-bit integer
 *          s = a 16-bit integer
 *
 *          P = returns a pointer
 *          L = returns a 32-bit integer
 *          S = returns a 16-bit signed integer
 *          U = returns a 16-bit unsigned integer
 *
 *  @parm   FARPROC | fp |
 *
 *          16:16 function to call.
 *
 *  @parm   PCSTR | pszSig |
 *
 *          Function signature.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifndef NON_X86
__declspec(naked) DWORD
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.MapLS;            /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    s_mit.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    s_mit.MapSL;            /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.UnMapLS;          /* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}
#else
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
        return  0;
}
#endif

#pragma warning(default:4035)

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          Initialize the various goo we need in KERNEL32.
 *
 *          Returns FALSE if we cannot initialize the thunks.
 *          (For example, if the platform doesn't support flat thunks.)
 *
 *          Note that you must never ever call this function more
 *          than once.
 *
 ***************************************************************************/

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#endif

#pragma BEGIN_CONST_DATA

static char c_szVidx16[] = "VIDX16.DLL";

static LPCSTR c_rgpszVidx16[] = {
    (LPCSTR)6,      /* vidxAllocHeaders             */
    (LPCSTR)7,      /* vidxFreeHeaders              */
    (LPCSTR)8,      /* vidxAllocBuffer              */
    (LPCSTR)9,      /* vidxAllocPreviewBuffer       */
    (LPCSTR)10,     /* vidxFreeBuffer               */
    (LPCSTR)11,     /* vidxSetRect                  */
    (LPCSTR)12,     /* vidxFrame                    */
    (LPCSTR)13,     /* vidxAddBuffer                */
    (LPCSTR)14,     /* vidxGetErrorText             */
    (LPCSTR)15,     /* vidxUpdate                   */
    (LPCSTR)16,     /* vidxDialog                   */
    (LPCSTR)17,     /* vidxStreamInit               */
    (LPCSTR)18,     /* vidxStreamFini               */
    (LPCSTR)19,     /* vidxConfigure                */
    (LPCSTR)20,     /* vidxOpen                     */
    (LPCSTR)21,     /* vidxClose                    */
    (LPCSTR)22,     /* vidxGetChannelCaps           */
    (LPCSTR)23,     /* vidxStreamReset              */
    (LPCSTR)24,     /* vidxStreamStart              */
    (LPCSTR)25,     /* vidxStreamStop               */
    (LPCSTR)26,     /* vidxStreamUnprepareHeader    */
    (LPCSTR)27,     /* vidxCapDriverDescAndVer      */
    (LPCSTR)28,     /* vidxMessage      	    */
    (LPCSTR)29,     /* vidxFreePreviewBuffer        */
};

#pragma END_CONST_DATA

static HINSTANCE s_hinstVidx16;

static FARPROC s_rgfpVidx16[ARRAYSIZE(c_rgpszVidx16)];

#define s_fpvidxAllocHeaders            s_rgfpVidx16[0]
#define s_fpvidxFreeHeaders             s_rgfpVidx16[1]
#define s_fpvidxAllocBuffer             s_rgfpVidx16[2]
#define s_fpvidxAllocPreviewBuffer      s_rgfpVidx16[3]
#define s_fpvidxFreeBuffer              s_rgfpVidx16[4]
#define s_fpvidxSetRect                 s_rgfpVidx16[5]
#define s_fpvidxFrame                   s_rgfpVidx16[6]
#define s_fpvidxAddBuffer               s_rgfpVidx16[7]

#define s_fpvideoGetErrorText           s_rgfpVidx16[8]
#define s_fpvideoUpdate                 s_rgfpVidx16[9]
#define s_fpvideoDialog                 s_rgfpVidx16[10]
#define s_fpvideoStreamInit             s_rgfpVidx16[11]
#define s_fpvideoStreamFini             s_rgfpVidx16[12]
#define s_fpvideoConfigure              s_rgfpVidx16[13]
#define s_fpvideoOpen                   s_rgfpVidx16[14]
#define s_fpvideoClose                  s_rgfpVidx16[15]
#define s_fpvideoGetChannelCaps         s_rgfpVidx16[16]
#define s_fpvideoStreamReset            s_rgfpVidx16[17]
#define s_fpvideoStreamStart            s_rgfpVidx16[18]
#define s_fpvideoStreamStop             s_rgfpVidx16[19]
#define s_fpvideoStreamUnprepareHeader  s_rgfpVidx16[20]
#define s_fpvideoCapDriverDescAndVer    s_rgfpVidx16[21]
#define s_fpvideoMessage    		s_rgfpVidx16[22]
#define s_fpvidxFreePreviewBuffer       s_rgfpVidx16[23]

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkTerm |
 *
 *          Free it.
 *
 ***************************************************************************/

void NTAPI
ThunkTerm(void)
{
    if (s_hinstVidx16) {
        s_mit.FreeLibrary16(s_hinstVidx16);
        s_hinstVidx16 = 0;
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE NTAPI
ThunkGetProcAddresses(FARPROC rgfp[], LPCSTR rgpsz[], UINT cfp,
                      LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = s_mit.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = s_mit.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                s_mit.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          GetProcAddress16 our brains out.
 *
 ***************************************************************************/

BOOL NTAPI
ThunkInit(void)
{
    HINSTANCE hinstK32 = GetModuleHandle(c_tszKernel32);
    BOOL fRc;

    if (hinstK32) {
        int i;
        FARPROC *rgfpMit = (LPVOID)&s_mit;

        for (i = 0; i < ARRAYSIZE(c_rgpszKernel32); i++) {
            if ((LONG_PTR)(c_rgpszKernel32[i]) & ~(LONG_PTR)65535) {
                rgfpMit[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
            } else {
                rgfpMit[i] = GetProcOrd(hinstK32, (UINT_PTR)c_rgpszKernel32[i]);
            }
            if (!rgfpMit[i]) return FALSE;  /* Aigh! */
        }

        s_hinstVidx16 =
            ThunkGetProcAddresses(s_rgfpVidx16, c_rgpszVidx16,
                                  ARRAYSIZE(s_rgfpVidx16),
                                  c_szVidx16);

        if (!s_hinstVidx16) {
            goto failed;
        }

        fRc = 1;

    } else {
    failed:;
        ThunkTerm();

        fRc = 0;
    }

    return fRc;
}


/***************************************************************************
 *
 *  Now come the actual thunklets.
 *
 ***************************************************************************/

// typedef DWORD   HDR32;
// typedef DWORD   HVIDEO;
// typedef DWORD  *LPHVIDEO;
typedef struct channel_caps_tag CHANNEL_CAPS, *LPCHANNEL_CAPS;


#include "ivideo32.h"

typedef PTR32 FAR * PPTR32;

extern int g_IsNT;


#define tHVIDEO                 "l"
#define tUINT                   "s"
#define tHWND                   "s"
#define tHDC                    "s"
#define tint                    "s"
#define tDWORD                  "l"
#define tLPARAM                 "l"
#define tDWORD_PTR              "l"	// exactly like DWORD, or we'll blow up
#define tHDR32                  "l"
#define tPTR32                  "l"
#define tLPVIDEOHDR             "p"	// was l
#define tLPVOID                 "p"
#define tLPDWORD                "p"
#define tPPTR32                 "p"
#define tLPSTR                  "p"
#define tLPTSTR                 "p"
#define tLPHVIDEO               "p"
#define tLPCHANNEL_CAPS         "p"
#define rDWORD                  "L"
#define rLRESULT                "L"

#pragma BEGIN_CONST_DATA


#define MAKETHUNK1(rT, fn, t1, a1)                                          \
rT NTAPI                                                                    \
fn(t1 a1)                                                                   \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1);                                                  \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1                                                       \
        r##rT,     a1);                                                     \
}                                                                           \

#define MAKETHUNK2(rT, fn, t1, a1, t2, a2)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2)                                                            \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2);                                               \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2                                                 \
        r##rT,   a1,     a2);                                               \
}                                                                           \

#define MAKETHUNK3(rT, fn, t1, a1, t2, a2, t3, a3)                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3)                                                     \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3);                                            \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3                                           \
        r##rT,   a1,     a2,   a3);                                         \
}                                                                           \

#define MAKETHUNK4(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4)                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4)                                              \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4);                                         \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4                                     \
        r##rT,     a1,   a2,   a3,   a4);                                   \
}                                                                           \

#define MAKETHUNK5(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5)          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5)                                       \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5);                                      \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5                               \
        r##rT,     a1,   a2,   a3,   a4,   a5);                             \
}                                                                           \

#define MAKETHUNK6(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6)  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6)                                \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6);                                   \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6                         \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6);                       \
}                                                                           \

#define MAKETHUNK7(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7)                                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7)                         \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7);                                \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7                   \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7);                 \
}                                                                           \

#define MAKETHUNK8(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7, t8, a8)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7, t8 a8)                  \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7,a8);                             \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7 t##t8             \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7,   a8);           \
}                                                                           \

MAKETHUNK4(DWORD,   vidxAllocHeaders,
           HVIDEO,  hv,
           UINT,    nHeaders,
           UINT,    cbHeader,
           PPTR32,  lp32Hdrs)

MAKETHUNK1(DWORD,   vidxFreeHeaders,
           HVIDEO,  hv)

MAKETHUNK4(DWORD,   vidxAllocBuffer,
           HVIDEO,  hv,
           UINT,    iHdr,
           PPTR32,  pp32Hdr,
           DWORD,   dwSize)

MAKETHUNK4(DWORD,   vidxAllocPreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr,
           UINT,    cbHdr,
           DWORD,   cbData)

MAKETHUNK2(DWORD,   vidxFreePreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr)

MAKETHUNK2(DWORD,   vidxFreeBuffer,
           HVIDEO,  hv,
           DWORD,   p32Hdr)

MAKETHUNK4(DWORD,   videoGetErrorText,
           HVIDEO,  hv,
           UINT,    wError,
           LPTSTR,   lpText,
           UINT,    wSize)

MAKETHUNK6(DWORD,   vidxSetRect,
           HVIDEO,  hv,
           UINT,    wMsg,
           int,     left,
           int,     top,
           int,     right,
           int,     bottom)

MAKETHUNK3(DWORD,   videoUpdate,
           HVIDEO,  hv,
           HWND,    hWnd,
           HDC,     hDC)

MAKETHUNK3(DWORD,   videoDialog,
           HVIDEO,  hv,
           HWND,    hWndParent,
           DWORD,   dwFlags)

MAKETHUNK5(DWORD,   videoStreamInit,
           HVIDEO,  hvideo,
           DWORD,   dwMicroSecPerFrame,
           DWORD_PTR,   dwCallback,
           DWORD_PTR,   dwCallbackInst,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoStreamFini,
           HVIDEO,  hvideo)

MAKETHUNK2(DWORD,   vidxFrame,
           HVIDEO,  hvideo,
           LPVIDEOHDR, p32hdr)

MAKETHUNK8(DWORD,   videoConfigure,
           HVIDEO,  hvideo,
           UINT,    msg,
           DWORD,   dwFlags,
           LPDWORD, lpdwReturn,
           LPVOID,  lpData1,
           DWORD,   dwSize1,
           LPVOID,  lpData2,
           DWORD,   dwSize2)

MAKETHUNK3(DWORD,   videoOpen,
           LPHVIDEO,phv,
           DWORD,   dwDevice,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoClose,
           HVIDEO,  hv)

MAKETHUNK3(DWORD,   videoGetChannelCaps,
           HVIDEO,  hv,
           LPCHANNEL_CAPS, lpcc,
           DWORD,  dwSize)

MAKETHUNK3(DWORD,   vidxAddBuffer,
           HVIDEO,  hvideo,
           PTR32,   p32Hdr,
           DWORD,   dwSize)

MAKETHUNK1(DWORD,   videoStreamReset,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStart,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStop,
           HVIDEO,  hvideo)

MAKETHUNK3(DWORD,   videoStreamUnprepareHeader,
           HVIDEO,  hvideo,
           LPVIDEOHDR,   lpVHdr,
           DWORD,   dwSize)

MAKETHUNK5(DWORD,   videoCapDriverDescAndVer,
           DWORD,  dwDeviceID,
           LPTSTR, lpszDesc,
           UINT,   cbDesc,
           LPTSTR, lpszVer,
           UINT,   cbVer)

MAKETHUNK4(LRESULT,   videoMessage,
           HVIDEO,  hVideo,
           UINT,    uMsg,
           LPARAM,   dw1,
           LPARAM,   dw2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\stream.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <streams.h>
#include "driver.h"
#include "common.h"
#include "ivideo32.h"

extern "C" {
    extern int g_IsNT;
};

// turn on performance measuring code
//
//#define JMK_HACK_TIMERS
#include "cmeasure.h" // perf logging stuff


#ifndef _WIN64
// on Win95 we have to convert the event handle we will be using as a
// callback into a VxD handle, on NT this is unnecessary.
// since the Win95 kernel does not publish this entry point and it does
// not exist on NT, we dynamically link to it
//
static DWORD WINAPI OpenVxDHandle(
    HANDLE hEvent)
{
    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    GetVersionEx(&osv);
    if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
       {
       #define idOpenVxDHandle "OpenVxDHandle"
       typedef DWORD (WINAPI *PFNOPENVXDHANDLE)(HANDLE);
       static DWORD (WINAPI *pfnOpenVxDHandle)(HANDLE);
       if ( ! pfnOpenVxDHandle)
          {
          HMODULE hModule = GetModuleHandle(TEXT("Kernel32"));
          if (!hModule)
             {
             ASSERT(0);
             return 0;
             }
          pfnOpenVxDHandle = (PFNOPENVXDHANDLE)GetProcAddress (hModule, idOpenVxDHandle);
          if ( ! pfnOpenVxDHandle)
             {
             ASSERT (0);
             return 0;
             }
          }
       return pfnOpenVxDHandle (hEvent);
       }
    else
       return (DWORD)hEvent;
}
#endif

#define ONEMEG (1024L * 1024L)
DWORD_PTR GetFreePhysicalMemory(void)
{
    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);

    GlobalMemoryStatus(&ms);

    if (ms.dwTotalPhys > 8L * ONEMEG)
        return ms.dwTotalPhys - ONEMEG * 4;

    #define FOREVER_FREE 32768L   // Always keep this free for swap space
    return (ms.dwTotalPhys / 2) - FOREVER_FREE;
}

// =============== IMemAllocator interfaces ======================

CCapStream::CAlloc::CAlloc(
    TCHAR      * pname,
    CCapStream * pStream,
    HRESULT    * phr)
    :
    CUnknown(pname, pStream->GetOwner()),
    m_pStream(pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::CAlloc constructor")));
}

CCapStream::CAlloc::~CAlloc()
{
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::CAlloc destructor")));

static int iDestructorCalls = 0;
++iDestructorCalls;
}

#if 0
// override this to publicise our interfaces
STDMETHODIMP
CCapStream::CAlloc::NonDelegatingQueryInterface (
   REFIID riid,
   void **ppv)
{
   if (riid == IID_IMemAllocator)
      return GetInterface((IMemAllocator *) this, ppv);
   return m_pStream->NonDelegatingQueryInterface(riid, ppv);
}
#endif

STDMETHODIMP
CCapStream::CAlloc::SetProperties (
   ALLOCATOR_PROPERTIES * pRequest,
   ALLOCATOR_PROPERTIES * pActual)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::SetProperties")));

   // if we have already allocated headers & buffers
   // ignore the requested and return the actual.
   // otherwise, make a note of the requested so that
   // we can honour it later.
   //
   if ( ! m_pStream->Committed())
      {
      parms.cBuffers  = pRequest->cBuffers;
      parms.cbBuffer  = pRequest->cbBuffer;
      parms.cbAlign   = pRequest->cbAlign;
      parms.cbPrefix  = pRequest->cbPrefix;
      }

   pActual->cBuffers     = (long)parms.cBuffers;
   pActual->cbBuffer     = (long)parms.cbBuffer;
   pActual->cbAlign      = (long)parms.cbAlign;
   pActual->cbPrefix     = (long)parms.cbPrefix;

   return S_OK;
}

STDMETHODIMP
CCapStream::CAlloc::GetProperties (
   ALLOCATOR_PROPERTIES * pProps)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::GetProperties")));

   pProps->cBuffers = (long)parms.cBuffers;
   pProps->cbBuffer = (long)parms.cbBuffer;
   pProps->cbAlign = (long)parms.cbAlign;
   pProps->cbPrefix = (long)parms.cbPrefix;
   return S_OK;
}

// override Commit to allocate memory. We handle the GetBuffer
//state changes
STDMETHODIMP
CCapStream::CAlloc::Commit ()
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::Commit")));

   return S_OK;
}

// override this to handle the memory freeing. We handle any outstanding
// GetBuffer calls
STDMETHODIMP
CCapStream::CAlloc::Decommit ()
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::Decommit")));

   return S_OK;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct. The two time parameters are
// optional and either may be NULL, they may alternatively be set to
// the start and end times the sample will have attached to it

STDMETHODIMP
CCapStream::CAlloc::GetBuffer (
   IMediaSample **ppBuffer,
   REFERENCE_TIME * pStartTime,
   REFERENCE_TIME * pEndTime,
   DWORD dwFlags)
{
   DbgLog((LOG_TRACE,2,TEXT("CAlloc::GetBuffer")));

   return E_FAIL;
}

// final release of a IMediaSample will call this
STDMETHODIMP
CCapStream::CAlloc::ReleaseBuffer (
   IMediaSample * pSample)
{
   DbgLog((LOG_TRACE,5,TEXT("CAlloc::ReleaseBuffer")));

   LPTHKVIDEOHDR ptvh = ((CFrameSample *)pSample)->GetFrameHeader();

   ASSERT (ptvh == &m_pStream->m_cs.tvhPreview || (CFrameSample *)ptvh->dwUser == pSample );
   return m_pStream->ReleaseFrame(ptvh);
}

HRESULT
CCapStream::ConnectToDriver()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::ConnectToDriver")));

   // Open and initialize all the channels in the SAME ORDER that AVICap did,
   // for compatability with buggy drivers like Broadway and BT848.

   // Open the VIDEO_IN driver, the one we mostly talk to, and who provides
   // the video FORMAT dialog
   m_cs.mmr = videoOpen(&m_cs.hVideoIn, m_user.uVideoID, VIDEO_IN);
   if (m_cs.mmr)
      {
      ASSERT(!"Failed videoOpen - Aborting");
      return VFW_E_NO_CAPTURE_HARDWARE;
      }

   // Now open the EXTERNALIN device.  He's only good for providing the video
   // SOURCE dialog, so it doesn't really matter if we can't get him
   m_cs.hVideoExtIn = NULL;
   m_cs.mmr = videoOpen(&m_cs.hVideoExtIn, m_user.uVideoID, VIDEO_EXTERNALIN);

  #if 0
   if (m_cs.mmr)
      {
      ASSERT(!"Failed videoOpen - Aborting");
      videoClose (m_cs.hVideoIn);
      return E_FAIL;
      }
  #endif

   // Now open the EXTERNALOUT device.  He's only good for providing the video
   // DISPLAY dialog, and for overlay, so it doesn't really matter if we can't
   // get him
   m_cs.hVideoExtOut = NULL;

   // Do we support overlay?
   m_cs.bHasOverlay = FALSE;
   if (videoOpen(&m_cs.hVideoExtOut, m_user.uVideoID, VIDEO_EXTERNALOUT) ==
								DV_ERR_OK) {
	CHANNEL_CAPS VideoCapsExternalOut;
        if (m_cs.hVideoExtOut && videoGetChannelCaps(m_cs.hVideoExtOut,
                &VideoCapsExternalOut, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
            m_cs.bHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                				(DWORD)VCAPS_OVERLAY);
        } else {
            DbgLog((LOG_TRACE,2,TEXT("*** ERROR calling videoGetChannelCaps")));
	}
   } else {
       DbgLog((LOG_ERROR,1,TEXT("*** ERROR opening VIDEO_EXTERNALOUT")));
   }

   // VidCap does this, so I better too or some cards will refuse to preview
   if (m_cs.mmr == 0)
       videoStreamInit(m_cs.hVideoExtIn, 0, 0, 0, 0);

   if (m_pCap->m_fAvoidOverlay) {
       m_cs.bHasOverlay = FALSE;
   }

   if (m_cs.bHasOverlay)
       DbgLog((LOG_TRACE,1,TEXT("Driver supports OVERLAY")));
   else
       DbgLog((LOG_TRACE,1,TEXT("Driver does NOT support OVERLAY")));

   return S_OK;
}

HRESULT
CCapStream::DisconnectFromDriver()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::DisconnectFromDriver")));

   if (m_cs.hVideoIn)
      videoClose (m_cs.hVideoIn);
   if (m_cs.hVideoExtIn) {
      videoStreamFini(m_cs.hVideoExtIn);	// this one was streaming
      videoClose (m_cs.hVideoExtIn);
   }
   if (m_cs.hVideoExtOut)
      videoClose (m_cs.hVideoExtOut);
   return S_OK;
}

HRESULT
CCapStream::InitPalette ()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::InitPalette")));

   struct {
      WORD         wVersion;
      WORD         wNumEntries;
      PALETTEENTRY aEntry[256];
      } pal;
   ZeroMemory(&pal, sizeof(pal));
   pal.wVersion = 0x0300;
   pal.wNumEntries = 256;

   // if we are connected to a driver. query it for its
   // palette, otherwise use the default system palette
   //
   if ( ! m_cs.hVideoIn ||
        DV_ERR_OK  != videoConfigure (m_cs.hVideoIn,
                                      DVM_PALETTE,
                                      VIDEO_CONFIGURE_GET
                                      | VIDEO_CONFIGURE_CURRENT,
                                      NULL,
                                      &pal,
                                      sizeof(pal),
                                      NULL,
                                      0))
      {
      HPALETTE hPal = (HPALETTE)GetStockObject (DEFAULT_PALETTE);
      GetObject (hPal, sizeof(pal.wNumEntries), &pal.wVersion);
      ASSERT (pal.wNumEntries <= NUMELMS(pal.aEntry));
      pal.wNumEntries = min(pal.wNumEntries,NUMELMS(pal.aEntry));
      GetPaletteEntries(hPal, 0, pal.wNumEntries, pal.aEntry);
      }

   // convert the palette into a bitmapinfo set of RGBQUAD's
   //
   ASSERT (m_user.pvi);
   RGBQUAD *      pRGB = ((LPBITMAPINFO)&m_user.pvi->bmiHeader)->bmiColors;
   PALETTEENTRY * pe   = pal.aEntry;
   for (UINT ii = 0; ii < (UINT)pal.wNumEntries; ++ii, ++pRGB, ++pe)
      {
      pRGB->rgbBlue  = pe->peBlue;
      pRGB->rgbGreen = pe->peGreen;
      pRGB->rgbRed   = pe->peRed;
      //pRGB->rgbReserved = pe->peFlags;
      }

   m_user.pvi->bmiHeader.biClrUsed = pal.wNumEntries;

   return S_OK;
}

//
// tell the driver what format to use
//
HRESULT CCapStream::SendFormatToDriver(VIDEOINFOHEADER *pvi)
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::SendFormatToDriver")));

    ASSERT (m_cs.hVideoIn && pvi);
    if (!m_cs.hVideoIn || !pvi)
	return E_FAIL;

    if (videoConfigure(m_cs.hVideoIn,
                      DVM_FORMAT,
                      VIDEO_CONFIGURE_SET, NULL,
                      &pvi->bmiHeader,
                      pvi->bmiHeader.biSize,
                      NULL, 0))
	return VFW_E_INVALIDMEDIATYPE;

// nobody really supports VIDEOIN source or dest rectangles.  Even if they
// did, I'm not sure what I should do about it
#if 0
    // If we have specific rectangles, use them, otherwise use Width x Height
    DWORD dwErrSrc, dwErrDst;
    if (pvi->rcSource.right && pvi->rcSource.bottom) {
	dwErrSrc = vidxSetRect(m_cs.hVideoIn, DVM_SRC_RECT, pvi->rcSource.left,
		pvi->rcSource.top, pvi->rcSource.right, pvi->rcSource.bottom);
    } else {
	dwErrSrc = vidxSetRect(m_cs.hVideoIn, DVM_SRC_RECT, 0, 0,
		pvi->bmiHeader.biWidth, pvi->bmiHeader.biHeight);
    }

    if (pvi->rcTarget.right && pvi->rcTarget.bottom) {
	dwErrDst = vidxSetRect(m_cs.hVideoIn, DVM_DST_RECT, pvi->rcTarget.left,
		pvi->rcTarget.top, pvi->rcTarget.right, pvi->rcTarget.bottom);
    } else {
	dwErrDst = vidxSetRect(m_cs.hVideoIn, DVM_DST_RECT, 0, 0,
		pvi->bmiHeader.biWidth, pvi->bmiHeader.biHeight);
    }
#endif

    // !!! Do I need to set the palette too?  Do I care?

    return S_OK;
}

//
// ask the driver what format to use, and stuff that in our internal VIDEOINFOH
// Use the current VIDEOINFOHEADER's data rate and frame rate
//
HRESULT CCapStream::GetFormatFromDriver ()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::GetFormatFromDriver")));

    ASSERT (m_cs.hVideoIn);
    if ( ! m_cs.hVideoIn)
	return E_FAIL;

    // How large is the BITMAPINFOHEADER?
    DWORD biSize = 0;
    videoConfigure(m_cs.hVideoIn, DVM_FORMAT,
                   VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
                   &biSize, 0, 0, NULL, 0);
    if ( ! biSize)
	biSize = sizeof (BITMAPINFOHEADER);

    // allocate space for a videoinfo that will hold it
    //
    UINT cb = sizeof(VIDEOINFOHEADER)
             + biSize - sizeof(BITMAPINFOHEADER)
             + sizeof(RGBQUAD) * 256;	// space for PALETTE or BITFIELDS
    VIDEOINFOHEADER * pvi = (VIDEOINFOHEADER *)(new BYTE[cb]);
    
    if ( ! pvi)
	    return E_OUTOFMEMORY;
    LPBITMAPINFOHEADER pbih = &pvi->bmiHeader;
    

    if (videoConfigure(m_cs.hVideoIn, DVM_FORMAT,
                       VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
                       pbih, biSize, NULL, 0)) {
	// very bad. the driver can't tell us its format. we're hosed.
	ASSERT(!"Cant get format from driver");
    delete [] (BYTE *) pvi;
	return E_FAIL;
    }

    if (pvi->bmiHeader.biSizeImage == 0 &&
			(pvi->bmiHeader.biCompression == BI_RGB ||
			pvi->bmiHeader.biCompression == BI_BITFIELDS)) {
        DbgLog((LOG_TRACE,2,TEXT("Fixing biSizeImage from a broken driver")));
	pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
    }

    // dont require that we've already got a videoinfo, but
    // we expect it. so assert that it's true.
    //
    ASSERT (m_user.pvi);
    if (m_user.pvi) {

	// I assuming preserving these is the best philosophy
	pvi->rcSource = m_user.pvi->rcSource;
	pvi->rcTarget = m_user.pvi->rcTarget;
	pvi->dwBitRate = m_user.pvi->dwBitRate;
	pvi->dwBitErrorRate = m_user.pvi->dwBitErrorRate;
	pvi->AvgTimePerFrame = m_user.pvi->AvgTimePerFrame;

// Do not touch the source and target rectangles.  Leave them as they were.
// This won't compile anyway
#if 0
	RECT rcSrc, rcDst;
        DWORD dwErrSrc = 1, dwErrDst = 1;

	// This won't compile
	dwErrSrc = videoMessage(m_cs.hVideoIn, DVM_SRC_RECT, &rcSrc,
				CONFIGURE_GET | CONFIGURE_GET_CURRENT);
	dwErrDst = videoMessage(m_cs.hVideoIn, DVM_DST_RECT, &rcDst,
				CONFIGURE_GET | CONFIGURE_GET_CURRENT);

	if (dwErrSrc || dwErrDst)
	    DbgLog((LOG_ERROR,1,TEXT("vidxGetRect FAILED!")));

	if (dwErrSrc == 0 && rcSrc.right && rcSrc.bottom) {
	    pvi->rcSource.left = rcSrc.left;
	    pvi->rcSource.top = rcSrc.top;
	    pvi->rcSource.right = rcSrc.right;
	    pvi->rcSource.bottom = rcSrc.bottom;
	} else {
	    pvi->rcSource.left = pvi->rcSource.top = 0;
	    pvi->rcSource.right = pvi->bmiHeader.biWidth;
	    pvi->rcSource.bottom = pvi->bmiHeader.biHeight;
	}
	if (dwErrDst == 0 && rcDst.right && rcDst.bottom) {
	    pvi->rcTarget.left = rcDst.left;
	    pvi->rcTarget.top = rcDst.top;
	    pvi->rcTarget.right = rcDst.right;
	    pvi->rcTarget.bottom = rcDst.bottom;
	} else {
	    pvi->rcTarget.left = pvi->rcTarget.top = 0;
	    pvi->rcTarget.right = pvi->bmiHeader.biWidth;
	    pvi->rcTarget.bottom = pvi->bmiHeader.biHeight;
	}
#endif

	delete [] m_user.pvi;
    }

    m_user.pvi = pvi;
    m_user.cbFormat = cb;

    // BOGUS cap is broken and doesn't reset num colours
    // WINNOV reports 256 colours of 24 bit YUV8 - scary!
    if (m_user.pvi->bmiHeader.biBitCount > 8)
	m_user.pvi->bmiHeader.biClrUsed = 0;

    return S_OK;
}


// called when stopping. flush any buffers that may
// be still downstream
HRESULT
CCapStream::Flush()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::Flush")));

   BeginFlush();
   EndFlush();

   return S_OK;
}

HRESULT
CCapStream::Prepare()
{
   DbgLog((LOG_TRACE,2,TEXT("CCapStream::Prepare")));

   HRESULT hr = E_OUTOFMEMORY;
   m_cs.paHdr = NULL;
   m_cs.hEvtBufferDone = NULL;
   m_cs.h0EvtBufferDone = 0;
   m_cs.llLastTick = (LONGLONG)-1;
   m_cs.uiLastAdded = (UINT)-1;
   m_cs.dwFirstFrameOffset = 0;
   m_cs.llFrameCountOffset = 0;
   m_cs.fReRun = FALSE;
   m_cs.rtLastStamp = 0;
   m_cs.rtDriverLatency = -1;	// not set yet
   m_cs.fLastSampleDiscarded = FALSE;
   //m_cs.cbVidHdr = sizeof(VIDEOHDREX);
   m_cs.cbVidHdr = sizeof(VIDEOHDR);

   // reset stats every time we stream
   m_capstats.dwlNumDropped = 0;
   m_capstats.dwlNumCaptured = 0;
   m_capstats.dwlTotalBytes = 0;
   m_capstats.msCaptureTime = 0;
   m_capstats.flFrameRateAchieved = 0.;
   m_capstats.flDataRateAchieved = 0.;

   // can't do anything if no videoformat has been choosen
   //
   if ( ! m_user.pvi)
      {
      DbgLog((LOG_ERROR,1,TEXT("no video format chosen")));
      goto bail;
      }

   m_cs.hEvtBufferDone = CreateEvent (NULL, FALSE, FALSE, NULL);
   if (!m_cs.hEvtBufferDone)
      {
      DbgLog((LOG_ERROR,1,TEXT("failed to create buffer done event")));
      goto bail;
      }

#ifndef _WIN64
   m_cs.h0EvtBufferDone = OpenVxDHandle(m_cs.hEvtBufferDone);
#else
   m_cs.h0EvtBufferDone = (DWORD_PTR)m_cs.hEvtBufferDone;
#endif
   if (!m_cs.h0EvtBufferDone)
      {
      DbgLog((LOG_ERROR,1,TEXT("failed to create event's Ring 0 handle")));
      goto bail;
      }

   // for each buffer, allocate the user requested size
   // Also, align allocation size up to nearest align boundary
   //
   m_cs.cbBuffer = m_Alloc.parms.cbPrefix + m_Alloc.parms.cbBuffer;
   ASSERT(m_user.pvi->bmiHeader.biSizeImage + m_Alloc.parms.cbPrefix
				<= m_cs.cbBuffer);
   // Allocate cbAlign bytes too much so we can align the buffer start
   m_cs.cbBuffer += m_Alloc.parms.cbAlign;

   // try to get the requested number of buffers, but make sure
   // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
   //
   m_cs.nHeaders = max(m_Alloc.parms.cBuffers, (long)m_user.nMinBuffers);
   m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);

   // limit the number of buffers to the amount of physical
   // memory (since we will try to keep them all locked down
   // at once)
   //
   if (m_cs.nHeaders > m_user.nMinBuffers)
      {
      DWORD_PTR dwFree;
      DWORDLONG dwlUser;

      // How much actual free physical memory exists?
      dwFree = GetFreePhysicalMemory();

      // How much memory will be used if we allocate per the request?
      dwlUser = (m_cs.cbBuffer * m_cs.nHeaders);

      DbgLog((LOG_TRACE,2,TEXT("Buffers take up %d bytes, phys mem=%d"),
						(DWORD)dwlUser, dwFree));

      // If request is greater than available memory, force fewer buffers
      //
      if (dwlUser > (DWORDLONG)dwFree)
         {
	 // only use up 80% of physical memory
         m_cs.nHeaders = (UINT)(((dwFree * 8) / 10) / m_cs.cbBuffer);
         m_cs.nHeaders = min (m_user.nMaxBuffers, m_cs.nHeaders);
         m_cs.nHeaders = max (m_user.nMinBuffers, m_cs.nHeaders);
         }
      }

   DbgLog((LOG_TRACE,2,TEXT("We are trying to get %d buffers"), m_cs.nHeaders));

   // allocate headers for all of the buffers that we will be using
   //
   if (vidxAllocHeaders(m_cs.hVideoIn,
                        m_cs.nHeaders,
                        sizeof(m_cs.paHdr[0]),
                        (LPVOID *)&m_cs.paHdr))
      {
      DbgLog((LOG_ERROR,1,TEXT("vidxAllocHeaders failed")));
      goto bail;
      }

   // allocate each buffer, if buffer allocation ever fails
   // just set the number of buffers to the number of successes
   // and continue on.
   //
   UINT ii;
   for (ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      LPTHKVIDEOHDR ptvh;

      if (vidxAllocBuffer (m_cs.hVideoIn, ii, (LPVOID *)&ptvh, m_cs.cbBuffer))
          break;
      ASSERT (ptvh == &m_cs.paHdr[ii].tvh);
      ASSERT (!IsBadWritePtr(ptvh->p32Buff, m_cs.cbBuffer));

      // fix the memory we got to obey alignment
      ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) +
							m_Alloc.parms.cbPrefix;
      // we added cbAlign up top, so take it back now
      ptvh->vh.dwBufferLength = m_cs.cbBuffer - m_Alloc.parms.cbAlign -
							m_Alloc.parms.cbPrefix;

      ptvh->vh.dwBytesUsed = 0;
      ptvh->vh.dwTimeCaptured = 0;
      ptvh->vh.dwFlags = 0;

      ptvh->dwIndex = ii;	// Which buffer is this?

      ASSERT (!IsBadWritePtr(ptvh->vh.lpData, ptvh->vh.dwBufferLength));
      DbgLog((LOG_TRACE,4,TEXT("Alloc'd: ptvh %08lX, buffer %08lX, size %d, p32 %08lX, p16 %08lX"),
           ptvh, ptvh->vh.lpData, ptvh->vh.dwBufferLength, ptvh->p32Buff, ptvh->p16Alloc));

      hr = S_OK;
      CFrameSample * pSample = new CFrameSample(&m_Alloc, &hr, ptvh);
      DbgLog((LOG_TRACE,4,TEXT("Buffer[%d] ptvh = %08lX pSample = %08lX"),
						ii, ptvh, pSample));
      ptvh->dwUser = (DWORD_PTR)pSample;
      if (FAILED(hr) || ! pSample)
         {
         DbgLog((LOG_ERROR,1,TEXT("Failed to create CFrameSample for buffer %d")
									, ii));
         break;
         }
      }
   m_cs.nHeaders = ii;

   // This is where we will remember in what order we gave the buffers to 
   // the driver
   m_pBufferQueue = (UINT *)QzTaskMemAlloc(ii * sizeof(UINT));
   //DbgLog((LOG_TRACE,5,TEXT("QUEUE: got space for %d frames"), ii));

   if (m_cs.nHeaders < m_user.nMinBuffers)
      {
      DbgLog((LOG_ERROR,1,TEXT("FAIL: %d is less than MIN_VIDEO_BUFFERS"),
								m_cs.nHeaders));
      hr = E_FAIL;
      goto bail;
      }

#ifdef TIME_DRIVER	// !!!
    long ms;
#endif

   // calculate the requested microsec per frame
   // RefTime is in 100ns units, so we divide by
   // 10 to get microsec/frame. (the +5 is to handle rounding)
   //
   {
   m_user.usPerFrame = (DWORD) ((TickToRefTime(1) + 5) / 10);

   // Open the driver for streaming access
   //
   hr = E_FAIL;
   DbgLog((LOG_TRACE,1,TEXT("Initializing with %d usPerFrame"),
						m_user.usPerFrame));

#ifdef TIME_DRIVER 	// !!!
   ms = timeGetTime();
#endif

   if (videoStreamInit(m_cs.hVideoIn,
                       m_user.usPerFrame,
                       m_cs.h0EvtBufferDone,
                       0,
                       CALLBACK_EVENT))
      {
      DbgLog((LOG_ERROR,1,TEXT("videoStreamInit failed")));
      goto bail;
      }
   }

   for (ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      ASSERT (m_cs.cbVidHdr >= sizeof(VIDEOHDR));

      // vidxAddBuffer can fail if there is not enough memory to
      // prepare (lock down) the buffer. This is ok, we will just
      // make due with the buffers that we have
      //
      if (vidxAddBuffer(m_cs.hVideoIn,
                        &m_cs.paHdr[ii].tvh.vh,
                        m_cs.cbVidHdr))
         {

// legacy VFW capture filter makes no attempt at time code/line 21
#if 0
         // if the first request to queue up an extended header
         // failed. try again with old size videohdr.
         //
         if (0 == ii && m_cs.cbVidHdr > sizeof(VIDEOHDR))
            {
            // if we succeed with the smaller header, continue on
            // otherwise, go deal with the failure.
            //
	    // Eliminate the extended VIDEOHDR stuff?
            m_cs.cbVidHdr = sizeof(VIDEOHDR);
            if ( !vidxAddBuffer(m_cs.hVideoIn,
                                &m_cs.paHdr[ii].tvh.vh,
                                m_cs.cbVidHdr))
               continue;
            }
#endif

         // free all of the pSamples that we will not be using
         //
         for (UINT jj = ii; jj < m_cs.nHeaders; ++jj)
            {
            CFrameSample * pSample = (CFrameSample *)m_cs.paHdr[jj].tvh.dwUser;
            m_cs.paHdr[jj].tvh.dwUser = 0;
            delete pSample;
            }

         // set the buffer count to the number of prepared buffers
         // note, we have no method of freeing the allocated but
         // unprepared buffers.  we will ignore them for now and free
         // them when Unprepare()
	 // I guess vidxFreeHeaders frees them all?
         //
         m_cs.nHeaders = ii;
         break;
         }
      }

      // To start with, we gave the buffers to the driver in numerical order.
      // From now on, we will use this list to know what buffer to wait for
      // next, and when we send another buffer to the driver.  We can't assume
      // they'll always be in the same order.  What if a downstream filter
      // decides to hold on to a sample longer than the next one we send it?
      UINT kk;
      for (kk = 0; kk < m_cs.nHeaders; kk++)
	  m_pBufferQueue[kk] = kk;
      m_uiQueueHead = 0;
      m_uiQueueTail = 0;

#ifdef TIME_DRIVER	// !!!
      char ach[80];
      wsprintf(ach, "Took %d ms", timeGetTime() - ms);
      MessageBox(NULL, ach, ach, MB_OK);
#endif

   DbgLog((LOG_TRACE,1,TEXT("We are capturing with %d buffers"),m_cs.nHeaders));

   // if we have 0 buffers to capture into DO NOT BAIL... bad things seem to
   // happen if you fail a Pause transition, and we start hanging later

   return S_OK;

bail:
   Unprepare();
   return hr;
}

HRESULT
CCapStream::Unprepare()
{
    DbgLog((LOG_TRACE,2,TEXT("CCapStream::Unprepare")));

    LONG lNotDropped, lDropped, lAvgFrameSize;
#ifdef DEBUG
    LONG lDroppedInfo[NUM_DROPPED], lSize;
#endif

    // Why not use our official interface to test it
    GetNumDropped(&lDropped);
    GetNumNotDropped(&lNotDropped);
    GetAverageFrameSize(&lAvgFrameSize);

    if (m_capstats.msCaptureTime) {
        m_capstats.flFrameRateAchieved = (double)(LONGLONG)lNotDropped * 1000. /
				(double)(LONGLONG)m_capstats.msCaptureTime;
        m_capstats.flDataRateAchieved = (double)(LONGLONG)lNotDropped
				/ (double)(LONGLONG)m_capstats.msCaptureTime *
 				1000. * (double)(LONGLONG)lAvgFrameSize;
    } else {
	// !!! If no frames captured, it will think msCaptureTime = 0
        m_capstats.flFrameRateAchieved = 0.;
        m_capstats.flDataRateAchieved = 0.;
    }

#ifdef DEBUG
    GetDroppedInfo(NUM_DROPPED, lDroppedInfo, &lSize);

    DbgLog((LOG_TRACE,1,TEXT("Captured %d frames in %d seconds"),
				lNotDropped,
				(int)(m_capstats.msCaptureTime / 1000)));
    DbgLog((LOG_TRACE,1,TEXT("Frame rate acheived %d.%d fps"),
					(int)m_capstats.flFrameRateAchieved,
					(int)((m_capstats.flFrameRateAchieved -
					(int)m_capstats.flFrameRateAchieved)
					* 10)));
    DbgLog((LOG_TRACE,1,TEXT("Data rate acheived %d bytes/sec"),
					(int)m_capstats.flDataRateAchieved));
    DbgLog((LOG_TRACE,1,TEXT("Dropped %d frames"),
					lDropped));
    DbgLog((LOG_TRACE,1,TEXT("=================")));
    LONG l;
    for (l=0; l < lSize; l++)
    {
        DbgLog((LOG_TRACE,2,TEXT("%d"), (int)lDroppedInfo[l]));
    }
#endif

   // Delete the Preview frame sample
   // The preview buffer is implicitly freed by closing the driver
   delete m_cs.pSamplePreview;
   //ZeroMemory (&m_cs.tvhPreview, sizeof(m_cs.tvhPreview));
   m_cs.pSamplePreview = NULL;

   for (UINT ii = 0; ii < m_cs.nHeaders; ++ii)
      {
      delete (CFrameSample *)m_cs.paHdr[ii].tvh.dwUser;
      // The buffer itself will be freed with the headers.
      }

   if (m_cs.hVideoIn)
      {
      videoStreamReset (m_cs.hVideoIn);
      vidxFreeHeaders (m_cs.hVideoIn);
      m_cs.paHdr = NULL;
      videoStreamFini (m_cs.hVideoIn);
      }

   //DbgLog((LOG_TRACE,5,TEXT("QUEUE: freeing queue")));
   if (m_pBufferQueue)
       QzTaskMemFree(m_pBufferQueue);
   m_pBufferQueue = NULL;

   if (m_cs.hEvtBufferDone)
      CloseHandle (m_cs.hEvtBufferDone), m_cs.hEvtBufferDone = NULL;

   m_cs.nHeaders = 0;
   return S_OK;
}

// returns S_FALSE if the pin is off (IAMStreamControl)
//
HRESULT
CCapStream::SendFrame (
   LPTHKVIDEOHDR ptvh,
   BOOL          bDiscon,
   BOOL          bPreroll)
{
   DWORDLONG dwlTimeCaptured;

   DbgLog((LOG_TRACE,5,TEXT("CCapStream::SendFrame")));

   HRESULT hr = S_OK;
   CFrameSample * pSample = (CFrameSample *)ptvh->dwUser;

   // this was set up already, but maybe somebody has overwritten it?
   // ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) + m_Alloc.parms.cbPrefix;

   // Even though the capture time is reported in ms, some drivers internally
   // use us and wrap around every 72 minutes!! this is really bad,
   // we need to figure out the non-wrapped time, or we'll think every
   // frame is old and stop capturing!!
   dwlTimeCaptured = ptvh->vh.dwTimeCaptured + m_cs.dwlTimeCapturedOffset;
   // could wrap at 4,294,967ms if buggy driver wraps microsecs internally
   if (dwlTimeCaptured < m_cs.dwlLastTimeCaptured &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured > 4000000 &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured < 4400000) {
	dwlTimeCaptured += 4294967;
	m_cs.dwlTimeCapturedOffset += 4294967;
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
	DbgLog((LOG_TRACE,1,TEXT("******  MICROSECONDS WRAPPED  *******")));
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
   }
   // WILL wrap at 4,294,967,296ms
   if (dwlTimeCaptured < m_cs.dwlLastTimeCaptured &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured > 4000000000 &&
		m_cs.dwlLastTimeCaptured - dwlTimeCaptured < 4400000000) {
	dwlTimeCaptured += 4294967296;
	m_cs.dwlTimeCapturedOffset += 4294967296;
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
	DbgLog((LOG_TRACE,1,TEXT("******  MILLISECONDS WRAPPED  *******")));
	DbgLog((LOG_TRACE,1,TEXT("*************************************")));
   }
   m_cs.dwlLastTimeCaptured = dwlTimeCaptured;

   // what frame number is this (based on the time captured)?  Round such that
   // if frames 1 and 2 are expected at 33 and 66ms, anything from 17 to 49 will
   // considered frame 1.
   //
   // frame = ((ms + 1/2(ms per frame)) * rate) / (1000 * scale);
   //
   // then we add an offset if we so desire
   //
   DWORDLONG dwlTick = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset +
			m_user.usPerFrame / 2000) * m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
   ASSERT (dwlTick < (DWORDLONG)0x100000000);

   // Now what frame number would this be using a different algorithm,
   // considering anything from 33 to 65ms to be frame 1?
   //
   DWORDLONG dwlTickPrime = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset) *
			m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;

   // If we are RUN, and frames 0-10 come through, then we are PAUSEd and RUN
   // again, the first thing coming through may be frame 11 left over from the
   // first RUN, and then they'll start back at 0 again (the driver starts over
   // again).  This confuses our time stamping, becuase we are supposed to send
   // 9 10 11 12 13 not 9 10 11 0 1 2.  We will wait for the first back-in-time
   // we see after being re-run, and add an offset to each frame number to
   // keep stamping the numbers where we left off.
   //
   // We could mess up if we get a wacky back in time thing for another
   // reason!
   if (m_cs.fReRun && m_cs.llLastTick != -1 &&
				dwlTick < (DWORDLONG)m_cs.llLastTick) {
	m_cs.fReRun = FALSE;	// don't do this again
	m_cs.llFrameCountOffset = m_cs.llLastTick + 1;
	m_cs.llLastTick = -1;	// force recalc of new first frame offset
	DbgLog((LOG_TRACE,2,TEXT("Add %d to frame numbers cuz we were re-run"),
						(int)m_cs.llFrameCountOffset));
   }

   // This is the first thing we've captured.  Or, we just noticed above that
   // we've been rerun.
   if (m_cs.llLastTick == -1) {

        // !!! The driver may capture a frame and take forever to tell us,
	// so the current clock time when we notice a frame is captured is
	// NOT correct.  To prevent sync from being off we will assume that
	// this latency is the always the same as the first latency.  We will
	// see how much time elapsed between starting the capture process
	// and us noticing a frame was captured, and subtract the time the
	// driver says it took to capture the first frame (over this short
	// an interval we'll assume the two clocks are in sync)
	// !!! quick cam says 1st frame is captured after 64 frames have been
	// captured, and this inflates the latency and breaks sync.  I better
	// do this test with only 1 buffer outstanding?
	if (m_cs.rtDriverLatency < 0) { // only once please, or that's bad
	    m_cs.rtDriverLatency = m_cs.rtThisFrameTime - m_cs.rtDriverStarted -
				(LONGLONG)dwlTimeCaptured * 10000;
	    if (m_cs.rtDriverLatency < 0)
	        m_cs.rtDriverLatency = 0;	// don't laugh...
	    DbgLog((LOG_TRACE,1,TEXT("Driver latency appears to be %dms"),
				(int)(m_cs.rtDriverLatency / 10000)));
	}

	// !!! Using a FirstFrameOffset was my way of making the first frame
	// we capture always look like frame #0, so we never drop the first
 	// frame.  But that messed up the RUN-PAUSE-RUN case (after re-running
  	// dwlTick would be 20 million) and it also could mess sync up.
	// m_cs.dwFirstFrameOffset = dwlTimeCaptured;
	m_cs.dwFirstFrameOffset = 0;

	// new offset, recalculate
        dwlTick = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset +
			m_user.usPerFrame / 2000) * m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
        dwlTickPrime = ((dwlTimeCaptured - m_cs.dwFirstFrameOffset) *
			m_user.dwTickRate) /
			UInt32x32To64(1000, m_user.dwTickScale) +
			m_cs.llFrameCountOffset;
	m_cs.llLastTick = (LONGLONG)dwlTick - 1; // don't think we've dropped
	DbgLog((LOG_TRACE,2,TEXT("First frame captured %dms after streaming"),
						dwlTimeCaptured));
	if (m_cs.dwFirstFrameOffset > m_user.usPerFrame / 1000)
	    DbgLog((LOG_ERROR,1,TEXT("*** Boy, the first frame arrived late! (%dms)"),
						dwlTimeCaptured));
   }

   if (ptvh->vh.dwBytesUsed)
   {
      // !!! It isn't necessarily a keyframe, I can't tell
      pSample->SetSyncPoint (ptvh->vh.dwFlags & VHDR_KEYFRAME);
      pSample->SetActualDataLength (ptvh->vh.dwBytesUsed);
      // !!! isn't it a discontinuity if we dropped the last frame, too?
      // For us all-key frame guys, it probably doesn't matter
      pSample->SetDiscontinuity(bDiscon);
      pSample->SetPreroll(bPreroll);

      // Here's the thing.  If we are expecting frames at 10, 20, 30, 40 ms,
      // but we see them at 9, 24, 36, 43, we should say "close enough" and
      // capture the four frames.  But we normally round such that frame 3
      // is anything from 25-34ms, so we'll think we got frame 1, 2, 4, 4
      // and drop a frame.  So we also have dwlTickPrime, which is the frame
      // number rounded such that anything from 30-39 is considered frame 3.
      // So if dwlTick thinks 36 belongs as frame 4, but dwlTickPrime thinks
      // it belongs as frame 3, we'll admit it's probably frame three and not
      // needlessly drop a frame.  Using either dwlTick or dwlTickPrime alone
      // would both think a frame was dropped (either 3 or 1)
      if ((LONGLONG)dwlTick == m_cs.llLastTick + 2 &&
				(LONGLONG)dwlTickPrime == m_cs.llLastTick + 1)
	  dwlTick = dwlTickPrime;

      // !!! Do we need a dwlTickPrime2 for when Tick==LastTick and 
      //  !!! TickPrime2 == LastTick+1 ???

      // Use the clock's graph to mark the times for the samples.  The video
      // capture card's clock is going to drift from the graph clock, so you'll
      // think we're dropping frames or sending too many frames if you look at
      // the time stamps, so we have an agreement to mark the MediaTime with the
      // frame number so you can tell if any frames are dropped.
      // Use the time we got in Run() to determine the stream time.  Also add
      // a latency (HACK!) to prevent preview renderers from thinking we're
      // late.
      // If we are RUN, PAUSED, RUN, we won't send stuff smoothly where we
      // left off because of the async nature of pause.
      CRefTime rtSample;
      CRefTime rtEnd;
      if (m_pCap->m_pClock) {
	    // This sample's time stamp is (clock time when captured -
	    // clock time given in Run(rt) + !!! NO LATENCY FOR CAP PIN !!!)
      	    rtSample = m_cs.rtThisFrameTime 
                       - m_pCap->m_tStart
                       - m_cs.rtDriverLatency; // we add the offset in SetTime
                       // + m_user.dwLatency;
      	    rtEnd    = rtSample + m_user.pvi->AvgTimePerFrame;
            DbgLog((LOG_TRACE,4,TEXT("driver stamp %d, stream time is %d"),
				(LONG)dwlTimeCaptured,
				(LONG)rtSample.Millisecs()));
      } else {
	    // no clock, use our driver time stamps
      	    rtSample = TickToRefTime((DWORD)dwlTick);
      	    rtEnd    = rtSample + m_user.pvi->AvgTimePerFrame;
            DbgLog((LOG_ERROR,1,TEXT("No clock! Stream time is %d"),
					(LONG)rtSample.Millisecs()));
      }
      LONGLONG llStart = dwlTick;
      LONGLONG llEnd = dwlTick + 1;
      pSample->SetMediaTime(&llStart, &llEnd);

      // when we're adding offsets to our timestamps we need to do more work...
      // because since stream control will block we can't give it
      // sample times which use the stream offset.
      // Since CheckStreamState takes a sample but only needs the start and
      // end times for it we need to call SetTime on the sample twice, once
      // for stream control (without the offset) and again before we deliver
      // (with the offset).

      pSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);

      // IAMStreamControl stuff.  Has somebody turned us off for now?
      int iStreamState = CheckStreamState(pSample);
      if (iStreamState == STREAM_FLOWING) {
          DbgLog((LOG_TRACE,4,TEXT("*CAP Sending frame %d"), (int)llStart));
	  if (m_cs.fLastSampleDiscarded)
              pSample->SetDiscontinuity(TRUE);
	  m_cs.fLastSampleDiscarded = FALSE;
      } else {
          DbgLog((LOG_TRACE,4,TEXT("*CAPTURE Discarding frame %d"),
								(int)llStart));
	  m_cs.fLastSampleDiscarded = TRUE;
	  hr = S_FALSE;		// discarding
      }
      
      // now reset the time accounting for the stream offset if we've got a clock
      if( 0 < m_rtStreamOffset && m_pCap->m_pClock )
      {  
         REFERENCE_TIME rtOffsetStart = rtSample + m_rtStreamOffset;    
         REFERENCE_TIME rtOffsetEnd   = rtEnd + m_rtStreamOffset;    
         pSample->SetTime( (REFERENCE_TIME *) &rtOffsetStart
                         , (REFERENCE_TIME *) &rtOffsetEnd );
      }                         

      // Oh look.  This time stamp is less than the last time stamp we
      // delivered.  Not allowed!  We won't be delivering it.
      if (rtSample < m_cs.rtLastStamp)
            DbgLog((LOG_TRACE,1,TEXT("Avoiding sending a backwards in time stamp")));

      // This frame # might not be one higher than last frame #.  If not,
      // something funny is up.  If it's stamp is not higher than the last stamp
      // we delivered, it's not going to be delivered anyway, so who cares if
      // something funny is going on.  It shouldn't count as being dropped.
      // Ditto if this stream has been turned off for now
      if (iStreamState == STREAM_FLOWING && rtSample >= m_cs.rtLastStamp &&
				dwlTick != (DWORDLONG)(m_cs.llLastTick + 1)) {
	    if ((LONGLONG)dwlTick > m_cs.llLastTick + 1)
            {
                DbgLog((LOG_ERROR,1,TEXT("*** DROPPED %d frames: Expected %d got %d (%d)"),
				(int)(dwlTick - m_cs.llLastTick - 1),
	  			(DWORD)m_cs.llLastTick + 1, (DWORD)dwlTick,
				dwlTimeCaptured));
                MSR_INTEGER(m_perfWhyDropped, 1);
            }
	    else
            {
                DbgLog((LOG_ERROR,1,TEXT("*** TIME SHIFT: Expected %d got %d (%d)"),
	  			(DWORD)m_cs.llLastTick + 1, (DWORD)dwlTick,
				dwlTimeCaptured));
                MSR_INTEGER(m_perfWhyDropped, 2);
            }
	    DWORDLONG dwl;
	    for (dwl=(DWORDLONG)(m_cs.llLastTick + 1); dwl<dwlTick; dwl++)
	    {
		if (m_capstats.dwlNumDropped < NUM_DROPPED)
		    m_capstats.dwlDropped[m_capstats.dwlNumDropped] = dwl;
		m_capstats.dwlNumDropped++;
	    }
      }

      // Don't deliver it if it's a wierd backwards in time frame or if the
      // time stamp is earlier than the last one delivered or if the stream
      // is off for now
      if (iStreamState == STREAM_FLOWING && rtSample >= m_cs.rtLastStamp &&
			dwlTick > (DWORDLONG)m_cs.llLastTick) {
	  m_capstats.dwlTotalBytes += ptvh->vh.dwBytesUsed;
	  m_capstats.dwlNumCaptured++;
	  // !!! This won't work if we're RUN-PAUSE-RUN, it will only think
	  // we've been running for the time of the second RUN, but it counts
	  // ALL the frames captured in both!
	  // Also, this doesn't account for when the stream is turned off
	  m_capstats.msCaptureTime = dwlTimeCaptured - m_cs.dwFirstFrameOffset;
	  DbgLog((LOG_TRACE,3,TEXT("Stamps(%u): Time(%d,%d) MTime(%d) Drv(%d)"),
			m_pBufferQueue[m_uiQueueTail],
			(LONG)rtSample.Millisecs(), (LONG)rtEnd.Millisecs(),
			(LONG)llStart, dwlTimeCaptured));

          jmkBeforeDeliver(ptvh,dwlTick)
          hr = Deliver (pSample);
          jmkAfterDeliver(ptvh)
	  if (hr == S_FALSE)
		hr = E_FAIL;	// stop delivering anymore, this is serious

	  m_cs.rtLastStamp = rtSample;	// this is the last stamp delivered
      }

      if (rtSample >= m_cs.rtLastStamp &&
			dwlTick > (DWORDLONG)m_cs.llLastTick) {
	  // don't just update this if we're FLOWING, or we'll think we
	  // dropped all the samples during the time we were DISCARDING
	  // rtLastStamp will be equal to rtSample if we delivered it.
          m_cs.llLastTick = dwlTick;
      }

   } else {
      DbgLog((LOG_ERROR,1,TEXT("*** BUFFER (%08lX %ld %lu) returned EMPTY!"),
			pSample, (DWORD)dwlTick, dwlTimeCaptured));
   }

   return hr;
}

HRESULT
CCapStream::ReleaseFrame (
   LPTHKVIDEOHDR ptvh)
{

   HRESULT hr = S_OK;

   // when the preview buffer is released, it doesn't get queued
   // back to the capture driver. other buffers do.
   //
   if (ptvh == &m_cs.tvhPreview)
      return S_OK;

   DDSURFACEDESC SurfaceDesc;
   SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);

   bool fPrimaryLocked = false;

   // lock our ddraw surface so that we take the win16 lock. On Win9x,
   // we may be called with the win16 lock held. Since vidxAddBuffer
   // takes the win16 lock, we can't guarantee m_ReleaseLock and the
   // win16 lock will be taken in the same order on each thread.
   // 
   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS) {
       if(m_pDrawPrimary) {
           fPrimaryLocked = SUCCEEDED(m_pDrawPrimary->Lock(
               0, &SurfaceDesc, DDLOCK_WAIT, (HANDLE) NULL));
       }
       // continue on failure risking incorrect operation.
   } else {
       m_ReleaseLock.Lock();
   }

   // just to be careful, make sure that the correct start
   // pointer is in place
   // Maybe somebody wrecked it, we are not read-only buffers
   ptvh->vh.lpData = (LPBYTE) ALIGNUP(ptvh->p32Buff, m_Alloc.parms.cbAlign) + m_Alloc.parms.cbPrefix;

   DbgLog((LOG_TRACE,4,TEXT("Giving buffer (%d) back to the driver"),
							ptvh->dwIndex));

   if (vidxAddBuffer(m_cs.hVideoIn,
                     &ptvh->vh,
                     m_cs.cbVidHdr)) {
       DbgLog((LOG_ERROR,1,TEXT("******* ADD BUFFER FAILED!")));
       hr = E_FAIL;
   } else {
        //DbgLog((LOG_TRACE,5,TEXT("PUT QUEUE: pos %d gets %d"), m_uiQueueHead, ptvh->dwIndex));
	m_pBufferQueue[m_uiQueueHead] = ptvh->dwIndex;
	if (++m_uiQueueHead >= m_cs.nHeaders)
	    m_uiQueueHead = 0;
   }

   if (++m_cs.uiLastAdded >= m_cs.nHeaders)
	m_cs.uiLastAdded = 0;
   if (m_cs.uiLastAdded != ptvh->dwIndex) {
        DWORD dw = m_cs.uiLastAdded;
        m_cs.uiLastAdded = ptvh->dwIndex;
	// Use dw to keep the above code fairly atomic... DPF will get prempted
        DbgLog((LOG_TRACE,4,TEXT("*** Out of order AddBuffer - %d not %d"),
							ptvh->dwIndex, dw));
   }

   if(g_amPlatform == VER_PLATFORM_WIN32_WINDOWS) {
       if(fPrimaryLocked) {
           m_pDrawPrimary->Unlock(SurfaceDesc.lpSurface);
       }
   } else {
       m_ReleaseLock.Unlock();
   }

   return hr;
}


// Fake a preview stream by sending copies of some of our captured frames
//
HRESULT CCapStream::FakePreview(BOOL fForcePreview)
{
    LPTHKVIDEOHDR ptvhNext;
    static int iii = 0;
    UINT uiT, uiPreviewIndex;
    HRESULT hr = S_OK;
    CFrameSample *pSample;

    // no preview pin, no can do
    if (!m_pCap->m_pPreviewPin)
	return S_OK;

    // If the NEXT frame is not done yet, we have some spare time and can
    // send THIS frame to the preview guy to preview
    // We might be asked to preview no matter what (fForcePreview)
    // !!! Preview every 30th frame in case we never have time?
    // !!! Don't check next done flag, check # of queued buffers?
    // 
    // I am going to be clever and not preview the current frame we're
    // about to deliver out our capture pin, because that might be
    // 10 seconds or more old (we may have lots of buffering).  Rather I
    // will grovel through all the buffers the driver has been given and find
    // the most recent one that is DONE, and use that as our preview frame.
    //

    // we don't want a preview frame
    ptvhNext = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
    if (!fForcePreview && (ptvhNext->vh.dwFlags & VHDR_DONE) && iii++ != 30)
	return S_OK;
		
    // find the most recent DONE frame
    uiPreviewIndex = m_uiQueueTail;
    if (fForcePreview || iii == 31) {
 	while (1) {
	    uiT = uiPreviewIndex + 1;
	    if (uiT == m_cs.nHeaders)
	        uiT = 0;
	    if (uiT == m_uiQueueHead)
		break;
	    if (!(m_cs.paHdr[m_pBufferQueue[uiT]].tvh.vh.dwFlags & VHDR_DONE))
		break;
	    uiPreviewIndex = uiT;
	}
    }

    // DO NOT addref and release this, or it will cause the the sample to
    // be given to the driver again and mess everything up!
    pSample = (CFrameSample *)m_cs.paHdr[m_pBufferQueue[uiPreviewIndex]].
								tvh.dwUser;
    iii = 0;
    DbgLog((LOG_TRACE,4,TEXT("Previewing buffer %d (capturing %d)"),
				m_pBufferQueue[uiPreviewIndex],
				m_pBufferQueue[m_uiQueueTail]));
	m_pCap->m_pPreviewPin->ReceivePreviewFrame(pSample,
    		m_cs.paHdr[m_pBufferQueue[uiPreviewIndex]].tvh.vh.dwBytesUsed);
    return hr;
}


HRESULT CCapStream::Capture()
{
   DbgLog((LOG_TRACE,1,TEXT("CCapStream::Capture")));

   HRESULT hr = E_FAIL;
   DWORD dwOldPrio = GetThreadPriority(GetCurrentThread());
   if (dwOldPrio != THREAD_PRIORITY_HIGHEST)
      SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

   // start streams
   //
   BOOL bDiscon = TRUE;

   // done by main thread on RUN
   // videoStreamStart(m_cs.hVideoIn);

   jmkBegin // begin perf logging

   // stream as long as we're running
   while (m_state == TS_Run && m_cs.nHeaders > 0)
   {
      LPTHKVIDEOHDR ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;

      DbgLog((LOG_TRACE,5,TEXT("Checking for done buffers [%d]"), m_pBufferQueue[m_uiQueueTail]));
      //DbgLog((LOG_TRACE,5,TEXT("GET QUEUE: pos %d says wait for %d"), m_uiQueueTail, m_pBufferQueue[m_uiQueueTail]));

      //for (UINT ii = 0; ii < m_cs.nHeaders; ++ii)
      //   AuxDebugDump (5, m_cs.paHdr+ii, sizeof(m_cs.paHdr[0].tvh));

      if (!(ptvh->vh.dwFlags & VHDR_DONE)) {
	 // STOP will hang until this event times out. So make sure this never
	 // waits across a state transition
	 // !!! PAUSE will still keep waiting until the timeout for slow rates
	 HANDLE hStuff[2] = {m_cs.hEvtBufferDone, m_hEvtRun};
         int i = WaitForMultipleObjects(2, hStuff, FALSE,
						m_user.usPerFrame / 500);

	 if (i == WAIT_TIMEOUT) {
      	     DbgLog((LOG_ERROR,1,TEXT("*** Waiting for buffer %d TIMED OUT!"),
						m_pBufferQueue[m_uiQueueTail]));
      	     //DbgLog((LOG_ERROR,1,TEXT("*** Driver starved or may not be sending callbacks!")));
         } else if (i == WAIT_OBJECT_0 && !(ptvh->vh.dwFlags & VHDR_DONE)) {
      	     DbgLog((LOG_ERROR,1,TEXT("*** GOT %d EVENT BUT NO DONE BIT!"),
						m_pBufferQueue[m_uiQueueTail]));
	 }
      } else {

	 // note the clock time as close as possible to the capturing of this
	 // frame.
	 // !!! The driver could capture it, wait 2 seconds, and then deliver it
	 // and this will really confuse the MUX who will not keep the file in
	 // sync unless it does the right thing.
	 // !!! If Deliver blocks on a frame, the next frame may be marked DONE
	 // but I'll take a long time before this code runs and stamp it wrong!
	 if (m_pCap->m_pClock)
         {     
	     m_pCap->m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtThisFrameTime);
         
             DbgLog((LOG_TRACE,15,TEXT("stream time when frame received %dms"),
		        	(LONG)(m_cs.rtThisFrameTime-m_pCap->m_tStart) ) );
         }
         jmkFrameArrives(ptvh, m_pBufferQueue[m_uiQueueTail])

   	 ptvh->vh.dwFlags &= ~VHDR_DONE;

	 if (m_pBufferQueue[m_uiQueueTail] == m_cs.uiLastAdded) {
   	     DbgLog((LOG_ERROR,1,TEXT("*** Danger Will Robinson! - card is STARVING")));
	 }

   	 CFrameSample * pSample = (CFrameSample *)ptvh->dwUser;
   	 pSample->AddRef();
         hr = SendFrame (ptvh, bDiscon, FALSE);

         bDiscon = FALSE;

	 // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
	 if (FAILED(hr)) {
	     // so the next time we enter this function we're ready to continue
             if (++m_uiQueueTail >= m_cs.nHeaders)
                 m_uiQueueTail = 0;
	     pSample->Release();
	     break;
         }

	 // If we have spare time, we'll send something out our preview pin
	 // If SendFrame returned S_FALSE, we are not capturing, so we will
	 // always preview since we know we can't hurt capture performance

	 FakePreview(hr == S_FALSE ? TRUE : FALSE);

	 // Please don't increment m_uiQueueTail until after the SendFrame
	 // and FakePreview
         if (++m_uiQueueTail >= m_cs.nHeaders)
            m_uiQueueTail = 0;

	 // now we're all done with this sample
	 pSample->Release();
      }
   }

   // the main thread will stop the capture because this thread probably hung
   // in Deliver going from run->pause and will never get to this line!
   // (The video renderer will hold samples in Receive in pause mode)
   // videoStreamStop (m_cs.hVideoIn);

   jmkEnd // stop perf logging

   SetThreadPriority (GetCurrentThread(), dwOldPrio);
   return hr;
}

#if 0
HRESULT
CCapStream::StillFrame()
{
   DbgLog((LOG_TRACE,1,TEXT("CCapStream::StillFrame")));
   MMRESULT mmr;
   HRESULT  hr = S_OK;
   LPTHKVIDEOHDR ptvh = &m_cs.tvhPreview;

   if ( ! ptvh->vh.lpData)
      {
      ZeroMemory (ptvh, sizeof(*ptvh));
      ptvh->vh.dwBufferLength = m_cs.cbBuffer;

      mmr = vidxAllocPreviewBuffer (m_cs.hVideoIn,
                                    (LPVOID *)&ptvh->vh.lpData,
                                    sizeof(ptvh->vh),
                                    m_cs.cbBuffer);
      if (mmr)
         return E_FAIL;

      // SendFrame expects to find a copy of the buffer pointer
      // in ptvh->p32Buff, so we need to put it there.
      //
      ptvh->p32Buff = ptvh->vh.lpData;

      // Is this aligned right?

      m_cs.pSamplePreview = new CFrameSample(&m_Alloc, &hr, &m_cs.tvhPreview);
      m_cs.tvhPreview.dwUser = (DWORD)m_cs.pSamplePreview;
      }

   hr = E_FAIL;
   mmr = vidxFrame (m_cs.hVideoIn, &ptvh->vh);
   if ( ! mmr)
      {
      ptvh->vh.dwTimeCaptured = 0;
      hr = SendFrame (ptvh, TRUE, TRUE);
      }

   return hr;
}
#endif


HRESULT CCapStream::DriverDialog(HWND hwnd, UINT uType, UINT uQuery)
{
    BOOL fMustReconnect = FALSE;
    DbgLog((LOG_TRACE,1,TEXT("CCapStream::DriverDialog")));

    HVIDEO hVideo = NULL;
    switch (uType)
    {
      case VIDEO_IN:
         hVideo = m_cs.hVideoIn;
	 fMustReconnect = (uQuery != VIDEO_DLG_QUERY);
         break;

      case VIDEO_EXTERNALIN:
         hVideo = m_cs.hVideoExtIn;
         break;


      case VIDEO_EXTERNALOUT:
         hVideo = m_cs.hVideoExtOut;
         break;
    }

    if (!hVideo)
        return E_INVALIDARG;

    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Also make sure another dialog isn't already up (I'm paranoid)
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    m_pCap->m_pLock->Lock();
    if (m_pCap->m_State != State_Stopped || m_pCap->m_fDialogUp) {
        m_pCap->m_pLock->Unlock();
	return E_UNEXPECTED;	// even queries should fail
    }
    if (uQuery != VIDEO_DLG_QUERY) {
        m_pCap->m_fDialogUp = TRUE;	// don't allow start streaming
    }
    m_pCap->m_pLock->Unlock();

    MMRESULT mmr = videoDialog(hVideo, hwnd, uQuery);

    if (mmr) {
        m_pCap->m_fDialogUp = FALSE;
        if (uQuery == VIDEO_DLG_QUERY)
            return S_FALSE;
        return E_FAIL;
    }

    if (mmr == 0 && fMustReconnect && uQuery != VIDEO_DLG_QUERY) {

        DbgLog((LOG_TRACE,1,TEXT("Changing output formats")));
        // The dialog changed the driver's internal format.  Get it again.
        GetFormatFromDriver();
        SendFormatToDriver(m_user.pvi);	// unnecessary, but AVICAP32 did it
        if (m_user.pvi->bmiHeader.biBitCount <= 8)
	    InitPalette();

        // Now reconnect us so the graph starts using the new format
        Reconnect(TRUE);
    }

    if (uQuery != VIDEO_DLG_QUERY)
        m_pCap->m_fDialogUp = FALSE;

    return S_OK;
}

HRESULT CCapStream::Reconnect(BOOL fCapturePinToo)
{
      HRESULT hr;

      if (fCapturePinToo && IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our streaming pin")));
         CMediaType cmt;
	 GetMediaType(0, &cmt);
	 hr = GetConnected()->QueryAccept(&cmt);
	 if (hr == S_OK) {
	    m_pCap->m_pGraph->Reconnect(this);
	 } else {
            DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
#if 0
            // This will fail if we switch from 8 bit to 16 bit RGB connected
            // to a renderer that needs a colour converter inserted to do 16 bit
	    // Oh boy.  We're going to have to get clever and insert some
	    // filters between us to help us reconnect
            DbgLog((LOG_TRACE,1,TEXT("Whoa! We *really* need to reconnect!")));
	    IPin *pCon = GetConnected();
	    pCon->AddRef();	// or it will go away in Disconnect
	    m_pCap->m_pGraph->Disconnect(GetConnected());
	    m_pCap->m_pGraph->Disconnect(this);
	    IGraphBuilder *pFG;
	    HRESULT hr = m_pCap->m_pGraph->QueryInterface(IID_IGraphBuilder,
								(void **)&pFG);
	    if (hr == NOERROR) {
	        hr = pFG->Connect(this, pCon);
		pFG->Release();
	    }
	    pCon->Release();
	    if (hr != NOERROR)
                DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr; 	// notify application that graph is broken!
	    // !!! Tell app that graph has changed?
#endif
	 }

	 // We need to FAIL our return code if reconnecting the preview pin 
	 // will fail, even though we are doing it asynchronously.  Here we
	 // predict it will fail, to warn the caller.
         CCapPreview *pPreviewPin = m_pCap->m_pPreviewPin;
         if (pPreviewPin && pPreviewPin->IsConnected()) {
	     hr = pPreviewPin->GetConnected()->QueryAccept(&cmt);
	     if (hr != S_OK) {
         	 DbgLog((LOG_ERROR,1,TEXT("** RECONNECT preview will FAIL!")));
		 return hr;
	     }
	 }

	 // when this pin gets reconnected it will call us again to do the
	 // other two pins
	 return S_OK;
      }

      // Now reconnect the overlay pin
      CCapOverlay *pOverlayPin = m_pCap->m_pOverlayPin;
      if (pOverlayPin && pOverlayPin->IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our overlay pin")));
         CMediaType cmt;
	 pOverlayPin->GetMediaType(0, &cmt);
	 if (S_OK == pOverlayPin->GetConnected()->QueryAccept(&cmt)) {
	    m_pCap->m_pGraph->Reconnect(pOverlayPin);
	 } else {
	    // Huh?
	    ASSERT(FALSE);
	 }
      }

      // Now reconnect the non-overlay preview pin
      CCapPreview *pPreviewPin = m_pCap->m_pPreviewPin;
      if (pPreviewPin && pPreviewPin->IsConnected()) {
         DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our preview pin")));
         CMediaType cmt;
	 pPreviewPin->GetMediaType(0, &cmt);
	 hr = pPreviewPin->GetConnected()->QueryAccept(&cmt);
	 if (hr == S_OK) {
	    m_pCap->m_pGraph->Reconnect(pPreviewPin);
	 } else {
            DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
#if 0
	    // Oh boy.  We're going to have to get clever and insert some
	    // filters between us to help us reconnect
            DbgLog((LOG_TRACE,1,TEXT("Whoa! We *really* need to reconnect!")));
	    IPin *pCon = pPreviewPin->GetConnected();
	    pCon->AddRef();	// or it will go away in Disconnect
	    m_pCap->m_pGraph->Disconnect(pPreviewPin->GetConnected());
	    m_pCap->m_pGraph->Disconnect(pPreviewPin);
	    IGraphBuilder *pFG;
	    HRESULT hr = m_pCap->m_pGraph->QueryInterface(IID_IGraphBuilder,
								(void **)&pFG);
	    if (hr == NOERROR) {
	        hr = pFG->Connect(pPreviewPin, pCon);
		pFG->Release();
	    }
	    pCon->Release();
	    if (hr != NOERROR)
                DbgLog((LOG_ERROR,1,TEXT("*** RECONNECT FAILED! ***")));
	    return hr;
	    // !!! We need to notify application that graph is different
#endif
	 }
      }
      return S_OK;
}

//=============================================================================

// IAMStreamConfig stuff

// Tell the capture card to capture a specific format.  If it isn't connected,
// then it will use that format to connect when it does.  If already connected,
// then it will reconnect with the new format.
//
HRESULT CCapStream::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
	return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(m_pCap->m_pLock);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %x %dbit %dx%d"),
		HEADER(pmt->pbFormat)->biCompression,
		HEADER(pmt->pbFormat)->biBitCount,
		HEADER(pmt->pbFormat)->biWidth,
		HEADER(pmt->pbFormat)->biHeight));

    if (m_pCap->m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    // If this is the same format as we already are using, don't bother
    CMediaType mt;
    GetMediaType(0,&mt);
    if (mt == *pmt) {
	return NOERROR;
    }

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) {
	DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
	return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
	hr = GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR) {
	    DbgLog((LOG_TRACE,2,TEXT("Rejected by capture peer")));
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    // Changing our format will reconnect the preview pin too, so make sure
    // that peer can accept the new format before saying yes.
    if (m_pCap->m_pPreviewPin && m_pCap->m_pPreviewPin->IsConnected()) {
	hr = m_pCap->m_pPreviewPin->GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR) {
	    DbgLog((LOG_TRACE,2,TEXT("Rejected by preview peer")));
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    // OK, we're using it
    hr = SetMediaType((CMediaType *)pmt);

    // Changing the format means reconnecting if necessary
    if (hr == NOERROR)
        Reconnect(TRUE);

    return hr;
}


// What format is the capture card capturing right now?
// The caller must free it with DeleteMediaType(*ppmt)
//
HRESULT CCapStream::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
	return E_POINTER;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
	CoTaskMemFree(*ppmt);
	*ppmt = NULL;
	return hr;
    }
    return NOERROR;
}


//
//
HRESULT CCapStream::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetNumberOfCapabilities")));

    if (piCount == NULL || piSize == NULL)
	return E_POINTER;

    *piCount = 0;
    *piSize = 0;

    return NOERROR;
}


// find out some capabilities of this capture device
//
HRESULT CCapStream::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt,
						LPBYTE pSCC)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // !!! sorry, I have no clue what to say
    return E_NOTIMPL;

#if 0
    // Sorry, no more.
    if (i != 0)
	return S_FALSE;

    GetMediaType(0, (CMediaType *)pmt);

    ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));

    // Maybe the EXTERNALIN's channel caps tell me about the possible
    // output sizes?
#endif

// This is meaningless, but it's how we get channel caps
#if 0
    CHANNEL_CAPS VideoCaps;
    if (m_cs.hVideoIn && videoGetChannelCaps(m_cs.hVideoIn,
                	&VideoCaps, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
	pVSCC->VideoGranularityXPos = VideoCaps.dwDstRectXMod;
	pVSCC->VideoGranularityYPos = VideoCaps.dwDstRectYMod;
	pVSCC->VideoGranularityWidth = VideoCaps.dwDstRectWidthMod;
	pVSCC->VideoGranularityHeight = VideoCaps.dwDstRectHeightMod;
	pVSCC->CroppingGranularityXPos = VideoCaps.dwSrcRectXMod;
	pVSCC->CroppingGranularityYPos = VideoCaps.dwSrcRectYMod;
	pVSCC->CroppingGranularityWidth = VideoCaps.dwSrcRectWidthMod;
	pVSCC->CroppingGranularityHeight = VideoCaps.dwSrcRectHeightMod;
	// We don't allow funky rectangles in our media types
	pVSCC->fCanStretch = FALSE; //VideoCaps.dwFlags & VCAPS_CAN_SCALE;
	pVSCC->fCanShrink = FALSE; //VideoCaps.dwFlags & VCAPS_CAN_SCALE;
        return NOERROR;
    } else {
        DbgLog((LOG_TRACE,2,TEXT("ERROR getting stream caps")));
	return E_FAIL;
    }
#endif

    return NOERROR;
}


//=============================================================================

// IAMVideoCompression stuff

// Get some information about the driver
//
HRESULT CCapStream::GetInfo(LPWSTR pszVersion, int *pcbVersion, LPWSTR pszDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMVideoCompression::GetInfo")));

    // we can't do anything programmatically
    if (pCapabilities)
        *pCapabilities = 0;
    if (pDefaultKeyFrameRate)
        *pDefaultKeyFrameRate = 0;
    if (pDefaultPFramesPerKey)
        *pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
        *pDefaultQuality = 0;

    if (pcbVersion == NULL && pcbDescription == NULL)
	return NOERROR;

    // get the driver version and description
    #define DESCSIZE 80
    DWORD dwRet;
    WCHAR wachVer[DESCSIZE], wachDesc[DESCSIZE];
    wachVer[0] = 0; wachDesc[0] = 0;
    char achVer[DESCSIZE], achDesc[DESCSIZE];

#ifndef UNICODE
    if (g_IsNT)
#endif
    {
	// NT will return unicode strings even though the API says not
        dwRet = videoCapDriverDescAndVer(m_user.uVideoID, (TCHAR *) wachDesc, // !!!
				DESCSIZE, (TCHAR *) wachVer, DESCSIZE);
	DbgLog((LOG_TRACE,2,TEXT("%ls   %ls"), wachDesc, wachVer));
    }
#ifndef UNICODE 
    else 
    {
        dwRet = videoCapDriverDescAndVer(m_user.uVideoID, achDesc,
				DESCSIZE, achVer, DESCSIZE);
	DbgLog((LOG_TRACE,2,TEXT("%s   %s"), achDesc, achVer));
    }
#endif

    if (!dwRet && !g_IsNT) {
	Imbstowcs(wachDesc, achDesc, DESCSIZE);
	Imbstowcs(wachVer, achVer, DESCSIZE);
    }

    if (pszVersion && pcbVersion)
        lstrcpynW(pszVersion, wachVer, min(*pcbVersion / 2, DESCSIZE));
    if (pszDescription && pcbDescription)
        lstrcpynW(pszDescription, wachDesc, min(*pcbDescription / 2, DESCSIZE));

    // return the length in bytes needed (incl. NULL)
    if (pcbVersion)
	*pcbVersion = lstrlenW(wachVer) * 2 + 2;
    if (pcbDescription)
	*pcbDescription = lstrlenW(wachDesc) * 2 + 2;

    return NOERROR;
}


//=============================================================================

/* IAMDroppedFrames stuff */

// How many frames did we drop?
//
HRESULT CCapStream::GetNumDropped(long FAR* plDropped)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetNumDropped - %d dropped"),
			(int)m_capstats.dwlNumDropped));

    if (plDropped == NULL)
	return E_POINTER;

    *plDropped = (long)m_capstats.dwlNumDropped;
    return NOERROR;
}


// How many frames did we not drop?
//
HRESULT CCapStream::GetNumNotDropped(long FAR* plNotDropped)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetNumNotDropped - %d not dropped"),
					(int)m_capstats.dwlNumCaptured));

    if (plNotDropped == NULL)
	return E_POINTER;

    *plNotDropped = (long)(m_capstats.dwlNumCaptured);
    return NOERROR;
}


// Which frames did we drop (give me up to lSize of them - we got lNumCopied)
//
HRESULT CCapStream::GetDroppedInfo(long lSize, long FAR* plArray, long FAR* plNumCopied)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetDroppedInfo")));

    if (lSize <= 0)
	return E_INVALIDARG;
    if (plArray == NULL || plNumCopied == NULL)
	return E_POINTER;

    *plNumCopied = min(lSize, NUM_DROPPED);
    *plNumCopied = (long)min(*plNumCopied, m_capstats.dwlNumDropped);

    LONG l;
    for (l = 0; l < *plNumCopied; l++) {
	plArray[l] = (long)m_capstats.dwlDropped[l];
    }

    return NOERROR;
}


HRESULT CCapStream::GetAverageFrameSize(long FAR* plAverageSize)
{
    DbgLog((LOG_TRACE,3,TEXT("IAMDroppedFrames::GetAvergeFrameSize - %d"),
		m_capstats.dwlNumCaptured ?
		(long)(m_capstats.dwlTotalBytes / m_capstats.dwlNumCaptured) :
		0));

    if (plAverageSize == NULL)
	return E_POINTER;

    *plAverageSize = m_capstats.dwlNumCaptured ?
    		(long)(m_capstats.dwlTotalBytes / m_capstats.dwlNumCaptured) :
		0;

    return NOERROR;
}


///////////////////////////////
// IAMBufferNegotiation methods
///////////////////////////////

HRESULT CCapStream::SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("SuggestAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pCap->m_pLock);

    if (pprop == NULL)
	return E_POINTER;

    // sorry, too late
    if (IsConnected())
	return VFW_E_ALREADY_CONNECTED;

    m_propSuggested = *pprop;

    DbgLog((LOG_TRACE,2,TEXT("cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
		pprop->cBuffers,
                pprop->cbBuffer,
                pprop->cbAlign,
                pprop->cbPrefix));

    return NOERROR;
}


HRESULT CCapStream::GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("GetAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pCap->m_pLock);

    if (!IsConnected())
	return VFW_E_NOT_CONNECTED;

    if (pprop == NULL)
	return E_POINTER;

    *pprop = m_Alloc.parms;

    return NOERROR;
}

// IAMPushSource
HRESULT CCapStream::GetPushSourceFlags( ULONG *pFlags )
{
    *pFlags = 0 ; // we timestamp with graph clock, no special requirements
    return S_OK;
}    

HRESULT CCapStream::SetPushSourceFlags( ULONG Flags )
{
    // we don't support this currently
    return E_FAIL;
}    

HRESULT CCapStream::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}    

HRESULT CCapStream::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtStreamOffset = rtOffset;
    return S_OK;
}

HRESULT CCapStream::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CCapStream::GetMaxStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CCapStream::SetMaxStreamOffset( REFERENCE_TIME  rtOffset )
{
    m_rtMaxStreamOffset = rtOffset; // streaming pin doesn't really care about this at this point
    return S_OK;
}

//
// PIN CATEGORIES - let the world know that we are a CAPTURE pin
//

HRESULT CCapStream::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CCapStream::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
	return E_POINTER;

    if (pcbReturned)
	*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
	return S_OK;

    if (cbPropData < sizeof(GUID))
	return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_CAPTURE;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CCapStream::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
	return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
	return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
	*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.

****************************************************************************/

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <windowsx.h>

#include <mmsystem.h>
#ifdef WIN32
#include <mmddk.h>
#include <stdlib.h>
#endif

#include <vfw.h>
//#include "win32.h"
#if defined (NT_BUILD)
#include "vc50\msviddrv.h"
#else
#include "msviddrv.h"
#endif 
//#include "msvideo.h"
#include <ivideo32.h>
// #include "msvideoi.h"

#if 0
#include <windows.h>
//#include <windowsx.h>
#include <mmsystem.h>
#include "win32.h"
#include "msviddrv.h"
//#include "msvideo.h"
#include "ivideo32.h"
#include "msvideoi.h"
#endif

#ifdef DEBUG
  //extern void FAR CDECL dprintf(LPSTR, ...);
  #define dprintf ; / ## /
#else
  #define dprintf ; / ## /
#endif


#ifndef DVM_STREAM_FREEBUFFER
  #define DVM_STREAM_ALLOCBUFFER    (DVM_START + 312)
  #define DVM_STREAM_FREEBUFFER    (DVM_START + 313)
#endif

#define SZCODE const TCHAR
#define STATICDT static
#define STATICFN static

/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)

#define MapSL(x)	x

#define GetCurrentTask() GetCurrentThread()
#define MAXVIDEODRIVERS 10

#define DebugErr(this, that)

#pragma warning(disable:4002)
#define AuxDebugEx()
#define assert()

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");

#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

SZCODE szDriversDescRegKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");

UINT    wTotalVideoDevs;                  // total video devices
extern HINSTANCE ghInstDll;               // our module handle





// -----------------------------------------------------------
// If the following structure changes, update AVICAP and AVICAP.32 also!!!

typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

#ifndef DEVNODE
typedef	DWORD	   DEVNODE;	// Devnode.
#endif

#ifndef LPHKEY
typedef HKEY FAR * LPHKEY;
#endif

// Registry settings of interest to capture drivers
SZCODE  szRegKey[]          = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo");
SZCODE  szRegActive[]       = TEXT("Active");
SZCODE  szRegDisabled[]     = TEXT("Disabled");
SZCODE  szRegDescription[]  = TEXT("Description");
SZCODE  szRegDevNode[]      = TEXT("DevNode");
SZCODE  szRegDriver[]       = TEXT("Driver");
SZCODE  szRegSoftwareKey[]  = TEXT("SOFTWAREKEY");

LPCAPDRIVERINFO aCapDriverList[MAXVIDEODRIVERS]; // Array of all capture drivers


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegOpenMSVideoKey | This function returns a key
 *      for the msvideo node in the registry.
 *      If the key does not exist it will be created,
 *      and the default entries made.
 *
 * @rdesc Returns Key on success, else NULL.
 ****************************************************************************/
HKEY videoRegOpenMSVideoKey (void)
{
    HKEY hKey = NULL;

    // Get the key if it already exists
    if (RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szRegKey,
                &hKey) != ERROR_SUCCESS) {

        // Otherwise make a new key
        if (RegCreateKey (
                        HKEY_LOCAL_MACHINE,
                        szRegKey,
                        &hKey) == ERROR_SUCCESS) {
            // Add the default entries to the msvideo node?

        }
    }
    return hKey;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegGetDriverByIndex | This function returns information
 *      about a capture driver by index from the registry.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm LPDEVNODE | lpDevnode | Specifies a far pointer to a buffer
 *   used to return an <t DEVNODE> handle.  For non Plug-and-Play devices,
 *   this return value will be NULL.
 *
 * @parm LPBOOL | lpEnabled | Specifies a far pointer to a buffer
 *   used to return a <t BOOL> flag.  If this value is TRUE, the driver is
 *   enabled, if FALSE, the corresponding device is disabled.
 *
 * @rdesc Returns TRUE if successful, or FALSE if a driver was not found
 *  with the <p dwDeviceID> index.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 ****************************************************************************/


BOOL videoRegGetKeyByIndex (
        HKEY            hKeyMSVideoRoot,
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo,
        LPHKEY          phKeyChild)
{
    BOOL fOK = FALSE;
    HKEY hKeyEnum;
    int i;

    *phKeyChild = (HKEY) 0;

    for (i=0; i < MAXVIDEODRIVERS; i++) {	//

        if (RegEnumKey (
                hKeyMSVideoRoot,
                i,
                lpCapDriverInfo-> szKeyEnumName,
                sizeof(lpCapDriverInfo->szKeyEnumName)/sizeof(TCHAR)) != ERROR_SUCCESS)
            break;

        // Found a subkey, does it match the requested index?
        if (i == (int) dwDeviceID) {

            if (RegOpenKey (
                        hKeyMSVideoRoot,
                        lpCapDriverInfo-> szKeyEnumName,
                        &hKeyEnum) == ERROR_SUCCESS) {

                *phKeyChild = hKeyEnum;  // Found it!!!
                fOK = TRUE;

            }
            break;
        }
    } // endof all driver indices
    return fOK;
}

// Fetches driver info listed in the registry.
// Returns: TRUE if the index was valid, FALSE if no driver at that index
// Note: Registry entry ordering is random.

BOOL videoRegGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    DWORD dwType;
    DWORD dwSize;
    BOOL fOK;
    HKEY hKeyChild;
    HKEY hKeyMSVideoRoot;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    if (!(hKeyMSVideoRoot = videoRegOpenMSVideoKey()))
        return FALSE;

    if (fOK = videoRegGetKeyByIndex (
                hKeyMSVideoRoot,
                dwDeviceID,
                lpCapDriverInfo,
                &hKeyChild)) {

        // Fetch the values:
        //      Active
        //      Disabled
        //      Description
        //      DEVNODE
        //      Driver
        //      SOFTWAREKEY

        dwSize = sizeof(BOOL);          // Active
        RegQueryValueEx(
                   hKeyChild,
                   szRegActive,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fActive,
                   &dwSize);

        dwSize = sizeof(BOOL);          // Enabled
        RegQueryValueEx(
                   hKeyChild,
                   szRegDisabled,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fDisabled,
                   &dwSize);
        // Convert this thing to a bool
        lpCapDriverInfo->fDisabled = (lpCapDriverInfo->fDisabled == '1');

        // DriverDescription
        dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDescription,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

        // DEVNODE
        dwSize = sizeof(DEVNODE);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDevNode,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->dnDevNode,
                   &dwSize);

        // DriverName
        dwSize = sizeof (lpCapDriverInfo->szDriverName) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDriver,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverName,
                   &dwSize);

        // SoftwareKey
        dwSize = sizeof (lpCapDriverInfo->szSoftwareKey) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegSoftwareKey,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szSoftwareKey,
                   &dwSize);

        RegCloseKey (hKeyChild);

    } // if the subkey could be opened

    RegCloseKey (hKeyMSVideoRoot);

    return fOK;
}

// Fetches driver info listed in system.ini
// Returns: TRUE if the index was valid, FALSE if no driver at that index

BOOL videoIniGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    int w = (int) dwDeviceID;
    BOOL fOK = FALSE;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    lstrcpy(szKey, szVideo);	//
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }

    // Only get its driver name
    if (GetPrivateProfileString(szDrivers, szKey, szNull,	//
                lpCapDriverInfo->szDriverName,
                sizeof(lpCapDriverInfo->szDriverName)/sizeof(TCHAR),
                szSystemIni)) {

        HKEY hKey = NULL;
        DWORD dwSize, dwType;

        // Get the key if it already exists

        // Get Drivers.Desc from its Drivers32 driver name
        if (ERROR_SUCCESS == RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szDriversDescRegKey,
                &hKey) != ERROR_SUCCESS) {
            // DriverDescription
            dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
            // [drivers.desc]
            //   DriverName = DriverDescription
            dwType = REG_SZ;
            RegQueryValueEx(
                   hKey,
                   lpCapDriverInfo->szDriverName,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

            RegCloseKey (hKey);
        }  else {
            dprintf("videoIniGetDriverByIndex: RegOpenKey of Drivers.Desc failed !!\n");
        }





        // Found an entry at the requested index
        // The description and version info will be inserted as
        // requested by the client app.

        lpCapDriverInfo-> fOnlySystemIni = TRUE;

        fOK = TRUE;
    }

    return fOK;
}

DWORD videoFreeDriverList (void)

{
    int i;

    // Free the driver list
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    wTotalVideoDevs = 0;

    return DV_ERR_OK;
}

// This function may be called a number of times to create the
// current driver array.  Since Capscrn assumes it can throw a
// driver into system.ini on the fly and have it immediately accessible,
// this routine is called on videoGetNumDevs() and when AVICapx.dll
// tries to get the driver description and version.
//
// Drivers in the registry will be the first entries in the list.
//
// If a driver is listed in the registry AND in system.ini AND
// the full path to the drivers match, the system.ini entry will NOT
// be in the resulting list.

// The variable wTotalVideoDevs is set as a byproduct of this function.

// Returns DV_ERR_OK on success, even if no drivers are installed.
//
DWORD videoCreateDriverList (void)

{
    int i, j, k;


    // Delete the existing list
    videoFreeDriverList ();

    // Allocate an array of pointers to all possible capture drivers
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        aCapDriverList[i] = (LPCAPDRIVERINFO) GlobalAllocPtr (
                GMEM_MOVEABLE |
                GMEM_SHARE |
                GMEM_ZEROINIT,
                sizeof (CAPDRIVERINFO));
        if (aCapDriverList[i] == NULL) {
            videoFreeDriverList ();
            return DV_ERR_NOMEM;
        }
    }

    // Walk the list of Registry drivers and get each entry
    // Get VFW drivers from MediaResource\MsVideo
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (videoRegGetDriverByIndex (
                    (DWORD) i, aCapDriverList[wTotalVideoDevs])) {

            dprintf("MediaResource: idx %d, DriverName %x, Desc %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName, aCapDriverList[wTotalVideoDevs]->szDriverDescription);

            wTotalVideoDevs++;	//
        }
        else
            break;
    }

    if (wTotalVideoDevs == MAXVIDEODRIVERS)
        goto AllDone;

    // Now add the entries listed in system.ini, [Drivers#2] section, (msvideo[0-9] = driver.drv)
    // to the driver array, ONLY if the entry doesn't exactly match
    // an existing registry entry.

    for (j = 0; j < MAXVIDEODRIVERS; j++) {
        // Get driver name such as *.dll
        if (videoIniGetDriverByIndex ((DWORD) j,
                        aCapDriverList[wTotalVideoDevs])) {

            // Found an entry, now see if it is a duplicate of an existing
            // registry entry

            for (k = 0; k < (int) wTotalVideoDevs; k++) {

                if (lstrcmpi (aCapDriverList[k]->szDriverName,
                    aCapDriverList[wTotalVideoDevs]->szDriverName) == 0) {

                    // Found an exact match, so skip it!
                    goto SkipThisEntry;
                }
            }

            if (wTotalVideoDevs >= MAXVIDEODRIVERS - 1)
                break;

            dprintf("Drivers32: idx %d, DriverName %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName);

            wTotalVideoDevs++;

SkipThisEntry:
            ;
        } // If sytem.ini entry was found
    } // For all system.ini possibilities

AllDone:


    // Decrement wTotalVideoDevs for any entries which are marked as disabled
    // And remove disabled entries from the list
    for (i = 0; i < MAXVIDEODRIVERS; ) {

        if (aCapDriverList[i] && aCapDriverList[i]->fDisabled) {

            GlobalFreePtr (aCapDriverList[i]);

            // Shift down the remaining drivers
            for (j = i; j < MAXVIDEODRIVERS - 1; j++) {
                aCapDriverList[j] = aCapDriverList[j + 1];
            }
            aCapDriverList[MAXVIDEODRIVERS - 1] = NULL;

            wTotalVideoDevs--;
        }
        else
            i++;
    }

    // Free the unused pointers
    for (i = wTotalVideoDevs; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    // Put PnP drivers first in the list
    // These are the only entries that have a DevNode
    for (k = i = 0; i < (int) wTotalVideoDevs; i++) {
        if (aCapDriverList[i]-> dnDevNode) {
            LPCAPDRIVERINFO lpCDTemp;

            if (k != i) {
                // Swap the entries
                lpCDTemp = aCapDriverList[k];
                aCapDriverList[k] = aCapDriverList[i];
                aCapDriverList[i] = lpCDTemp;
            }
            k++;   // Index of first non-PnP driver
        }
    }

    dprintf("videoCreateDriverList: DeviceList contains %d Video Device(s).\n", wTotalVideoDevs);

    return DV_ERR_OK;
}





// ----------------------------------------------------------------------
//
// To clean up when a WOW app exits, we need to maintain a list of
// open devices. A list of HANDLEINFO structs is hung off g_pHandles.
// An item is added to the head of this list in videoOpen, and removed
// in videoClose. When a WOW app exits, winmm will call our WOWAppExit
// function: for each entry in the list that is owned by the exiting thread,
// we call videoClose to close the device and remove the handle entry.
//

#define THKHVIDEO_STAMP  MAKEFOURCC('t','V','H','x')
typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
typedef struct _thk_hvideo {
    struct _thk_hvideo * pNext;
    DWORD          Stamp;
    UINT           nHeaders;
    UINT           cbAllocHdr;
    UINT           cbVidHdr;
    UINT           spare;
    LPVOID         paHdrs;
    PTR32          p32aHdrs;
    LPVOID         pVSyncMem;
    DWORD          p32VSyncMem;
    DWORD          pid;

    HVIDEO         hVideo;
    HVIDEO         hFill;

    DWORD_PTR          dwCallback;
    DWORD_PTR          dwUser;

    LPTHKVIDEOHDR  pPreviewHdr;

    } THKHVIDEO;


// one of these per open handle
typedef struct _HANDLEINFO {
    HVIDEO hv;
    HANDLE hThread;
    THKHVIDEO tv;
    struct _HANDLEINFO * pNext;
} HANDLEINFO, * PHANDLEINFO;

// head of global list of open handles
PHANDLEINFO g_pHandles;

// critical section that protects global list
CRITICAL_SECTION csHandles;

// init list and critsec
void
NTvideoInitHandleList()
{
    g_pHandles = NULL;
    InitializeCriticalSection(&csHandles);
}

// finished with critsec list
void
NTvideoDeleteHandleList()
{
    // don't need critical section as no-one else can be using
    // it now (we are about to delete the critsec)

    // empty everything out of the list
    while (g_pHandles) {
        videoClose(g_pHandles->hv);
    }

    DeleteCriticalSection(&csHandles);
}



// add a handle to the list
void
NTvideoAddHandle(HVIDEO hv)
{
    PHANDLEINFO pinfo = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLEINFO));

    if (!pinfo) {
        // couldn't allocate the memory - best thing to do is
        // forget it - nothing bad will happen except that we
        // might possibly fail to clean up if this is a wow app and
        // it exits without closing the capture device.
        return;
    }

    pinfo->hv = hv;
    pinfo->hThread = GetCurrentTask();
    ZeroMemory(&pinfo->tv, sizeof(THKHVIDEO));
    pinfo->tv.Stamp = THKHVIDEO_STAMP;

    EnterCriticalSection(&csHandles);

    pinfo->pNext = g_pHandles;
    g_pHandles = pinfo;

    LeaveCriticalSection(&csHandles);
}

// delete an entry from the handle list given the HVIDEO.
// caller must close the HVIDEO
// should be called before closing (in case the HVIDEO is reassigned after
// closing and before removing from the list
void
NTvideoDelete(HVIDEO hv)
{
    PHANDLEINFO * ppNext;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ppNext = &g_pHandles;
    while (*ppNext) {
        if ((*ppNext)->hv == hv) {
            pinfo = *ppNext;
            *ppNext = pinfo->pNext;
            HeapFree(GetProcessHeap(), 0, pinfo);
            break;

        } else {
            ppNext = &(*ppNext)->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}

// close any handles open by this task
void
AppCleanup(HANDLE hTask)
{
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    pinfo = g_pHandles;
    while (pinfo) {

        if (pinfo->hThread == hTask) {

            // get the next pointer before videoClose deletes the entry
            HVIDEO hv = pinfo->hv;
            pinfo = pinfo->pNext;

            videoClose(hv);
        } else {
            pinfo = pinfo->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}


// ----------------------------------------------------------------------




/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
LRESULT WINAPI NTvideoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI NTvideoGetNumDevs(void)
{
    DWORD dwNumDevs = 0;

    if(DV_ERR_OK == videoCreateDriverList ()) {
       dwNumDevs = wTotalVideoDevs;  // Save it before reseting to 0 in videoFreeDriverList.
       videoFreeDriverList ();    
    }
                                                                       
    return dwNumDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/
#ifdef UNICODE  // Translate UNICODE response to ansi
DWORD WINAPI NTvideoGetErrorTextA(HVIDEO hVideo, UINT wError,
			LPSTR lpText, UINT wSize)
{
    return DV_ERR_NOTSUPPORTED;

#if 0
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        DWORD dwResult;
        LPWSTR lpwstr = LocalAlloc(LPTR, wSize*sizeof(WCHAR));
        if (NULL == lpwstr) {
            return(DV_ERR_NOMEM);
        }
        vet.dwError = (DWORD) wError;
        vet.lpText = lpwstr;
        vet.dwLength = (DWORD) wSize;
        dwResult = (DWORD)NTvideoMessage (hVideo, DVM_GETERRORTEXT, (LPARAM) (LPVOID) &vet,
                        NULL);
        if (DV_ERR_OK == dwResult) {
            Iwcstombs(lpText, lpwstr, wSize);
        }
        LocalFree(lpwstr);
        return(dwResult);
    }
    else
        return DV_ERR_BADERRNUM;
#endif
}
#endif //UNICODE

//
// The unicode/Win16 equivalent of the above
//

DWORD WINAPI NTvideoGetErrorTextW(HVIDEO hVideo, UINT wError,
			LPWSTR lpText, UINT wSize)
{
    return DV_ERR_NOTSUPPORTED;

#if 0
    VIDEO_GETERRORTEXT_PARMS vet;
    lpText[0] = 0;

    if (((wError > DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringW(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = (DWORD) wSize;
        return (DWORD)NTvideoMessage (hVideo, DVM_GETERRORTEXT, (LPARAM) (LPVOID) &vet,
                        NULL);
    }
    else
        return DV_ERR_BADERRNUM;
#endif
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI NTvideoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return (DWORD)NTvideoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (LPARAM)lpChannelCaps,
		dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI NTvideoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_UPDATE, (LPARAM)hWnd, (LPARAM)hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI NTvideoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    TCHAR szKey[MAX_PATH];  
    TCHAR szbuf[MAX_PATH];
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;
    DWORD dwErr;
    DWORD dwNumDevs = 0;

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    w = (UINT)dwDeviceID;
    *lphVideo = NULL;

    dwNumDevs = NTvideoGetNumDevs();

    // No drivers installed
    if (dwNumDevs == 0) 
        return DV_ERR_BADINSTALL;

    if (w >= MAXVIDEODRIVERS)
        return DV_ERR_BADDEVICEID;

    dwErr = videoCreateDriverList ();
    if(DV_ERR_OK != dwErr)
        return dwErr;
    
    if(w < dwNumDevs) {
       lstrcpyn(szKey, aCapDriverList[w]->szDriverName, MAX_PATH);
       lstrcpyn(szbuf, aCapDriverList[w]->szDriverName, MAX_PATH);
       videoFreeDriverList ();

       dprintf("szKey %x, szDrivers %x, szbuf %x\n", szKey, szDrivers, szbuf);

#ifdef THIS_IS_ANCIENT_CODE
        // Removed for VFW1.1
        // Only early Alpha 1.0 drivers required this...

        // Check driver version number by doing a configuration open...
        // Version 1 used LPARAM = dwFlags
        // Version 2 uses LPARAM = LPVIDEO_OPEN_PARMS

        if (hVideoTemp = OpenDriver(szKey, szDrivers, (LPARAM) NULL)) {
            HVIDEO hVideoTemp;

            // Version 1 drivers had the added bug of returning
            // the version from this message, instead of in
            // lParam1
            if (NTvideoMessage (hVideoTemp, DVM_GETVIDEOAPIVER,
                        (LPARAM) (LPVOID) &dwVersion, 0L) == 1)
                dwVersion = 1;
            CloseDriver(hVideoTemp, 0L, 0L );
        }

        if (dwVersion == 1)
            *lphVideo = OpenDriver(szKey, szDrivers, dwFlags);
        else
#endif // THIS_IS_ANCIENT_CODE

        *lphVideo = (HVIDEO)OpenDriver(szKey, szDrivers, (LPARAM) (LPVOID) &vop);

	    if( ! *lphVideo ) {
            if (vop.dwError)    // if driver returned an error code...
                return vop.dwError;
            else {
#ifdef WIN32
		        if (GetFileAttributes(szbuf) == (DWORD) -1)
#else
                OFSTRUCT of;

                if (OpenFile (szbuf, &of, OF_EXIST) == HFILE_ERROR)
#endif
                    return (DV_ERR_BADINSTALL);
                else
                    return (DV_ERR_NOTDETECTED);
            }
	    }
    } else {
        videoFreeDriverList ();
        return( DV_ERR_BADINSTALL );
    }

    NTvideoAddHandle(*lphVideo);

    return DV_ERR_OK;

}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI NTvideoClose (HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    NTvideoDelete(hVideo);

    return (CloseDriver((HDRVR)hVideo, 0L, 0L ) ? DV_ERR_OK : DV_ERR_NONSPECIFIC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *	
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI NTvideoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (*lpdwReturn)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return (DWORD)NTvideoMessage(hVideo, msg, dwFlags,
	    (LPARAM)(LPVIDEOCONFIGPARMS)&vcp );
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigureStorage | This function saves or loads
 *	     all configurable options for a channel.  Options
 *      can be saved and recalled for each application or each application
 *      instance.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPSTR | lpstrIdent  | Identifies the application or instance.
 *      Use an arbitrary string which uniquely identifies your application
 *      or instance.
 *
 * @parm DWORD | dwFlags | Specifies any flags for the function. The following
 *   flags are defined:
 *   @flag VIDEO_CONFIGURE_GET | Requests that the values be loaded.
 *   @flag VIDEO_CONFIGURE_SET | Requests that the values be saved.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm The method used by a driver to save configuration options is
 *      device dependent.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
#ifdef UNICODE
DWORD WINAPI NTvideoConfigureStorageA(HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags)
{
    DWORD ret;
    LPWSTR lpwstr;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;


    // Convert the input string to Unicode
    // Call the driver, free the Unicode string and return the result
    ret = strlen(lpstrIdent);
    lpwstr = LocalAlloc(LPTR, ret*sizeof(WCHAR));
    if (!lpwstr) {
        return(DV_ERR_NOMEM);
    }

    Imbstowcs(lpwstr, lpstrIdent, ret);

    ret = (DWORD)NTvideoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (LPARAM)lpwstr, dwFlags);

    LocalFree(lpwstr);
    return(ret);
}

#endif

// On NT the header file will have ensured that videoConfigureStorage is
// defined by a macro to videoConfigureStorageW
DWORD WINAPI NTvideoConfigureStorage(HVIDEO hVideo,
			LPWSTR lpstrIdent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (LPARAM)lpstrIdent, dwFlags);
}




/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *	     returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI NTvideoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_DIALOG, (LPARAM)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *	header and data
 *	by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI NTvideoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI NTvideoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAllocHdrAndBuffer | This function is used to allow
 *      drivers to optionally allocate video buffers.  Normally, the client
 *      application is responsible for allocating buffer memory, but devices
 *      which have on-board memory may optionally allocate headers and buffers
 *      using this function. Generally, this will avoid an additional data copy,
 *      resulting in faster capture rates.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR FAR * | plpvideoHdr | Specifies a pointer to the address of a
 *   <t VIDEOHDR> structure.  The driver saves the buffer address in this
 *   location, or NULL if it cannot allocate a buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure
 *      and associated video buffer in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 *   The buffer allocated must be accessible for DMA by the host.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamAllocHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR FAR * plpvideoHdr, DWORD dwSize)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
        return DV_ERR_PARAM1;

    *plpvideoHdr = NULL;        // Init to NULL ptr

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCHDRANDBUFFER,
            (LPARAM)plpvideoHdr, dwSize);

    if (*plpvideoHdr == NULL ||
                IsBadHugeWritePtr (*plpvideoHdr, dwSize)) {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: Allocation failed.");
        *plpvideoHdr = NULL;
        return wRet;
    }

    if (IsVideoHeaderPrepared(HVIDEO, *plpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: header is already prepared.");
        return DV_ERR_OK;
    }

    (*plpvideoHdr)->dwFlags = 0;

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, *plpvideoHdr);

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFreeHdrAndBuffer | This function is used to free
 *      buffers allocated by the driver using the <f videoStreamAllocHdrAndBuffer>
 *      function.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to the
 *   <t VIDEOHDR> structure and associated buffer to be freed.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/

DWORD WINAPI NTvideoStreamFreeHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamFreeHdrAndBuffer: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: header is not prepared.");
    }

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_FREEHDRANDBUFFER,
            (LPARAM)lpvideoHdr, 0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: Error freeing buffer.");
    }

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}

DWORD WINAPI NTvideoStreamAllocBuffer(HVIDEO hVideo,
		LPVOID FAR * plBuffer, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

// as this code is internal to our dll we do not need to check access rights
//    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
//        return DV_ERR_PARAM1;

    *plBuffer = NULL;        // Init to NULL ptr

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCBUFFER,
            (LPARAM)plBuffer, dwSize);

    if (*plBuffer == NULL) {
        DebugErr(DBF_WARNING,"videoStreamAllocBuffer: Allocation failed.");
	dprintf("videoStreamAllocBuffer: Allocation failed, wRet=0x%d",wRet);
        *plBuffer = NULL;
        return wRet;
    }
    return wRet;
}

DWORD WINAPI NTvideoStreamFreeBuffer(HVIDEO hVideo,
		LPVOID lpBuffer)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_FREEBUFFER,
            (LPARAM)lpBuffer, 0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeBuffer: Error freeing buffer.");
	dprintf("videoStreamFreeBuffer: error %d freeing buffer", wRet);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamPrepareHeader(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (LPARAM)lpvideoHdr, dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = NTvideoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (LPARAM)lpvideoHdr, dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = NTvideoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (LPARAM)lpvideoHdr, dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *	     on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI NTvideoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetPosition | This function retrieves the current
 *   position of the specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t MMTIME> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 * @comm Before using <f videoStreamGetPosition>, set the
 *   <e MMTIME.wType> member of the <t MMTIME> structure to indicate
 *   the time format desired. After
 *   <f videoStreamGetPosition> returns, check the <e MMTIME.wType>
 *   member to  determine if the your time format is supported. If
 *   not, <e MMTIME.wType> specifies an alternate format.
 *   Video capture drivers typically provide the millisecond time
 *   format.
 *
 *   The position is set to zero when streaming is started with
 *   <f videoStreamStart>.
 ****************************************************************************/
DWORD WINAPI NTvideoStreamGetPosition(HVIDEO hVideo, LPMMTIME lpInfo, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpInfo, sizeof (MMTIME)) )
        return DV_ERR_PARAM1;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_GETPOSITION,
            (LPARAM)lpInfo, dwSize);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD_PTR | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD_PTR | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) )
            return DV_ERR_PARAM2;
        if (!dwCallbackInst)
            return DV_ERR_PARAM2;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND)(dwCallback)) )
            return DV_ERR_PARAM2;
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = hVideo;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_INIT,
                (LPARAM) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                sizeof (VIDEO_STREAM_INIT_PARMS));
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI NTvideoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetError | This function returns the error
 *   most recently encountered.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPDWORD | lpdwErrorID | Specifies a far pointer to the <t DWORD>
 *      used to return the error ID.
 *
 * @parm LPDWORD | lpdwErrorValue | Specifies a far pointer to the <t DWORD>
 *      used to return the number of frames skipped.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm While streaming video data, a capture
 *      driver can fill buffers faster than the client application can
 *      save the buffers to disk.  In this case, the
 *      DV_ERR_NO_BUFFERS error is returned in <p lpdwErrorID>
 *      and <p lpdwErrorValue> contains a count of the number of
 *      frames missed.  After
 *      receiving this message and returning the error status, a driver
 *      should reset its internal error flag to DV_ERR_OK and
 *      the count of missed frames to zero.
 *
 *      Applications should send this message frequently during capture
 *      since some drivers which do not have access to interrupts use
 *      this message to trigger buffer processing.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI NTvideoStreamGetError(HVIDEO hVideo, LPDWORD lpdwError,
        LPDWORD lpdwFramesSkipped)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpdwError, sizeof (DWORD)) )
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpdwFramesSkipped, sizeof (DWORD)) )
        return DV_ERR_PARAM2;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_GETERROR, (LPARAM) lpdwError,
        (LPARAM) lpdwFramesSkipped);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI NTvideoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return (DWORD)NTvideoMessage(hVideo, DVM_FRAME, (LPARAM) lpVHdr,
                        sizeof(VIDEOHDR));
}


// NEW STUFF //





typedef struct tagVS_VERSION
{
      WORD wTotLen;
      WORD wValLen;
      TCHAR szSig[16];
      VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoCapDriverDescAndVer | This function gets strings
 *   for the description and version of a video capture driver
 *
 * @parm DWORD | dwDeviceID | Specifies the index of which video driver to get
 *      information about.
 *
 * @parm LPTSTR | lpszDesc | Specifies a place to return the description
 *
 * @parm UINT | cbDesc | Specifies the length of the description string
 *
 * @parm LPTSTR | lpszVer | Specifies a place to return the version
 *
 * @parm UINT | cbVer | Specifies the length of the version string
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number.
 *
 * @comm Use this function to get strings describing the driver and its version
 *
/****************************************************************************/
DWORD WINAPI NTvideoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc, UINT cbDesc, LPTSTR lpszVer, UINT cbVer)
{
    LPTSTR  lpVersion;
    UINT    wVersionLen;
    BOOL    bRetCode;
    TCHAR   szGetName[MAX_PATH];
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetName;
    BOOL    fGetVersion;

    const static TCHAR szNull[]        = TEXT("");
    const static TCHAR szVideo[]       = TEXT("msvideo");
    const static TCHAR szSystemIni[]   = TEXT("system.ini");
    const static TCHAR szDrivers[]     = TEXT("Drivers32");
          static TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];

    fGetName = lpszDesc != NULL && cbDesc != 0;
    fGetVersion = lpszVer != NULL && cbVer != 0;

    if (fGetName)
        lpszDesc[0] = TEXT('\0');
    if (fGetVersion)
        lpszVer [0] = TEXT('\0');

    lstrcpy(szKey, szVideo);
    szKey[sizeof(szVideo)/sizeof(TCHAR) - 1] = TEXT('\0');
    if( dwDeviceID > 0 ) {
        szKey[sizeof(szVideo)/sizeof(TCHAR)] = TEXT('\0');
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR)(TEXT('1') + (dwDeviceID-1) );  // driver ordinal
    }

    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szBuf, sizeof(szBuf)/sizeof(TCHAR), szSystemIni) < 2)
        return DV_ERR_BADDEVICEID;

    // Copy in the driver name initially, just in case the driver
    // has omitted a description field.
    if (fGetName)
        lstrcpyn(lpszDesc, szBuf, cbDesc);

    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;             // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        lpstrVffInfo  = GlobalLock(hMem);

        // Get the File Version first
        if (GetFileVersionInfo(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
             VS_VERSION FAR *pVerInfo = (VS_VERSION FAR *) lpstrVffInfo;

             // fill in the file version
             wsprintf(szBuf,
                      TEXT("Version:  %d.%d.%d.%d"),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionLS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionLS));
             if (fGetVersion)
                lstrcpyn (lpszVer, szBuf, cbVer);
        }

        // Now try to get the FileDescription
        // First try this for the "Translation" entry, and then
        // try the American english translation.
        // Keep track of the string length for easy updating.
        // 040904E4 represents the language ID and the four
        // least significant digits represent the codepage for
        // which the data is formatted.  The language ID is
        // composed of two parts: the low ten bits represent
        // the major language and the high six bits represent
        // the sub language.

        lstrcpy(szGetName, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));

        wVersionLen   = 0;
        lpVersion     = NULL;

        // Look for the corresponding string.
        bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                        (LPTSTR)szGetName,
                        (void FAR* FAR*)&lpVersion,
                        (UINT FAR *) &wVersionLen);

        if (fGetName && bRetCode && wVersionLen && lpVersion)
           lstrcpyn (lpszDesc, lpVersion, cbDesc);

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    return DV_ERR_OK;
}



/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
}

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}




DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr) {
   LPVIDEOHDR lpVHdr) {
    return NTvideoFrame(hVideo, (LPVIDEOHDR) lpVHdr);
}

DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData) {

    NTvideoStreamPrepareHeader(hVideo, lpVHdr, cbData);
    return NTvideoStreamAddBuffer(hVideo, lpVHdr, cbData);
}

DWORD WINAPI NTvideoSetRect(HVIDEO h, DWORD msg, RECT rc)
{
    return (DWORD)NTvideoMessage (h, msg, (LPARAM)(LPVOID)&rc, VIDEO_CONFIGURE_SET);
}

DWORD WINAPI NTvidxSetRect(
    HVIDEOX     hVideo,
    UINT        uMsg,
    int         left,
    int         top,
    int         right,
    int         bottom)
{
    RECT rc = {left, top, right, bottom};
    return NTvideoSetRect(hVideo, uMsg, rc);
}

#define USE_HW_BUFFERS 1
// #define USE_CONTIG_ALLOC	// can we do this in 32-bit land?


#define THKHDR(ii) ((LPTHKVIDEOHDR)((LPBYTE)ptv->paHdrs + (ii * ptv->cbAllocHdr)))

static struct _thk_local {
    THKHVIDEO *    pMruHandle;
    THKHVIDEO *    pFreeHandle;
    int            nPoolSize;
    int            nAllocCount;
    } tl;

#define V_HVIDEO(ptv) if (!ptv || ptv->Stamp != THKHVIDEO_STAMP) { \
             AuxDebugEx (-1, DEBUGLINE "V_HVIDEO failed hVideo=%08lx\r\n", ptv); \
             return MMSYSERR_INVALHANDLE; \
        }
#define V_HEADER(ptv,p32Hdr,ptvh) if (!(ptvh = NTvidxLookupHeader(ptv,p32Hdr))) { \
            AuxDebugEx(-1, DEBUGLINE "V_HEADER(%08lX,%08lX) failed!", ptv, p32Hdr); \
            return MMSYSERR_INVALPARAM; \
        }

//
LPTHKHVIDEO DATAFROMHANDLE(HVIDEOX hv)
{
    THKHVIDEO *ptv;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ptv = NULL;
    pinfo = g_pHandles;
    while (pinfo) {
        if ((pinfo)->hv == hv) {
            ptv = &(pinfo)->tv;
        }
        pinfo = pinfo->pNext;
    }

    LeaveCriticalSection(&csHandles);

    return ptv;
}


DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        ii,
   PTR32 FAR * pp32Hdr,
   DWORD       cbData)
{

    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;
   #ifdef USE_CONTIG_ALLOC
    CPA_DATA cpad;
   #endif

    AuxDebugEx (3, DEBUGLINE "vidxAllocBuffer(%08lx,%d,%08lx,%08lx)\r\n",
                ptv, ii, p32Hdr, cbData);

    *pp32Hdr = 0;

    V_HVIDEO(ptv);
    if (ii >= ptv->nHeaders || ptv->paHdrs == NULL)
        return MMSYSERR_NOMEM;

    ptvh = THKHDR(ii);

  #ifdef USE_HW_BUFFERS
    // try to allocate a buffer on hardware
    //
    if (NTvideoMessage (ptv->hVideo, DVM_STREAM_ALLOCBUFFER,
                (LPARAM) (LPVOID)&ptvh->dwTile, cbData)
        == DV_ERR_OK)
    {
        // if we got hw buffers, dwMemHandle == 0 && dwTile != 0
        // we will depend on this to know who to free the memory to
        // (for phys mem both will be non zero, while for GlobalMem
        // both will be zero)
        //
        ptvh->dwMemHandle = 0;
        ptvh->p16Alloc = (PTR16)ptvh->dwTile;
        ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);
        return MMSYSERR_NOERROR;
    }

    // if we have more than 1 buffer, and
    // the first buffer was on hardware.  if we fail
    // to allocate a buffer on hardware, return failure
    //
    // !!! This might upset somebody who doesn't get a min # of buffers
    if ((ii > 0) &&
        (0 == THKHDR(0)->dwMemHandle) &&
        (0 != THKHDR(0)->dwTile))
        return MMSYSERR_NOMEM;
  #endif

  #ifdef USE_CONTIG_ALLOC
    cpad.dwMemHandle = 0;
    cpad.dwPhysAddr = 0;
    // first try to get contig memory
    //
    ptvh->p32Buff = capPageAllocate (PageContig | PageFixed | PageUseAlign,
                                     (cbData + 4095) >> 12,
                                     0xFFFFF,  // max phys addr mask (fffff is no max addr)
                                     &cpad);
    if (ptvh->p32Buff)
    {
        ptvh->dwMemHandle = cpad.dwMemHandle;
        ptvh->dwTile = capTileBuffer (ptvh->p32Buff, cbData);
        ptvh->p16Alloc = PTR_FROM_TILE(ptvh->dwTile);
        if ( ! ptvh->p16Alloc)
        {
            capPageFree (ptvh->dwMemHandle);
            ptvh->dwMemHandle = 0;
            ptvh->dwTile = ptvh->p32Buff = 0;
        }
        else
        {
            // put the physical address into the the header so that
            // it can be used on the 32 bit side
            //
            ptvh->vh.dwReserved[3] = cpad.dwPhysAddr;

            AuxDebugEx (4, DEBUGLINE "contig alloc phys=%lX lin=%lX ptr=%lX cb=%ld\r\n",
                        cpad.dwPhysAddr, ptvh->p32Buff, ptvh->p16Alloc, cbData);
        }
    }

    // if we failed to get contiguous memory,
    // return NOMEM if there is a sufficient number of buffers
    // otherwise use GlobalAlloc
    // !!! The ideal thing to do is only use contig memory buffers until 
    // they're all full, then fall back on more non-contig buffers
    //
    if ( ! ptvh->p32Buff)
        if (ii >= MIN_VIDEO_BUFFERS)
            return MMSYSERR_NOMEM;
        else
   #endif
        {
            ptvh->dwTile = ptvh->dwMemHandle = 0;
            ptvh->p16Alloc = GlobalAllocPtr(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, cbData);
            if ( ! ptvh->p16Alloc)
               return MMSYSERR_NOMEM;

            ptvh->p32Buff = MapSL(ptvh->p16Alloc);

            AuxDebugEx (4, DEBUGLINE "global alloc lin=%lX ptr=%04X:%04X cb=%ld\r\n",
                        ptvh->p32Buff, ptvh->p16Alloc, cbData);
        }

    *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxFreePreviewBuffer (
    HVIDEOX	  hv,
    PTR32         p32)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreePreviewBuffer(%08lx,%08lx)\r\n",
                ptv, p32);

    V_HVIDEO(ptv);

    ptvh = ptv->pPreviewHdr;

    if (! ptvh ) 
        return MMSYSERR_NOMEM;

    if (ptvh->p16Alloc)
        GlobalFreePtr (ptvh->p16Alloc);

    GlobalFreePtr (ptvh);

    ptv->pPreviewHdr = NULL;

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  p32,
   UINT         cbHdr,
   DWORD        cbData)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxAllocPreviewBuffer(%08lx,%08lx,%08lx)\r\n",
                ptv, p32, cbData);

    cbHdr = max(cbHdr, sizeof(THKVIDEOHDR));

    *p32 = 0;

    V_HVIDEO(ptv);

    if (ptv->pPreviewHdr)
        NTvidxFreePreviewBuffer (hVideo, 0);

    ptvh = (LPVOID) GlobalAllocPtr(GPTR | GMEM_SHARE, cbHdr);
    if (!ptvh)
       return MMSYSERR_NOMEM;

    ptv->pPreviewHdr = ptvh;

    ptvh->dwTile = ptvh->dwMemHandle = 0;
    ptvh->p16Alloc = GlobalAllocPtr(GPTR | GMEM_SHARE, cbData);
    if ( ! ptvh->p16Alloc)
       {
       GlobalFreePtr (ptvh);
       return MMSYSERR_NOMEM;
       }

    ptvh->p32Buff = MapSL(ptvh->p16Alloc);

    AuxDebugEx (4, DEBUGLINE "global alloc lin=%lX ptr=%04X:%04X cb=%ld\r\n",
                ptvh->p32Buff, ptvh->p16Alloc, cbData);

    *p32 = ptvh->p32Buff;
    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbAllocHdr,
   PTR32 FAR * lpHdrs)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPVOID      lpv;

    AuxDebugEx (3, DEBUGLINE "vidxAllocHeaders(%08lx,%d,%08lx)\r\n",
                ptv, nHeaders, lpHdrs);

    V_HVIDEO(ptv);

    if ( ! nHeaders ||
        cbAllocHdr < sizeof(THKVIDEOHDR) ||
        cbAllocHdr & 3 ||
        (cbAllocHdr * nHeaders) > 0x10000l)
        return MMSYSERR_INVALPARAM;

    assert (ptv->paHdrs == NULL);

    lpv = GlobalAllocPtr (GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
                          cbAllocHdr * nHeaders);

    if (!lpv)
        return MMSYSERR_NOMEM;

    ptv->nHeaders   = nHeaders;
    ptv->cbAllocHdr = cbAllocHdr;
    //ptv->cbVidHdr   = sizeof(VIDEOHDREX);
    ptv->cbVidHdr   = sizeof(VIDEOHDR);
    ptv->p32aHdrs   = MapSL(lpv);
    ptv->paHdrs     = lpv;

    AuxDebugEx (4, DEBUGLINE "headers allocated. p16=@%lX, p32=%lX\r\n", lpv, ptv->p32aHdrs);

    *lpHdrs = ptv->p32aHdrs;

    return MMSYSERR_NOERROR;
}

STATICFN VOID PASCAL FreeBuffer (
    LPTHKHVIDEO ptv,
    LPTHKVIDEOHDR ptvh)
{
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

  #ifdef USE_CONTIG_ALLOC
    //
    // if this buffer was pageAllocated (as indicated by dwMemHandle
    // is non-zero)
    //
    if (ptvh->dwMemHandle)
    {
        if (ptvh->dwTile)
            capUnTileBuffer (ptvh->dwTile), ptvh->dwTile = 0;

        capPageFree (ptvh->dwMemHandle), ptvh->dwMemHandle = 0;
    }
    else
  #endif
  #ifdef USE_HW_BUFFERS
    //
    // if this buffer was allocated from capture hardware
    // (as indicated by dwMemHandle == 0 && dwTile != 0)
    //
    if (ptvh->dwTile != 0)
    {
        assert (ptvh->dwMemHandle == 0);
        NTvideoMessage (ptv->hVideo, DVM_STREAM_FREEBUFFER, 
                (LPARAM) (LPVOID) ptvh->dwTile, 0);
        ptvh->dwTile = 0;
    }
    else
  #endif
    //
    // if this buffer was allocated from global memory
    //
    {
        if (ptvh->p16Alloc)
            GlobalFreePtr (ptvh->p16Alloc);
    }

    ptvh->p16Alloc = NULL;
    ptvh->p32Buff  = 0;
}

DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    UINT          ii;
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreeHeaders(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);

    if ( ! ptv->paHdrs)
        return MMSYSERR_ERROR;

    for (ptvh = THKHDR(ii = 0); ii < ptv->nHeaders; ++ii, ptvh = THKHDR(ii))
    {
        if (ptvh->vh.dwFlags & VHDR_PREPARED)
        {
            NTvideoStreamUnprepareHeader (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);
            ptvh->vh.dwFlags &= ~VHDR_PREPARED;
        }
        FreeBuffer (ptv, ptvh);
    }

    GlobalFreePtr (ptv->paHdrs);
    ptv->paHdrs = NULL;
    ptv->p32aHdrs = 0;
    ptv->nHeaders = 0;

    return MMSYSERR_NOERROR;

}

STATICFN LPTHKVIDEOHDR PASCAL NTvidxLookupHeader (
    LPTHKHVIDEO ptv,
    DWORD_PTR p32Hdr)
{
    WORD ii;

    AuxDebugEx (5, DEBUGLINE "vidxLookupHeader(%08lx,%08lx)\r\n", ptv, p32Hdr);

    if ( ! p32Hdr || ! ptv->paHdrs || ! ptv->cbAllocHdr)
        return NULL;

    if ((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) % ptv->cbAllocHdr)
        return NULL;

    ii = (WORD)((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) / ptv->cbAllocHdr);
    if (ii > ptv->nHeaders)
        return NULL;

    return THKHDR(ii);
}
            
DWORD WINAPI NTvidxFreeBuffer (
    HVIDEOX       hv,
    DWORD_PTR         p32Hdr)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreeBuffer(%08lx,%08lx)\r\n",
                ptv, p32Hdr);

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    // single frame buffers are never prepared!
    //
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

    FreeBuffer (ptv, ptvh);
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\thunk.h ===
/****************************************************************************
 *
 *   thunk.h
 * 
 *   macros, defines, prototypes for avicap 16:32 thunks
 *
 *   Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _THUNK_H
#define _THUNK_H

typedef LPVOID P16VOID;
typedef DWORD  P32VOID;
//#define P16VOID LPVOID
//#define P32VOID DWORD

#include "common.h"

// thunk helpers exported from the kernel
//
DWORD WINAPI GetCurrentProcessID(void);  // KERNEL
DWORD WINAPI SetWin32Event(DWORD hEvent); // KERNEL

P16VOID  WINAPI MapLS(P32VOID);
P16VOID  WINAPI UnMapLS(P16VOID);
P32VOID  WINAPI MapSL(P16VOID);

// thunk helpers in thunka.asm
//
DWORD FAR PASCAL capTileBuffer (
    DWORD dwLinear,
    DWORD dwSize);

#define PTR_FROM_TILE(dwTile) (LPVOID)(dwTile & 0xFFFF0000)

void  FAR PASCAL capUnTileBuffer (
    DWORD dwTileInfo);

BOOL  FAR PASCAL capPageFree (
    DWORD dwMemHandle);

typedef struct _cpa_data {
    DWORD dwMemHandle;
    DWORD dwPhysAddr;
    } CPA_DATA, FAR * LPCPA_DATA;

DWORD FAR PASCAL capPageAllocate (  // returns ptr to allocated memory
    DWORD   dwFlags,
    DWORD   dwPageCount,
    DWORD   dwMaxPhysPageMask,
    LPCPA_DATA pcpad);   // returned mem handle & phys address

// flags for capPageAllocate, same as flags from vmm.inc
//
#define PageUseAlign    0x00000002
#define PageContig      0x00000004
#define PageFixed       0x00000008

#ifdef WIN32
void NTAPI ThunkTerm(void);
BOOL NTAPI ThunkInit(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\thunka.asm ===
page    ,132

        TITLE   $thunka.asm

        .386
        OPTION READONLY
        OPTION OLDSTRUCTS

        OPTION SEGMENT:USE16
        .model LARGE,PASCAL

        include mmdevldr.inc

;externDef FlatData:word
externDef MapLS:far16
externDef UnmapLS:far16
externDef MapSL:far16
externDef TileBuffer:far16
externDef UntileBuffer:far16

GetDeviceAPI            EQU     1684h                   ; int 2Fh query

        .data

MMDEVLDR_Entry  dd      ?       ; the api entry point for mmdevldr

        .code thunk

;===========================================================================

EAXtoDXAX       macro
        shld    edx, eax, 16            ; move HIWORD(eax) to dx
endm

DXAXtoEAX       macro
        ror     eax, 16                 ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax, edx, 16            ; move LOWORD(edx) to HIWORD(eax)
endm

;===========================================================================
public capTileBuffer
public capUnTileBuffer
public capPageAllocate
public capPageFree

;externDef      __FLATDS:abs
;
;_DATA SEGMENT WORD USE16 PUBLIC 'DATA'
;FlatData                dw      __FLATDS
;_DATA ENDS

;===========================================================================
align
capTileBuffer proc far16 public,
       dwFlatMemory:dword, dwLength:dword
        
        push    edi
        push    esi

        mov     eax, dwFlatMemory
        mov     ecx, dwLength
        call    TileBuffer
        mov     eax, ecx
        EAXtoDXAX

        pop     esi
        pop     edi
        ret
capTileBuffer endp

;===========================================================================
align
capUnTileBuffer proc far16 public,
        dwTilingInfo:dword

        push    esi
        push    edi
        mov     ecx, dwTilingInfo
        call    UntileBuffer
        pop     edi
        pop     esi
        ret
capUnTileBuffer endp

;===========================================================================

align
MMDEVLDR_load proc near16

        push    di
        xor     di, di                  ; zero ES:DI before call
        mov     es, di
        mov     ax, GetDeviceAPI        ; get device API entry point
        mov     bx, MMDEVLDR_Device_ID  ; virtual device ID
        int     2Fh                     ; call WIN/386 INT 2F API

        mov     ax, es
        ror     eax, 16
        mov     ax, di

        mov     DWORD PTR [MMDEVLDR_Entry], eax
        mov     ecx, eax
        pop     di
        ret
MMDEVLDR_Load endp


;===========================================================================
align
capPageAllocate proc far16 public,
        dwFlags:dword, dwPages:dword, dwMaxPhys:dword, phMem:dword

        mov     ecx, DWORD PTR [MMDEVLDR_Entry]
        jecxz   short cpa_load

cpa_doit:
        push    dwPages
        push    dwMaxPhys
        push    dwFlags
        mov     dx, MMDEVLDR_API_PageAllocate
        call    [MMDEVLDR_Entry]
        pop     ecx   ; handle
        pop     ebx   ; phys addr
        pop     eax   ; lin addr

        push    di
        push    es
        les     di, phMem
        mov     es:[di], ecx   ; return handle
        mov     es:[di+4], ebx ; return phys addr
        pop     es
        pop     di

        EAXtoDXAX

        ret

cpa_load:
        call    MMDEVLDR_Load
        jecxz   cpa_fail
        jmp     short cpa_doit

cpa_fail:
        xor     ax, ax
        mov     dx, ax
        ret

capPageAllocate endp

;===========================================================================
align
capPageFree proc far16 public,
        hMem:dword

        mov     ecx, DWORD PTR [MMDEVLDR_Entry]
        jecxz   short cpf_load

cpf_doit:
        push    hMem
        mov     dx, MMDEVLDR_API_PageFree
        call    [MMDEVLDR_Entry]
        pop     ebx  ; fix stack
        ret

cpf_load:
        call    MMDEVLDR_Load
        jecxz   cpf_fail
        jmp     short cpf_doit

cpf_fail:
        xor     ax, ax
        ret

capPageFree endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\video16.c ===
/****************************************************************************
 *
 *   thunk.c
 * 
 *   16:32 thunks for avicap & avicap32
 *
 *   Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

// !!! if you would rather use less buffers, but ensure they are all in
// contiguous memory, set this number
#define SAFE_NUMBER_OF_BUFFERS 16

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msviddrv.h>

typedef char FAR * LPTSTR;
typedef char FAR * LPCTSTR;
typedef char TCHAR;

#ifndef CALLBACK_THUNK
 #define CALLBACK_THUNK 0x00040000l
#endif
#ifndef CALLBACK_EVENT
 #define CALLBACK_EVENT 0x00050000l
#endif

#ifndef DVM_STREAM_FREEBUFFER
  #define DVM_STREAM_ALLOCBUFFER
  #define DVM_STREAM_FREEBUFFER
#endif

#include <msvideo.h>
#include "thunk.h"
#include "vidx.h"

#define MODULE_DEBUG_PREFIX "VIDX16\\"
#define _INC_MMDEBUG_CODE_ TRUE
#include "mmdebug.h"

// !!!
#define USE_HW_BUFFERS 1
#define USE_CONTIG_ALLOC

typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
typedef struct _thk_hvideo {
    struct _thk_hvideo * pNext;
    WORD           ds;    // this after pNext make it a far pointer at need...
    DWORD          Stamp;
    UINT           nHeaders;
    UINT           cbAllocHdr;
    UINT           cbVidHdr;
    UINT           spare;
    LPVOID         paHdrs;
    DWORD          p32aHdrs;
    LPVOID         pVSyncMem;
    DWORD          p32VSyncMem;
    DWORD          pid;

    HVIDEO         hVideo;
    HVIDEO         hFill;

    DWORD_PTR          dwCallback;
    DWORD_PTR          dwUser;

    LPTHKVIDEOHDR  pPreviewHdr;

    } THKHVIDEO;

#define THKHDR(ii) ((LPTHKVIDEOHDR)((LPBYTE)ptv->paHdrs + (ii * ptv->cbAllocHdr)))

static struct _thk_local {
    THKHVIDEO *    pMruHandle;
    THKHVIDEO *    pFreeHandle;
    int            nPoolSize;
    int            nAllocCount;
    } tl;

#define THKHVIDEO_STAMP  MAKEFOURCC('t','V','H','x')
#define V_HVIDEO(ptv) if (!ptv || ptv->Stamp != THKHVIDEO_STAMP) { \
             AuxDebugEx (-1, DEBUGLINE "V_HVIDEO failed hVideo=%08lx\r\n", ptv); \
             return MMSYSERR_INVALHANDLE; \
        }
#define V_HEADER(ptv,p32Hdr,ptvh) if (!(ptvh = vidxLookupHeader(ptv,p32Hdr))) { \
            AuxDebugEx(-1, DEBUGLINE "V_HEADER(%08lX,%08lX) failed!", ptv, p32Hdr); \
            return MMSYSERR_INVALPARAM; \
        }

#define SZCODE char _based(_segname("CODE"))
SZCODE pszDll16[] = "VIDX16.DLL";
SZCODE pszDll32[] = "CAPTURE.DLL";

//
//
BOOL WINAPI DllEntryPoint (
    DWORD           dwReason,
    HINSTANCE       hInstance,
    HGLOBAL         hgDS,
    WORD            wHeapSize,
    LPCSTR          lszCmdLine,     // Always NULL
    WORD            wCmdLine)       // Always 0
{
    DebugSetOutputLevel (GetProfileInt("Debug", "Vidx16", 0), 0);
    AuxDebugEx (1, DEBUGLINE "DllEntryPoint(%d,%04x,...)\r\n",
                dwReason, hInstance);

    return TRUE;
}

DWORD WINAPI vidxFreePreviewBuffer (
    LPTHKHVIDEO   ptv,
    DWORD         p32)
{
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreePreviewBuffer(%08lx,%08lx)\r\n",
                ptv, p32);

    V_HVIDEO(ptv);

    ptvh = ptv->pPreviewHdr;

    if (! ptvh ) 
        return MMSYSERR_NOMEM;

    if (ptvh->p16Alloc)
        GlobalFreePtr (ptvh->p16Alloc);

    GlobalFreePtr (ptvh);

    ptv->pPreviewHdr = NULL;

    return MMSYSERR_NOERROR;
}

DWORD WINAPI vidxAllocHeaders (
    LPTHKHVIDEO ptv,
    UINT        nHeaders,
    UINT        cbAllocHdr,
    LPDWORD     lpdwHdrLinearAddr)
{
    LPVOID      lpv;

    AuxDebugEx (3, DEBUGLINE "vidxAllocHeaders(%08lx,%d,%08lx)\r\n",
                ptv, nHeaders, lpdwHdrLinearAddr);

    V_HVIDEO(ptv);

    if ( ! nHeaders ||
        cbAllocHdr < sizeof(THKVIDEOHDR) ||
        cbAllocHdr & 3 ||
        (cbAllocHdr * nHeaders) > 0x10000l)
        return MMSYSERR_INVALPARAM;

    assert (ptv->paHdrs == NULL);

    lpv = GlobalAllocPtr (GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
                          cbAllocHdr * nHeaders);

    if (!lpv)
        return MMSYSERR_NOMEM;

    ptv->nHeaders   = nHeaders;
    ptv->cbAllocHdr = cbAllocHdr;
    //ptv->cbVidHdr   = sizeof(VIDEOHDREX);
    ptv->cbVidHdr   = sizeof(VIDEOHDR);
    ptv->p32aHdrs   = MapSL(lpv);
    ptv->paHdrs     = lpv;

    AuxDebugEx (4, DEBUGLINE "headers allocated. p16=@%lX, p32=%lX\r\n", lpv, ptv->p32aHdrs);

    *lpdwHdrLinearAddr = ptv->p32aHdrs;

    return MMSYSERR_NOERROR;
}

STATICFN VOID PASCAL FreeBuffer (
    LPTHKHVIDEO ptv,
    LPTHKVIDEOHDR ptvh)
{
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

  #ifdef USE_CONTIG_ALLOC
    //
    // if this buffer was pageAllocated (as indicated by dwMemHandle
    // is non-zero)
    //
    if (ptvh->dwMemHandle)
    {
        if (ptvh->dwTile)
            capUnTileBuffer (ptvh->dwTile), ptvh->dwTile = 0;

        capPageFree (ptvh->dwMemHandle), ptvh->dwMemHandle = 0;
    }
    else
  #endif
  #ifdef USE_HW_BUFFERS
    //
    // if this buffer was allocated from capture hardware
    // (as indicated by dwMemHandle == 0 && dwTile != 0)
    //
    if (ptvh->dwTile != 0)
    {
        assert (ptvh->dwMemHandle == 0);
        videoMessage (ptv->hVideo, DVM_STREAM_FREEBUFFER, 
                (DWORD) (LPVOID) ptvh->dwTile, 0);
        ptvh->dwTile = 0;
    }
    else
  #endif
    //
    // if this buffer was allocated from global memory
    //
    {
        if (ptvh->p16Alloc)
            GlobalFreePtr (ptvh->p16Alloc);
    }

    ptvh->p16Alloc = NULL;
    ptvh->p32Buff  = 0;
}

DWORD WINAPI vidxFreeHeaders (
    LPTHKHVIDEO ptv)
{
    UINT          ii;
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreeHeaders(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);

    if ( ! ptv->paHdrs)
        return MMSYSERR_ERROR;

    for (ptvh = THKHDR(ii = 0); ii < ptv->nHeaders; ++ii, ptvh = THKHDR(ii))
    {
        if (ptvh->vh.dwFlags & VHDR_PREPARED)
        {
            videoStreamUnprepareHeader (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);
            ptvh->vh.dwFlags &= ~VHDR_PREPARED;
        }
        FreeBuffer (ptv, ptvh);
    }

    GlobalFreePtr (ptv->paHdrs);
    ptv->paHdrs = NULL;
    ptv->p32aHdrs = 0;
    ptv->nHeaders = 0;

    return MMSYSERR_NOERROR;
}

STATICFN LPTHKVIDEOHDR PASCAL vidxLookupHeader (
    LPTHKHVIDEO ptv,
    DWORD       p32Hdr)
{
    WORD ii;

    AuxDebugEx (5, DEBUGLINE "vidxLookupHeader(%08lx,%08lx)\r\n", ptv, p32Hdr);

    if ( ! p32Hdr || ! ptv->paHdrs || ! ptv->cbAllocHdr)
        return NULL;

    if ((p32Hdr - ptv->p32aHdrs) % ptv->cbAllocHdr)
        return NULL;

    ii = (WORD)((p32Hdr - ptv->p32aHdrs) / ptv->cbAllocHdr);
    if (ii > ptv->nHeaders)
        return NULL;

    return THKHDR(ii);
}
            
DWORD WINAPI vidxFreeVSyncMem (
    LPTHKHVIDEO ptv)
{
    AuxDebugEx (3, DEBUGLINE "vidxFreeVSyncMem(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);

    if ( ! ptv->pVSyncMem)
        return MMSYSERR_ERROR;

    GlobalSmartPageUnlock ((HGLOBAL)HIWORD(ptv->pVSyncMem));
    GlobalFreePtr (ptv->pVSyncMem);
    ptv->pVSyncMem = NULL;
    ptv->p32VSyncMem = 0;

    return MMSYSERR_NOERROR;
}

STATICFN LPTHKHVIDEO PASCAL vidxAllocHandle(void)
{
    THKHVIDEO * ptv;
    int         ix;
    const int   GRANULARITY = 4;

    AuxDebugEx (4, DEBUGLINE "vidxAllocHandle() ");

    // first look in the free handle pool for a handle to use
    //
    if (ptv = tl.pFreeHandle)
    {
        assert (ptv->Stamp == THKHVIDEO_STAMP);
        tl.pFreeHandle = ptv->pNext;
        ptv->pNext = NULL;
    }
    // if we find the pool empty, alloc a few more handles
    // and put all but one in the pool.
    else
    {
        ptv = (VOID*)LocalAlloc(LPTR, sizeof(THKHVIDEO) * GRANULARITY);
        if (!ptv)
        {
            AuxDebugEx (4, "returns NULL\r\n");
            return NULL;
        }

        tl.nPoolSize += GRANULARITY;
        AuxDebugEx (4, DEBUGLINE "Allocating new %d GRAN, total = %d\r\nvidxAllocHandle() ",
                    GRANULARITY, tl.nPoolSize);

        for (ix = 1; ix < GRANULARITY; ++ix)
        {
            ptv[ix].Stamp = THKHVIDEO_STAMP;
            ptv[ix].pNext = tl.pFreeHandle;
            ptv[ix].ds    = HIWORD((LPVOID)ptv);
            tl.pFreeHandle = ptv +ix;
        }
    }

    ptv->Stamp = THKHVIDEO_STAMP;
    ptv->pNext = tl.pMruHandle;
    tl.pMruHandle = ptv;

    ++tl.nAllocCount;
    assert (tl.nAllocCount < 31);

    AuxDebugEx (4, "returns %08lx (of %d)\r\n", (LPVOID)ptv, tl.nAllocCount);
    return (LPVOID)ptv;
}

STATICFN BOOL PASCAL vidxFreeHandle(
    LPTHKHVIDEO ptvFar)
{
    THKHVIDEO * ptvFree;
    THKHVIDEO * ptv;
    THKHVIDEO * ptvPrev;

    ptvFree = (VOID*)LOWORD(ptvFar);
    assert (HIWORD(ptvFar) == HIWORD((LPVOID)ptvFree));

    AuxDebugEx (4, DEBUGLINE "vidxFreeHandle(%08lx) of %d\r\n", ptvFar, tl.nAllocCount);

    for (ptvPrev = NULL, ptv = tl.pMruHandle;
         ptv != NULL;
         ptvPrev = ptv, ptv = ptv->pNext)
    {
        if (ptv == ptvFree)
        {
            if (ptvPrev)
                ptvPrev->pNext = ptv->pNext;
            else
                tl.pMruHandle = ptv->pNext;

            ptv->pNext = tl.pFreeHandle;
            tl.pFreeHandle = ptv;

            --tl.nAllocCount;

            vidxFreePreviewBuffer(ptvFar, 0);
            if (ptv->paHdrs)
                vidxFreeHeaders (ptvFar);
            if (ptv->pVSyncMem)
                vidxFreeVSyncMem (ptvFar);

            return TRUE;
        }
    }
    assert3 (0, "attempt to free unused handle %08lxx", ptv);
    return FALSE;
}

DWORD WINAPI vidxOpen (
    LPTHKHVIDEO  FAR *pptv,
    DWORD        dwDevice,
    DWORD        dwFlags)
{
    LPTHKHVIDEO ptv;
    DWORD      mmr;

    AuxDebugEx (3, DEBUGLINE "vidxOpen(%08lx,%08lx,%08lx)\r\n", pptv, dwDevice, dwFlags);

    *pptv = NULL;
    ptv = vidxAllocHandle ();
    if (!ptv)
        return MMSYSERR_NOMEM;

    mmr = videoOpen(&ptv->hVideo, dwDevice, dwFlags);
    if (mmr != MMSYSERR_NOERROR)
    {
        vidxFreeHandle (ptv);
        ptv = NULL;
    }

    *pptv = ptv;
    return mmr;
}

DWORD WINAPI vidxClose (
    LPTHKHVIDEO ptv)
{
    DWORD   mmr;

    AuxDebugEx (3, DEBUGLINE "vidxClose(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);

    mmr = videoClose (ptv->hVideo);
    ptv->hVideo = 0;

    vidxFreeHandle (ptv);

    return mmr;
}

DWORD WINAPI vidxGetErrorText (
    LPTHKHVIDEO ptv,
    UINT        wError,
    LPSTR       lpText,
    UINT        wSize)
{
    // Don't use V_HVIDEO() because it is legal to pass a NULL hVideo
    // to this function...

    AuxDebugEx (5, DEBUGLINE "vidxGetErrorText(%08lx,%d,%08lx,%d)\r\n",
                ptv, wError, lpText, wSize);

    if (ptv && ptv->Stamp == THKHVIDEO_STAMP)
        return videoGetErrorText (ptv->hVideo, wError, lpText, wSize);
    else
        return videoGetErrorText (NULL, wError, lpText, wSize);
}

DWORD WINAPI vidxAllocBuffer (
    LPTHKHVIDEO ptv,
    UINT        ii,
    LPDWORD     p32Hdr,
    DWORD       cbData)
{
    LPTHKVIDEOHDR ptvh;
   #ifdef USE_CONTIG_ALLOC
    CPA_DATA cpad;
   #endif

    AuxDebugEx (4, DEBUGLINE "vidxAllocBuffer(%08lx,%d,%08lx,%08lx)\r\n",
                ptv, ii, p32Hdr, cbData);

    *p32Hdr = 0;

    V_HVIDEO(ptv);
    if (ii >= ptv->nHeaders || ptv->paHdrs == NULL)
        return MMSYSERR_NOMEM;

    ptvh = THKHDR(ii);

  #ifdef USE_HW_BUFFERS
    // try to allocate a buffer on hardware
    //
    if (videoMessage (ptv->hVideo, DVM_STREAM_ALLOCBUFFER,
                (DWORD) (LPVOID)&ptvh->dwTile, cbData)
        == DV_ERR_OK)
    {
        // if we got hw buffers, dwMemHandle == 0 && dwTile != 0
        // we will depend on this to know who to free the memory to
        // (for phys mem both will be non zero, while for GlobalMem
        // both will be zero)
        //
        ptvh->dwMemHandle = 0;
        ptvh->p16Alloc = (LPVOID)ptvh->dwTile;
        ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        *p32Hdr = ptv->p32aHdrs + (ii * ptv->cbAllocHdr);
        AuxDebugEx (3, "Got HARDWARE memory lin=%lX ptr=%lX cb=%ld\r\n",
                        		ptvh->p32Buff, ptvh->p16Alloc, cbData);
        return MMSYSERR_NOERROR;
    }

    // if we have more than 1 buffer, and
    // the first buffer was on hardware.  if we fail
    // to allocate a buffer on hardware, return failure
    //
    // !!! This might upset somebody who doesn't get a min # of buffers
    if ((ii > 0) &&
        (0 == THKHDR(0)->dwMemHandle) &&
        (0 != THKHDR(0)->dwTile))
        return MMSYSERR_NOMEM;
  #endif

  //#ifdef USE_CONTIG_ALLOC
    cpad.dwMemHandle = 0;
    cpad.dwPhysAddr = 0;
    // first try to get contig memory
    //
    ptvh->p32Buff = capPageAllocate (PageContig | PageFixed | PageUseAlign,
                                     (cbData + 4095) >> 12,
                                     0xFFFFF,  // max phys addr mask (fffff is no max addr)
                                     &cpad);
    if (ptvh->p32Buff)
    {
        ptvh->dwMemHandle = cpad.dwMemHandle;
        ptvh->dwTile = capTileBuffer (ptvh->p32Buff, cbData);
        ptvh->p16Alloc = PTR_FROM_TILE(ptvh->dwTile);
        if ( ! ptvh->p16Alloc)
        {
            AuxDebugEx (3, "*** can't get 16 bit pointer to contig memory\r\n");
	    
            capPageFree (ptvh->dwMemHandle);
            ptvh->dwMemHandle = 0;
            ptvh->dwTile = ptvh->p32Buff = 0;
        }
        else
        {
            // put the physical address into the the header so that
            // it can be used on the 32 bit side
            //
            ptvh->vh.dwReserved[3] = cpad.dwPhysAddr;

            AuxDebugEx (3, "Got CONTIGUOUS PHYSICAL memory=%lX lin=%lX ptr=%lX cb=%ld\r\n",
                        cpad.dwPhysAddr, ptvh->p32Buff, ptvh->p16Alloc, cbData);
        }
    }

    // if we failed to get contiguous memory,
    // return NOMEM if there is a sufficient number of buffers
    // otherwise use GlobalAlloc
    // !!! The ideal thing to do is only use contig memory buffers until 
    // they're all full, then fall back on more non-contig buffers
    //
    if ( ! ptvh->p32Buff) {
        if (ii >= SAFE_NUMBER_OF_BUFFERS) {
            AuxDebugEx (3, "Failed, but what the hell, we have enough\r\n");
            return MMSYSERR_NOMEM;
        } else
   //#endif
        {
            ptvh->dwTile = ptvh->dwMemHandle = 0;
            ptvh->p16Alloc = GlobalAllocPtr(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, cbData);
            if ( ! ptvh->p16Alloc) {
                AuxDebugEx (3, "*** Ack!  Global Alloc %d failed\r\n", cbData);
                return MMSYSERR_NOMEM;
	    }

            ptvh->p32Buff = MapSL(ptvh->p16Alloc);

            AuxDebugEx (3, "Got FRAGMENTED (virtual?) memory lin=%lX ptr=%04X:%04X cb=%ld\r\n",
                        ptvh->p32Buff, ptvh->p16Alloc, cbData);
        }
    }

    *p32Hdr = ptv->p32aHdrs + (ii * ptv->cbAllocHdr);

    return MMSYSERR_NOERROR;
}

DWORD WINAPI vidxFreeBuffer (
    LPTHKHVIDEO   ptv,
    DWORD         p32Hdr)
{
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxFreeBuffer(%08lx,%08lx)\r\n",
                ptv, p32Hdr);

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    // single frame buffers are never prepared!
    //
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

    FreeBuffer (ptv, ptvh);
    return MMSYSERR_NOERROR;
}


DWORD WINAPI vidxSetRect (
    LPTHKHVIDEO ptv,
    UINT        uMsg,
    int         left,
    int         top,
    int         right,
    int         bottom)
{
    RECT rc = {left, top, right, bottom};

    AuxDebugEx (5, DEBUGLINE "vidxSetRect(%08lx,%d,%d,%d,%d,%d)\r\n",
                ptv, uMsg, left, top, right, bottom);

    V_HVIDEO(ptv);
    return videoMessage (ptv->hVideo, uMsg,
                         (DWORD)(LPVOID)&rc,
                         VIDEO_CONFIGURE_SET);
}

DWORD WINAPI vidxUpdate (
    LPTHKHVIDEO ptv,
    HWND        hWnd,
    HDC         hDC)
{
    V_HVIDEO(ptv);

    AuxDebugEx (5, DEBUGLINE "vidxUpdate(%08lx,%04x,%04x)\r\n",
                ptv, hWnd, hDC);

    return videoUpdate(ptv->hVideo, hWnd, hDC);
}

DWORD WINAPI vidxDialog (
    LPTHKHVIDEO ptv,
    HWND        hWndParent,
    DWORD       dwFlags)
{
    V_HVIDEO(ptv);

    AuxDebugEx (5, DEBUGLINE "vidxDialog(%08lx,%04x,%08lx)\r\n",
                ptv, hWndParent, dwFlags);

    return videoDialog(ptv->hVideo, hWndParent, dwFlags);
}

DWORD WINAPI vidxStreamInit (
    LPTHKHVIDEO ptv,
    DWORD       dwMicroSecPerFrame,
    DWORD_PTR       dwCallback,
    DWORD_PTR       dwUser,
    DWORD       dwFlags)
{
    DWORD       dwCbType;
    DWORD       mmr;
   #if defined DEBUG || defined DEBUG_RETAIL
    DWORD       dwT;
    LPTHKVIDEOHDR ptvh = NULL;
   #endif

    V_HVIDEO(ptv);

    AuxDebugEx (3, DEBUGLINE "vidxStreamInit(%08lx,%08lx,%08lx,%08lx,%08lx)\r\n",
                ptv, dwMicroSecPerFrame, dwCallback, dwUser, dwFlags);

    ptv->dwCallback = dwCallback;
    ptv->dwUser = dwUser;

    dwCbType = dwFlags & CALLBACK_TYPEMASK;
    if (dwCbType == CALLBACK_FUNCTION)
        return MMSYSERR_NOTSUPPORTED;

    assert (!dwCallback || (ptvh == ptv->paHdrs));
    assert (!ptvh || (dwT == ptvh->p32Buff));
    //if (ptvh) {
    //    AuxDebugEx (4, DEBUGLINE "ptvh=%lX p32Buff=%lX map=%lX\r\n", ptvh, dwT, MapSL(ptvh));
    //    INLINE_BREAK;
    //}

    mmr = videoStreamInit (ptv->hVideo, dwMicroSecPerFrame, dwCallback, (DWORD_PTR)ptv, dwFlags);

    //if (ptvh) {
    //   AuxDebugEx (4, DEBUGLINE "ptvh=%lX p32Buff=%lX\r\n", ptvh, ptvh->p32Buff, MapSL(ptvh));
    //}
    assert (!ptvh || dwT == ptvh->p32Buff);

    return mmr;
}

DWORD WINAPI vidxStreamFini (
    LPTHKHVIDEO ptv)
{
    V_HVIDEO(ptv);

    AuxDebugEx (3, DEBUGLINE "vidxStreamFini(%08lx)\r\n", ptv);

    return videoStreamFini (ptv->hVideo);
}

DWORD WINAPI vidxAllocPreviewBuffer (
    LPTHKHVIDEO ptv,
    LPDWORD     p32,
    UINT        cbHdr,
    DWORD       cbData)
{
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (3, DEBUGLINE "vidxAllocPreviewBuffer(%08lx,%08lx,%08lx)\r\n",
                ptv, p32, cbData);

    cbHdr = max(cbHdr, sizeof(THKVIDEOHDR));

    *p32 = 0;

    V_HVIDEO(ptv);

    if (ptv->pPreviewHdr)
        vidxFreePreviewBuffer (ptv, 0);

    ptvh = (LPVOID) GlobalAllocPtr(GPTR | GMEM_SHARE, cbHdr);
    if (!ptvh)
       return MMSYSERR_NOMEM;

    ptv->pPreviewHdr = ptvh;

    ptvh->dwTile = ptvh->dwMemHandle = 0;
    ptvh->p16Alloc = GlobalAllocPtr(GPTR | GMEM_SHARE, cbData);
    if ( ! ptvh->p16Alloc)
       {
       GlobalFreePtr (ptvh);
       return MMSYSERR_NOMEM;
       }

    ptvh->p32Buff = MapSL(ptvh->p16Alloc);

    AuxDebugEx (4, DEBUGLINE "global alloc lin=%lX ptr=%04X:%04X cb=%ld\r\n",
                ptvh->p32Buff, ptvh->p16Alloc, cbData);

    *p32 = ptvh->p32Buff;
    return MMSYSERR_NOERROR;
}

STATICFN DWORD vidxSpecialFrame (
    LPTHKHVIDEO  ptv,
    //LPVIDEOHDREX pVHdr)
    LPVIDEOHDR pVHdr)
{
    //LPVIDEOHDREX pvh;
    LPVIDEOHDR pvh;
    DWORD        mmr;

    AuxDebugEx (5, DEBUGLINE "vidxSpecialFrame(%08lx,%08lx)\r\n", ptv, pVHdr);

    V_HVIDEO(ptv);

    pvh = (LPVOID) GlobalAllocPtr(GMEM_FIXED | GMEM_SHARE,
                                  pVHdr->dwBufferLength
                                  //+ sizeof(VIDEOHDREX));
                                  + sizeof(VIDEOHDR));
    if ( ! pvh)
        return MMSYSERR_NOMEM;

    *pvh = *pVHdr;
    pvh->lpData = (LPBYTE)(pvh+1);

    mmr = videoFrame (ptv->hVideo, (LPVIDEOHDR)pvh);
    if (MMSYSERR_NOERROR == mmr)
    {
        DWORD dwTile = capTileBuffer ((DWORD)pVHdr->lpData, pvh->dwBytesUsed);
        if ( ! dwTile)
        {
            GlobalFreePtr (pvh);
            return MMSYSERR_NOMEM;
        }

        hmemcpy (PTR_FROM_TILE(dwTile), pvh->lpData, pvh->dwBytesUsed);
        capUnTileBuffer (dwTile);
    }

    {
    LPVOID lpData = pVHdr->lpData;
    *pVHdr = *pvh;
    pVHdr->lpData = lpData;
    GlobalFreePtr (pvh);
    }

    AuxDebugEx (5, DEBUGLINE "vidxSpecialFrameEnd(%08lx,%08lx)\r\n", ptv, pVHdr);
    return mmr;
}

DWORD WINAPI vidxFrame (
    LPTHKHVIDEO   ptv,
    //LPVIDEOHDREX  pVHdr)
    LPVIDEOHDR  pVHdr)
{
    LPTHKVIDEOHDR ptvh;
    DWORD         mmr;
    LPVOID        lpData;

    AuxDebugEx (5, DEBUGLINE "vidxFrameStart(%08lx,%08lx)\r\n", ptv, pVHdr);

    V_HVIDEO(ptv);
        
    ptvh = ptv->pPreviewHdr;

    ptvh->vh = *pVHdr;

    // if the buffer pointer is not in the same segment as we
    // allocated, assume that it is a 32 bit linear address.
    // in this case we need to convert it to 16:16 address
    // it will be converted back to linear in the completion callback
    //
    if (HIWORD(ptvh->vh.lpData) != HIWORD(ptvh->p16Alloc))
    {
        DWORD cbPrefix = (DWORD)ptvh->vh.lpData - ptvh->p32Buff;

        // if cbPrefix > 4K, this must not be the same
        // buffer we gave back via vidxAllocPreviewBuffer,
        // so we punt and use the full (expensive) thunk
        // solution in vidxSpecialFrame.  This will happen
        // during palette createing and during step capture
        // at 2X size.
        //
        if (cbPrefix > 4095)
            return vidxSpecialFrame(ptv, pVHdr);

        ptvh->vh.lpData = (LPBYTE)ptvh->p16Alloc + LOWORD(cbPrefix);
    }

    mmr = videoFrame (ptv->hVideo, (LPVIDEOHDR)&ptvh->vh);

    lpData = pVHdr->lpData;
    *pVHdr = ptvh->vh;
    pVHdr->lpData = lpData;

    AuxDebugEx (5, DEBUGLINE "vidxFrameEnd(%08lx,%08lx)\r\n", ptv, pVHdr);
    return mmr;
}

DWORD WINAPI vidxConfigure (
    LPTHKHVIDEO ptv,
    UINT        uMsg,
    DWORD       dwFlags,
    LPDWORD     lpdwRet,
    LPVOID      lpv1,
    DWORD       cb1,
    LPVOID      lpv2,
    DWORD       cb2)
{
    V_HVIDEO(ptv);

    AuxDebugEx (5, DEBUGLINE "vidxConfigure(%08lx,%d,%08lx, ...)\r\n", ptv, uMsg, dwFlags);

    return videoConfigure (ptv->hVideo, uMsg, dwFlags, lpdwRet, lpv1, cb1, lpv2, cb2);
}

DWORD WINAPI vidxGetChannelCaps (
    LPTHKHVIDEO    ptv,
    LPCHANNEL_CAPS lpcc,
    DWORD          dwSize)
{
    V_HVIDEO(ptv);

    AuxDebugEx (5, DEBUGLINE "vidxGetChannelCaps(%08lx,%08lx,%ld)\r\n", ptv, lpcc, dwSize);

    return videoGetChannelCaps (ptv->hVideo, lpcc, dwSize);
}

DWORD WINAPI vidxAddBuffer (
    LPTHKHVIDEO ptv,
    PTR32       p32Hdr,
    DWORD       cbHdr)
{
    LPTHKVIDEOHDR ptvh;
    DWORD         mmr;

    AuxDebugEx (5, DEBUGLINE "vidxAddBuffer(%08lx,%08lx,%ld)\r\n", ptv, p32Hdr, cbHdr);

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    // if the buffer pointer is not in the same segment as we
    // allocated, assume that it is a 32 bit linear address.
    // in this case we need to convert it to 16:16 address
    // it will be converted back to linear in the completion callback
    //
    if (HIWORD(ptvh->vh.lpData) != HIWORD(ptvh->p16Alloc))
    {
        DWORD cbPrefix = (DWORD)ptvh->vh.lpData - ptvh->p32Buff;

        assert (cbPrefix < 0x4096);
        if (cbPrefix > 4095)
            return MMSYSERR_ERROR;

        ptvh->vh.lpData = (LPBYTE)ptvh->p16Alloc + LOWORD(cbPrefix);
    }

    //assert (cbHdr == sizeof(VIDEOHDR) || cbHdr == sizeof(VIDEOHDREX));
    //if (cbHdr == sizeof(VIDEOHDR) && ptv->cbVidHdr == sizeof(VIDEOHDREX))
    //   ptv->cbVidHdr = (UINT)cbHdr;
    assert (cbHdr == sizeof(VIDEOHDR));
    assert (cbHdr == ptv->cbVidHdr);

    mmr = MMSYSERR_NOERROR;
    if (!(ptvh->vh.dwFlags & VHDR_PREPARED))
        mmr = videoStreamPrepareHeader (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);

    if (mmr == MMSYSERR_NOERROR)
        mmr = videoStreamAddBuffer (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);
    return mmr;
}

DWORD WINAPI vidxStreamUnprepareHeader (
    LPTHKHVIDEO ptv,
    DWORD       p32Hdr,
    DWORD       cbHdr)
{
    LPTHKVIDEOHDR ptvh;

    AuxDebugEx (5, DEBUGLINE "vidxStreamUnprepareHeader(%08lx,%08lx,%ld)\r\n", ptv, p32Hdr, cbHdr);

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    return videoStreamUnprepareHeader (ptv->hVideo, (LPVOID)ptvh, cbHdr);
}


DWORD WINAPI vidxStreamReset (
    LPTHKHVIDEO ptv)
{
    AuxDebugEx (4, DEBUGLINE "vidxStreamReset(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);
    return videoStreamReset (ptv->hVideo);
}

DWORD WINAPI vidxStreamStart (
    LPTHKHVIDEO ptv)
{
    AuxDebugEx (4, DEBUGLINE "vidxStreamStart(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);

    return videoStreamStart (ptv->hVideo);
}

DWORD WINAPI vidxStreamStop (
    LPTHKHVIDEO ptv)
{
    AuxDebugEx (4, DEBUGLINE "vidxStreamStop(%08lx)\r\n", ptv);

    V_HVIDEO(ptv);
    return videoStreamStop (ptv->hVideo);
}

DWORD WINAPI vidxSetupVSyncMem (
    LPTHKHVIDEO ptv,
    LPDWORD     pp32VSyncMem) // NULL to release VSYNC mem
{
    MMRESULT mmr = MMSYSERR_NOERROR;

    AuxDebugEx (4, DEBUGLINE "vidxSetupVSyncMem(%08lx)\r\n", ptv);
    V_HVIDEO(ptv);

    // if ppVSyncMem != NULL, then we are asked to allocate
    // VSync mem and pass it to the driver, then return a pointer
    // to the application.
    //
    if (pp32VSyncMem)
       {
       LPVOID lpv;
       *pp32VSyncMem = 0;
       if (ptv->pVSyncMem)
          {
          *pp32VSyncMem = ptv->p32VSyncMem;
          return MMSYSERR_NOERROR;
          }

       lpv = GlobalAllocPtr (GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
                             sizeof(VSYNCMEM));
       if (!lpv)
           return MMSYSERR_NOMEM;

       GlobalSmartPageLock ((HGLOBAL)HIWORD(lpv));

       ptv->pVSyncMem = lpv;
       *pp32VSyncMem = ptv->p32VSyncMem = MapSL(lpv);
       AuxDebugEx (4, DEBUGLINE "vsyncmem allocated. p16=@%lX, p32=%lX\r\n", lpv, ptv->p32VSyncMem);

       // ask the driver to begin using this VSyncMem buffer
       //
       mmr = videoMessage (ptv->hVideo,
                           (UINT)DVM_CLOCK_BUFFER,
                           (DWORD)(LPVOID)lpv,
                           (DWORD)sizeof(VSYNCMEM));
       if (mmr)
          vidxFreeVSyncMem(ptv);
       }
    // if pp32VSyncMem is NULL, we are asked to free any allocated
    // VSyncMem
    else
       {
       // tell driver to release VSyncMem (if it even cares...)
       //
       videoMessage (ptv->hVideo, DVM_CLOCK_BUFFER, 0, 0);
       vidxFreeVSyncMem(ptv);
       }

    return mmr;
}

// For some reason, left out of msvideo.h
DWORD WINAPI videoCapDriverDescAndVer (
        DWORD dwDeviceID,
        LPTSTR lpszName, UINT cbName,
        LPTSTR lpszVer, UINT cbVer);

DWORD WINAPI vidxCapDriverDescAndVer (
    DWORD dwDriverIndex,
    LPSTR lpszName,
    UINT  cbName,
    LPSTR lpszVer,
    UINT  cbVer)
{
    AuxDebugEx (4, DEBUGLINE "vidxDriverDescAndVer(%08lx,%08lx,%d,%08lx,%d)\r\n", dwDriverIndex, lpszName, cbName, lpszVer, cbVer);

    if (IsBadWritePtr(lpszName, cbName) || IsBadWritePtr(lpszVer, cbVer))
        return MMSYSERR_INVALPARAM;

    return videoCapDriverDescAndVer(dwDriverIndex, lpszName, cbName,
                                        lpszVer, cbVer);
}

DWORD WINAPI vidxMessage(
    LPTHKHVIDEO ptv,
    UINT uMsg,
    DWORD dw1,
    DWORD dw2)
{
    AuxDebugEx(4, DEBUGLINE "vidxMessage(%08lx,%d,%d,%d)\r\n",
							ptv, uMsg, dw1, dw2);

    return videoMessage(ptv->hVideo, uMsg, dw1, dw2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\vidx.h ===
/*+ vidx.h
 *
 * structures and prototypes for thunkable videoXXX api's
 *
 *-================ Copyright 1995 Microsoft Corp. ======================*/

#ifndef _VIDX_H
#define _VIDX_H

// Force C declarations for C++
//
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#ifdef WIN32
  typedef unsigned __int64 QUADWORD;
  #define HVIDEOX HVIDEO
  #define PTR32   LPVOID
  #define PTR16   LPVOID
#else
  #define QUADWORD struct { DWORD lo; DWORD hi; }
  #undef  WINAPI
  #define WINAPI FAR PASCAL _export
  typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
  #undef  HVIDEO
  #define HVIDEOX LPTHKHVIDEO
  #define PTR32   DWORD
  #define PTR16   LPVOID
#endif

// 'cooked' SMPTE timecode.  this is organized so that
// timecode values can be compared as a single QUAD operation
// so long as frame rates match.
//
// it is treated as a fixed point 48bit binary real number
// with the decimal point always at 32.16
//
// the only non-integral frame rate is 29.97 (NTSC) which is
// indicated by 0 in the frame rate field.
//
typedef union _vidxtimecode {
   struct {
      WORD  wFrameRate;  // 0 == 29.97 frame rate
      WORD  wFrameFract; // fractional frames. range 0-FFFF
      DWORD dwFrames;    // frame count.
      };
   QUADWORD qw;          // for copy/compare operations.
   } VIDXTIMECODE;

// timecode + userdata
//
typedef struct _vidxtimecodedata {
   VIDXTIMECODE time;
   DWORD    dwSMPTEFlags;
   DWORD    dwUser;
   } VIDXTIMECODEDATA;

// structure of memory shared between driver and quartz
// capture. used to allow Quartz to slave a clock to
// the vsync interrupt.
//
// This memory region will be locked down prior to being
// passed to the driver in Win95 so that it may be accessed at
// interrupt time. Because of the way the thunking layer works,
// it is not advisable for the driver to attempt to lock this
// memory. The memory will be visible in all process contexts.
//
// The driver is responsible for updating nVsyncCount on each VSYNC
// or as often as possible.  Whenever nVsyncCount is updated, qwSystemTime
// should be updated also, and if SMPTE timecode corresponding to this VSYNC
// is available, tcdata should be updated also.  If SMPTE timecode for this
// VSYNC is NOT available, dwFlags should be changed to indicate there is no
// timecode infomation (clear the VSYNCMEM_FLAGS_SMPTE bit of dwFlags)
//
// While updating, the driver should set the low bit of the dwInUse flag to 1.
// 
// The driver should set the dwFlags field to indicated the presense
// of valid nVsyncCount/qwSystemTime and tcdata.
//
// The driver is allowed to choose between setting qwSystemTime to the return
// value of QueryPerformanceCounter or the value of the Pentium tick.  It is 
// recommended to use QPC on NT as the pentium tick is not necessarily available
// to application code in that environment.
//
// When the Quartz capture wrapper reads from this shared memory, it will check
// the dwInUse flag and also read twice comparing results to insure that it reads
// valid, consistent data. 
//
typedef struct _vsyncmem {
   DWORD        dwInUse;       // low bit is non-zero when the driver is
                               // updating this struture.  other bits reserved.

   DWORD        nVsyncCount;  // VSYNC count
   QUADWORD     qwSystemTime; // QueryPerformanceCounter value at this VSYNC

   DWORD        dwFlags;      // flags indicate which fields are in use
   #define VSYNCMEM_TIME_MASK    0x0000000F // mask to get type of qwSystemTime
   #define VSYNCMEM_TIME_QPC     0x00000001 // qwSystemTime is QueryPerformanceCounter
   #define VSYNCMEM_TIME_PENTIUM 0x00000002 // qwSystemTime is pentium CPU tick

   #define VSYNCMEM_FLAG_SMPTE   0x00000010  // set if tcdata is valid

   DWORD        dwSpare;      // spare to align the next field on Quad boundary
   VIDXTIMECODEDATA tcdata;   // SMPTE timecode associated with this VSYNC
   } VSYNCMEM;

// DVM_xxx messages are defined in VFW.H
//
#ifndef DVM_CONFIGURE_START
  #define DVM_CONFIGURE_START 0x1000
#endif
#define DVM_CLOCK_BUFFER     (UINT)(DVM_CONFIGURE_START+0x10)
   //
   // dw1 = ptr to VSYNCMEM. ptr is valid until next DVM_CLOCK_BUFFER message
   //       or until driver is closed.
   // dw2 = size of VSYNCMEM buffer
   //
   // driver should return MMSYSERR_NOERROR (0) to indicate that it is
   // capable of keeping the contents of the VSYNCMEM buffer up to date.
   //


// legacy VFW capture filter will NOT make any attempt at time code/line 21
//========================================================================
#if 0
// The extended video header has extra fields that can be used to
// return CC (Line21) and SMPTE timcode information along with captured
// video frames.
//
// the first time the driver gets a DVM_STREAM_PREPAREHEADER and/or DVM_STREAM_ADDBUFFER
// message, it will contain sizeof(VIDEOHDREX) as dwParam2, if the driver fails
// this message, all subsequent messages will use sizeof(VIDEOHDR) as the videoheader size.
// drivers that do not fail this message, may still not be checking the header size 
// and responding properly to the new fields.  
//
// Drivers that do support the extra fields in VIDEOHDREX are responsible for setting
// bits in dwExtraMask to indicate which extra fields have valid data, this should be
// done BEFORE setting the 'done' bit in the VIDEOHDR
//
typedef struct _videohdrex {
  LPBYTE lpData;
  DWORD  dwBufferLength;
  DWORD  dwBytesUsed;
  DWORD  dwTimeCaptured;
  DWORD  dwUser;
  DWORD  dwFlags;
  DWORD  dwReserved[4];
  //
  // fields above this match the VIDEOHDR
  //

  // bits in this mask indicate which extra header fields
  // have data in them
  DWORD  dwExtraMask;

  // accumulated line21 info since last header. older data
  // is in smaller index'd elements.  the mask indicates
  // how many words of line21 are filled in the array.
  // if both CC and OTHER information are being captured
  // then CC data is in even elements and OTHER data is in
  // odd elements.
  //
  #define VHDR_EXTRA_LINE21     0x0000F  // count of wLine21 members that have data
  #define VHDR_EXTRA_CC         0x00010  // set when data is from CC field
  #define VHDR_EXTRA_OTHER      0x00020  // set when data is program info field
  WORD   wLine21[10]; // this needs to be a multiple of 4+2 so
                      // that the timecode field below gets aligned
                      // properly

  // primary and secondary timecode + userdata
  // timecodeA is in element [0] of the array
  //
  #define VHDR_EXTRA_TIMECODEA  0x10000
  #define VHDR_EXTRA_TIMECODEB  0x20000
  VIDXTIMECODEDATA timecode[2];

} VIDEOHDREX, FAR * LPVIDEOHDREX;
#endif
//========================================================================

// VIDEOHDR + extra fields used by the thunking layer
//
typedef struct _thk_videohdr {
    //VIDEOHDREX vh;
    VIDEOHDR vh;
    PTR32      p32Buff;
    PTR16      p16Alloc;
    DWORD      dwMemHandle;
    DWORD      dwTile;
    DWORD_PTR  dwUser;		// use this instead of dwUser in VIDEOHDR
				// because some drivers trash it! (Miro DC30)
    DWORD      dwIndex;		// which header is this in our array?
} THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

DWORD WINAPI vidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);
DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);

DWORD WINAPI vidxFreeHeaders(
   HVIDEOX hv);
DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv);

DWORD WINAPI vidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);
DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);

DWORD WINAPI vidxFreeBuffer (
   HVIDEOX hv,
   DWORD   p32Hdr);
DWORD WINAPI NTvidxFreeBuffer (
   HVIDEOX hv,
   DWORD_PTR p32Hdr);

DWORD WINAPI vidxSetRect (
   HVIDEOX hv,
   UINT    wMsg,
   int     left,
   int     top,
   int     right,
   int     bottom);
DWORD WINAPI NTvidxSetRect (
   HVIDEOX hv,
   UINT    wMsg,
   int     left,
   int     top,
   int     right,
   int     bottom);

DWORD WINAPI vidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI vidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);
DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);

DWORD WINAPI vidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);
DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);

DWORD WINAPI vidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);
DWORD WINAPI NTvidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);

DWORD WINAPI vidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem
DWORD WINAPI NTvidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem


// needed for Win95 thunking
//
VOID WINAPI OpenMMDEVLDR(void);
VOID WINAPI CloseMMDEVLDR(void);

#ifdef __cplusplus
}
#endif

#endif // _VIDX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\co.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// Quartz wrapper for old video compressors - CO
//

#include <streams.h>
#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <windowsx.h>
#include <vfw.h>
#include "..\dec\msvidkey.h"

//#include <olectl.h>
//#include <olectlid.h>
#include "co.h"

#define A_NUMBER_BIGGER_THAN_THE_KEYFRAME_RATE 1000000

// setup data now done by the class manager unless building separate DLLS
#if 0

const AMOVIESETUP_MEDIATYPE
sudAVICoType =  { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudAVICoPins[] =  { { L"Input"             // strName
                     , FALSE                // bRendered
                     , FALSE                // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Output"            // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVICoType }      // lpTypes
                   , { L"Output"            // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVICoType } };   // lpTypes

const AMOVIESETUP_FILTER
sudAVICo  = { &CLSID_AVICo          // clsID
            , L"AVI Compressor"     // strName
            , MERIT_DO_NOT_USE      // dwMerit
            , 2                     // nPins
            , psudAVICoPins };      // lpPin

#endif


#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    {L"AVI Compressor", &CLSID_AVICo, CAVICo::CreateInstance, NULL, 0},
#ifdef WANT_DIALOG
    {L"AVI Compressor Property Page", &CLSID_ICMProperties, CICMProperties::CreateInstance, NULL, NULL}
#endif
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif

// --- CAVICo ----------------------------------------

CAVICo::CAVICo(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
    : CTransformFilter(pName, pUnk, CLSID_AVICo),
      CPersistStream(pUnk, phr),
      m_hic(NULL),
      m_lpBitsPrev(NULL),
      m_lpbiPrev(NULL),
      m_fStreaming(FALSE),
      m_fDialogUp(FALSE),
      m_fCacheHic(FALSE),
      m_fOfferSetFormatOnly(FALSE),
      m_fInICCompress(FALSE),
      m_lpState(NULL),
      m_cbState(0),
      m_fCompressorInitialized(FALSE),
      m_fDecompressorInitialized(FALSE)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the CO filter")));
    _fmemset(&m_compvars, 0, sizeof(m_compvars));

    m_compvars.cbSize = sizeof(m_compvars);
    m_compvars.dwFlags = ICMF_COMPVARS_VALID;
    m_compvars.lQ = ICQUALITY_DEFAULT;
    m_compvars.lKey = -1;
}

CAVICo::~CAVICo()
{
    if(m_fStreaming) {
        ReleaseStreamingResources();
    }

    if (m_hic) {
        ICClose(m_hic);
    }

    if (m_lpState)
        QzTaskMemFree(m_lpState);
    m_lpState = NULL;

    DbgLog((LOG_TRACE,1,TEXT("*Destroying the CO filter")));
}

STDMETHODIMP CAVICo::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    DbgLog((LOG_TRACE,9,TEXT("somebody's querying my interface")));
    if (riid == IID_IAMVfwCompressDialogs) {
        DbgLog((LOG_TRACE,5,TEXT("QI for IAMVfwCompressDialogs")));
	return GetInterface((IAMVfwCompressDialogs *)this, ppv);
#ifdef WANT_DIALOG
    } else if (riid == IID_ISpecifyPropertyPages) {
        DbgLog((LOG_TRACE,5,TEXT("QI for ISpecifyPropertyPages")));
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IICMOptions) {
        DbgLog((LOG_TRACE,5,TEXT("QI for IICMOptions")));
        return GetInterface((IICMOptions *) this, ppv);
#endif
    } else if (riid == IID_IPersistPropertyBag) {
        DbgLog((LOG_TRACE,3,TEXT("VfwCap::QI for IPersistPropertyBag")));
        return GetInterface((IPersistPropertyBag*)this, ppv);
    } else if(riid == IID_IPersistStream) {
        DbgLog((LOG_TRACE,3,TEXT("VfwCap::QI for IPersistStream")));
        return GetInterface((IPersistStream *) this, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


// this goes in the factory template table to create new instances
CUnknown * CAVICo::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CAVICo(TEXT("VFW compression filter"), pUnk, phr);
}


CBasePin * CAVICo::GetPin(int n)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,9,TEXT("CAVICo::GetPin")));

    // Create an input pin if necessary

    if (n == 0 && m_pInput == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"Input");         // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pInput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Or alternatively create an output pin

    if (n == 1 && m_pOutput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new CCoOutputPin(NAME("CO output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"Output");      // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pOutput == NULL) {
            delete m_pOutput;
            m_pOutput = NULL;
        }

// !!! TEST
#if 0
    WCHAR wachDesc[80];
    int cbDesc = 80;
    if (m_pOutput) {
        ((CCoOutputPin *)m_pOutput)->GetInfo(NULL, NULL, wachDesc, &cbDesc,
						NULL, NULL, NULL, NULL);
        DbgLog((LOG_TRACE,1,TEXT("Codec description: %ls"), wachDesc));
    }
#endif

    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    }
    return m_pOutput;
}

STDMETHODIMP CAVICo::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped)
    {
        return VFW_E_WRONG_STATE;
    }
    // If they don't give us a key, default to something (CINEPAK)
    if (pPropBag == NULL) {
	m_compvars.fccHandler = MKFOURCC('C','V','I','D');
	return NOERROR;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"FccHandler", &var,0);
    if(SUCCEEDED(hr))
    {
        char szFccHandler[5];
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1,
                            szFccHandler, sizeof(szFccHandler), 0, 0);
        SysFreeString(var.bstrVal);
        DbgLog((LOG_TRACE,2,TEXT("Co::Load: use %c%c%c%c"),
                szFccHandler[0], szFccHandler[1], szFccHandler[2], szFccHandler[3]));
        m_compvars.fccHandler = *(DWORD UNALIGNED *)szFccHandler;;
        if (m_pOutput && m_pOutput->IsConnected()) {
            DbgLog((LOG_TRACE,2,TEXT("Co::Load: reconnect output")));
            return ((CCoOutputPin *)m_pOutput)->Reconnect();
        }
        hr = S_OK;


    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }


    return hr;
}

STDMETHODIMP CAVICo::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CAVICo::InitNew()
{
    // fine. just call load
    return S_OK;
}

STDMETHODIMP CAVICo::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;
}

struct CoPersist
{
    DWORD dwSize;
    DWORD fccHandler;
};

HRESULT CAVICo::WriteToStream(IStream *pStream)
{
    CoPersist cp;
    cp.dwSize = sizeof(cp);
    cp.fccHandler = m_compvars.fccHandler;

    return pStream->Write(&cp, sizeof(cp), 0);
}

HRESULT CAVICo::ReadFromStream(IStream *pStream)
{
   if(m_compvars.fccHandler != 0)
   {
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   CoPersist cp;
   HRESULT hr = pStream->Read(&cp, sizeof(cp), 0);
   if(FAILED(hr))
       return hr;

   if(cp.dwSize != sizeof(cp))
       return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

   m_compvars.fccHandler = cp.fccHandler;

   return S_OK;
}

int CAVICo::SizeMax()
{
    return sizeof(CoPersist);
}

HRESULT CAVICo::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DWORD dwFlagsOut = 0L;
    DWORD ckid = 0L;
    BOOL  fKey;
    DWORD err;
    FOURCCMap fccOut;
    BOOL fFault = FALSE;

    DbgLog((LOG_TRACE,5,TEXT("*::Transform")));

    // codec not open ?
    if (m_hic == 0) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, no codec open")));
	return E_UNEXPECTED;
    }

    // we haven't started streaming yet?
    if (!m_fStreaming) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, not streaming")));
	return E_UNEXPECTED;
    }

    // make sure we have valid input and output pointers

    BYTE * pSrc;
    HRESULT hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting input sample data")));
	return hr;
    }

    BYTE * pDst;
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting output sample data")));
	return hr;
    }

    // !!! Could the source filter change our mtIn too? Yes!

    // !!! We may be told on the fly to start compressing to a different format
#if 0
    MediaType *pmtOut;
    pOut->GetType(&pmtOut);
    if (pmtOut != NULL && pmtOut->pbFormat != NULL) {
	#define rcSource (((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource)
	#define rcTarget (((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget)
        fccOut.SetFOURCC(&pmtOut->subtype);
	LONG lCompression = HEADER(pmtOut->pbFormat)->biCompression;
	LONG lBitCount = HEADER(pmtOut->pbFormat)->biBitCount;
	LONG lStride = (HEADER(pmtOut->pbFormat)->biWidth * lBitCount + 7) / 8;
	lStride = (lStride + 3) & ~3;
        DbgLog((LOG_TRACE,3,TEXT("*** Changing output type on the fly to")));
        DbgLog((LOG_TRACE,3,TEXT("*** FourCC: %lx Compression: %lx BitCount: %ld"),
		fccOut.GetFOURCC(), lCompression, lBitCount));
        DbgLog((LOG_TRACE,3,TEXT("*** biHeight: %ld rcDst: (%ld, %ld, %ld, %ld)"),
		HEADER(pmtOut->pbFormat)->biHeight,
		rcTarget.left, rcTarget.top, rcTarget.right, rcTarget.bottom));
        DbgLog((LOG_TRACE,3,TEXT("*** rcSrc: (%ld, %ld, %ld, %ld) Stride: %ld"),
		rcSource.left, rcSource.top, rcSource.right, rcSource.bottom,
		lStride));
	StopStreaming();
	m_pOutput->CurrentMediaType() = *pmtOut;
	DeleteMediaType(pmtOut);
	hr = StartStreaming();
	if (FAILED(hr)) {
	    return hr;
	}
    }
#endif

    // get the BITMAPINFOHEADER structure, and fix biSizeImage

    LPBITMAPINFOHEADER lpbiSrc = HEADER(m_pInput->CurrentMediaType().Format());
    LPBITMAPINFOHEADER lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());
    lpbiSrc->biSizeImage = pIn->GetActualDataLength();

    BOOL dwFlags = 0;

    fKey = (m_nKeyCount >= m_compvars.lKey);
    // if this is a discontinuity, using previously kept bits (by us or the
    // codec) to make a non-key would be ugly.  We must make a key
    if (pIn->IsDiscontinuity() == S_OK) {
	fKey = TRUE;
    }
    if (fKey) {
        DbgLog((LOG_TRACE,6,TEXT("I will ask for a keyframe")));
	dwFlags |= ICCOMPRESS_KEYFRAME;
    }

    // pretty please, compiler, don't optimize this away
    int cbSize = DIBSIZE(*lpbiSrc);
    __try {
	// cinepak will access one byte too many... occasionally this faults
	if (lpbiSrc->biBitCount == 24)
	    volatile int cb = *(pSrc + cbSize);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
	// OK, I guess I have to copy it into a bigger buffer to avoid this
        DbgLog((LOG_ERROR,0,TEXT("Compressor faulted!  Recovering...")));
	fFault = TRUE;
	BYTE *pOld = pSrc;
	pSrc = (BYTE *)QzTaskMemAlloc(cbSize + 1);
	if (pSrc == NULL)
	    return E_OUTOFMEMORY;
	CopyMemory(pSrc, pOld, cbSize);
    }

    DbgLog((LOG_TRACE,6,TEXT("Calling ICCompress on frame %ld"),
					m_lFrameCount));
    // StopStreaming may get called while we're inside here, blowing us up
    m_fInICCompress = TRUE;

    err =  ICCompress(
	        m_hic,
	        dwFlags,
	        lpbiDst,
	        pDst,
	        lpbiSrc,
	        pSrc,
		&ckid,
		&dwFlagsOut,
		m_lFrameCount,
		m_dwSizePerFrame,
		m_compvars.lQ,
		fKey ? NULL : m_lpbiPrev,
		fKey ? NULL : m_lpBitsPrev);
    if (fFault)
	QzTaskMemFree(pSrc);
    if (ICERR_OK != err) {
        DbgLog((LOG_ERROR,1,TEXT("Error in ICCompress")));
        m_fInICCompress = FALSE;
        return E_FAIL;
    }

    // was the compressed frame a keyframe?
    fKey = dwFlagsOut & AVIIF_KEYFRAME;
    pOut->SetSyncPoint(fKey);

    // If we made a key, reset when we need the next one.
    if (fKey)
	m_nKeyCount = 0;

    // Do we want periodic key frames? If not, never make one again.
    // (The first frame is always a keyframe).
    if (m_compvars.lKey)
	m_nKeyCount++;
    else
	m_nKeyCount = -1;

    // Count how many frames we compress
    m_lFrameCount++;

    // Decompress into previous frame
    if (m_lpBitsPrev) {
        if (ICERR_OK != ICDecompress(m_hic, 0, lpbiDst, pDst, m_lpbiPrev,
								m_lpBitsPrev)){
    	    m_fInICCompress = FALSE;
	    return E_FAIL;
	}
    }
    m_fInICCompress = FALSE;

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    // Even if we receive discontinuities, once we recompress it, it's like
    // it's not discontinuous anymore.  If we don't reset this, and we
    // connect to a renderer, we'll drop almost every frame needlessly in some
    // scenarios.
    pOut->SetDiscontinuity(FALSE);

    return S_OK;
}


// check if you can support mtIn
HRESULT CAVICo::CheckInputType(const CMediaType* pmtIn)
{
    FOURCCMap fccHandlerIn;
    HIC hic;

    DbgLog((LOG_TRACE,2,TEXT("*::CheckInputType")));

    if (pmtIn == NULL || pmtIn->Format() == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we only support MEDIATYPE_Video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    fccHandlerIn.SetFOURCC(pmtIn->Subtype());

    DbgLog((LOG_TRACE,3,TEXT("Checking fccType: %lx biCompression: %lx"),
		fccHandlerIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression));

    //
    //  Most VFW codecs don't like upsize-down (DIRECTDRAW) style bitmaps.  If the
    //  height is negative then reject it.
    //
    if (HEADER(pmtIn->Format())->biHeight < 0 &&
        HEADER(pmtIn->Format())->biCompression <= BI_BITFIELDS) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: Negative height")));
        return E_INVALIDARG;
    }

    // look for a compressor for this format
    if (HEADER(pmtIn->Format())->biCompression != BI_BITFIELDS &&
        HEADER(pmtIn->Format())->biCompression != BI_RGB &&
    	*pmtIn->Subtype() != MEDIASUBTYPE_YV12 &&
    	*pmtIn->Subtype() != MEDIASUBTYPE_YUY2 &&
    	*pmtIn->Subtype() != MEDIASUBTYPE_UYVY &&
    	*pmtIn->Subtype() != MEDIASUBTYPE_YVYU &&
        *pmtIn->Subtype() != MEDIASUBTYPE_YVU9 &&

        // wm mpeg4 may support these as well
        HEADER(pmtIn->Format())->biCompression != MAKEFOURCC('I', '4', '2', '0') &&
        HEADER(pmtIn->Format())->biCompression != MAKEFOURCC('I', 'Y', 'U', 'V') ) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: This is compressed already!")));
	return E_INVALIDARG;
    }

    // !!! I'm only going to say I accept an input type if the default (current)
    // compressor can handle it.  I'm not going to ask every compressor.  This
    // way an app can make a choose compressor box and only show those
    // compressors that support a given input format, by making a CO filter
    // with each compressor as a default and asking them all

    // We might have a hic cached if we connected before and then broken
    if (!m_hic) {
        DbgLog((LOG_TRACE,4,TEXT("opening a compressor")));
        hic = ICOpen(ICTYPE_VIDEO, m_compvars.fccHandler, ICMODE_COMPRESS);
        if (!hic) {
            DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a compressor")));
	    return E_FAIL;
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("using a cached compressor")));
	hic = m_hic;
    }

    if (ICCompressQuery(hic, HEADER(pmtIn->Format()), NULL)) {
        DbgLog((LOG_ERROR,1,TEXT("Error: Compressor rejected format")));
	if (hic != m_hic)
	    ICClose(hic);
	return E_FAIL;
    }

    // remember this hic to save time if asked again.
    if (m_hic == NULL) {
        DbgLog((LOG_TRACE,4,TEXT("caching this compressor")));
	m_hic = hic;
    }

    return NOERROR;
}


// check if you can support the transform from this input to this output

HRESULT CAVICo::CheckTransform(const CMediaType* pmtIn,
                               const CMediaType* pmtOut)
{
    HIC hic = NULL;
    FOURCCMap fccIn;

    DbgLog((LOG_TRACE,2,TEXT("*::CheckTransform")));

    if (pmtIn == NULL || pmtOut == NULL || pmtIn->Format() == NULL ||
					pmtOut->Format() == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type/format is NULL")));
	return E_POINTER;
    }

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: types don't match")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // and we only accept video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type not VIDEO")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtOut->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: output format type not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: input format type not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }

#ifdef PICKY_PICKY // !!!
    if (((VIDEOINFOHEADER *)(pmtOut->Format()))->AvgTimePerFrame &&
    		((VIDEOINFOHEADER *)(pmtOut->Format()))->AvgTimePerFrame !=
    		((VIDEOINFOHEADER *)(pmtIn->Format()))->AvgTimePerFrame) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't frame rate convert")));
        return VFW_E_INVALIDMEDIATYPE;
    }
#endif

    // check it really is a FOURCC
    fccIn.SetFOURCC(pmtIn->Subtype());

    ASSERT(pmtOut->Format());

#define rcS1 ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget

    DbgLog((LOG_TRACE,3,TEXT("Check fccIn: %lx biCompIn: %lx bitDepthIn: %d"),
		fccIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression,
		HEADER(pmtIn->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthIn: %ld biHeightIn: %ld"),
		HEADER(pmtIn->Format())->biWidth,
		HEADER(pmtIn->Format())->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("biCompOut: %lx bitDepthOut: %d"),
		HEADER(pmtOut->Format())->biCompression,
		HEADER(pmtOut->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthOut: %ld biHeightOut: %ld"),
		HEADER(pmtOut->Format())->biWidth,
		HEADER(pmtOut->Format())->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom));
    DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));

    if (!IsRectEmpty(&rcT1) && (rcT1.left != 0 || rcT1.top != 0 ||
			HEADER(pmtOut->Format())->biWidth != rcT1.right ||
			HEADER(pmtOut->Format())->biHeight != rcT1.bottom)) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't use funky rcTarget")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    if (!IsRectEmpty(&rcS1) && (rcS1.left != 0 || rcS1.top != 0 ||
			HEADER(pmtIn->Format())->biWidth != rcS1.right ||
			HEADER(pmtIn->Format())->biHeight != rcS1.bottom)) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't use funky rcSource")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // find a codec for this transform

    DbgLog((LOG_TRACE,3,TEXT("Trying to find a compressor for this")));
    // If we've opened a compressor before, quickly try that one to see if it
    // will do the job (saves lots of time) before trying the whole universe of
    // compressors.
    if (!m_hic || ICCompressQuery(m_hic, HEADER(pmtIn->Format()),
				HEADER(pmtOut->Format())) != ICERR_OK) {
        hic = ICLocate(ICTYPE_VIDEO, NULL, HEADER(pmtIn->Format()),
				HEADER(pmtOut->Format()), ICMODE_COMPRESS);
        if (!hic) {
            DbgLog((LOG_ERROR,1,TEXT("all compressors reject this transform")));
	    return VFW_E_INVALIDMEDIATYPE;
        } else {

    	    DbgLog((LOG_TRACE,3,TEXT("Found somebody to accept it")));
	    // If we're not connected yet, remember this compressor so we'll
	    // use it once we are connected.  If we're already connected, then
	    // don't remember it, or we'll change the behaviour of our filter.
	    // After all, this was only a query.  (Although somebody may want
	    // us to remember it anyway)
	    if (m_fCacheHic || !m_pOutput->IsConnected()) {
	        if (m_hic)
		    ICClose(m_hic);
	        m_hic = hic;
	    } else {
		ICClose(hic);
	    }
	}
    } else {
    	DbgLog((LOG_TRACE,3,TEXT("The cached compressor accepts it")));
    }

    return NOERROR;
}


// overriden to know when the media type is actually set

HRESULT CAVICo::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{

    // Set the OUTPUT type.  Looks like we're all connected!
    if (direction == PINDIR_OUTPUT) {

	// Please call me if this goes off. - DannyMi
	ASSERT(!m_fStreaming);

        DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (output)")));
        DbgLog((LOG_TRACE,2,TEXT("Output type is: biComp=%lx biBitCount=%d")
		,HEADER(pmt->Format())->biCompression
		,HEADER(pmt->Format())->biBitCount));

	// we may not be using the compressor from m_compvars, if somebody
	// did a ConnectWithMediaType on us.  We need to get info about this
	// media type and m_hic and fill in m_compvars so that from now on
	// we use the right info.
        ASSERT(m_hic);
        m_compvars.cbSize = sizeof(m_compvars);
        m_compvars.dwFlags = ICMF_COMPVARS_VALID;
        ICINFO icinfo;
	if (ICGetInfo(m_hic, &icinfo, sizeof(ICINFO)) > 0) {
	    if (m_compvars.fccHandler != icinfo.fccHandler) {
		// different compressor? don't use old state!
		m_compvars.lpState = NULL;
		m_compvars.cbState = 0;
	    }
            m_compvars.fccHandler = icinfo.fccHandler;
            DbgLog((LOG_TRACE,2,TEXT("New fccHandler = %08x"),
					icinfo.fccHandler));
	} else {
	    m_compvars.lpState = NULL;
	    m_compvars.cbState = 0;
	}
        m_compvars.lDataRate = ((VIDEOINFOHEADER *)pmt->Format())->dwBitRate /
								8192;
	// We will leave Quality and Keyframe settings as is

	// !!! If we connect 8 bit on our input and then try to connect
	// our output with a type that needs 24 bit on our input we don't
	// reconnect the input! We will FAIL!  We need to do like ACMWRAP
	// and override the output pin's CheckMediaType to accept something
	// if the input can be reconnected to allow it, and we need to do
	// that reconnect here.

	return NOERROR;
    }

    ASSERT(direction == PINDIR_INPUT);

    // Please call me if this goes off. - DannyMi
    ASSERT(!m_fStreaming);

    DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (input)")));
    DbgLog((LOG_TRACE,2,TEXT("Input type is: biComp=%lx biBitCount=%d"),
		HEADER(m_pInput->CurrentMediaType().Format())->biCompression,
		HEADER(m_pInput->CurrentMediaType().Format())->biBitCount));

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
	// This might fail!
	// make sure the output sees what's changed
	return ((CCoOutputPin *)m_pOutput)->Reconnect();
    }

    return NOERROR;
}


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.

HRESULT CAVICo::GetMediaType(int iPosition,CMediaType *pmt)
{
    LARGE_INTEGER li;
    CMediaType cmt;
    FOURCCMap fccHandler;

    DbgLog((LOG_TRACE,2,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Media Type is NULL, no can do")));
	return E_POINTER;
    }

    // Output choices depend on the input connected
    // This is pointless!  We'll never get here if not connected
    if (!m_pInput->CurrentMediaType().IsValid()) {
        DbgLog((LOG_TRACE,2,TEXT("No input type set yet, no can do")));
	return VFW_E_NOT_CONNECTED;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Give our compressed format
    if (iPosition == 0) {

	// somebody told us what format to use.  We should only offer that one
 	if (m_fOfferSetFormatOnly) {
            DbgLog((LOG_TRACE,2,TEXT("Giving Media Type from ::SetFormat")));
            *pmt = m_cmt;
	    return NOERROR;
	}

	// We offer one compressed type - the same as the input type, but
 	// with the compressor chosen in the properties's default output format
        DbgLog((LOG_TRACE,2,TEXT("Giving Media Type 0: default codec out")));

        HIC hic = ICOpen(ICTYPE_VIDEO, m_compvars.fccHandler, ICMODE_COMPRESS);

	if (hic == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("UH OH! Can't open compressor!")));
	    return E_FAIL;	// uh oh, we're not connecting to anybody today
	}

	cmt = m_pInput->CurrentMediaType();

        //  Don't output negative height for YUV - YUV is always
        //  the same way up (upside down).
        if (HEADER(cmt.pbFormat)->biHeight < 0 &&
            HEADER(cmt.pbFormat)->biCompression > BI_BITFIELDS) {
            HEADER(cmt.pbFormat)->biHeight = -HEADER(cmt.pbFormat)->biHeight;
        }

        ULONG cb = (ULONG)ICCompressGetFormatSize(hic,
				HEADER(m_pInput->CurrentMediaType().Format()));
        if ((LONG)cb < (LONG)sizeof(BITMAPINFOHEADER)) {
            DbgLog((LOG_ERROR,1,TEXT("Error from ICCompressGetFormatSize")));
	    ICClose(hic);
     	    return E_FAIL;
        }

        // allocate a VIDEOINFOHEADER for the default output format
        cb += SIZE_PREHEADER;
        VIDEOINFOHEADER *pf = (VIDEOINFOHEADER *) cmt.AllocFormatBuffer(cb);
        if (pf == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Error allocating format buffer")));
	    ICClose(hic);
	    return E_OUTOFMEMORY;
        }

        ZeroMemory(pf, sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER);
        DWORD_PTR dwerr = ICCompressGetFormat(hic,
				HEADER(m_pInput->CurrentMediaType().Format()),
	    			HEADER(cmt.Format()));
        if (ICERR_OK != dwerr) {
            DbgLog((LOG_ERROR,1,TEXT("Error from ICCompressGetFormat")));
	    ICClose(hic);
	    return E_FAIL;
        }

	// use the frame rate of the incoming video
        pf->AvgTimePerFrame = ((VIDEOINFOHEADER *)
		m_pInput->CurrentMediaType().pbFormat)->AvgTimePerFrame;
        li.QuadPart = pf->AvgTimePerFrame;

	// use the data rate we've been told to make.  If we aren't going to
	// make the compressor use a specific rate, find out what it's going
	// to do anyway.
	if (m_compvars.lDataRate)
            pf->dwBitRate = m_compvars.lDataRate * 8192;
	else if (li.LowPart)
            pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000,
								li.LowPart);
        pf->dwBitErrorRate = 0L;

        DbgLog((LOG_TRACE,3,TEXT("Returning biComp: %lx biBitCount: %d"),
		    HEADER(cmt.Format())->biCompression,
		    HEADER(cmt.Format())->biBitCount));

        const GUID SubTypeGUID = GetBitmapSubtype(HEADER(cmt.Format()));
        cmt.SetSubtype(&SubTypeGUID);
        cmt.SetTemporalCompression(m_compvars.lKey != 1);
        cmt.SetVariableSize();
        *pmt = cmt;

	ICClose(hic);

        return NOERROR;

    } else {
	return VFW_S_NO_MORE_ITEMS;
    }
}


// called from CBaseOutputPin to prepare the allocator's count
// of buffers and sizes
HRESULT CAVICo::DecideBufferSize(IMemAllocator * pAllocator,
                                 ALLOCATOR_PROPERTIES *pProperties)
{
    // David assures me this won't be called with NULL output mt.
    ASSERT(m_pOutput->CurrentMediaType().IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);
    ASSERT(m_hic);

    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.

    pProperties->cBuffers = 1;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();

    // Variable sized?  Ask the compressor.
    if (pProperties->cbBuffer == 0) {
	pProperties->cbBuffer = (DWORD)ICCompressGetSize(m_hic,
				HEADER(m_pInput->CurrentMediaType().Format()),
				HEADER(m_pOutput->CurrentMediaType().Format()));
        //DbgLog((LOG_TRACE,1,TEXT("*** Compressor says %d"), pProperties->cbBuffer));
	// compressor can't tell us.  Assume decompressed size is max compressed
	// size. (Winnov PYRAMID reports a bogus negative number)
        if (pProperties->cbBuffer <= 0) {
	    pProperties->cbBuffer =
		GetBitmapSize(HEADER(m_pInput->CurrentMediaType().Format()));
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("*::DecideBufferSize - size is %ld"), pProperties->cbBuffer));

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    // we must get exactly one buffer, since the temporal compression assumes
    // that the previous decompressed frame is already present in the output
    // buffer. The alternative is to copy the bits from a saved location before
    // doing the decompression, but that is not nice.
    if (Actual.cBuffers != 1) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - need exactly 1 buffer")));
	return E_INVALIDARG;
    }

    return S_OK;
}

#include "..\..\..\filters\asf\wmsdk\inc\wmsdk.h"

HRESULT CAVICo::StartStreaming()
{
    DbgLog((LOG_TRACE,1,TEXT("*::StartStreaming")));

    // We have a driver dialog up that is about to change the capture settings.
    // Now is NOT a good time to start streaming.
    if (m_fDialogUp) {
        DbgLog((LOG_TRACE,1,TEXT("*::StartStreaming - Dialog up. SORRY!")));
	return E_UNEXPECTED;
    }

    if (!m_fStreaming) {
        if (HEADER(m_pOutput->CurrentMediaType().Format())->biCompression == 0x3334504d && m_pGraph) { // !!! MP43
            IObjectWithSite *pSite;
            HRESULT hrKey = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
            if (SUCCEEDED(hrKey)) {
                IServiceProvider *pSP;
                hrKey = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
                pSite->Release();

                if (SUCCEEDED(hrKey)) {
                    IUnknown *pKey;
                    hrKey = pSP->QueryService(__uuidof(IWMReader), IID_IUnknown, (void **) &pKey);
                    pSP->Release();

                    if (SUCCEEDED(hrKey)) {
                        // !!! verify key?

                        pKey->Release();
                        DbgLog((LOG_TRACE, 1, "CO: Unlocking MP43 codec"));
                        //
                        // Use GetState() to set the key into a particular
                        // instance of the codec.  While it looks odd
                        // to be using ICGetState to set values, it is correct!
                        //

                        DWORD dwSize = ICGetStateSize( m_hic );

                        if( dwSize <= 256 )
                        {
                            CHAR rgcBuf[256];
                            MSVIDUNLOCKKEY *pks;

                            pks = (MSVIDUNLOCKKEY *)rgcBuf;

                            pks->dwVersion = MSMP43KEY_VERSION;
                            pks->guidKey   = __uuidof( MSMP43KEY_V1 );

                            ICGetState( m_hic, rgcBuf, dwSize );
                        } else {
                            ASSERT(0);
                        }
                    }
                }
            }
        }

	// First prepare the compressor with the state info we've been told
	// to give it.
	if (m_lpState)
	    ICSetState(m_hic, m_lpState, m_cbState);

	// Start Streaming Compression
	ICINFO icinfo;
	DWORD_PTR err = ICCompressBegin(m_hic,
				HEADER(m_pInput->CurrentMediaType().Format()),
		    		HEADER(m_pOutput->CurrentMediaType().Format()));
	if (ICERR_OK == err) {
            m_fCompressorInitialized = TRUE;

	    // Reset streaming frame # count
	    m_lFrameCount = 0;

	    // Use defaults
	    if (m_compvars.lKey < 0)
		m_compvars.lKey = ICGetDefaultKeyFrameRate(m_hic);
	    if (m_compvars.lQ == ICQUALITY_DEFAULT)
		m_compvars.lQ = ICGetDefaultQuality(m_hic);

	    // Make sure first frame we make will be a keyframe, no matter how
	    // often key frames might be requested.
	    m_nKeyCount = A_NUMBER_BIGGER_THAN_THE_KEYFRAME_RATE;

 	    // Figure out how big each frame needs to be based on the data rate
	    // and fps of the movie.  Don't overflow!
    	    LONGLONG time = ((VIDEOINFOHEADER *)
			(m_pInput->CurrentMediaType().Format()))->AvgTimePerFrame;
    	    DWORD fps = time ? DWORD(UNITS * (LONGLONG)1000 / time) : 1000;
    	    m_dwSizePerFrame = DWORD(LONGLONG(m_compvars.lDataRate) *
				1024 * 1000 / fps);
    	    DbgLog((LOG_TRACE,2,TEXT("Making each frame %d bytes big"),
				m_dwSizePerFrame));

	    // We'll need a previous buffer for compression if not every
	    // frame is a keyframe, and the compressor does temporal
	    // compression and needs such a buffer
	    if (ICGetInfo(m_hic, &icinfo, sizeof(icinfo))) {

		if (!(icinfo.dwFlags & VIDCF_CRUNCH))
		    m_compvars.lDataRate = 0;	// we can't crunch

	        // Now prepare the decompressor for the previous bits
	        if (m_compvars.lKey != 1 &&
				(icinfo.dwFlags & VIDCF_TEMPORAL) &&
				!(icinfo.dwFlags & VIDCF_FASTTEMPORALC)) {

		    // allocate a previous header of the proper size
		    DWORD dw = ICDecompressGetFormatSize(m_hic,
			HEADER(m_pOutput->CurrentMediaType().Format()));
		    if (dw <= 0) {
                        ReleaseStreamingResources();
                        DbgLog((LOG_ERROR,1,TEXT(
				"Error %d from ICDecompressGetFormatSize"),
				 dw));
		        return E_FAIL;
		    }
		    m_lpbiPrev = (LPBITMAPINFOHEADER)GlobalAllocPtr(
							GMEM_FIXED, dw);
		    if (!m_lpbiPrev) {
                        ReleaseStreamingResources();

                        DbgLog((LOG_ERROR,1,TEXT("Error allocating previous bih")));
		        return E_OUTOFMEMORY;
		    }

		    // Ask the compressor what format to decompress back to...
		    // it's not necessarily the same as what it compressed from-
		    // the size may change
		    dw = ICDecompressGetFormat(m_hic,
			HEADER(m_pOutput->CurrentMediaType().Format()),
			m_lpbiPrev);
		    if ((LONG) dw < 0) {
                        ReleaseStreamingResources();

                        DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompressGetFormat")));
		        return E_FAIL;
		    }

		    if (m_lpbiPrev->biSizeImage == 0)
	    	        m_lpbiPrev->biSizeImage = DIBSIZE(*m_lpbiPrev);

		    // allocate enough space for a decompressed image
		    m_lpBitsPrev = GlobalAllocPtr(GMEM_FIXED,
						m_lpbiPrev->biSizeImage);
		    if (m_lpBitsPrev == NULL) {
                        ReleaseStreamingResources();

                        DbgLog((LOG_ERROR,1,TEXT("Error reallocating BitsPrev")));
		        return E_OUTOFMEMORY;
		    }

		    if (ICERR_OK != ICDecompressBegin(m_hic,
			HEADER(m_pOutput->CurrentMediaType().Format()),
			m_lpbiPrev)) {

                        ReleaseStreamingResources();

                        DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompressBegin")));
		        return E_FAIL;
		    }

                    m_fDecompressorInitialized = TRUE;
		}
	    } else {
                ReleaseStreamingResources();

                DbgLog((LOG_ERROR,1,TEXT("Error in ICGetInfo")));
		return E_FAIL;
	    }

	    // OK, everything worked.
	    m_fStreaming = TRUE;

	} else {
            DbgLog((LOG_ERROR,1,TEXT("Error in ICCompressBegin")));
	    return E_FAIL;
	}
    }

    return NOERROR;
}

HRESULT CAVICo::StopStreaming()
{
    DbgLog((LOG_TRACE,1,TEXT("*::StopStreaming")));

    if (m_fStreaming) {
	ASSERT(m_hic);

	if (m_fInICCompress)
    	    DbgLog((LOG_TRACE,1,TEXT("***** ACK! Still compressing!")));
	while (m_fInICCompress);	// !!!

        ReleaseStreamingResources();

        m_fStreaming = FALSE;
    }
    return NOERROR;
}

void CAVICo::ReleaseStreamingResources()
{
    // NULL is not a valid HIC handle value.  m_hic should never be NULL
    // when this function is called.  m_hic should never be NULL because
    //
    //      - ICCompressBegin() fails if m_hic is NULL.  ReleaseStreamingResources() is
    //        not called if the ICCompressBegin() call in StartStreaming() fails.
    //      
    //      - m_hic's value cannot be changed while the filter is 
    //        streaming.
    // 
    ASSERT(NULL != m_hic);

    if (m_fCompressorInitialized) {
        // ICCompressEnd() should never fail because m_hic always contains a
        // valid handle if the ICCompressBegin() call in StartStreaming()
	// succeeded.
        EXECUTE_ASSERT(ICERR_OK == ICCompressEnd(m_hic));
        m_fCompressorInitialized = FALSE;
    }

    if (m_fDecompressorInitialized) {
    
        // ICDecompressEnd() should never fail because m_hic always contains a
        // valid handle if the ICDecompressBegin() call in StartStreaming()
	// succeeded.
        EXECUTE_ASSERT(ICERR_OK == ICDecompressEnd(m_hic));
        m_fDecompressorInitialized = FALSE;
    }


    if (NULL != m_lpBitsPrev) {
        GlobalFreePtr(m_lpBitsPrev);
        m_lpBitsPrev = NULL;
    }

    if (NULL != m_lpbiPrev) {
        GlobalFreePtr(m_lpbiPrev);
        m_lpbiPrev = NULL;
    }
}


HRESULT CAVICo::BeginFlush()
{
    // Make sure first frame we make next will be a keyframe, because the
    // saved data of what the previous frame looks like is no longer valid
    // Make a key in case the codec is remembering old bits... this is the
    // only way I know to flush it for sure, is to tell it to make a key
    m_nKeyCount = A_NUMBER_BIGGER_THAN_THE_KEYFRAME_RATE;
    return CTransformFilter::BeginFlush();
}


#ifdef WANT_DIALOG

/* Return the CLSIDs for the property page we support */

STDMETHODIMP CAVICo::GetPages(CAUUID *pPages)
{
    DbgLog((LOG_TRACE,2,TEXT("ISpecifyPropertyPages::GetPages")));

    pPages->cElems = 1;
    pPages->pElems = (GUID *)QzTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    pPages->pElems[0] = CLSID_ICMProperties;
    return NOERROR;
}

/* Return the current compression options we're using */

STDMETHODIMP CAVICo::ICMGetOptions(PCOMPVARS pcompvars)
{
    if (pcompvars == NULL)
	return E_POINTER;

    // Did I miss something?
    pcompvars->cbSize = m_compvars.cbSize;
    pcompvars->dwFlags = m_compvars.dwFlags;
    pcompvars->fccHandler = m_compvars.fccHandler;
    pcompvars->lQ = m_compvars.lQ;
    pcompvars->lpState = m_compvars.lpState;
    pcompvars->cbState = m_compvars.cbState;
    pcompvars->lKey = m_compvars.lKey;
    pcompvars->lDataRate = m_compvars.lDataRate;

    return NOERROR;
}


/* Set the current compression options */

STDMETHODIMP CAVICo::ICMSetOptions(PCOMPVARS pcompvars)
{
    // not while streaming you don't!
    CAutoLock cLock(&m_csFilter);
    if (m_fStreaming)
	return E_UNEXPECTED;

    m_compvars.cbSize = pcompvars->cbSize;
    m_compvars.dwFlags = pcompvars->dwFlags;
    m_compvars.fccHandler = pcompvars->fccHandler;
    m_compvars.lQ = pcompvars->lQ;
    m_compvars.lpState = pcompvars->lpState;
    m_compvars.cbState = pcompvars->cbState;
    m_compvars.lKey = pcompvars->lKey;
    m_compvars.lDataRate = pcompvars->lDataRate;

    // The compression type changed, so we have to reconnect.
    // This might fail!
    // !!! Who cares, this is never called
    ((CCoOutputPin *)m_pOutput)->Reconnect();

    // Don't reconnect the output if the output is connected but the input
    // isn't, because it will happen as soon as the input is connected,
    // (if necessary)
    return NOERROR;
}


/* Bring up the ICCompressorChoose dialog */

STDMETHODIMP CAVICo::ICMChooseDialog(HWND hwnd)
{
    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    m_csFilter.Lock();
    if (m_fStreaming) {
        DbgLog((LOG_TRACE,1,TEXT("ICMChooseDialog - no dlg, we're streaming")));
        m_csFilter.Unlock();
	return E_UNEXPECTED;
    }
    m_fDialogUp = TRUE;
    m_csFilter.Unlock();

    DWORD dwFlags = ICMF_CHOOSE_DATARATE | ICMF_CHOOSE_KEYFRAME;
    BOOL  f;

    DbgLog((LOG_TRACE,1,TEXT("ICMChooseDialog - bringing up the dialog")));

    // Only ask for compressors that can handle the input format we have
    f = ICCompressorChoose(hwnd, dwFlags,
		m_pInput->CurrentMediaType().IsValid() ?
		HEADER(m_pInput->CurrentMediaType().Format()) : NULL,
		NULL, &m_compvars, NULL);

    if (f) {
	// The compression type changed, so we have to reconnect.
	// This might fail!
	// !!! Do I care about this dialog?
	((CCoOutputPin *)m_pOutput)->Reconnect();

	// Don't reconnect the output if the output is connected but the input
	// isn't, because it will happen as soon as the input is connected,
	// (if necessary)
    }

    m_fDialogUp = FALSE;
    return (f ? S_OK : S_FALSE);
}

#endif 	// #ifdef WANT_DIALOG


//======================================================================

//IAMVfwCompressDialogs stuff

STDMETHODIMP CAVICo::ShowDialog(int iDialog, HWND hwnd)
{
    BOOL fClose = FALSE;
    HIC  hic;
    DWORD dw;

    // !!! necessary?
    if (hwnd == NULL)
	hwnd = GetDesktopWindow();

    if (iDialog != VfwCompressDialog_Config &&
				iDialog != VfwCompressDialog_About &&
				iDialog != VfwCompressDialog_QueryConfig &&
				iDialog != VfwCompressDialog_QueryAbout)
	return E_INVALIDARG;

	
    // If the compressor is open already, great.
    if (m_hic) {
	hic = m_hic;
    } else {
        hic = ICOpen(ICTYPE_VIDEO, m_compvars.fccHandler, ICMODE_COMPRESS);
        if (hic == NULL) {
	    return E_FAIL;
        }
	fClose = TRUE;
    }

    // Before we bring the dialog up, make sure we're not streaming, or about to
    // Then don't allow us to stream any more while the dialog is up (we can't
    // very well keep the critsect for a day and a half).
    if (iDialog == VfwCompressDialog_Config ||
				iDialog != VfwCompressDialog_About) {
        m_csFilter.Lock();
        if (m_fStreaming) {
            m_csFilter.Unlock();
	    if (fClose)
	        ICClose(hic);
	    return VFW_E_NOT_STOPPED;
        }
        m_fDialogUp = TRUE;
        m_csFilter.Unlock();
    }

    // bring up the configure dialog?  And after we do, remember how it was
    // configured because it will do no good to close the compressor and
    // lose this information! We'll use it from now on.
    if (iDialog == VfwCompressDialog_Config) {
	dw = (DWORD)ICConfigure(hic, hwnd);
        // To make sure two people don't touch m_lpState - DON'T HOLD THIS
	// WHILE THE DIALOG IS UP!
        CAutoLock cObjectLock(&m_csFilter);
	if (m_lpState)
	    QzTaskMemFree(m_lpState);
	m_lpState = NULL;
	m_cbState = (DWORD)ICGetStateSize(hic);
	if (m_cbState > 0)
	    m_lpState = (LPBYTE)QzTaskMemAlloc(m_cbState);
	if (m_lpState)
	    ICGetState(hic, m_lpState, m_cbState);

    // bring up the about box?
    } else if (iDialog == VfwCompressDialog_About) {
	dw = (DWORD)ICAbout(hic, hwnd);
    } else if (iDialog == VfwCompressDialog_QueryConfig) {
	if (ICQueryConfigure(hic))
	    dw = S_OK;
 	else
	    dw = S_FALSE;
    } else if (iDialog == VfwCompressDialog_QueryAbout) {
	if (ICQueryAbout(hic))
	    dw = S_OK;
 	else
	    dw = S_FALSE;
    }

    m_fDialogUp = FALSE;
    if (fClose)
	ICClose(hic);

    return dw;
}


// so the outside world get get at ICGetState
//
STDMETHODIMP CAVICo::GetState(LPVOID lpState, int *pcbState)
{
    if (pcbState == NULL)
	return E_POINTER;

    // they want to know the size of the state info
    if (lpState == NULL) {
	HIC hic;
	if (m_hic == NULL) {
            hic = ICOpen(ICTYPE_VIDEO, m_compvars.fccHandler, ICMODE_COMPRESS);
            if (hic == NULL)
	        return E_FAIL;
	    *pcbState = (DWORD)ICGetStateSize(hic);
	    ICClose(hic);
	} else {
	    *pcbState = (DWORD)ICGetStateSize(m_hic);
	}
	return NOERROR;
    }

    if (*pcbState <= 0)
	return E_INVALIDARG;

    if (m_lpState == NULL)
	return E_UNEXPECTED;	// !!! it would be the default

    CopyMemory(lpState, m_lpState, m_cbState);
    return NOERROR;
}


// so the outside world get get at ICSetState
//
STDMETHODIMP CAVICo::SetState(LPVOID lpState, int cbState)
{
    // To make sure two people don't touch m_lpState
    CAutoLock cObjectLock(&m_csFilter);

    if (lpState == NULL)
	return E_POINTER;

    if (cbState == 0)
	return E_INVALIDARG;

    if (m_lpState)
	QzTaskMemFree(m_lpState);
    m_lpState = NULL;
    m_cbState = cbState;
    m_lpState = (LPBYTE)QzTaskMemAlloc(m_cbState);
    if (m_lpState == NULL)
	return E_OUTOFMEMORY;
    CopyMemory(m_lpState, lpState, cbState);

    // !!! I assume it will work, without calling ICSetState yet
    return NOERROR;
}


STDMETHODIMP CAVICo::SendDriverMessage(int uMsg, long dw1, long dw2)
{
    HIC  hic;
    BOOL fClose = FALSE;

    // This could do anything!  Bring up a dialog, who knows.
    // Don't take any crit sect or do any kind of protection.
    // They're on their own

    // If the compressor is open already, great.
    if (m_hic) {
	hic = m_hic;
    } else {
        hic = ICOpen(ICTYPE_VIDEO, m_compvars.fccHandler, ICMODE_COMPRESS);
        if (hic == NULL) {
	    return E_FAIL;
        }
	fClose = TRUE;
    }

    DWORD_PTR dw = ICSendMessage(hic, uMsg, dw1, dw2);

    if (fClose)
	ICClose(hic);

    #ifdef _WIN64
    #error This code may not work on Win64 because the ICM_DRAW_GET_PALETTE message returns a handle and SendDriverMessage() truncates the handle to a 32 bit value.
    #endif // _WIN64

    return (HRESULT)dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\capture\vc50\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video drivers           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		3

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR  dwCallback;
       DWORD_PTR  dwCallbackInst;
       DWORD  dwFlags;
       HVIDEO  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\co.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

//
// Prototype NDM wrapper for old video compressors
//

extern const AMOVIESETUP_FILTER sudAVICo;

#include "property.h"

class CAVICo : 
#ifdef WANT_DIALOG
	       public ISpecifyPropertyPages, public IICMOptions,
#endif
 	       public CTransformFilter, public IAMVfwCompressDialogs,
               public IPersistPropertyBag, public CPersistStream
{

public:

    CAVICo(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVICo();

    DECLARE_IUNKNOWN

    // IAMVfwCompressDialogs stuff
    STDMETHODIMP ShowDialog(int iDialog, HWND hwnd);
    STDMETHODIMP GetState(LPVOID lpState, int *pcbState);
    STDMETHODIMP SetState(LPVOID lpState, int cbState);
    STDMETHODIMP SendDriverMessage(int uMsg, long dw1, long dw2);

#ifdef WANT_DIALOG
    STDMETHODIMP GetPages(CAUUID *pPages);
#endif

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(
                const CMediaType* mtIn,
                const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts
    // and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();
    HRESULT BeginFlush();

    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Overridden to make a CCoOutputPin
    CBasePin * GetPin(int n);

    // IPersistPropertyBag methods
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);
    STDMETHODIMP InitNew();

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();
    

private:
    void ReleaseStreamingResources();

    HIC m_hic;	// current codec

    // force CheckTransform to cache any hic it opens... we'll need it
    BOOL m_fCacheHic;

    // the fourCC used to open m_hic
    //FOURCC m_FourCCIn;

    // are we inside an ICCompress call?
    BOOL m_fInICCompress;

    // is there a dialog box up that should prevent start streaming?
    BOOL m_fDialogUp;

    // have we called ICDecompressBegin ?
    BOOL m_fStreaming;

    // how long since last keyframe
    int m_nKeyCount;

    // the frame number we're compressing
    LONG m_lFrameCount;

    // the previous decompressed frame for temporal compressors
    LPVOID m_lpBitsPrev;

    // the format it decompresses back to
    LPBITMAPINFOHEADER m_lpbiPrev;

    // the compression options being used
    COMPVARS m_compvars;

    // how big to make each frame, based on data rate and fps
    DWORD m_dwSizePerFrame;

    // Somebody called ::SetFormat and wants this media type used
    BOOL m_fOfferSetFormatOnly;
    CMediaType m_cmt;

    // send this to the codec via ICSetState when we open it
    LPBYTE m_lpState;
    int    m_cbState;

    // TRUE if ICCompressBegin() has been called and 
    // ICCompressEnd() has not been called.  Otherwise
    // FALSE.
    BOOL m_fCompressorInitialized;

    // TRUE if ICDecompressBegin() has been called and 
    // ICDecompressEnd() has not been called.  Otherwise
    // FALSE.
    BOOL m_fDecompressorInitialized;

public:

#ifdef WANT_DIALOG
    // Implement the IICMOptions interface
    STDMETHODIMP ICMGetOptions(THIS_ PCOMPVARS pcompvars);
    STDMETHODIMP ICMSetOptions(THIS_ PCOMPVARS pcompvars);
    STDMETHODIMP ICMChooseDialog(THIS_ HWND hwnd);
#endif

    friend class CCoOutputPin;
};

class CCoOutputPin : public CTransformOutputPin, public IAMStreamConfig,
		   public IAMVideoCompression
{

public:

    CCoOutputPin(
        TCHAR *pObjectName,
        CAVICo *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CCoOutputPin();

    DECLARE_IUNKNOWN

    // override to expose IAMStreamConfig, etc.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pVSCC);

    /* IAMVideoCompression methods */
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate);
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate);
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality);
    STDMETHODIMP get_Quality(double FAR* pQuality);
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize);
    STDMETHODIMP OverrideKeyFrame(long FrameNumber);
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size);
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);
 
    HRESULT Reconnect();

private:

    /*  Controlling filter */
    CAVICo *m_pFilter;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\property.h ===
#ifdef WANT_DIALOG

// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
// Implements an ICM codec property page, Danny Miller, October 1996

// CLSID for CICMProperties
// {C00B55C0-10BF-11cf-AC98-00AA004C0FA9}
DEFINE_GUID(CLSID_ICMProperties,
0xc00b55c0, 0x10bf, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9);

// CLSID for IICMOptions
// {8675CC20-1234-11cf-AC98-00AA004C0FA9}
DEFINE_GUID(IID_IICMOptions,
0x8675cc20, 0x1234, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9);

DECLARE_INTERFACE_(IICMOptions,IUnknown)
{
    /* IUnknown methods */

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /* IICMOptions methods */

    STDMETHOD(ICMGetOptions)(THIS_ PCOMPVARS pcompvars) PURE;
    STDMETHOD(ICMSetOptions)(THIS_ PCOMPVARS pcompvars) PURE;
    // returns FAIL, S_OK if OK was pressed or S_FALSE if CANCEL was pressed
    STDMETHOD(ICMChooseDialog)(THIS_ HWND hwnd) PURE;
};

class CICMProperties : public CUnknown, public IPropertyPage
{
    COMPVARS m_compvars;		  // compression options structure
    LPPROPERTYPAGESITE m_pPageSite;       // Details for our property site
    HWND m_hwnd;                          // Window handle for the page
    HWND m_Dlg;                           // Actual dialog window handle
    BOOL m_bDirty;                        // Has anything been changed
    IICMOptions *m_pICM;                  // Pointer to codec interface

    static BOOL CALLBACK ICMDialogProc(HWND hwnd,
                                         UINT uMsg,
                                         WPARAM wParam,
                                         LPARAM lParam);

public:

    CICMProperties(LPUNKNOWN lpUnk,HRESULT *phr);

    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    DECLARE_IUNKNOWN;

    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN *ppUnk);
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent,LPCRECT prect,BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) { return m_bDirty ? S_OK : S_FALSE; }
    STDMETHODIMP Apply(void);
    STDMETHODIMP Help(LPCWSTR lpszHelpDir) { return E_UNEXPECTED; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg) { return E_NOTIMPL; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\resource.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#define IDD_ICMPROPERTIES	700
#define ID_OPTIONS		    701
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\pin.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// CO - quartz wrapper for old video compressors
// pin.cpp - the output pin code
//

#include <streams.h>
#include <windowsx.h>
#include <vfw.h>
//#include <olectl.h>
//#include <olectlid.h>
#include "co.h"

// --- CCoOutputPin ----------------------------------------

/*
    CCoOutputPin constructor
*/
CCoOutputPin::CCoOutputPin(
    TCHAR              * pObjectName,
    CAVICo 	       * pFilter,
    HRESULT            * phr,
    LPCWSTR              pPinName) :

    CTransformOutputPin(pObjectName, pFilter, phr, pPinName),
    m_pFilter(pFilter)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the CCoOutputPin")));
}

CCoOutputPin::~CCoOutputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the CCoOutputPin")));
};


// overriden to expose IMediaPosition and IMediaSeeking control interfaces
// and all the capture interfaces we support
// !!! The base classes change all the time and I won't pick up their bug fixes!
STDMETHODIMP CCoOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    if (riid == IID_IAMStreamConfig) {
	return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else {
        DbgLog((LOG_TRACE,99,TEXT("QI on CCoOutputPin")));
        return CTransformOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CCoOutputPin::Reconnect()
{
    if (IsConnected()) {
        DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our output pin")));
        CMediaType cmt;
	GetMediaType(0, &cmt);
	if (S_OK == GetConnected()->QueryAccept(&cmt)) {
	    m_pFilter->m_pGraph->Reconnect(this);
	} else {
	    // !!! CAPTURE does this better - I don't care, we don't need this
	    // except for the Dialog box
	    // I better break our connections cuz we can't go on like this
            DbgLog((LOG_ERROR,1,TEXT("Can't reconnect with new MT! Disconnecting!")));
	    // !!! We need to notify applications that connections are broken !
	    GetConnected()->Disconnect();
	    Disconnect();
	    return E_UNEXPECTED;
	}
    }
    return NOERROR;
}

//=============================================================================
//=============================================================================

// IAMStreamConfig stuff

// Tell the compressor to compress to a specific format.  If it isn't connected,
// then it will use that format to connect when it does.  If already connected,
// then it will reconnect with the new format.
//
// calling this to change compressors will change what GetInfo will return
//
HRESULT CCoOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
	return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %x %dbit %dx%d"),
		HEADER(pmt->pbFormat)->biCompression,
		HEADER(pmt->pbFormat)->biBitCount,
		HEADER(pmt->pbFormat)->biWidth,
		HEADER(pmt->pbFormat)->biHeight));

    if (m_pFilter->m_fStreaming)
	return VFW_E_NOT_STOPPED;

    if (!m_pFilter->m_pInput->IsConnected())
	return VFW_E_NOT_CONNECTED;

    // If this is the same format as we already are using, don't bother
    CMediaType cmt;
    if ((hr = GetMediaType(0,&cmt)) != S_OK)
	return hr;
    if (cmt == *pmt) {
	return NOERROR;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
	hr = GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR)
	    return VFW_E_INVALIDMEDIATYPE;
    }

    // Normally we wouldn't leave the compressor we find in CheckTransform
    // open if our input is connected already, but we need to force it to
    // leave it open so that it's still open when we call SetMediaType below
    m_pFilter->m_fCacheHic = TRUE;
    hr = m_pFilter->CheckTransform(&m_pFilter->m_pInput->CurrentMediaType(),
						(CMediaType *)pmt);
    m_pFilter->m_fCacheHic = FALSE;

    if (hr != S_OK) {
        DbgLog((LOG_TRACE,1,TEXT("Nobody likes this format. Sorry.")));
 	return hr;
    }

    hr = m_pFilter->SetMediaType(PINDIR_OUTPUT, (CMediaType *)pmt);
    ASSERT(hr == S_OK);

    // from now on, this is the only media type we offer
    m_pFilter->m_cmt = *pmt;
    m_pFilter->m_fOfferSetFormatOnly = TRUE;

    // Changing the format means reconnecting if necessary
    Reconnect();

    return NOERROR;
}


// What format are we compressing to right now?
//
HRESULT CCoOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMAudioStreamConfig::GetFormat")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (ppmt == NULL)
	return E_POINTER;

    // Output choices depend on the input connected
    if (!m_pFilter->m_pInput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("No input type set yet, no can do")));
	return VFW_E_NOT_CONNECTED;
    }

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
	CoTaskMemFree(*ppmt);
	*ppmt = NULL;
	return hr;
    }
    return NOERROR;
}


//
//
HRESULT CCoOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetNumberOfCapabilities")));

    if (piCount == NULL || piSize == NULL)
	return E_POINTER;

    *piCount = 1;
    *piSize = sizeof(VIDEO_STREAM_CONFIG_CAPS);
    return NOERROR;
}


// find out some capabilities of this compressor
//
HRESULT CCoOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    VIDEO_STREAM_CONFIG_CAPS *pVSCC = (VIDEO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (ppmt == NULL || pSCC == NULL)
	return E_POINTER;

    // no good
    if (i < 0)
	return E_INVALIDARG;
    if (i > 0)
	return S_FALSE;

    HRESULT hr = GetFormat(ppmt);
    if (hr != NOERROR)
	return hr;

    ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));
    pVSCC->guid = MEDIATYPE_Video;

    // we don't do cropping
    if (m_pFilter->m_pInput->IsConnected()) {
        pVSCC->InputSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->InputSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
        pVSCC->MinCroppingSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->MinCroppingSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
        pVSCC->MaxCroppingSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->MaxCroppingSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
    }

    return NOERROR;
}


//=============================================================================

// IAMVideoCompression stuff

// make key frames this often
//
HRESULT CCoOutputPin::put_KeyFrameRate(long KeyFrameRate)
{
    HIC hic;

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (KeyFrameRate >=0) {
        m_pFilter->m_compvars.lKey = KeyFrameRate;
	return NOERROR;
    }

    if (!m_pFilter->m_hic) {
	hic = ICOpen(ICTYPE_VIDEO, m_pFilter->m_compvars.fccHandler,
							ICMODE_COMPRESS);
        if (!hic) {
            DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a compressor")));
	    return E_FAIL;
        }
    } else {
	hic = m_pFilter->m_hic;
    }
	
    m_pFilter->m_compvars.lKey = ICGetDefaultKeyFrameRate(hic);

    if (!m_pFilter->m_hic)
	ICClose(hic);

    return NOERROR;
}


// make key frames this often
//
HRESULT CCoOutputPin::get_KeyFrameRate(long FAR* pKeyFrameRate)
{
    if (pKeyFrameRate) {
	*pKeyFrameRate = m_pFilter->m_compvars.lKey;
    } else {
	return E_POINTER;
    }

    return NOERROR;
}


// compress with this quality
//
HRESULT CCoOutputPin::put_Quality(double Quality)
{
    if (Quality < 0)
	m_pFilter->m_compvars.lQ = ICQUALITY_DEFAULT;
    else if (Quality >= 0. && Quality <= 1.)
	m_pFilter->m_compvars.lQ = (long)(Quality * 10000.);
    else
	return E_INVALIDARG;

    return NOERROR;
}


// compress with this quality
//
HRESULT CCoOutputPin::get_Quality(double FAR* pQuality)
{
    // scale 0-10000 to 0-1
    if (pQuality) {
	if (m_pFilter->m_compvars.lQ == ICQUALITY_DEFAULT)
	    *pQuality = -1.;
	else
	    *pQuality = m_pFilter->m_compvars.lQ / (double)ICQUALITY_HIGH;
    } else {
	return E_POINTER;
    }

    return NOERROR;
}


// every frame must fit in the data rate... we don't do the WindowSize thing
//
HRESULT CCoOutputPin::get_WindowSize(DWORDLONG FAR* pWindowSize)
{
    if (pWindowSize == NULL)
	return E_POINTER;

    *pWindowSize = 1;	// we don't do windows
    return NOERROR;
}


// make this frame a key frame, whenever it comes by
//
HRESULT CCoOutputPin::OverrideKeyFrame(long FrameNumber)
{
    // !!! be brave?
    return E_NOTIMPL;
}


// make this frame this size, whenever it comes by
//
HRESULT CCoOutputPin::OverrideFrameSize(long FrameNumber, long Size)
{
    // !!! be brave?
    return E_NOTIMPL;
}


// Get some information about the codec
//
HRESULT CCoOutputPin::GetInfo(LPWSTR pstrVersion, int *pcbVersion, LPWSTR pstrDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    HIC hic;
    ICINFO icinfo;
    DbgLog((LOG_TRACE,1,TEXT("IAMVideoCompression::GetInfo")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (!m_pFilter->m_hic) {
	hic = ICOpen(ICTYPE_VIDEO, m_pFilter->m_compvars.fccHandler,
							ICMODE_COMPRESS);
        if (!hic) {
            DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a compressor")));
	    return E_FAIL;
        }
    } else {
	hic = m_pFilter->m_hic;
    }
	
    DWORD dw = (DWORD)ICGetInfo(hic, &icinfo, sizeof(ICINFO));

    if (pDefaultKeyFrameRate)
	*pDefaultKeyFrameRate = ICGetDefaultKeyFrameRate(hic);
    if (pDefaultPFramesPerKey)
	*pDefaultPFramesPerKey = 0;
    if (pDefaultQuality)
	// scale this 0-1
	*pDefaultQuality = ICGetDefaultQuality(hic) / (double)ICQUALITY_HIGH;
    if (pCapabilities) {
	*pCapabilities = 0;
	if (dw > 0) {
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_QUALITY) ?
					CompressionCaps_CanQuality : 0);
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_CRUNCH) ?
					CompressionCaps_CanCrunch : 0);
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_TEMPORAL) ?
					CompressionCaps_CanKeyFrame : 0);
	    // we don't do b frames
	}
    }

    // We have no version string, but we have a description
    if (pstrVersion)
        *pstrVersion = 0;
    if (pcbVersion)
        *pcbVersion = 0;
    if (dw > 0) {
        if (pstrDescription && pcbDescription)
            lstrcpynW(pstrDescription, (LPCWSTR)&icinfo.szDescription,
			min(*pcbDescription / 2,
			lstrlenW((LPCWSTR)&icinfo.szDescription) + 1));
	if (pcbDescription)
	    // string length in bytes, incl. NULL
	    *pcbDescription = lstrlenW((LPCWSTR)&icinfo.szDescription) * 2 + 2;
    } else {
        if (pstrDescription) {
    	    *pstrDescription = 0;
	if (pcbDescription)
	    *pcbDescription = 0;
	}
    }

    if (hic != m_pFilter->m_hic)
	ICClose(hic);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\dec.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// Prototype wrapper for old video decompressors
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <vfw.h>
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <dynlink.h>

#include "dec.h"
#include "safeseh.h"
#include "msvidkey.h"

// you can never have too many parentheses!
#define ABS(x) (((x) > 0) ? (x) : -(x))

// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// #define OFFER_NEGATIVE_HEIGHTS

// ***************************************************************
// here are the current bugs that without fixes, would play wrong:
    //
    // * Hooking up a YUV type to the ASF writer, without forcing the codec
    // see -biHeight on the output, will result in a flipped image being written

    // **** When Primary Surface is already taken ****
    // WINX to 16/24/32 - plays black
    // WINX to 8 bit - corrupted
    // (H.263 codec at fault for the following:)
    // I420 320x240 to 24 - corrupted
    // I420 160x120 to 24 - corrupted
    // I420 320x240 to 16 - flipped
    // I420 160x120 to 16 - flipped
    // IYUV 320x240 to 16 - flipped
    // IYUV 160x240 to 16 - flipped
    // ************************************************

    // **** When Primary Surface is not taken ****
    // WNV1 to 24 faults display
    // IYUV 320x240 to 24 is flipped
    // IYUV 160x120 to 24 is flipped
    // IYUV 320x240 to 16 is flipped
    // IYUV 160x120 to 16 is flipped
    // ********************************************
// ***************************************************************
// ***************************************************************

// setup data

const AMOVIESETUP_MEDIATYPE
sudAVIDecType = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psudAVIDecPins[] = { { L"Input"             // strName
                     , FALSE                // bRendered
                     , FALSE                // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Output"            // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIDecType }     // lpTypes
                   , { L"Output"            // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudAVIDecType } };  // lpTypes

const AMOVIESETUP_FILTER
sudAVIDec = { &CLSID_AVIDec         // clsID
            , L"AVI Decompressor"   // strName
            , MERIT_NORMAL          // dwMerit
            , 2                     // nPins
            , psudAVIDecPins };     // lpPin

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"AVI Decompressor"
    , &CLSID_AVIDec
    , CAVIDec::CreateInstance
    , NULL
    , &sudAVIDec }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

// --- CAVICodec ----------------------------------------

CAVIDec::CAVIDec(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
    : CVideoTransformFilter(pName, pUnk, CLSID_AVIDec),
      m_hic(NULL),
      m_FourCCIn(0),
      m_fStreaming(FALSE),
      m_fPassFormatChange(FALSE),
      m_bUseEx( FALSE ),
      m_fToRenderer( false )
#ifdef _X86_
      ,
      m_hhpShared(NULL)
#endif
{
    DbgLog((LOG_TRACE,2,TEXT("*Instantiating the DEC filter")));

#ifdef PERF
    m_idSkip = MSR_REGISTER(TEXT("AVI Decoder Skip frame"));
    m_idLate = MSR_REGISTER(TEXT("AVI Decoder late"));
    m_idFrameType = MSR_REGISTER(TEXT("AVI Frame type (1=Key)"));
#endif

    m_bNoSkip = GetProfileInt(TEXT("Quartz"), TEXT("AVINoSkip"), 0);
}

CAVIDec::~CAVIDec()
{
    if (m_hic) {
	ICClose(m_hic);
    }
    DbgLog((LOG_TRACE,2,TEXT("*Destroying the DEC filter")));
}

// this goes in the factory template table to create new instances
CUnknown * CAVIDec::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CAVIDec(TEXT("VFW decompression filter"), pUnk, phr);
}

HRESULT CAVIDec::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DWORD_PTR err = 0;
    FOURCCMap fccOut;
    CMediaType *pmtIn;

    DbgLog((LOG_TRACE,6,TEXT("*::Transform")));

    // codec not open ?
    if (m_hic == 0) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, no codec open")));
	return E_UNEXPECTED;
    }

    if (pIn == NULL || pOut == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, NULL arguments")));
	return E_UNEXPECTED;
    }

    // we haven't started streaming yet?
    if (!m_fStreaming) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, not streaming")));
	return E_UNEXPECTED;
    }

    // make sure we have valid input and output pointers

    BYTE * pSrc;
    HRESULT hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting input sample data")));
	return hr;
    }

    BYTE * pDst;
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting output sample data")));
	return hr;
    }

    LPBITMAPINFOHEADER lpbiSrc = &InputFormat( )->bmiHeader;
    LPBITMAPINFOHEADER lpbiDst = &IntOutputFormat( )->bmiHeader; // internal

    // ICDecompress needs this to be the actual size of this frame, but
    // we can't go changing this for good, so we'll put it back later
    DWORD biSizeImageOld = lpbiSrc->biSizeImage;
    lpbiSrc->biSizeImage = pIn->GetActualDataLength();

    // we just received a format change from the source. So we better notify
    // the guy downstream of the format change
    pIn->GetMediaType((AM_MEDIA_TYPE **)&pmtIn);
    // sometimes we don't end up passing anything to the renderer (eg preroll)
    // so once we notice a format change we will keep trying to pass it to
    // the renderer until we succeed.  Don't waste time trying if we KNOW we're
    // not going to do it.
    if (pmtIn != NULL && pmtIn->Format() != NULL)
	m_fPassFormatChange = TRUE;
    DeleteMediaType(pmtIn);

    if (m_fPassFormatChange && pIn->IsPreroll() != S_OK &&
        				pIn->GetActualDataLength() > 0) {
	CMediaType cmt;
	CopyMediaType((AM_MEDIA_TYPE *)&cmt, &m_pOutput->CurrentMediaType());
        LPBITMAPINFOHEADER lpbi = HEADER(cmt.Format());
	// if we're decompressing 8 bit to 8 bit, I'm assuming this is a
	// palette change, so get the new palette
	// VFW palette changes always have the same number of colours
	if (lpbi && lpbiSrc && lpbiSrc->biBitCount == 8 &&
				lpbi->biBitCount == 8) {
	    ASSERT(lpbi->biClrUsed == lpbiSrc->biClrUsed);
	    if (lpbi->biClrUsed == lpbiSrc->biClrUsed) {
                DbgLog((LOG_TRACE,2,TEXT("Dynamic palette change suspected - doing it")));
	        CopyMemory(lpbi + 1, lpbiSrc + 1,
		   	(lpbiSrc->biClrUsed ? lpbiSrc->biClrUsed : 256) *
							sizeof(RGBQUAD));
	        pOut->SetMediaType(&cmt);
	    }
	}
    }

    // some RLE-compressed videos have the initial frame broken
    // into several separate frames. To work round this problem, avifile.dll
    // reads and decodes all of these frames into a single decompressed frame.
    // If we detect this (an RLE frame with the size of a decompressed frame)
    // then we just copy it.
    if ((lpbiSrc->biCompression == BI_RLE8) &&
        (pIn->GetActualDataLength() == (long)lpbiDst->biSizeImage)) {

        CopyMemory(pDst, pSrc, lpbiDst->biSizeImage);
    } else {

        BOOL dwFlags = 0;

        if (pIn->IsPreroll() == S_OK) {
            DbgLog((LOG_TRACE,6,TEXT("This is a preroll")));
 	    dwFlags |= ICDECOMPRESS_PREROLL;
        }

        if (pIn->GetActualDataLength() <= 0) {
            DbgLog((LOG_TRACE,6,TEXT("This is a NULL frame")));
 	    dwFlags |= ICDECOMPRESS_NULLFRAME;
        }

        if(pIn->IsSyncPoint() == S_OK) {
            DbgLog((LOG_TRACE,6,TEXT("This is a keyframe")));
        } else {
 	    dwFlags |= ICDECOMPRESS_NOTKEYFRAME;
        }

//      PLEASE don't ever send this flag to a codec! Some codecs take this as
//      a hint to speed up, unfortunately others are slightly less clever and
//      all they do when told to speed up is to send the same frame over and
//      over again! Which in turn means that bugs get raised against me for
//      random reasons such as when the window is being blown up full screen
//	!!! well, we should do this SOMETIMES, shouldn't we?
//
//        if (m_itrLate>0) {
//            dwFlags |= ICDECOMPRESS_HURRYUP;    // might help - who knows?
//        }

#ifdef _X86_
        //  Fix the exception handling for win95
        BOOL bPatchedExceptions = m_hhpShared != NULL && BeginScarySEH(m_pvShared);
#endif // _X86_
__try {

	// If we're doing something really funky, use ICDecompressEx
        // we use m_bUseEx here instead of ShoudUseEx because ICDecompressExBegin
        // has already been called, and m_bUseEx will already have been set
        if( m_bUseEx ) {

            // these rects should ALWAYS be filled in
            //
            RECT rcS, rcT;
            GetSrcTargetRects( IntOutputFormat( ), &rcS, &rcT );

            DbgLog((LOG_TRACE,4,TEXT("Calling ICDecompressEx")));

            err =  ICDecompressEx(m_hic, dwFlags, lpbiSrc, pSrc,
		    rcS.left, rcS.top,
		    rcS.right - rcS.left,
		    rcS.bottom - rcS.top,
	            lpbiDst, pDst,
		    rcT.left,
// !!! What about when the big rect is the movie size, and there's a subrect?
// Should I do this hack or not?
// !!! How should I munge the source rect?
		    (lpbiDst->biHeight > 0) ? rcT.top :
				(ABS(lpbiDst->biHeight) - rcT.bottom),
		    rcT.right - rcT.left,
		    rcT.bottom - rcT.top);
        } else {
            DbgLog((LOG_TRACE,4,TEXT("Calling ICDecompress")));
            err =  ICDecompress(m_hic, dwFlags, lpbiSrc, pSrc, lpbiDst, pDst);
        }
} __except(EXCEPTION_EXECUTE_HANDLER) {
	// codecs will GPF on corrupt data.  Best to not draw it instead
        DbgLog((LOG_ERROR,1,TEXT("Decompressor faulted! Recovering...")));
        //DbgBreak("Decompressor faulted! Recovering...");
	err = ICERR_DONTDRAW;

}
#ifdef _X86_
        if (bPatchedExceptions) {
            EndScarySEH(m_pvShared);
        }
#endif // _X86_
        if ((LONG_PTR)err < 0) {
	    DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompress(Ex) 0x%x"), (LONG)err));
            //  Note we can get 0 size samples from capture drivers which pipeline
            //  Because buffers must be returned in the order they are got
            //  the capture driver may have to invalidate 1 buffer by making
            //  it 0 length if it gets bad data.
            err = ICERR_DONTDRAW;
        }
    }

    // now put this back, or it'll shrink until we only decode part of each frm
    lpbiSrc->biSizeImage = biSizeImageOld;

    // decompressed frames are always key
    pOut->SetSyncPoint(TRUE);

    // Check if this is preroll to get from keyframe to the current frame,
    // or a null frame, or if the decompressor doesn't want this frame drawn.
    // If so, we want to decompress it into the output buffer but not
    // deliver it.  Returning S_FALSE tells the base class not to deliver
    // this sample.
    if (pIn->IsPreroll() == S_OK || err == ICERR_DONTDRAW ||
        				pIn->GetActualDataLength() <= 0) {

        DbgLog((LOG_TRACE,5,TEXT("don't pass this to renderer")));
	return S_FALSE;
    }

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    // If there's a pending format change to pass to the renderer, we are now
    // doing it
    m_fPassFormatChange = FALSE;

    return S_OK;
}


// check if you can support mtIn
HRESULT CAVIDec::CheckInputType(const CMediaType* pmtIn)
{
    FOURCCMap fccHandlerIn;
    HIC hic;
    BOOL fOpenedHIC = FALSE;

    DbgLog((LOG_TRACE,3,TEXT("*::CheckInputType")));

    if (pmtIn == NULL || pmtIn->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we only support MEDIATYPE_Video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    fccHandlerIn.SetFOURCC(pmtIn->Subtype());
    if (fccHandlerIn != *pmtIn->Subtype()) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: subtype not a FOURCC")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,3,TEXT("Checking fccType: %lx biCompression: %lx"),
		fccHandlerIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression));

    // We are a decompressor only - reject anything uncompressed.
    // Conversions between RGB types is done by COLOUR.DLL
    if (HEADER(pmtIn->Format())->biCompression == BI_BITFIELDS ||
    			HEADER(pmtIn->Format())->biCompression == BI_RGB)
    {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: This is uncompressed already!")));
	return E_INVALIDARG;
    }

    // look for a decompressor for this format
    if (fccHandlerIn.GetFOURCC() != m_FourCCIn) {
        DbgLog((LOG_TRACE,4,TEXT("opening a decompressor")));
	// This won't find MSVC called CRAM or MRLE called 1
        // hic = ICOpen(ICTYPE_VIDEO, fccHandlerIn.GetFOURCC(),
	//						ICMODE_DECOMPRESS);
	// !!! This still won't find MRLE called 'RLE '
        hic = ICLocate(ICTYPE_VIDEO, fccHandlerIn.GetFOURCC(),
			HEADER(pmtIn->Format()), NULL, ICMODE_DECOMPRESS);
	if (hic)
	    fOpenedHIC = TRUE;
    } else {
        DbgLog((LOG_TRACE,4,TEXT("using a cached decompressor")));
   	hic = m_hic;
    }

    if (!hic) {
        DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a decompressor")));
	if (FCC('rpza') == fccHandlerIn.GetFOURCC()) {
	    return VFW_E_RPZA;
	} else {
	    return VFW_E_NO_DECOMPRESSOR;
	}
    } else {
	if (ICDecompressQuery(hic, HEADER(pmtIn->Format()), NULL)) {
            DbgLog((LOG_ERROR,1,TEXT("Error: Decompressor rejected format")));
	    if (fOpenedHIC) 
	            ICClose(hic);
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}

        // IV41 crashes for Y41P -> RGB8. We have a native Indeo 4
        // filter, so we could perhaps refuse IV41 altogether.
        if(fccHandlerIn.GetFOURCC() == FCC('Y41P'))
        {
            ICINFO IcInfo;
            if(ICGetInfo( hic, &IcInfo, sizeof( IcInfo ) ) != 0) {
                if(IcInfo.fccHandler == FCC('IV41')) {
                    if(fOpenedHIC) {
                        ICClose(hic);
                    }
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        }
            
        

	// remember this hic to save time if asked again, if it won't
	// interfere with an existing connection.  If a connection is
	// broken, we will remember the next hic.
	if (!m_pInput->IsConnected()) {
            DbgLog((LOG_TRACE,4,TEXT("caching this decompressor")));
	    if (fOpenedHIC && m_hic)
		    ICClose(m_hic);

#ifdef DEBUG
            if( fOpenedHIC )
            {
                ICINFO IcInfo;
                memset( &IcInfo, 0, sizeof( IcInfo ) );
                IcInfo.dwSize = sizeof( IcInfo );
                LRESULT lr = ICGetInfo( hic, &IcInfo, sizeof( IcInfo ) );
                if( lr != 0 )
                {
                    WCHAR wszOutput[512];
                    long len = 32; // could be only 5. I'm paranoid.
                    if( IcInfo.szDriver ) len += wcslen( IcInfo.szDriver );
                    if( IcInfo.szDescription ) len += wcslen( IcInfo.szDescription );

                    wcscpy( wszOutput, L"DEC:" );
                    if( IcInfo.szDriver )
                    {
                        WCHAR drive[_MAX_PATH];
                        WCHAR path[_MAX_PATH];
                        WCHAR file[_MAX_PATH];
                        WCHAR ext[_MAX_PATH];
                        _wsplitpath( IcInfo.szDriver, drive, path, file, ext );
                        wcscat( wszOutput, file );
                        wcscat( wszOutput, ext );
                    }
                    if( IcInfo.szDescription )
                    {
                        wcscat( wszOutput, L" (" );
                        wcscat( wszOutput, IcInfo.szDescription );
                        wcscat( wszOutput, L")" );
                    }

                    DbgLog((LOG_TRACE, 1, TEXT("%ls"), wszOutput));
                }
            }
#endif

            m_hic = hic;
            m_FourCCIn = fccHandlerIn.GetFOURCC();
	} else if (fOpenedHIC) {
            DbgLog((LOG_TRACE,4,TEXT("not caching decompressor - we're connected")));
	    ICClose(hic);
	}
    }

    return NOERROR;
}


// check if you can support the transform from this input to this output

HRESULT CAVIDec::CheckTransform(const CMediaType* pmtIn,
                                const CMediaType* pmtOut)
{
    HIC hic = NULL;
    FOURCCMap fccIn;
    FOURCCMap fccOut;
    DWORD_PTR err;
    BOOL      fOpenedHIC = FALSE;

    DbgLog((LOG_TRACE,3,TEXT("*::CheckTransform")));

    if (pmtIn == NULL || pmtOut == NULL || pmtIn->Format() == NULL ||
				pmtOut->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: types don't match")));
	return E_INVALIDARG;
    }

    // and we only accept video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type not VIDEO")));
	return E_INVALIDARG;
    }

    // no ICM codecs can decompress to ARGB.
    //
    if( *pmtOut->Subtype( ) == MEDIASUBTYPE_ARGB32 )
    {
        return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtOut->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: output format type not VIDINFO")));
        return E_INVALIDARG;
    }
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: input format type not VIDINFO")));
        return E_INVALIDARG;
    }

    fccIn.SetFOURCC(pmtIn->Subtype());
    if (fccIn != *pmtIn->Subtype()) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: input subtype not a FOURCC")));
	return E_INVALIDARG;
    }

    ASSERT(pmtOut->Format());

    // this stinks for slowness, but we've made a rule that whenever we talk
    // to a codec with YUV, we're going to force biHeight to be -. This at least
    // forces us to be consistent when talking to the ICM drivers
    //
    VIDEOINFOHEADER * pVIHin = (VIDEOINFOHEADER*) pmtIn->Format( );
    VIDEOINFOHEADER * pVIHout = (VIDEOINFOHEADER*) pmtOut->Format( );

    CMediaType cmtOutCopy(*pmtOut);
    VIDEOINFOHEADER * pVIHoutCopy = (VIDEOINFOHEADER *)cmtOutCopy.Format();
    
    BITMAPINFOHEADER &outBIHcopy = pVIHoutCopy->bmiHeader;
    BITMAPINFOHEADER * pBIHout = &outBIHcopy;
    BITMAPINFOHEADER * pBIHin = &pVIHin->bmiHeader;
    if( ( outBIHcopy.biHeight > 0 ) && IsYUVType( pmtOut ) )
    {
        DbgLog((LOG_TRACE,3,TEXT("  checktransform flipping output biHeight to -, since YUV")));
        outBIHcopy.biHeight *= -1;
    }

    // these rects should ALWAYS be filled in, since the commented out
    // code below just copied, then filled in anyhow
    //
    RECT rcS, rcT;
    GetSrcTargetRects( pVIHout, &rcS, &rcT );

    DbgLog((LOG_TRACE,3,TEXT("Check fccIn: %lx biCompIn: %lx bitDepthIn: %d"),
		fccIn.GetFOURCC(),
		pBIHin->biCompression,
		pBIHin->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthIn: %ld biHeightIn: %ld biSizeIn: %ld"),
		pBIHin->biWidth,
		pBIHin->biHeight,
		pBIHin->biSize));
    DbgLog((LOG_TRACE,3,TEXT("fccOut: %lx biCompOut: %lx bitDepthOut: %d"),
		fccOut.GetFOURCC(),
		pBIHout->biCompression,
		pBIHout->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthOut: %ld biHeightOut: %ld"),
		pBIHout->biWidth,
		pBIHout->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS.left, rcS.top, rcS.right, rcS.bottom));
    DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT.left, rcT.top, rcT.right, rcT.bottom));

    // ehr: if the output pin exists, and is NOT connected, then reject
    // transforms between matching media types. If the output pin is connected,
    // then the video renderer might suggest going from YUV to YUV in mid-stride,
    // which we should allow querying for
    //
    if( !m_fToRenderer && m_pOutput && !m_pOutput->IsConnected( ) )
    {
        if( HEADER( pVIHin )->biCompression == HEADER( pVIHout )->biCompression )
        {
            DbgLog((LOG_TRACE,3,TEXT("Rejecting: dec used as pass-thru, same compression formats")));
            return E_INVALIDARG;
        }
        else if( IsYUVType( pmtIn ) && IsYUVType( pmtOut ) )
        {
          // also don't allow yuv to yuv conversions, to avoid endless connections to ourself
          // for certain codecs that do uyvy to yuy2 conversions and back (since our merit is high)
            DbgLog((LOG_TRACE,3,TEXT("Rejecting: dec used as yuv to yuv, which we don't allow")));
            return E_INVALIDARG;
        }
    }

    // find a codec for this transform

    // I assume that we've already got a codec open
    ASSERT(m_hic);

    // the right codec better be open!
    // When reconnecting, we'll get called with a new input, but same output,
    // and better admit we can handle it
    if (m_FourCCIn != fccIn.GetFOURCC()) {
        DbgLog((LOG_TRACE,4,TEXT("Testing with a newly opened decompressor")));
        hic = ICLocate(ICTYPE_VIDEO, fccIn.GetFOURCC(),
			pBIHin, NULL, ICMODE_DECOMPRESS);
	if (hic)
	    fOpenedHIC = TRUE;
    } else {
	// We already have the right codec open to try this transform
        DbgLog((LOG_TRACE,4,TEXT("Testing with the cached decompressor")));
	hic = m_hic;
    }

    if (!hic) {
        DbgLog((LOG_ERROR,1,TEXT("Error: Can't find a decompressor")));
	return E_FAIL;
    }

    // If we are being asked to do something funky, we have to use ICDecompressEx
    // We need to call ShouldsUseEx here because m_bUseEx isn't in context, we're just
    // calling ICDecompress(Ex?)Query
    if( ShouldUseExFuncs( hic, pVIHin, pVIHout ) ) {
        DbgLog((LOG_TRACE,4,TEXT("Trying this format with ICDecompressEx")));
        err = ICDecompressExQuery(hic, 0, pBIHin, NULL,
		rcS.left, rcS.top,
		rcS.right - rcS.left,
		rcS.bottom - rcS.top,
		pBIHout, NULL,
		rcT.left, rcT.top,
		rcT.right - rcT.left,
		rcT.bottom - rcT.top);
    } else {
        DbgLog((LOG_TRACE,4,TEXT("Trying this format with ICDecompress")));
        err = ICDecompressQuery(hic, pBIHin, pBIHout);
    }

    // if we just opened it, close it.
    if (fOpenedHIC)
	ICClose(hic);

    if (err != ICERR_OK) {
        DbgLog((LOG_TRACE,3,TEXT("decompressor rejected this transform")));
        return E_FAIL;
    }

    return NOERROR;
}


// overriden to know when the media type is actually set

HRESULT CAVIDec::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    FOURCCMap fccHandler;

    if (direction == PINDIR_OUTPUT) {

	// Please call me if this goes off. -DannyMi
	ASSERT(!m_fStreaming);

	// OK, we've finally decided on what codec to use.  See if it
	// supports temporal compression, but can't do it without needing
	// the undisturbed previous bits.  If so, then we need to use
	// 1 read only buffer on our output pin (in DecideAllocator and
	// DecideBufferSize)
	ASSERT(m_hic);
	ICINFO icinfo;
 	DWORD dw = ICGetInfo(m_hic, &icinfo, sizeof(icinfo));
	m_fTemporal = TRUE;	// better safe than sorry?
	if (dw > 0) {
	    m_fTemporal = (icinfo.dwFlags & VIDCF_TEMPORAL) &&
				!(icinfo.dwFlags & VIDCF_FASTTEMPORALD);
	}
        DbgLog((LOG_TRACE,3,TEXT("Temporal compressor=%d"), m_fTemporal));
        DbgLog((LOG_TRACE,3,TEXT("***::SetMediaType (output)")));
        DbgLog((LOG_TRACE,3,TEXT("Output type is: biComp=%lx biBitCount=%d"),
		HEADER(OutputFormat())->biCompression,
		HEADER(OutputFormat())->biBitCount));

	return NOERROR;
    }

    ASSERT(direction == PINDIR_INPUT);

    DbgLog((LOG_TRACE,3,TEXT("***::SetMediaType (input)")));
    DbgLog((LOG_TRACE,3,TEXT("Input type is: biComp=%lx biBitCount=%d"),
		HEADER(InputFormat())->biCompression,
		HEADER(InputFormat())->biBitCount));

    // Please call me if this goes off. -DannyMi
    ASSERT(!m_fStreaming);

    // We better have one of these opened by now
    ASSERT(m_hic);

    // We better have the RIGHT one open
    FOURCCMap fccIn;
    fccIn.SetFOURCC(pmt->Subtype());

    // Please call me if this goes off. -DannyMi
    // Maybe a dynamic input format change?  But that shouldn't call
    // SetMediaType, or it will force a reconnect of the output which is bad.
    ASSERT(m_FourCCIn == fccIn.GetFOURCC());

    // !!! BUG! We won't let somebody reconnect our input from cinepak to
    // RLE if our output is 24 bit RGB because RLE can't decompress to 24 bit
    // We would have to override CheckMediaType not to call CheckTransform
    // with the current output type

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
        DbgLog((LOG_TRACE,2,TEXT("Reconnecting the output pin...")));
	// This shouldn't fail, we're not changing the media type
	m_pGraph->Reconnect(m_pOutput);
    }

    return NOERROR;
}


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.
//
// NOTE: We can't enumerate the codecs so we are pulling random formats out
// of our butt!

HRESULT CAVIDec::GetMediaType(int iPosition,CMediaType *pmt)
{
    LARGE_INTEGER li;
    FOURCCMap fccHandler;
    VIDEOINFOHEADER *pf;

    DbgLog((LOG_TRACE,3,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Media type is NULL, no can do")));
	return E_INVALIDARG;
    }

    // Output choices depend on the input connected
    if (!m_pInput->CurrentMediaType().IsValid()) {
        DbgLog((LOG_TRACE,3,TEXT("No input type set yet, no can do")));
	return E_FAIL;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Caution: These are given out of order. be careful renumbering
    // the case statements !!!

    switch (iPosition) {
	
    // Offer the compressor's favourite after all the YUV and RGB's we offer, so
    // we don't end up always using 8 bit or 24 bit over YUV just cuz it's the
    // compressor's favourite

    // cinepak crashes on win95 and osr2
//     // Offer CPLA (Cinepak's favourite and best looking)
//     case 0:
//     {

//         DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 0: CPLA")));

// 	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
//      // only offer positive heights so downstream connections aren't confused
//      HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

// 	// Can't error, can only be smaller
// 	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

// 	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
// 	lpbi->biSize = sizeof(BITMAPINFOHEADER);
// 	lpbi->biCompression = MKFOURCC('C','P','L','A');
// 	lpbi->biBitCount = 12;
// 	lpbi->biClrUsed = 0;
// 	lpbi->biClrImportant = 0;
// 	lpbi->biSizeImage = DIBSIZE(*lpbi);

//         pmt->SetSubtype(&MEDIASUBTYPE_CPLA);

//         break;
//     }




    // offer CLJR (Cinepak and Cirrus Logic can do this)
    case 0:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 1: CLJR")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('C','L','J','R');
	lpbi->biBitCount = 8;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_CLJR);

        break;
    }

    // offer UYVY (Cinepak can do this)
    case 1:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 3: UYVY")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('U','Y','V','Y');
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_UYVY);

        break;
    }

    // offer YUY2 (Cinepak can do this)
    case 2:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 4: YUY2")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('Y','U','Y','2');
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_YUY2);

        break;
    }

    // Offer 32 bpp RGB
    case 3:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 5: 32 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 32;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB32);

        break;
    }

    // Offer 24 bpp RGB
    case 4:
    {
        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 6: 24 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 24;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);

        break;
    }

    // Offer 16 bpp RGB 565 before 555
    case 5:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 7: 565 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	if (pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) +
							SIZE_MASKS) == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory reallocating format")));
	    return E_OUTOFMEMORY;
	}

	// update the RGB 565 bit field masks

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_BITFIELDS;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

	DWORD *pdw = (DWORD *) (lpbi+1);
	pdw[iRED] = bits565[iRED];
	pdw[iGREEN] = bits565[iGREEN];
	pdw[iBLUE] = bits565[iBLUE];

        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);

        break;
    }

    // Offer 16 bpp RGB 555
    case 6:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 8: 555 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);

        break;
    }

    // Offer 8 bpp palettised
    case 7:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 9: 8 bit RGB")));


	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	if (pmt->ReallocFormatBuffer(SIZE_PREHEADER +
			sizeof(BITMAPINFOHEADER) + SIZE_PALETTE) == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory reallocating format")));
    	    return E_OUTOFMEMORY;
	}

        LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
        lpbi->biCompression = BI_RGB;
        lpbi->biBitCount = 8;
        lpbi->biSizeImage = DIBSIZE(*lpbi);

        // we need the source VIDEOINFOHEADER type to get any palette from and
        // also the number of bytes size it allocated. We copy the palette
        // from the input format in case the codec can't deliver it to us

        VIDEOINFOHEADER *pSourceInfo = InputFormat();
        int nBitDepth = pSourceInfo->bmiHeader.biBitCount;
        int nColours = pSourceInfo->bmiHeader.biClrUsed;
  	if (nColours == 0 && nBitDepth <=8)
	    nColours = 1 << nBitDepth;

        // if there is a palette present then copy the maximum number of bytes
        // available which is bounded by the memory we previously allocated

        if (nColours > 0) {
	    CopyMemory((PVOID)(lpbi + 1),
		   (PVOID) COLORS(pSourceInfo),
		   min(SIZE_PALETTE,nColours * sizeof(RGBQUAD)));
	    lpbi->biClrUsed = nColours;
	    lpbi->biClrImportant = 0;
        } else {

	    // I DON'T KNOW WHY somebody thought this was necessary, but might
	    // as well keep it, just in case.  ONLY DO IT if the source guy
	    // didn't have a palette, or we'll zero out system colours
	    // by mistake. - DannyMi 5/97

            // this is really painful, if we are running on a true colour
            // display we still want the codec to give us the correct palette
	    // colours, but some of them return garbage for the VGA colours so
	    // if we are on a device which isn't palettised then we zero fill
	    // the twenty VGA entries - some british guy 5/95

            HDC hdc = GetDC(NULL);
	    BOOL fPalette = FALSE;
	    if (hdc) {
                fPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
                ReleaseDC(NULL,hdc);
	    }

            if (!fPalette) {
                ZeroMemory((lpbi + 1),10 * sizeof(RGBQUAD));
                ZeroMemory((LPBYTE)(lpbi + 1) + 246 * sizeof(RGBQUAD),
							    10 * sizeof(RGBQUAD));
            }
	}

        // Read palette from codec - will write palette to output lpbi
        // ignore any error: the palette used will be from the source
        // in that case (which we have already copied)

	ICDecompressGetPalette(m_hic, HEADER(pSourceInfo), lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB8);

        break;
    }

#ifdef OFFER_NEGATIVE_HEIGHTS

    // offer CLJR (Cinepak and Cirrus Logic can do this)
    case 8:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 1: CLJR")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('C','L','J','R');
	lpbi->biBitCount = 8;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_CLJR);

        break;
    }

    // offer UYVY (Cinepak can do this)
    case 9:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 3: UYVY")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('U','Y','V','Y');
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_UYVY);

        break;
    }

    // offer YUY2 (Cinepak can do this)
    case 10:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 4: YUY2")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = MKFOURCC('Y','U','Y','2');
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_YUY2);

        break;
    }

    // Offer 32 bpp RGB
    case 11:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 5: 32 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 32;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_RGB32);

        break;
    }

    // Offer 24 bpp RGB
    case 12:
    {
        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 6: 24 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 24;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);

        break;
    }

    // Offer 16 bpp RGB 565 before 555
    case 13:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 7: 565 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	if (pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) +
							SIZE_MASKS) == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory reallocating format")));
	    return E_OUTOFMEMORY;
	}

	// update the RGB 565 bit field masks

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_BITFIELDS;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

	DWORD *pdw = (DWORD *) (lpbi+1);
	pdw[iRED] = bits565[iRED];
	pdw[iGREEN] = bits565[iGREEN];
	pdw[iBLUE] = bits565[iBLUE];

        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);

        break;
    }

    // Offer 16 bpp RGB 555
    case 14:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 8: 555 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);

        break;
    }

    // Offer 8 bpp palettised
    case 15:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 9: 8 bit RGB")));


	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// now offer negative type
	HEADER(pmt->Format())->biHeight = -ABS(HEADER(pmt->Format())->biHeight);

	if (pmt->ReallocFormatBuffer(SIZE_PREHEADER +
			sizeof(BITMAPINFOHEADER) + SIZE_PALETTE) == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory reallocating format")));
    	    return E_OUTOFMEMORY;
	}

        LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
        lpbi->biCompression = BI_RGB;
        lpbi->biBitCount = 8;
        lpbi->biSizeImage = DIBSIZE(*lpbi);
        lpbi->biHeight = -abs( lpbi->biHeight );

        // we need the source VIDEOINFOHEADER type to get any palette from and
        // also the number of bytes size it allocated. We copy the palette
        // from the input format in case the codec can't deliver it to us

        VIDEOINFOHEADER *pSourceInfo = InputFormat();
        int nBitDepth = pSourceInfo->bmiHeader.biBitCount;
        int nColours = pSourceInfo->bmiHeader.biClrUsed;
  	if (nColours == 0 && nBitDepth <=8)
	    nColours = 1 << nBitDepth;

        // if there is a palette present then copy the maximum number of bytes
        // available which is bounded by the memory we previously allocated

        if (nColours > 0) {
	    CopyMemory((PVOID)(lpbi + 1),
		   (PVOID) COLORS(pSourceInfo),
		   min(SIZE_PALETTE,nColours * sizeof(RGBQUAD)));
	    lpbi->biClrUsed = nColours;
	    lpbi->biClrImportant = 0;
        } else {

	    // I DON'T KNOW WHY somebody thought this was necessary, but might
	    // as well keep it, just in case.  ONLY DO IT if the source guy
	    // didn't have a palette, or we'll zero out system colours
	    // by mistake. - DannyMi 5/97

            // this is really painful, if we are running on a true colour
            // display we still want the codec to give us the correct palette
	    // colours, but some of them return garbage for the VGA colours so
	    // if we are on a device which isn't palettised then we zero fill
	    // the twenty VGA entries - some british guy 5/95

            HDC hdc = GetDC(NULL);
	    BOOL fPalette = FALSE;
	    if (hdc) {
                fPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
                ReleaseDC(NULL,hdc);
	    }

            if (!fPalette) {
                ZeroMemory((lpbi + 1),10 * sizeof(RGBQUAD));
                ZeroMemory((LPBYTE)(lpbi + 1) + 246 * sizeof(RGBQUAD),
							    10 * sizeof(RGBQUAD));
            }
	}

        // Read palette from codec - will write palette to output lpbi
        // ignore any error: the palette used will be from the source
        // in that case (which we have already copied)

	ICDecompressGetPalette(m_hic, HEADER(pSourceInfo), lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB8);

        break;
    }


    // !!! This comes last because it might fail, and stop enumerating
    case 16:
#else
    case 8:
#endif
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Last Media Type: default codec out")));

        // ask the codec to recommend an output format size and add on the
        // space required by the extra members in the VIDEOINFOHEADER structure
        ULONG cb = ICDecompressGetFormatSize(m_hic,
			HEADER(InputFormat()));
        if (cb <= 0) {
            DbgLog((LOG_ERROR,1,TEXT("Error %d in ICDecompressGetFormatSize"),
									cb));
     	    return E_FAIL;
        }

        // allocate a VIDEOINFOHEADER for the default output format
        cb += SIZE_PREHEADER;
        pf = (VIDEOINFOHEADER *)pmt->AllocFormatBuffer(cb);
        if (pf == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Error allocating format buffer")));
	    return E_OUTOFMEMORY;
        }

        RESET_HEADER(pf);

        DWORD dwerr = ICDecompressGetFormat(m_hic,
			HEADER(InputFormat()),
	    		HEADER(pmt->Format()));
        if (ICERR_OK != dwerr) {
             DbgLog((LOG_ERROR,1,TEXT("Error from ICDecompressGetFormat")));
	     return E_FAIL;
        }

        DbgLog((LOG_TRACE,3,TEXT("biComp: %x biBitCount: %d"),
			HEADER(pmt->Format())->biCompression,
	 		HEADER(pmt->Format())->biBitCount));

        const GUID SubTypeGUID = GetBitmapSubtype(HEADER(pmt->Format()));
        pmt->SetSubtype(&SubTypeGUID);

        break;
    }





    default:
	return VFW_S_NO_MORE_ITEMS;

    }

    // now set the common things about the media type
    pf = (VIDEOINFOHEADER *)pmt->Format();
    pf->AvgTimePerFrame = InputFormat( )->AvgTimePerFrame;
    li.QuadPart = pf->AvgTimePerFrame;
    if (li.LowPart)
        pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000, li.LowPart);
    pf->dwBitErrorRate = 0L;
    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetSampleSize(pf->bmiHeader.biSizeImage);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    return NOERROR;
}

HRESULT CAVIDec::CheckConnect(PIN_DIRECTION dir,IPin *pPin)
{
    m_fToRenderer = false;
    if(dir == PINDIR_OUTPUT)
    {
        PIN_INFO pi;
        HRESULT hr = pPin->QueryPinInfo(&pi);
        if(hr == S_OK && pi.pFilter) {
            CLSID clsid;
            if(pi.pFilter->GetClassID(&clsid) == S_OK &&
               clsid == CLSID_VideoMixingRenderer) {
                m_fToRenderer = true;
            }
            pi.pFilter->Release();
        }
    }
    return CVideoTransformFilter::CheckConnect(dir, pPin);
}

HRESULT CAVIDec::BreakConnect(PIN_DIRECTION dir)
{
    // probably no need to reset because we will always set before
    // checking this variable
    m_fToRenderer = false;

    return CVideoTransformFilter::BreakConnect(dir);
}


// overridden to create a CDecOutputPin
// !!! base class changes won't get picked up by me
//
CBasePin * CAVIDec::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (m_pInput == NULL) {

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"XForm In");      // Pin name


        //  Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pInput == NULL) {
            return NULL;
        }
        m_pOutput = (CTransformOutputPin *)
		   new CDecOutputPin(NAME("Transform output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"XForm Out");   // Pin name


        // Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    } else
    if (n == 1) {
        return m_pOutput;
    } else {
        return NULL;
    }
}


// overridden to properly mark buffers read only or not in NotifyAllocator
// !!! base class changes won't get picked up by me
//
HRESULT CDecOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    // temporal compression ==> read only buffers
	    hr = pPin->NotifyAllocator(*ppAlloc,
					((CAVIDec *)m_pFilter)->m_fTemporal);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    // temporal compression ==> read only buffers
	    hr = pPin->NotifyAllocator(*ppAlloc,
					((CAVIDec *)m_pFilter)->m_fTemporal);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


// called from CBaseOutputPin to prepare the allocator's count
// of buffers and sizes
HRESULT CAVIDec::DecideBufferSize(IMemAllocator * pAllocator,
                                  ALLOCATOR_PROPERTIES *pProperties)
{
    // David assures me this won't be called with NULL output mt.
    ASSERT(m_pOutput->CurrentMediaType().IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);
    ASSERT(m_hic);

    // If we are doing temporal compression where we need the undisturbed
    // previous bits, we insist on 1 buffer (also our default)
    if (m_fTemporal || pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // set the size of buffers based on the expected output frame size
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();

    ASSERT(pProperties->cbBuffer);

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    // For temporal compressors, we MUST get exactly one buffer, since we assume
    // that the previous decompressed frame is already present in the output
    // buffer. The alternative is to copy the bits from a saved location before
    // doing the decompression, but that is not nice.
    if (m_fTemporal && Actual.cBuffers != 1) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - need exactly 1 buffer")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,2,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));


    // It happens - connect me to the mux.  I don't care
    //ASSERT(Actual.cbAlign == 1);
    //ASSERT(Actual.cbPrefix == 0);
    //DbgLog((LOG_TRACE,1,TEXT("Buffer Align=%d Prefix=%d"), Actual.cbAlign, Actual.cbPrefix));

    return S_OK;
}

#include "..\..\..\filters\asf\wmsdk\inc\wmsdk.h"

HRESULT CAVIDec::StartStreaming()
{
    DWORD_PTR err;

    DbgLog((LOG_TRACE,2,TEXT("*::StartStreaming")));

    // first copy the media type to our internal one. Type changes on the output pin
    // will cause this to update, which is good.
    //
    m_mtFixedOut = m_pOutput->CurrentMediaType( );

    // see if we need to fix up biHeight on m_mtFixedOut if we output YUV
    // this will change m_mtFixedOut's biHeight if necessary
    //
    CheckNegBiHeight( );
 
    VIDEOINFOHEADER * pVIHout = IntOutputFormat( ); // internal
    VIDEOINFOHEADER * pVIHin = InputFormat( );
    LPBITMAPINFOHEADER lpbiSrc = HEADER(pVIHin);
    LPBITMAPINFOHEADER lpbiDst = HEADER(pVIHout);

    if (!m_fStreaming) {
        if (lpbiSrc->biCompression == 0x3334504d && m_pGraph) { // !!! MP43
            IObjectWithSite *pSite;
            HRESULT hrKey = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
            if (SUCCEEDED(hrKey)) {
                IServiceProvider *pSP;
                hrKey = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
                pSite->Release();

                if (SUCCEEDED(hrKey)) {
                    IUnknown *pKey;
                    hrKey = pSP->QueryService(__uuidof(IWMReader), IID_IUnknown, (void **) &pKey);
                    pSP->Release();

                    if (SUCCEEDED(hrKey)) {
                        // !!! verify key?
                        pKey->Release();

                        DbgLog((LOG_TRACE, 1, "Dec: Unlocking MP43 codec"));
                        //
                        // Use GetState() to set the key into a particular
                        // instance of the codec.  While it looks odd
                        // to be using ICGetState to set values, it is correct!
                        //

                        DWORD dwSize = ICGetStateSize( m_hic );

                        if( dwSize <= 256 )
                        {
                            CHAR rgcBuf[256];
                            MSVIDUNLOCKKEY *pks;

                            pks = (MSVIDUNLOCKKEY *)rgcBuf;

                            pks->dwVersion = MSMP43KEY_VERSION;
                            pks->guidKey   = __uuidof( MSMP43KEY_V1 );

                            ICGetState( m_hic, rgcBuf, dwSize );
                        } else {
                            ASSERT(0);
                        }
                    }
                }
            }
        }

        // indeo codec (V4.11.15.60) crashes in ICDecompressBegin with
        // the 2.0 runtime because of this call
        // cinepak blows up thinking CLJR is palettised, too
        if (lpbiSrc->biCompression != FCC('IV41') &&
        			lpbiDst->biCompression != FCC('CLJR')) {
            ICDecompressSetPalette(m_hic, lpbiDst);
        }

        // start off with it being false
        //
        m_bUseEx = FALSE;

	// Start Streaming Decompression - if we're doing something funky, use
	// ICDecompressEx
        // find out if we can set m_bUseEx by calling ShoudUseEx...
        if( ShouldUseExFuncs( m_hic, pVIHin, pVIHout ) ) {

            // these rects should ALWAYS be filled in
            //
            RECT rcS, rcT;
            GetSrcTargetRects( pVIHout, &rcS, &rcT );

            // set it here now that we've called DecompressExBegin
            //
            m_bUseEx = TRUE;

            DbgLog((LOG_TRACE,3,TEXT("Calling ICDecompressExBegin")));

	    err = ICDecompressExBegin(m_hic, 0,
			lpbiSrc, NULL,
			rcS.left, rcS.top,
			rcS.right - rcS.left,
			rcS.bottom - rcS.top,
			lpbiDst, NULL,
			rcT.left,
// !!! What about when the big rect is the movie size, and there's a subrect?
// Should I do this hack or not?
// !!! How should I munge the source rect?
			(lpbiDst->biHeight > 0) ? rcT.top :
				(ABS(lpbiDst->biHeight) - rcT.bottom),
			rcT.right - rcT.left,
			rcT.bottom - rcT.top);
	} else {
            DbgLog((LOG_TRACE,3,TEXT("Calling ICDecompressBegin")));
	    err = ICDecompressBegin(m_hic, lpbiSrc, lpbiDst);
            if( err != ICERR_OK )
            {
                DbgLog((LOG_TRACE,2,TEXT("ICDecompressBegin failed")));

                // something went wrong. If the heighth was -,
                // then we'll try again with a + height
                //
                if( lpbiDst->biHeight < 0 )
                {
                    DbgLog((LOG_TRACE,2,TEXT("trying ICDecompressBegin with flipped biHeight")));

                    lpbiDst->biHeight = abs( lpbiDst->biHeight );
                    long err2 = 0;
            	    err2 = ICDecompressBegin(m_hic, lpbiSrc, lpbiDst);

                    if( err2 == ICERR_OK )
                    {
                        DbgLog((LOG_TRACE,2,TEXT("that worked!")));

                        int erudolphsezcallmeifthisgoesoff = 0;
                        ASSERT( erudolphsezcallmeifthisgoesoff );
                        err = err2;
                    }
                    else
                    {
                        DbgLog((LOG_TRACE,2,TEXT("didn't work, so we'll fail")));

                        // put it back to - so we don't confuse anybody
                        //
                        lpbiDst->biHeight = -lpbiDst->biHeight;
                    }
                }
            }
	}

	if (ICERR_OK == err) {
	    m_fStreaming = TRUE;

#ifdef _X86_
            // Create our exception handler heap
            ASSERT(m_hhpShared == NULL);
            if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
               m_hhpShared = CreateFileMapping(INVALID_HANDLE_VALUE,
                                               NULL,
                                               PAGE_READWRITE,
                                               0,
                                               20,
                                               NULL);
               if (m_hhpShared) {
                   m_pvShared = MapViewOfFile(m_hhpShared,
                                              FILE_MAP_WRITE,
                                              0,
                                              0,
                                              20);
                   if (m_pvShared == NULL) {
                       EXECUTE_ASSERT(CloseHandle(m_hhpShared));
                       m_hhpShared = NULL;
                   } else {
                       DbgLog((LOG_TRACE, 1, TEXT("Shared memory at %8.8X"),
                              m_pvShared));
                   }
               }
            }
#endif // _X86_
	} else {
            DbgLog((LOG_ERROR,1,TEXT("Error %d in ICDecompress(Ex)Begin"),err));
	    return E_FAIL;
	}	

    } // if !m_fStreaming
    return CVideoTransformFilter::StartStreaming();
}

HRESULT CAVIDec::StopStreaming()
{
    DbgLog((LOG_TRACE,2,TEXT("*::StopStreaming")));

    if (m_fStreaming) {
	ASSERT(m_hic);

	// Stop whichever one was started, m_bUseEx tells us which
        if( m_bUseEx ) {
	    ICDecompressExEnd(m_hic);
	} else {
	    ICDecompressEnd(m_hic);
	}

	m_fStreaming = FALSE;

#ifdef _X86_
        if (m_hhpShared) {
            EXECUTE_ASSERT(UnmapViewOfFile(m_pvShared));
            EXECUTE_ASSERT(CloseHandle(m_hhpShared));;
            m_hhpShared = NULL;
        }
#endif // _X86_
    }
    return NOERROR;
}

// We're now streaming - tell the codec to hurry up from now on
STDMETHODIMP CAVIDec::Run(REFERENCE_TIME tStart)
{
    if (m_State == State_Paused && m_hic) {
        DbgLog((LOG_TRACE,3,TEXT("Sending ICM_DRAW_START to the codec")));
	ICDrawStart(m_hic);
    }

    return CBaseFilter::Run(tStart);
}

// We're no longer streaming (from the codec's point of view)
STDMETHODIMP CAVIDec::Pause(void)
{
    if (m_State == State_Running && m_hic) {
        DbgLog((LOG_TRACE,3,TEXT("Sending ICM_DRAW_STOP to the codec")));
	ICDrawStop(m_hic);
    }

    return CTransformFilter::Pause();
}

// ehr: this little bit of code is a hakk for OSR4.1 bug #117296, which
// is that if you connect a YUV type to the WM (ASF) writer filter,
// since it doesn't suggest and we don't offer -biHeight YUV, the 
// Cinepak codec (and possibly others) are told they are decompressing
// to a +biHeight YUV format, and for Cinepak at least, this produces
// YUV video that is inverted, which should NEVER happen. This fixes
// that by telling ALL codecs that if they are decoding to YUV, they
// are doing it to -biHeight YUV, no matter what the connected output
// mediatype is. (We are lying to the codec, but since the rule is that
// + or - biHeight YUV is always "normal", then it's okay)
// We fool the codec by keeping a copy of the media type that's connected
// on the output pin, but we switch around the sign on the biHeight on 
// our private copy.

// check for YUV types that need a negative biHeight
// only called from StartStreaming, m_mtFixed(In)Out is already set
void CAVIDec::CheckNegBiHeight( )
{
    if( ( IntOutputFormat( )->bmiHeader.biHeight > 0 ) && IsYUVType( &m_mtFixedOut ) )
    {
        IntOutputFormat( )->bmiHeader.biHeight *= -1;
        DbgLog((LOG_TRACE,1,TEXT("Dec:Flipping internal output biHeight to negative")));
    }
}

BOOL CAVIDec::IsYUVType( const AM_MEDIA_TYPE * pmt)
{
    if( NULL == pmt )
    {
        return FALSE;
    }

//
// !! WARNING: If a YUV type is ever added to this list which has a biSize > sizeof(BITMAPINFOHEADER)
//             then other updates will be required, since the code which handles ensuring negative
//             biHeights are passed to ICM calls assumes biSize = BITMAPINFOHEADER size for YUV types, to
//             avoid dynamic allocations.
//

    // packed formats we care about
    const GUID * pYUVs[] = 
    {
        // packed formats
        &MEDIASUBTYPE_UYVY,
        &MEDIASUBTYPE_YUY2,
        &MEDIASUBTYPE_CLJR,
        &MEDIASUBTYPE_Y211,
        &MEDIASUBTYPE_Y411,
        &MEDIASUBTYPE_YUYV,
        &MEDIASUBTYPE_Y41P,
        &MEDIASUBTYPE_YVYU,
        // planar formats
        &MEDIASUBTYPE_YVU9,
        &MEDIASUBTYPE_IF09,
        &MEDIASUBTYPE_YV12,
        &MEDIASUBTYPE_IYUV,
        &MEDIASUBTYPE_CLPL
    };
    int gTypes = sizeof(pYUVs) / sizeof(pYUVs[0]);
    for( int i = 0 ; i < gTypes ; i++ )
    {
        if( pmt->subtype == *pYUVs[i] ) return TRUE;
    }

    return FALSE;
}

// called from CheckTransform, StartStreaming, Transform
// we NEVER pass back empty rects. Anybody who calls this function is about to
// use them for ICDecompressQueryEx or ICDecompressEx, and those functions
// don't want empty rects, ever. Never call IntOutputFormat( ) from here,
// they may not be set by now.
void CAVIDec::GetSrcTargetRects( const VIDEOINFOHEADER * pVIH, RECT * pSource, RECT * pTarget )
{
    if( IsRectEmpty( &pVIH->rcSource ) ) {
        const VIDEOINFOHEADER* pvihInputFormat = InputFormat();

        pSource->left = 0;
        pSource->top = 0;
        pSource->right = pvihInputFormat->bmiHeader.biWidth;
        pSource->bottom = abs( pvihInputFormat->bmiHeader.biHeight );
    } else {
        *pSource = pVIH->rcSource;
    }

    if( IsRectEmpty( &pVIH->rcTarget ) ) {

        pTarget->left = 0;
        pTarget->top = 0;
        pTarget->right = pVIH->bmiHeader.biWidth;
        pTarget->bottom = abs( pVIH->bmiHeader.biHeight );
    } else {
        *pTarget = pVIH->rcTarget;
    }
}

// this function determines if the ICDecompresEx function is used or not. 
// Unless a certain driver says it needs to, ICDecompressEx WON'T be called if
// the rects are blank, or if they match the destination width/height
// This function is called from only two places: StartStreaming, and CheckTransform. 

BOOL CAVIDec::ShouldUseExFuncs( HIC hic, const VIDEOINFOHEADER * pVIHin, const VIDEOINFOHEADER * pVIHout )
{
    if( ShouldUseExFuncsByDriver( hic, &pVIHin->bmiHeader, &pVIHout->bmiHeader ) )
    {
        return TRUE;
    }

    // if the rects have something in them, and they are not just the full-size values,
    // then we know we need to call the Ex functions
    //
    const RECT * pSource = &pVIHout->rcSource;
    const RECT * pTarget = &pVIHout->rcTarget;
    if( !IsRectEmpty( pSource ) )
    {
        if( pSource->left != 0 || pSource->right != pVIHout->bmiHeader.biWidth || pSource->top != 0 || pSource->bottom != abs( pVIHout->bmiHeader.biHeight ) )
            return TRUE;
    }
    if( !IsRectEmpty( pTarget ) )
    {
        if( pTarget->left != 0 || pTarget->right != pVIHout->bmiHeader.biWidth || pTarget->top != 0 || pTarget->bottom != abs( pVIHout->bmiHeader.biHeight ) )
            return TRUE;
    }

    return FALSE; // too bad it has to check all the above to get to this point. :-(
}

/******************************************************************************

ShouldUseExFuncsByDriver

WNV1: If you don't call the Ex funcs, memory will get corrupted.

WINX: If you don't call the Ex funcs, it'll play upside down

I420, IYUV, M263, M26X:
This function was created to work around bug 257820 and bug 259129.  Both 
bugs are in the Windows Bugs database.  Bug 257820's title is "B2: USB: I420 
codec causes video to replay upside down.".  Bug 259129's title is "B2:USB: 
IYUV codec causes upside down preview in GraphEdit".  Both bugs occur because
the MSH263.DRV codec can produce upside-down bitmaps.  The bug occurs when the 
AVI Decompressor does not specify a source rectangle or target rectangle and it
asks MSH263.DRV to output top-down RGB bitmaps.

******************************************************************************/

bool CAVIDec::ShouldUseExFuncsByDriver( HIC hic, const BITMAPINFOHEADER * lpbiSrc, const BITMAPINFOHEADER * lpbiDst )
{
    // WNV1 will corrupt memory in 24 bit upside down without Ex called
    if( lpbiSrc->biCompression == '1VNW' )
    {
        return true;
    }

    // WINX will play upside down without Ex called
    if( lpbiSrc->biCompression == 'XNIW' )
    {
        return true;
    }

    // all output types serviced by MSH263.drv need fixing. But we don't
    // want to call ICGetInfo over and over again, so we need to test the
    // input types that MSH263 offers first
    if( 
        lpbiSrc->biCompression == '024I' ||
        lpbiSrc->biCompression == 'VUYI' ||
        lpbiSrc->biCompression == '362M' ||
        lpbiSrc->biCompression == 'X62M' ||
        0 ) // just to make the above lines look nice.
    {
        // Is this a top-down DIBs (negative height) bitmap?
        if( lpbiDst->biHeight >= 0 ) {
            return false;
        }

        // Are we outputing non-RGB bitmaps?
        if( (BI_RGB != lpbiDst->biCompression ) && (BI_BITFIELDS != lpbiDst->biCompression ) ) {
            return false;
        }        

        // Determine if we are using the MSH263.DRV decoder. 
        ICINFO infoDecompressor;
        infoDecompressor.dwSize = sizeof(ICINFO);

        ASSERT( m_hic != 0 );
        LRESULT lr = ICGetInfo( hic, &infoDecompressor, sizeof(infoDecompressor) );

        // ICGetInfo() returns 0 if an error occurs.  The worst that can happen if this 
        // fails is that the video may be upside-down.  Since upside-down video is better
        // than no video we will ignore the failure.  For more information see 
        // CAVIDec::ShouldUseExFuncsByDriver()'s function comment.
        if( 0 == lr ) {
            return false;
        }

        const WCHAR MSH263_DRIVER_NAME[] = L"MS H.263";

        // lstrcmpiW() returns 0 if the two strings match.
        if( 0 != lstrcmpiW( infoDecompressor.szName, MSH263_DRIVER_NAME ) ) {
            return false;
        }

        DbgLog((LOG_TRACE,2,TEXT("MSH263 detected, using Ex funcs")));

        return true;
    }

    // default is no...
    //
    return false;
}

#pragma warning(disable:4514)   // inline function removed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\co\property.cpp ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.

// !!!    all.reg

#include <streams.h>
#include <vfw.h>

#include <olectl.h>

#include "co.h"
#include "resource.h"


#ifdef WANT_DIALOG

CICMProperties::CICMProperties(LPUNKNOWN pUnk,HRESULT *phr) :
    CUnknown(NAME("ICM Property Page"),pUnk),
    m_hwnd(NULL),
    m_Dlg(NULL),
    m_pPageSite(NULL),
    m_bDirty(FALSE),
    m_pICM(NULL)
{
    ASSERT(phr);
    DbgLog((LOG_TRACE,1,TEXT("*** Instantiating the Property Page")));
}


/* Create a video properties object */

CUnknown *CICMProperties::CreateInstance(LPUNKNOWN lpUnk,HRESULT *phr)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::CreateInstance")));
    return new CICMProperties(lpUnk,phr);
}


/* Expose our IPropertyPage interface */

STDMETHODIMP
CICMProperties::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    if (riid == IID_IPropertyPage) {
        DbgLog((LOG_TRACE,1,TEXT("Prop::QI for IPropertyPage")));
        return GetInterface((IPropertyPage *)this,ppv);
    } else {
        DbgLog((LOG_TRACE,1,TEXT("Prop::QI for ???")));
        return CUnknown::NonDelegatingQueryInterface(riid,ppv);
    }
}


/* Handles the messages for our property window */

BOOL CALLBACK CICMProperties::ICMDialogProc(HWND hwnd,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam)
{
    static CICMProperties *pCICM;

    switch (uMsg) {

        case WM_INITDIALOG:

    	    DbgLog((LOG_TRACE,1,TEXT("Initializing the Dialog Box")));
            pCICM = (CICMProperties *) lParam;
            pCICM->m_bDirty = FALSE;
            pCICM->m_Dlg = hwnd;
            return (LRESULT) 1;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

		case ID_OPTIONS:
		    DbgLog((LOG_TRACE,1,TEXT("You pressed the magic button!")));
		    // Is m_pICM initialized for sure?
		    ASSERT(pCICM->m_pICM);
	    	    if (pCICM->m_pICM->ICMChooseDialog(pCICM->m_hwnd) == S_OK)
            		pCICM->m_bDirty = TRUE;	// so what?
	    }
            return (LRESULT) 0;
    }
    return (LRESULT) 0;
}


/* Tells us the object that should be informed of the property changes */

STDMETHODIMP CICMProperties::SetObjects(ULONG cObjects,LPUNKNOWN *ppUnk)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,1,TEXT("Prop::SetObjects")));

    if (cObjects == 1) {
        DbgLog((LOG_TRACE,2,TEXT("Getting the IICMOptions interface")));

        if ((ppUnk == NULL) || (*ppUnk == NULL)) {
            return E_POINTER;
        }

        ASSERT(m_pICM == NULL);

        // Ask the CO filter for it's ICMOptions interface.  This is how we are
	// going to communicate what happens in the dialog box to the filter.

        HRESULT hr = (*ppUnk)->QueryInterface(IID_IICMOptions,
						(void **)&m_pICM);
        if (FAILED(hr)) {
            return E_NOINTERFACE;
        }

        ASSERT(m_pICM);

    } else if (cObjects == 0) {
        DbgLog((LOG_TRACE,2,TEXT("Releasing the IICMOptions interface")));

        /* Release the interface */

        if (m_pICM == NULL) {
            return E_UNEXPECTED;
        }

        m_pICM->Release();
        m_pICM = NULL;

    } else {
        DbgLog((LOG_TRACE,2,TEXT("No support for more than one object")));
        return E_UNEXPECTED;
    }
    return NOERROR;
}


/* Get the page info so that the page site can size itself */

STDMETHODIMP CICMProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    WCHAR szTitle[] = L"Compression";

    DbgLog((LOG_TRACE,1,TEXT("Prop::GetPageInfo")));

    /* Allocate dynamic memory for the property page title */

    LPOLESTR pszTitle = (LPOLESTR) QzTaskMemAlloc(sizeof(szTitle));
    if (pszTitle == NULL) {
        return E_OUTOFMEMORY;
    }

    memcpy(pszTitle,szTitle,sizeof(szTitle));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;
    pPageInfo->size.cx          = 76;	// 76;	// !!! get out the measure tape
    pPageInfo->size.cy          = 155;	// 155;	// !!!
    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;
}


/* Create the window we will use to edit properties */

STDMETHODIMP CICMProperties::Activate(HWND hwndParent,
                                        LPCRECT pRect,
                                        BOOL fModal)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::Activate - creating dialog")));

    m_hwnd = CreateDialogParam(g_hInst,
                               MAKEINTRESOURCE(IDD_ICMPROPERTIES),
                               hwndParent,
                               ICMDialogProc,
                               (LPARAM)this);
    if (m_hwnd == NULL) {
        return E_OUTOFMEMORY;
    }
    DbgLog((LOG_TRACE,1,TEXT("Created window %ld"), m_hwnd));

    Move(pRect);
    Show(SW_SHOW);
    return NOERROR;
}


/* Set the position of the property page */

STDMETHODIMP CICMProperties::Move(LPCRECT pRect)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::Move")));

    if (m_hwnd == NULL) {
        return E_UNEXPECTED;
    }

    MoveWindow(m_hwnd,
               pRect->left,
               pRect->top,
               pRect->right - pRect->left,
               pRect->bottom - pRect->top,
               TRUE);

    return NOERROR;
}


/* Display the property dialog */

STDMETHODIMP CICMProperties::Show(UINT nCmdShow)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::Show")));

    if (m_hwnd == NULL) {
        return E_UNEXPECTED;
    }

    ShowWindow(m_hwnd,nCmdShow);
    InvalidateRect(m_hwnd,NULL,TRUE);

    return NOERROR;
}


/* Destroy the property page dialog */

STDMETHODIMP CICMProperties::Deactivate(void)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::Deactivate - destroy the dialog")));

    if (m_hwnd == NULL) {
        return(E_UNEXPECTED);
    }

    /* Destroy the dialog window */

    DestroyWindow(m_hwnd);
    m_hwnd = NULL;
    return NOERROR;
}


/* Tells the application property page site */

STDMETHODIMP CICMProperties::SetPageSite(LPPROPERTYPAGESITE pPageSite)
{
    DbgLog((LOG_TRACE,1,TEXT("Prop::SetPageSite - whatever")));

    if (pPageSite) {

        if (m_pPageSite) {
            return(E_UNEXPECTED);
        }

        m_pPageSite = pPageSite;
        m_pPageSite->AddRef();

    } else {

        if (m_pPageSite == NULL) {
            return(E_UNEXPECTED);
        }

        m_pPageSite->Release();
        m_pPageSite = NULL;
    }
    return NOERROR;
}


/* Apply any changes so far made */

STDMETHODIMP CICMProperties::Apply()
{
    /* Has anything changed */

    if (m_bDirty == TRUE) {
	// !!! We have nothing to do. Can we get rid of the APPLY button?
        m_bDirty = FALSE;
    }
    return NOERROR;
}
#endif	// #ifdef WANT_DIALOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\safeseh.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL BeginScarySEH(PVOID pvShared);
extern void EndScarySEH(PVOID pvShared);

#define HEAP_SHARED 0x04000000

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\msvidkey.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       msvidkey.h
//
//  Classes:    n/a
//
//  Contents:   MS Video Codec Keying Mechanism.
//
//  History:    04/01/99     BrianCri    Initial version.
//              05/03/99     BrianCri    Added keying for MP43
//
//--------------------------------------------------------------------------

#ifndef __MSSKEY_H__
#define __MSSKEY_H__

#define MSSKEY_VERSION        1
#define MSMP43KEY_VERSION     1

//
// Use __uuidof( MSSKEY_V1 ) to assign to guidKey!
//

struct __declspec(uuid("65218BA2-E85C-11d2-A4E0-0060976EA0C3")) MSSKEY_V1;
struct __declspec(uuid("B4C66E30-0180-11d3-BBC6-006008320064")) MSMP43KEY_V1;

struct MSVIDUNLOCKKEY
{
    DWORD   dwVersion;
    GUID    guidKey;   
};


#endif // __MSSKEY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\safeseh.c ===
/* Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved. */
//#define STRICT
#include <windows.h>
#include <safeseh.h>

//HANDLE g_hhpShared;
#ifdef _X86_

/*
 *  The trampoline is a small stub that we put up in shared memory
 *  which merely jumps to the real exception handler.  Why do we
 *  do this?  Because on Windows 95, if you take an exception while
 *  the Win16 lock is held, Kernel32 will not dispatch to any
 *  private-arena exception handlers.  This rule is enforced because
 *  application exception handlers are not Win16-lock-aware; if we
 *  let them run, they won't release the Win16 lock and your system
 *  would hang.
 *
 *  And then DirectDraw showed up and broke all the rules by letting
 *  Win32 apps take the Win16 lock.
 *
 *  By putting our handler in the shared arena, we are basically saying,
 *  "We are Win16 lock-aware; please include me in the exception chain."
 *
 *  Code courtesy of RaymondC
 */
#pragma pack(1)
typedef struct TRAMPOLINE {
    BYTE bPush;
    DWORD dwTarget;
    BYTE bRet;
} TRAMPOLINE, LPTRAMPOLINE;
#pragma pack()

/*
 *  Warning!  This code must *NOT* be called if we are running on NT!
 */
BOOL BeginScarySEH(PVOID pvShared)
{
     BOOL bRet;

    _asm {
        mov     eax, pvShared;
	test    eax, eax;
	jz	failed;			/* Out of memory */

	xor	ecx, ecx;		/* Keep zero handy */
	mov	[eax].bPush, 0x68;	/* push immed32 */
	mov	ecx, fs:[ecx];		/* ecx -> SEH frame */
	mov	edx, [ecx][4];		/* edx = original handler */
	mov	[eax].dwTarget, edx;	/* Revector it */
	mov	[eax].bRet, 0xC3;	/* retd */
	mov	[ecx][4], eax;		/* Install the trampoline */
failed:;
        mov     bRet, eax
    }
    return bRet;
}

/*
 *  DO NOT CALL THIS IF BeginScarySEH FAILED!
 */
void EndScarySEH(PVOID pvShared)
{
    _asm {
	xor	edx, edx;		/* Keep zero handy */
	mov	ecx, fs:[edx];		/* ecx -> SEH frame */
	mov	eax, [ecx][4];		/* eax -> trampoline */
	mov	eax, [eax].dwTarget;	/* Extract original handler */
	mov	[ecx][4], eax;		/* Unvector it back */
    }
}

#if 0
void Mumble(void)
{
    if (BeginScarySEH()) {
	__try {
	    OutputDebugString("About to raise exception\r\n");
	    RaiseException(1, 0, 0, 0);
	} __except (EXCEPTION_EXECUTE_HANDLER) {
	    OutputDebugString("Inside exception handler\r\n");
	}
	EndScarySEH();
    }
}

int __cdecl main(int argc, char **argv)
{
    /* Do this once, at app startup; if it fails, abort */
    g_hhpShared = HeapCreate(HEAP_SHARED, 1, 0);
    if (g_hhpShared) {
	Mumble();

	/* Don't forget to do this, or you will leak memory */
	HeapDestroy(g_hhpShared);
    } else {
    }
    return 0;
}
#endif

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\dec\dec.h ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudAVIDec;

//
// Prototype NDM wrapper for old video codecs
//

#if 0 //-- now in uuids.h
// Class ID for CAVIDec object
// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}
DEFINE_GUID(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70);
#endif

class CAVIDec : public CVideoTransformFilter   DYNLINKVFW
{
public:

    CAVIDec(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVIDec();

    DECLARE_IUNKNOWN

    // override to create an output pin of our derived class
    CBasePin *GetPin(int n);

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(
                const CMediaType* mtIn,
                const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts
    // and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overridden to know when we're streaming to the codec
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();

    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // special case the VMR.
    HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
    HRESULT BreakConnect(PIN_DIRECTION dir);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);

private:

    HIC m_hic;	// current codec

    BOOL m_fTemporal;	// codec needs one read-only buffer because it
			// needs the previous frame bits undisturbed

    // the fourCC used to open m_hic
    FOURCC m_FourCCIn;

    // have we called ICDecompressBegin ?
    BOOL m_fStreaming;

    // do we need to give a format change to the renderer?
    BOOL m_fPassFormatChange;

    BOOL m_bUseEx;

    // same at the output pin's connected mt, except biHeight may be inverted.
    CMediaType m_mtFixedOut;

    VIDEOINFOHEADER * IntOutputFormat( ) { return (VIDEOINFOHEADER*) m_mtFixedOut.Format(); }
    VIDEOINFOHEADER * OutputFormat( ) { return (VIDEOINFOHEADER*) m_pOutput->CurrentMediaType().Format(); }
    VIDEOINFOHEADER * InputFormat() { return (VIDEOINFOHEADER*) m_pInput->CurrentMediaType().Format(); }

    friend class CDecOutputPin;

    // checks the output format, and if necessary, sets to -biHeight on m_mtFixedOut
    void CheckNegBiHeight(void); 

    // helper function, used by CheckTransform and CheckNegBiHeight
    BOOL IsYUVType( const AM_MEDIA_TYPE * pmt);

    // get the src/target rects, fill out with width/height if necessary
    void GetSrcTargetRects( const VIDEOINFOHEADER * pVIH, RECT * pSource, RECT * pTarget );

    // ask if we should use the ex functions or not. called by CheckTransform and StartStreaming
    BOOL ShouldUseExFuncs( HIC hic, const VIDEOINFOHEADER * pVIHin, const VIDEOINFOHEADER * pVIHout );

    // another function that takes care of exceptional drivers
    bool ShouldUseExFuncsByDriver( HIC hic, const BITMAPINFOHEADER * lpbiSrc, const BITMAPINFOHEADER * lpbiDst );

    bool m_fToRenderer;         // VMR downstream?

#ifdef _X86_
    //  HACK HACK for exception handling on win95
    HANDLE m_hhpShared;
    PVOID  m_pvShared;
#endif // _X86_
};

// override the output pin class to do our own decide allocator
class CDecOutputPin : public CTransformOutputPin
{
public:

    DECLARE_IUNKNOWN

    CDecOutputPin(TCHAR *pObjectName, CTransformFilter *pTransformFilter,
        				HRESULT * phr, LPCWSTR pName) :
        CTransformOutputPin(pObjectName, pTransformFilter, phr, pName) {};

    ~CDecOutputPin() {};

    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\avimidi.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

/* AVI MIDI stream renderer	*/
/*     CMIDIFilter class	*/
/*       Danny Miller		*/
/*        July 1995		*/

#include <streams.h>
#include <mmsystem.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <vfw.h>
#include "midif.h"
#include "avimidi.h"

// ------------------------------------------------------------------------
// setup data


// input pin
const AMOVIESETUP_MEDIATYPE
sudMIDIPinTypes =
{
  &MEDIATYPE_Midi,            // MajorType
  &MEDIASUBTYPE_NULL         // MinorType
};

const AMOVIESETUP_PIN
sudMIDIPin =
{
  L"Input",                     // strName
  TRUE,                         // bRenderered
  FALSE,                        // bOutput
  FALSE,                        // bZero
  FALSE,                        // bMany
  &CLSID_NULL,		        // connects to filter // !!!
  NULL,                         // connects to pin
  1,                            // nMediaTypes
  &sudMIDIPinTypes              // lpMediaType
};

const AMOVIESETUP_FILTER
sudMIDIRender =
{
  &CLSID_AVIMIDIRender,         // clsID
  L"MIDI Renderer",             // strName
  MERIT_PREFERRED,              // dwMerit
  1,                            // nPins
  &sudMIDIPin                   // lpPin
};


#ifdef FILTER_DLL
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
    { L"MIDI Renderer"
    , &CLSID_AVIMIDIRender
    , CMIDIFilter::CreateInstance
    , NULL
    , &sudMIDIRender }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif

/* This goes in the factory template table to create new instances */

CUnknown *CMIDIFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CMIDIFilter *pFilter = new CMIDIFilter(pUnk, phr);
    if (!pFilter)
	*phr = E_OUTOFMEMORY;
    else if (FAILED(*phr)) {
	delete pFilter;
	pFilter = NULL;
    }
    return pFilter;
}

//
// IBaseFilter stuff
//

//
// Return the number of input pins we support */
//
int CMIDIFilter::GetPinCount()
{
    DbgLog((LOG_TRACE,3,TEXT("GetPinCount: We have 1 pin")));
    return 1;
}

//
// Return our single input pin - addrefed by caller if needed
//
//
CBasePin *CMIDIFilter::GetPin(int n)
{
    DbgLog((LOG_TRACE,3,TEXT("GetPin: %d"), n));

    // We only support one input pin and it is number zero
    if (n != 0) {
        return NULL;
    }

    // Made in our constructor, so we know it's around
    return m_pInputPin;
}


//
// The filter has been told to stop playing
//
STDMETHODIMP CMIDIFilter::Stop()
{
    FILTER_STATE m_OldState = m_State;

    DbgLog((LOG_TRACE,1,TEXT("Stop:")));

    // before we take the CritSect
    m_fWaitingForData = FALSE;

    // This code is part of our critical section
    CAutoLock lock(this);

    HRESULT   hr;

    // If we are not stopped,
    // CBaseFilter::Stop changes the state, and then calls
    // CMIDIInputPin::Inactive which calls CAllocator::Decommit which
    // calls CAllocator::Free and thus everything shuts down.

    // stop first, before doing our stuff, so that the rest of the code knows
    // we're stopped and shutting MIDI down
    hr =  CBaseFilter::Stop();

    if (m_OldState != State_Stopped) {

	// We're stopping, no need to worry about EOS anymore. Reset
	m_fEOSReceived = FALSE;
	m_fEOSDelivered = FALSE;

	if (m_hmidi) {
	    DbgLog((LOG_TRACE,1,TEXT("calling midiOutReset")));
	    midiOutReset((HMIDIOUT)m_hmidi);

            // !!! What if a receive is happening right now? It might go through
	    // now and give MMYSTEM a buffer which will never come back, and
	    // we'll hang.

	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamClose")));
	    midiStreamClose(m_hmidi);
	    m_hmidi = NULL;
	}

	// now force the buffer count back to the normal
	// at this point, we are sure there are no more buffers coming in
	// and no more buffers waiting for callbacks.
	m_lBuffers = 0;

    }

    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}

//
// The filter has been told to pause playback
//
STDMETHODIMP CMIDIFilter::Pause()
{
    DbgLog((LOG_TRACE,1,TEXT("Midi filter pausing:")));

    // This code is part of our critical section
    CAutoLock lock(this);

    HRESULT hr = NOERROR;

    if (m_State == State_Running) {
	DbgLog((LOG_TRACE,1,TEXT("Pause: when running")));

	// Next time we're run, send another EC_COMPLETE if we're at EOS
	m_fEOSDelivered = FALSE;

	if (m_hmidi) {
	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamPause")));
	    midiStreamPause(m_hmidi);
	}
    } else if (m_State == State_Stopped) {
	DbgLog((LOG_TRACE,1,TEXT("Pause: when stopped")));

	// Start things off by opening the device.  You may think this belongs
	// in the allocator stuff, since that does everything else, like
	// preparing headers, writing to the the device, etc., but the filter
	// needs to know the midi device handle too, for starting and stopping
	// it, and the allocator doesn't know what filter this is to give it
	// that information, but we know what allocator our pin is using.  So
	// we will open the device here, give the hmidi to the allocator, and
	// the allocator will do everything else.
	if (m_pInputPin->IsConnected()) {	// otherwise we'll blow up
	    HRESULT hr = OpenMIDIDevice();
	    if (FAILED(hr)) {
		// We will fail silently
	        // This will trigger Receive to fail and Run to send EC_COMPLETE
	        m_fEOSReceived = TRUE;
	    } else {
		// we aren't done the pause until we get some data
	        m_fWaitingForData = TRUE;
		DbgLog((LOG_TRACE, 2, "Midi - waiting now TRUE (from PAUSE)"));
	        hr = CBaseFilter::Pause();
	        if (hr == NOERROR)
		    return S_FALSE;
	        else
		    return hr;
	    }
	}
    } else {
	DbgLog((LOG_TRACE,2,TEXT("Midi must have been paused already")));
    }

    // If we are in stopped state,
    // CBaseFilter::Pause changes the state, and then calls
    // CMIDIInputPin::Active which calls CAllocator::Commit which
    // calls CAllocator::Alloc and thus everything gets set up.
    return CBaseFilter::Pause();

}

//
// The filter has been told to start playback at a particular time
//
STDMETHODIMP CMIDIFilter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,1,TEXT("Run:")));

    // This code is part of our critical section
    CAutoLock lock(this);

    // We're not finished pausing yet
    while (m_fWaitingForData) {
	// !!! this might happen after EndFlush and before we get new data
	Sleep(1);
    }

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;

    // !!! I'm ignoring the start time!
    // We should postpone this restart until the correct
    // start time. That means knowing the stream at which we paused
    // and having an advise for (just before) that time. ???

    // this will call ::Pause if currently Stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    // We have seen EOS, so running is pointless. Send EC_COMPLETE if we
    // haven't done so yet
    if (m_fEOSReceived) {
	m_csEOS.Lock();
	if (!m_fEOSDelivered) {
            DbgLog((LOG_TRACE,1,TEXT("::Run signals EC_COMPLETE")));
            NotifyEvent(EC_COMPLETE, S_OK, 0);
	}
	m_fEOSDelivered = TRUE;
	m_csEOS.Unlock();
    } else if (fsOld != State_Running) {
	if (m_hmidi) {
	    // Tell MIDI to start playing
	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamRestart")));
	    midiStreamRestart(m_hmidi);
	}
    }

    return NOERROR;
}

//
// Open the MIDI device, and set the tempo from the format
// Called by the allocator at Commit time
//
STDMETHODIMP CMIDIFilter::OpenMIDIDevice(void)
{
    // the format was set during connection negotiation by the base class
    MIDIFORMAT *pmf = (MIDIFORMAT *) m_pInputPin->m_mt.Format();
    MIDIPROPTIMEDIV mptd;
    UINT	    uDeviceID = (UINT)-1;

    // Sends callbacks to our function when buffers are done
    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamOpen")));
    UINT err = midiStreamOpen(&m_hmidi,
                           &uDeviceID,
                           1,
                           (DWORD_PTR) &CMIDIFilter::MIDICallback,
                           (DWORD_PTR) this,
                           CALLBACK_FUNCTION);

    if (err != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error %u in midiStreamOpen"), err));
	m_hmidi = NULL;
        return E_FAIL;
    }

    // The format of a MIDI stream is just the time division (the tempo).
    // Set the proper tempo.
    mptd.cbStruct  = sizeof(mptd);
    mptd.dwTimeDiv = pmf->dwDivision;
    DbgLog((LOG_TRACE,1,TEXT("Setting time division to %ld"),mptd.dwTimeDiv));
    if (midiStreamProperty(m_hmidi, (LPBYTE)&mptd,
			MIDIPROP_SET|MIDIPROP_TIMEDIV) != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error setting time division, closing device")));
	midiStreamClose(m_hmidi);
	m_hmidi = NULL;
	return E_FAIL;
    }

    return NOERROR;
}

/* PUBLIC Member functions */


#pragma warning(disable:4355)

//
// Constructor
//
CMIDIFilter::CMIDIFilter(LPUNKNOWN pUnk, HRESULT *phr)
    : CBaseFilter(NAME("AVI MIDI Filter"), pUnk, (CCritSec *) this, CLSID_AVIMIDIRender),
      m_pImplPosition(NULL),
      m_lBuffers(0),
      m_fEOSReceived(FALSE),
      m_fEOSDelivered(FALSE),
      m_fWaitingForData(FALSE)

{

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFilter constructor")));

    m_hmidi = NULL;

    // Create the single input pin
    m_pInputPin = new CMIDIInputPin(
                            this,                   // Owning filter
                            phr,                    // Result code
                            L"AVI MIDI Input pin"); // Pin name

    if (!m_pInputPin) {
	DbgLog((LOG_ERROR,1,TEXT("new CMIDIInput pin failed!")));
	// OLE will not have returned an error code in this case.
	*phr = E_OUTOFMEMORY;
    }

    // Just call me paranoid.
    if (m_pInputPin && FAILED(*phr)) {
	DbgLog((LOG_ERROR,1,TEXT("new CMIDIINput pin failed!")));
	delete m_pInputPin;
	m_pInputPin = NULL;
    }
}

//
// Destructor
//
CMIDIFilter::~CMIDIFilter()
{

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFilter destructor")));

    ASSERT(m_hmidi == NULL);

    /* Delete the contained interfaces */

    if (m_pInputPin) {
        delete m_pInputPin;
    }

    if (m_pImplPosition) {
	delete m_pImplPosition;
    }
}

//
// Override this to say what interfaces we support and where
//
STDMETHODIMP CMIDIFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IPersist) {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for IPersist")));
        return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for position")));
	if (!m_pImplPosition) {
            HRESULT hr = S_OK;
	    // This helper class does ALL THE WORK of passing position
	    // requests back to the source filter which is the one who
	    // really cares about such stuff.
            m_pImplPosition = new CPosPassThru(
                                    NAME("MIDI CPosPassThru"),
                                    GetOwner(),
                                    &hr,
                                    (IPin *)m_pInputPin);
	    if (!m_pImplPosition) {
		DbgLog((LOG_ERROR,1,TEXT("new CPosPassThru failed!")));
		// OLE will not have returned an error code in this case.
		return E_OUTOFMEMORY;
	    }
	    // That's me, Mr. Paranoid
            if (FAILED(hr)) {
		DbgLog((LOG_ERROR,1,TEXT("new CPosPassThru failed!")));
                delete m_pImplPosition;
                m_pImplPosition = NULL;
                return hr;
            }
	}
	return m_pImplPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for ???")));
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

//
// Override this if your state changes are not done synchronously
//
STDMETHODIMP CMIDIFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE,4,TEXT("::GetState wait for %ldms"), dwMSecs));
    CheckPointer( State, E_POINTER );

    // We are in an intermediate state.  Give ourselves dwMSecs ms to steady
    while (m_fWaitingForData && dwMSecs > 10) {
	Sleep(10);
	dwMSecs -= 10;
    }
    DbgLog((LOG_TRACE,4,TEXT("::GetState done waiting")));

    *State = m_State;
    if (m_fWaitingForData) {
	// guess we didn't steady in time
	DbgLog((LOG_TRACE, 2, "Midi getstate returning INTERMEDIATE"));
        return VFW_S_STATE_INTERMEDIATE;
    } else {
        return S_OK;
    }
}

// Pin stuff

//
// Constructor: Remember what filter we're attached to.
//
CMIDIInputPin::CMIDIInputPin(CMIDIFilter *pFilter, HRESULT *phr,
							LPCWSTR pPinName)
    : CBaseInputPin(NAME("AVI MIDI Pin"), pFilter, pFilter, phr, pPinName)
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIInputPin constructor")));
    m_pFilter = pFilter;
    m_fFlushing = FALSE;
}

//
// Destructor
//
CMIDIInputPin::~CMIDIInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIInputPin destructor")));
    // Release our allocator if we made one
}

//
// return the allocator interface that this input pin
// would like the output pin to use, or, if we've already been
// assigned an allocator, just return that one.
//
STDMETHODIMP CMIDIInputPin::GetAllocator(IMemAllocator ** ppAllocator)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,3,TEXT("CMIDIInputPin::GetAllocator")));

    // We shouldn't be asked this question before getting connected to
    // somebody.
    if (!IsConnected()) {
	DbgLog((LOG_TRACE,3,TEXT("Sorry, not connected yet")));
	return E_FAIL;
    }

    // Well, we don't have a preference; we don't have an allocator
    if (ppAllocator)
        *ppAllocator = NULL;
    return E_NOINTERFACE;
}

//
// We are being told to use this allocator
//
STDMETHODIMP CMIDIInputPin::NotifyAllocator(
    IMemAllocator *pAllocator)
{
    HRESULT hr;             // General OLE return code

    DbgLog((LOG_TRACE,3,TEXT("NotifyAllocator:")));

    // The base class will remember this allocator, and free the old one
    // Should we always signal that the samples are to be read only?
    hr = CBaseInputPin::NotifyAllocator(pAllocator,TRUE);
    if (FAILED(hr)) {
        return hr;
    }

    // Actually, we don't care.
    return NOERROR;
}


//
// This is called when a connection or an attempted connection is terminated
// and allows us to do anything we want besides releasing the allocator and
// connected pin.
// We will reset our media type to NULL, so we can use that as an indicator
// as to whether we're connected or not.
// !!! So what!  Is this necessary? Probably not
// !!! We leave the format block alone as it will be reallocated if we get
// another connection or alternatively be deleted if the filter is finally
// released - look at CMediaType
//
HRESULT CMIDIInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE,2,TEXT("BreakConnect:")));

    // This just checks to see if the major type is already GUID_NULL
    if (m_mt.IsValid() == FALSE) {
        return E_FAIL;
    }

    // !!! Should we check that all buffers have been freed?

    // Set the CLSIDs of the connected media type to nothing
    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    // This will do absolutely nothing
    return CBaseInputPin::BreakConnect();
}

//
// Check that we can support a given proposed media type
//
HRESULT CMIDIInputPin::CheckMediaType(const CMediaType *pmt)
{

    MIDIFORMAT *pmf = (MIDIFORMAT *) pmt->Format();
    DbgLog((LOG_TRACE,2,TEXT("CheckMediaType:")));
    DbgLog((LOG_TRACE,2,TEXT("Format length %d"),pmt->FormatLength()));

    #ifdef DEBUG

    /* Dump the GUID types */

    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));

    /* Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->FormatLength()));

    #endif

    // Verify that majortype is MIDI
    if (pmt->majortype != MEDIATYPE_Midi) {
	return E_INVALIDARG;
    }

    // Verify that the format is the right length
    if (pmt->FormatLength() < sizeof(MIDIFORMAT))
	return E_INVALIDARG;

    #ifdef DEBUG

    /* Dump the contents of the MIDIFORMAT type-specific format structure */

    DbgLog((LOG_TRACE,2,TEXT("Format dwDivision=%ld"), pmf->dwDivision));

    #endif

    // Just assume that we can accept whatever the format is

    DbgLog((LOG_TRACE,2,TEXT("Accepting the media type")));

    return NOERROR;
}


// Implements the remaining IMemInputPin virtual methods

//
// Here's the next block of data from the stream
// We need to AddRef it since we're not blocking until we're done with it.
// We will release it in the MIDI callback when MMSYSTEM is done with it.
//
HRESULT CMIDIInputPin::Receive(IMediaSample * pSample)
{
    DbgLog((LOG_TRACE,3,TEXT("Receive:")));

    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive

    CAutoLock lock(m_pFilter);

    // we're flushing and don't want any receives
    if (m_fFlushing) {
        DbgLog((LOG_TRACE,2,TEXT("can't receive, flushing")));
	return VFW_E_WRONG_STATE;
    }

    // what are we doing receiving data after we were promised no more would be
    // sent?
    if (m_pFilter->m_fEOSReceived) {
        DbgLog((LOG_TRACE,2,TEXT("can't receive, already seen EOS")));
	return E_UNEXPECTED;
    }

    // if we're stopped, then reject this call
    // (the filter graph may be in mid-change)
    if (m_pFilter->m_State == State_Stopped) {
	DbgLog((LOG_TRACE,2,TEXT("can't receive, stopped")));
        return E_FAIL;
    }

    // If this was a "play from 10 to 10" the video wants to draw it, but
    // we don't want to play any MIDI data.
    CRefTime tStart, tStop;
    pSample->GetTime((REFERENCE_TIME *) &tStart,
                     (REFERENCE_TIME *) &tStop);
    if (tStop <= tStart) {
	return S_OK;
    }

    HRESULT hr = NOERROR;

    // This will verify that we are receiving valid MIDI data
    hr = CBaseInputPin::Receive(pSample);
    // S_FALSE or an error code both mean we aren't receiving samples.
    if (hr != S_OK) {
	DbgLog((LOG_ERROR,1, TEXT("can't receive, base class unhappy")));
        return hr;
    }

    // !!! We're ignoring pre-roll!

    // The sample we get contains a MIDIHDR, the keyframe data, a MIDIHDR, and
    // this frame's data.  Typically, we only need to send the second buffer.
    // Before we send it, we'll have to patch the header with the proper
    // lpData and dwBufferSize. We also have to Prepare it now, because
    // we didn't know until now what part of the buffer we'd need to send.
    // Remember to set dwUser to pSample to retrieve it later.
    BYTE *pData;
    pSample->GetPointer(&pData);
    ASSERT(pData != NULL);

    // Each sample that comes to us is actually 2 headers and buffers
    // in a row.  The first is key frame data, which we only need if
    // we play non-contiguously.  The second one is the one we want.
    // Then adjust the actual bytes written
    LPMIDIHDR pmh = (LPMIDIHDR)pData;

    // This is not simply the next sample in a contiguous group.  So we need
    // to throw out keyframe data to the MIDI device.  This frame is a keyframe,
    // that much is guaranteed by Quartz, but we keep the keyframe data
    // separate and have to know that we need to use it.
    if (pSample->IsDiscontinuity() == S_OK && pmh->dwBufferLength) {

        DbgLog((LOG_TRACE,1, TEXT("Not continuous.  Sending a KEYFRAME")));

        // we have to set the USER word so we know which sample this came from
        pmh->dwUser = (DWORD_PTR)pSample;

	hr = SendBuffer(pmh);

	if (FAILED(hr)) {
	    return hr;
	}
    }

    // Now skip to the second buffer in the sample, the actual data (the first
    // buffer is the keyframe data).
    pmh = (LPMIDIHDR)((LPBYTE)(pmh + 1) + pmh->dwBufferLength);

    // we have to set the USER word so we know which sample this came from
    pmh->dwUser = (DWORD_PTR)pSample;

    hr = SendBuffer(pmh);

    m_pFilter->m_fWaitingForData = FALSE;

    /* Return the status code */
    return hr;
}

// No more data is coming. If we have samples queued, then store this for
// action in the last MIDI callback. If there are no samples, then action
// it now by notifying the filtergraph.
//
// Once we run out of buffers, we can signal EC_COMPLETE if we've seen EOS
STDMETHODIMP CMIDIInputPin::EndOfStream(void)
{
    // we're flushing and don't want any receives
    if (m_fFlushing) {
        DbgLog((LOG_TRACE,1,TEXT("don't care about EOS, flushing")));
	return VFW_E_WRONG_STATE;
    }

    // not supposed to do anything if we're stopped
    if (m_pFilter->m_State == State_Stopped) {
        DbgLog((LOG_TRACE,1,TEXT("don't care about EOS, stopped")));
	return VFW_E_WRONG_STATE;
    }

    DbgLog((LOG_TRACE,1,TEXT("EndOfStream received")));

    // do this before taking the CritSect
    m_pFilter->m_fWaitingForData = FALSE;

    m_pFilter->m_fEOSReceived = TRUE;

    // no outstanding buffers, OK to deliver EC_COMPLETE if running
    m_pFilter->m_csEOS.Lock();
    if (m_pFilter->m_lBuffers == 0 && m_pFilter->m_fEOSDelivered == FALSE &&
	    			m_pFilter->m_State == State_Running) {

        DbgLog((LOG_TRACE,1,TEXT("EndOfStream signals EC_COMPLETE")));
        m_pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);

	m_pFilter->m_fEOSDelivered = TRUE;
    }
    m_pFilter->m_csEOS.Unlock();

    // else there are some buffers outstanding, and on release of the
    // last buffer the MIDI callback will signal.

    return S_OK;
}

// enter flush state - block receives and free queued data
STDMETHODIMP CMIDIInputPin::BeginFlush(void)
{
    DbgLog((LOG_TRACE,1,TEXT("BeginFlush received")));

    // do this before taking the CritSect
    m_pFilter->m_fWaitingForData = FALSE;

    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive

    CAutoLock lock(m_pFilter);

    // don't allow any more receives
    m_fFlushing = TRUE;

    HRESULT hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) {
	return hr;
    }

    // discard queued data

    // force end-of-stream clear
    m_pFilter->m_fEOSReceived = FALSE;
    m_pFilter->m_fEOSDelivered = FALSE;

    // release all buffers from the driver
    if (m_pFilter->m_hmidi) {
	DbgLog((LOG_TRACE,1,TEXT("calling midiOutReset")));
	midiOutReset((HMIDIOUT)m_pFilter->m_hmidi);

        // !!! What if a receive is happening right now? It might go through
	// now and MMSYSTEM will never give the buffer back, and we'll hang

	// Now that we've called Reset, we'll never be able to Restart the MIDI
	// stream without closing and re-opening it (MMSYSTEM bug)
	DbgLog((LOG_TRACE,1,TEXT("calling midiStreamClose (begin flush)")));
	midiStreamClose(m_pFilter->m_hmidi);
	m_pFilter->m_hmidi = NULL;
    }

    // now force the buffer count back to normal
    // at this point, we are sure there are no more buffers coming in
    // and no more buffers waiting for callbacks.
    m_pFilter->m_lBuffers = 0;

    // free anyone blocked on receive - not possible in this filter

    // call downstream -- no downstream pins
    return S_OK;
}

// leave flush state - ok to re-enable receives
STDMETHODIMP CMIDIInputPin::EndFlush(void)
{
    HRESULT hr = NOERROR, hr2;

    DbgLog((LOG_TRACE,1,TEXT("EndFlush received")));

    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream
    // --- we did this in BeginFlush()

    // call EndFlush on downstream pins -- no downstream pins

    // We're ready to Receive data again.  If we're not stopped, we need
    // to re-open the MIDI device.  If we are stopped, pausing will open it
    // for us.
    if (m_pFilter->m_State != State_Stopped) {
	hr = m_pFilter->OpenMIDIDevice();
	if (FAILED(hr)) {
	    // something wrong? Make sure Receive's fail, and EC_COMPLETE is
	    // sent if we try and run, but otherwise pretend it's OK
	    m_pFilter->m_fEOSReceived = TRUE;
	    hr = NOERROR;
	} else {
	    ASSERT(m_pFilter->m_State == State_Paused);
	    // can't run until we get some data
	    // !!! The filtergraph won't hold off the run until we're ready
	    m_pFilter->m_fWaitingForData = TRUE;
	}
    }

    m_fFlushing = FALSE;

    // unblock Receives
    hr2 = CBaseInputPin::EndFlush();

    if (FAILED(hr)) {
	return hr;
    } else {
	return hr2;
    }
}

//
// Our pin has become active.  Nothing needs to happen here.  The output pin
// is the one who will allocate all the buffers.
//
HRESULT CMIDIInputPin::Active(void)
{
    DbgLog((LOG_TRACE,3,TEXT("Active: nothing to do")));

    // this doesn't do a darn thing
    return CBaseInputPin::Active();
}

//
// Our pin has become inactive.  Nothing needs to happen here either. The
// output pin is the one who will free all the buffers
//
HRESULT CMIDIInputPin::Inactive(void)
{
    DbgLog((LOG_TRACE,3,TEXT("Inactive: nothing to do")));

    // this won't do a darn thing
    return CBaseInputPin::Inactive();
}

HRESULT CMIDIInputPin::SendBuffer(LPMIDIHDR pmh)
{
    // Back when we set up these headers we didn't know the buffer size
    // yet, so set it now.
    pmh->lpData = (LPSTR)(pmh + 1);

    DbgLog((LOG_TRACE,3, TEXT("This buffer has length %ld"), pmh->dwBufferLength));
	
    // There's nothing to send
    if (pmh->dwBufferLength == 0)
	return NOERROR;

    DbgLog((LOG_TRACE,3, TEXT("Preparing header")));
    UINT err = midiOutPrepareHeader((HMIDIOUT)m_pFilter->m_hmidi, pmh,
							sizeof(MIDIHDR));
    if (err != MMSYSERR_NOERROR) {
	DbgLog((LOG_ERROR,1,TEXT("Error %d from midiOutPrepareHeader"),err));
	return E_FAIL;
    }

    // note that we have added another buffer
    InterlockedIncrement(&m_pFilter->m_lBuffers);

    DbgLog((LOG_TRACE,3, TEXT("midiStreamOut: sample %x  %d bytes"),
					pmh->dwUser, pmh->dwBufferLength));
    // addref the sample BEFORE USING IT so we keep it until MMSYSTEM is done
    ((IMediaSample *)(pmh->dwUser))->AddRef();
    err = midiStreamOut(m_pFilter->m_hmidi, pmh, sizeof(MIDIHDR));
    if (err != MMSYSERR_NOERROR) {
	// device error: PCMCIA card removed?
	DbgLog((LOG_ERROR,1,TEXT("Error %d from midiStreamOut"), err));
	((IMediaSample *)(pmh->dwUser))->Release();
	return E_FAIL;
    } else {
	return NOERROR;
    }
}

//
// MMSYSTEM will callback to this function whenever it's done with a buffer.
// dwUser parameter is the CMIDIFilter pointer
//
void CALLBACK CMIDIFilter::MIDICallback(HDRVR hdrvr, UINT uMsg,
				DWORD dwUser, DWORD dw1, DWORD dw2)
{
    switch (uMsg) {
	case MOM_DONE:
	{
	    LPMIDIHDR lpmh = (LPMIDIHDR) dw1;

	    IMediaSample * pSample = (IMediaSample *) lpmh->dwUser;

	    DbgLog((LOG_TRACE,3,TEXT("MIDIOutCallback: sample %x  %ld bytes"),
						pSample, lpmh->dwBufferLength));

            CMIDIFilter* pFilter = (CMIDIFilter *)dwUser;
            ASSERT(pFilter);

	    // if we are getting callbacks because of a midiOutReset, then
	    // we already have the critical section, so we better not try
	    // and take it now!
	
	    // First, unprepare this buffer
	    UINT err = midiOutUnprepareHeader((HMIDIOUT)pFilter->m_hmidi, lpmh,
							sizeof(*lpmh));
	    if (err != MMSYSERR_NOERROR) {
		// Ok, now what? - don't worry, won't happen
	    }

            // is this the end of stream and are we out of buffers?
	    // If so, we're supposed to signal EC_COMPLETE
	    pFilter->m_csEOS.Lock();
	    if (InterlockedDecrement(&pFilter->m_lBuffers) == 0 &&
			pFilter->m_fEOSReceived && !pFilter->m_fEOSDelivered) {
        	DbgLog((LOG_TRACE,1,TEXT("Callback signals EC_COMPLETE")));
                pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);
		pFilter->m_fEOSDelivered = TRUE;
            }
	    pFilter->m_csEOS.Unlock();

	    // This will call CMemAllocator::PutOnFreeList
	    if (pSample)	// necessary to avoid a TurtleBeach bug
	        pSample->Release();
	    else
        	DbgLog((LOG_ERROR,1,TEXT("NOT RELEASING SAMPLE! Turtle beach bug?")));

	}
	    break;

	case WOM_OPEN:
	case WOM_CLOSE:
	    break;

	default:
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\draw\coverlay.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

/*

    Methods for COverlayOutputPin

*/

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <vfw.h>
#endif

#include <dynlink.h>
#include "draw.h"

/*
    COverlayOutputPin constructor
*/
COverlayOutputPin::COverlayOutputPin(
    TCHAR              * pObjectName,
    CAVIDraw 	       * pFilter,
    HRESULT            * phr,
    LPCWSTR              pPinName) :

    CTransformOutputPin(pObjectName, pFilter, phr, pPinName),
    m_OverlayNotify(NAME("Overlay notification interface"), pFilter, NULL, phr),
    m_bAdvise(FALSE),
    m_pOverlay(NULL),
    m_pFilter(pFilter)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the Overlay pin")));
}

COverlayOutputPin::~COverlayOutputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Overlay pin")));
};


// can we connect to this guy?
//
HRESULT COverlayOutputPin::CheckConnect(IPin *pPin)
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayOutputPin::CheckConnect")));

    // we don't connect to anyone who doesn't support IOverlay.
    // after all, we're an overlay pin
    HRESULT hr = pPin->QueryInterface(IID_IOverlay, (void **)&m_pOverlay);

    if (FAILED(hr)) {
        return E_NOINTERFACE;
    } else {
	m_pOverlay->Release();
	m_pOverlay = NULL;
    }

    return CBaseOutputPin::CheckConnect(pPin);
}


/*
    Say if we're prepared to connect to a given input pin from
    this output pin
*/

STDMETHODIMP COverlayOutputPin::Connect(IPin *pReceivePin,
                                        const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayOutputPin::Connect")));

    /*  Call the base class to make sure the directions match! */
    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if (FAILED(hr)) {
        return hr;
    }
    /*  We're happy if we can get an IOverlay interface */

    hr = pReceivePin->QueryInterface(IID_IOverlay,
                                     (void **)&m_pOverlay);

    // we were promised this would work
    ASSERT(SUCCEEDED(hr));

    hr = m_pOverlay->Advise(&m_OverlayNotify,
			(m_pFilter->m_fScaryMode ? ADVISE_CLIPPING : 0) |
 			ADVISE_PALETTE | ADVISE_POSITION);

    /*
        We don't need to hold on to the IOverlay pointer
        because BreakConnect will be called before the receiving
        pin goes away.
    */


    if (FAILED(hr)) {
	// !!! not quite right, but this shouldn't happen
        Disconnect();
	pReceivePin->Disconnect();
        return hr;
    } else {
        m_bAdvise = TRUE;
    }

    return hr;
}


// !!! The base classes change all the time and I won't pick up their bug fixes!
HRESULT COverlayOutputPin::BreakConnect()
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayOutputPin::BreakConnect")));

    if (m_pOverlay != NULL) {
        if (m_bAdvise) {
            m_pOverlay->Unadvise();
            m_bAdvise = FALSE;
        }
        m_pOverlay->Release();
        m_pOverlay = NULL;
    }

    // we've broken our connection, so next time we reconnect don't allow
    // repainting until we've actually drawn something in the first place
    m_pFilter->m_fOKToRepaint = FALSE;

    m_pFilter->BreakConnect(PINDIR_OUTPUT);
    return CBaseOutputPin::BreakConnect();
}


// Override this because we don't want any allocator!
HRESULT COverlayOutputPin::DecideAllocator(IMemInputPin * pPin,
                        IMemAllocator ** pAlloc) {
    /*  We just don't want one so everything's OK as it is */
    return S_OK;
}


// Return the IOverlay interface we are using (AddRef'd)

IOverlay *COverlayOutputPin::GetOverlayInterface()
{
    if (m_pOverlay) {
        m_pOverlay->AddRef();
    }
    return m_pOverlay;
}




//=========================================================================//
//***			I N T E R M I S S I O N				***//
//=========================================================================//




/*
        IOverlayNotify
*/

COverlayNotify::COverlayNotify(TCHAR              * pName,
                               CAVIDraw 	  * pFilter,
                               LPUNKNOWN            pUnk,
                               HRESULT            * phr) :
    CUnknown(pName, pUnk)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating COverlayNotify")));
    m_pFilter = pFilter;
    m_hrgn = CreateRectRgn(0, 0, 0, 0);
}


COverlayNotify::~COverlayNotify()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying COverlayNotify")));
    if (m_hrgn)
        DeleteObject(m_hrgn);
}


STDMETHODIMP COverlayNotify::NonDelegatingQueryInterface(REFIID riid,
                                                         void ** ppv)
{
    DbgLog((LOG_TRACE,99,TEXT("COverlayNotify::QueryInterface")));
    if (ppv)
	*ppv = NULL;

    /* Do we have this interface */

    if (riid == IID_IOverlayNotify) {
        return GetInterface((LPUNKNOWN) (IOverlayNotify *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP_(ULONG) COverlayNotify::NonDelegatingRelease()
{
    return m_pFilter->Release();
}


STDMETHODIMP_(ULONG) COverlayNotify::NonDelegatingAddRef()
{
    return m_pFilter->AddRef();
}


STDMETHODIMP COverlayNotify::OnColorKeyChange(
    const COLORKEY *pColorKey)          // Defines new colour key
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayNotify::OnColorKeyChange")));

// We expect the draw handler to handle colour key stuff, so I'm really
// hoping that the renderer will never draw the colour key itself.

    return NOERROR;
}


// The calls to OnClipChange happen in sync with the window. So it's called
// with an empty clip list before the window moves to freeze the video, and
// then when the window has stabilised it is called again with the new clip
// list. The OnPositionChange callback is for overlay cards that don't want
// the expense of synchronous clipping updates and just want to know when
// the source or destination video positions change. They will NOT be called
// in sync with the window but at some point after the window has changed
// (basicly in time with WM_SIZE etc messages received). This is therefore
// suitable for overlay cards that don't inlay their data to the framebuffer

STDMETHODIMP COverlayNotify::OnClipChange(
    const RECT    * pSourceRect,         // Area of source video to use
    const RECT    * pDestinationRect,    // screen co-ords of window
    const RGNDATA * pRegionData)         // Header describing clipping
{
    POINT pt;
    BOOL fForceBegin = FALSE;

    // we're not even completely connected - don't waste my time!
    if (m_pFilter->m_pInput == NULL ||
			m_pFilter->m_pInput->IsConnected() == FALSE ||
            		m_pFilter->m_pOutput == NULL ||
			m_pFilter->m_pOutput->IsConnected() == FALSE) {
	return NOERROR;
    }

    // totally empty rectangles means that the window is being dragged, or
    // about to be clipped.  We'll be informed of the new position after
    // it's finished moving.  Besides, drivers will blow up with empty rects.
    if (IsRectEmpty(pSourceRect) && IsRectEmpty(pDestinationRect))
	return NOERROR;

    // I get lots of these before the window is visible, and responding to
    // them bogs the system down and kills performance
    if (m_pFilter->m_hwnd && !IsWindowVisible(m_pFilter->m_hwnd))
	return NOERROR;

    // sometimes the video renderer tells us to draw offscreen!
    if (pDestinationRect->left >= GetSystemMetrics(SM_CXSCREEN) ||
			pDestinationRect->top >= GetSystemMetrics(SM_CYSCREEN))
	return NOERROR;

    // get the hwnd as soon as possible, and as soon as it's visible, start
    // partying - we need the rectangles as soon as possible for ICDrawBegin
    // !!! Danger! This will hang if called after play is pressed. (I can't make
    // any calls on the video window during an ::OnClipChange callback)
    if (!m_pFilter->m_fStreaming && !m_pFilter->m_hwnd) {
        m_pFilter->GetRendererHwnd();
	fForceBegin = TRUE;	// give new HDC to handler on next begin
    }

    // !!!

    // I'm seeing some REPAINT ONLY's coming with new rectangles. ???

    // I get way too many of these.  I even get some CLIP CHANGES while the
    // window is invisible, but such is life.

    // If the window moves but does not need repainting, I will still repaint
    // needlessly, not knowing. I don't know how I can tell.

    // !!!

    // Don't let any other ICDraw calls be made during OnClipChange
    // We can't use the m_csReceive crit sec or we WILL deadlock
    // (if they sit in fPauseBlocked when a clip change comes thru)
    //DbgLog((LOG_TRACE,3,TEXT("OnClipChange wants the draw lock")));
    m_pFilter->m_csICDraw.Lock();

    ASSERT(m_pFilter->m_hic);

    BOOL fRectChanged = !EqualRect(&m_pFilter->m_rcTarget, pDestinationRect);
    BOOL fRepaintOnly = FALSE;

    m_pFilter->m_rcSource = *pSourceRect;
    m_pFilter->m_rcTarget = *pDestinationRect;
    m_pFilter->m_rcClient = *pDestinationRect;	// default

    HRGN hrgn;
    if (pRegionData) {
        hrgn = ExtCreateRegion(NULL, pRegionData->rdh.dwSize +
			pRegionData->rdh.nRgnSize, pRegionData);
    } else {
	hrgn = NULL;
    }

    // The image renderer doesn't distinguish between a clip change and
    // only needing to repaint (we may have invalidated ourselves), so we have
    // to figure it out. If we do anything besides repaint when there hasn't
    // been a real clip change, we could infinite loop.

    if (!hrgn || EqualRgn(hrgn, m_hrgn)) {

    	DbgLog((LOG_TRACE,3,TEXT("COverlayNotify::OnClipChange - REPAINT ONLY")));
        fRepaintOnly = TRUE;
    } else {
        DbgLog((LOG_TRACE,3,TEXT("COverlayNotify::OnClipChange - CLIP CHANGE")));
    }

    if (hrgn) {
	if (m_hrgn)
	    DeleteObject(m_hrgn);
        m_hrgn = hrgn;
    }

    // We need to repaint.  If we're running, just have us do it
    // next time we're drawing anyway, otherwise, specifically do it
    // now.  If that fails, better get the graph to send us the data
    // again.
    if (m_pFilter->m_State == State_Running) {
        m_pFilter->m_fNeedUpdate = TRUE;
    } else {
	DWORD_PTR dw;
	// If we're not streaming, we haven't called ICDrawBegin yet, and
	// we can't, because we don't have our formats yet, so we can't call
	// ICDraw().
	if (m_pFilter->m_fStreaming) {
            dw = ICDraw(m_pFilter->m_hic, ICDRAW_UPDATE, NULL, NULL, 0,
    				            m_pFilter->m_lFrame);
	} else {
	    dw = (DWORD_PTR)ICERR_ERROR;
	}

	// better not try and repaint by pushing data through the pipe if
	// we're not connected!  Better also not if we have no source rect,
	// that means we aren't showing yet (I think).
        if (dw != ICERR_OK &&
			m_pFilter->m_pOutput->CurrentMediaType().IsValid() &&
			!IsRectEmpty(pSourceRect) && m_pFilter->m_hwnd &&
	    		IsWindowVisible(m_pFilter->m_hwnd)) {
	    // We couldn't update by ourselves, better ask for a repaint
	    // !!! We have the ICDraw lock, is that OK?
	    // Use fOKToRepaint to avoid the 1 million repaints we would get
	    // before we've even drawn anything at all in the first place?
	    // !!! try even harder to avoid doing this
	    // !!! I would love to avoid unnecessary repaints, but I've done 
	    // all I can.  Unless I repaint here, apps that open up the file
	    // and don't run it will never see the first frame drawn (eg MCIQTZ)
	    if (1 || m_pFilter->m_fOKToRepaint) {
    	        DbgLog((LOG_TRACE,2,TEXT("Asking FilterGraph for a REPAINT!")));
	        m_pFilter->NotifyEvent(EC_REPAINT, 0, 0);
	    }
        }
    }

// There's no reason we should have to do this, and if we do, we're still
// broken because we need to do the GetBuffersWantedStuff after the new
// Begin
#if 0
    // Why is this necessary?
    // we appear to need a fresh DC if the rect has changed.  Don't do this
    // if we just got the DC from GetRendererHwnd a second ago.  Be sure
    // to do this after the ICDraw call above that repainted, because we
    // can't go calling DrawEnd and then Draw!
    if (!fForceBegin && fRectChanged && m_pFilter->m_hwnd) {
	if (m_pFilter->m_fStreaming) {	// we're actually inside a DrawBegin
	    ICDrawEnd(m_pFilter->m_hic);// we'll be doing a new Begin next
	}

	// We seem to need a new hdc whenever the window moves
	if (m_pFilter->m_hdc)
	    ReleaseDC(m_pFilter->m_hwnd, m_pFilter->m_hdc);
        m_pFilter->m_hdc = GetDC(m_pFilter->m_hwnd);
    	DbgLog((LOG_TRACE,4,TEXT("Time for a new DC")));
        if (!m_pFilter->m_hdc) {
    	    DbgLog((LOG_ERROR,1,TEXT("***Lost our DC!")));
    	    m_pFilter->m_csICDraw.Unlock();
	    return E_UNEXPECTED;
	}
    }
#endif

    DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		pSourceRect->left, pSourceRect->top,
		pSourceRect->right, pSourceRect->bottom));
    DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		pDestinationRect->left, pDestinationRect->top,
		pDestinationRect->right, pDestinationRect->bottom));

    // convert destination to client co-ords

    if (m_pFilter->m_hdc && GetDCOrgEx(m_pFilter->m_hdc, &pt)) {
        //DbgLog((LOG_TRACE,2,TEXT("Fixing CLIENT by %d"), pt.x));
        m_pFilter->m_rcClient.left = pDestinationRect->left - pt.x;
        m_pFilter->m_rcClient.right = pDestinationRect->right - pt.x;
        m_pFilter->m_rcClient.top = pDestinationRect->top - pt.y;
        m_pFilter->m_rcClient.bottom = pDestinationRect->bottom - pt.y;
    } else if (m_pFilter->m_hdc) {
	// !!! NT seems to fail GetDCOrgEx unless I get a fresh hdc just before
 	// calling it. Oh well.
	HDC hdc = GetDC(m_pFilter->m_hwnd);
        if (GetDCOrgEx(hdc, &pt)) {
            //DbgLog((LOG_TRACE,1,TEXT("Take 2:Fixing CLIENT by %d"), pt.x));
            m_pFilter->m_rcClient.left = pDestinationRect->left - pt.x;
            m_pFilter->m_rcClient.right = pDestinationRect->right - pt.x;
            m_pFilter->m_rcClient.top = pDestinationRect->top - pt.y;
            m_pFilter->m_rcClient.bottom = pDestinationRect->bottom - pt.y;
	} else {
	    ASSERT(FALSE);	// !!!
	}
	ReleaseDC(m_pFilter->m_hwnd, hdc);
    }

    // We gave ourselves a chance to get the renderer hwnd and repaint, all done
    // If we continue and call ICDrawWindow, we could infinite loop
    if (fRepaintOnly && !fRectChanged) {
        //DbgLog((LOG_TRACE,3,TEXT("OnClipChange wants draw lock no more")));
    	m_pFilter->m_csICDraw.Unlock();
	return NOERROR;
    }

// This got around the NT bug above, but is uglier and wrong
#if 0
    if (m_pFilter->m_fStreaming && (fRectChanged || fForceBegin)) {

	// !!! What about fullscreen?
        DbgLog((LOG_TRACE,2,TEXT("Calling ICDrawBegin with hdc %d"),
							m_pFilter->m_hdc));
	ICDrawBegin(m_pFilter->m_hic, ICDRAW_HDC, NULL, /* !!! hpal from OnPaletteChange? */
		m_pFilter->m_hwnd, m_pFilter->m_hdc,
		m_pFilter->m_rcClient.left, m_pFilter->m_rcClient.top,
		m_pFilter->m_rcClient.right - m_pFilter->m_rcClient.left,
		m_pFilter->m_rcClient.bottom - m_pFilter->m_rcClient.top,
		HEADER(m_pFilter->m_pInput->CurrentMediaType().Format()),
		m_pFilter->m_rcSource.left, m_pFilter->m_rcSource.top,
		m_pFilter->m_rcSource.right - m_pFilter->m_rcSource.left,
		m_pFilter->m_rcSource.bottom - m_pFilter->m_rcSource.top,
		m_pFilter->m_dwRate, m_pFilter->m_dwScale);
	m_pFilter->m_fNewBegin = TRUE;
	// To give the new hdc to DrawDib
	ICDrawRealize(m_pFilter->m_hic, m_pFilter->m_hdc, FALSE /* !!! */);
	// !!! What about ICDrawFlush?

    }
#endif

    DbgLog((LOG_TRACE,2,TEXT("ICDrawWindow (%d,%d,%d,%d)"),
		m_pFilter->m_rcTarget.left,
		m_pFilter->m_rcTarget.top,
		m_pFilter->m_rcTarget.right,
		m_pFilter->m_rcTarget.bottom));
    ICDrawWindow(m_pFilter->m_hic, &m_pFilter->m_rcTarget);

    // This seems to keep the palette from flipping out
    if (m_pFilter->m_fStreaming && (fRectChanged || fForceBegin)) {
	ICDrawRealize(m_pFilter->m_hic, m_pFilter->m_hdc, FALSE /* !!! */);
    }

    //DbgLog((LOG_TRACE,3,TEXT("OnClipChange wants the draw lock no longer")));
    m_pFilter->m_csICDraw.Unlock();
    return NOERROR;
}


STDMETHODIMP COverlayNotify::OnPaletteChange(
    DWORD dwColors,                     // Number of colours present
    const PALETTEENTRY *pPalette)       // Array of palette colours
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayNotify::OnPaletteChange")));

    if (m_pFilter->m_hic)
        ICDrawRealize(m_pFilter->m_hic, m_pFilter->m_hdc, FALSE /* !!! */);

    return NOERROR;
}


STDMETHODIMP COverlayNotify::OnPositionChange(
    const RECT *pSourceRect,            // Area of video to play with
    const RECT *pDestinationRect)       // Area video goes
{
    DbgLog((LOG_TRACE,3,TEXT("COverlayNotify::OnPositionChange - calling OnClipChange")));
    return OnClipChange(pSourceRect, pDestinationRect, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\avimidi.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/* This is a renderer that can play MIDI data as found in AVI files */
/* (not quite what you'd find in a .MID file)			    */

/*            Danny Miller            	*/
/*              July 1995             	*/

extern const AMOVIESETUP_FILTER sudMIDIRender;

/* 07b65360-c445-11ce-afde-00aa006c14f4 */

DEFINE_GUID(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4);

class CMIDIFilter;

/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CMIDIInputPin : public CBaseInputPin
{
    friend class CMIDIFilter;

private:

    CMIDIFilter *m_pFilter;         // The renderer that owns us

public:

    CMIDIInputPin(CMIDIFilter *pMIDIFilter, HRESULT *phr, LPCWSTR pPinName);

    ~CMIDIInputPin();

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType *pmt);

    /* Send a MIDI buffer to MMSYSTEM */
    HRESULT SendBuffer(LPMIDIHDR pmh);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // no more data is coming
    STDMETHODIMP EndOfStream(void);

    // flush our queued data
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);

    // flushing, ignore all receives
    BOOL	m_fFlushing;
};

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and IMediaFilter and has a single input stream (pin)

   It will also (soon ??? !!!) support IDispatch to allow it to expose some
   simple properties....

*/

class CMIDIFilter : public CBaseFilter, public CCritSec
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
	

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

public:

    CMIDIFilter(LPUNKNOWN pUnk, HRESULT *phr);
    virtual ~CMIDIFilter();

    // open the MIDI device - called when our filter becomes active
    STDMETHODIMP OpenMIDIDevice(void);

    /* Return the pins that we support */

    int GetPinCount();
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

private:

    /* The nested classes may access our private state */

    friend class CMIDIInputPin;

    /* Member variables */
    CMIDIInputPin *m_pInputPin;         /* IPin and IMemInputPin interfaces */

    HMIDISTRM m_hmidi;

    // handles IMediaPosition by passing upstream
    CPosPassThru * m_pImplPosition;

    static void MIDICallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
					DWORD dw1, DWORD dw2);

    // we have a long that counts the number of queued buffers, which we
    // access with InterlockedIncrement. It is initialised to 0,
    // incremented whenever a buffer is added, and then decremented whenever
    // a buffer is completed.
    LONG        m_lBuffers;

    // End of stream goop.
    BOOL	m_fEOSReceived;
    BOOL	m_fEOSDelivered;

    // need some data to complete the ::Pause
    volatile BOOL m_fWaitingForData;

    CCritSec	m_csEOS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\draw\draw.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// Prototype wrapper for old video decompressors
//
// This filter is based on the transform filter, but differs in that it doesn't
// use IMemInputPin to connect to the renderer, it uses IOverlay.  So we have
// to override all of the CTransform functions that would create an
// IMemInputPin output pin (and use it) and replace it with our IOverlay pin.
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#include <vfw.h>
#endif

#include <dynlink.h>
#include "draw.h"

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypesOutput =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_NULL        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput1 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_MJPG        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput2 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_TVMJ        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput3 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_WAKE        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput4 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_CFCC        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput5 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_IJPG        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput6 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_Plum        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput7 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_DVCS        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput8 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_DVSD        // Minor type
};

const AMOVIESETUP_MEDIATYPE sudPinTypesInput9 =
{
    &MEDIATYPE_Video,         // Major CLSID
    &MEDIASUBTYPE_MDVF        // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput1 },   // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput2 },   // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput3 },   // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput4 },   // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput5 },   // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput6 }, // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput7 }, // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput8 }, // Pin information
    { L"Input",            // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypesInput9 }, // Pin information
    { L"Output",             // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypesOutput }  // Pin information
};

const AMOVIESETUP_FILTER sudAVIDraw =
{
    &CLSID_AVIDraw,         // CLSID of filter
    L"AVI Draw",                // Filter's name
    MERIT_NORMAL+0x64,      // Filter merit
    sizeof(psudPins) / sizeof(AMOVIESETUP_PIN), // Number of pins
    psudPins                // Pin information
};


#ifdef FILTER_DLL
CFactoryTemplate g_Templates [1] = {
    { L"AVI Draw"
    , &CLSID_AVIDraw
    , CAVIDraw::CreateInstance
    , NULL
    , &sudAVIDraw }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
#endif


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

// --- CAVIDraw ----------------------------------------

CAVIDraw::CAVIDraw(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
    : CTransformFilter(pName, pUnk, CLSID_AVIDraw),
      m_hic(NULL),
      m_FourCCIn(NULL),
      m_fStreaming(FALSE),
      m_fInStop(FALSE),
      m_hwnd(NULL),
      m_hdc(NULL),
      m_dwRate(0),
      m_dwScale(0),
      m_fCueing(FALSE),
      m_fPauseBlocked(FALSE),
      m_fNeedUpdate(FALSE),
      m_dwAdvise(0),
      m_fOKToRepaint(FALSE),
      m_fPleaseDontBlock(FALSE),
      m_EventCueing(TRUE),
      m_fVfwCapInGraph(-1),
      m_lStart(-1)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the ICDraw filter")));
#ifdef DEBUG
    m_dwTime = timeGetTime();
#endif
    SetRect(&m_rcTarget, 0, 0, 0, 0);

    // Shall we get the renderer to use a WindowsHook and tell us clip
    // changes? (necessary only for inlay cards like T2K using its own
    // display card)
    m_fScaryMode = GetProfileInt(TEXT("ICDraw"), TEXT("ScaryMode"), TRUE);
}


CAVIDraw::~CAVIDraw()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the ICDraw filter")));

    if (m_hic) {

	// !!! the FAST MJPEG won't hide its overlay unless we do this!
	// closing their driver should be enough to make them hide it.
 	RECT rc;
	rc.top=0; rc.bottom=0; rc.left=0; rc.right = 0;
	ICDrawWindow(m_hic, &rc);

	ICClose(m_hic);
    }

    if (m_hdc && m_hwnd)
	ReleaseDC(m_hwnd, m_hdc);

}


STDMETHODIMP CAVIDraw::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    DbgLog((LOG_TRACE,99,TEXT("somebody's querying my interface")));

    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}


// this goes in the factory template table to create new instances
//
CUnknown * CAVIDraw::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CAVIDraw(TEXT("VFW ICDraw filter"), pUnk, phr);
}


#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

// check if you can support mtIn
//
HRESULT CAVIDraw::CheckInputType(const CMediaType* pmtIn)
{
    FOURCCMap fccHandlerIn;
    HIC hic;
    int i;
    ICINFO icinfo;
    char achDraw[_MAX_PATH];

    DbgLog((LOG_TRACE,2,TEXT("*::CheckInputType")));

    // We will refuse to connect to anything if the VFW capture filter is in
    // the graph, because we're talking to the same h/w, and we won't work!
    // The drivers don't report an error, they just draw black.
    if (m_fVfwCapInGraph == -1)
	m_fVfwCapInGraph = IsVfwCapInGraph();
    if (m_fVfwCapInGraph) {
        DbgLog((LOG_ERROR,1,TEXT("VFW Capture filter is in graph! ABORT!")));
	return E_UNEXPECTED;
    }

    if (pmtIn == NULL || pmtIn->Format() == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: NULL type/format")));
	return E_INVALIDARG;
    }

    // we only support MEDIATYPE_Video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

// This is fixed now
#if 0
    if (HEADER(pmtIn->Format())->biCompression == BI_RGB) {
	// FAST cards incorrectly say they do RGB!
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: format is uncompressed")));
        return E_INVALIDARG;
    }
#endif

    fccHandlerIn.SetFOURCC(pmtIn->Subtype());

    DbgLog((LOG_TRACE,3,TEXT("Checking fccType: %lx biCompression: %lx"),
		fccHandlerIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression));

    // Firstly try the one we may still have around from last time.  We may
    // get called several times in a row, and don't want to be inefficient.
    if (!m_hic || ICDrawQuery(m_hic, HEADER(pmtIn->Format())) != ICERR_OK) {

#ifdef DEBUG
	m_dwTimeLocate = timeGetTime();
#endif

	// Loop through all the vids handlers in the system
        for (i=0, hic=NULL; ICInfo(MKFOURCC('v','i','d','s'), i, &icinfo); i++)
        {
    	    DbgLog((LOG_TRACE,2,TEXT("Trying VIDS.%lx"), icinfo.fccHandler));

	    // We don't want to use DirectVideo (the whole purpose is to use
	    // HARDWARE handlers, so refuse to use anything that is
	    // vids.draw=x:\blah\blah\dvideo.dll
	    if (icinfo.fccHandler == 0x57415244 ||	// "DRAW"
					icinfo.fccHandler == 0x77617264) {

		// Give them an .ini switch to use DVideo
		if (!GetProfileInt(TEXT("ICDraw"), TEXT("TryDVideo"), FALSE)) {
    		    LPCSTR   lszCur;

		    // get the installed vids.draw handler path name
		    GetPrivateProfileStringA("drivers32", "VIDS.DRAW",
				"", achDraw, sizeof(achDraw), "system.ini");

		    // Now skip past the drive letter and path to get the
		    // filename part
    		    for (lszCur = achDraw + lstrlenA(achDraw);
				lszCur > achDraw && !SLASH(*lszCur) &&
					*lszCur != TEXT(':');
				lszCur--);
    		    if (lszCur != achDraw)
        		lszCur += 1;

		    if (lstrcmpiA(lszCur, "dvideo.dll") == 0) {
    	    	        DbgLog((LOG_TRACE,1,
				TEXT("****** Oops!  Don't use DVIDEO!")));
		        continue;
		    }
		}
	    }

            hic = ICOpen(MKFOURCC('v','i','d','s'), icinfo.fccHandler,
								ICMODE_DRAW);
	    if (!hic)
		// Many existing draw handlers will reject vids opens, so
		// we have to open them with vidc.
                hic = ICOpen(MKFOURCC('v','i','d','c'), icinfo.fccHandler,
								ICMODE_DRAW);

	    if (hic) {
	        if (ICDrawQuery(hic, HEADER(pmtIn->Format())) == ICERR_OK)
		    break;
		ICClose(hic);
		hic = NULL;
	    }
        }

	// well that didn't work.  I hate to do this, but some cards
	// install themselves as VIDC, so we may have to enumerate the VIDC
	// guys.  That takes way too long to do unless we have to, so we will
	// enumerate only the one we're told to (or all if it's blank)

	GetProfileStringA("ICDraw", "TryVIDC", "X", achDraw, sizeof(achDraw));

	// Try VIDC.MJPG - MIRO DC20 needs this
	if (hic == NULL) {
    	    DbgLog((LOG_TRACE,2,TEXT("Trying VIDC.MJPG")));

            hic = ICOpen(MKFOURCC('v','i','d','c'), MKFOURCC('M','J','P','G'),
								ICMODE_DRAW);
	    if (hic && ICDrawQuery(hic, HEADER(pmtIn->Format())) != ICERR_OK) {
		ICClose(hic);
		hic = NULL;
	    }
	}

	// Try VIDC.Plum - Plum needs this
	if (hic == NULL) {
    	    DbgLog((LOG_TRACE,2,TEXT("Trying VIDC.Plum")));

            hic = ICOpen(MKFOURCC('v','i','d','c'), MKFOURCC('P','l','u','m'),
								ICMODE_DRAW);
	    if (hic && ICDrawQuery(hic, HEADER(pmtIn->Format())) != ICERR_OK) {
		ICClose(hic);
		hic = NULL;
	    }
	}

// !!! Try TVMJ IJPG WAKE CFCC too?

	// Entry is blank?  Try them all
        for (i=0; achDraw[0] == 0 && hic == NULL &&
			ICInfo(MKFOURCC('v','i','d','c'), i, &icinfo); i++)
        {
    	    DbgLog((LOG_TRACE,2,TEXT("Trying VIDC.%lx"), icinfo.fccHandler));

            hic = ICOpen(MKFOURCC('v','i','d','c'), icinfo.fccHandler,
								ICMODE_DRAW);
	    if (hic) {
	        if (ICDrawQuery(hic, HEADER(pmtIn->Format())) == ICERR_OK)
		    break;
		ICClose(hic);
		hic = NULL;
	    }
        }

	// we are being told to try something specific
	if (hic == NULL && lstrcmpiA(achDraw, "X") != 0 && achDraw[0] != '\0') {
    	    DbgLog((LOG_TRACE,2,TEXT("Trying VIDC.%lx"), *(DWORD *)achDraw));

            hic = ICOpen(MKFOURCC('v','i','d','c'), *(DWORD *)achDraw,
								ICMODE_DRAW);
	    if (hic && ICDrawQuery(hic, HEADER(pmtIn->Format())) != ICERR_OK) {
		ICClose(hic);
		hic = NULL;
	    }
	}

#ifdef DEBUG
	m_dwTimeLocate = timeGetTime() - m_dwTimeLocate;
        m_dwTime = timeGetTime() - m_dwTime;
        DbgLog((LOG_ERROR,1,TEXT("*Locating a handler took %ldms"),
							m_dwTimeLocate));
        DbgLog((LOG_ERROR,1,TEXT("*This filter has been around for %ldms"),
							m_dwTime));
#endif
	if (hic == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Error: All handlers rejected it")));
	    return E_FAIL;
	} else {
    	    DbgLog((LOG_TRACE,2,TEXT("Format has been accepted")));
	    // Cache this new hic for next time, to save time.  If we're
	    // already connected, we're actually using this puppy, so don't
	    // nuke it!
	    if (!m_pInput->CurrentMediaType().IsValid()) {
	        if (m_hic)
		    ICClose(m_hic);
	        m_hic = hic;
	    } else {
		ICClose(hic);
	    }
	}
    } else {
    	DbgLog((LOG_TRACE,2,TEXT("The cached handler accepted it")));
    }

    return NOERROR;
}


// Is our Vfw Capture filter in the graph?
//
BOOL CAVIDraw::IsVfwCapInGraph()
{
    IEnumFilters *pFilters;

    if (m_pGraph == NULL) {
	DbgLog((LOG_ERROR,1,TEXT("No graph!")));
	return FALSE;
    }

    if (FAILED(m_pGraph->EnumFilters(&pFilters))) {
	DbgLog((LOG_ERROR,1,TEXT("EnumFilters failed!")));
	return FALSE;
    }

    IBaseFilter *pFilter;
    ULONG	n;
    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
	IAMVfwCaptureDialogs *pVFW;
	if (pFilter->QueryInterface(IID_IAMVfwCaptureDialogs, (void **)&pVFW)
								== NOERROR) {
	    pVFW->Release();
	    pFilter->Release();
    	    pFilters->Release();
	    return TRUE;
	}
        pFilter->Release();
    }
    pFilters->Release();
    return FALSE;
}


// check if you can support the transform from this input to this output
//
HRESULT CAVIDraw::CheckTransform(const CMediaType* pmtIn, const CMediaType* pmtOut)
{
    DbgLog((LOG_TRACE,2,TEXT("*::CheckTransform")));
    if (*pmtOut->Type() != MEDIATYPE_Video ||
				*pmtOut->Subtype() != MEDIASUBTYPE_Overlay)
	return E_INVALIDARG;
    return CheckInputType(pmtIn);
}


// overriden to know when the media type is actually set
//
HRESULT CAVIDraw::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    FOURCCMap fccHandler;

    if (direction == PINDIR_OUTPUT) {

        // Please call me if you hit this. - DannyMi
        ASSERT(!m_fStreaming);

        DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (output)")));
	return NOERROR;
    }

    ASSERT(direction == PINDIR_INPUT);

    // Please call me if you hit this. - DannyMi
    ASSERT(!m_fStreaming);

    DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (input)")));
    DbgLog((LOG_TRACE,2,TEXT("Input type is: biComp=%lx biBitCount=%d"),
				HEADER(m_pInput->CurrentMediaType().Format())->biCompression,
				HEADER(m_pInput->CurrentMediaType().Format())->biBitCount));

    // We better have one of these opened by now
    ASSERT(m_hic);

    // Calculate the frame rate of the movie
    LONGLONG time = ((VIDEOINFOHEADER *)
			(m_pInput->CurrentMediaType().Format()))->AvgTimePerFrame;
    m_dwScale = 1000;
    m_dwRate = DWORD(time ? UNITS * (LONGLONG)m_dwScale / time : m_dwScale);
    DbgLog((LOG_TRACE,2,TEXT("** This movie is %d.%.3d frames per second"),
			m_dwRate / m_dwScale, m_dwRate % m_dwScale));

    if (m_pOutput && m_pOutput->IsConnected()) {
        //DbgLog((LOG_TRACE,1,TEXT("***Changing IN when OUT already connected")));
        // DbgLog((LOG_TRACE,1,TEXT("Reconnecting the output pin...")));
	// not necessary because setting the input type does nothing, really
	// m_pGraph->Reconnect(m_pOutput);
    }

    return NOERROR;
}


// DecideBufferSize will be eaten by our output pin but is pure virtual so we
// must override.
//
HRESULT CAVIDraw::DecideBufferSize(IMemAllocator * pAllocator,
                                   ALLOCATOR_PROPERTIES *pProperties)
{
    return NOERROR;
}


HRESULT CAVIDraw::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE,3,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("NULL format, no can do")));
	return E_INVALIDARG;
    }
	
    // Output choices depend on the input connected
    if (!m_pInput->CurrentMediaType().IsValid()) {
        DbgLog((LOG_TRACE,3,TEXT("No input type set yet, no can do")));
	return E_FAIL;
    }

    if (iPosition <0) {
        return E_INVALIDARG;
    }

    if (iPosition >0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    // We set the BITMAPINFOHEADER to be a really basic eight bit palettised
    // format so that the video renderer will always accept it. We have to
    // provide a valid media type as source filters can swap between the
    // IMemInputPin and IOverlay transports as and when they feel like it

    BYTE aFormat[sizeof(VIDEOINFOHEADER) + SIZE_PALETTE];
    VIDEOINFOHEADER *pFormat = (VIDEOINFOHEADER *)aFormat;
    ZeroMemory(pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);
    // same size as the input stream
    pFormat->bmiHeader.biWidth  = HEADER(m_pInput->CurrentMediaType().Format())->biWidth;
    pFormat->bmiHeader.biHeight = HEADER(m_pInput->CurrentMediaType().Format())->biHeight;
    pFormat->bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);
    pFormat->bmiHeader.biPlanes = 1;
    pFormat->bmiHeader.biBitCount = 8;

    // Hack - use bitmapinfoheader for now!
    pmt->SetFormat((PBYTE)pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE);
    pmt->SetFormatType(&FORMAT_VideoInfo);

    if (pmt->pbFormat == NULL) {
        return E_OUTOFMEMORY;
    }

    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype   = MEDIASUBTYPE_Overlay;
    pmt->bFixedSizeSamples    = FALSE;
    pmt->bTemporalCompression = FALSE;
    pmt->lSampleSize          = 0;

    return NOERROR;
}


HRESULT CAVIDraw::GetRendererHwnd()
{
    ASSERT(m_pOutput);

    // no csReceive critsec or we'll hang
    HWND hwnd;

    DbgLog((LOG_TRACE,3,TEXT("CAVIDraw::GetRendererHwnd")));

    COverlayOutputPin *pOutput = (COverlayOutputPin *) m_pOutput;
    IOverlay *pOverlay = pOutput->GetOverlayInterface();
    if (pOverlay == NULL) {
        return E_FAIL;
    }

    // Get the window handle then release the IOverlay interface

    HRESULT hr = pOverlay->GetWindowHandle(&hwnd);
    pOverlay->Release();

    if (SUCCEEDED(hr) && hwnd != m_hwnd) {
        if (m_hdc)
            ReleaseDC(m_hwnd, m_hdc);
        m_hdc = NULL;
        m_hwnd = hwnd;
        if (m_hwnd)
            m_hdc = GetDC(m_hwnd);
       	DbgLog((LOG_TRACE,3,TEXT("Renderer gives HWND: %d  HDC: %d"),
							    m_hwnd, m_hdc));
    }
    return NOERROR;
}


HRESULT CAVIDraw::StartStreaming()
{
    CAutoLock lck(&m_csReceive);
    //DbgLog((LOG_TRACE,3,TEXT("StartStreaming wants the draw lock")));
    CAutoLock lck2(&m_csICDraw);
    DWORD_PTR err;

    DbgLog((LOG_TRACE,3,TEXT("*::StartStreaming")));

    if (!m_fStreaming) {

	ASSERT(m_hic);
	
	GetRendererHwnd();

        DbgLog((LOG_TRACE,3,TEXT("hwnd: %d  hdc: %d  rcSrc: (%ld, %ld, %ld, %ld)"),
		m_hwnd, m_hdc,
		m_rcSource.left, m_rcSource.top,
		m_rcSource.right, m_rcSource.bottom));
        DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		m_rcTarget.left, m_rcTarget.top,
		m_rcTarget.right, m_rcTarget.bottom));

	// !!! What about fullscreen?
        DbgLog((LOG_TRACE,3,TEXT("ICDrawBegin hdc=%d (%d,%d,%d,%d)"), m_hdc,
		m_rcClient.left,
		m_rcClient.top,
		m_rcClient.right,
		m_rcClient.bottom));
	err = ICDrawBegin(m_hic, ICDRAW_HDC, NULL, /* !!! hpal from ::OnPaletteChange? */
			m_hwnd, m_hdc,
			m_rcClient.left, m_rcClient.top,
			m_rcClient.right - m_rcClient.left,
			m_rcClient.bottom - m_rcClient.top,
			HEADER(m_pInput->CurrentMediaType().Format()),
			m_rcSource.left, m_rcSource.top,
			m_rcSource.right - m_rcSource.left,
			m_rcSource.bottom - m_rcSource.top,
			// !!! I know I'm passing these backwards, but MCIAVI
			// did (for the default draw handler only)
			m_dwScale, m_dwRate);
	m_fNewBegin = TRUE;

	if (err != ICERR_OK) {
            DbgLog((LOG_ERROR,1,TEXT("Error in ICDrawBegin")));
	    return E_FAIL;
	}

	ICDrawRealize(m_hic, m_hdc, FALSE /* !!! not sure */);

	// next NewSegment will have a new frame range
        m_lStart = -1;

	// If this message is supported, it means we need to send this many
	// buffers ahead of time
	if (ICGetBuffersWanted(m_hic, &m_BufWanted))
	     m_BufWanted = 0;
        DbgLog((LOG_TRACE,1,TEXT("Driver says %d buffers wanted"),m_BufWanted));

	m_fStreaming = TRUE;
    }

    //DbgLog((LOG_TRACE,3,TEXT("StartStreaming wants the draw lock no more")));
    return NOERROR;
}


HRESULT CAVIDraw::StopStreaming()
{
    CAutoLock lck(&m_csReceive);
    //DbgLog((LOG_TRACE,3,TEXT("StopStreaming wants the draw lock")));
    CAutoLock lck2(&m_csICDraw);

    DbgLog((LOG_TRACE,3,TEXT("*::StopStreaming")));

    if (m_fStreaming) {
	ASSERT(m_hic);

	// We're stopping the clock.. so the AdviseTime event won't go off and
	// we'll block forever!
	if (m_pClock && m_dwAdvise) {
    	    DbgLog((LOG_TRACE,3,TEXT("Firing the event we're blocked on")));
	    m_pClock->Unadvise(m_dwAdvise);
	    m_EventAdvise.Set();
	}

        DbgLog((LOG_TRACE,2,TEXT("ICDrawStopPlay")));
	ICDrawStopPlay(m_hic);

        DbgLog((LOG_TRACE,2,TEXT("ICDrawEnd")));
	ICDrawEnd(m_hic);

	// put this as close to the DrawEnd as possible, cuz that's what it
	// means
	m_fStreaming = FALSE;

	if (m_hdc && m_hwnd)
	    ReleaseDC(m_hwnd, m_hdc);
	m_hdc = NULL;
	m_hwnd = NULL;

    }
    //DbgLog((LOG_TRACE,3,TEXT("StopStreaming wants the draw lock no more")));
    return NOERROR;
}


CBasePin * CAVIDraw::GetPin(int n)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,5,TEXT("CAVIDraw::GetPin")));

    // Create an input pin if necessary

    if (n == 0 && m_pInput == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"Input");         // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pInput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Or alternatively create an output pin

    if (n == 1 && m_pOutput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new COverlayOutputPin(NAME("Overlay output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"Output");      // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pOutput == NULL) {
            delete m_pOutput;
            m_pOutput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    }
    return m_pOutput;
}

// The base class should assume we can block in Receive because we're not
// using IMemInputPin.


// !!! Watch out if the base class changes and it won't be reflected here
//
HRESULT CAVIDraw::Receive(IMediaSample *pSample)
{
    // we already hold the csReceive critsec.

    CRefTime tstart, tstop;

    ASSERT(pSample);

    // we haven't started streaming yet
    if (!m_fStreaming) {
        DbgLog((LOG_ERROR,1,TEXT("Can't receive, not streaming")));
	return E_UNEXPECTED;
    }

    // Don't let Stop be called and decide we aren't blocked on pause.
    // Because as soon as this thread continues, we WILL block and never
    // unblock because Stop completed already (ditto for BeginFlush)
    m_csPauseBlock.Lock();

    // But that doesn't help us if Stop has already been called before we
    // took the lock.  This tells us that Stop has happened and we can't
    // count on it to unblock us, so we better not block in the first place.
    // This could also be set if we're flushing and supposed to ignore all
    // Receives.
    if (m_fPleaseDontBlock) {
	DbgLog((LOG_TRACE,2,TEXT("*** Oops! Another thread is stopping or flushing!")));
        m_csPauseBlock.Unlock();
	return VFW_E_WRONG_STATE;
    }

    // We can't get the range being played until we've gotten some data
    if (m_lStart < 0) {

	// get the start and stop time in units
	LONGLONG start = m_pInput->CurrentStartTime();
	LONGLONG stop = m_pInput->CurrentStopTime();
        DbgLog((LOG_TRACE,2,TEXT("** start = %d stop = %d"), (int)start, 
								(int)stop));

	// convert to the range we're playing in milliseconds
	LONGLONG msStart = LONGLONG(start / 10000);
	LONGLONG msStop = LONGLONG(stop / 10000);

	// now get the range we're playing in frames
	// to avoid rounding errors, aim for the middle of a sample
        LONGLONG time = ((VIDEOINFOHEADER *)
		(m_pInput->CurrentMediaType().Format()))->AvgTimePerFrame / 10000;
	m_lStart = LONG((msStart + time / 2) * m_dwRate / (m_dwScale * 1000));
	m_lStop = LONG((msStop + time / 2) * m_dwRate / (m_dwScale * 1000));

        DbgLog((LOG_TRACE,2,TEXT("ICDrawStartPlay")));
	ICDrawStartPlay(m_hic, m_lStart, m_lStop);

        DbgLog((LOG_TRACE,1,TEXT("** We'll be playing from frame %d to %d"),
					m_lStart, m_lStop));
    }

    // we're paused.. we must block until unpaused and then use the new m_tStart
    // and continue (that's why this comes first)
    if (m_State == State_Paused && !m_fCueing) {
	m_fPauseBlocked = TRUE;
	DbgLog((LOG_TRACE,3,TEXT("Paused: blocking until running again")));
	// now that we've set m_fPauseBlocked, we can allow Stop to happen
	// Make sure to do this before blocking!
        m_csPauseBlock.Unlock();
	m_EventPauseBlock.Wait();
	// don't test for stopped, it won't be set yet and will still say paused
	if (m_State != State_Running) {
            DbgLog((LOG_TRACE,3,TEXT("Went from PAUSED to STOPPED, abort!")));
	    return VFW_E_WRONG_STATE;
	}
    } else {
	// We don't need this anymore
        m_csPauseBlock.Unlock();
    }

    // If something went wrong getting our window and hdc, we shouldn't continue
    if (!m_hdc) {
        DbgLog((LOG_ERROR,1,TEXT("NO HDC!  Erroring out, abort!")));
	return E_UNEXPECTED;
    }

    // When is this sample supposed to be drawn? And what frame is it?
    pSample->GetTime((REFERENCE_TIME *)&tstart, (REFERENCE_TIME *)&tstop);
    LONGLONG msStart = tstart.Millisecs();
    LONGLONG msStop = tstop.Millisecs();
    // aim for the middle of the frame to avoid rounding errors
    m_lFrame = LONG((msStop + msStart)  / 2 * m_dwRate / (m_dwScale * 1000));
    m_lFrame += m_lStart;	// now offset it from the frame we started at

    //DbgLog((LOG_TRACE,3,TEXT("*** DRAW frame %d at %dms"), m_lFrame, msStart));

    // codec not open ?
    if (m_hic == 0) {
        DbgLog((LOG_ERROR,1,TEXT("Can't receive, no codec open")));
	return E_UNEXPECTED;
    }

    // make sure we have valid input pointer

    BYTE * pSrc;
    HRESULT hr = pSample->GetPointer(&pSrc);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting input sample data")));
	return hr;
    }

    // !!! Could the source filter change our mtIn? Yes.  We would need to
    // call ICDrawChangePalette.  The size, compression type, etc. might
    // conceivably change, too.  If you do add an ICDraw call in here, put
    // the critsec around it.

    // get the BITMAPINFOHEADER structure, and fix biSizeImage
    LPBITMAPINFOHEADER lpbiSrc = HEADER(m_pInput->CurrentMediaType().Format());
    // patch the format to reflect this frame
    lpbiSrc->biSizeImage = pSample->GetActualDataLength();

    // We might want to send each frame a certain number of frames ahead of time
    //
    if (m_BufWanted) {
        LONGLONG time = ((VIDEOINFOHEADER *)
		(m_pInput->CurrentMediaType().Format()))->AvgTimePerFrame;
	tstart -= time * m_BufWanted;
    }

    // Now wait until it's time to draw.
    // Ask the clock to set an event when it's time to draw this sample.
    // Then wait for that event.  If we don't have a clock, just draw it
    // now.
    //
    if (m_pClock) {

	// If it's already time for this frame (or we're behind) don't waste
	// time Advising and Waiting
	REFERENCE_TIME curtime;
	m_pClock->GetTime((REFERENCE_TIME *)&curtime);

        DbgLog((LOG_TRACE,4,TEXT("*** DRAW frame %d in %dms"),
		m_lFrame - m_lStart,
		(int)((m_tStart + tstart - curtime) / 10000)));

	if (curtime < m_tStart + tstart) {
            hr = m_pClock->AdviseTime(
		// this was the reference time when our stream started playing
            	(REFERENCE_TIME) m_tStart,
		// this is the offset from our start time when the frame goes
		// !!! ask for a few usec early? (constant overhead?)
            	(REFERENCE_TIME) tstart,
            	(HEVENT)(HANDLE) m_EventAdvise,		// event to fire
            	&m_dwAdvise);                       	// Advise cookie
	    DbgLog((LOG_TRACE,5,TEXT("Waiting until it's time to draw")));

            if (SUCCEEDED(hr)) {
	        m_EventAdvise.Wait();
            } else {
	        DbgLog((LOG_TRACE,2,TEXT("AdviseTime ERROR, drawing now...")));
            }
            m_dwAdvise = 0;
	} else {
	    DbgLog((LOG_TRACE,5,TEXT("It's already time to draw this.")));
	}
    } else {
	DbgLog((LOG_TRACE,5,TEXT("No clock - draw it now.")));
    }

    // We need to make this mutex with COverlayNotify::OnClipChange calling any
    // ICDrawX API.  We can't use the m_csReceive crit sec or we WILL deadlock
    // (if we sit in fPauseBlocked when a clip change comes thru)
    //DbgLog((LOG_TRACE,3,TEXT("::Receive wants the draw lock")));
    m_csICDraw.Lock();

    // setting the right flags goes inside the crit sect lock because somebody
    // else grabbing the lock might change our mind about what to do
    BOOL dwFlags = 0;

    if (m_fNeedUpdate) {
        DbgLog((LOG_TRACE,5,TEXT("We need an UPDATE")));
 	dwFlags |= ICDRAW_UPDATE;
    }

    if (pSample->IsPreroll() == S_OK) {
        DbgLog((LOG_TRACE,5,TEXT("This is a preroll")));
 	dwFlags |= ICDRAW_PREROLL;
    }

    if (pSample->GetActualDataLength() <= 0) {
        DbgLog((LOG_TRACE,5,TEXT("This is a NULL frame")));
 	dwFlags |= ICDRAW_NULLFRAME;
    } else {
        DbgLog((LOG_TRACE,5,TEXT("This frame is %d big"), pSample->GetActualDataLength()));
    }

    // after a DrawBegin, we preroll until the next key
    if(pSample->IsSyncPoint() == S_OK) {
        DbgLog((LOG_TRACE,5,TEXT("This is a keyframe")));
	m_fNewBegin = FALSE;
    } else {
 	dwFlags |= ICDRAW_NOTKEYFRAME;
	if (m_fNewBegin) {
	    // After each begin, we PREROLL until the next keyframe, because
	    // this is what MCIAVI appeared to do (compatability)
	    dwFlags |= ICDRAW_PREROLL;
	}
    }

    //DbgLog((LOG_TRACE,2,TEXT("ICDraw")));
    if (ICDraw(m_hic, dwFlags, HEADER(m_pInput->CurrentMediaType().Format()),
    		pSrc, pSample->GetActualDataLength(), m_lFrame - m_lStart) != ICERR_OK) {
        //DbgLog((LOG_TRACE,3,TEXT("::Receive wants the draw lock no longer")));
        m_csICDraw.Unlock();
	return E_FAIL;
    }
    //DbgLog((LOG_TRACE,2,TEXT("AFTER ICDRAW")));

    // we've drawn something.  Repainting is no longer a ridiculous concept.
    m_fOKToRepaint = TRUE;

    // only reset this if it succeeded
    if (m_fNeedUpdate)
	m_fNeedUpdate = FALSE;

    // We've given the draw handler as much cueing as it wants.
    // If we're prerolling, we get a bunch of frames stamped as frame zero,
    // so it's important we don't stop accepting frames until the last one,
    // the one not marked preroll
    if (m_fCueing && (m_lFrame >= m_lStart + (LONG)m_BufWanted) &&
				pSample->IsPreroll() != S_OK) {
	DbgLog((LOG_TRACE,3,TEXT("Finished cueing.")));
	// tell the world we're done cueing, if anybody's listening
	m_fCueing = FALSE;	// do this first
	m_EventCueing.Set();
    }

    //DbgLog((LOG_TRACE,3,TEXT("::Receive wants the draw lock no longer")));
    m_csICDraw.Unlock();

    return NOERROR;
}

// Override this if your state changes are not done synchronously

STDMETHODIMP CAVIDraw::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE,5,TEXT("::GetState wait for %ldms"), dwMSecs));
    CheckPointer( State, E_POINTER );

    // We are in an intermediate state.  Give ourselves dwMSecs ms to steady
    if (m_fCueing && dwMSecs) {
	m_EventCueing.Wait(dwMSecs);
    }

    DbgLog((LOG_TRACE,5,TEXT("::GetState done waiting")));

    *State = m_State;
    if (m_fCueing)
	// guess we didn't steady in time
        return VFW_S_STATE_INTERMEDIATE;
    else
        return S_OK;
}

// Overridden to set state to Intermediate, not Paused (from stop)
// Also, we need to know we paused to stop the renderer
// !!! Base class bug fixes won't be picked up by me!
//
STDMETHODIMP CAVIDraw::Pause()
{
    CAutoLock lck(&m_csFilter);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::Pause")));

    // this line differs from the base class
    // it's OK for Receive to block again
    m_fPleaseDontBlock = FALSE;

    if (m_State == State_Paused) {
    }

    // If we have no input pin or it isn't yet connected then when we are
    // asked to pause we deliver an end of stream to the downstream filter.
    // This makes sure that it doesn't sit there forever waiting for
    // samples which we cannot ever deliver without an input connection.

    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE) {
        if (m_pOutput && m_bEOSDelivered == FALSE) {
            m_pOutput->DeliverEndOfStream();
	    m_bEOSDelivered = TRUE;
        }
        m_State = State_Paused;
    }

    // We may have an input connection but no output connection

    else if (m_pOutput == NULL || m_pOutput->IsConnected() == FALSE) {
        m_State = State_Paused;
    }

    else {
	if (m_State == State_Stopped) {
	    // allow a class derived from CTransformFilter
	    // to know about starting and stopping streaming
	    hr = StartStreaming();
	}
	if (FAILED(hr)) {
	    return hr;
	}
    }

// CBaseFilter stuff begins here

    CAutoLock cObjectLock(m_pLock);

    // notify all pins of the change to active state
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
		// This is different.  We don't have an allocator, so it's
		// OK to get that error.
	        if (FAILED(hr) && hr != VFW_E_NO_ALLOCATOR) {
    		    DbgLog((LOG_ERROR,1,TEXT("* Active failed!")));
		    return hr;
	        }
            }
	}
    }

    // This section of code is different
    //
    if (m_State == State_Stopped) {
	// driver may want some frames in advance.  Can't finish pausing yet
        DbgLog((LOG_TRACE,2,TEXT("Pause - need to cue up %d extra frames"),
						m_BufWanted));
	m_State = State_Paused;
	m_EventCueing.Reset();	// more than one thread can block on it
	m_fCueing = TRUE;	// reset event first
        return S_FALSE;	// not really paused yet
    } else {
        DbgLog((LOG_TRACE,3,TEXT("Pause - was running")));
	m_State = State_Paused;
        DbgLog((LOG_TRACE,2,TEXT("ICDrawStop")));
	ICDrawStop(m_hic);
	return S_OK;
    }
}


// overridden to know when we unpause, and restart the renderer
//
STDMETHODIMP CAVIDraw::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::Run")));

    // It appears we aren't going to be able to cue data before being run.
    // !!! So how do I avoid the GetBuffersWanted frame lag?
    if (m_fCueing) {
	m_fCueing = FALSE;	// do this first
	m_EventCueing.Set();
    }

    HRESULT hr = CBaseFilter::Run(tStart);

    DbgLog((LOG_TRACE,2,TEXT("ICDrawStart")));
    ICDrawStart(m_hic);

    // Unblock the renderer, but only if he's blocked
    // Make sure to do this after the base class fixes up m_tStart
    if (m_fPauseBlocked) {
        DbgLog((LOG_TRACE,3,TEXT("Run - unblocking Receive")));
	m_fPauseBlocked = FALSE;
	m_EventPauseBlock.Set();
    }

    return hr;
}


// overridden to unblock our renderer
// !!! Base class bug fixes won't be picked up by me!
//
STDMETHODIMP CAVIDraw::Stop()
{
    CAutoLock lck1(&m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::Stop")));

    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE ||
            m_pOutput == NULL || m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
		m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    m_fInStop = TRUE;

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // We sometimes don't get an EndOfStream, so we could still be cueing
    // We're waiting for more data that will never come.
    // So we need to stop cueing, and send a RenderBuffer so the codec will
    // know to draw whatever GetBuffersWanted preroll it has stashed
    //
    if (m_fCueing) {
        DbgLog((LOG_TRACE,3,TEXT("No more data coming-done cueing")));
        // !!!tell the draw handler no more data is coming... draw what you have
        DbgLog((LOG_TRACE,2,TEXT("ICDrawRenderBuffer")));
        ICDrawRenderBuffer(m_hic);
        // tell the world we're done cueing, if anybody's listening
        m_fCueing = FALSE;	// do this first
        m_EventCueing.Set();
    }

    // decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();

    // This is the only section that is different
    // Unblock the renderer, but only if he's blocked.  Do it now, before
    // we take the Receive critsec, cuz Receive is blocked!!

    // Prevent Receive from getting
    // pre-empted between the time it decides to block and actually sets
    // m_fPauseBlocked, or we won't know that as soon as the Receive thread
    // continues, it will block after we decided it wasn't going to.
    m_csPauseBlock.Lock();

    // If another thread is currently in Receive but hasn't yet blocked
    // (but is going to) we won't unblock it below (because it isn't blocked
    // yet) and then as soon as we take the Receive crit sect a moment later,
    // the Receive thread will start up again, block, and we're dead.
    m_fPleaseDontBlock = TRUE;

    if (m_fPauseBlocked) {
        DbgLog((LOG_TRACE,3,TEXT("Stop - unblocking Receive")));
	m_fPauseBlocked = FALSE;
	m_EventPauseBlock.Set();
    }

    m_csPauseBlock.Unlock();

    // back to normal.
    // synchronize with Receive calls

    CAutoLock lck2(&m_csReceive);
    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();
    if (SUCCEEDED(hr)) {
        // complete the state transition
        m_State = State_Stopped;
        m_bEOSDelivered = FALSE;
    }

    m_fInStop = FALSE;

    return hr;
}


// No more data coming.  If we're blocked waiting for more data, unblock!
HRESULT CAVIDraw::EndOfStream(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::EndOfStream")));

    // We're waiting for more data that will never come.  We better enter
    // our pause state for real, or we'll hang
    if (m_fCueing) {
	DbgLog((LOG_TRACE,3,TEXT("No more data coming - done cueing")));
	// !!!tell the draw handler no more data is coming... draw what you have
        DbgLog((LOG_TRACE,2,TEXT("ICDrawRenderBuffer")));
	ICDrawRenderBuffer(m_hic);
	// tell the world we're done cueing, if anybody's listening
	m_fCueing = FALSE;	// do this first
	m_EventCueing.Set();
    }

    return CTransformFilter::EndOfStream();
}

// enter flush state. Receives already blocked
// must override this if you have queued data or a worker thread
// !!! Base class bug fixes won't be picked up by me!
HRESULT CAVIDraw::BeginFlush(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::BeginFlush")));

    if (m_pOutput != NULL) {
	// block receives -- done by caller (CBaseInputPin::BeginFlush)

	// discard queued data -- we have no queued data

        // Prevent Receive from getting pre-empted between
        // the time it decides to block and actually sets m_fPauseBlocked,
        // or we won't know that as soon as the Receive thread
        // continues, it will block after we decided it wasn't going to.
        m_csPauseBlock.Lock();

	// free anyone blocked on receive
        if (m_fPauseBlocked) {
            DbgLog((LOG_TRACE,3,TEXT("BeginFlush - unblocking Receive")));
	    m_fPauseBlocked = FALSE;
	    m_EventPauseBlock.Set();
        }

	// Until the EndFlush, Receive should reject everything
	m_fPleaseDontBlock = TRUE;

        m_csPauseBlock.Unlock();

	// next NewSegment will hold a new frame range
        m_lStart = -1;
        DbgLog((LOG_TRACE,2,TEXT("ICDrawStopPlay")));
	ICDrawStopPlay(m_hic);
        DbgLog((LOG_TRACE,2,TEXT("ICDrawEnd")));
	ICDrawEnd(m_hic);


	// do NOT call downstream - we are not connected with IMemInputPin
	// and IMAGE will deadlock
	// NO NO NO hr = m_pOutput->DeliverBeginFlush();

 	// If this driver has a bunch of queued up frames, it should throw
	// them away instead of showing them during the next unrelated 
	// segment it's asked to play
        DbgLog((LOG_TRACE,2,TEXT("ICDrawFlush")));
	ICDrawFlush(m_hic);
    }
    return hr;
}

// leave flush state. must override this if you have queued data
// or a worker thread
// !!! Base class bug fixes won't be picked up by me!
HRESULT CAVIDraw::EndFlush(void)
{

    DbgLog((LOG_TRACE,2,TEXT("CAVIDraw::EndFlush")));

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream -- we have no queued data

    // since we just flushed, anything that comes downstream from now on
    // is stuff to cue up as if we just entered Pause mode (from Stop).
    m_fPleaseDontBlock = FALSE;
    m_EventCueing.Reset();	// more than one thread can block on it

    // If we're really paused, we can expect to see more frames come our way
    // If not, none are coming, and we will HANG if we think we're cueing
    // Also, we appear to need a new DrawBegin to keep the drivers happy
    if (m_State == State_Paused && !m_fInStop) {
        m_fCueing = TRUE;		// reset event first
        DbgLog((LOG_TRACE,3,TEXT("ICDrawBegin hdc=%d (%d,%d,%d,%d)"), m_hdc,
		m_rcClient.left,
		m_rcClient.top,
		m_rcClient.right,
		m_rcClient.bottom));
	DWORD_PTR err = ICDrawBegin(m_hic, ICDRAW_HDC, NULL, /* !!! hpal */
			m_hwnd, m_hdc,
			m_rcClient.left, m_rcClient.top,
			m_rcClient.right - m_rcClient.left,
			m_rcClient.bottom - m_rcClient.top,
			HEADER(m_pInput->CurrentMediaType().Format()),
			m_rcSource.left, m_rcSource.top,
			m_rcSource.right - m_rcSource.left,
			m_rcSource.bottom - m_rcSource.top,
			// !!! I know I'm passing these backwards, but MCIAVI
			// did (for the default draw handler only)
			m_dwScale, m_dwRate);
	m_fNewBegin = TRUE;
	if (err != ICERR_OK) {
            DbgLog((LOG_ERROR,1,TEXT("Error in ICDrawBegin")));
	    return E_FAIL;
	}
    }

    // do NOT call downstream - we are not connected with IMemInputPin
    // NO NO NO return m_pOutput->DeliverEndFlush();
    return NOERROR;

    // caller (the input pin's method) will unblock Receives
}


STDMETHODIMP CAVIDraw::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = CLSID_AVIDraw;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\debug.c ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and
//      distribute the Sample Files (and/or any modified version) in
//      any way you find useful, provided that you agree that
//      Microsoft has no warranty obligations or liability for any
//      Sample Application Files which are modified.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp]
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <mmsystem.h>
#include <stdarg.h>
#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_CODE"))
#endif


#define WSPRINTF_LIMIT 1024

//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#define GetProfileIntA       GetProfileInt
#define OutputDebugStringA   OutputDebugStr

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level

WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  WinAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI WinAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char szWork[256];
    static char BCODE szFormat[] =
        "!Assert: %s#%lu [%s]";

    dprintf(0, (LPSTR)szFormat, (LPSTR)lpstrFile, dwLine, (LPSTR)lpstrExp);
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************

void FAR CDECL DbgVPrintF(
   LPSTR szFmt,
   va_list va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     smf=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

void FAR CDECL dprintf(
   UINT     uDbgLevel,
   LPSTR   szFmt,
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize(BOOL fEnable)
{
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  SMF=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  DEBUG_MODULE_NAME    "smf"          // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)
                                             
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI WinAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\draw\draw.h ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudAVIDraw;

//
// Wrapper for ICDraw messages
//

#if 0	// in uuids.h
// Class ID for CAVIDraw object
// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}
DEFINE_GUID(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9);
#endif

class CAVIDraw;

class COverlayNotify : public CUnknown, public IOverlayNotify DYNLINKVFW
{
    public:
        /* Constructor and destructor */
        COverlayNotify(TCHAR              *pName,
                       CAVIDraw		  *pFilter,
                       LPUNKNOWN           pUnk,
                       HRESULT            *phr);
        ~COverlayNotify();

        /* Unknown methods */

        DECLARE_IUNKNOWN

        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        STDMETHODIMP_(ULONG) NonDelegatingRelease();
        STDMETHODIMP_(ULONG) NonDelegatingAddRef();

        /* IOverlayNotify methods */

        STDMETHODIMP OnColorKeyChange(
            const COLORKEY *pColorKey);         // Defines new colour key

        STDMETHODIMP OnClipChange(
            const RECT *pSourceRect,            // Area of video to play
            const RECT *pDestinationRect,       // Area of video to play
            const RGNDATA *pRegionData);        // Header describing clipping

        STDMETHODIMP OnPaletteChange(
            DWORD dwColors,                     // Number of colours present
            const PALETTEENTRY *pPalette);      // Array of palette colours

        STDMETHODIMP OnPositionChange(
            const RECT *pSourceRect,            // Area of video to play with
            const RECT *pDestinationRect);      // Area video goes

    private:
        CAVIDraw *m_pFilter;

	// remember the last clip region given by ::OnClipChange
	HRGN m_hrgn;
} ;


class COverlayOutputPin : public CTransformOutputPin
{
    public:

        /*  Pin methods
        */

        // Return the IOverlay interface we are using (AddRef'd)
        IOverlay *GetOverlayInterface();

        //  Override connect so we can do more work if it works
        STDMETHODIMP Connect(IPin * pReceivePin,const AM_MEDIA_TYPE *pmt);

        //  Don't connect to anybody who can't do IOverlay
        HRESULT CheckConnect(IPin *pPin);

        // undo any work done in CheckConnect.
        HRESULT BreakConnect();

        // Override this because we don't want any allocator!
        HRESULT DecideAllocator(IMemInputPin * pPin,
                                IMemAllocator ** pAlloc);

        /*  Constructor and Destructor
        */
        COverlayOutputPin(
            TCHAR              * pObjectName,
            CAVIDraw	       * pFilter,
            HRESULT            * phr,
            LPCWSTR              pPinName);

        ~COverlayOutputPin();

    /*  Private members */

    private:

        /*  Controlling filter */
        CAVIDraw *m_pFilter;

        /*  Overlay window on output pin */
        IOverlay     * m_pOverlay;

        /*  Notify object */
        COverlayNotify m_OverlayNotify;

        /*  Advise id */
        BOOL           m_bAdvise;

        friend class CAVIDraw;
} ;


class CAVIDraw : public CTransformFilter   DYNLINKVFW
{

public:

    CAVIDraw(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAVIDraw();

    DECLARE_IUNKNOWN

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(
                const CMediaType* mtIn,
                const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts
    // and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overridden to handling pausing correctly
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Stop();
    HRESULT BeginFlush();
    HRESULT EndFlush();
    HRESULT EndOfStream();

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // overridden to do the ICDraw
    HRESULT Receive(IMediaSample *pSample);

    // Overridden to make an overlay output pin
    CBasePin * GetPin(int n);

    // Ask the renderer's input pin what hwnd he's using
    HRESULT GetRendererHwnd(void);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // figure out if the VFW capture filter is in the graph with us
    BOOL IsVfwCapInGraph();

private:
    HIC  m_hic;	// current codec
    HWND m_hwnd;// hwnd from renderer
    HDC  m_hdc;	// hdc of that hwnd

    DWORD m_dwRate, m_dwScale;	// for frames/sec
    LONG  m_lStart, m_lStop;	// start and end frame number we're streaming
    LONG  m_lFrame;		// last ICDraw frame we sent

    DWORD m_BufWanted;		// how much to buffer ahead

    RECT  m_rcSource;		// from IOverlay - what to draw
    RECT  m_rcTarget;		// from IOverlay - where to draw
    RECT  m_rcClient;		// m_rcTarget in client co-ords

    BOOL  m_fScaryMode;		// ask renderer for clip changes and make
				// it to a WindowsHook - necessary for
				// inlay cards

    BOOL  m_fVfwCapInGraph;	// is the VFW capture filter in graph with us

    // the fourCC used to open m_hic
    FOURCC m_FourCCIn;

    // have we called ICDecompressBegin ?
    BOOL m_fStreaming;

    // are we inside ::Stop?
    BOOL m_fInStop;

    // set ICDRAW_UPDATE next time we call ICDraw().
    BOOL m_fNeedUpdate;

    // are we cuing up the draw handler?
    BOOL m_fCueing;
    BOOL m_fPauseBlocked;

    // did we just do a begin?  (we need to preroll until next key)
    BOOL m_fNewBegin;

    // Wait until we've drawn something before trying to repaint
    BOOL m_fOKToRepaint;

    // prevent deadlock
    BOOL m_fPleaseDontBlock;

    DWORD_PTR m_dwAdvise;
    CAMEvent m_EventPauseBlock;
    CAMEvent m_EventAdvise;
    CAMEvent m_EventCueing;

    // only 1 ICDrawX API should be called at a time
    CCritSec m_csICDraw;

    // prevent ::Stop from being called during parts of ::Receive
    CCritSec m_csPauseBlock;

    DWORD  m_dwTime;
    DWORD  m_dwTimeLocate;

    friend class COverlayOutputPin;
    friend class COverlayNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\global.h ===
/*****************************************************************************
*
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
*  A PARTICULAR PURPOSE.
*
*  Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
*
******************************************************************************
*
* Global.H
*
* #define's everybody needs
*
*****************************************************************************/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifndef _WIN32
#define  BCODE                  __based(__segname("_CODE"))
#define  BSTACK                 __based(__segname("_STACK"))
#define  BSEG(x)                __based(__segname(x))
#define  HUGE                   __huge
#else
#define  BCODE
#define  BSTACK
#define  BSEG(x)
#define  HUGE
#endif

/* Allow visibility of static functions for debug
*/ 
#ifdef DEBUG
#define  PUBLIC
#define  PRIVATE
#else
#define  PUBLIC                 
#define  PRIVATE                static
#endif

#define  FNLOCAL                NEAR PASCAL
#define  FNGLOBAL               FAR PASCAL
#define  FNEXPORT               FAR PASCAL __export __loadds

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if not exist $(QUARTZ)\bin\$(TARGET_DIRECTORY)
    md $(QUARTZ)\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(QUARTZ)\bin\$(TARGET_DIRECTORY)\*.*

#  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
#    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
#         $(SDK_ROOT)\bin\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\handler.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

extern "C" {
#include "smf.h"
}

#define IDS_STREAMNAME		100
#define IDS_FILETYPE		101

/* Remove warning of using object during initialization. */
#pragma warning(disable:4355)

/*      -       -       -       -       -       -       -       -       */

/*      -       -       -       -       -       -       -       -       */

class  CMIDIFile : public CUnknown, public IAVIFile,
		    public IAVIStream, public IPersistFile {

	DECLARE_IUNKNOWN

public:
        static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
	STDMETHODIMP NonDelegatingQueryInterface(const IID&, void **);

private:
        CMIDIFile(IUnknown FAR* pUnknownOuter, HRESULT *phr);
        ~CMIDIFile();

private:
	// IAVIFile
	STDMETHODIMP Info(THIS_ AVIFILEINFOW * pfi, LONG lSize);
	STDMETHODIMP GetStream(THIS_ PAVISTREAM FAR * ppStream,
		DWORD fccType, LONG lParam);
	STDMETHODIMP CreateStream(THIS_ PAVISTREAM FAR * ppStream,
		AVISTREAMINFOW * psi);
	STDMETHODIMP EndRecord(THIS);
	STDMETHODIMP DeleteStream(THIS_ DWORD fccType, LONG lParam);

	// IAVIStream
	STDMETHODIMP Create(THIS_ LPARAM lParam1, LPARAM lParam2);
	STDMETHODIMP Info(THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
	STDMETHODIMP_(LONG) FindSample(THIS_ LONG lPos, LONG lFlags);
	STDMETHODIMP ReadFormat(THIS_ LONG lPos, LPVOID lpFormat,
		LONG FAR *cbFormat);
	STDMETHODIMP SetFormat(THIS_ LONG lPos, LPVOID lpFormat,
		LONG cbFormat);
	STDMETHODIMP Read(THIS_ LONG lStart, LONG lSamples,
		LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes,
		LONG FAR * plSamples);
	STDMETHODIMP Write(THIS_ LONG lStart, LONG lSamples,
		LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags,
		LONG FAR *plSampWritten, LONG FAR *plBytesWritten);
	STDMETHODIMP Delete(THIS_ LONG lStart, LONG lSamples);
	STDMETHODIMP ReadData(THIS_ DWORD fcc, LPVOID lp,
		LONG FAR *lpcb);
	STDMETHODIMP WriteData(THIS_ DWORD fcc, LPVOID lp, LONG cb);
	STDMETHODIMP SetInfo(AVISTREAMINFOW FAR * lpInfo, LONG cbInfo);

	// *** IPersist methods ***
	STDMETHODIMP GetClassID (LPCLSID lpClassID);
	// *** IPersistFile methods ***
	STDMETHODIMP IsDirty ();
	STDMETHODIMP Load (LPCOLESTR lpszFileName, DWORD grfMode);
	STDMETHODIMP Save (LPCOLESTR lpszFileName, BOOL fRemember);
	STDMETHODIMP SaveCompleted (LPCOLESTR lpszFileName);
	STDMETHODIMP GetCurFile (LPOLESTR FAR * lplpszFileName);

        //
        // MIDI Stream instance data
        //
	LONG	m_lLastSampleRead;	// lStart + lSamples - 1 of last ::Read
        BOOL    m_fStreamPresent;
        BOOL	m_fDirty;
        UINT    m_mode;
        AVIFILEINFOW	m_finfo;
        AVISTREAMINFOW	m_sinfo;
	HSMF	m_hsmf;			// handle for contigous reader
	HSMF	m_hsmfK;		// handle for keyframe reader
	DWORD	m_dwTimeDivision;	// used for the format

	// !!! Does this DLL only supports reading 1 file at a time?

};

/*      -       -       -       -       -       -       -       -       */

DEFINE_AVIGUID(CLSID_MIDIFileReader, 0x0002001E, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\midif.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD		dwDivision;
    DWORD		dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\smf.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smf.h

    DESCRIPTION:
      Public include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMF_
#define _SMF_

#include "global.h"             // #define's we need
//-----------------------------------------------------------------------------
//
// Debug from test app - remove later
//
extern void NEAR SeqDebug(LPSTR lpstrDebugText, ...);
//-----------------------------------------------------------------------------


typedef DWORD SMFRESULT;
typedef DWORD TICKS;
typedef TICKS FAR *PTICKS;
typedef BYTE HUGE *HPBYTE;
// !!! typedef BYTE __huge *HPBYTE;

#define MAX_TICKS           ((TICKS)0xFFFFFFFFL)

#define SMF_SUCCESS         (0L)
#define SMF_INVALID_FILE    (1L)
#define SMF_NO_MEMORY       (2L)
#define SMF_OPEN_FAILED     (3L)
#define SMF_INVALID_TRACK   (4L)
#define SMF_META_PENDING    (5L)
#define SMF_ALREADY_OPEN    (6L)
#define SMF_END_OF_TRACK    (7L)
#define SMF_NO_META         (8L)
#define SMF_INVALID_PARM    (9L)
#define SMF_INVALID_BUFFER  (10L)
#define SMF_END_OF_FILE     (11L)
#define SMF_REACHED_TKMAX   (12L)

DECLARE_HANDLE(HSMF);
DECLARE_HANDLE(HTRACK);

//-----------------------------------------------------------------------------

typedef struct tag_smfopenstruct
{
    LPSTR               pstrName;
    HTASK               htask;
    DWORD               dwTimeDivision;
    HSMF                hsmf;
}   SMFOPENFILESTRUCT,
    FAR *PSMFOPENFILESTRUCT;

extern SMFRESULT FNLOCAL smfOpenFile(
    PSMFOPENFILESTRUCT  psofs);

extern SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf);

typedef struct tag_smffileinfo
{
    DWORD               dwTracks;
    DWORD               dwFormat;
    DWORD               dwTimeDivision;
    TICKS               tkLength;
    BOOL                fMSMidi; 
    LPBYTE              pbTrackName;
    LPBYTE              pbCopyright;
    WORD                wChanInUse;
}   SMFFILEINFO,
    FAR *PSMFFILEINFO;

extern SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi);

extern void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask);

extern void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum);                                    

//-----------------------------------------------------------------------------

extern DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset);

extern DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset);

//-----------------------------------------------------------------------------

#define SMF_REF_NOMETA      0x00000001L

extern SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents);

extern SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

// !!! new
extern SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

extern DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition);

extern DWORD FNLOCAL smfGetStateMaxSize(
    void);

extern LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf);

extern LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf);


//-----------------------------------------------------------------------------

//
// Buffer described by LPMIDIHDR is in polymsg format, except that it
// can contain meta-events (which will be ignored during playback by
// the current system). This means we can use the pack functions, etc.
//
#define PMSG_META       ((BYTE)0xC0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef _X86_

    //
    //  Use 32-bit x86 assembly.
    //

    #pragma warning(disable:4035 4704)

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
        _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     shr     ebx,1            //  sar  ebx,1
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     dec     ebx              //  dec  ebx
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRU32()

    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRD32()

    #pragma warning(default:4035 4704)


#else

    //
    //  Use C9 __int64 support for Daytona RISC platforms.
    //

    INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
    {
        return (LONG)( Int32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( UInt32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
    }


    INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
    }

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\smf.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************
 
    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smf.c

    DESCRIPTION:
      Routines for reading and writing Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh);

/*****************************************************************************
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfOpenFile | This function opens a MIDI file for access. No
 *  I/O can actually be performed until an HTRACK handle is obtained from
 *  <f smfOpenTrack>.
 *
 * @parm <t PSMFOPENFILESTRUCT> | psofs | Specifies the file to open and
 *  associated parameters. Contains a valid HSMF handle on success.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was opened.
 *  @flag SMF_OPEN_FAILED | The specified file could not be opened because it
 *   did not exist or could not be created on the disk.
 *  @flag SMF_INVALID_FILE | The specified file was corrupt or not a MIDI file.
 *  @flag SMF_NO_MEMORY | There was insufficient memory to open the file.
 *  @flag SMF_INVALID_PARM | The given flags or time division in the
 *   <t SMFOPENFILESTRUCT> were invalid.
 * 
 * @xref <t SMFOPENFILESTRUCT>, <f smfCloseFile>, <f smfOpenTrack>
 *****************************************************************************/
SMFRESULT FNLOCAL smfOpenFile(
    PSMFOPENFILESTRUCT  psofs)
{
    HMMIO               hmmio = (HMMIO)NULL;
    PSMF                psmf;
    SMFRESULT           smfrc = SMF_SUCCESS;
    MMIOINFO            mmioinfo;
    MMCKINFO            ckRIFF;
    MMCKINFO            ckDATA;

    assert(psofs != NULL);
    assert(psofs->pstrName != NULL);
    
    // !!! as good a place as any?
    DbgInitialize(TRUE);

    // Verify that the file can be opened or created
    //
    _fmemset(&mmioinfo, 0, sizeof(mmioinfo));
    mmioinfo.htask = psofs->htask;
    
    hmmio = mmioOpen(psofs->pstrName, &mmioinfo, MMIO_READ|MMIO_ALLOCBUF);
    if ((HMMIO)NULL == hmmio)
    {
        DPF(1, "smfOpenFile: mmioOpen failed!");
        return SMF_OPEN_FAILED;
    }

    // Now see if we can create the handle structure
    //
    psmf = (PSMF)LocalAlloc(LPTR, sizeof(SMF));
    if (NULL == psmf)
    {
        DPF(1, "smfOpenFile: LocalAlloc failed!");
        smfrc = SMF_NO_MEMORY;
        goto smf_Open_File_Cleanup;
    }

    lstrcpy(psmf->szName, psofs->pstrName);
    psmf->fdwSMF = 0;
    psmf->pTempoMap = NULL;
    psmf->pbTrackName = NULL;
    psmf->pbCopyright = NULL;
    psmf->wChannelMask = 0xFFFF;

    // Pull the entire file into a block of memory. 
    //
    _fmemset(&ckRIFF, 0, sizeof(ckRIFF));
    
    if (0 == mmioDescend(hmmio, &ckRIFF, NULL, MMIO_FINDRIFF) &&
        ckRIFF.fccType == FOURCC_RMID)
    {
        ckDATA.ckid = FOURCC_data;
        
        if (0 == mmioDescend(hmmio, &ckDATA, &ckRIFF, MMIO_FINDCHUNK))
        {
            psmf->cbImage   = ckDATA.cksize;
        }
        else
        {
            DPF(1, "smfOpenFile: Could not descend into RIFF DATA chunk!");
            smfrc = SMF_INVALID_FILE;
            goto smf_Open_File_Cleanup;
        }
    }
    else
    {
        mmioSeek(hmmio, 0L, SEEK_SET);
        
        psmf->cbImage = mmioSeek(hmmio, 0L, SEEK_END);
        mmioSeek(hmmio, 0L, SEEK_SET);
    }
    
    if (NULL == (psmf->hpbImage = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, psmf->cbImage)))
    {
        DPF(1, "smfOpenFile: No memory for image! [%08lX]", psmf->cbImage);
        smfrc = SMF_NO_MEMORY;
        goto smf_Open_File_Cleanup;
    }
 
    if (psmf->cbImage != (DWORD)mmioRead(hmmio, psmf->hpbImage, psmf->cbImage))
    {
        DPF(1, "smfOpenFile: Read error on image!");
        smfrc = SMF_INVALID_FILE;
        goto smf_Open_File_Cleanup;
    }

    //
    // If the file exists, parse it just enough to pull out the header and
    // build a track index.
    //
    smfrc = smfBuildFileIndex((PSMF BSTACK *)&psmf);
    if (MMSYSERR_NOERROR != smfrc)
    {
        DPF(1, "smfOpenFile: smfBuildFileIndex failed! [%lu]", (DWORD)smfrc);
    }

    psmf->htask = psofs->htask; 

smf_Open_File_Cleanup:

    mmioClose(hmmio, 0);

    if (SMF_SUCCESS != smfrc)
    {
        if (NULL != psmf)
        {
            if (NULL != psmf->hpbImage)
            {
                GlobalFreePtr(psmf->hpbImage);
            }
            
            LocalFree((HLOCAL)psmf);
        }
    }
    else
    {
        psofs->hsmf = (HSMF)psmf;
    }
    
    return smfrc;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfCloseFile | This function closes an open MIDI file.
 *  Any open tracks are closed. All data is flushed and the MIDI file is
 *  remerged with any new track data. 
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @comm 
 *  Any track handles opened from this file handle are invalid after this
 *  call.
 *        
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was closed.
 *  @flag SMF_INVALID_PARM | The given handle was not valid.
 *
 * @xref <f smfOpenFile>
 *****************************************************************************/
SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf)
{
    PSMF                psmf        = (PSMF)hsmf;
    
    assert(psmf != NULL);
    
    //
    // Free up handle memory 
    //
    if (NULL != psmf->pbTrackName)
        LocalFree((HLOCAL)psmf->pbTrackName);
    
    if (NULL != psmf->pbCopyright)
        LocalFree((HLOCAL)psmf->pbCopyright);
    
    if (NULL != psmf->hpbImage)
        GlobalFreePtr(psmf->hpbImage);

    if (NULL != psmf->hTempoMap)
    {
        LocalUnlock(psmf->hTempoMap);
        LocalFree(psmf->hTempoMap);
    }
    
    LocalFree((HLOCAL)psmf);
    
    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetFileInfo | This function gets information about
 *  the MIDI file.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to inquire about.
 *
 * @parm PSMFFILEINFO | psfi | A structure which will be filled in with
 *  information about the file.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | Information was gotten about the file.
 *  @flag SMF_INVALID_PARM | The given handle was invalid.
 *
 * @xref <t SMFFILEINFO>
 *****************************************************************************/
SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);
    assert(psfi != NULL);

    // 
    // Just fill in the structure with useful information.
    //
    psfi->dwTracks      = psmf->dwTracks;
    psfi->dwFormat      = psmf->dwFormat;
    psfi->dwTimeDivision= psmf->dwTimeDivision;
    psfi->tkLength      = psmf->tkLength;
    psfi->fMSMidi       = (psmf->fdwSMF & SMF_F_MSMIDI) ? TRUE : FALSE;
    psfi->pbTrackName   = (LPBYTE)psmf->pbTrackName;
    psfi->pbCopyright   = (LPBYTE)psmf->pbCopyright;
    psfi->wChanInUse    = psmf->wChanInUse;
    
    return SMF_SUCCESS;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfSetChannelMask | This function sets the channel mask that
 *  SMF will use in all future read operations. The low bit corresponds to
 *  channel 0; the high bit to channel 15. Only 454-0055 events which are on
 *  channels with the corresponding bit set in the channel mask will be read.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm WORD | wChannelMask | The new channel mask.
 *
 * @comm
 *  Don't change this in the middle of the file unless you want to have 
 *  missing note off's for note on's that already happened. 
 *        
 *****************************************************************************/
void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(1, "smfSetChannelMask(%04X)", wChannelMask);

    psmf->wChannelMask = wChannelMask;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfRemapDrum | This function sets the remap drum flag. If
 *  this flag is set, SMF will convert all events on channel 16 to channel
 *  10.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm BOOL | fRemapDrum | The value to set the remap flag to
 *
 *****************************************************************************/
void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(2, "smfSetRemapDrum(%04X)", fRemapDrum);

    if (fRemapDrum)
        psmf->fdwSMF |= SMF_F_REMAPDRUM;
    else
        psmf->fdwSMF &=~SMF_F_REMAPDRUM;
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfTicksToMillisecs | This function returns the millisecond
 *  offset into the file given the tick offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm TICKS | tkOffset | Specifies the tick offset into the stream to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same millisecond value
 *  might not be valid at a later time if the tempo track is rewritten.
 *
 * @rdesc Returns the number of milliseconds from the start of the stream.
 *
 * @xref <f smfMillisecsToTicks>
 *****************************************************************************/
DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    assert(psmf != NULL);

    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);
        
        return (DWORD)muldiv32(tkOffset, 1000L, dwTicksPerSec);
    }
       
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkOffset < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //

    return pTempo->msBase + muldiv32(tkOffset-pTempo->tkTempo,
                                     pTempo->dwTempo,
                                     1000L*psmf->dwTimeDivision);
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfMillisecsToTicks | This function returns the nearest tick
 *  offset into the file given the millisecond offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm DWORD | msOffset | Specifies the millisecond offset into the stream
 *  to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same tick value
 *  might not be valid at a later time if the tempo track is rewritten.
 *  If the millisecond value does not exactly map to a tick value, then
 *  the tick value will be rounded down.
 *
 * @rdesc Returns the number of ticks from the start of the stream.
 *
 * @xref <f smfTicksToMillisecs>
 *****************************************************************************/
DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    DPF(2, "smfMillisecsToTicks");
    assert(psmf != NULL);
    
    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);

        DPF(2, "SMPTE: dwTicksPerSec %ld", dwTicksPerSec);
        
        return (DWORD)muldiv32(msOffset, dwTicksPerSec, 1000L);
    }
    
    // Walk the tempo map and find the nearest millisecond position. Linearly
    // calculate the rest (using MATH.ASM)
    //
    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (msOffset < pTempo->msBase)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    DPF(2, "pTempo->tkTempo %lu msBase %lu dwTempo %lu", (DWORD)pTempo->tkTempo, (DWORD)pTempo->msBase, pTempo->dwTempo);
    return pTempo->tkTempo + muldiv32(msOffset-pTempo->msBase,
                                     1000L*psmf->dwTimeDivision,
                                     pTempo->dwTempo);
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfReadEvents | This function reads events from a track.
 *
 * @parm HSMF | hsmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @parm DWORD | fdwRead | Contains flags specifying how to do the read.
 *  @flag SMF_REF_NOMETA | Meta events will not be put into the buffer.         
 *
 * @comm
 *  This function may only be called on a file opened for read access.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_PARM | The given handle, buffer, or flags were invalid.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfWriteEvents>
 *****************************************************************************/
SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents)
{
    PSMF                psmf = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    LPDWORD             lpdw;
    DWORD               dwTempo;

    assert(psmf != NULL);
    assert(lpmh != NULL);

    // 
    // Read events from the track and pack them into the buffer in polymsg
    // format.
    // 
    // If a SysEx or meta would go over a buffer boundry, split it.
    // 
    lpmh->dwBytesRecorded = 0;
    if (psmf->dwPendingUserEvent)
    {
        DPF(1, "smfReadEvents: Inserting pending event...");
        
        smfrc = smfInsertParmData(psmf, (TICKS)0, lpmh);
        if (SMF_SUCCESS != smfrc)
        {
            DPF(1, "smfInsertParmData() -> %u", (UINT)smfrc);
            return smfrc;
        }
    }
    
    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        DPF(1, "smfReadEvents: SMF_F_EOF set; instant out");
        return SMF_END_OF_FILE;
    }

    while(TRUE)
    {
        assert(lpmh->dwBytesRecorded <= lpmh->dwBufferLength);
        
        // If we know ahead of time we won't have room for the
        // event, just break out now. We need at least 3 DWORD's
        // for any event we might store - this will allow us a full
        // short event or the delta time and stub for a long
        // event to be split.
        //
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
        {
            break;
        }

        smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkMax);
        if (SMF_SUCCESS != smfrc)
        {
            // smfGetNextEvent doesn't set this because smfSeek uses it
            // as well and needs to distinguish between reaching the
            // seek point and reaching end-of-file.
            //
            // To the user, however, we present the selection between
            // their given tkBase and tkEnd as the entire file, therefore
            // we want to translate this into EOF.
            //
            if (SMF_REACHED_TKMAX == smfrc)
            {
	 	// !!! poor API!!! This prevents Read(100), Read(200) from
		// working, because the Read(200) will fail just because the
		// Read(100) succeeded and says that the EOF is reached!
                // pSmf->fdwSMF |= SMF_F_EOF;
            }
            
            DPF(2, "smfReadEvents: smfGetNextEvent() -> %u", (UINT)smfrc);
            break;
        }

        
        if (MIDI_SYSEX > EVENT_TYPE(event))
        {
            BYTE b = EVENT_TYPE(event);

            // If we're remapping drum events, and this event is on
            // channel 16, move it to channel 10 (or, 0-based, 15 to 9)
            //
            if (psmf->fdwSMF & SMF_F_REMAPDRUM &&
                ((b & 0x0F) == 0x0F))
            {
               b = (b & 0xF0) | 0x09;
            }
            
            *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
            psmf->tkDiscardedEvents = 0;
            
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG)<<24) |
                      ((DWORD)b)|
                      (((DWORD)EVENT_CH_B1(event)) << 8) |
                      (((DWORD)EVENT_CH_B2(event)) << 16);
            
            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_EOT == EVENT_META_TYPE(event))
        {
            // These are ignoreable since smfReadNextEvent()
            // takes care of track merging
            //
            DPF(1, "smfReadEvents: Hit META_EOT");
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_TEMPO == EVENT_META_TYPE(event))
        {
            if (event.cbParm != 3)
            {
                DPF(1, "smfReadEvents: Corrupt tempo event");
                return SMF_INVALID_FILE;
            }

            if( !fDiscardTempoEvents ) {
                dwTempo = (((DWORD)MEVT_TEMPO)<<24)|
                        (((DWORD)event.hpbParm[0])<<16)|
                        (((DWORD)event.hpbParm[1])<<8)|
                        ((DWORD)event.hpbParm[2]);

                *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
                psmf->tkDiscardedEvents = 0;

                // Tempo should be honored by everyone
                //
                *lpdw++ = (DWORD)-1L;
                *lpdw++ = dwTempo;

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }
        }
        else if (MIDI_META != EVENT_TYPE(event))
        {
            // Must be F0 or F7 system exclusive or FF meta
            // that we didn't recognize
            //
            psmf->cbPendingUserEvent = event.cbParm;
            psmf->hpbPendingUserEvent = event.hpbParm;
            psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;

            switch(EVENT_TYPE(event))
            {
//                case MIDI_META:
//                    psmf->dwPendingUserEvent = ((DWORD)MEVT_META) << 24;
//                    break;

                case MIDI_SYSEX:
                    psmf->fdwSMF |= SMF_F_INSERTSYSEX;
            
                    ++psmf->cbPendingUserEvent;

                    // Falling through...
                    //

                case MIDI_SYSEXEND:
                    psmf->dwPendingUserEvent = ((DWORD)MEVT_LONGMSG) << 24;
                    break;
            }

            smfrc = smfInsertParmData(psmf,
                                      psmf->tkDiscardedEvents + event.tkDelta,
                                      lpmh);
            psmf->tkDiscardedEvents = 0;
            
            if (SMF_SUCCESS != smfrc)
            {
                DPF(1, "smfInsertParmData[2] %u", (UINT)smfrc);
                return smfrc;
            }

            lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);
        }
        else
        {
            // Take into account the delta-time of any events
            // we don't actually put into the buffer
            //
            psmf->tkDiscardedEvents += event.tkDelta;
        }        
    }

    if( 0 == lpmh->dwBytesRecorded ) {
	// !!! poor API!!! This prevents Read(100), Read(200) from
	// working, because the Read(200) will fail just because the
	// Read(100) succeeded and says that the EOF is reached!
        // psmf->fdwSMF |= SMF_F_EOF;
    }

    return (psmf->fdwSMF & SMF_F_EOF) ? SMF_END_OF_FILE : SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @api SMFRESULT | smfInsertParmData | Inserts pending long data from
 *  a track into the given buffer.
 *
 * @parm PSMF | psmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @comm
 *  Fills as much data as will fit while leaving room for the buffer
 *  terminator.
 *
 *  If the long data is depleted, resets <p psmf!dwPendingUserEvent> so
 *  that the next event may be read.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfReadEvents>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh)
{
    DWORD               dwLength;
    DWORD               dwRounded;
    LPDWORD             lpdw;

    assert(psmf != NULL);
    assert(lpmh != NULL);
    
    // Can't fit 4 DWORD's? (tkDelta + stream-id + event + some data) Can't do anything.
    //
    assert(lpmh->dwBufferLength >= lpmh->dwBytesRecorded);
    
    if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 4*sizeof(DWORD))
    {
        if (0 == tkDelta)
            return SMF_SUCCESS;

        // If we got here with a real delta, that means smfReadEvents screwed
        // up calculating left space and we should flag it somehow.
        //
        return SMF_INVALID_FILE;
    }

    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    dwLength = lpmh->dwBufferLength - lpmh->dwBytesRecorded - 3*sizeof(DWORD);
    dwLength = min(dwLength, psmf->cbPendingUserEvent);

    *lpdw++ = (DWORD)tkDelta;

    // Stream ID -- SysEx is broadcast
    //
    *lpdw++ = (DWORD)-1L;
    *lpdw++ = (psmf->dwPendingUserEvent & 0xFF000000L) | (dwLength & 0x00FFFFFFL);

    dwRounded = (dwLength + 3) & (~3L);
    
    if (psmf->fdwSMF & SMF_F_INSERTSYSEX)
    {
        *((LPBYTE)lpdw)++ = MIDI_SYSEX;
        psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;
        --dwLength;
        --psmf->cbPendingUserEvent;
    }    

    hmemcpy(lpdw, psmf->hpbPendingUserEvent, dwLength);
    if (0 == (psmf->cbPendingUserEvent -= dwLength))
        psmf->dwPendingUserEvent = 0;

    lpmh->dwBytesRecorded += 3*sizeof(DWORD) + dwRounded;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfSeek | This function moves the file pointer within a track
 *  and gets the state of the track at the new position. It returns a buffer of
 *  state information which can be used to set up to play from the new position.
 *
 * @parm HTRACK | htrack | The track to seek and get state information from.
 *
 * @parm TICKS | tkPosition | The position to seek to in the track.
 *         
 * @parm LPMIDIHDR | lpmh | A buffer to contain the state information.
 *  If this pointer is NULL, then no state information will be returned.
 *
 * @comm
 *  The state information in the buffer includes patch changes, tempo changes,
 *  time signature, key signature, 
 *  and controller information. Only the most recent of these paramters before
 *  the current position will be stored. The state buffer will be returned
 *  in polymsg format so that it may be directly transmitted over the MIDI
 *  bus to bring the state up to date.
 *
 *  The buffer is mean to be sent as a streaming buffer; i.e. immediately
 *  followed by the first data buffer. If the requested tick position
 *  does not exist in the file, the last event in the buffer
 *  will be a MEVT_NOP with a delta time calculated to make sure that
 *  the next stream event plays at the proper time.
 *
 *  The meta events (tempo, time signature, key signature) will be the
 *  first events in the buffer if they exist.
 * 
 *  This function may only be called on a file opened for read access.
 *
 *  Use <f smfGetStateMaxSize> to determine the maximum size of the state
 *  information buffer. State information that will not fit into the given
 *  buffer will be lost.
 *
 *  On return, the <t dwBytesRecorded> field of <p lpmh> will contain the
 *  actual number of bytes stored in the buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *  @flag SMF_END_OF_TRACK | The pointer was moved to end of track and no state
 *   information was returned.
 *  @flag SMF_INVALID_PARM | The given handle or buffer was invalid.
 *  @flag SMF_NO_MEMORY | There was insufficient memory in the given buffer to
 *   contain all of the state data.
 *
 * @xref <f smfGetStateMaxSize>
 *****************************************************************************/

PRIVATE SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh);

SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    PTRACK              ptrk;
    DWORD               idxTrack;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
// !!! KEYFRAME is now part of SMF

    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    _fmemset(&psmf->kf, 0xFF, sizeof(KEYFRAME));
    
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    // !!! This part has been pulled out into a separate function
    smfrc = smfFillBufferFromKeyframe(hsmf, lpmh);

    // Force all tracks to be at tkPosition. We are guaranteed that
    // all tracks will be past the event immediately preceding tkPosition;
    // this will force correct delta-ticks to be generated so that events
    // on all tracks will line up properly on a seek into the middle of the
    // file.
    //
// !!! I think this is commented out because of the --tkPosition added above
//    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
//    {
//        ptrk->tkPosition        = tkPosition;
//    }

    return smfrc;
    
}
    

// !!! Danny's new function to seek forward a bit and keep the old keyframe
// info around, only adding to it, to avoid every seek seeking from the
// beginning of the file.  You would use it like:
//
// smfSeek(10);
// smfDannySeek(20);
// smfDannySeek(30);
//
// which will work as long as you make no other calls on this handle in between.
// The subsequent seeks will NOT re-seek from the beginning, but remember where
// they left off.
//
SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    if (tkPosition < psmf->tkPosition) {
        DPF(1,"smfDannySeek: not seeking forward... doing a REAL seek");
	return smfSeek(hsmf, tkPosition, lpmh);
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    return smfFillBufferFromKeyframe(hsmf, lpmh);
}


// !!! new function
SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh)
{
    UINT                idx;
    UINT                idxChannel;
    UINT                idxController;
    LPDWORD             lpdw;
    PSMF                psmf    = (PSMF)hsmf;

    // Build lpmh from keyframe
    //
    lpmh->dwBytesRecorded = 0;
    lpdw = (LPDWORD)lpmh->lpData;

    // Tempo change event?
    //
    if (KF_EMPTY != psmf->kf.rbTempo[0] ||
        KF_EMPTY != psmf->kf.rbTempo[1] ||
        KF_EMPTY != psmf->kf.rbTempo[2])
    {
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
            return SMF_NO_MEMORY;

        *lpdw++ = 0;
        *lpdw++ = 0;
        *lpdw++ = (((DWORD)psmf->kf.rbTempo[0])<<16)|
                  (((DWORD)psmf->kf.rbTempo[1])<<8)|
                  ((DWORD)psmf->kf.rbTempo[2])|
                  (((DWORD)MEVT_TEMPO) << 24);

        lpmh->dwBytesRecorded += 3*sizeof(DWORD);
    }

    // Program change events?
    //
    for (idx = 0; idx < 16; idx++)
    {
        if (KF_EMPTY != psmf->kf.rbProgram[idx])
        {
            if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                return SMF_NO_MEMORY;

            *lpdw++ = 0;
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG) << 24)      |
                      ((DWORD)MIDI_PROGRAMCHANGE)         |
                      ((DWORD)idx)                        |
                      (((DWORD)psmf->kf.rbProgram[idx]) << 8);

            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
    }

    // Controller events?
    //
    idx = 0;
    for (idxChannel = 0; idxChannel < 16; idxChannel++)
    {
        for (idxController = 0; idxController < 120; idxController++)
        {
            if (KF_EMPTY != psmf->kf.rbControl[idx])
            {
                if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                    return SMF_NO_MEMORY;

                *lpdw++ = 0;
                *lpdw++ = 0;
                *lpdw++ = (((DWORD)MEVT_SHORTMSG << 24)     |
                          ((DWORD)MIDI_CONTROLCHANGE)       |
                          ((DWORD)idxChannel)               |
                          (((DWORD)idxController) << 8)     |
                          (((DWORD)psmf->kf.rbControl[idx]) << 16));

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }

            idx++;
        }
    }

    return SMF_SUCCESS;
}

DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition)
{
    PSMF                psmf     = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkPosition < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    return pTempo->dwTempo;
}
                          

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetStateMaxSize | This function returns the maximum size
 *  of buffer that is needed to hold the state information returned by
 *  <f smfSeek>.
 *
 * @parm PDWORD | pdwSize | Gets the size in bytes that should be allocated
 *  for the state buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *
 * @xref <f smfSeek>
 *****************************************************************************/
DWORD FNLOCAL smfGetStateMaxSize(
    void)
{
    return  3*sizeof(DWORD) +           // Tempo
            3*16*sizeof(DWORD) +        // Patch changes
            3*16*120*sizeof(DWORD) +    // Controller changes
            3*sizeof(DWORD);            // Time alignment NOP
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetPatchCache | This function returns the patch cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCachePatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get patch information from.
 *
 * @xref <f smfGetKeyCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awPatchCache;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetKeyCache | This function returns the key cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCacheDrumPatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get key information from.
 *
 * @xref <f smfGetPatchCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awKeyCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\smfi.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smfi.h

    DESCRIPTION:
      Private include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMFI_
#define _SMFI_

#define CH_DRUM_BASE        15
#define CH_DRUM_EXT         9

#define EV_DRUM_BASE        (MIDI_NOTEON | CH_DRUM_BASE)
#define EV_DRUM_EXT         (MIDI_NOTEON | CH_DRUM_EXT)

// 
// Handle structure for HSMF
// 

#define SMF_TF_EOT          0x00000001L
#define SMF_TF_INVALID      0x00000002L

typedef struct tag_tempomapentry
{
    TICKS           tkTempo;            // Where this change takes effect
    DWORD           msBase;             // Milliseconds already passed at this point
    DWORD           dwTempo;            // New tempo value in microseconds per quarter note
}   TEMPOMAPENTRY,
    *PTEMPOMAPENTRY;

typedef struct tag_smf *PSMF;

typedef struct tag_keyframe
{
    //
    // Meta events. All FF's indicates never seen.
    //
    BYTE        rbTempo[3];

    //
    // MIDI channel messages. FF indicates never seen.
    //
    BYTE        rbProgram[16];
    BYTE        rbControl[16*120];
}   KEYFRAME,
    FAR *PKEYFRAME;

#define KF_EMPTY ((BYTE)0xFF)

typedef struct tag_track
{
    PSMF            psmf;

    DWORD           idxTrack;           // Start of track rel to psmf->hpbImage
    
    TICKS           tkPosition;         // Tick position of last event played
    DWORD           cbLeft;             // Bytes left in track past hpbImage
    HPBYTE          hpbImage;           // Pointer to current position in track
    
    DWORD           fdwTrack;           // Flags about current state

    struct
    {
        TICKS       tkLength;
        DWORD       cbLength;
    }
    smti;                               // Returnable track information
    BYTE            bRunningStatus;     // Running status for this track

}   TRACK,
    *PTRACK;

#define SMF_F_EOF               0x00000001L
#define SMF_F_MSMIDI            0x00000002L
#define SMF_F_INSERTSYSEX       0x00000004L
#define SMF_F_REMAPDRUM         0x00000008L

#define C_TEMPO_MAP_CHK     16
typedef struct tag_smf
{
    char            szName[128];
    HPBYTE          hpbImage;
    DWORD           cbImage;
    HTASK           htask;

    TICKS           tkPosition;
    TICKS           tkLength;
    TICKS           tkDiscardedEvents;
    DWORD           dwFormat;
    DWORD           dwTracks;
    DWORD           dwTimeDivision;
    DWORD           fdwSMF;
    WORD            wChanInUse;
    WORD            wChannelMask;

    DWORD           cTempoMap;
    DWORD           cTempoMapAlloc;
    HLOCAL          hTempoMap;
    PTEMPOMAPENTRY  pTempoMap;

    DWORD           dwPendingUserEvent;
    DWORD           cbPendingUserEvent;
    HPBYTE          hpbPendingUserEvent;

    PBYTE           pbTrackName;
    PBYTE           pbCopyright;

    WORD            awPatchCache[128];
    WORD            awKeyCache[128];
    
    // !!! new
    KEYFRAME	    kf;

    TRACK           rTracks[];
}   SMF;

typedef struct tagEVENT
{
    TICKS           tkDelta;            // Delta tick count for event
    DWORD           cbParm;             // Length of parameters if any
    HPBYTE          hpbParm;            // -> into image at paramters
    BYTE            abEvent[3];         // abEvent[0] == F0 or F7 for SysEx
                                        //            == FF for meta
                                        // Otherwise channel message (running
                                        // status expanded)
}   EVENT,
    BSTACK *SPEVENT;

#define EVENT_TYPE(event)       ((event).abEvent[0])
#define EVENT_CH_B1(event)      ((event).abEvent[1])
#define EVENT_CH_B2(event)      ((event).abEvent[2])

#define EVENT_META_TYPE(event)  ((event).abEvent[1])

//----------------------------------------------------------------------------
//
// Globals
//
extern UINT rbChanMsgLen[];


//----------------------------------------------------------------------------
// 
// Internal prototypes
//
// read.c
extern SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK *       ppsmf);

extern DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,
    DWORD               dwLeft,                                
    DWORD BSTACK *      pdw);

extern SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    SPEVENT             pevent,
    TICKS               tkMax);

//----------------------------------------------------------------------------
// 
// Stuff from MIDI specs
//

//
// Useful macros when dealing with hi-lo format integers
//
#define DWORDSWAP(dw) \
    ((((dw)>>24)&0x000000FFL)|\
    (((dw)>>8)&0x0000FF00L)|\
    (((dw)<<8)&0x00FF0000L)|\
    (((dw)<<24)&0xFF000000L))

#define WORDSWAP(w) \
    ((((w)>>8)&0x00FF)|\
    (((w)<<8)&0xFF00))

#define FOURCC_RMID     mmioFOURCC('R','M','I','D')
#define FOURCC_data     mmioFOURCC('d','a','t','a')
#define FOURCC_MThd     mmioFOURCC('M','T','h','d')
#define FOURCC_MTrk     mmioFOURCC('M','T','r','k')

typedef struct tag_chunkhdr
{
    FOURCC  fourccType;
    DWORD   dwLength;
}   CHUNKHDR,
    *PCHUNKHDR;

typedef struct tag_filehdr
{
    WORD    wFormat;
    WORD    wTracks;
    WORD    wDivision;
}   FILEHDR,
    *PFILEHDR;

// NOTE: This is arbitrary and only used if there is a tempo map but no
// entry at tick 0.
//
#define MIDI_DEFAULT_TEMPO      (500000L)

#define MIDI_MSG                ((BYTE)0x80)
#define MIDI_NOTEOFF            ((BYTE)0x80)
#define MIDI_NOTEON             ((BYTE)0x90)
#define MIDI_POLYPRESSURE       ((BYTE)0xA0)
#define MIDI_CONTROLCHANGE      ((BYTE)0xB0)
#define MIDI_PROGRAMCHANGE      ((BYTE)0xC0)
#define MIDI_CHANPRESSURE       ((BYTE)0xD0)
#define MIDI_PITCHBEND          ((BYTE)0xE0)
#define MIDI_META               ((BYTE)0xFF)
#define MIDI_SYSEX              ((BYTE)0xF0)
#define MIDI_SYSEXEND           ((BYTE)0xF7)

#define MIDI_META_COPYRIGHT     ((BYTE)0x02)
#define MIDI_META_TRACKNAME     ((BYTE)0x03)
#define MIDI_META_EOT           ((BYTE)0x2F)
#define MIDI_META_TEMPO         ((BYTE)0x51)
#define MIDI_META_TIMESIG       ((BYTE)0x58)
#define MIDI_META_KEYSIG        ((BYTE)0x59)
#define MIDI_META_SEQSPECIFIC   ((BYTE)0x7F)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\smfread.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    read.c

    DESCRIPTION:
      Routines for reading Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

UINT rbChanMsgLen[] =
{ 
    0,                      // 0x   not a status byte
    0,                      // 1x   not a status byte
    0,                      // 2x   not a status byte
    0,                      // 3x   not a status byte
    0,                      // 4x   not a status byte
    0,                      // 5x   not a status byte
    0,                      // 6x   not a status byte
    0,                      // 7x   not a status byte
    3,                      // 8x   Note off
    3,                      // 9x   Note on
    3,                      // Ax   Poly pressure
    3,                      // Bx   Control change
    2,                      // Cx   Program change
    2,                      // Dx   Chan pressure
    3,                      // Ex   Pitch bend change
    0,                      // Fx   SysEx (see below)                  
} ;

PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent);

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfBuildFileIndex | Preliminary parsing of a MIDI file.
 *
 * @parm PSMF BSTACK * | ppsmf | Pointer to a returned SMF structure if the
 *  file is successfully parsed.
 *
 * @comm
 *  This function validates the format of and existing MIDI or RMI file
 *  and builds the handle structure which will refer to it for the
 *  lifetime of the instance.
 *  
 *  The file header information will be read and verified, and
 *  <f smfBuildTrackIndices> will be called on every existing track
 *  to build keyframes and validate the track format.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory to build key frames.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfTrackIndices>
 *****************************************************************************/

SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK         *ppsmf)
{
    SMFRESULT           smfrc;
    CHUNKHDR UNALIGNED FAR *      pch;
    FILEHDR UNALIGNED FAR *       pfh;
    DWORD               i;
    PSMF                psmf,
                        psmfTemp;
    PTRACK              ptrk;
    WORD                wMemory;
    DWORD               dwLeft;
    HPBYTE              hpbImage;
    
    DWORD               idxTrack;
    EVENT               event;
    DWORD               dwLength;
    WORD                wChanInUse;
    WORD                wFirstNote;

    assert(ppsmf != NULL);

    psmf = *ppsmf;

    assert(psmf != NULL);

    // MIDI data image is already in hpbImage (already extracted from
    // RIFF header if necessary).
    //

    // Validate MIDI header
    //
    dwLeft   = psmf->cbImage;
    hpbImage = psmf->hpbImage;
    
    if (dwLeft < sizeof(CHUNKHDR))
        return SMF_INVALID_FILE;

    pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= sizeof(CHUNKHDR);
    hpbImage += sizeof(CHUNKHDR);
    
    if (pch->fourccType != FOURCC_MThd)
        return SMF_INVALID_FILE;

    dwLength = DWORDSWAP(pch->dwLength);
    if (dwLength < sizeof(FILEHDR) || dwLength > dwLeft)
        return SMF_INVALID_FILE;

    pfh = (FILEHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= dwLength;
    hpbImage += dwLength;
    
    psmf->dwFormat       = (DWORD)(WORDSWAP(pfh->wFormat));
    DPF(1, "*This MIDI file is format %ld", psmf->dwFormat);	// !!!
    psmf->dwTracks       = (DWORD)(WORDSWAP(pfh->wTracks));
    DPF(1, "*This MIDI file has %ld tracks", psmf->dwTracks);	// !!!
    psmf->dwTimeDivision = (DWORD)(WORDSWAP(pfh->wDivision));

    //
    // We've successfully parsed the header. Now try to build the track
    // index.
    // 
    // We only check out the track header chunk here; the track will be
    // preparsed after we do a quick integretiy check.
    //
    wMemory = sizeof(SMF) + (WORD)(psmf->dwTracks*sizeof(TRACK));
    psmfTemp = (PSMF)LocalReAlloc((HLOCAL)psmf, wMemory, LMEM_MOVEABLE|LMEM_ZEROINIT);

    if (NULL == psmfTemp)
    {
        DPF(1, "No memory for extended psmf");
        return SMF_NO_MEMORY;
    }

    psmf = *ppsmf = psmfTemp;
    ptrk = psmf->rTracks;
    
    for (i=0; i<psmf->dwTracks; i++)
    {
        if (dwLeft < sizeof(CHUNKHDR))
            return SMF_INVALID_FILE;

        pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

        dwLeft   -= sizeof(CHUNKHDR);
        hpbImage += sizeof(CHUNKHDR);

        if (pch->fourccType != FOURCC_MTrk)
            return SMF_INVALID_FILE;
        
        ptrk->idxTrack      = (DWORD)(hpbImage - psmf->hpbImage);
        ptrk->smti.cbLength = DWORDSWAP(pch->dwLength);

        if (ptrk->smti.cbLength > dwLeft)
        {
            DPF(1, "Track longer than file!");
            return SMF_INVALID_FILE;
        }

        dwLeft   -= ptrk->smti.cbLength;
        hpbImage += ptrk->smti.cbLength;

        ptrk++;
    }

    // File looks OK. Now preparse, doing the following:
    // (1) Build tempo map so we can convert to/from ticks quickly
    // (2) Determine actual tick length of file
    // (3) Validate all events in all tracks
    // 
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

//    for (idxTrack=0,ptrk=psmf->rTracks; idxTrack < psmf->dwTracks; idxTrack++,ptrk++)
//    {
//        DPF(1, "Track %lu ptrk %04X ptrk->hpbImage %08lX", (DWORD)idxTrack, (WORD)ptrk, (DWORD)ptrk->hpbImage);
//    }

    psmf->awPatchCache[0] = 0xFDFF; // assume default patch on all but channel 10
    wFirstNote = wChanInUse = 0;
    while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (EVENT BSTACK *)&event, MAX_TICKS)))
    {
        // track whether a channel is used, and whether we have seen
        // the first note-on event yet
        //
        if (0xF0 != (EVENT_TYPE(event)))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            wChanInUse |= wChan;
            if ((EVENT_TYPE(event) & 0xF0) == 0x80) // if note on
                wFirstNote |= wChan;
        }
            
        if (MIDI_META == EVENT_TYPE(event))
        {
            switch(EVENT_META_TYPE(event))
            {
                case MIDI_META_TEMPO:
                    if (SMF_SUCCESS != (smfrc = smfAddTempoMapEntry(psmf, (EVENT BSTACK *)&event)))
                    {
                        return smfrc;
                    }
                    break;

                case MIDI_META_SEQSPECIFIC:
                    if (3 == event.cbParm &&
                        event.hpbParm[0] == 0x00 &&
                        event.hpbParm[1] == 0x00 &&
                        event.hpbParm[2] == 0x41)
                    {
                        DPF(1, "This file is MSMIDI");
                        psmf->fdwSMF |= SMF_F_MSMIDI;
                    }
                    break;

                case MIDI_META_TRACKNAME:
                    if (psmf->pbTrackName)
                        LocalFree((HLOCAL)psmf->pbTrackName);

                    psmf->pbTrackName = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbTrackName)
                    {
                        hmemcpy((HPBYTE)psmf->pbTrackName, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbTrackName[(UINT)event.cbParm] = '\0';
                    }
                    break;
                    
                case MIDI_META_COPYRIGHT:
                    if (psmf->pbCopyright)
                        LocalFree((HLOCAL)psmf->pbCopyright);

                    psmf->pbCopyright = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbCopyright)
                    {
                        hmemcpy((HPBYTE)psmf->pbCopyright, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbCopyright[(UINT)event.cbParm] = '\0';
                    }
                    break;
            }
        }
        else if (MIDI_PROGRAMCHANGE == (EVENT_TYPE(event)&0xF0))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            //
            // if this channel has a patch change, and it is
            // before the first keydown event on the channel
            // clear the 'default' patch and set the bit
            // for the requested patch
            //
            if (!(wFirstNote & wChan))
               psmf->awPatchCache[0] &= ~wChan;
            psmf->awPatchCache[EVENT_CH_B1(event)] |= wChan;
        }
        else if (EV_DRUM_BASE == EVENT_TYPE(event) ||
                 EV_DRUM_EXT  == EVENT_TYPE(event))
        {
            psmf->awKeyCache[EVENT_CH_B1(event)]
                |= (1 << (EVENT_TYPE(event)&0x0F));
        }
    }

    psmf->wChanInUse = wChanInUse;
    
    if (SMF_END_OF_FILE == smfrc || SMF_SUCCESS == smfrc)
    {
	// !!! Will format 2 work?
        // NOTE: This is wrong for format 2, where the tracks are end-to-end
        //
        psmf->tkLength = psmf->tkPosition;
        smfrc = SMF_SUCCESS;
    }

    // Do something reasonable if we don't have a tempo entry in the file
    //
    if (SMF_SUCCESS == smfrc && 0 == psmf->cTempoMap)
    {
        if (NULL == (psmf->hTempoMap = LocalAlloc(LHND, sizeof(TEMPOMAPENTRY))))
            return SMF_NO_MEMORY;

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap);

        psmf->cTempoMap = 1;
        psmf->cTempoMapAlloc = 1;

        psmf->pTempoMap->tkTempo = 0;
        psmf->pTempoMap->msBase = 0;
        psmf->pTempoMap->dwTempo = MIDI_DEFAULT_TEMPO;
    }
        
    return smfrc;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfAddTempoMapEntry | Adds a tempo map entry.
 *
 * @parm PSMF | psmf | Pointer to the owning SMF structure.
 *
 * @parm PEVENT BSTACK * | pevent | Pointer to the tempo event.
 *
 * @comm
 *  Add the event to the map.
 *  
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory in the local heap for the map.
 * 
 * @xref <f smfBuildTrackIndex>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent)
{
    BOOL                    fFirst;
    HLOCAL                  hlocal;
    PTEMPOMAPENTRY          pTempo;
    DWORD                   dwTempo;
    
    if (3 != pevent->cbParm)
    {
        return SMF_INVALID_FILE;
    }

    dwTempo = (((DWORD)pevent->hpbParm[0])<<16)|
              (((DWORD)pevent->hpbParm[1])<<8)|
              ((DWORD)pevent->hpbParm[2]);

    // Some MIDI files have tempo changes strewn through them at regular
    // intervals even tho the tempo never changes -- or they have the same
    // tempo change across all tracks to the same value. In either case, most
    // of the changes are redundant -- don't waste memory storing them.
    //
    if (psmf->cTempoMap)
        if (psmf->pTempoMap[psmf->cTempoMap-1].dwTempo == dwTempo)
            return SMF_SUCCESS;

    fFirst = FALSE;
    if (psmf->cTempoMap == psmf->cTempoMapAlloc)
    {
        if (NULL != psmf->hTempoMap)
        {
            LocalUnlock(psmf->hTempoMap);
        }

        psmf->cTempoMapAlloc += C_TEMPO_MAP_CHK;
        fFirst = FALSE;
        if (0 == psmf->cTempoMap)
        {
            hlocal = LocalAlloc(LHND, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)));
            fFirst = TRUE;
        }
        else
        {
            hlocal = LocalReAlloc(psmf->hTempoMap, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)), LHND);
        }

        if (NULL == hlocal)
        {
            return SMF_NO_MEMORY;
        }

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap = hlocal);
    }

    if (fFirst && psmf->tkPosition != 0)
    {
        // Inserting first event and the absolute time is zero.
        // This is not good since we have no idea what the tempo
        // should be; assume the standard 500,000 uSec/QN (120 BPM
        // at 4/4 time).
        //

        pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

        pTempo->tkTempo = 0;
        pTempo->msBase  = 0;
        pTempo->dwTempo = MIDI_DEFAULT_TEMPO;

        fFirst = FALSE;
    }

    pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

    pTempo->tkTempo = psmf->tkPosition;
    if (fFirst)
    {
        pTempo->msBase = 0;
    }
    else
    {
        // NOTE: Better not be here unless we're q/n format!
        //
        pTempo->msBase = (pTempo-1)->msBase +
                         muldiv32(pTempo->tkTempo-((pTempo-1)->tkTempo),
                                  (pTempo-1)->dwTempo,
                                  1000L*psmf->dwTimeDivision);
    }
    
    pTempo->dwTempo = dwTempo;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfGetNextEvent | Read the next event from the given
 *  file.
 *
 * @parm PSMF | psmf | File to read the event from.
 *
 * @parm SPEVENT | pevent | Pointer to an event structure which will receive
 *  basic information about the event.
 *
 * @parm TICKS | tkMax | Tick destination. An attempt to read past this
 *  position in the file will fail.
 *
 * @comm
 *  This is the lowest level of parsing for a raw MIDI stream. The basic
 *  information about one event in the file will be returned in <p pevent>.
 *
 *  Merging data from all tracks into one stream is performed here.
 * 
 *  <p pevent!tkDelta> will contain the tick delta for the event.
 *
 *  <p pevent!abEvent> will contain a description of the event.
 *   <p pevent!abEvent[0]> will contain
 *    F0 or F7 for a System Exclusive message.
 *    FF for a MIDI file meta event.
 *    The status byte of any other MIDI message. (Running status will
 *    be tracked and expanded).
 *
 *  <p pevent!cbParm> will contain the number of bytes of paramter data
 *   which is still in the file behind the event header already read.
 *   This data may be read with <f smfGetTrackEventData>. Any unread
 *   data will be skipped on the next call to <f smfGetNextTrackEvent>.
 *
 *  Channel messages (0x8? - 0xE?) will always be returned fully in
 *   <p pevent!abEvent>.
 *
 *  Meta events will contain the meta type in <p pevent!abEvent[1]>.
 *
 *  System exclusive events will contain only an 0xF0 or 0xF7 in
 *   <p pevent!abEvent[0]>.
 *
 *  The following fields in <p ptrk> are used to maintain state and must
 *  be updated if a seek-in-track is performed:
 *
 *  <f bRunningStatus> contains the last running status message or 0 if
 *   there is no valid running status.
 *
 *  <f hpbImage> is a pointer into the file image of the first byte of
 *   the event to follow the event just read.
 *
 *  <f dwLeft> contains the number of bytes from hpbImage to the end
 *   of the track.
 *
 *
 * Get the next due event from all (in-use?) tracks
 *
 * For all tracks
 *  If not end-of-track
 *   decode event delta time without advancing through buffer
 *   event_absolute_time = track_tick_time + track_event_delta_time
 *   relative_time = event_absolute_time - last_stream_time
 *   if relative_time is lowest so far
 *    save this track as the next to pull from, along with times
 *
 * If we found a track with a due event
 *  Advance track pointer past event, saving ptr to parm data if needed
 *  track_tick_time += track_event_delta_time
 *  last_stream_time = track_tick_time
 * Else
 *  Mark and return end_of_file
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_FILE | There are no more events to read in this track.
 *  @flag SMF_REACHED_TKMAX | No event was read because <p tkMax> was reached.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfGetTrackEventData>
 *****************************************************************************/

SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    EVENT BSTACK *      pevent,
    TICKS               tkMax)
{
    PTRACK              ptrk;
    PTRACK              ptrkFound;
    DWORD               idxTrack;
    TICKS               tkEventDelta;
    TICKS               tkRelTime;
    TICKS               tkMinRelTime;
    BYTE                bEvent;
    DWORD               dwGotTotal;
    DWORD               dwGot;
    DWORD               cbEvent;
    WORD                wChannelMask;

    assert(psmf != NULL);
    assert(pevent != NULL);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        return SMF_END_OF_FILE;
    }

    pevent->tkDelta = 0;

    for(;;)
    {
        ptrkFound       = NULL;
        tkMinRelTime    = MAX_TICKS;

        for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
        {
            if (ptrk->fdwTrack & SMF_TF_EOT)
                continue;

            //        DPF(1, "ptrk %04X ptrk->hpbImage %08lX", (WORD)ptrk, (DWORD)ptrk->hpbImage);

            if (!smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta))
            {
                DPF(1, "Hit end of track w/o end marker!");
                return SMF_INVALID_FILE;
            }

            tkRelTime = ptrk->tkPosition + tkEventDelta - psmf->tkPosition;

            if (tkRelTime < tkMinRelTime)
            {
                tkMinRelTime = tkRelTime;
                ptrkFound = ptrk;
            }
        }

        if (!ptrkFound)
        {
            DPF(2, "END_OF_FILE!");

	    // !!! poor API!!! This prevents Read(100), Read(200) from
	    // working, because the Read(200) will fail just because the
	    // Read(100) succeeded and says that the EOF is reached!
            // pSmf->fdwSMF |= SMF_F_EOF;
            return SMF_END_OF_FILE;
        }

        ptrk = ptrkFound;

        if (psmf->tkPosition + tkMinRelTime > tkMax)
        {
            return SMF_REACHED_TKMAX;
        }


        ptrk->hpbImage += (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta));
        ptrk->cbLeft   -= dwGot;

        // We MUST have at least three bytes here (cause we haven't hit
        // the end-of-track meta yet, which is three bytes long). Checking
        // against three means we don't have to check how much is left
        // in the track again for any short event, which is most cases.
        //
        if (ptrk->cbLeft < 3)
        {
            return SMF_INVALID_FILE;
        }

        ptrk->tkPosition += tkEventDelta;
        pevent->tkDelta += ptrk->tkPosition - psmf->tkPosition;

        bEvent = *ptrk->hpbImage++;

        if (MIDI_MSG > bEvent)
        {
            if (0 == ptrk->bRunningStatus)
            {
                DPF(1, "Need running status; it's zero");
                return SMF_INVALID_FILE;
            }

            dwGotTotal = 1;
            pevent->abEvent[0] = ptrk->bRunningStatus;
            pevent->abEvent[1] = bEvent;
            if (3 == rbChanMsgLen[(ptrk->bRunningStatus >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else if (MIDI_SYSEX > bEvent)
        {
            ptrk->bRunningStatus = bEvent;
            
            dwGotTotal = 2;
            pevent->abEvent[0] = bEvent;
            pevent->abEvent[1] = *ptrk->hpbImage++;
            if (3 == rbChanMsgLen[(bEvent >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else
        {
            // Even though the SMF spec says that meta and SysEx clear
            // running status, there are files out there that make the
            // assumption that you can span running status across these
            // events (Knowledge Adventure's Aviation Adventure). So we
            // do NOT clear running status here
            //
            if (MIDI_META == bEvent)
            {
                pevent->abEvent[0] = MIDI_META;
                if (MIDI_META_EOT == (pevent->abEvent[1] = *ptrk->hpbImage++))
                {
                    ptrk->fdwTrack |= SMF_TF_EOT;
                }

                dwGotTotal = 2;
            }
            else if (MIDI_SYSEX == bEvent || MIDI_SYSEXEND == bEvent)
            {
                pevent->abEvent[0] = bEvent;
                dwGotTotal = 1;
            }
            else
            {
                return SMF_INVALID_FILE;
            }

            if (0 == (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft - 2, (DWORD BSTACK *)&cbEvent)))
            {
                return SMF_INVALID_FILE;
            }

            ptrk->hpbImage  += dwGot;
            dwGotTotal      += dwGot;

            if (dwGotTotal + cbEvent > ptrk->cbLeft)
            {
                return SMF_INVALID_FILE;
            }

            pevent->cbParm  = cbEvent;
            pevent->hpbParm = ptrk->hpbImage;

            ptrk->hpbImage += cbEvent;
            dwGotTotal     += cbEvent;
        }

        // DON'T update total file time based including end-of-track
        // deltas -- these are sometimes way off
        //
        if (!(ptrk->fdwTrack & SMF_TF_EOT))
            psmf->tkPosition = ptrk->tkPosition;
        
        assert(ptrk->cbLeft >= dwGotTotal);

        ptrk->cbLeft -= dwGotTotal;

        if (MIDI_SYSEX > pevent->abEvent[0])
        {
            wChannelMask = 1 << (pevent->abEvent[0] & 0x0F);
            if (!(wChannelMask & psmf->wChannelMask))
            {
//                DPF(3, "Skip event mask=%04X", wChannelMask);
                continue;
            }
        }

        return SMF_SUCCESS;
    }
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func BOOL | smfGetVDword | Reads a variable length DWORD from
 *  the given file.
 *
 * @parm HPBYTE | hpbImage | Pointer to the first byte of the VDWORD.
 *
 * @parm DWORD | dwLeft | Bytes left in image
 *
 *
 * @parm DWORD BSTACK * | pdw | Pointer to a DWORD to store the result in.
 *  track.
 *
 * @comm
 *  A variable length DWORD stored in a MIDI file contains one or more
 *  bytes. Each byte except the last has the high bit set; only the
 *  low 7 bits are significant.
 *  
 * @rdesc # of bytes consumed on success; else 0.
 * 
 *****************************************************************************/

DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,                                
    DWORD               dwLeft,                               
    DWORD BSTACK *      pdw)
{
    BYTE                b;
    DWORD               dwUsed  = 0;

    assert(hpbImage != NULL);
    assert(pdw != NULL);
    
    *pdw = 0;

    do
    {
        if (!dwLeft)
        {
            return 0;
        }

        b = *hpbImage++;
        dwLeft--;
        dwUsed++;
        
        *pdw = (*pdw << 7) | (b & 0x7F);
    } while (b&0x80);

    return dwUsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\jconfig.h ===
/*
 * jconfig.doc
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file documents the configuration options that are required to
 * customize the JPEG software for a particular system.
 *
 * The actual configuration options for a particular installation are stored
 * in jconfig.h.  On many machines, jconfig.h can be generated automatically
 * or copied from one of the "canned" jconfig files that we supply.  But if
 * you need to generate a jconfig.h file by hand, this file tells you how.
 *
 * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
 * EDIT A COPY NAMED JCONFIG.H.
 */

/* jcb */

#define ALIGN_TYPE double

/*
 * These symbols indicate the properties of your machine or compiler.
 * #define the symbol if yes, #undef it if no.
 */

/* Does your compiler support function prototypes?
 * (If not, you also need to use ansi2knr, see install.doc)
 */
#define HAVE_PROTOTYPES

/* Does your compiler support the declaration "unsigned char" ?
 * How about "unsigned short" ?
 */
#define HAVE_UNSIGNED_CHAR
#define HAVE_UNSIGNED_SHORT

/* Define "void" as "char" if your compiler doesn't know about type void.
 * NOTE: be sure to define void such that "void *" represents the most general
 * pointer type, e.g., that returned by malloc().
 */
/* #define void char */

/* Define "const" as empty if your compiler doesn't know the "const" keyword.
 */
/* #define const */

/* Define this if an ordinary "char" type is unsigned.
 * If you're not sure, leaving it undefined will work at some cost in speed.
 * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
 */
#define CHAR_IS_UNSIGNED

/* Define this if your system has an ANSI-conforming <stddef.h> file.
 */
#define HAVE_STDDEF_H

/* Define this if your system has an ANSI-conforming <stdlib.h> file.
 */
#define HAVE_STDLIB_H

/* Define this if your system does not have an ANSI/SysV <string.h>,
 * but does have a BSD-style <strings.h>.
 */
#undef NEED_BSD_STRINGS

/* Define this if your system does not provide typedef size_t in any of the
 * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
 * <sys/types.h> instead.
 */
#undef NEED_SYS_TYPES_H

/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
 * unless you are using a large-data memory model or 80386 flat-memory mode.
 * On less brain-damaged CPUs this symbol must not be defined.
 * (Defining this symbol causes large data structures to be referenced through
 * "far" pointers and to be allocated with a special version of malloc.)
 */
#undef NEED_FAR_POINTERS

/* Define this if your linker needs global names to be unique in less
 * than the first 15 characters.
 */
#undef NEED_SHORT_EXTERNAL_NAMES

/* Although a real ANSI C compiler can deal perfectly well with pointers to
 * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
 * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
 * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
 * actually get "missing structure definition" warnings or errors while
 * compiling the JPEG code.
 */
#undef INCOMPLETE_TYPES_BROKEN


/*
 * The following options affect code selection within the JPEG library,
 * but they don't need to be visible to applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS has been defined.
 */

#ifdef JPEG_INTERNALS

/* Define this if your compiler implements ">>" on signed values as a logical
 * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
 * which is the normal and rational definition.
 */
#undef RIGHT_SHIFT_IS_UNSIGNED


#endif /* JPEG_INTERNALS */


/*
 * The remaining options do not affect the JPEG library proper,
 * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).
 * Other applications can ignore these.
 */

#ifdef JPEG_CJPEG_DJPEG

/* These defines indicate which image (non-JPEG) file formats are allowed. */

#define BMP_SUPPORTED		/* BMP image file format */
#define GIF_SUPPORTED		/* GIF image file format */
#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
#undef RLE_SUPPORTED		/* Utah RLE image file format */
#define TARGA_SUPPORTED		/* Targa image file format */

/* Define this if you want to name both input and output files on the command
 * line, rather than using stdout and optionally stdin.  You MUST do this if
 * your system can't cope with binary I/O to stdin/stdout.  See comments at
 * head of cjpeg.c or djpeg.c.
 */
#define TWO_FILE_COMMANDLINE

/* Define this if your system needs explicit cleanup of temporary files.
 * This is crucial under MS-DOS, where the temporary "files" may be areas
 * of extended memory; on most other systems it's not as important.
 */
#undef NEED_SIGNAL_CATCHER

/* By default, we open image files with fopen(...,"rb") or fopen(...,"wb").
 * This is necessary on systems that distinguish text files from binary files,
 * and is harmless on most systems that don't.  If you have one of the rare
 * systems that complains about the "b" spec, define this symbol.
 */
#undef DONT_USE_B_MODE

/* Define this if you want percent-done progress reports from cjpeg/djpeg.
 */
#undef PROGRESS_REPORT


#endif /* JPEG_CJPEG_DJPEG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\midi\midifile.cpp ===
/****************************************************************************
 *
 *  MIDIFILE.CPP
 *
 *  routines for reading/writing MIDI files
 *
 ***************************************************************************/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#include <streams.h>
#include <mmsystem.h>
#include <vfw.h>

#include "muldiv32.h"
#include "midif.h"
#include "handler.h"

#undef hmemcpy
#define hmemcpy memmoveInternal

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#ifdef FILTER_LIB

// fix separate dll build
//
// this stuff only appears to be needed when
// building as lib to link into Quartz.dll.
// Elsewise picked up from...?

//
// This is a bit of a hack... we need two of the AVI GUIDs defined
// within this file.  Sigh...
//

#define REALLYDEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#define REALLYDEFINE_AVIGUID(name, l, w1, w2) \
    REALLYDEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

REALLYDEFINE_AVIGUID(IID_IAVIFile,       0x00020020, 0, 0);
REALLYDEFINE_AVIGUID(IID_IAVIStream,       0x00020021, 0, 0);
//end of declare guid hack

#endif

/*      -       -       -       -       -       -       -       -       */

// We break MIDI data up into samples of 1s each - constant time, variable
// size.
#define MSPERSAMPLE	1000L	// smaller buffers break up too often

/*      -       -       -       -       -       -       -       -       */

//
// External function called by the Class Factory to create an instance of
// the MIDI file reader/writer
//
CUnknown *CMIDIFile::CreateInstance(LPUNKNOWN pUnknownOuter, HRESULT *phr)
{
    CMIDIFile *   pMIDIFile;

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFile::CreateInstance")));

    pMIDIFile = new CMIDIFile(pUnknownOuter, phr);
    if (!pMIDIFile) {
	*phr = E_OUTOFMEMORY;
	return NULL;
    }

    return pMIDIFile;
}
/*      -       -       -       -       -       -       -       -       */

//
// Random C++ stuff: constructors & such...
//
CMIDIFile::CMIDIFile(IUnknown FAR* pUnknownOuter, HRESULT *phr) :
   CUnknown(NAME("MIDI file reader"), pUnknownOuter),
	m_lLastSampleRead(0),
        m_fStreamPresent(FALSE),
        m_fDirty(FALSE),
        //mode;
        //finfo;
        //sinfo;
	m_hsmf(NULL),
	m_hsmfK(NULL),
	m_dwTimeDivision(0)
{
    DbgLog((LOG_TRACE,1,TEXT("CMIDIFile::CMIDIFile")));
}

CMIDIFile::~CMIDIFile()
{
    DbgLog((LOG_TRACE,1,TEXT("CMIDIFile::~CMIDIFile")));
    if (m_hsmf)
        smfCloseFile(m_hsmf);
    if (m_hsmfK)
        smfCloseFile(m_hsmfK);
}


/*      -       -       -       -       -       -       -       -       */

//
// This QueryInterface function allows a caller to move between the various
// interfaces the object presents
//
STDMETHODIMP CMIDIFile::NonDelegatingQueryInterface(const IID&  iid, void **ppv)
{

    if (ppv)
        *ppv = NULL;

    if (iid == IID_IAVIFile) {
        DbgLog((LOG_TRACE,3,TEXT("CMIDIFile::QI for IAVIFile")));
        return GetInterface((IAVIFile *) this, ppv);
    } else if (iid == IID_IAVIStream) {
        DbgLog((LOG_TRACE,3,TEXT("CMIDIFile::QI for IAVIStream")));
        return GetInterface((IAVIStream *) this, ppv);
    } else if (iid == IID_IPersistFile) {
        DbgLog((LOG_TRACE,3,TEXT("CMIDIFile::QI for IPersistFile")));
        return GetInterface((IPersistFile *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(iid, ppv);
    }
}

// *** IPersist methods ***
STDMETHODIMP CMIDIFile::GetClassID (LPCLSID lpClassID)
{
    *lpClassID = CLSID_MIDIFileReader;

    return NOERROR;
}

// *** IPersistFile methods ***
STDMETHODIMP CMIDIFile::IsDirty ()
{
    if (m_fDirty) {
        return NOERROR;
    } else {
        return ResultFromScode(S_FALSE);
    }
}

/*      -       -       -       -       -       -       -       -       */

#if defined _WIN32 && !defined UNICODE

int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer)
{
    char    ach[128];
    int	    i;

    i = LoadString(hinst, wID, ach, sizeof(ach));
    if (i > 0)
	MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer);
    return i;
}

#else
#define LoadUnicodeString   LoadString
#endif

/*      -       -       -       -       -       -       -       -       */

#if 0
// !!! This function won't push ebp and will blow up
#pragma optimize("", off)
#endif

//
// "Open" a MIDI file
//
STDMETHODIMP CMIDIFile::Load (LPCOLESTR szFile, DWORD mode)
{
    SMFOPENFILESTRUCT	smf, smfK;
    SMFFILEINFO	sfi;
    DWORD	dwLength;
    BOOL	f;
    char	szFileA[MAX_PATH];

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFile::Load")));
    CheckPointer(szFile, E_POINTER);

    // Believe it or not, this will convert the OLE Unicode string to ANSI
    wsprintf(szFileA, "%ls", szFile);

    m_mode = mode;

    if (m_mode & OF_CREATE) {
	//
	// They're creating a "new" sequence - not supported
	//
	m_fStreamPresent = FALSE;
        DbgLog((LOG_ERROR,1,TEXT("*Error: Creating a file unsupported")));
        return ResultFromScode(AVIERR_UNSUPPORTED);
    } else {

	//
	// They're opening an existing sequence
	//
	m_fStreamPresent = TRUE;

	//
	// Something bogus to force a seek on first read
	//
	m_lLastSampleRead = -64;

	//
	// Build a stream header....
	//
	_fmemset(&m_sinfo, 0, sizeof(m_sinfo));
	m_sinfo.fccType = streamtypeMIDI;
	m_sinfo.dwFlags = 0;
	m_sinfo.dwScale = MSPERSAMPLE;
	m_sinfo.dwRate = 1000;
	m_sinfo.dwSampleSize = 0;	// variable size samples
	// !!! Is this right?
	m_sinfo.dwSuggestedBufferSize=muldiv32(31250L * 4, MSPERSAMPLE, 1000L);
	LoadUnicodeString(g_hInst, IDS_STREAMNAME,
            m_sinfo.szName,	// !!!
            sizeof(m_sinfo.szName));

	//
	// ... and a file header.
	//
	_fmemset(&m_finfo, 0, sizeof(m_finfo));
	// Our format takes more space than the actual MIDI bytes
	// !!! Hope nobody authors a higher data rate ?
	m_finfo.dwMaxBytesPerSec = 31250L * 4;
	m_finfo.dwRate = 1000L;
	m_finfo.dwScale = MSPERSAMPLE;
	m_finfo.dwStreams = 1;
	// !!! Max size for each sample - is this right?
	m_finfo.dwSuggestedBufferSize=muldiv32(31250L * 4, MSPERSAMPLE, 1000L);
	m_finfo.dwCaps = AVIFILECAPS_CANREAD |
			AVIFILECAPS_CANWRITE |
			// !!! Is it?
			// AVIFILECAPS_ALLKEYFRAMES |
			AVIFILECAPS_NOCOMPRESSION;
	LoadUnicodeString(g_hInst, IDS_FILETYPE,
            m_finfo.szFileType,	// !!!
            sizeof(m_finfo.szFileType));

	// !!! What about the share bug?  We let some random API try to open
	// the file.

	// Open the MIDI file for reading contiguosly
	smf.pstrName = (LPSTR)szFileA;
        f = smfOpenFile(&smf);
	if (f != SMF_SUCCESS) {
            DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file"), (int)f));
	    return ResultFromScode(AVIERR_FILEREAD);
	}
	m_hsmf = smf.hsmf;

	// Open it again for seeking to get keyframe info.  The only way to
	// get a nice midiStreamOut buffer is to read contiguously without
	// seeking in between reads, so we need a separate file handle to
	// to the seeking.
	smfK.pstrName = (LPSTR)szFileA;
        f = smfOpenFile(&smfK);
	if (f != SMF_SUCCESS) {
	    smfCloseFile(smf.hsmf);	// close first opened instance
            DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file second time"),
								(int)f));
	    return ResultFromScode(AVIERR_FILEREAD);
	}
	m_hsmfK = smfK.hsmf;

	//
	// Fix up the length (in samples) in the header structures
	//
	f = smfGetFileInfo(m_hsmf, &sfi);
	if (f != SMF_SUCCESS) {
            DbgLog((LOG_ERROR,1,TEXT("*Error %d from smfGetFileInfo"), f));
	    // !!! Now what?
	}
	m_dwTimeDivision = sfi.dwTimeDivision;	// save for the format
	// Get the length of the file in ms and convert to samples
	dwLength = smfTicksToMillisecs(m_hsmf, sfi.tkLength);
	m_sinfo.dwLength = (dwLength + MSPERSAMPLE - 1) / MSPERSAMPLE;
	m_finfo.dwLength = m_sinfo.dwLength;
    }

    //
    // all done return success.
    //
    return ResultFromScode(0); // success
}

#pragma optimize("", on)

STDMETHODIMP CMIDIFile::Save (LPCOLESTR lpszFileName, BOOL fRemember)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::SaveCompleted (LPCOLESTR lpszFileName)
{
    return NOERROR;
}

STDMETHODIMP CMIDIFile::GetCurFile (LPOLESTR FAR * lplpszFileName)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

// -------------------- IAVIFile Implementation-----------------------

//
// The GetStream method returns an interface pointer to the video stream,
// assuming one exists.
//
STDMETHODIMP CMIDIFile::GetStream(PAVISTREAM FAR * ppavi, DWORD fccType, LPARAM lParam)
{
    int             iStreamWant;

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFile::GetStream")));

    iStreamWant = (int)lParam;

    if (!m_fStreamPresent)
	return ResultFromScode(-1);

    // We only support one stream
    if (lParam != 0)
	return ResultFromScode(-1);

    // We only support a midi stream
    if (fccType && fccType != streamtypeVIDEO)
	return ResultFromScode(-1);

    //
    // Be sure to keep the reference count up to date...
    //
    AddRef();

    *ppavi = (PAVISTREAM)this;
    return ResultFromScode(AVIERR_OK);
}

STDMETHODIMP CMIDIFile::CreateStream(PAVISTREAM FAR *ppstream, AVISTREAMINFOW FAR *psi)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::EndRecord(void)
{
    return ResultFromScode(AVIERR_OK);
}

STDMETHODIMP CMIDIFile::Info(AVIFILEINFOW FAR * pfi, LONG lSize)
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIFile::Info (file)")));

    if (pfi && lSize)
	hmemcpy(pfi, &m_finfo, min(lSize, sizeof(m_finfo)));
    return 0;
}

STDMETHODIMP CMIDIFile::DeleteStream(DWORD fccType, LPARAM lParam)
{
    return ResultFromScode(E_FAIL);
}

// -------------------- IAVIStream Implementation-----------------------

STDMETHODIMP CMIDIFile::Create(LPARAM lParam1, LPARAM lParam2)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

//
// Returns information about key frames, format changes, etc.
//
STDMETHODIMP_(LONG) CMIDIFile::FindSample(LONG lPos, LONG lFlags)
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIFile::FindSample")));

    // !!! What if there are long periods of silence? There could be empty ones.
    if ((lFlags & FIND_TYPE) == FIND_ANY) {
	if ((lFlags & FIND_DIR) == FIND_FROM_START)
	    return 0L;
	else if (lPos < 0 || lPos >= (LONG) m_sinfo.dwLength)
	    return -1;
	else
	    return lPos;
    }

    // !!! Someday don't have all key frames.  Would MCIAVI actually work, I
    // wonder?
    if ((lFlags & FIND_TYPE) == FIND_KEY) {
	if ((lFlags & FIND_DIR) == FIND_FROM_START)
	    return 0L;
	else if (lPos < 0 || lPos >= (LONG) m_sinfo.dwLength)
	    return -1;
	else
	    return lPos;
    }

    // This one is actually correct!
    if ((lFlags & FIND_TYPE) == FIND_FORMAT) {
	if ((lFlags & FIND_DIR) == FIND_FROM_START)
	    return 0L;
	else if (lPos < 0 || lPos >= (LONG) m_sinfo.dwLength)
	    return -1;
	else if ((lFlags & FIND_DIR) == FIND_PREV)
	    return lPos;
	else if ((lFlags & FIND_DIR) == FIND_NEXT) {
	    if (lPos == 0)
		return lPos;
	    else
		return -1;
	}
    }

    // What could they be asking for?
    return -1;
}

//
// The ReadFormat method returns the format of the specified frame....
//
STDMETHODIMP CMIDIFile::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    MIDIFORMAT	midifmt;

    DbgLog((LOG_TRACE,2,TEXT("CMIDIFile::ReadFormat")));

    // The format is the time division of the file
    _fmemset(&midifmt, 0, sizeof(midifmt));
    midifmt.dwDivision = m_dwTimeDivision;

    // No buffer to fill in, this means return the size needed.
    if (lpFormat == NULL || lpcbFormat == NULL || *lpcbFormat == 0) {
	if (lpcbFormat)
	    *lpcbFormat = sizeof(MIDIFORMAT);
	return 0;
    }

    //
    // and return as much of the format as will fit.
    //
    hmemcpy(lpFormat, &midifmt, min(*lpcbFormat, sizeof(midifmt)));
    *lpcbFormat = sizeof(MIDIFORMAT);
    return 0;
}

STDMETHODIMP CMIDIFile::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIFile::Info (stream)")));

    if (psi && lSize)
	hmemcpy(psi, &m_sinfo, min(lSize, sizeof(m_sinfo)));
    return 0;
}

STDMETHODIMP CMIDIFile::Read(LONG lStart, LONG lSamples,
	LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes,
	LONG FAR * plSamples)
{
    DWORD	dwSize, dwReadSize;
    LPMIDIHDR	lpmh;
    TICKS	tk;
    LPBYTE	lp = NULL;
    HRESULT	hr;
    SMFRESULT	smfrc;

    DbgLog((LOG_TRACE,3,TEXT("CMIDIFile::Read Position %ld"), lStart));

    // Invalid position
    if (lStart < 0 || lStart >= (LONG) m_sinfo.dwLength) {
	if (plBytes)
	    *plBytes = 0;
	if (plSamples)
	    *plSamples = 0;
	return AVIERR_BADPARAM;
    }

    // We have variable length samples and can only read one at a time, since
    // there's no way to pull out individual samples from a bunch of them.
    if (lSamples > 1)
	lSamples = 1;

    // Allocate some memory for the keyframe info and for the events
    dwSize = 2 * sizeof(MIDIHDR) + smfGetStateMaxSize() +
	muldiv32(lSamples * MSPERSAMPLE, 31250 * 4, 1000);	// !!!
    if ((lp = (LPBYTE)GlobalAllocPtr(GHND, dwSize)) == NULL)
	return AVIERR_MEMORY;

    // !!! MCIAVI can't play with more granularity than our sample size, so
    // !!! AVI files could get out of sync as much as MSPERSAMPLE ms!

    // Seek to the spot we'll begin reading from, and get keyframe info to
    // write our keyframe. Since this disturbs reading the file contiguously,
    // we have our own file handle for this.

    tk = smfMillisecsToTicks(m_hsmfK, lStart * MSPERSAMPLE);
    lpmh = (LPMIDIHDR)lp;
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;

    // the API smfSeek() starts looking from the beginning, and takes forever
    // if you are seeking way into the file.  We can't do that while streaming
    // playback, there is no time.  So if we are just being asked for the next
    // portion of MIDI after the last one we just gave, we will do a special
    // seek I wrote that remembers the keyframe last time and adds just the
    // new bits for this next section.

    if (m_lLastSampleRead != lStart - 1) {
        DbgLog((LOG_TRACE,4,TEXT("Doing a REAL seek from the beginning for keyframe info")));
        if ((smfrc = smfSeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    hr = ResultFromScode(AVIERR_FILEREAD);
	    goto error;
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("Doing a small forward seek for keyframe info")));
        if ((smfrc = smfDannySeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    hr = ResultFromScode(AVIERR_FILEREAD);
	    goto error;
        }
    }

    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    DbgLog((LOG_TRACE,3,TEXT("Key frame is %ld bytes"), lpmh->dwBytesRecorded));

    // Now prepare to read the actual data for these samples.
    // !!! I'll bet this blows up when dwSize > 64K even if data read < 64K
    // because we're already offset in the pointer!
    lpmh = (LPMIDIHDR)((LPBYTE)lpmh + sizeof(MIDIHDR) + lpmh->dwBufferLength);
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - ((LPBYTE)lpmh - lp) - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;

    // We are NOT reading contiguously, so we'll have to do a seek to get to
    // the right spot.
    if (m_lLastSampleRead != lStart - 1) {
        DbgLog((LOG_TRACE,1,TEXT("Discontiguous Read:  Seeking from %ld to %ld")
					, m_lLastSampleRead, lStart));
	tk = smfMillisecsToTicks(m_hsmf, lStart * MSPERSAMPLE);
	if ((smfrc = smfSeek(m_hsmf, tk, lpmh)) != SMF_SUCCESS) {
	    hr = ResultFromScode(AVIERR_FILEREAD);
	    goto error;
	}
    }

    // We are reading contiguously, simply continue where we left off, with
    // a new high limit

    tk = smfMillisecsToTicks(m_hsmf, (lStart + lSamples) * MSPERSAMPLE);
    smfrc = smfReadEvents(m_hsmf, lpmh, 0, tk, FALSE);
    if (smfrc != SMF_SUCCESS && smfrc != SMF_END_OF_FILE)
	goto error;
    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    dwReadSize = lpmh->dwBufferLength + sizeof(MIDIHDR) + ((LPBYTE)lpmh - lp);
    DbgLog((LOG_TRACE,3,TEXT("Data is %ld bytes"), lpmh->dwBytesRecorded));

    //
    // a NULL buffer means return the size buffer needed to read
    // the given sample.
    // !!! Do we want to actually do the work and be accurate, or be quicker
    // and guess too high?
    //
    if (lpBuffer == NULL || cbBuffer == 0) {
	if (plBytes)
            *plBytes = dwReadSize;
	if (plSamples)
            *plSamples = lSamples;
	hr = AVIERR_OK;
	goto error;
    }

    //
    // They didn't give us enough space for the frame, so complain
    //
    if (cbBuffer < (LONG)dwReadSize) {
        if (plBytes)
            *plBytes = dwReadSize;
        hr = ResultFromScode(AVIERR_BUFFERTOOSMALL);
	goto error;
    }

    //
    // Copy the frame into the caller's buffer
    //
    hmemcpy(lpBuffer, lp, dwReadSize);

    // Looks like we're actually going to return success; update the last sample
    // we returned to them.
    m_lLastSampleRead = lStart + lSamples - 1;

    //
    // Return number of bytes and number of samples read
    //
    if (plBytes)
        *plBytes = dwReadSize;

    if (plSamples)
        *plSamples = lSamples;

    if (lp)
	GlobalFreePtr(lp);

    return ResultFromScode(AVIERR_OK);

error:
    if (lp)
	GlobalFreePtr(lp);

    return hr;
}

STDMETHODIMP CMIDIFile::SetFormat(LONG lPos, LPVOID lpFormat,
	LONG cbFormat)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::Write(LONG lStart, LONG lSamples,
	LPVOID lpData, LONG cbData, DWORD dwFlags, LONG FAR *plSampWritten,
	LONG FAR *plBytesWritten)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::SetInfo(AVISTREAMINFOW FAR * lpInfo, LONG cbInfo)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::Delete(LONG lStart, LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

// !!! Should these just map to Read/WriteData?
STDMETHODIMP CMIDIFile::ReadData(DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CMIDIFile::WriteData(DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

/****************************************************************************/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\mjpeglib.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
typedef struct {
    DWORD   dwFlags;    // flags from ICOPEN
    DWORD   dwFormat;
    struct jpeg_error_mgr error_mgr;
    struct jpeg_compress_struct   cinfo;
    struct jpeg_decompress_struct dinfo;
    BOOLEAN compress_active;
    BOOLEAN decompress_active;
    BOOLEAN draw_active;
    int xSubSample;
    int ySubSample;
    int smoothingFactor;
    BOOLEAN fancyUpsampling;
    BOOLEAN reportNonStandard;
    BOOLEAN fasterAlgorithm;
    BOOLEAN enabled;
	

    int destSize;  // some programs seem not to remember
	
    HWND	hwnd;
    RECT 	rcSource;
    RECT	rcDest;
    HBRUSH	hKeyBrush;

} INSTINFO, *PINSTINFO;

typedef struct tagJPEGEXBMINFOHEADER {
    BITMAPINFOHEADER bitMap;
    /* extended BITMAPINFOHEADER fields */
    DWORD   biExtDataOffset;
    JPEGINFOHEADER JbitMap;	
} JPEGBITMAPINFOHEADER;

extern "C" INSTINFO * __stdcall Open(ICINFO *icinfo);
extern "C" DWORD __stdcall Close(INSTINFO *pinst);
extern "C" DWORD __stdcall GetInfo(INSTINFO * pinst, ICINFO *icinfo, DWORD dwSize);
extern "C" DWORD __stdcall DecompressQuery(INSTINFO * pinst, JPEGBITMAPINFOHEADER * lpbiIn, LPBITMAPINFOHEADER lpbiOut);
extern "C" DWORD __stdcall DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
extern "C" DWORD __stdcall DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
extern "C" DWORD __stdcall Decompress(INSTINFO * pinst, ICDECOMPRESS  *icinfo, DWORD dwSize);
extern "C" DWORD __stdcall DecompressEnd(INSTINFO * pinst);
extern "C" DWORD __stdcall CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, JPEGBITMAPINFOHEADER * lpbiOut);
extern "C" DWORD __stdcall CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, JPEGBITMAPINFOHEADER * lpbiOut);
extern "C" DWORD __stdcall CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
extern "C" DWORD __stdcall CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
extern "C" DWORD __stdcall Compress(INSTINFO * pinst, ICCOMPRESS  *icinfo, DWORD dwSize);
extern "C" DWORD __stdcall CompressEnd(INSTINFO * pinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\jmorecfg.h ===
/*
 * jmorecfg.h
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains additional configuration options that customize the
 * JPEG software for special applications or support machine-dependent
 * optimizations.  Most users will not need to touch this file.
 */


/*
 * Define BITS_IN_JSAMPLE as either
 *   8   for 8-bit sample values (the usual setting)
 *   12  for 12-bit sample values
 * Only 8 and 12 are legal data precisions for lossy JPEG according to the
 * JPEG standard, and the IJG code does not support anything else!
 * We do not support run-time selection of data precision, sorry.
 */

#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */


/*
 * Maximum number of components (color channels) allowed in JPEG image.
 * To meet the letter of the JPEG spec, set this to 255.  However, darn
 * few applications need more than 4 channels (maybe 5 for CMYK + alpha
 * mask).  We recommend 10 as a reasonable compromise; use 4 if you are
 * really short on memory.  (Each allowed component costs a hundred or so
 * bytes of storage, whether actually used in an image or not.)
 */

#define MAX_COMPONENTS  10	/* maximum number of image components */


/*
 * Basic data types.
 * You may need to change these if you have a machine with unusual data
 * type sizes; for example, "char" not 8 bits, "short" not 16 bits,
 * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,
 * but it had better be at least 16.
 */

/* Representation of a single sample (pixel element value).
 * We frequently allocate large arrays of these, so it's important to keep
 * them small.  But if you have memory to burn and access to char or short
 * arrays is very slow on your hardware, you might want to change these.
 */

#if BITS_IN_JSAMPLE == 8
/* JSAMPLE should be the smallest type that will hold the values 0..255.
 * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JSAMPLE;
#ifdef CHAR_IS_UNSIGNED
#define GETJSAMPLE(value)  ((int) (value))
#else
#define GETJSAMPLE(value)  ((int) (value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */

#define MAXJSAMPLE	255
#define CENTERJSAMPLE	128

#endif /* BITS_IN_JSAMPLE == 8 */


#if BITS_IN_JSAMPLE == 12
/* JSAMPLE should be the smallest type that will hold the values 0..4095.
 * On nearly all machines "short" will do nicely.
 */

typedef short JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#define MAXJSAMPLE	4095
#define CENTERJSAMPLE	2048

#endif /* BITS_IN_JSAMPLE == 12 */


/* Representation of a DCT frequency coefficient.
 * This should be a signed value of at least 16 bits; "short" is usually OK.
 * Again, we allocate large arrays of these, but you can change to int
 * if you have memory to burn and "short" is really slow.
 */

typedef short JCOEF;


/* Compressed datastreams are represented as arrays of JOCTET.
 * These must be EXACTLY 8 bits wide, at least once they are written to
 * external storage.  Note that when using the stdio data source/destination
 * managers, this is also the data type passed to fread/fwrite.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JOCTET;
#define GETJOCTET(value)  (value)

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JOCTET;
#ifdef CHAR_IS_UNSIGNED
#define GETJOCTET(value)  (value)
#else
#define GETJOCTET(value)  ((value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */


/* These typedefs are used for various table entries and so forth.
 * They must be at least as wide as specified; but making them too big
 * won't cost a huge amount of memory, so we don't provide special
 * extraction code like we did for JSAMPLE.  (In other words, these
 * typedefs live at a different point on the speed/space tradeoff curve.)
 */

/* UINT8 must hold at least the values 0..255. */

#ifdef HAVE_UNSIGNED_CHAR
typedef unsigned char UINT8;
#else /* not HAVE_UNSIGNED_CHAR */
#ifdef CHAR_IS_UNSIGNED
typedef char UINT8;
#else /* not CHAR_IS_UNSIGNED */
typedef short UINT8;
#endif /* CHAR_IS_UNSIGNED */
#endif /* HAVE_UNSIGNED_CHAR */

/* UINT16 must hold at least the values 0..65535. */

#ifdef HAVE_UNSIGNED_SHORT
typedef unsigned short UINT16;
#else /* not HAVE_UNSIGNED_SHORT */
typedef unsigned int UINT16;
#endif /* HAVE_UNSIGNED_SHORT */

/* INT16 must hold at least the values -32768..32767. */

#ifndef XMD_H			/* X11/xmd.h correctly defines INT16 */
typedef short INT16;
#endif

/* INT32 must hold at least signed 32-bit values. */

/*x #ifndef XMD_H			//* X11/xmd.h correctly defines INT32 
typedef long INT32;
typedef unsigned long UINT32;
#endif
*X*/
/* Datatype used for image dimensions.  The JPEG standard only supports
 * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
 * "unsigned int" is sufficient on all machines.  However, if you need to
 * handle larger images and you don't mind deviating from the spec, you
 * can change this datatype.
 */

typedef unsigned int JDIMENSION;

#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */


/* These defines are used in all function definitions and extern declarations.
 * You could modify them if you need to change function linkage conventions.
 * Another application is to make all functions global for use with debuggers
 * or code profilers that require it.
 */

#define METHODDEF  static	/* a function called through method pointers */
#define LOCAL	   static	/* a function used only in its module */
#define GLOBAL			/* a function referenced thru EXTERNs */
#define EXTERN	  extern	/* a reference to a GLOBAL function */


/* Here is the pseudo-keyword for declaring pointers that must be "far"
 * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
 * by just saying "FAR *" where such a pointer is needed.  In a few places
 * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
 */

/*X* 
#ifdef NEED_FAR_POINTERS
#define FAR  far
#else
#define FAR
#endif
*X*/

/*
 * On a few systems, type boolean and/or its values FALSE, TRUE may appear
 * in standard header files.  Or you may have conflicts with application-
 * specific header files that you want to include together with these files.
 * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
 */
/*X*
#ifndef HAVE_BOOLEAN
typedef int boolean;
#endif
*X*/
#ifndef FALSE			/* in case these macros already exist */
#define FALSE	0		/* values of boolean */
#endif
#ifndef TRUE
#define TRUE	1
#endif


/*
 * The remaining options affect code selection within the JPEG library,
 * but they don't need to be visible to most applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.
 */

#ifdef JPEG_INTERNALS
#define JPEG_INTERNAL_OPTIONS
#endif

#ifdef JPEG_INTERNAL_OPTIONS


/*
 * These defines indicate whether to include various optional functions.
 * Undefining some of these symbols will produce a smaller but less capable
 * library.  Note that you can leave certain source files out of the
 * compilation/linking process if you've #undef'd the corresponding symbols.
 * (You may HAVE to do that if your compiler doesn't like null source files.)
 */

/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */

/* Capability options common to encoder and decoder: */

#define DCT_ISLOW_SUPPORTED	/* slow but accurate integer algorithm */
#define DCT_IFAST_SUPPORTED	/* faster, less accurate integer method */
#define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */

/* Encoder capability options: */

#undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#undef  C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files?  (NYI) */
#define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
/* Note: if you selected 12-bit data precision, it is dangerous to turn off
 * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
 * precision, so jchuff.c normally uses entropy optimization to compute
 * usable tables for higher precision.  If you don't want to do optimization,
 * you'll have to supply different default Huffman tables.
 */
#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */

/* Decoder capability options: */

#undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
#define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
#undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */

/* more capability options later, no doubt */


/*
 * Ordering of RGB data in scanlines passed to or from the application.
 * If your application wants to deal with data in the order B,G,R, just
 * change these macros.  You can also deal with formats such as R,G,B,X
 * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing
 * the offsets will also change the order in which colormap data is organized.
 * RESTRICTIONS:
 * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.
 * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not
 *    useful if you are using JPEG color spaces other than YCbCr or grayscale.
 * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE
 *    is not 3 (they don't understand about dummy color components!).  So you
 *    can't use color quantization if you change that value.
 */

#define RGB_RED		2	/* Offset of Red in an RGB scanline element */
#define RGB_GREEN	1	/* Offset of Green */
#define RGB_BLUE	0	/* Offset of Blue */
#define RGB_PIXELSIZE	3	/* JSAMPLEs per RGB scanline element */


/* Definitions for speed-related optimizations. */


/* If your compiler supports inline functions, define INLINE
 * as the inline keyword; otherwise define it as empty.
 */

#ifndef INLINE
#ifdef __GNUC__			/* for instance, GNU C knows about inline */
#define INLINE __inline__
#endif
#ifndef INLINE
#define INLINE			/* default is to define it as empty */
#endif
#endif


/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying
 * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
 * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.
 */

#ifndef MULTIPLIER
#define MULTIPLIER  int		/* type for fastest integer multiply */
#endif


/* FAST_FLOAT should be either float or double, whichever is done faster
 * by your compiler.  (Note that this type is only used in the floating point
 * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)
 * Typically, float is faster in ANSI C compilers, while double is faster in
 * pre-ANSI compilers (because they insist on converting to double anyway).
 * The code below therefore chooses float if we have ANSI-style prototypes.
 */

#ifndef FAST_FLOAT
#ifdef HAVE_PROTOTYPES
#define FAST_FLOAT  float
#else
#define FAST_FLOAT  double
#endif
#endif

#endif /* JPEG_INTERNAL_OPTIONS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\decode\safeseh.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL BeginScarySEH(PVOID pvShared);
extern void EndScarySEH(PVOID pvShared);

#define HEAP_SHARED 0x04000000

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\decode\safeseh.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
//#define STRICT
#include <windows.h>
#include <safeseh.h>

//HANDLE g_hhpShared;
#ifdef _X86_

/*
 *  The trampoline is a small stub that we put up in shared memory
 *  which merely jumps to the real exception handler.  Why do we
 *  do this?  Because on Windows 95, if you take an exception while
 *  the Win16 lock is held, Kernel32 will not dispatch to any
 *  private-arena exception handlers.  This rule is enforced because
 *  application exception handlers are not Win16-lock-aware; if we
 *  let them run, they won't release the Win16 lock and your system
 *  would hang.
 *
 *  And then DirectDraw showed up and broke all the rules by letting
 *  Win32 apps take the Win16 lock.
 *
 *  By putting our handler in the shared arena, we are basically saying,
 *  "We are Win16 lock-aware; please include me in the exception chain."
 *
 *  Code courtesy of RaymondC
 */
#pragma pack(1)
typedef struct TRAMPOLINE {
    BYTE bPush;
    DWORD dwTarget;
    BYTE bRet;
} TRAMPOLINE, LPTRAMPOLINE;
#pragma pack()

/*
 *  Warning!  This code must *NOT* be called if we are running on NT!
 */
BOOL BeginScarySEH(PVOID pvShared)
{
     BOOL bRet;

    _asm {
        mov     eax, pvShared;
	test    eax, eax;
	jz	failed;			/* Out of memory */

	xor	ecx, ecx;		/* Keep zero handy */
	mov	[eax].bPush, 0x68;	/* push immed32 */
	mov	ecx, fs:[ecx];		/* ecx -> SEH frame */
	mov	edx, [ecx][4];		/* edx = original handler */
	mov	[eax].dwTarget, edx;	/* Revector it */
	mov	[eax].bRet, 0xC3;	/* retd */
	mov	[ecx][4], eax;		/* Install the trampoline */
failed:;
        mov     bRet, eax
    }
    return bRet;
}

/*
 *  DO NOT CALL THIS IF BeginScarySEH FAILED!
 */
void EndScarySEH(PVOID pvShared)
{
    _asm {
	xor	edx, edx;		/* Keep zero handy */
	mov	ecx, fs:[edx];		/* ecx -> SEH frame */
	mov	eax, [ecx][4];		/* eax -> trampoline */
	mov	eax, [eax].dwTarget;	/* Extract original handler */
	mov	[ecx][4], eax;		/* Unvector it back */
    }
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\jpeglib.h ===
/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 *
 * Portions Copyright (c) 1994 Paradigm Matrix.
 *   All Rights Reserved.
 */

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
#include "jconfig.h"		/* widely used configuration options */
#endif
#include "jmorecfg.h"		/* seldom changed options */


/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
 */

#define JPEG_LIB_VERSION  50	/* Version 5.0 */


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
#define MAX_BLOCKS_IN_MCU   10	/* JPEG limit on # of blocks in an MCU */


/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
 */

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This field directly represents the contents of a JPEG DQT marker.
   * Note: the values are always given in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];		/* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;		/* identifier for this component (0..255) */
  int component_index;		/* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;		/* horizontal sampling factor (1..4) */
  int v_samp_factor;		/* vertical sampling factor (1..4) */
  int quant_tbl_no;		/* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  int dc_tbl_no;		/* DC entropy table selector (0..3) */
  int ac_tbl_no;		/* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
   */
  int DCT_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
   */
  JDIMENSION downsampled_width;	 /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;	/* do we need the value of this component? */

  /* These values are computed before starting a scan of the component: */
  int MCU_width;		/* number of blocks per MCU, horizontally */
  int MCU_height;		/* number of blocks per MCU, vertically */
  int MCU_blocks;		/* MCU_width * MCU_height */
  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
  int last_col_width;		/* # of non-dummy blocks across in last MCU */
  int last_row_height;		/* # of non-dummy blocks down in last MCU */

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,		/* error/unspecified */
	JCS_GRAYSCALE,		/* monochrome */
	JCS_RGB,		/* red/green/blue */
	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,		/* C/M/Y/K */
	JCS_YCCK		/* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,		/* slow but accurate integer algorithm */
	JDCT_IFAST,		/* faster, less accurate integer method */
	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,		/* no dithering */
	JDITHER_ORDERED,	/* simple ordered dither */
	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;	/* Error handler module */\
  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  boolean is_decompressor;	/* so common code can tell which is which */\
  int global_state		/* for checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;		/* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};


typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;	/* input image width */
  JDIMENSION image_height;	/* input image height */
  int input_components;		/* # of color components in input image */
  J_COLOR_SPACE in_color_space;	/* colorspace of input image */

  int pixel_size;			/* number of bytes per pixel, 2,3,4 */
  UINT32 pixel_mask;		/* for clearing empty byte of 32-bit pixels */
  UINT32 red_pixel_mask;
  int red_pixel_shift;
  UINT32 green_pixel_mask;
  int green_pixel_shift;
  UINT32 blue_pixel_mask;
  int blue_pixel_shift;

  double input_gamma;		/* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  int data_precision;		/* bits of precision in image data */

  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */
  
  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */
  
  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
  boolean interleave;		/* TRUE=interleaved output, FALSE=not */
  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;	/* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;		/* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;	/* should a JFIF marker be written? */
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
  boolean write_AVI1_marker;    /* write marker as defined by AVI MJPEG spec */
  UINT8 AVI1_field_id;				/* 0 for non-interlaced, 1 for odd frame, 2 for even frame */

  UINT8 * app0_marker_size_ptr;
  UINT8 * soi_ptr;					/* used to measure field and set app0 size values */

  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;	/* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
  JDIMENSION image_height;	/* nominal image height */
  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */
  
  int pixel_size;			/* number of bytes per pixel, 2,3,4 */
  UINT32 pixel_mask;			/* for clearing empty byte of 32-bit pixels */
  UINT32 red_pixel_mask;
  int red_pixel_shift;
  UINT32 green_pixel_mask;
  int green_pixel_shift;
  UINT32 blue_pixel_mask;
  int blue_pixel_shift;
  UINT32 * red_table; 		/* pixel mapping tables */
  UINT32 * green_table;
  UINT32 * blue_table;
  
  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;		/* image gamma wanted in output */

  boolean raw_data_out;		/* TRUE=downsampled data wanted */

  boolean quantize_colors;	/* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
  int desired_number_of_colors;	/* max number of colors to use */

  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;	/* scaled image width */
  JDIMENSION output_height;	/* scaled image height */
  int out_color_components;	/* # of color components in out_color_space */
  int output_components;	/* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;	/* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;	/* number of entries in use */
  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */

  /* State variable: index of next scaled scanline to be read from
   * jpeg_read_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (output_scanline < output_height)".
   */

  JDIMENSION output_scanline;	/* 0 .. output_height-1  */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;		/* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker: */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
  boolean saw_AVI1_marker;
  UINT8 AVI1_field_id;				/* 0 for non-interlaced, 1 for odd frame, 2 for even frame */

  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be output by coef ctlr */
  /* The coefficient controller outputs data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCT_scaled_size sample rows of each component
   * in an "iMCU" (interleaved MCU) row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */

  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;		/* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;		/* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;	/* code for first string in addon table */
  int last_addon_message;	/* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;		/* work units completed in this pass */
  long pass_limit;		/* total number of work units in this pass */
  int completed_passes;		/* passes completed so far */
  int total_passes;		/* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS	2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION unitheight));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION unitheight));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)	arglist
#else
#define JPP(arglist)	()
#endif


/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error		jStdError
#define jpeg_create_compress	jCreaCompress
#define jpeg_create_decompress	jCreaDecompress
#define jpeg_destroy_compress	jDestCompress
#define jpeg_destroy_decompress	jDestDecompress
#define jpeg_stdio_dest		jStdDest
#define jpeg_stdio_src		jStdSrc
#define jpeg_set_defaults	jSetDefaults
#define jpeg_set_colorspace	jSetColorspace
#define jpeg_default_colorspace	jDefColorspace
#define jpeg_set_quality	jSetQuality
#define jpeg_set_linear_quality	jSetLQuality
#define jpeg_add_quant_table	jAddQuantTable
#define jpeg_quality_scaling	jQualityScaling
#define jpeg_suppress_tables	jSuppressTables
#define jpeg_alloc_quant_table	jAlcQTable
#define jpeg_alloc_huff_table	jAlcHTable
#define jpeg_start_compress	jStrtCompress
#define jpeg_write_scanlines	jWrtScanlines
#define jpeg_finish_compress	jFinCompress
#define jpeg_write_raw_data	jWrtRawData
#define jpeg_write_marker	jWrtMarker
#define jpeg_write_tables	jWrtTables
#define jpeg_read_header	jReadHeader
#define jpeg_start_decompress	jStrtDecompress
#define jpeg_read_scanlines	jReadScanlines
#define jpeg_finish_decompress	jFinDecompress
#define jpeg_read_raw_data	jReadRawData
#define jpeg_calc_output_dimensions	jCalcDimensions
#define jpeg_set_marker_processor	jSetMarker
#define jpeg_abort_compress	jAbrtCompress
#define jpeg_abort_decompress	jAbrtDecompress
#define jpeg_abort		jAbort
#define jpeg_destroy		jDestroy
#define jpeg_resync_to_restart	jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN struct jpeg_error_mgr *jpeg_std_error JPP((struct jpeg_error_mgr *err));

/* Initialization and destruction of JPEG compression objects */
/* NB: you must set up the error-manager BEFORE calling jpeg_create_xxx */
EXTERN void jpeg_create_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_create_decompress JPP((j_decompress_ptr cinfo));
EXTERN void jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
// EXTERN void jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
// EXTERN void jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));

EXTERN void jpeg_compress_dest JPP((j_compress_ptr cinfo, JOCTET * destData, long * destSizePtr));
EXTERN void jpeg_decompress_src JPP((j_decompress_ptr cinfo, JOCTET * srcData, long srcSize));


/* Default parameter setup for compression */
EXTERN void jpeg_set_defaults JPP((j_compress_ptr cinfo));
/* Compression parameter setup aids */
EXTERN void jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				     J_COLOR_SPACE colorspace));
EXTERN void jpeg_default_colorspace JPP((j_compress_ptr cinfo));
EXTERN void jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				  boolean force_baseline));
EXTERN void jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					 int scale_factor,
					 boolean force_baseline));
EXTERN void jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				      const unsigned int *basic_table,
				      int scale_factor,
				      boolean force_baseline));
EXTERN int jpeg_quality_scaling JPP((int quality));
EXTERN void jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				      boolean suppress));
EXTERN JQUANT_TBL * jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN JHUFF_TBL * jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
EXTERN void	jpeg_set_subsampling (j_compress_ptr cinfo, int x, int y);

/* Main entry points for compression */
EXTERN void jpeg_start_compress JPP((j_compress_ptr cinfo,
				     boolean write_all_tables));
EXTERN JDIMENSION jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION num_lines));
EXTERN void jpeg_finish_compress JPP((j_compress_ptr cinfo));

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN JDIMENSION jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION num_lines));

/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN void jpeg_write_marker JPP((j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));

/* Alternate compression function: just write an abbreviated table file */
EXTERN void jpeg_write_tables JPP((j_compress_ptr cinfo));

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN int jpeg_read_header JPP((j_decompress_ptr cinfo,
				 boolean require_image));
/* Return value is one of: */
#define JPEG_HEADER_OK		0 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	1 /* Found valid table-specs-only datastream */
#define JPEG_SUSPENDED		2 /* Had to suspend before end of headers */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN void jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN JDIMENSION jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					   JSAMPARRAY scanlines,
					   JDIMENSION max_lines));
EXTERN boolean jpeg_finish_decompress JPP((j_decompress_ptr cinfo));

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN JDIMENSION jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					  JSAMPIMAGE data,
					  JDIMENSION max_lines));

/* Precalculate output dimensions for current decompression parameters. */
EXTERN void jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));

/* Install a special processing method for COM or APPn markers. */
EXTERN void jpeg_set_marker_processor JPP((j_decompress_ptr cinfo,
					   int marker_code,
					   jpeg_marker_parser_method routine));

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN void jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN void jpeg_abort_decompress JPP((j_decompress_ptr cinfo));

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN void jpeg_abort JPP((j_common_ptr cinfo));
EXTERN void jpeg_destroy JPP((j_common_ptr cinfo));

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN boolean jpeg_resync_to_restart JPP((j_decompress_ptr cinfo));


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_SOI    0xD8	/* SOI marker code */
#define JPEG_RST0	0xD0	/* RST0 marker code */
#define JPEG_EOI	0xD9	/* EOI marker code */
#define JPEG_APP0	0xE0	/* APP0 marker code */
#define JPEG_COM	0xFE	/* COM marker code */


/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"		/* fetch private declarations */
#include "jerror.h"		/* fetch error codes too */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\decode\mjpeg.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// Prototype wrapper for old video decompressors
//


#include <streams.h>
#include <windowsx.h>
#include <mmreg.h>
#include <vfw.h>

#ifdef FILTER_DLL
//#include <vfw.h>
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include "mjpeg.h"
#include "safeseh.h"

// you can never have too many parentheses!
#define ABS(x) (((x) > 0) ? (x) : -(x))

// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// setup data
const AMOVIESETUP_MEDIATYPE
subMjpegDecTypeIn = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_MJPG }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
subMjpegDecTypeOut = { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN
psubMjpegDecPins[] = { { L"Input"             // strName
                     , FALSE                // bRendered
                     , FALSE                // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Output"            // strConnectsToPin
                     , 1                    // nTypes
                     , &subMjpegDecTypeIn }     // lpTypes
                   , { L"Output"            // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &subMjpegDecTypeOut } };  // lpTypes

const AMOVIESETUP_FILTER
sudMjpegDec = { &CLSID_MjpegDec         // clsID
            , L"MJPEG Decompressor"   // strName
            , MERIT_NORMAL          // dwMerit
            , 2                     // nPins
            , psubMjpegDecPins };     // lpPin

#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    { L"MJPEG Decompressor"
    , &CLSID_MjpegDec
    , CMjpegDec::CreateInstance
    , NULL
    , &sudMjpegDec }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif


//------------------------------------------------------
// Local functions for exception handling
//------------------------------------------------------
static int
Exception_Filter(DWORD dwExceptionCode)
{
    if(dwExceptionCode == MJPEG_ERROREXIT_EXCEPTION)
    {
        DbgLog((LOG_TRACE,1,TEXT("Decode EXCEPTION:: PMJPEG32 threw a known ERROR EXIT exception")));
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else
    {
        DbgLog((LOG_TRACE,1,TEXT("Decode EXCEPTION:: PMJPEG32 threw an unknown exception")));
        return EXCEPTION_CONTINUE_SEARCH;
    }

}


// --- CMjpegDec ----------------------------------------

CMjpegDec::CMjpegDec(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
    : CVideoTransformFilter(pName, pUnk, CLSID_MjpegDec),
      m_phInstance(NULL),
      m_FourCCIn(0),
      m_fStreaming(FALSE),
      m_fPassFormatChange(FALSE)
#ifdef _X86_
      ,
      m_hhpShared(NULL)
#endif
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the MJPEG DEC filter")));

#ifdef PERF
    m_idSkip = MSR_REGISTER(TEXT("MJPEG Decoder Skip frame"));
    m_idLate = MSR_REGISTER(TEXT("MJPEG Decoder late"));
    m_idFrameType = MSR_REGISTER(TEXT("MJPEG Frame type (1=Key)"));
#endif

    m_bNoSkip = GetProfileInt(TEXT("Quartz"), TEXT("MJPEGNoSkip"), 0);

    // return good error code
    *phr = NOERROR;
}


CMjpegDec::~CMjpegDec()
{
    if (m_phInstance)
    {
        __try
        {
	Close(m_phInstance);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
        }
    }

    DbgLog((LOG_TRACE,1,TEXT("*Destroying the MJPEG DEC filter")));
}



// this goes in the factory template table to create new instances
CUnknown * CMjpegDec::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CMjpegDec(TEXT("MJPEG decompression filter"), pUnk, phr);
}



HRESULT CMjpegDec::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DWORD_PTR err = 0;
    FOURCCMap fccOut;
    CMediaType *pmtIn;

    DbgLog((LOG_TRACE,6,TEXT("*::Transform")));

    // codec not open ?
    if (m_phInstance==NULL) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, no codec open")));
	return E_UNEXPECTED;
    }

    if (pIn == NULL || pOut == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, NULL arguments")));
	return E_UNEXPECTED;
    }

    // we haven't started streaming yet?
    if (!m_fStreaming) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, not streaming")));
	return E_UNEXPECTED;
    }

    // make sure we have valid input and output pointers
    BYTE * pSrc;
    HRESULT hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting input sample data")));
	return hr;
    }

    BYTE * pDst;
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting output sample data")));
	return hr;
    }

    LPBITMAPINFOHEADER lpbiSrc = HEADER(m_pInput->CurrentMediaType().Format());
    LPBITMAPINFOHEADER lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());

    // ICDecompress needs this to be the actual size of this frame, but
    // we can't go changing this for good, so we'll put it back later
    DWORD biSizeImageOld = lpbiSrc->biSizeImage;
    lpbiSrc->biSizeImage = pIn->GetActualDataLength();

    // we just received a format change from the source. So we better notify
    // the guy downstream of the format change
    pIn->GetMediaType((AM_MEDIA_TYPE **)&pmtIn);
    // sometimes we don't end up passing anything to the renderer (eg preroll)
    // so once we notice a format change we will keep trying to pass it to
    // the renderer until we succeed.  Don't waste time trying if we KNOW we're
    // not going to do it.
    if (pmtIn != NULL && pmtIn->Format() != NULL)
	m_fPassFormatChange = TRUE;
    DeleteMediaType(pmtIn);

    if (m_fPassFormatChange && pIn->IsPreroll() != S_OK &&
        				pIn->GetActualDataLength() > 0) {
	CMediaType cmt;
	CopyMediaType((AM_MEDIA_TYPE *)&cmt, &m_pOutput->CurrentMediaType());
        LPBITMAPINFOHEADER lpbi = HEADER(cmt.Format());
	// we do not support 8 bits
    }


    BOOL dwFlags = 0;
    if (pIn->IsPreroll() == S_OK) {
	DbgLog((LOG_TRACE,6,TEXT("This is a preroll")));
	dwFlags |= ICDECOMPRESS_PREROLL;
    }

    if (pIn->GetActualDataLength() <= 0) {
	DbgLog((LOG_TRACE,6,TEXT("This is a NULL frame")));
	dwFlags |= ICDECOMPRESS_NULLFRAME;
    }

    if(pIn->IsSyncPoint() == S_OK) {
	DbgLog((LOG_TRACE,6,TEXT("This is a keyframe")));
    } else {
        dwFlags |= ICDECOMPRESS_NOTKEYFRAME;
    }

//      PLEASE don't ever send this flag to a codec! Some codecs take this as
//      a hint to speed up, unfortunately others are slightly less clever and
//      all they do when told to speed up is to send the same frame over and
//      over again! Which in turn means that bugs get raised against me for
//      random reasons such as when the window is being blown up full screen
//	!!! well, we should do this SOMETIMES, shouldn't we?
//
//        if (m_itrLate>0) {
//            dwFlags |= ICDECOMPRESS_HURRYUP;    // might help - who knows?
//        }

	RECT& rcS3 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcSource;
	RECT& rcT3 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcTarget;

#ifdef _X86_
        //  Fix the exception handling for win95
        BOOL bPatchedExceptions = m_hhpShared != NULL && BeginScarySEH(m_pvShared);
#endif // _X86_
__try {
            DbgLog((LOG_TRACE,5,TEXT("Calling ICDecompress")));
	    ICDECOMPRESS Icdec;
	    Icdec.dwFlags =dwFlags;
	    Icdec.lpbiInput = lpbiSrc;
	    Icdec.lpInput= pSrc;
	    Icdec.lpbiOutput=lpbiDst;
	    Icdec.lpOutput=pDst;

            err =  Decompress(m_phInstance, &Icdec, 0);

} __except(EXCEPTION_EXECUTE_HANDLER) {
	// codecs will GPF on corrupt data.  Best to not draw it instead
        DbgLog((LOG_ERROR,1,TEXT("Decompressor faulted! Recovering...")));
        //DbgBreak("Decompressor faulted! Recovering...");
	err = ICERR_DONTDRAW;
}

    // now put this back, or it'll shrink until we only decode part of each frm
    lpbiSrc->biSizeImage = biSizeImageOld;

#ifdef _X86_
    if (bPatchedExceptions)
    {
	EndScarySEH(m_pvShared);
    }
#endif // _X86_
    if ((LONG_PTR)err < 0)
    {
        DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompress(Ex)")));
        return E_FAIL;
    }


    // decompressed frames are always key
    pOut->SetSyncPoint(TRUE);

    // Check if this is preroll to get from keyframe to the current frame,
    // or a null frame, or if the decompressor doesn't want this frame drawn.
    // If so, we want to decompress it into the output buffer but not
    // deliver it.  Returning S_FALSE tells the base class not to deliver
    // this sample.
    if (pIn->IsPreroll() == S_OK || err == ICERR_DONTDRAW ||
       				pIn->GetActualDataLength() <= 0)
    {

        DbgLog((LOG_TRACE,5,TEXT("don't pass this to renderer")));
	return S_FALSE;
    }

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    // If there's a pending format change to pass to the renderer, we are now
    // doing it
    m_fPassFormatChange = FALSE;

    return S_OK;
}

// X*
// check if you can support mtIn
// X*
HRESULT CMjpegDec::CheckInputType(const CMediaType* pmtIn)
{
    FOURCCMap fccHandlerIn;
    PINSTINFO ph;
    BOOL fLoadDLL = FALSE;

    DbgLog((LOG_TRACE,3,TEXT("*::CheckInputType")));

    if (pmtIn == NULL || pmtIn->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we only support MEDIATYPE_Video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // X* check FOURCC
    fccHandlerIn.SetFOURCC(pmtIn->Subtype());
    if( ( fccHandlerIn != *pmtIn->Subtype() )
    || ( MEDIASUBTYPE_MJPG !=*pmtIn->Subtype() )
	)
    {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: subtype not a FOURCC or MJPEG")));
	return E_INVALIDARG;
    }
    DbgLog((LOG_TRACE,3,TEXT("Checking fccType: %lx biCompression: %lx"),
		fccHandlerIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression));

    // We are a decompressor only - reject anything uncompressed.
    // Conversions between RGB types is done by COLOUR.DLL
    if (HEADER(pmtIn->Format())->biCompression == BI_BITFIELDS ||
    	HEADER(pmtIn->Format())->biCompression == BI_RGB)
    {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: This is uncompressed already!")));
	return E_INVALIDARG;
    }

    // look for a decompressor
    if (fccHandlerIn.GetFOURCC() != m_FourCCIn)
    {
        DbgLog((LOG_TRACE,4,TEXT("loading a MJPEG decompressor")));

	ICINFO icinfo;

        __try
        {
        // Pmjpeg32 may throw exception
	GetInfo (NULL, &icinfo, sizeof(ICINFO));
	ph=Open (&icinfo);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	if (ph)
	  fLoadDLL = TRUE;
    } else
    {
        DbgLog((LOG_TRACE,4,TEXT("using a cached MJPEG decompressor")));
   	ph = m_phInstance;
    }

    if (ph==NULL)
    {
        DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a MJPEG decompressor")));
	return VFW_E_NO_DECOMPRESSOR;
    } else
    {

//*X*
        LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)pmtIn->Format());

        __try
        {
	if( ICERR_BADFORMAT==DecompressQuery (ph, (JPEGBITMAPINFOHEADER *)HEADER(pmtIn->Format()), NULL) )
	{

            DbgLog((LOG_ERROR,1,TEXT("Error: MJPEG Decompressor rejected format")));
	    if (fLoadDLL)
            {
                __try
                {
	        Close(ph);
                }
                __except(Exception_Filter(GetExceptionCode()))
                {
                    DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                    return E_FAIL;
                }
            }
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // clean up
            __try
            {
            if(fLoadDLL)
            {
                Close(ph);
            }
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                // just fall through
            }
            // handling code
            return E_FAIL;
        }


//*X*/
	// remember this hic to save time if asked again, if it won't
	// interfere with an existing connection.  If a connection is
	// broken, we will remember the next hic.
	if (!m_pInput->IsConnected())
        {
            DbgLog((LOG_TRACE,4,TEXT("caching this decompressor")));
	    if (fLoadDLL && m_phInstance)
            {
                __try
                {
		Close(ph);
                }
                __except(Exception_Filter(GetExceptionCode()))
                {
                    DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                    return E_FAIL;
                }
            }
	    m_phInstance = ph;
	    m_FourCCIn = fccHandlerIn.GetFOURCC();
	}
        else if (fLoadDLL)
        {
            DbgLog((LOG_TRACE,4,TEXT("not caching MJPEG decompressor - we're connected")));
            __try
            {
	    Close(ph);;
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                return E_FAIL;
            }
	}
    }

    return NOERROR;
}


// check if you can support the transform from this input to this output

HRESULT CMjpegDec::CheckTransform(const CMediaType* pmtIn,
                                const CMediaType* pmtOut)
{
    PINSTINFO ph = NULL;
    FOURCCMap fccIn;
    FOURCCMap fccOut;
    DWORD_PTR err;
    BOOL      fLoadDLL = FALSE;

    DbgLog((LOG_TRACE,3,TEXT("*::CheckTransform")));

    if (pmtIn == NULL || pmtOut == NULL || pmtIn->Format() == NULL ||
				pmtOut->Format() == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: types don't match")));
	return E_INVALIDARG;
    }

    // and we only accept video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: type not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtOut->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: output format type not VIDINFO")));
        return E_INVALIDARG;
    }
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: input format type not VIDINFO")));
        return E_INVALIDARG;
    }

    fccIn.SetFOURCC(pmtIn->Subtype());
    if ( (fccIn != *pmtIn->Subtype())
	 ||  (MEDIASUBTYPE_MJPG !=*pmtIn->Subtype() )
	)
    {
        DbgLog((LOG_TRACE,3,TEXT("Rejecting: input subtype not a FOURCC or MJPEG")));
	return E_INVALIDARG;
    }

    ASSERT(pmtOut->Format());

    RECT& rcS1 = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource;
    RECT& rcT1 = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget;

    LPBITMAPINFOHEADER lpbi = HEADER(pmtOut->Format());
    LPBITMAPINFOHEADER lpbii = HEADER(pmtIn->Format());

    //we only support 16,24, and 32
    if( (  (HEADER(pmtOut->Format())->biCompression == BI_RGB)
        &&(   (HEADER(pmtOut->Format())->biBitCount ==16)
	   ||(HEADER(pmtOut->Format())->biBitCount ==24)
	   ||(HEADER(pmtOut->Format())->biBitCount ==32 &&
              pmtOut->subtype == MEDIASUBTYPE_RGB32)
          )
	)   ||
        (  ( HEADER(pmtOut->Format())->biCompression == BI_BITFIELDS)
         &&(HEADER(pmtOut->Format())->biBitCount ==16)
	)
      )
    {
	;
    }
    else
    {
	DbgLog((LOG_TRACE,3,TEXT("Rejecting: Decoder can not support this output format")));
	return E_INVALIDARG;
    }


    DbgLog((LOG_TRACE,3,TEXT("Check fccIn: %lx biCompIn: %lx bitDepthIn: %d"),
		fccIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression,
		HEADER(pmtIn->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthIn: %ld biHeightIn: %ld biSizeIn: %ld"),
		HEADER(pmtIn->Format())->biWidth,
		HEADER(pmtIn->Format())->biHeight,
		HEADER(pmtIn->Format())->biSize));
    DbgLog((LOG_TRACE,3,TEXT("fccOut: %lx biCompOut: %lx bitDepthOut: %d"),
		fccOut.GetFOURCC(),
		HEADER(pmtOut->Format())->biCompression,
		HEADER(pmtOut->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthOut: %ld biHeightOut: %ld"),
		HEADER(pmtOut->Format())->biWidth,
		HEADER(pmtOut->Format())->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom));
    DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));

    // find a codec for this transform

    // I assume that we've already got a codec open
    ASSERT(m_phInstance);

    // the right codec better be open!
    // When reconnecting, we'll get called with a new input, but same output,
    // and better admit we can handle it
    if (m_FourCCIn != fccIn.GetFOURCC()) {
        DbgLog((LOG_TRACE,4,TEXT("Can not find a MJPEG decompressor")));
        ph =NULL;
	return E_FAIL;
    } else {
	// We already have the right codec open to try this transform
        DbgLog((LOG_TRACE,4,TEXT("Testing with the cached decompressor")));
	ph = m_phInstance;
    }

    if (!ph) {
        DbgLog((LOG_ERROR,1,TEXT("Error: Can't find a decompressor")));
	return E_FAIL;
    }

    __try
    {
    //check if the decompressor likes it.
    err = DecompressQuery(ph, (JPEGBITMAPINFOHEADER *)HEADER(pmtIn->Format()),
				HEADER(pmtOut->Format()));
    }
    __except(Exception_Filter(GetExceptionCode()))
    {
        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
        // handling code
        return E_FAIL;
    }

//XXXX
//*X8
if (err != ICERR_OK) {
        DbgLog((LOG_TRACE,3,TEXT("decompressor rejected this transform")));
        return E_FAIL;
    }
//    *X*/

    return NOERROR;
}


// overriden to know when the media type is actually set

HRESULT CMjpegDec::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    FOURCCMap fccHandler;

    if (direction == PINDIR_OUTPUT) {

	// Please call me if this goes off. -DannyMi
	ASSERT(!m_fStreaming);

	// OK, we've finally decided on what codec to use.  See if it
	// supports temporal compression, but can't do it without needing
	// the undisturbed previous bits.  If so, then we need to use
	// 1 read only buffer on our output pin (in DecideAllocator and
	// DecideBufferSize)
	ASSERT(m_phInstance);
	ICINFO icinfo;
 	//DWORD dw = ICGetInfo(m_hic, &icinfo, sizeof(icinfo));

        DWORD dw = 0;
        __try
        {
	dw = GetInfo(NULL, &icinfo, sizeof(icinfo));
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	m_fTemporal = TRUE;	// better safe than sorry?
	if (dw > 0) {
	    m_fTemporal = (icinfo.dwFlags & VIDCF_TEMPORAL) &&
				!(icinfo.dwFlags & VIDCF_FASTTEMPORALD);
	}
        DbgLog((LOG_TRACE,3,TEXT("Temporal compressor=%d"), m_fTemporal));
        DbgLog((LOG_TRACE,3,TEXT("***::SetMediaType (output)")));
        DbgLog((LOG_TRACE,3,TEXT("Output type is: biComp=%lx biBitCount=%d"),
		HEADER(m_pOutput->CurrentMediaType().Format())->biCompression,
		HEADER(m_pOutput->CurrentMediaType().Format())->biBitCount));
#if 0
        RECT& rcS1 = ((VIDEOINFOHEADER *)(pmt->Format()))->rcSource;
        RECT& rcT1 = ((VIDEOINFOHEADER *)(pmt->Format()))->rcTarget;
        DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom));
        DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));
#endif

	return NOERROR;
    }

    ASSERT(direction == PINDIR_INPUT);

    DbgLog((LOG_TRACE,3,TEXT("***::SetMediaType (input)")));
    DbgLog((LOG_TRACE,3,TEXT("Input type is: biComp=%lx biBitCount=%d"),
		HEADER(m_pInput->CurrentMediaType().Format())->biCompression,
		HEADER(m_pInput->CurrentMediaType().Format())->biBitCount));
#if 0
    RECT& rcS1 = ((VIDEOINFOHEADER *)(pmt->Format()))->rcSource;
    RECT& rcT1 = ((VIDEOINFOHEADER *)(pmt->Format()))->rcTarget;
    DbgLog((LOG_TRACE,2,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom));
    DbgLog((LOG_TRACE,2,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));
#endif

    // Please call me if this goes off. -DannyMi
    ASSERT(!m_fStreaming);

    // We better have one of these opened by now
    ASSERT(m_phInstance);

    // We better have the RIGHT one open
    FOURCCMap fccIn;
    fccIn.SetFOURCC(pmt->Subtype());

    ASSERT(m_FourCCIn == fccIn.GetFOURCC());

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
        DbgLog((LOG_TRACE,2,TEXT("Reconnecting the output pin...")));
	// This shouldn't fail, we're not changing the media type
	m_pGraph->Reconnect(m_pOutput);
    }

    return NOERROR;
}


// Return our preferred output media types (in order)

HRESULT CMjpegDec::GetMediaType(int iPosition,CMediaType *pmt)
{
    LARGE_INTEGER li;
    FOURCCMap fccHandler;
    VIDEOINFOHEADER *pf;

    DbgLog((LOG_TRACE,3,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,3,TEXT("Media type is NULL, no can do")));
	return E_INVALIDARG;
    }

    // Output choices depend on the input connected
    if (!m_pInput->CurrentMediaType().IsValid()) {
        DbgLog((LOG_TRACE,3,TEXT("No input type set yet, no can do")));
	return E_FAIL;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Caution: These are given out of order. be careful renumbering
    // the case statements !!!

    //
    //  the decoder only support
    //	biCompression=BI_RGB, biBitCount == 16, 24, 32
    // or biCompression == BI_BITFIELDS,biBitCount == 16
    //
    switch (iPosition) {
	
    // Offer the compressor's favourite
    // Offer 32 bpp RGB
    case 0:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 5: 32 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 32;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB32);

        break;
    }
    // Offer 24 bpp RGB
    case 1:
    {
        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 6: 24 bit RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 24;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);

        break;
    }
    // Offer 16 bpp RGB 565 before 555
    case 2:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 7: 565 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	if (pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) +
							SIZE_MASKS) == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory reallocating format")));
	    return E_OUTOFMEMORY;
	}

	// update the RGB 565 bit field masks

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_BITFIELDS;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

	DWORD *pdw = (DWORD *) (lpbi+1);
	pdw[iRED] = bits565[iRED];
	pdw[iGREEN] = bits565[iGREEN];
	pdw[iBLUE] = bits565[iBLUE];

        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);

        break;
    }

    // Offer 16 bpp RGB 555
    case 3:
    {

        DbgLog((LOG_TRACE,3,TEXT("Giving Media Type 8: 555 RGB")));

	*pmt = m_pInput->CurrentMediaType();	// gets width, height, etc.
	// only offer positive heights so downstream connections aren't confused
	HEADER(pmt->Format())->biHeight = ABS(HEADER(pmt->Format())->biHeight);

	// Can't error, can only be smaller
	pmt->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

	LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 16;
	lpbi->biClrUsed = 0;
	lpbi->biClrImportant = 0;
	lpbi->biSizeImage = DIBSIZE(*lpbi);

        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);

        break;
    }
    default:
	return VFW_S_NO_MORE_ITEMS;

    }

    // now set the common things about the media type
    pf = (VIDEOINFOHEADER *)pmt->Format();
    pf->AvgTimePerFrame = ((VIDEOINFOHEADER *)
		m_pInput->CurrentMediaType().pbFormat)->AvgTimePerFrame;
    li.QuadPart = pf->AvgTimePerFrame;
    if (li.LowPart)
        pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000, li.LowPart);
    pf->dwBitErrorRate = 0L;
    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetSampleSize(pf->bmiHeader.biSizeImage);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    return NOERROR;
}


// overridden to create a CMJPGDecOutputPin
// !!! base class changes won't get picked up by me
//
CBasePin * CMjpegDec::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (m_pInput == NULL)
    {

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"XForm In");      // Pin name


        //  Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pInput == NULL)
        {
            return NULL;
        }
        m_pOutput = (CTransformOutputPin *)
		   new CMJPGDecOutputPin(NAME("Transform output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"XForm Out");   // Pin name


        // Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL)
        {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    } else
    if (n == 1) {
        return m_pOutput;
    } else {
        return NULL;
    }
}


// overridden to properly mark buffers read only or not in NotifyAllocator
// !!! base class changes won't get picked up by me
//
HRESULT CMJPGDecOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0)
    {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr))
    {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr))
        {
	    // temporal compression ==> read only buffers
	    hr = pPin->NotifyAllocator(*ppAlloc,
					((CMjpegDec *)m_pFilter)->m_fTemporal);
	    if (SUCCEEDED(hr))
            {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc)
    {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr))
    {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr))
        {
	    // temporal compression ==> read only buffers
	    hr = pPin->NotifyAllocator(*ppAlloc,
					((CMjpegDec *)m_pFilter)->m_fTemporal);
	    if (SUCCEEDED(hr))
            {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc)
    {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


// called from CBaseOutputPin to prepare the allocator's count
// of buffers and sizes
HRESULT CMjpegDec::DecideBufferSize(IMemAllocator * pAllocator,
                                  ALLOCATOR_PROPERTIES *pProperties)
{
    // DMJPEGd assures me this won't be called with NULL output mt.
    ASSERT(m_pOutput->CurrentMediaType().IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);
    ASSERT(m_phInstance);

    // If we are doing temporal compression where we need the undisturbed
    // previous bits, we insist on 1 buffer (also our default)
    if (m_fTemporal || pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // set the size of buffers based on the expected output frame size
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();

    ASSERT(pProperties->cbBuffer);

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer)
    {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    // For temporal compressors, we MUST get exactly one buffer, since we assume
    // that the previous decompressed frame is already present in the output
    // buffer. The alternative is to copy the bits from a saved location before
    // doing the decompression, but that is not nice.
    if (m_fTemporal && Actual.cBuffers != 1) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - need exactly 1 buffer")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,1,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));

    return S_OK;
}


HRESULT CMjpegDec::StartStreaming()
{
    DWORD_PTR err;
    LPBITMAPINFOHEADER lpbiSrc = HEADER(m_pInput->CurrentMediaType().Format());
    LPBITMAPINFOHEADER lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());
    RECT& rcS2 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcSource;
    RECT& rcT2 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcTarget;

    DbgLog((LOG_TRACE,2,TEXT("*::StartStreaming")));

    if (!m_fStreaming) {

        __try
        {
	err = DecompressBegin(m_phInstance, lpbiSrc, lpbiDst);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	if (ICERR_OK == err) {
	    m_fStreaming = TRUE;
#ifdef _X86_
            // Create our exception handler heap
            ASSERT(m_hhpShared == NULL);
            if (g_osInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            {
               m_hhpShared = CreateFileMapping((HANDLE)0xFFFFFFFF,
                                               NULL,
                                               PAGE_READWRITE,
                                               0,
                                               20,
                                               NULL);
               if (m_hhpShared)
               {
                   m_pvShared = MapViewOfFile(m_hhpShared,
                                              FILE_MAP_WRITE,
                                              0,
                                              0,
                                              20);
                   if (m_pvShared == NULL)
                   {
                       EXECUTE_ASSERT(CloseHandle(m_hhpShared));
                       m_hhpShared = NULL;
                   }
                   else
                   {
                       DbgLog((LOG_TRACE, 1, TEXT("Shared memory at %8.8X"),
                              m_pvShared));
                   }
               }
            }
#endif // _X86_
	}
        else
        {
            DbgLog((LOG_ERROR,1,TEXT("Error %d in ICDecompress(Ex)Begin"),err));
	    return E_FAIL;
	}	
    }
    return CVideoTransformFilter::StartStreaming();
}

HRESULT CMjpegDec::StopStreaming()
{
    DbgLog((LOG_TRACE,2,TEXT("*::StopStreaming")));
    RECT& rcS2 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcSource;
    RECT& rcT2 = ((VIDEOINFOHEADER *)(m_pOutput->CurrentMediaType().Format()))->rcTarget;

    if (m_fStreaming)
    {
	ASSERT(m_phInstance);

        __try
        {
	DecompressEnd(m_phInstance);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	m_fStreaming = FALSE;

#ifdef _X86_
        if (m_hhpShared)
        {
            EXECUTE_ASSERT(UnmapViewOfFile(m_pvShared));
            EXECUTE_ASSERT(CloseHandle(m_hhpShared));;
            m_hhpShared = NULL;
        }
#endif // _X86_
    }
    return NOERROR;
}
#pragma warning(disable:4514)   // inline function removed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\decode\mjpeg.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _MJPEG_H_
#define _MJPEG_H_

#include "..\pmjpeg32\jpeglib.h"
#include "..\pmjpeg32\MJpegLib.h"

extern const AMOVIESETUP_FILTER sudMjpegDec;

//
// Prototype NDM wrapper for old video codecs
//


class CMjpegDec : public CVideoTransformFilter  
{
public:

    CMjpegDec(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMjpegDec();

    DECLARE_IUNKNOWN

    // override to create an output pin of our derived class
    CBasePin *GetPin(int n);

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(
                const CMediaType* mtIn,
                const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts
    // and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);

private:
    PINSTINFO m_phInstance;		// current codec

    BOOL m_fTemporal;	// codec needs one read-only buffer because it
			// needs the previous frame bits undisturbed

    // the fourCC used to open m_hic
    FOURCC m_FourCCIn;

    // have we called ICDecompressBegin ?
    BOOL m_fStreaming;

    // do we need to give a format change to the renderer?
    BOOL m_fPassFormatChange;
 

    friend class CMJPGDecOutputPin;

#ifdef _X86_
    //  HACK HACK for exception handling on win95
    HANDLE m_hhpShared;
    PVOID  m_pvShared;
#endif // _X86_
};

// override the output pin class to do our own decide allocator
class CMJPGDecOutputPin : public CTransformOutputPin
{
public:

    DECLARE_IUNKNOWN

    CMJPGDecOutputPin(TCHAR *pObjectName, CTransformFilter *pTransformFilter,
        				HRESULT * phr, LPCWSTR pName) :
        CTransformOutputPin(pObjectName, pTransformFilter, phr, pName) {};

    ~CMJPGDecOutputPin() {};

    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
};

#endif // #ifndef _MJPEG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\encode\mjpgenc.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// Quartz wrapper for old video compressors - CO
//

#include <streams.h>
#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include <windowsx.h>
#include <vfw.h>

#include "MJPGEnc.h"


const AMOVIESETUP_MEDIATYPE
sudMJPGEncTypeIn =  { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
sudMJPGEncTypeOut =  { &MEDIATYPE_Video      // clsMajorType
                , &MEDIASUBTYPE_MJPG }; // clsMinorType

const AMOVIESETUP_PIN
psudMJPGEncPins[] =  { { L"Input"             // strName
                     , FALSE                // bRendered
                     , FALSE                // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Output"            // strConnectsToPin
                     , 1                    // nTypes
                     , &sudMJPGEncTypeIn }      // lpTypes
                   , { L"Output"            // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudMJPGEncTypeOut } };   // lpTypes

const AMOVIESETUP_FILTER
sudMJPGEnc  = { &CLSID_MJPGEnc          // clsID
            , L"MJPEG Compressor"     // strName
            , MERIT_DO_NOT_USE      // dwMerit
            , 2                     // nPins
            , psudMJPGEncPins };      // lpPin



#ifdef FILTER_DLL
// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = {
    {L"MJPEG Compressor", &CLSID_MJPGEnc, CMJPGEnc::CreateInstance, NULL, 0},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

const WCHAR *g_wszUniq = L"MJPEG Video Encoder" ;

STDAPI DllRegisterServer()
{
 HRESULT hr = AMovieDllRegisterServer2( TRUE );
 if( FAILED(hr) )
     return hr;
 
 IFilterMapper2 *pFm2 = 0;

 hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pFm2       );
    
 if(FAILED(hr))
     return hr;

 REGFILTER2 rf2;
 rf2.dwVersion = 1;
 rf2.dwMerit = MERIT_DO_NOT_USE;
 rf2.cPins = 0;
 rf2.rgPins = 0;

 hr = pFm2->RegisterFilter(
      CLSID_MJPGEnc,
      g_wszUniq,
      0,
      &CLSID_VideoCompressorCategory,
      g_wszUniq,
      &rf2);

 pFm2->Release();
 
 return hr;

}

STDAPI DllUnregisterServer()
{

 HRESULT hr = AMovieDllRegisterServer2( FALSE );
 if( FAILED(hr) )
     return hr;

 
 IFilterMapper2 *pFm2 = 0;

 hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pFm2       );
    
 if(FAILED(hr))
     return hr;


 hr = pFm2->UnregisterFilter(
      &CLSID_VideoCompressorCategory,
      g_wszUniq,
      CLSID_MJPGEnc);

 pFm2->Release();
 
 return hr;
}

#endif


//------------------------------------------------------
// Local functions for exception handling
//------------------------------------------------------
static int
Exception_Filter(DWORD dwExceptionCode)
{
    if(dwExceptionCode == MJPEG_ERROREXIT_EXCEPTION)
    {
        DbgLog((LOG_TRACE,1,TEXT("Decode EXCEPTION:: PMJPEG32 threw a known ERROR EXIT exception")));
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else
    {
        DbgLog((LOG_TRACE,1,TEXT("Decode EXCEPTION:: PMJPEG32 threw an unknown exception")));
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


// --- CMJPGEnc ----------------------------------------

CMJPGEnc::CMJPGEnc(TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr)
    : CTransformFilter(pName, pUnk, CLSID_MJPGEnc),
      CPersistStream(pUnk, phr),
      m_phInstance(NULL),
      m_lpBitsPrev(NULL),
      m_lpbiPrev(NULL),
      m_fStreaming(FALSE),
      m_fDialogUp(FALSE),
      m_fCacheIns(FALSE),
      m_fOfferSetFormatOnly(FALSE),
      m_fInICCompress(FALSE),
      m_lpState(NULL),
      m_cbState(0)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the MJPEG Encoder filter")));
    _fmemset(&m_compvars, 0, sizeof(m_compvars));

    m_compvars.cbSize	    = sizeof(m_compvars);
    m_compvars.dwFlags	    = ICMF_COMPVARS_VALID;
    m_compvars.lQ	    = ICQUALITY_DEFAULT;
    m_compvars.lKey	    = -1;   
    m_compvars.fccHandler   = MKFOURCC('M','J','P','G');
}

CMJPGEnc::~CMJPGEnc()
{
    if (m_phInstance) {
        __try
        {
	if (m_fStreaming) 
	    CompressEnd(m_phInstance);

	Close(m_phInstance);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
        }
    }

    // TODO ?
    if (m_lpState)
	QzTaskMemFree(m_lpState);
    m_lpState = NULL;

    DbgLog((LOG_TRACE,1,TEXT("*Destroying the MJPEG Encode filter")));
}

STDMETHODIMP CMJPGEnc::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    DbgLog((LOG_TRACE,9,TEXT("somebody's querying my interface")));
    if(riid == IID_IPersistStream) {
        DbgLog((LOG_TRACE,3,TEXT("VfwCap::QI for IPersistStream")));
        return GetInterface((IPersistStream *) this, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


// this goes in the factory template table to create new instances
CUnknown * CMJPGEnc::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CMJPGEnc(TEXT("MJPEG compression filter"), pUnk, phr);
}


CBasePin * CMJPGEnc::GetPin(int n)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,9,TEXT("CMJPGEnc::GetPin")));

    // Create an input pin if necessary

    if (n == 0 && m_pInput == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"Input");         // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pInput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Or alternatively create an output pin

    if (n == 1 && m_pOutput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new CMJPGOutputPin(NAME("MJPEG Encode Output Pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"Output");      // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pOutput == NULL) {
            delete m_pOutput;
            m_pOutput = NULL;
        }

    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    }
    return m_pOutput;
}

STDMETHODIMP CMJPGEnc::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped)
    {
        return VFW_E_WRONG_STATE;
    }
    // If they don't give us a key, default to something (CINEPAK)
    if (pPropBag == NULL) {
	m_compvars.fccHandler = MKFOURCC('C','V','I','D');
	return NOERROR;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"FccHandler", &var,0);
    if(SUCCEEDED(hr))
    {
        char szFccHandler[5];
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1,
                            szFccHandler, sizeof(szFccHandler), 0, 0);
        SysFreeString(var.bstrVal);
        DbgLog((LOG_TRACE,2,TEXT("MJPEG::Load: use %c%c%c%c"),
                szFccHandler[0], szFccHandler[1], szFccHandler[2], szFccHandler[3]));
        m_compvars.fccHandler = *(DWORD UNALIGNED *)szFccHandler;;
        if (m_pOutput && m_pOutput->IsConnected()) {
            DbgLog((LOG_TRACE,2,TEXT("MJPEG::Load: reconnect output")));
            return ((CMJPGOutputPin *)m_pOutput)->Reconnect();
        }
        hr = S_OK;
        

    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    

    return hr;
}

STDMETHODIMP CMJPGEnc::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CMJPGEnc::InitNew()
{
    // fine. just call load
    return S_OK;
}

STDMETHODIMP CMJPGEnc::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;  
}

struct CoPersist
{
    DWORD dwSize;
    DWORD fccHandler;
};

HRESULT CMJPGEnc::WriteToStream(IStream *pStream)
{
    CoPersist cp;
    cp.dwSize = sizeof(cp);
    cp.fccHandler = m_compvars.fccHandler;
    
    return pStream->Write(&cp, sizeof(cp), 0);
}

HRESULT CMJPGEnc::ReadFromStream(IStream *pStream)
{
   if(m_compvars.fccHandler != 0)
   {
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   CoPersist cp;
   HRESULT hr = pStream->Read(&cp, sizeof(cp), 0);
   if(FAILED(hr))
       return hr;

   if(cp.dwSize != sizeof(cp))
       return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

   m_compvars.fccHandler = cp.fccHandler;

   return S_OK;
}

int CMJPGEnc::SizeMax()
{
    return sizeof(CoPersist);
}

HRESULT CMJPGEnc::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    BOOL  fKey;
    DWORD err;
    FOURCCMap fccOut;
    BOOL fFault = FALSE;

    DbgLog((LOG_TRACE,5,TEXT("*::Transform")));

    // codec not open ?
    if (m_phInstance == 0) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, no codec open")));
	return E_UNEXPECTED;
    }

    // we haven't started streaming yet?
    if (!m_fStreaming) {
        DbgLog((LOG_ERROR,1,TEXT("Can't transform, not streaming")));
	return E_UNEXPECTED;
    }

    // make sure we have valid input and output pointers

    BYTE * pSrc;
    HRESULT hr = pIn->GetPointer(&pSrc);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting input sample data")));
	return hr;
    }

    BYTE * pDst;
    hr = pOut->GetPointer(&pDst);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error getting output sample data")));
	return hr;
    }

    // !!! Could the source filter change our mtIn too? Yes!

    // get the BITMAPINFOHEADER structure, and fix biSizeImage

    LPBITMAPINFOHEADER lpbiSrc = HEADER(m_pInput->CurrentMediaType().Format());
    LPBITMAPINFOHEADER lpbiDst = HEADER(m_pOutput->CurrentMediaType().Format());

    // ICCompress will alter this value!  Which is illegal, other filters use
    // this as the connection type
    DWORD biSizeImageOld = lpbiDst->biSizeImage;

    lpbiSrc->biSizeImage = pIn->GetActualDataLength();

    BOOL dwFlags = 0;

    fKey = (m_nKeyCount >= m_compvars.lKey);
    if (fKey) {
        DbgLog((LOG_TRACE,6,TEXT("I will ask for a keyframe")));
	dwFlags |= ICCOMPRESS_KEYFRAME;
    }

    // pretty please, compiler, don't optimize this away
    int cbSize = DIBSIZE(*lpbiSrc);
    __try { 
	// cinepak will access one byte too many... occasionally this faults
	if (lpbiSrc->biBitCount == 24)
	    volatile int cb = *(pSrc + cbSize);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
	// OK, I guess I have to copy it into a bigger buffer to avoid this
        DbgLog((LOG_ERROR,0,TEXT("Compressor faulted!  Recovering...")));
	fFault = TRUE;
	BYTE *pOld = pSrc;
	pSrc = (BYTE *)QzTaskMemAlloc(cbSize + 1);
	if (pSrc == NULL)
	    return E_OUTOFMEMORY;
	CopyMemory(pSrc, pOld, cbSize);
    }

    DbgLog((LOG_TRACE,6,TEXT("Calling Compress on frame %ld"),
					m_lFrameCount));
    // StopStreaming may get called while we're inside here, blowing us up
    m_fInICCompress = TRUE;

    ICCOMPRESS IcEnc;
    IcEnc.dwFlags   =dwFlags;
    IcEnc.lpbiOutput=lpbiDst;
    IcEnc.lpOutput  =pDst;
    IcEnc.lpbiInput = lpbiSrc;
    IcEnc.lpInput   = pSrc;
    
    DWORD ckid = 0L;
    IcEnc.lpckid    = &ckid;  //  address to contain the chunk identifier for data in the AVI file

    DWORD dwFlagsOut = 0L;
    IcEnc.lpdwFlags = &dwFlagsOut;  //Flags for the AVI index

    IcEnc.lFrameNum = m_lFrameCount;//number of the frames to compress
    IcEnc.dwFrameSize= m_dwSizePerFrame;//Desired Manimun size in bytes
    IcEnc.dwQuality = m_compvars.lQ;//quality set

    IcEnc.lpbiPrev  =fKey ? NULL : m_lpbiPrev;
    IcEnc.lpPrev    =fKey ? NULL : m_lpBitsPrev;
    __try
    {
    err =Compress(m_phInstance, &IcEnc, 0); //the last var is not used.
    }
    __except(Exception_Filter(GetExceptionCode()))
    {
        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
        // we may not be able to survive a compression fault
        m_fInICCompress = FALSE;
        lpbiDst->biSizeImage = biSizeImageOld;
        return E_FAIL;
    }
    
    if (fFault)
	QzTaskMemFree(pSrc);

    if (ICERR_OK != err) {
        DbgLog((LOG_ERROR,1,TEXT("Error in ICCompress")));
        m_fInICCompress = FALSE;
        lpbiDst->biSizeImage = biSizeImageOld;
        return E_FAIL;
    }

    // was the compressed frame a keyframe?
    fKey = dwFlagsOut & AVIIF_KEYFRAME;
    pOut->SetSyncPoint(fKey);

    // If we made a key, reset when we need the next one.
    if (fKey)
	m_nKeyCount = 0;

    // Do we want periodic key frames? If not, never make one again.
    // (The first frame is always a keyframe).
    if (m_compvars.lKey)
	m_nKeyCount++;
    else
	m_nKeyCount = -1;

    // Count how many frames we compress
    m_lFrameCount++;

    // Decompress into previous frame
    if (m_lpBitsPrev) {

	ICDECOMPRESS Icdec;
	Icdec.dwFlags =dwFlags;
	Icdec.lpbiInput = lpbiSrc;
	Icdec.lpInput= pSrc;
	Icdec.lpbiOutput=lpbiDst;
	Icdec.lpOutput=pDst;

        __try
        {
        if (ICERR_OK != Decompress(m_phInstance, &Icdec, 0))
	{
    	    m_fInICCompress = FALSE;
            lpbiDst->biSizeImage = biSizeImageOld;
	    return E_FAIL;
	}
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            m_fInICCompress = FALSE;
            lpbiDst->biSizeImage = biSizeImageOld;
            return E_FAIL;
        }        
    }
    m_fInICCompress = FALSE;

    // now put this back, or it'll shrink until we only decode part of each frm
    lpbiDst->biSizeImage = biSizeImageOld;

    pOut->SetActualDataLength(lpbiDst->biSizeImage);

    return S_OK;
}


// check if you can support mtIn
HRESULT CMJPGEnc::CheckInputType(const CMediaType* pmtIn)
{
    FOURCCMap fccHandlerIn;
    PINSTINFO ph;

    DbgLog((LOG_TRACE,2,TEXT("*::CheckInputType")));

    if (pmtIn == NULL || pmtIn->Format() == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // we only support MEDIATYPE_Video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    fccHandlerIn.SetFOURCC(pmtIn->Subtype());

    DbgLog((LOG_TRACE,3,TEXT("Checking fccType: %lx biCompression: %lx"),
		fccHandlerIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression));

    //
    //  Most VFW codecs don't like upsize-down (DIRECTDRAW) style bitmaps.  If the
    //  height is negative then reject it.
    //
    if (HEADER(pmtIn->Format())->biHeight < 0) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: Negative height")));
        return E_INVALIDARG;
    }

    // look for a compressor for this format

    if (HEADER(pmtIn->Format())->biCompression != BI_BITFIELDS &&
    		HEADER(pmtIn->Format())->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: This is compressed already!")));
	return E_INVALIDARG;
    }

    // !!! I'm only going to say I accept an input type if the default (current)
    // compressor can handle it.  I'm not going to ask every compressor.  This
    // way an app can make a choose compressor box and only show those
    // compressors that support a given input format, by making a CO filter
    // with each compressor as a default and asking them all

    // We might have a instance cached if we connected before and then broken
    if (!m_phInstance) {
        DbgLog((LOG_TRACE,4,TEXT("opening a compressor")));

	ICINFO icinfo;
        __try
        {
	GetInfo (NULL, &icinfo, sizeof(ICINFO));  //first var is not used by the function
	ph=Open (&icinfo);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

        if (!ph) {
            DbgLog((LOG_ERROR,1,TEXT("Error: Can't open a compressor")));
	    return E_FAIL;
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("using a cached compressor")));
	ph = m_phInstance;
    }

    __try
    {
    if (ICERR_BADFORMAT==CompressQuery(ph, HEADER(pmtIn->Format()), NULL)) {
        DbgLog((LOG_ERROR,1,TEXT("Error: Compressor rejected format")));
	if (ph != m_phInstance)
        {
            __try
            {
	    Close(ph);
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                // handling code
                // fall through to failure
            }
        }
	return E_FAIL;
    }
    }
    __except(Exception_Filter(GetExceptionCode()))
    {
        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
        // handling code
        __try
        {
            if(ph != m_phInstance)
            {
                Close(ph);
            }
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            // fall through to failure
        }
        return E_FAIL;
    }

    // remember this instahce to save time if asked again.
    if (m_phInstance == NULL) {
        DbgLog((LOG_TRACE,4,TEXT("caching this compressor")));
	m_phInstance = ph;
    }

    return NOERROR;
}


// check if you can support the transform from this input to this output

HRESULT CMJPGEnc::CheckTransform(const CMediaType* pmtIn,
                               const CMediaType* pmtOut)
{
    FOURCCMap fccIn;

    DbgLog((LOG_TRACE,2,TEXT("*::CheckTransform")));

    if (pmtIn == NULL || pmtOut == NULL || pmtIn->Format() == NULL ||
					pmtOut->Format() == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type/format is NULL")));
	return E_POINTER;
    }

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: types don't match")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // and we only accept video
    if (*pmtIn->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: type not VIDEO")));
	return VFW_E_INVALIDMEDIATYPE;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmtOut->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: output format type not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if (*pmtIn->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: input format type not VIDINFO")));
        return VFW_E_INVALIDMEDIATYPE;
    }

#ifdef PICKY_PICKY // !!!
    if (((VIDEOINFOHEADER *)(pmtOut->Format()))->AvgTimePerFrame &&
    		((VIDEOINFOHEADER *)(pmtOut->Format()))->AvgTimePerFrame !=
    		((VIDEOINFOHEADER *)(pmtIn->Format()))->AvgTimePerFrame) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't frame rate convert")));
        return VFW_E_INVALIDMEDIATYPE;
    }
#endif

    // check it really is a FOURCC
    fccIn.SetFOURCC(pmtIn->Subtype());

    ASSERT(pmtOut->Format());

#define rcS1 ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget

    DbgLog((LOG_TRACE,3,TEXT("Check fccIn: %lx biCompIn: %lx bitDepthIn: %d"),
		fccIn.GetFOURCC(),
		HEADER(pmtIn->Format())->biCompression,
		HEADER(pmtIn->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthIn: %ld biHeightIn: %ld"),
		HEADER(pmtIn->Format())->biWidth,
		HEADER(pmtIn->Format())->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("biCompOut: %lx bitDepthOut: %d"),
		HEADER(pmtOut->Format())->biCompression,
		HEADER(pmtOut->Format())->biBitCount));
    DbgLog((LOG_TRACE,3,TEXT("biWidthOut: %ld biHeightOut: %ld"),
		HEADER(pmtOut->Format())->biWidth,
		HEADER(pmtOut->Format())->biHeight));
    DbgLog((LOG_TRACE,3,TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
		rcS1.left, rcS1.top, rcS1.right, rcS1.bottom));
    DbgLog((LOG_TRACE,3,TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
		rcT1.left, rcT1.top, rcT1.right, rcT1.bottom));

    if (!IsRectEmpty(&rcT1) && (rcT1.left != 0 || rcT1.top != 0 ||
			HEADER(pmtOut->Format())->biWidth != rcT1.right ||
			HEADER(pmtOut->Format())->biHeight != rcT1.bottom)) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't use funky rcTarget")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    if (!IsRectEmpty(&rcS1) && (rcS1.left != 0 || rcS1.top != 0 ||
			HEADER(pmtIn->Format())->biWidth != rcS1.right ||
			HEADER(pmtIn->Format())->biHeight != rcS1.bottom)) {
        DbgLog((LOG_TRACE,2,TEXT("Rejecting: can't use funky rcSource")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // find a codec for this transform

    DbgLog((LOG_TRACE,3,TEXT("Trying to find a compressor for this")));
    // If we've opened a compressor before, quickly try that one to see if it
    // will do the job (saves lots of time) before trying the whole universe of
    // compressors.
    DWORD dwQueryResult = 0;
    __try
    {
    dwQueryResult = CompressQuery(m_phInstance, HEADER(pmtIn->Format()),
				(JPEGBITMAPINFOHEADER *)HEADER(pmtOut->Format()));
    }
    __except(Exception_Filter(GetExceptionCode()))
    {
        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
        // handling code
        return E_FAIL;
    }

    // check result
    if ((!m_phInstance) || (dwQueryResult != ICERR_OK))
    {
        DbgLog((LOG_TRACE,3,TEXT("compressor rejected this transform")));
        return E_FAIL;
    } else 
    {
    	DbgLog((LOG_TRACE,3,TEXT("The cached compressor accepts it")));
    }

    return NOERROR;
}


// overriden to know when the media type is actually set

HRESULT CMJPGEnc::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{

    // Set the OUTPUT type.  Looks like we're all connected!
    if (direction == PINDIR_OUTPUT) {

	// Please call me if this goes off. - DannyMi
	ASSERT(!m_fStreaming);

        DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (output)")));
        DbgLog((LOG_TRACE,2,TEXT("Output type is: biComp=%lx biBitCount=%d")
		,HEADER(pmt->Format())->biCompression
		,HEADER(pmt->Format())->biBitCount));

	// we may not be using the compressor from m_compvars, if somebody
	// did a ConnectWithMediaType on us.  We need to get info about this
	// media type and m_phInstance and fill in m_compvars so that from now on
	// we use the right info.
        ASSERT(m_phInstance);
        m_compvars.cbSize = sizeof(m_compvars);
        m_compvars.dwFlags = ICMF_COMPVARS_VALID;

        ICINFO icinfo;
        DWORD dwGetInfoResult = 0;
        __try
        {
        dwGetInfoResult = GetInfo(m_phInstance, &icinfo, sizeof(ICINFO));
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            // return failure
            return E_FAIL;
        }

        // check result
	if (dwGetInfoResult  > 0)
	{
	    if (m_compvars.fccHandler != icinfo.fccHandler) {
		// different compressor? don't use old state!
		m_compvars.lpState = NULL;
		m_compvars.cbState = 0;
	    }
            m_compvars.fccHandler = icinfo.fccHandler;
            DbgLog((LOG_TRACE,2,TEXT("New fccHandler = %08x"),
					icinfo.fccHandler));
	} else {
	    m_compvars.lpState = NULL;
	    m_compvars.cbState = 0;
	}
        m_compvars.lDataRate = ((VIDEOINFOHEADER *)pmt->Format())->dwBitRate /
								8192;
	// We will leave Quality and Keyframe settings as is

	// !!! If we connect 8 bit on our input and then try to connect 
	// our output with a type that needs 24 bit on our input we don't
	// reconnect the input! We will FAIL!  We need to do like ACMWRAP
	// and override the output pin's CheckMediaType to accept something
	// if the input can be reconnected to allow it, and we need to do
	// that reconnect here.

        LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)pmt->Format());

	return NOERROR;
    }

    ASSERT(direction == PINDIR_INPUT);

    // Please call me if this goes off. - DannyMi
    ASSERT(!m_fStreaming);

    DbgLog((LOG_TRACE,2,TEXT("***::SetMediaType (input)")));
    DbgLog((LOG_TRACE,2,TEXT("Input type is: biComp=%lx biBitCount=%d"),
		HEADER(m_pInput->CurrentMediaType().Format())->biCompression,
		HEADER(m_pInput->CurrentMediaType().Format())->biBitCount));

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
	// This might fail!
	// !!! only necessary if we accepted something we can't transform
	// return ((CMJPGOutputPin *)m_pOutput)->Reconnect();
    }

    return NOERROR;
}


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.

HRESULT CMJPGEnc::GetMediaType(int iPosition,CMediaType *pmt)
{
    LARGE_INTEGER li;
    CMediaType cmt, Outcmt;
    FOURCCMap fccHandler;

    DbgLog((LOG_TRACE,2,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Media Type is NULL, no can do")));
	return E_POINTER;
    }

    // Output choices depend on the input connected
    // This is pointless!  We'll never get here if not connected
    if (!m_pInput->CurrentMediaType().IsValid()) {
        DbgLog((LOG_TRACE,2,TEXT("No input type set yet, no can do")));
	return VFW_E_NOT_CONNECTED;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Give our compressed format
    if (iPosition == 0) {

	cmt = m_pInput->CurrentMediaType();

	// somebody told us what format to use.  We should only offer that one
 	if (m_fOfferSetFormatOnly) 
	{
            DbgLog((LOG_TRACE,2,TEXT("Giving Media Type from ::SetFormat")));

	    //Output formate
            *pmt = m_cmt;

	    ASSERT(m_phInstance);
            __try
            {
	    if( ICERR_OK ==CompressQuery(m_phInstance, HEADER(cmt.Format()),
				(JPEGBITMAPINFOHEADER *)HEADER(pmt->Format())) ) 
		return NOERROR;
	    else
		return E_FAIL;
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                // handling code
                return E_FAIL;
            }
	}

	// We offer one compressed type - the same as the input type, but
 	// with the compressor chosen in the properties's default output format
        DbgLog((LOG_TRACE,2,TEXT("Giving Media Type 0: default codec out")));
	ASSERT(m_phInstance);

	cmt = m_pInput->CurrentMediaType();
	JPEGBITMAPINFOHEADER jpegbiOut;
	DWORD_PTR err = 0;
        __try
        {
	err=CompressGetFormat(m_phInstance, HEADER(cmt.Format()), &jpegbiOut);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	if (err != ICERR_OK) {
	    DbgLog((LOG_TRACE,3,TEXT("compressor rejected this transform")));
	    return E_FAIL;
	}

	ULONG cb = sizeof(VIDEOINFOHEADER);
	    
	// !!! this is the wrong amount of extra biSize we use, but I'm scared
        // to fix it, it could break something
        // should be cb += jpegbiOut.bitMap.biSize - sizeof(BITMAPINFOHEADER)
	cb += SIZE_PREHEADER;

	VIDEOINFOHEADER *pf = (VIDEOINFOHEADER *) Outcmt.AllocFormatBuffer(cb);

	if (pf == NULL) {
	    DbgLog((LOG_ERROR,1,TEXT("Error allocating format buffer")));
	    Close(m_phInstance);
        return E_OUTOFMEMORY;
	}

	ZeroMemory(pf, sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER);
	CopyMemory(&(pf->bmiHeader),&jpegbiOut.bitMap, sizeof(BITMAPINFOHEADER));
        // this is wrong!!! biSize is 0x44 for our format, but the code breaks
        // if we tell the truth (can't connect to our own decoder)
	HEADER(pf)->biSize  = sizeof(BITMAPINFOHEADER);
	 
	// use the frame rate of the incoming video
	pf->AvgTimePerFrame = ((VIDEOINFOHEADER *)
	m_pInput->CurrentMediaType().pbFormat)->AvgTimePerFrame;

	li.QuadPart = pf->AvgTimePerFrame;
	// use the data rate we've been told to make.  If we aren't going to
	// make the compressor use a specific rate, find out what it's going
	// to do anyway.
	if (m_compvars.lDataRate)
	    pf->dwBitRate = m_compvars.lDataRate * 8192;
	else if (li.LowPart)
	    pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000,
								li.LowPart);
	pf->dwBitErrorRate = 0L;

	DbgLog((LOG_TRACE,3,TEXT("Returning biComp: %lx biBitCount: %d"),
		    HEADER(cmt.Format())->biCompression,
		    HEADER(cmt.Format())->biBitCount));

	Outcmt.SetType(&MEDIATYPE_Video);
	Outcmt.SetSubtype(&MEDIASUBTYPE_MJPG);
	Outcmt.SetTemporalCompression(m_compvars.lKey != 1);
	Outcmt.SetFormatType(&FORMAT_VideoInfo);
	Outcmt.SetTemporalCompression(TRUE);
	Outcmt.SetVariableSize();

	*pmt = Outcmt;

        //debug
        LPBITMAPINFOHEADER lpbi = HEADER(pmt->Format());


	return NOERROR;

    } else {
        return VFW_S_NO_MORE_ITEMS;
    }
}


// called from CBaseOutputPin to prepare the allocator's count
// of buffers and sizes
HRESULT CMJPGEnc::DecideBufferSize(IMemAllocator * pAllocator,
                                 ALLOCATOR_PROPERTIES *pProperties)
{
    // David assures me this won't be called with NULL output mt.
    ASSERT(m_pOutput->CurrentMediaType().IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);
    ASSERT(m_phInstance);

    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.

    pProperties->cBuffers = 1;

    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize();

    // Variable sized? the answer is in biSizeImage
    if (pProperties->cbBuffer == 0) {

	LPBITMAPINFOHEADER lpbi=HEADER(m_pOutput->CurrentMediaType().Format());
	pProperties->cbBuffer= lpbi->biSizeImage;
        if (pProperties->cbBuffer <= 0) {
	    DbgLog((LOG_ERROR,1,TEXT("do not have image size")));
	    return E_INVALIDARG;
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("*::DecideBufferSize - size is %ld"), pProperties->cbBuffer));

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    // we must get exactly one buffer, since the temporal compression assumes
    // that the previous decompressed frame is already present in the output
    // buffer. The alternative is to copy the bits from a saved location before
    // doing the decompression, but that is not nice.
    if (Actual.cBuffers != 1) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - need exactly 1 buffer")));
	return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT CMJPGEnc::StartStreaming()
{
    DbgLog((LOG_TRACE,1,TEXT("*::StartStreaming")));

    // We have a driver dialog up that is about to change the capture settings.
    // Now is NOT a good time to start streaming.
    if (m_fDialogUp) {
        DbgLog((LOG_TRACE,1,TEXT("*::StartStreaming - Dialog up. SORRY!")));
	return E_UNEXPECTED;
    }

    if (!m_fStreaming) {

	//since MJPEG's SetState does nothing. i take it out
	// if (m_lpState)
	//    ICSetState(m_phInstance, m_lpState, m_cbState);

	// Start Streaming Compression
	ICINFO icinfo;
        DWORD_PTR err = 0;
        __try
        {
	err = CompressBegin(m_phInstance,
				HEADER(m_pInput->CurrentMediaType().Format()),
		    		HEADER(m_pOutput->CurrentMediaType().Format()));
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	if (ICERR_OK == err) {

	    // Reset streaming frame # count
	    m_lFrameCount = 0;

	    // Use defaults
	    if (m_compvars.lKey < 0)
		// *X* MJPEG codec dees not support this compression Messages
	    	//m_compvars.lKey = ICGetDefaultKeyFrameRate(m_phInstance);
		m_compvars.lKey=AM_MJPEG_DEFAULTKEYFRAMERATE;

	    // use defaults
	    //if (m_compvars.lQ == ICQUALITY_DEFAULT)
	   //	m_compvars.lQ = GetDefaultQuality(m_phInstance);

	    // Make sure first frame we make will be a keyframe, no matter how
	    // often key frames might be requested.
	    m_nKeyCount = 1000000;

 	    // Figure out how big each frame needs to be based on the data rate
	    // and fps of the movie.  Don't overflow!
    	    LONGLONG time = ((VIDEOINFOHEADER *)
			(m_pInput->CurrentMediaType().Format()))->AvgTimePerFrame;
    	    DWORD fps = time ? DWORD(UNITS * (LONGLONG)1000 / time) : 1000;
    	    m_dwSizePerFrame = DWORD(LONGLONG(m_compvars.lDataRate) *
				1024 * 1000 / fps);
    	    DbgLog((LOG_TRACE,2,TEXT("Making each frame %d bytes big"),
				m_dwSizePerFrame));

	    // We'll need a previous buffer for compression if not every
	    // frame is a keyframe, and the compressor does temporal
	    // compression and needs such a buffer
            DWORD dwGetInfoResult = 0;
            __try
            {
            dwGetInfoResult = GetInfo(m_phInstance, &icinfo, sizeof(icinfo));
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                // handling code
                return E_FAIL;
            }

	    if (dwGetInfoResult) {

		if (!(icinfo.dwFlags & VIDCF_CRUNCH))
		    m_compvars.lDataRate = 0;	// we can't crunch

	        // Now prepare the decompressor for the previous bits
	        if (m_compvars.lKey != 1 &&
				(icinfo.dwFlags & VIDCF_TEMPORAL) &&
				!(icinfo.dwFlags & VIDCF_FASTTEMPORALC)) {

		    // allocate a previous header of the proper size
		    DWORD dw = sizeof(BITMAPINFOHEADER);

		    m_lpbiPrev = (LPBITMAPINFOHEADER)GlobalAllocPtr(
							GMEM_MOVEABLE, dw);
		    if (!m_lpbiPrev) {
                        DbgLog((LOG_ERROR,1,TEXT("Error allocating previous bih")));
		        return E_OUTOFMEMORY;
		    }

		    // Ask the compressor what format to decompress back to...
		    // it's not necessarily the same as what it compressed from-
		    // the size may change
                    __try
                    {
		    dw = DecompressGetFormat(m_phInstance,
			HEADER(m_pOutput->CurrentMediaType().Format()),
			m_lpbiPrev);
                    }
                    __except(Exception_Filter(GetExceptionCode()))
                    {
                        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                        // handling code
		        GlobalFreePtr(m_lpbiPrev);
		        m_lpbiPrev = NULL;
                        return E_FAIL;
                    }
		    if ((LONG) dw < 0) {
		        GlobalFreePtr(m_lpbiPrev);
		        m_lpbiPrev = NULL;
                        DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompressGetFormat")));
		        return E_FAIL;
		    }

		    if (m_lpbiPrev->biSizeImage == 0)
	    	        m_lpbiPrev->biSizeImage = DIBSIZE(*m_lpbiPrev);

		    // allocate enough space for a decompressed image
		    m_lpBitsPrev = GlobalAllocPtr(GMEM_MOVEABLE,
						m_lpbiPrev->biSizeImage);
		    if (m_lpBitsPrev == NULL) {
		        GlobalFreePtr(m_lpbiPrev);
		        m_lpbiPrev = NULL;
                        DbgLog((LOG_ERROR,1,TEXT("Error reallocating BitsPrev")));
		        return E_OUTOFMEMORY;
		    }

                    __try
                    {
                        dw = DecompressBegin(m_phInstance,
			                    HEADER(m_pOutput->CurrentMediaType().Format()),
			                    m_lpbiPrev);
                    }
                    __except(Exception_Filter(GetExceptionCode()))
                    {
                        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                        // handling code
		        GlobalFreePtr(m_lpBitsPrev);
		        GlobalFreePtr(m_lpbiPrev);
		        m_lpBitsPrev = NULL;
		        m_lpbiPrev = NULL;
                        return E_FAIL;
                    }
		    if (ICERR_OK != dw) {
		        GlobalFreePtr(m_lpBitsPrev);
		        GlobalFreePtr(m_lpbiPrev);
		        m_lpBitsPrev = NULL;
		        m_lpbiPrev = NULL;
                        DbgLog((LOG_ERROR,1,TEXT("Error in ICDecompressBegin")));
		        return E_FAIL;
		    }
		}
	    } else {

		DbgLog((LOG_ERROR,1,TEXT("Error in ICGetInfo")));
		return E_FAIL;
	    }

	    // OK, everything worked.
	    m_fStreaming = TRUE;

	} else {
            DbgLog((LOG_ERROR,1,TEXT("Error in CompressBegin")));
	    return E_FAIL;
	}  //if (ICERR_OK == err)
    }  //if(!n_fStreaming

    return NOERROR;
}

HRESULT CMJPGEnc::StopStreaming()
{
    DbgLog((LOG_TRACE,1,TEXT("*::StopStreaming")));

    if (m_fStreaming) {
	ASSERT(m_phInstance);

	if (m_fInICCompress)
    	    DbgLog((LOG_TRACE,1,TEXT("***** ACK! Still compressing!")));
	while (m_fInICCompress);	// !!!

        __try
        {
	CompressEnd(m_phInstance);
        }
        __except(Exception_Filter(GetExceptionCode()))
        {
            DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
            // handling code
            return E_FAIL;
        }

	m_fStreaming = FALSE;
	if (m_lpBitsPrev) {
            __try
            {
	    DecompressEnd(m_phInstance);
            }
            __except(Exception_Filter(GetExceptionCode()))
            {
                DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
                // handling code
                // clean up
                GlobalFreePtr(m_lpBitsPrev);
	        GlobalFreePtr(m_lpbiPrev);
	        m_lpbiPrev = NULL;
	        m_lpBitsPrev = NULL;
                return E_FAIL;
            }
	    GlobalFreePtr(m_lpBitsPrev);
	    GlobalFreePtr(m_lpbiPrev);
	    m_lpbiPrev = NULL;
	    m_lpBitsPrev = NULL;
	}
    }
    return NOERROR;
}

DWORD CMJPGEnc::GetICInfo (ICINFO *picinfo)
{
    CheckPointer(picinfo, E_POINTER);

    DWORD dwGetInfoResult = 0;
    __try
    {
    dwGetInfoResult = GetInfo (NULL, picinfo, sizeof(ICINFO));
    }
    __except(Exception_Filter(GetExceptionCode()))
    {
        DbgLog((LOG_TRACE,1,TEXT("Handling PMJPEG32 Exception")));
        // handling code
        return E_FAIL;
    }

    return dwGetInfoResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\encode\x.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_ICMPROPERTIES	700
#define ID_OPTIONS		    701
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\encode\pin.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// CO - quartz wrapper for old video compressors
// pin.cpp - the output pin code
//

#include <streams.h>
#include <windowsx.h>
#include <vfw.h>

#include "MJPGEnc.h"

// --- CCoOutputPin ----------------------------------------

/*
    CMJPGOutputPin constructor
*/
CMJPGOutputPin::CMJPGOutputPin(
    TCHAR              * pObjectName,
    CMJPGEnc 	       * pFilter,
    HRESULT            * phr,
    LPCWSTR              pPinName) :

    CTransformOutputPin(pObjectName, pFilter, phr, pPinName),
    m_pFilter(pFilter)
{
    DbgLog((LOG_TRACE,1,TEXT("*Instantiating the CMJPGOutputPin")));
}

CMJPGOutputPin::~CMJPGOutputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying the CMJPGOutputPin")));
};


// overriden to expose IMediaPosition and IMediaSeeking control interfaces
// and all the capture interfaces we support
// !!! The base classes change all the time and I won't pick up their bug fixes!
STDMETHODIMP CMJPGOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    if (riid == IID_IAMStreamConfig) {
	return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMVideoCompression) {
	return GetInterface((LPUNKNOWN)(IAMVideoCompression *)this, ppv);
    } else {
        DbgLog((LOG_TRACE,99,TEXT("QI on CMJPGOutputPin")));
        return CTransformOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CMJPGOutputPin::Reconnect()
{
    if (IsConnected()) {
        DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our output pin")));
        CMediaType cmt;
	GetMediaType(0, &cmt);
	if (S_OK == GetConnected()->QueryAccept(&cmt)) {
	    m_pFilter->m_pGraph->Reconnect(this);
	} else {
	    // !!! CAPTURE does this better - I don't care, we don't need this
	    // except for the Dialog box
	    // I better break our connections cuz we can't go on like this
            DbgLog((LOG_ERROR,1,TEXT("Can't reconnect with new MT! Disconnecting!")));
	    // !!! We need to notify applications that connections are broken !
	    GetConnected()->Disconnect();
	    Disconnect();
	    return E_UNEXPECTED;
	}
    }
    return NOERROR;
}

//=============================================================================
//=============================================================================

// IAMStreamConfig stuff

// Tell the compressor to compress to a specific format.  If it isn't connected,
// then it will use that format to connect when it does.  If already connected,
// then it will reconnect with the new format.
//
// calling this to change compressors will change what GetInfo will return
//
HRESULT CMJPGOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
	return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %x %dbit %dx%d"),
		HEADER(pmt->pbFormat)->biCompression,
		HEADER(pmt->pbFormat)->biBitCount,
		HEADER(pmt->pbFormat)->biWidth,
		HEADER(pmt->pbFormat)->biHeight));

    if (m_pFilter->m_fStreaming)
	return VFW_E_NOT_STOPPED;

    if (!m_pFilter->m_pInput->IsConnected())
	return VFW_E_NOT_CONNECTED;

    // If this is the same format as we already are using, don't bother
    CMediaType cmt;
    if ((hr = GetMediaType(0,&cmt)) != S_OK)
	return hr;
    if (cmt == *pmt) {
	return NOERROR;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
	hr = GetConnected()->QueryAccept(pmt);
	if (hr != NOERROR)
	    return VFW_E_INVALIDMEDIATYPE;
    }

    // Normally we wouldn't leave the compressor we find in CheckTransform
    // open if our input is connected already, but we need to force it to
    // leave it open so that it's still open when we call SetMediaType below
    m_pFilter->m_fCacheIns = TRUE;
    hr = m_pFilter->CheckTransform(&m_pFilter->m_pInput->CurrentMediaType(),
						(CMediaType *)pmt);
    m_pFilter->m_fCacheIns = FALSE;

    if (hr != S_OK) {
        DbgLog((LOG_TRACE,1,TEXT("Nobody likes this format. Sorry.")));
 	return hr;
    }

    hr = m_pFilter->SetMediaType(PINDIR_OUTPUT, (CMediaType *)pmt);
    ASSERT(hr == S_OK);

    // from now on, this is the only media type we offer
    m_pFilter->m_cmt = *pmt;
    m_pFilter->m_fOfferSetFormatOnly = TRUE;

    // Changing the format means reconnecting if necessary
    Reconnect();

    return NOERROR;
}


// What format are we compressing to right now?
//
HRESULT CMJPGOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMAudioStreamConfig::GetFormat")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (ppmt == NULL)
	return E_POINTER;

    // Output choices depend on the input connected
    if (!m_pFilter->m_pInput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("No input type set yet, no can do")));
	return VFW_E_NOT_CONNECTED;
    }

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
	CoTaskMemFree(*ppmt);
	*ppmt = NULL;
	return hr;
    }
    return NOERROR;
}


//
//
HRESULT CMJPGOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetNumberOfCapabilities")));

    if (piCount == NULL || piSize == NULL)
	return E_POINTER;

    *piCount = 1;
    *piSize = sizeof(VIDEO_STREAM_CONFIG_CAPS);
    return NOERROR;
}


// find out some capabilities of this compressor
//
HRESULT CMJPGOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    VIDEO_STREAM_CONFIG_CAPS *pVSCC = (VIDEO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (ppmt == NULL || pSCC == NULL)
	return E_POINTER;

    // no good
    if (i < 0)
	return E_INVALIDARG;
    if (i > 0)
	return S_FALSE;

    HRESULT hr = GetFormat(ppmt);
    if (hr != NOERROR)
	return hr;

    ZeroMemory(pVSCC, sizeof(VIDEO_STREAM_CONFIG_CAPS));
    pVSCC->guid = MEDIATYPE_Video;

    // we don't do cropping
    if (m_pFilter->m_pInput->IsConnected()) {
        pVSCC->InputSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->InputSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
        pVSCC->MinCroppingSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->MinCroppingSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
        pVSCC->MaxCroppingSize.cx =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biWidth;
        pVSCC->MaxCroppingSize.cy =
	HEADER(m_pFilter->m_pInput->CurrentMediaType().Format())->biHeight;
    }

    return NOERROR;
}


//=============================================================================

// IAMVideoCompression stuff

// make key frames this often
//
HRESULT CMJPGOutputPin::put_KeyFrameRate(long KeyFrameRate)
{

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    if (KeyFrameRate >=0) {
        m_pFilter->m_compvars.lKey = KeyFrameRate;
	return NOERROR;
    }

    //MJPEG codec does not support ICM_GetDefaultKeyFrameRate()
    //m_pFilter->m_compvars.lKey = ICGetDefaultKeyFrameRate(ph);
    m_pFilter->m_compvars.lKey =AM_MJPEG_DEFAULTKEYFRAMERATE;
    
    return NOERROR;
}


// make key frames this often
//
HRESULT CMJPGOutputPin::get_KeyFrameRate(long FAR* pKeyFrameRate)
{
    if (pKeyFrameRate) {
	*pKeyFrameRate = m_pFilter->m_compvars.lKey;
    } else {
	return E_POINTER;
    }

    return NOERROR;
}


// compress with this quality
//
HRESULT CMJPGOutputPin::put_Quality(double Quality)
{
    if (Quality < 0)
	m_pFilter->m_compvars.lQ = ICQUALITY_DEFAULT;
    else if (Quality >= 0. && Quality <= 1.)
	m_pFilter->m_compvars.lQ = (long)(Quality * 10000.);
    else
	return E_INVALIDARG;

    return NOERROR;
}


// compress with this quality
//
HRESULT CMJPGOutputPin::get_Quality(double FAR* pQuality)
{
    // scale 0-10000 to 0-1
    if (pQuality) {
	if (m_pFilter->m_compvars.lQ == ICQUALITY_DEFAULT)
	    *pQuality = -1.;
	else
	    *pQuality = m_pFilter->m_compvars.lQ / (double)ICQUALITY_HIGH;
    } else {
	return E_POINTER;
    }

    return NOERROR;
}


// every frame must fit in the data rate... we don't do the WindowSize thing
//
HRESULT CMJPGOutputPin::get_WindowSize(DWORDLONG FAR* pWindowSize)
{
    if (pWindowSize == NULL)
	return E_POINTER;

    *pWindowSize = 1;	// we don't do windows
    return NOERROR;
}


// make this frame a key frame, whenever it comes by
//
HRESULT CMJPGOutputPin::OverrideKeyFrame(long FrameNumber)
{
    // !!! be brave?
    return E_NOTIMPL;
}


// make this frame this size, whenever it comes by
//
HRESULT CMJPGOutputPin::OverrideFrameSize(long FrameNumber, long Size)
{
    // !!! be brave?
    return E_NOTIMPL;
}


// Get some information about the codec
//
HRESULT CMJPGOutputPin::GetInfo(LPWSTR pstrVersion, int *pcbVersion, LPWSTR pstrDescription, int *pcbDescription, long FAR* pDefaultKeyFrameRate, long FAR* pDefaultPFramesPerKey, double FAR* pDefaultQuality, long FAR* pCapabilities)
{
    ICINFO icinfo;
    DbgLog((LOG_TRACE,1,TEXT("IAMVideoCompression::GetInfo")));

    // To make sure we're not in the middle of connecting
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);
	
    DWORD dw = m_pFilter->GetICInfo (&icinfo);  //first var is not used by the function
    
    if (pDefaultKeyFrameRate)
	*pDefaultKeyFrameRate = AM_MJPEG_DEFAULTKEYFRAMERATE;

    if (pDefaultPFramesPerKey)
	*pDefaultPFramesPerKey = 0;

    if (pDefaultQuality)
	*pDefaultQuality = .75; // ask the driver, don't hardcode

    if (pCapabilities) {
	*pCapabilities = 0;
	if (dw > 0) {
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_QUALITY) ?
					CompressionCaps_CanQuality : 0);
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_CRUNCH) ?
					CompressionCaps_CanCrunch : 0);
	    *pCapabilities |= ((icinfo.dwFlags & VIDCF_TEMPORAL) ?
					CompressionCaps_CanKeyFrame : 0);
	    // we don't do b frames
	}
    }

    // We have no version string, but we have a description
    if (pstrVersion)
        *pstrVersion = 0;
    if (pcbVersion)
        *pcbVersion = 0;
    if (dw > 0) {
        if (pstrDescription && pcbDescription)
            lstrcpynW(pstrDescription, (LPCWSTR)&icinfo.szDescription,
			min(*pcbDescription / 2,
			lstrlenW((LPCWSTR)&icinfo.szDescription) + 1));
	if (pcbDescription)
	    // string length in bytes, incl. NULL
	    *pcbDescription = lstrlenW((LPCWSTR)&icinfo.szDescription) * 2 + 2;
    } else {
        if (pstrDescription) {
    	    *pstrDescription = 0;
	if (pcbDescription)
	    *pcbDescription = 0;
	}
    }

    
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\dibtable.c ===
/* Copyright (c) 1994 Paradigm Matrix.
   All Rights Reserved.
*/

/* pixel mapping table for different DIB formats */
#include <windows.h>
DWORD shiftl16bits8[256] = {
	0x00000000, 0x00010000, 0x00020000, 0x00030000, 0x00040000, 0x00050000, 0x00060000, 0x00070000, 
	0x00080000, 0x00090000, 0x000a0000, 0x000b0000, 0x000c0000, 0x000d0000, 0x000e0000, 0x000f0000, 
	0x00100000, 0x00110000, 0x00120000, 0x00130000, 0x00140000, 0x00150000, 0x00160000, 0x00170000, 
	0x00180000, 0x00190000, 0x001a0000, 0x001b0000, 0x001c0000, 0x001d0000, 0x001e0000, 0x001f0000, 
	0x00200000, 0x00210000, 0x00220000, 0x00230000, 0x00240000, 0x00250000, 0x00260000, 0x00270000, 
	0x00280000, 0x00290000, 0x002a0000, 0x002b0000, 0x002c0000, 0x002d0000, 0x002e0000, 0x002f0000, 
	0x00300000, 0x00310000, 0x00320000, 0x00330000, 0x00340000, 0x00350000, 0x00360000, 0x00370000, 
	0x00380000, 0x00390000, 0x003a0000, 0x003b0000, 0x003c0000, 0x003d0000, 0x003e0000, 0x003f0000, 
	0x00400000, 0x00410000, 0x00420000, 0x00430000, 0x00440000, 0x00450000, 0x00460000, 0x00470000, 
	0x00480000, 0x00490000, 0x004a0000, 0x004b0000, 0x004c0000, 0x004d0000, 0x004e0000, 0x004f0000, 
	0x00500000, 0x00510000, 0x00520000, 0x00530000, 0x00540000, 0x00550000, 0x00560000, 0x00570000, 
	0x00580000, 0x00590000, 0x005a0000, 0x005b0000, 0x005c0000, 0x005d0000, 0x005e0000, 0x005f0000, 
	0x00600000, 0x00610000, 0x00620000, 0x00630000, 0x00640000, 0x00650000, 0x00660000, 0x00670000, 
	0x00680000, 0x00690000, 0x006a0000, 0x006b0000, 0x006c0000, 0x006d0000, 0x006e0000, 0x006f0000, 
	0x00700000, 0x00710000, 0x00720000, 0x00730000, 0x00740000, 0x00750000, 0x00760000, 0x00770000, 
	0x00780000, 0x00790000, 0x007a0000, 0x007b0000, 0x007c0000, 0x007d0000, 0x007e0000, 0x007f0000, 
	0x00800000, 0x00810000, 0x00820000, 0x00830000, 0x00840000, 0x00850000, 0x00860000, 0x00870000, 
	0x00880000, 0x00890000, 0x008a0000, 0x008b0000, 0x008c0000, 0x008d0000, 0x008e0000, 0x008f0000, 
	0x00900000, 0x00910000, 0x00920000, 0x00930000, 0x00940000, 0x00950000, 0x00960000, 0x00970000, 
	0x00980000, 0x00990000, 0x009a0000, 0x009b0000, 0x009c0000, 0x009d0000, 0x009e0000, 0x009f0000, 
	0x00a00000, 0x00a10000, 0x00a20000, 0x00a30000, 0x00a40000, 0x00a50000, 0x00a60000, 0x00a70000, 
	0x00a80000, 0x00a90000, 0x00aa0000, 0x00ab0000, 0x00ac0000, 0x00ad0000, 0x00ae0000, 0x00af0000, 
	0x00b00000, 0x00b10000, 0x00b20000, 0x00b30000, 0x00b40000, 0x00b50000, 0x00b60000, 0x00b70000, 
	0x00b80000, 0x00b90000, 0x00ba0000, 0x00bb0000, 0x00bc0000, 0x00bd0000, 0x00be0000, 0x00bf0000, 
	0x00c00000, 0x00c10000, 0x00c20000, 0x00c30000, 0x00c40000, 0x00c50000, 0x00c60000, 0x00c70000, 
	0x00c80000, 0x00c90000, 0x00ca0000, 0x00cb0000, 0x00cc0000, 0x00cd0000, 0x00ce0000, 0x00cf0000, 
	0x00d00000, 0x00d10000, 0x00d20000, 0x00d30000, 0x00d40000, 0x00d50000, 0x00d60000, 0x00d70000, 
	0x00d80000, 0x00d90000, 0x00da0000, 0x00db0000, 0x00dc0000, 0x00dd0000, 0x00de0000, 0x00df0000, 
	0x00e00000, 0x00e10000, 0x00e20000, 0x00e30000, 0x00e40000, 0x00e50000, 0x00e60000, 0x00e70000, 
	0x00e80000, 0x00e90000, 0x00ea0000, 0x00eb0000, 0x00ec0000, 0x00ed0000, 0x00ee0000, 0x00ef0000, 
	0x00f00000, 0x00f10000, 0x00f20000, 0x00f30000, 0x00f40000, 0x00f50000, 0x00f60000, 0x00f70000, 
	0x00f80000, 0x00f90000, 0x00fa0000, 0x00fb0000, 0x00fc0000, 0x00fd0000, 0x00fe0000, 0x00ff0000
	};

DWORD shiftl8bits8[256] = {
	0x00000000, 0x00000100, 0x00000200, 0x00000300, 0x00000400, 0x00000500, 0x00000600, 0x00000700, 
	0x00000800, 0x00000900, 0x00000a00, 0x00000b00, 0x00000c00, 0x00000d00, 0x00000e00, 0x00000f00, 
	0x00001000, 0x00001100, 0x00001200, 0x00001300, 0x00001400, 0x00001500, 0x00001600, 0x00001700, 
	0x00001800, 0x00001900, 0x00001a00, 0x00001b00, 0x00001c00, 0x00001d00, 0x00001e00, 0x00001f00, 
	0x00002000, 0x00002100, 0x00002200, 0x00002300, 0x00002400, 0x00002500, 0x00002600, 0x00002700, 
	0x00002800, 0x00002900, 0x00002a00, 0x00002b00, 0x00002c00, 0x00002d00, 0x00002e00, 0x00002f00, 
	0x00003000, 0x00003100, 0x00003200, 0x00003300, 0x00003400, 0x00003500, 0x00003600, 0x00003700, 
	0x00003800, 0x00003900, 0x00003a00, 0x00003b00, 0x00003c00, 0x00003d00, 0x00003e00, 0x00003f00, 
	0x00004000, 0x00004100, 0x00004200, 0x00004300, 0x00004400, 0x00004500, 0x00004600, 0x00004700, 
	0x00004800, 0x00004900, 0x00004a00, 0x00004b00, 0x00004c00, 0x00004d00, 0x00004e00, 0x00004f00, 
	0x00005000, 0x00005100, 0x00005200, 0x00005300, 0x00005400, 0x00005500, 0x00005600, 0x00005700, 
	0x00005800, 0x00005900, 0x00005a00, 0x00005b00, 0x00005c00, 0x00005d00, 0x00005e00, 0x00005f00, 
	0x00006000, 0x00006100, 0x00006200, 0x00006300, 0x00006400, 0x00006500, 0x00006600, 0x00006700, 
	0x00006800, 0x00006900, 0x00006a00, 0x00006b00, 0x00006c00, 0x00006d00, 0x00006e00, 0x00006f00, 
	0x00007000, 0x00007100, 0x00007200, 0x00007300, 0x00007400, 0x00007500, 0x00007600, 0x00007700, 
	0x00007800, 0x00007900, 0x00007a00, 0x00007b00, 0x00007c00, 0x00007d00, 0x00007e00, 0x00007f00, 
	0x00008000, 0x00008100, 0x00008200, 0x00008300, 0x00008400, 0x00008500, 0x00008600, 0x00008700, 
	0x00008800, 0x00008900, 0x00008a00, 0x00008b00, 0x00008c00, 0x00008d00, 0x00008e00, 0x00008f00, 
	0x00009000, 0x00009100, 0x00009200, 0x00009300, 0x00009400, 0x00009500, 0x00009600, 0x00009700, 
	0x00009800, 0x00009900, 0x00009a00, 0x00009b00, 0x00009c00, 0x00009d00, 0x00009e00, 0x00009f00, 
	0x0000a000, 0x0000a100, 0x0000a200, 0x0000a300, 0x0000a400, 0x0000a500, 0x0000a600, 0x0000a700, 
	0x0000a800, 0x0000a900, 0x0000aa00, 0x0000ab00, 0x0000ac00, 0x0000ad00, 0x0000ae00, 0x0000af00, 
	0x0000b000, 0x0000b100, 0x0000b200, 0x0000b300, 0x0000b400, 0x0000b500, 0x0000b600, 0x0000b700, 
	0x0000b800, 0x0000b900, 0x0000ba00, 0x0000bb00, 0x0000bc00, 0x0000bd00, 0x0000be00, 0x0000bf00, 
	0x0000c000, 0x0000c100, 0x0000c200, 0x0000c300, 0x0000c400, 0x0000c500, 0x0000c600, 0x0000c700, 
	0x0000c800, 0x0000c900, 0x0000ca00, 0x0000cb00, 0x0000cc00, 0x0000cd00, 0x0000ce00, 0x0000cf00, 
	0x0000d000, 0x0000d100, 0x0000d200, 0x0000d300, 0x0000d400, 0x0000d500, 0x0000d600, 0x0000d700, 
	0x0000d800, 0x0000d900, 0x0000da00, 0x0000db00, 0x0000dc00, 0x0000dd00, 0x0000de00, 0x0000df00, 
	0x0000e000, 0x0000e100, 0x0000e200, 0x0000e300, 0x0000e400, 0x0000e500, 0x0000e600, 0x0000e700, 
	0x0000e800, 0x0000e900, 0x0000ea00, 0x0000eb00, 0x0000ec00, 0x0000ed00, 0x0000ee00, 0x0000ef00, 
	0x0000f000, 0x0000f100, 0x0000f200, 0x0000f300, 0x0000f400, 0x0000f500, 0x0000f600, 0x0000f700, 
	0x0000f800, 0x0000f900, 0x0000fa00, 0x0000fb00, 0x0000fc00, 0x0000fd00, 0x0000fe00, 0x0000ff00
	};

DWORD shiftl0bits8[256] = {
	0x00000000, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 
	0x00000008, 0x00000009, 0x0000000a, 0x0000000b, 0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f, 
	0x00000010, 0x00000011, 0x00000012, 0x00000013, 0x00000014, 0x00000015, 0x00000016, 0x00000017, 
	0x00000018, 0x00000019, 0x0000001a, 0x0000001b, 0x0000001c, 0x0000001d, 0x0000001e, 0x0000001f, 
	0x00000020, 0x00000021, 0x00000022, 0x00000023, 0x00000024, 0x00000025, 0x00000026, 0x00000027, 
	0x00000028, 0x00000029, 0x0000002a, 0x0000002b, 0x0000002c, 0x0000002d, 0x0000002e, 0x0000002f, 
	0x00000030, 0x00000031, 0x00000032, 0x00000033, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 
	0x00000038, 0x00000039, 0x0000003a, 0x0000003b, 0x0000003c, 0x0000003d, 0x0000003e, 0x0000003f, 
	0x00000040, 0x00000041, 0x00000042, 0x00000043, 0x00000044, 0x00000045, 0x00000046, 0x00000047, 
	0x00000048, 0x00000049, 0x0000004a, 0x0000004b, 0x0000004c, 0x0000004d, 0x0000004e, 0x0000004f, 
	0x00000050, 0x00000051, 0x00000052, 0x00000053, 0x00000054, 0x00000055, 0x00000056, 0x00000057, 
	0x00000058, 0x00000059, 0x0000005a, 0x0000005b, 0x0000005c, 0x0000005d, 0x0000005e, 0x0000005f, 
	0x00000060, 0x00000061, 0x00000062, 0x00000063, 0x00000064, 0x00000065, 0x00000066, 0x00000067, 
	0x00000068, 0x00000069, 0x0000006a, 0x0000006b, 0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f, 
	0x00000070, 0x00000071, 0x00000072, 0x00000073, 0x00000074, 0x00000075, 0x00000076, 0x00000077, 
	0x00000078, 0x00000079, 0x0000007a, 0x0000007b, 0x0000007c, 0x0000007d, 0x0000007e, 0x0000007f, 
	0x00000080, 0x00000081, 0x00000082, 0x00000083, 0x00000084, 0x00000085, 0x00000086, 0x00000087, 
	0x00000088, 0x00000089, 0x0000008a, 0x0000008b, 0x0000008c, 0x0000008d, 0x0000008e, 0x0000008f, 
	0x00000090, 0x00000091, 0x00000092, 0x00000093, 0x00000094, 0x00000095, 0x00000096, 0x00000097, 
	0x00000098, 0x00000099, 0x0000009a, 0x0000009b, 0x0000009c, 0x0000009d, 0x0000009e, 0x0000009f, 
	0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3, 0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7, 
	0x000000a8, 0x000000a9, 0x000000aa, 0x000000ab, 0x000000ac, 0x000000ad, 0x000000ae, 0x000000af, 
	0x000000b0, 0x000000b1, 0x000000b2, 0x000000b3, 0x000000b4, 0x000000b5, 0x000000b6, 0x000000b7, 
	0x000000b8, 0x000000b9, 0x000000ba, 0x000000bb, 0x000000bc, 0x000000bd, 0x000000be, 0x000000bf, 
	0x000000c0, 0x000000c1, 0x000000c2, 0x000000c3, 0x000000c4, 0x000000c5, 0x000000c6, 0x000000c7, 
	0x000000c8, 0x000000c9, 0x000000ca, 0x000000cb, 0x000000cc, 0x000000cd, 0x000000ce, 0x000000cf, 
	0x000000d0, 0x000000d1, 0x000000d2, 0x000000d3, 0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7, 
	0x000000d8, 0x000000d9, 0x000000da, 0x000000db, 0x000000dc, 0x000000dd, 0x000000de, 0x000000df, 
	0x000000e0, 0x000000e1, 0x000000e2, 0x000000e3, 0x000000e4, 0x000000e5, 0x000000e6, 0x000000e7, 
	0x000000e8, 0x000000e9, 0x000000ea, 0x000000eb, 0x000000ec, 0x000000ed, 0x000000ee, 0x000000ef, 
	0x000000f0, 0x000000f1, 0x000000f2, 0x000000f3, 0x000000f4, 0x000000f5, 0x000000f6, 0x000000f7, 
	0x000000f8, 0x000000f9, 0x000000fa, 0x000000fb, 0x000000fc, 0x000000fd, 0x000000fe, 0x000000ff
	};

DWORD shiftl7bits5[256] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000400, 0x00000400, 
	0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000800, 0x00000800, 0x00000800, 
	0x00000800, 0x00000800, 0x00000800, 0x00000800, 0x00000800, 0x00000c00, 0x00000c00, 0x00000c00, 
	0x00000c00, 0x00000c00, 0x00000c00, 0x00000c00, 0x00000c00, 0x00001000, 0x00001000, 0x00001000, 
	0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001400, 0x00001400, 
	0x00001400, 0x00001400, 0x00001400, 0x00001400, 0x00001400, 0x00001400, 0x00001800, 0x00001800, 
	0x00001800, 0x00001800, 0x00001800, 0x00001800, 0x00001800, 0x00001800, 0x00001c00, 0x00001c00, 
	0x00001c00, 0x00001c00, 0x00001c00, 0x00001c00, 0x00001c00, 0x00001c00, 0x00002000, 0x00002000, 
	0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002400, 0x00002400, 
	0x00002400, 0x00002400, 0x00002400, 0x00002400, 0x00002400, 0x00002400, 0x00002400, 0x00002800, 
	0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002c00, 
	0x00002c00, 0x00002c00, 0x00002c00, 0x00002c00, 0x00002c00, 0x00002c00, 0x00002c00, 0x00003000, 
	0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003400, 
	0x00003400, 0x00003400, 0x00003400, 0x00003400, 0x00003400, 0x00003400, 0x00003400, 0x00003400, 
	0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 
	0x00003c00, 0x00003c00, 0x00003c00, 0x00003c00, 0x00003c00, 0x00003c00, 0x00003c00, 0x00003c00, 
	0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 
	0x00004400, 0x00004400, 0x00004400, 0x00004400, 0x00004400, 0x00004400, 0x00004400, 0x00004400, 
	0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 
	0x00004800, 0x00004c00, 0x00004c00, 0x00004c00, 0x00004c00, 0x00004c00, 0x00004c00, 0x00004c00, 
	0x00004c00, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 
	0x00005000, 0x00005400, 0x00005400, 0x00005400, 0x00005400, 0x00005400, 0x00005400, 0x00005400, 
	0x00005400, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 
	0x00005800, 0x00005800, 0x00005c00, 0x00005c00, 0x00005c00, 0x00005c00, 0x00005c00, 0x00005c00, 
	0x00005c00, 0x00005c00, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 
	0x00006000, 0x00006000, 0x00006400, 0x00006400, 0x00006400, 0x00006400, 0x00006400, 0x00006400, 
	0x00006400, 0x00006400, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 
	0x00006800, 0x00006800, 0x00006800, 0x00006c00, 0x00006c00, 0x00006c00, 0x00006c00, 0x00006c00, 
	0x00006c00, 0x00006c00, 0x00006c00, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 
	0x00007000, 0x00007000, 0x00007000, 0x00007400, 0x00007400, 0x00007400, 0x00007400, 0x00007400, 
	0x00007400, 0x00007400, 0x00007400, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 
	0x00007800, 0x00007800, 0x00007800, 0x00007c00, 0x00007c00, 0x00007c00, 0x00007c00, 0x00007c00
	};

DWORD shiftl2bits5[256] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000020, 0x00000020, 0x00000020, 
	0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000040, 0x00000040, 0x00000040, 
	0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000060, 0x00000060, 0x00000060, 
	0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000080, 0x00000080, 0x00000080, 
	0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x000000a0, 0x000000a0, 
	0x000000a0, 0x000000a0, 0x000000a0, 0x000000a0, 0x000000a0, 0x000000a0, 0x000000c0, 0x000000c0, 
	0x000000c0, 0x000000c0, 0x000000c0, 0x000000c0, 0x000000c0, 0x000000c0, 0x000000e0, 0x000000e0, 
	0x000000e0, 0x000000e0, 0x000000e0, 0x000000e0, 0x000000e0, 0x000000e0, 0x00000100, 0x00000100, 
	0x00000100, 0x00000100, 0x00000100, 0x00000100, 0x00000100, 0x00000100, 0x00000120, 0x00000120, 
	0x00000120, 0x00000120, 0x00000120, 0x00000120, 0x00000120, 0x00000120, 0x00000120, 0x00000140, 
	0x00000140, 0x00000140, 0x00000140, 0x00000140, 0x00000140, 0x00000140, 0x00000140, 0x00000160, 
	0x00000160, 0x00000160, 0x00000160, 0x00000160, 0x00000160, 0x00000160, 0x00000160, 0x00000180, 
	0x00000180, 0x00000180, 0x00000180, 0x00000180, 0x00000180, 0x00000180, 0x00000180, 0x000001a0, 
	0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 
	0x000001c0, 0x000001c0, 0x000001c0, 0x000001c0, 0x000001c0, 0x000001c0, 0x000001c0, 0x000001c0, 
	0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 
	0x00000200, 0x00000200, 0x00000200, 0x00000200, 0x00000200, 0x00000200, 0x00000200, 0x00000200, 
	0x00000220, 0x00000220, 0x00000220, 0x00000220, 0x00000220, 0x00000220, 0x00000220, 0x00000220, 
	0x00000240, 0x00000240, 0x00000240, 0x00000240, 0x00000240, 0x00000240, 0x00000240, 0x00000240, 
	0x00000240, 0x00000260, 0x00000260, 0x00000260, 0x00000260, 0x00000260, 0x00000260, 0x00000260, 
	0x00000260, 0x00000280, 0x00000280, 0x00000280, 0x00000280, 0x00000280, 0x00000280, 0x00000280, 
	0x00000280, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 
	0x000002a0, 0x000002c0, 0x000002c0, 0x000002c0, 0x000002c0, 0x000002c0, 0x000002c0, 0x000002c0, 
	0x000002c0, 0x000002c0, 0x000002e0, 0x000002e0, 0x000002e0, 0x000002e0, 0x000002e0, 0x000002e0, 
	0x000002e0, 0x000002e0, 0x00000300, 0x00000300, 0x00000300, 0x00000300, 0x00000300, 0x00000300, 
	0x00000300, 0x00000300, 0x00000320, 0x00000320, 0x00000320, 0x00000320, 0x00000320, 0x00000320, 
	0x00000320, 0x00000320, 0x00000340, 0x00000340, 0x00000340, 0x00000340, 0x00000340, 0x00000340, 
	0x00000340, 0x00000340, 0x00000340, 0x00000360, 0x00000360, 0x00000360, 0x00000360, 0x00000360, 
	0x00000360, 0x00000360, 0x00000360, 0x00000380, 0x00000380, 0x00000380, 0x00000380, 0x00000380, 
	0x00000380, 0x00000380, 0x00000380, 0x000003a0, 0x000003a0, 0x000003a0, 0x000003a0, 0x000003a0, 
	0x000003a0, 0x000003a0, 0x000003a0, 0x000003c0, 0x000003c0, 0x000003c0, 0x000003c0, 0x000003c0, 
	0x000003c0, 0x000003c0, 0x000003c0, 0x000003e0, 0x000003e0, 0x000003e0, 0x000003e0, 0x000003e0
	};

DWORD shiftr3bits5[256] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000001, 
	0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000002, 
	0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000003, 0x00000003, 0x00000003, 
	0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000004, 0x00000004, 0x00000004, 
	0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000005, 0x00000005, 
	0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000006, 0x00000006, 
	0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000007, 0x00000007, 
	0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000008, 0x00000008, 
	0x00000008, 0x00000008, 0x00000008, 0x00000008, 0x00000008, 0x00000008, 0x00000009, 0x00000009, 
	0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x0000000a, 
	0x0000000a, 0x0000000a, 0x0000000a, 0x0000000a, 0x0000000a, 0x0000000a, 0x0000000a, 0x0000000b, 
	0x0000000b, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000c, 
	0x0000000c, 0x0000000c, 0x0000000c, 0x0000000c, 0x0000000c, 0x0000000c, 0x0000000c, 0x0000000d, 
	0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, 
	0x0000000e, 0x0000000e, 0x0000000e, 0x0000000e, 0x0000000e, 0x0000000e, 0x0000000e, 0x0000000e, 
	0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f, 0x0000000f, 
	0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 
	0x00000011, 0x00000011, 0x00000011, 0x00000011, 0x00000011, 0x00000011, 0x00000011, 0x00000011, 
	0x00000012, 0x00000012, 0x00000012, 0x00000012, 0x00000012, 0x00000012, 0x00000012, 0x00000012, 
	0x00000012, 0x00000013, 0x00000013, 0x00000013, 0x00000013, 0x00000013, 0x00000013, 0x00000013, 
	0x00000013, 0x00000014, 0x00000014, 0x00000014, 0x00000014, 0x00000014, 0x00000014, 0x00000014, 
	0x00000014, 0x00000015, 0x00000015, 0x00000015, 0x00000015, 0x00000015, 0x00000015, 0x00000015, 
	0x00000015, 0x00000016, 0x00000016, 0x00000016, 0x00000016, 0x00000016, 0x00000016, 0x00000016, 
	0x00000016, 0x00000016, 0x00000017, 0x00000017, 0x00000017, 0x00000017, 0x00000017, 0x00000017, 
	0x00000017, 0x00000017, 0x00000018, 0x00000018, 0x00000018, 0x00000018, 0x00000018, 0x00000018, 
	0x00000018, 0x00000018, 0x00000019, 0x00000019, 0x00000019, 0x00000019, 0x00000019, 0x00000019, 
	0x00000019, 0x00000019, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a, 
	0x0000001a, 0x0000001a, 0x0000001a, 0x0000001b, 0x0000001b, 0x0000001b, 0x0000001b, 0x0000001b, 
	0x0000001b, 0x0000001b, 0x0000001b, 0x0000001c, 0x0000001c, 0x0000001c, 0x0000001c, 0x0000001c, 
	0x0000001c, 0x0000001c, 0x0000001c, 0x0000001d, 0x0000001d, 0x0000001d, 0x0000001d, 0x0000001d, 
	0x0000001d, 0x0000001d, 0x0000001d, 0x0000001e, 0x0000001e, 0x0000001e, 0x0000001e, 0x0000001e, 
	0x0000001e, 0x0000001e, 0x0000001e, 0x0000001f, 0x0000001f, 0x0000001f, 0x0000001f, 0x0000001f
	};

DWORD shiftl8bits5[256] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000800, 0x00000800, 0x00000800, 
	0x00000800, 0x00000800, 0x00000800, 0x00000800, 0x00000800, 0x00001000, 0x00001000, 0x00001000, 
	0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001800, 0x00001800, 0x00001800, 
	0x00001800, 0x00001800, 0x00001800, 0x00001800, 0x00001800, 0x00002000, 0x00002000, 0x00002000, 
	0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002800, 0x00002800, 
	0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00002800, 0x00003000, 0x00003000, 
	0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003800, 0x00003800, 
	0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00003800, 0x00004000, 0x00004000, 
	0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004800, 0x00004800, 
	0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00004800, 0x00005000, 
	0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005800, 
	0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00005800, 0x00006000, 
	0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006800, 
	0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 0x00006800, 
	0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 
	0x00007800, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 0x00007800, 
	0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 
	0x00008800, 0x00008800, 0x00008800, 0x00008800, 0x00008800, 0x00008800, 0x00008800, 0x00008800, 
	0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 
	0x00009000, 0x00009800, 0x00009800, 0x00009800, 0x00009800, 0x00009800, 0x00009800, 0x00009800, 
	0x00009800, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, 
	0x0000a000, 0x0000a800, 0x0000a800, 0x0000a800, 0x0000a800, 0x0000a800, 0x0000a800, 0x0000a800, 
	0x0000a800, 0x0000b000, 0x0000b000, 0x0000b000, 0x0000b000, 0x0000b000, 0x0000b000, 0x0000b000, 
	0x0000b000, 0x0000b000, 0x0000b800, 0x0000b800, 0x0000b800, 0x0000b800, 0x0000b800, 0x0000b800, 
	0x0000b800, 0x0000b800, 0x0000c000, 0x0000c000, 0x0000c000, 0x0000c000, 0x0000c000, 0x0000c000, 
	0x0000c000, 0x0000c000, 0x0000c800, 0x0000c800, 0x0000c800, 0x0000c800, 0x0000c800, 0x0000c800, 
	0x0000c800, 0x0000c800, 0x0000d000, 0x0000d000, 0x0000d000, 0x0000d000, 0x0000d000, 0x0000d000, 
	0x0000d000, 0x0000d000, 0x0000d000, 0x0000d800, 0x0000d800, 0x0000d800, 0x0000d800, 0x0000d800, 
	0x0000d800, 0x0000d800, 0x0000d800, 0x0000e000, 0x0000e000, 0x0000e000, 0x0000e000, 0x0000e000, 
	0x0000e000, 0x0000e000, 0x0000e000, 0x0000e800, 0x0000e800, 0x0000e800, 0x0000e800, 0x0000e800, 
	0x0000e800, 0x0000e800, 0x0000e800, 0x0000f000, 0x0000f000, 0x0000f000, 0x0000f000, 0x0000f000, 
	0x0000f000, 0x0000f000, 0x0000f000, 0x0000f800, 0x0000f800, 0x0000f800, 0x0000f800, 0x0000f800
	};

DWORD shiftl3bits6[256] = {
	0x00000000, 0x00000000, 0x00000000, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000040, 
	0x00000040, 0x00000040, 0x00000040, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000080, 
	0x00000080, 0x00000080, 0x00000080, 0x000000a0, 0x000000a0, 0x000000a0, 0x000000a0, 0x000000c0, 
	0x000000c0, 0x000000c0, 0x000000c0, 0x000000e0, 0x000000e0, 0x000000e0, 0x000000e0, 0x00000100, 
	0x00000100, 0x00000100, 0x00000100, 0x00000120, 0x00000120, 0x00000120, 0x00000120, 0x00000140, 
	0x00000140, 0x00000140, 0x00000140, 0x00000160, 0x00000160, 0x00000160, 0x00000160, 0x00000180, 
	0x00000180, 0x00000180, 0x00000180, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001a0, 0x000001c0, 
	0x000001c0, 0x000001c0, 0x000001c0, 0x000001e0, 0x000001e0, 0x000001e0, 0x000001e0, 0x00000200, 
	0x00000200, 0x00000200, 0x00000200, 0x00000220, 0x00000220, 0x00000220, 0x00000220, 0x00000240, 
	0x00000240, 0x00000240, 0x00000240, 0x00000260, 0x00000260, 0x00000260, 0x00000260, 0x00000280, 
	0x00000280, 0x00000280, 0x00000280, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 0x000002a0, 
	0x000002c0, 0x000002c0, 0x000002c0, 0x000002c0, 0x000002e0, 0x000002e0, 0x000002e0, 0x000002e0, 
	0x00000300, 0x00000300, 0x00000300, 0x00000300, 0x00000320, 0x00000320, 0x00000320, 0x00000320, 
	0x00000340, 0x00000340, 0x00000340, 0x00000340, 0x00000360, 0x00000360, 0x00000360, 0x00000360, 
	0x00000380, 0x00000380, 0x00000380, 0x00000380, 0x000003a0, 0x000003a0, 0x000003a0, 0x000003a0, 
	0x000003c0, 0x000003c0, 0x000003c0, 0x000003c0, 0x000003e0, 0x000003e0, 0x000003e0, 0x000003e0, 
	0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000420, 0x00000420, 0x00000420, 0x00000420, 
	0x00000440, 0x00000440, 0x00000440, 0x00000440, 0x00000460, 0x00000460, 0x00000460, 0x00000460, 
	0x00000480, 0x00000480, 0x00000480, 0x00000480, 0x000004a0, 0x000004a0, 0x000004a0, 0x000004a0, 
	0x000004c0, 0x000004c0, 0x000004c0, 0x000004c0, 0x000004e0, 0x000004e0, 0x000004e0, 0x000004e0, 
	0x00000500, 0x00000500, 0x00000500, 0x00000500, 0x00000520, 0x00000520, 0x00000520, 0x00000520, 
	0x00000520, 0x00000540, 0x00000540, 0x00000540, 0x00000540, 0x00000560, 0x00000560, 0x00000560, 
	0x00000560, 0x00000580, 0x00000580, 0x00000580, 0x00000580, 0x000005a0, 0x000005a0, 0x000005a0, 
	0x000005a0, 0x000005c0, 0x000005c0, 0x000005c0, 0x000005c0, 0x000005e0, 0x000005e0, 0x000005e0, 
	0x000005e0, 0x00000600, 0x00000600, 0x00000600, 0x00000600, 0x00000620, 0x00000620, 0x00000620, 
	0x00000620, 0x00000640, 0x00000640, 0x00000640, 0x00000640, 0x00000660, 0x00000660, 0x00000660, 
	0x00000660, 0x00000680, 0x00000680, 0x00000680, 0x00000680, 0x000006a0, 0x000006a0, 0x000006a0, 
	0x000006a0, 0x000006c0, 0x000006c0, 0x000006c0, 0x000006c0, 0x000006e0, 0x000006e0, 0x000006e0, 
	0x000006e0, 0x00000700, 0x00000700, 0x00000700, 0x00000700, 0x00000720, 0x00000720, 0x00000720, 
	0x00000720, 0x00000740, 0x00000740, 0x00000740, 0x00000740, 0x00000760, 0x00000760, 0x00000760, 
	0x00000760, 0x00000780, 0x00000780, 0x00000780, 0x00000780, 0x000007a0, 0x000007a0, 0x000007a0, 
	0x000007a0, 0x000007c0, 0x000007c0, 0x000007c0, 0x000007c0, 0x000007c0, 0x000007e0, 0x000007e0
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\cdjpeg.h ===
/*
 * cdjpeg.h
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains common declarations for the sample applications
 * cjpeg and djpeg.  It is NOT used by the core JPEG library.
 */

#define JPEG_CJPEG_DJPEG	/* define proper options in jconfig.h */
#define JPEG_INTERNAL_OPTIONS	/* cjpeg.c,djpeg.c need to see xxx_SUPPORTED */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"		/* get library error codes too */
#include "cderror.h"		/* get application-specific error codes */


/*
 * Object interface for cjpeg's source file decoding modules
 */

typedef struct cjpeg_source_struct * cjpeg_source_ptr;

struct cjpeg_source_struct {
  JMETHOD(void, start_input, (j_compress_ptr cinfo,
			      cjpeg_source_ptr sinfo));
  JMETHOD(JDIMENSION, get_pixel_rows, (j_compress_ptr cinfo,
				       cjpeg_source_ptr sinfo));
  JMETHOD(void, finish_input, (j_compress_ptr cinfo,
			       cjpeg_source_ptr sinfo));

  FILE *input_file;

  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * Object interface for djpeg's output file encoding modules
 */

typedef struct djpeg_dest_struct * djpeg_dest_ptr;

struct djpeg_dest_struct {
  /* start_output is called after jpeg_start_decompress finishes.
   * The color map will be ready at this time, if one is needed.
   */
  JMETHOD(void, start_output, (j_decompress_ptr cinfo,
			       djpeg_dest_ptr dinfo));
  /* Emit the specified number of pixel rows from the buffer. */
  JMETHOD(void, put_pixel_rows, (j_decompress_ptr cinfo,
				 djpeg_dest_ptr dinfo,
				 JDIMENSION rows_supplied));
  /* Finish up at the end of the image. */
  JMETHOD(void, finish_output, (j_decompress_ptr cinfo,
				djpeg_dest_ptr dinfo));

  /* Target file spec; filled in by djpeg.c after object is created. */
  FILE * output_file;

  /* Output pixel-row buffer.  Created by module init or start_output.
   * Width is cinfo->output_width * cinfo->output_components;
   * height is buffer_height.
   */
  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * cjpeg/djpeg may need to perform extra passes to convert to or from
 * the source/destination file format.  The JPEG library does not know
 * about these passes, but we'd like them to be counted by the progress
 * monitor.  We use an expanded progress monitor object to hold the
 * additional pass count.
 */

struct cdjpeg_progress_mgr {
  struct jpeg_progress_mgr pub;	/* fields known to JPEG library */
  int completed_extra_passes;	/* extra passes completed */
  int total_extra_passes;	/* total extra */
  /* last printed percentage stored here to avoid multiple printouts */
  int percent_done;
};

typedef struct cdjpeg_progress_mgr * cd_progress_ptr;


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_read_bmp		jIRdBMP
#define jinit_write_bmp		jIWrBMP
#define jinit_read_gif		jIRdGIF
#define jinit_write_gif		jIWrGIF
#define jinit_read_ppm		jIRdPPM
#define jinit_write_ppm		jIWrPPM
#define jinit_read_rle		jIRdRLE
#define jinit_write_rle		jIWrRLE
#define jinit_read_targa	jIRdTarga
#define jinit_write_targa	jIWrTarga
#define read_color_map		RdCMap
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Module selection routines for I/O modules. */

EXTERN cjpeg_source_ptr jinit_read_bmp JPP((j_compress_ptr cinfo));
EXTERN djpeg_dest_ptr jinit_write_bmp JPP((j_decompress_ptr cinfo,
					   boolean is_os2));
EXTERN cjpeg_source_ptr jinit_read_gif JPP((j_compress_ptr cinfo));
EXTERN djpeg_dest_ptr jinit_write_gif JPP((j_decompress_ptr cinfo));
EXTERN cjpeg_source_ptr jinit_read_ppm JPP((j_compress_ptr cinfo));
EXTERN djpeg_dest_ptr jinit_write_ppm JPP((j_decompress_ptr cinfo));
EXTERN cjpeg_source_ptr jinit_read_rle JPP((j_compress_ptr cinfo));
EXTERN djpeg_dest_ptr jinit_write_rle JPP((j_decompress_ptr cinfo));
EXTERN cjpeg_source_ptr jinit_read_targa JPP((j_compress_ptr cinfo));
EXTERN djpeg_dest_ptr jinit_write_targa JPP((j_decompress_ptr cinfo));

/* Other global routines */

EXTERN void read_color_map JPP((j_decompress_ptr cinfo, FILE * infile));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\cderror.h ===
/*
 * cderror.h
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the error and message codes for the cjpeg/djpeg
 * applications.  These strings are not needed as part of the JPEG library
 * proper.
 * Edit this file to add new codes, or to translate the message strings to
 * some other language.
 */


/* To define the enum list of message codes, include this file without
 * defining JMAKE_MSG_TABLE.  To create the message string table, include it
 * again with JMAKE_MSG_TABLE defined (this should be done in just one module).
 */

#ifdef JMAKE_MSG_TABLE

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define addon_message_table	cdMsgTable
#endif

const char * const addon_message_table[] = {

#define JMESSAGE(code,string)	string ,

#else /* not JMAKE_MSG_TABLE */

typedef enum {

#define JMESSAGE(code,string)	code ,

#endif /* JMAKE_MSG_TABLE */

JMESSAGE(JMSG_FIRSTADDONCODE=1000, NULL) /* Must be first entry! */

#ifdef BMP_SUPPORTED
JMESSAGE(JERR_BMP_BADCMAP, "Unsupported BMP colormap format")
JMESSAGE(JERR_BMP_BADDEPTH, "Only 8- and 24-bit BMP files are supported")
JMESSAGE(JERR_BMP_BADHEADER, "Invalid BMP file: bad header length")
JMESSAGE(JERR_BMP_BADPLANES, "Invalid BMP file: biPlanes not equal to 1")
JMESSAGE(JERR_BMP_COLORSPACE, "BMP output must be grayscale or RGB")
JMESSAGE(JERR_BMP_COMPRESSED, "Sorry, compressed BMPs not yet supported")
JMESSAGE(JERR_BMP_NOT, "Not a BMP file - does not start with BM")
JMESSAGE(JTRC_BMP, "%ux%u 24-bit BMP image")
JMESSAGE(JTRC_BMP_MAPPED, "%ux%u 8-bit colormapped BMP image")
JMESSAGE(JTRC_BMP_OS2, "%ux%u 24-bit OS2 BMP image")
JMESSAGE(JTRC_BMP_OS2_MAPPED, "%ux%u 8-bit colormapped OS2 BMP image")
#endif /* BMP_SUPPORTED */

#ifdef GIF_SUPPORTED
JMESSAGE(JERR_GIF_BUG, "GIF output got confused")
JMESSAGE(JERR_GIF_CODESIZE, "Bogus GIF codesize %d")
JMESSAGE(JERR_GIF_COLORSPACE, "GIF output must be grayscale or RGB")
JMESSAGE(JERR_GIF_IMAGENOTFOUND, "Too few images in GIF file")
JMESSAGE(JERR_GIF_NOT, "Not a GIF file")
JMESSAGE(JTRC_GIF, "%ux%ux%d GIF image")
JMESSAGE(JTRC_GIF_BADVERSION,
	 "Warning: unexpected GIF version number '%c%c%c'")
JMESSAGE(JTRC_GIF_EXTENSION, "Ignoring GIF extension block of type 0x%02x")
JMESSAGE(JTRC_GIF_NONSQUARE, "Caution: nonsquare pixels in input")
JMESSAGE(JWRN_GIF_BADDATA, "Corrupt data in GIF file")
JMESSAGE(JWRN_GIF_CHAR, "Bogus char 0x%02x in GIF file, ignoring")
JMESSAGE(JWRN_GIF_ENDCODE, "Premature end of GIF image")
JMESSAGE(JWRN_GIF_NOMOREDATA, "Ran out of GIF bits")
#endif /* GIF_SUPPORTED */

#ifdef PPM_SUPPORTED
JMESSAGE(JERR_PPM_COLORSPACE, "PPM output must be grayscale or RGB")
JMESSAGE(JERR_PPM_NONNUMERIC, "Nonnumeric data in PPM file")
JMESSAGE(JERR_PPM_NOT, "Not a PPM file")
JMESSAGE(JTRC_PGM, "%ux%u PGM image")
JMESSAGE(JTRC_PGM_TEXT, "%ux%u text PGM image")
JMESSAGE(JTRC_PPM, "%ux%u PPM image")
JMESSAGE(JTRC_PPM_TEXT, "%ux%u text PPM image")
#endif /* PPM_SUPPORTED */

#ifdef RLE_SUPPORTED
JMESSAGE(JERR_RLE_BADERROR, "Bogus error code from RLE library")
JMESSAGE(JERR_RLE_COLORSPACE, "RLE output must be grayscale or RGB")
JMESSAGE(JERR_RLE_DIMENSIONS, "Image dimensions (%ux%u) too large for RLE")
JMESSAGE(JERR_RLE_EMPTY, "Empty RLE file")
JMESSAGE(JERR_RLE_EOF, "Premature EOF in RLE header")
JMESSAGE(JERR_RLE_MEM, "Insufficient memory for RLE header")
JMESSAGE(JERR_RLE_NOT, "Not an RLE file")
JMESSAGE(JERR_RLE_TOOMANYCHANNELS, "Cannot handle %d output channels for RLE")
JMESSAGE(JERR_RLE_UNSUPPORTED, "Cannot handle this RLE setup")
JMESSAGE(JTRC_RLE, "%ux%u full-color RLE file")
JMESSAGE(JTRC_RLE_FULLMAP, "%ux%u full-color RLE file with map of length %d")
JMESSAGE(JTRC_RLE_GRAY, "%ux%u grayscale RLE file")
JMESSAGE(JTRC_RLE_MAPGRAY, "%ux%u grayscale RLE file with map of length %d")
JMESSAGE(JTRC_RLE_MAPPED, "%ux%u colormapped RLE file with map of length %d")
#endif /* RLE_SUPPORTED */

#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_TGA_BADCMAP, "Unsupported Targa colormap format")
JMESSAGE(JERR_TGA_BADPARMS, "Invalid or unsupported Targa file")
JMESSAGE(JERR_TGA_COLORSPACE, "Targa output must be grayscale or RGB")
JMESSAGE(JTRC_TGA, "%ux%u RGB Targa image")
JMESSAGE(JTRC_TGA_GRAY, "%ux%u grayscale Targa image")
JMESSAGE(JTRC_TGA_MAPPED, "%ux%u colormapped Targa image")
#else
JMESSAGE(JERR_TGA_NOTCOMP, "Targa support was not compiled")
#endif /* TARGA_SUPPORTED */

JMESSAGE(JERR_BAD_CMAP_FILE,
	 "Color map file is invalid or of unsupported format")
JMESSAGE(JERR_TOO_MANY_COLORS,
	 "Output file format cannot handle %d colormap entries")
JMESSAGE(JERR_UNGETC_FAILED, "ungetc failed")
#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_UNKNOWN_FORMAT,
	 "Unrecognized input file format --- perhaps you need -targa")
#else
JMESSAGE(JERR_UNKNOWN_FORMAT, "Unrecognized input file format")
#endif
JMESSAGE(JERR_UNSUPPORTED_FORMAT, "Unsupported output file format")

#ifdef JMAKE_MSG_TABLE

  NULL
};

#else /* not JMAKE_MSG_TABLE */

  JMSG_LASTADDONCODE
} ADDON_MESSAGE_CODE;

#endif /* JMAKE_MSG_TABLE */

#undef JMESSAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\encode\mjpgenc.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _MJPEGENC_H_
#define _MJPEGENC_H_

#include "..\pmjpeg32\jpeglib.h"
#include "..\pmjpeg32\MJpegLib.h"


extern const AMOVIESETUP_FILTER sudMJPGEnc;


#define AM_MJPEG_DEFAULTKEYFRAMERATE 20	    //PMatrix codec does not support ICM_GetDefaultKeyFrameRate

class CMJPGEnc : 
	public CTransformFilter
	, public CPersistStream

{

public:

    CMJPGEnc(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMJPGEnc();

    DECLARE_IUNKNOWN

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(
                const CMediaType* mtIn,
                const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts
    // and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Overridden to make a CMJPGOutputPin
    CBasePin * GetPin(int n);

    // IPersistPropertyBag methods
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);
    STDMETHODIMP InitNew();

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();
    
    //for output pin 
    DWORD GetICInfo (ICINFO *picinfo);

private:
    PINSTINFO m_phInstance;		// current codec

    // force CheckTransform to cache any Ins it opens... we'll need it
    BOOL m_fCacheIns;

    // are we inside an ICCompress call?
    BOOL m_fInICCompress;

    // is there a dialog box up that should prevent start streaming?
    BOOL m_fDialogUp;

    // have we called ICDecompressBegin ?
    BOOL m_fStreaming;

    // how long since last keyframe
    int m_nKeyCount;

    // the frame number we're compressing
    LONG m_lFrameCount;

    // the previous decompressed frame for temporal compressors
    LPVOID m_lpBitsPrev;

    // the format it decompresses back to
    LPBITMAPINFOHEADER m_lpbiPrev;

    // the compression options being used
    COMPVARS m_compvars;

    // how big to make each frame, based on data rate and fps
    DWORD m_dwSizePerFrame;

    // Somebody called ::SetFormat and wants this media type used
    BOOL m_fOfferSetFormatOnly;
    CMediaType m_cmt;

    // send this to the codec via ICSetState when we open it
    LPBYTE m_lpState;
    int    m_cbState;

public:


    friend class CMJPGOutputPin;
};

class CMJPGOutputPin :	public CTransformOutputPin, 
			public IAMStreamConfig,
			public IAMVideoCompression
{

public:

    CMJPGOutputPin(
        TCHAR *pObjectName,
        CMJPGEnc *pCapture,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CMJPGOutputPin();

    DECLARE_IUNKNOWN

    // override to expose IAMStreamConfig, etc.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pVSCC);

    /* IAMVideoCompression methods */
    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate);
    STDMETHODIMP get_KeyFrameRate(long FAR* pKeyFrameRate);
    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP get_PFramesPerKeyFrame(long FAR* pPFramesPerKeyFrame)
			{return E_NOTIMPL;};
    STDMETHODIMP put_Quality(double Quality);
    STDMETHODIMP get_Quality(double FAR* pQuality);
    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;};
    STDMETHODIMP get_WindowSize(DWORDLONG FAR* pWindowSize);
    STDMETHODIMP OverrideKeyFrame(long FrameNumber);
    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size);
    STDMETHODIMP GetInfo(LPWSTR pstrVersion,
			int *pcbVersion,
			LPWSTR pstrDescription,
			int *pcbDescription,
			long FAR* pDefaultKeyFrameRate,
			long FAR* pDefaultPFramesPerKey,
			double FAR* pDefaultQuality,
			long FAR* pCapabilities);
 
    HRESULT Reconnect();

private:

    /*  Controlling filter */
    CMJPGEnc *m_pFilter;

};


#endif  //#ifndef _MJPEGENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\draw.c ===
/*
 * Software MJPEG Codec
 *
 * Copyright (c) Paradigm Matrix 1993
 * All Rights Reserved
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
// #include <compddk.h>

#include "mjpeg.h"


/*
 * position and enable the overlay at pinst->rcDest (screen co-ords)
 */
DWORD
PlaceOverlay(PINSTINFO pinst)
{
#ifdef DRAW_SUPPORT

    DWORD mode;
    OVERLAY_RECTS or;
    RECT rc;
    COLORREF cref;
    RECT rcClient;
    HDC hdc;
    HBRUSH hbrOld;

    /*
     * check we have a device that supports overlay
     */
    if((pinst->vh == NULL) ||
       ((mode = VC_GetOverlayMode(pinst->vh)) == 0)) {
	   return((DWORD) ICERR_ERROR);
    }




    /*
     * set the destination rect. This is the screen co-ords where
     * the video should appear - and so is the overlay rect.
     */
    or.ulCount = 1;
    or.rcRects[0] = pinst->rcDest;

    if (!VC_SetOverlayRect(pinst->vh, &or)) {
	return( (DWORD) ICERR_ERROR);
    }

    /*
     * set the overlay offset. this tells the board which pixel
     * to place at the top-left of the overlay window. For us, this
     * should always be pixel(0,0) of the frame buffer, so that whatever
     * we draw to the framebuffer can go straight to the top left, and will
     * appear correctly in the top left of the window
     */
    SetRect(&rc, 0, 0, pinst->rcDest.right - pinst->rcDest.left,
		    	pinst->rcDest.bottom - pinst->rcDest.top);
    if (!VC_SetOverlayOffset(pinst->vh, &rc)) {
	return( (DWORD) ICERR_ERROR);
    }



    /* init the overlay colour and brush if we haven't yet */

    if (pinst->hKeyBrush == NULL) {


	/*
	 * this version assumes a key-colour and simple rectangle
	 * combination
	 */
	ASSERT(mode & VCO_KEYCOLOUR);
	ASSERT(mode & VCO_SIMPLE_RECT);

	if (mode & VCO_KEYCOLOUR_FIXED) {

	    /* we need to get the key colour from the driver
	     * check first if we are getting rgb or palette index
	     */
	    if (mode & VCO_KEYCOLOUR_RGB) {
		cref = VC_GetKeyColour(pinst->vh);
	    } else {
		cref = PALETTEINDEX(VC_GetKeyColour(pinst->vh));
	    }
	} else {
	    /* we can set it ourselves. Check whether we should be setting
	     * an RGB or a palette index
	     */
	    if (mode & VCO_KEYCOLOUR_RGB) {
		RGBQUAD rgbq;

		rgbq.rgbBlue = 0x7f;
		rgbq.rgbGreen = 0;
		rgbq.rgbRed = 0x7f;
		VC_SetKeyColourRGB(pinst->vh, &rgbq);

		cref = RGB(0x7f, 0, 0x7f);

    	    } else {

		VC_SetKeyColourPalIdx(pinst->vh, 5);
		cref = PALETTEINDEX(5);
	    }
	}

	pinst->hKeyBrush = CreateSolidBrush(cref);
    }


    /* convert the screen co-ords for the overlay location into
     * client window co-ords
     */
    rcClient = pinst->rcDest;
    MapWindowPoints(HWND_DESKTOP, pinst->hwnd, (PPOINT) &rcClient, 2);


    /* paint the key colour over all the overlay area */
    hdc = GetDC(pinst->hwnd);
    hbrOld = SelectObject(hdc, pinst->hKeyBrush);
    PatBlt(hdc, rcClient.left, rcClient.top,
	        rcClient.right - rcClient.left,
		rcClient.bottom - rcClient.top,
		PATCOPY);
    SelectObject(hdc, hbrOld);
    ReleaseDC(pinst->hwnd, hdc);

    /* switch on overlay */
    VC_Overlay(pinst->vh, TRUE);


    return(ICERR_OK);
#else
	return((DWORD) ICERR_UNSUPPORTED); // for now, only decompress
#endif

}


/*
 * check whether we can do this drawing or not
 */
DWORD
DrawQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

#ifdef DRAW_SUPPORT

    VCUSER_HANDLE vh;

	return((DWORD) ICERR_UNSUPPORTED); // for now, only decompress
    
    /* check that the input is our format */
    if ((lpbiIn->biCompression != FOURCC_MJPEG) ||
	(lpbiIn->biBitCount != 24)) {
	    return( (DWORD) ICERR_UNSUPPORTED);
    }

    /*
     * check 1:1 - we don't stretch (if we are given a output format)
     */
    if (lpbiOut != NULL) {
	if ((lpbiIn->biWidth != lpbiOut->biWidth) ||
	    (lpbiIn->biHeight != lpbiOut->biHeight)) {
		return((DWORD) ICERR_UNSUPPORTED);
	}
    }


    /*
     * check we can open the device (if we haven't already done this)
     */
    if (pinst->vh == NULL) {

	int i;

	/* for now, since there is no easy way of telling how
	 * many devices exist (and they may not be contiguous - and
	 * we cannot distinguish failure to exist from being busy),
	 * we will try all of the first 16 devices to see if any
	 * are available for overlaying
	 */
	for (i = 0; i < 16; i++) {
	    if ((vh = VC_OpenDevice(NULL, i))  != NULL) {
		
		/* check this device can overlay */
		if ((VC_GetOverlayMode(vh) & VCO_CAN_DRAW) != 0) {

		    /* found a good device */
		    break;
		}

		// no draw support - close and try next
		VC_CloseDevice(vh);
		vh = NULL;
	    }
	}
	if (vh == NULL) {
	    // we failed to find a device
	    return((DWORD) ICERR_UNSUPPORTED);
	}

	/* that's it - we can do it */
	VC_CloseDevice(vh);
    }

    return(ICERR_OK);
#else
	return((DWORD) ICERR_UNSUPPORTED); // for now, only decompress
#endif

}


/*
 * initiate decompress&draw
 *
 * check that the input and output formats and sizes are valid, and
 * that we can access the hardware.
 *
 * enable the overlay in the correct position
 *
 * Note that draw-begin and draw-end are not necessarily issued one-for-one,
 * so the device may well still be open at this call.
 */
DWORD
DrawBegin(
    PINSTINFO pinst,
    ICDRAWBEGIN * icinfo,
    DWORD dwSize
)
{
#ifdef DRAW_SUPPORT


    /*
     * check that this is our format
     */
    if ((icinfo->lpbi->biCompression != FOURCC_MJPEG) ||
	(icinfo->lpbi->biBitCount != 16)) {
	    return((DWORD) ICERR_UNSUPPORTED);
    }


    if (icinfo->dwFlags & ICDRAW_FULLSCREEN) {
	return((DWORD) ICERR_UNSUPPORTED);
    }

    /*
     * check 1:1 (we don't stretch)
     */
    if ((icinfo->dxDst != icinfo->dxSrc) ||
	(icinfo->dyDst != icinfo->dySrc)) {
	    return((DWORD) ICERR_UNSUPPORTED);
    }


    /*
     * check we can open the device - if we haven't already done this.
     */

    if (pinst->vh == NULL) {

	int i;

	/* for now, since there is no easy way of telling how
	 * many devices exist (and they may not be contiguous - and
	 * we cannot distinguish failure to exist from being busy),
	 * we will try all of the first 16 devices to see if any
	 * are available for overlaying
	 */
	for (i = 0; i < 16; i++) {
	    if ((pinst->vh = VC_OpenDevice(NULL, i))  != NULL) {
		
		/* check this device can overlay */
		if ((VC_GetOverlayMode(pinst->vh) & VCO_CAN_DRAW) != 0) {

		    /* found a good device */
		    break;
		}

		// no draw support - close and try next
		VC_CloseDevice(pinst->vh);
		pinst->vh = NULL;
	    }
	}

	if (pinst->vh == NULL) {
	    // we failed to find a device
	    return((DWORD) ICERR_UNSUPPORTED);
	}

	/* if this was a query - that's it. remember to close the device*/
	if (icinfo->dwFlags & ICDRAW_QUERY) {
	    VC_CloseDevice(pinst->vh);
	    pinst->vh = NULL;
    	}
    }



    /*
     * we have checked all we need to check for a query. Don't close
     * the device though, unless we just opened it for this query.
     */
    if (icinfo->dwFlags & ICDRAW_QUERY) {
	return(ICERR_OK);
    }


    /*
     * remember the bits we will need later
     */

    /*
     * client window to draw into.
     *
     * Note that we also need a DC to paint the key-colour with. We should
     * not use the DC passed with this message, as it will not remain valid
     * (eg after a draw-end, we will still need a dc in processing draw-window).
     * One alternative is to store the dc passed here, and to replace it with
     * the dc passed with a draw-realize message. A cleaner solution (adopted
     * here) is to get our own dc each time we need it.
     */
    pinst->hwnd = icinfo->hwnd;

    /*
     * this is the portion of the original dib that we are to draw
     */
    SetRect(&pinst->rcSource,
	    	icinfo->xSrc,
		icinfo->ySrc,
		icinfo->dxSrc + icinfo->xSrc,
		icinfo->dySrc + icinfo->ySrc);

    /*
     * this is the location (in window co-ords) within the client window
     * where the video is to appear.
     */
    SetRect(&pinst->rcDest,
	    	icinfo->xDst,
		icinfo->yDst,
		icinfo->dxDst + icinfo->xDst,
		icinfo->dyDst + icinfo->yDst);
    /*
     * we need to convert the rcDest from window-based to screen-based before
     * writing to the hardware.
     */
    MapWindowPoints(pinst->hwnd, HWND_DESKTOP, (PPOINT) &pinst->rcDest, 2);


    /*
     * enable and position the overlay
     */
    return(PlaceOverlay(pinst));
#else
	return((DWORD)ICERR_UNSUPPORTED);
#endif


}


/*
 * decompress and render a single frame. Note that if we are pre-buffering,
 * (which we don't in this driver), we should not start rendering frames
 * until the draw-start message. As we don't pre-buffer (we don't respond
 * to the ICM_GETBUFFERSWANTED message), we can render as soon as we
 * get the draw request.
 */
DWORD
Draw(
    PINSTINFO pinst,
    ICDRAW * icinfo,
    DWORD dwSize
)
{
#ifdef DRAW_SUPPORT

    DRAWBUFFER Draw;
    LPBITMAPINFOHEADER lpbi;

    /*
     * do we have anything to do ? As we don't do inter-frame compression or
     * any form of pre-buffering, we can do nothing for any of these
     * occasions
     */
    if (icinfo->dwFlags & (ICDRAW_HURRYUP | ICDRAW_PREROLL | ICDRAW_NULLFRAME)) {
	return(ICERR_OK);
    }

    /*
     * UPDATE means draw an existing frame, rather than a new frame.
     * Sometimes we will not get data - in this case it is already in
     * the hardware and we need do nothing (a separate draw-window message
     * will have been sent to sync the overlay region).
     *
     * If, however, there is data, then we should draw it. Update in this
     * case means that the data is not a delta on a previous frame. However,
     * we may never have seen this frame before, so it may not be in the
     * frame buffer.
     */
    if ((icinfo->dwFlags & ICDRAW_UPDATE) &&
	    ((icinfo->cbData == 0) || (icinfo->lpData == NULL))) {
	return(ICERR_OK);
    }

    Draw.lpData = icinfo->lpData;
    Draw.rcSource = pinst->rcSource;
    Draw.Format = FOURCC_MJPEG;
    lpbi = (LPBITMAPINFOHEADER) icinfo->lpFormat;
    Draw.ulWidth = lpbi->biWidth;
    Draw.ulHeight = lpbi->biHeight;

    /* check that a draw-begin has happened */
    if (pinst->vh == NULL) {
	return((DWORD) ICERR_ERROR);
    }

    if (!VC_DrawFrame(pinst->vh, &Draw)) {
	return((DWORD) ICERR_ERROR);
    }

    return(ICERR_OK);
#else
	return((DWORD) ICERR_UNSUPPORTED);
#endif

}

/*
 * stop rendering, and disable overlay. In fact, this function is not
 * called in response to the ICM_DRAW_END message as this comes too early -
 * it is done in response to device close. see drvproc.c for draw message
 * handling comments.
 */
DWORD
DrawEnd(PINSTINFO pinst)
{
#ifdef DRAW_SUPPORT

    if (pinst->vh) {

	dprintf2(("close yuv hardware"));

	VC_Overlay(pinst->vh, FALSE);
	VC_CloseDevice(pinst->vh);
	pinst->vh = NULL;
    }

    if (pinst->hKeyBrush) {
	DeleteObject(pinst->hKeyBrush);
	pinst->hKeyBrush = NULL;
    }

    return(ICERR_OK);
#else
	return((DWORD)ICERR_UNSUPPORTED);
#endif
}

/*
 * window has moved.
 * we are given the new dest-rect in screen co-ords - but possibly only the
 * vis-region or z-ordering have changed.
 */
DWORD
DrawWindow(PINSTINFO pinst, PRECT prc)
{
   pinst->rcDest = *prc;

   return(PlaceOverlay(pinst));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\jbufsrc.c ===
/*
 * jbufsrc.c
 *
 * This file contains decompression data source routines for the case of
 * reading JPEG data from a buffer.  While these routines
 * are sufficient for most applications, some will want to use a different
 * source manager.
 * Copyright (c) 1994 Paradigm Matrix.
 * All Rights Reserved.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"



typedef struct {
  struct jpeg_source_mgr pub;	/* public fields */

  JOCTET * buffer;		/* start of buffer */
  long bufferSize;
  boolean start_of_buffer;	/* have we gotten any data yet? */
} my_source_mgr;

typedef my_source_mgr * my_src_ptr;

JOCTET eoi_filler[4] = {0xFF, JPEG_EOI, 0xFF, JPEG_EOI}; // in case we run out of data

/*
 * Initialize source --- called by jpeg_read_header
 * before any data is actually read.
 */

METHODDEF void
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* We reset the empty-input-file flag for each image,
   * but we don't clear the input buffer.
   * This is correct behavior for reading a series of images from one source.
   */
  src->start_of_buffer = TRUE;
}


/*
 * Fill the input buffer --- called whenever buffer is emptied.
 *
 * In typical applications, this should read fresh data into the buffer
 * (ignoring the current state of next_input_byte & bytes_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been reloaded.  It is not necessary to
 * fill the buffer entirely, only to obtain at least one more byte.
 *
 * There is no such thing as an EOF return.  If the end of the file has been
 * reached, the routine has a choice of ERREXIT() or inserting fake data into
 * the buffer.  In most cases, generating a warning message and inserting a
 * fake EOI marker is the best course of action --- this will allow the
 * decompressor to output however much of the image is there.  However,
 * the resulting error message is misleading if the real problem is an empty
 * input file, so we handle that case specially.
 *
 * In applications that need to be able to suspend compression due to input
 * not being available yet, a FALSE return indicates that no more data can be
 * obtained right now, but more may be forthcoming later.  In this situation,
 * the decompressor will return to its caller (with an indication of the
 * number of scanlines it has read, if any).  The application should resume
 * decompression after it has loaded more data into the input buffer.  Note
 * that there are substantial restrictions on the use of suspension --- see
 * the documentation.
 *
 * When suspending, the decompressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_input_byte & bytes_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point must be rescanned after resumption, so move it to
 * the front of the buffer rather than discarding it.
 */

METHODDEF boolean
fill_input_buffer (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  if (src->start_of_buffer) {
    if (src->bufferSize == 0) {
	  ERREXIT(cinfo, JERR_INPUT_EMPTY);
	  }
	else {
      src->pub.next_input_byte = src->buffer;
      src->pub.bytes_in_buffer = src->bufferSize;
      src->start_of_buffer = FALSE;
	  }
	}
  else {
    src->pub.next_input_byte = eoi_filler;
    src->pub.bytes_in_buffer = sizeof(eoi_filler);
	}
     
  return TRUE;
}


/*
 * Skip data --- used to skip over a potentially large amount of
 * uninteresting data (such as an APPn marker).
 *
 * Writers of suspendable-input applications must note that skip_input_data
 * is not granted the right to give a suspension return.  If the skip extends
 * beyond the data currently in the buffer, the buffer can be marked empty so
 * that the next read will cause a fill_input_buffer call that can suspend.
 * Arranging for additional bytes to be discarded before reloading the input
 * buffer is the application writer's problem.
 */

METHODDEF void
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
    while (num_bytes > (long) src->pub.bytes_in_buffer) {
      num_bytes -= (long) src->pub.bytes_in_buffer;
      (void) fill_input_buffer(cinfo);
    }
    src->pub.next_input_byte += (size_t) num_bytes;
    src->pub.bytes_in_buffer -= (size_t) num_bytes;
  }
}


/*
 * An additional method that can be provided by data source modules is the
 * resync_to_restart method for error recovery in the presence of RST markers.
 * For the moment, this source module just uses the default resync method
 * provided by the JPEG library.  That method assumes that no backtracking
 * is possible.
 */


/*
 * Terminate source --- called by jpeg_finish_decompress
 * after all data has been read.  Often a no-op.
 *
 * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
 * application must deal with any cleanup that should happen even
 * for error exit.
 */

METHODDEF void
term_source (j_decompress_ptr cinfo)
{
  /* no work necessary here */
}




/*
 * Prepare for input from a memory buffer.
 */

GLOBAL void
jpeg_decompress_src (j_decompress_ptr cinfo, JOCTET * srcData, long srcSize)
{
  my_src_ptr src;

  /* The source object and input buffer are made permanent so that a series
   * of JPEG images can be read from the same file by calling jpeg_stdio_src
   * only before the first one.  (If we discarded the buffer at the end of
   * one image, we'd likely lose the start of the next one.)
   * This makes it unsafe to use this manager and a different source
   * manager serially with the same JPEG object.  Caveat programmer.
   */
  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  SIZEOF(my_source_mgr));
  }

  src = (my_src_ptr) cinfo->src;
  src->buffer = srcData;
  src->bufferSize = srcSize;
  src->pub.init_source = init_source;
  src->pub.fill_input_buffer = fill_input_buffer;
  src->pub.skip_input_data = skip_input_data;
  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
  src->pub.term_source = term_source;
  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
  src->pub.next_input_byte = NULL; /* until buffer loaded */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\jbufdst.c ===
/*
 * jdatadst.c
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains compression data destination routines for the case of
 * emitting JPEG data to a file (or any stdio stream).  While these routines
 * are sufficient for most applications, some will want to use a different
 * destination manager.
 * IMPORTANT: we assume that fwrite() will correctly transcribe an array of
 * JOCTETs into 8-bit-wide elements on external storage.  If char is wider
 * than 8 bits on your machine, you may need to do some tweaking.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"


/* Expanded data destination object for buffer output */

typedef struct {
  struct jpeg_destination_mgr pub; /* public fields */

  JOCTET * buffer;		/* start of buffer */
  long bufferSize;
  int * outputSizePtr;
} my_destination_mgr;

typedef my_destination_mgr * my_dest_ptr;

#define OUTPUT_BUF_SIZE  4096	/* choose an efficiently fwrite'able size */


/*
 * Initialize destination --- called by jpeg_start_compress
 * before any data is actually written.
 */

METHODDEF void
init_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

}


/*
 * Empty the output buffer --- called whenever buffer fills up.
 *
 * In typical applications, this should write the entire output buffer
 * (ignoring the current state of next_output_byte & free_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been dumped.
 *
 * In applications that need to be able to suspend compression due to output
 * overrun, a FALSE return indicates that the buffer cannot be emptied now.
 * In this situation, the compressor will return to its caller (possibly with
 * an indication that it has not accepted all the supplied scanlines).  The
 * application should resume compression after it has made more room in the
 * output buffer.  Note that there are substantial restrictions on the use of
 * suspension --- see the documentation.
 *
 * When suspending, the compressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_output_byte & free_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point will be regenerated after resumption, so do not
 * write it out when emptying the buffer externally.
 */

METHODDEF boolean
empty_output_buffer (j_compress_ptr cinfo)
{
 
 
  return TRUE;
}


/*
 * Terminate destination --- called by jpeg_finish_compress
 * after all data has been written.  Usually needs to flush buffer.
 *
 * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
 * application must deal with any cleanup that should happen even
 * for error exit.
 */

METHODDEF void
term_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
  
  *(dest->outputSizePtr) = dest->bufferSize - dest->pub.free_in_buffer;

}


/*
 * Prepare for output to a stdio stream.
 * The caller must have already opened the stream, and is responsible
 * for closing it after finishing compression.
 */

GLOBAL void
jpeg_compress_dest (j_compress_ptr cinfo, JOCTET * buf, long * sizePtr)
{
  my_dest_ptr dest;

  /* The destination object is made permanent so that multiple JPEG images
   * can be written to the same file without re-executing jpeg_stdio_dest.
   * This makes it dangerous to use this manager and a different destination
   * manager serially with the same JPEG object, because their private object
   * sizes may be different.  Caveat programmer.
   */
  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
    cinfo->dest = (struct jpeg_destination_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  SIZEOF(my_destination_mgr));
  }

  dest = (my_dest_ptr) cinfo->dest;
  dest->buffer = buf;
  dest->bufferSize = *sizePtr;
  dest->outputSizePtr = sizePtr;
  dest->pub.next_output_byte = buf;
  dest->pub.free_in_buffer = *sizePtr;

  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\jccolor.c ===
/*
 * jccolor.c
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains input colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_converter pub; /* public fields */

  /* Private state for RGB->YCC conversion */
  INT32 * rgb_ycc_tab;		/* => table for RGB to YCbCr conversion */
} my_color_converter;

typedef my_color_converter * my_cconvert_ptr;


/**************** RGB -> YCbCr conversion: most common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *	Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
 *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + MAXJSAMPLE/2
 *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + MAXJSAMPLE/2
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times R,G,B for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The MAXJSAMPLE/2 offsets and the rounding fudge-factor of 0.5 are included
 * in the tables to save adding them separately in the inner loop.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/* We allocate one big table and divide it up into eight parts, instead of
 * doing eight alloc_small requests.  This lets us use a single table base
 * address, which can be held in a register in the inner loops on many
 * machines (more than can hold all eight addresses, anyway).
 */

#define R_Y_OFF		0			/* offset to R => Y section */
#define G_Y_OFF		(1*(MAXJSAMPLE+1))	/* offset to G => Y section */
#define B_Y_OFF		(2*(MAXJSAMPLE+1))	/* etc. */
#define R_CB_OFF	(3*(MAXJSAMPLE+1))
#define G_CB_OFF	(4*(MAXJSAMPLE+1))
#define B_CB_OFF	(5*(MAXJSAMPLE+1))
#define R_CR_OFF	B_CB_OFF		/* B=>Cb, R=>Cr are the same */
#define G_CR_OFF	(6*(MAXJSAMPLE+1))
#define B_CR_OFF	(7*(MAXJSAMPLE+1))
#define TABLE_SIZE	(8*(MAXJSAMPLE+1))


/*
 * Initialize for RGB->YCC colorspace conversion.
 */

METHODDEF void
rgb_ycc_start (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  INT32 * rgb_ycc_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
    rgb_ycc_tab[i+R_Y_OFF] = FIX(0.29900) * i;
    rgb_ycc_tab[i+G_Y_OFF] = FIX(0.58700) * i;
    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.11400) * i     + ONE_HALF;
    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.16874)) * i;
    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.33126)) * i;
    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + ONE_HALF*(MAXJSAMPLE+1);
/*  B=>Cb and R=>Cr tables are the same
    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + ONE_HALF*(MAXJSAMPLE+1);
*/
    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.41869)) * i;
    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.08131)) * i;
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 *
 * Note that we change from the application's interleaved-pixel format
 * to our internal noninterleaved, one-plane-per-component format.
 * The input buffer is therefore three times as wide as the output buffer.
 *
 * A starting row offset is provided only for the output buffer.  The caller
 * can easily adjust the passed input_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF void
rgb_ycc_convert (j_compress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		 JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;
  register UINT32 pixel;
  register int pixel_size;			/* number of bytes per pixel, 2,3,4 */
  register UINT32 pixel_mask;			/* for clearing empty byte of 32-bit pixels */
  register UINT32 red_pixel_mask;
  register int red_pixel_shift;
  register UINT32 green_pixel_mask;
  register int green_pixel_shift;
  register UINT32 blue_pixel_mask;
  register int blue_pixel_shift;

  
  /* put these someplace faster */
  pixel_size = cinfo->pixel_size;
  pixel_mask = cinfo->pixel_mask;
  red_pixel_mask = cinfo->red_pixel_mask;
  red_pixel_shift = cinfo->red_pixel_shift;
  green_pixel_mask = cinfo->green_pixel_mask;
  green_pixel_shift = cinfo->green_pixel_shift;
  blue_pixel_mask = cinfo->blue_pixel_mask;
  blue_pixel_shift = cinfo->blue_pixel_shift;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {

	  pixel = *((UINT32 *)inptr); /* get the pixel */
	  inptr += pixel_size;

      if (red_pixel_shift >= 0)	  
        r = ((pixel >> red_pixel_shift) & red_pixel_mask);
	  else
        r = ((pixel << (-red_pixel_shift)) & red_pixel_mask);
	  
      if (green_pixel_shift >= 0)	  
        g = ((pixel >> green_pixel_shift) & green_pixel_mask);
	  else
        g = ((pixel << (-green_pixel_shift)) & green_pixel_mask);
	  
      if (blue_pixel_shift >= 0)	  
        b = ((pixel >> blue_pixel_shift) & blue_pixel_mask);
	  else
        b = ((pixel << (-blue_pixel_shift)) & blue_pixel_mask);
	  
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/**************** Cases other than RGB -> YCbCr **************/


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles RGB->grayscale conversion, which is the same
 * as the RGB->Y portion of RGB->YCbCr.
 * We assume rgb_ycc_start has been called (we only use the Y tables).
 */

METHODDEF void
rgb_gray_convert (j_compress_ptr cinfo,
		  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		  JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[RGB_RED]);
      g = GETJSAMPLE(inptr[RGB_GREEN]);
      b = GETJSAMPLE(inptr[RGB_BLUE]);
      inptr += RGB_PIXELSIZE;
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles Adobe-style CMYK->YCCK conversion,
 * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume rgb_ycc_start has been called.
 */

METHODDEF void
cmyk_ycck_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    outptr3 = output_buf[3][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
      /* K passes through as-is */
      outptr3[col] = inptr[3];	/* don't need GETJSAMPLE here */
      inptr += 4;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles grayscale output with no conversion.
 * The source can be either plain grayscale or YCbCr (since Y == gray).
 */

METHODDEF void
grayscale_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;
  int instride = cinfo->input_components;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      outptr[col] = inptr[0];	/* don't need GETJSAMPLE() here */
      inptr += instride;
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles multi-component colorspaces without conversion.
 * We assume input_components == num_components.
 */

METHODDEF void
null_convert (j_compress_ptr cinfo,
	      JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
	      JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  register int ci;
  int nc = cinfo->num_components;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    /* It seems fastest to make a separate pass for each component. */
    for (ci = 0; ci < nc; ci++) {
      inptr = *input_buf;
      outptr = output_buf[ci][output_row];
      for (col = 0; col < num_cols; col++) {
	outptr[col] = inptr[ci]; /* don't need GETJSAMPLE() here */
	inptr += nc;
      }
    }
    input_buf++;
    output_row++;
  }
}


/*
 * Empty method for start_pass.
 */

METHODDEF void
null_method (j_compress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for input colorspace conversion.
 */

GLOBAL void
jinit_color_converter (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_converter));
  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
  /* set start_pass to null method until we find out differently */
  cconvert->pub.start_pass = null_method;

  /* Make sure input_components agrees with in_color_space */
  switch (cinfo->in_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->input_components != 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_RGB:
#if RGB_PIXELSIZE != 3
    if (cinfo->input_components != RGB_PIXELSIZE)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
#endif /* else share code with YCbCr */

  case JCS_YCbCr:
    if (cinfo->input_components != 3)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->input_components != 4)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->input_components < 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
  }

  /* Check num_components, set conversion method based on requested space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_GRAYSCALE)
      cconvert->pub.color_convert = grayscale_convert;
    else if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_gray_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = grayscale_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_RGB:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_ycc_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_CMYK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = cmyk_ycck_convert;
    } else if (cinfo->in_color_space == JCS_YCCK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  default:			/* allow null conversion of JCS_UNKNOWN */
    if (cinfo->jpeg_color_space != cinfo->in_color_space ||
	cinfo->num_components != cinfo->input_components)
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    cconvert->pub.color_convert = null_convert;
    break;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\drvproc.c ===
/* Copyright (c) 1994 Paradigm Matrix.
   All Rights Reserved.
*/

#include <windows.h>
#include <mmsystem.h>
#include "mjpeg.h"
#include <stdio.h>

/////////////////////////////////////////////////////////////////////////////
// added to assist unicode builds -anuragsh
const TCHAR *szSubKey_SoftwareParadigmMatrixSoftwareMJPEGCodec =
    TEXT("Software\\Paradigm Matrix\\Software M-JPEG Codec");

const TCHAR *szValue_Enabled =
    TEXT("Enabled");
//
/////////////////////////////////////////////////////////////////////////////

HMODULE ghModule;
DWORD driverEnabled = TRUE;
tErrorMessageEntry *errorMessages = NULL;

extern void ClearErrorMessages();

// for testing
volatile ICDECOMPRESSEX *decompressEx;

// not needed for filter
#if 0

/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

LRESULT  DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)(UINT)dwDriverID; 	
	
	// __asm int 3

// #ifdef zzz
	if (dwDriverID == 0) {
		if (!((uiMessage == DRV_LOAD) ||
			  (uiMessage == DRV_FREE) ||
			  (uiMessage == DRV_OPEN) ||
			  (uiMessage == DRV_DISABLE) ||
			  (uiMessage == DRV_ENABLE) ||
			  (uiMessage == DRV_INSTALL) ||
			  (uiMessage == DRV_REMOVE)))
			return ICERR_UNSUPPORTED;
	}
// #endif

    switch (uiMessage)
    {
	case DRV_LOAD:
	    return (LRESULT) 1L;

	case DRV_FREE:
	    return (LRESULT)1L;

    case DRV_OPEN:
	    // if being opened with no open struct, then return a non-zero
	    // value without actually opening
	    if (lParam2 == 0L)
                return 0xFFFF0000;

	    return (LRESULT) Open((ICOPEN FAR *) lParam2);

	case DRV_CLOSE:
#ifdef WIN32
	    if (dwDriverID != 0xFFFF0000)
#else
	    if (pi)
#endif
		Close(pi);

	    return (LRESULT)1L;

	/*********************************************************************

	    state messages

	*********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return DRV_OK; // (LRESULT)0L;

        case DRV_CONFIGURE:
			Configure(pi, (HWND)lParam1);
            return DRV_OK;

        case ICM_CONFIGURE:
            //
            //  return ICERR_OK if you will do a configure box, error otherwise
            //
            if (lParam1 == -1)
		return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return Configure(pi, (HWND)lParam1);

        case ICM_ABOUT:
            //
            //  return ICERR_OK if you will do a about box, error otherwise
            //
            if (lParam1 == -1)
		return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return About(pi, (HWND)lParam1);

	case ICM_GETSTATE:
	    return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_SETSTATE:
	    return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_GETINFO:
            return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

        case ICM_GETDEFAULTQUALITY:
            if (lParam1)
            {
                *((LPDWORD)lParam1) = 7500;
                return ICERR_OK;
            }
            break;
	
	/*********************************************************************

	    compression messages

	*********************************************************************/

	case ICM_COMPRESS_QUERY:
	    return CompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (JPEGBITMAPINFOHEADER *)lParam2);

	case ICM_COMPRESS_BEGIN:
	    return CompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_FORMAT:
	    return CompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (JPEGBITMAPINFOHEADER *)lParam2);

	case ICM_COMPRESS_GET_SIZE:
	    return CompressGetSize(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);
	
	case ICM_COMPRESS:
	    return Compress(pi,
			    (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_COMPRESS_END:
	    return CompressEnd(pi);
	
	/*********************************************************************

	    decompress messages

	*********************************************************************/

	case ICM_DECOMPRESS_QUERY:
	    return DecompressQuery(pi,
			 (JPEGBITMAPINFOHEADER *)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_BEGIN:
	    return DecompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_GET_FORMAT:
	    return DecompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
                         (LPBITMAPINFOHEADER)lParam2);

        case ICM_DECOMPRESS_GET_PALETTE:
            return DecompressGetPalette(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS:
	    return Decompress(pi,
			 (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_DECOMPRESS_END:
	    return DecompressEnd(pi);

	/*********************************************************************

	    DecompressEx messages

	*********************************************************************/

	case ICM_DECOMPRESSEX_QUERY:
		{
#if 0
		char buf[128];

			decompressEx = (ICDECOMPRESSEX *)lParam1;
			sprintf(buf, "width %i height %i planes %i bits %i\n compression %8x %c %c %c %c  size %i",
			   decompressEx->lpbiDst->biWidth,
			   decompressEx->lpbiDst->biHeight,
			   decompressEx->lpbiDst->biPlanes,
			   decompressEx->lpbiDst->biBitCount,
			   (DWORD)decompressEx->lpbiDst->biCompression,
			   (decompressEx->lpbiDst->biCompression) & 0xff,
			   ((decompressEx->lpbiDst->biCompression) >> 8) & 0xff,
			   ((decompressEx->lpbiDst->biCompression) >> 16) & 0xff,
			   ((decompressEx->lpbiDst->biCompression) >> 24) & 0xff,
			   decompressEx->lpbiDst->biSizeImage);
			MessageBox(0,buf,"format info",MB_OK);
#endif

		return ICERR_BADFORMAT;
		}


	case ICM_DECOMPRESSEX_BEGIN:
		return ICERR_UNSUPPORTED;

	case ICM_DECOMPRESSEX:
		return ICERR_UNSUPPORTED;

	case ICM_DECOMPRESSEX_END:
		return ICERR_UNSUPPORTED;
	
		/*********************************************************************

	    draw messages

	*********************************************************************/

	case ICM_DRAW_BEGIN:
	    /*
	     * sent when a sequence of draw calls are about to start -
	     * enable hardware.
	     */
			return ICERR_UNSUPPORTED;
            // return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW:
	    /*
	     * frame ready for decompress. Since we don't have any pre-buffering,
	     * it is ok to render the frame at this time too. If we had
	     * pre-buffer, we would queue now, and start clocking frames out
	     * on the draw-start message.
	     */
			return ICERR_UNSUPPORTED;
//            return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW_END:
	    /*
	     * this message is sent when the sequence of draw calls has finished -
	     * note that the final frame should remain rendered!! - so we can't
	     * disable the hardware yet.
	     */
	    //return DrawEnd(pi);
		return ICERR_UNSUPPORTED;

//	    return((DWORD) ICERR_OK);


	case ICM_DRAW_WINDOW:
	    /*
	     * the window has changed position or z-ordering. re-sync the
	     * hardware rendering.
	     */
		return ICERR_UNSUPPORTED;
		// return(DrawWindow(pi, (PRECT)lParam1));


	case ICM_DRAW_QUERY:
	    /*
	     * can we draw this format ? (lParam2 may (should?) be null)
	     */
		return ICERR_BADFORMAT;
		 // jcb 11-15-96
	    //return DrawQuery(pi,
		//	 (LPBITMAPINFOHEADER)lParam1,
		//	 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DRAW_START:
	case ICM_DRAW_STOP:
	    /*
	     * only relevant if you have pre-buffering.
	     */
		return ICERR_UNSUPPORTED;
		// return( (DWORD) ICERR_OK);



	/*********************************************************************

	    standard driver messages

	*********************************************************************/

	case DRV_DISABLE:
	case DRV_ENABLE:
	    return (LRESULT)1L;

	case DRV_INSTALL:
	case DRV_REMOVE:
	    return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc(dwDriverID, hDriver, uiMessage,lParam1,lParam2);
    else
	return ICERR_UNSUPPORTED;
}

#endif // 0

#ifdef WIN32

#ifdef FILTER_DLL
BOOL DllMain(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
DWORD kind;
DWORD value;
DWORD len;
HKEY keyHandle;
DWORD disposition;

	if (Reason == DLL_PROCESS_DETACH)
		ClearErrorMessages();
	else if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
	
	if (RegCreateKeyEx(HKEY_CURRENT_USER,
				   szSubKey_SoftwareParadigmMatrixSoftwareMJPEGCodec,
				   0,
				   NULL,
				   REG_OPTION_NON_VOLATILE,
				   KEY_ALL_ACCESS,
				   NULL,
				   &keyHandle,
				   &disposition) == ERROR_SUCCESS) {
		kind = REG_DWORD;
		value = 0;
		len = sizeof(value);
		if (RegQueryValueEx(keyHandle,
						   szValue_Enabled,
						   NULL,
						   &kind,
						   (unsigned char *)&value,
						   &len) == ERROR_SUCCESS) {
		  driverEnabled = value;
		  }		
		else {
			RegSetValueEx(keyHandle,
						  szValue_Enabled,
						  0,
						  REG_DWORD,
						  (unsigned char *)&driverEnabled,
						  sizeof(DWORD));
		}
	  RegCloseKey(keyHandle);
	}

		
    }
    return TRUE;
}
#endif // FILTER_DLL

#else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\jccoefct.c ===
/*
 * jccoefct.c
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for compression.
 * This controller is the top level of the JPEG compressor proper.
 * The coefficient buffer lies between forward-DCT and entropy encoding steps.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* We use a full-image coefficient buffer when doing Huffman optimization,
 * and also for writing multiple-scan JPEG files.  In all cases, the DCT
 * step is run during the first pass, and subsequent passes need only read
 * the buffered coefficients.
 */
#ifdef ENTROPY_OPT_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#else
#ifdef C_MULTISCAN_FILES_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#endif
#endif


/* Private buffer controller object */

typedef struct {
  struct jpeg_c_coef_controller pub; /* public fields */

  JDIMENSION MCU_row_num;	/* keep track of MCU row # within image */

  /* For single-pass compression, it's sufficient to buffer just one MCU
   * (although this may prove a bit slow in practice).  We allocate a
   * workspace of MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each
   * MCU constructed and sent.  (On 80x86, the workspace is FAR even though
   * it's not really very big; this is to keep the module interfaces unchanged
   * when a large coefficient buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays.
   */
  JBLOCKROW MCU_buffer[MAX_BLOCKS_IN_MCU];

  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;


/* Forward declarations */
METHODDEF void compress_data
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr));
#ifdef FULL_COEF_BUFFER_SUPPORTED
METHODDEF void compress_first_pass
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr));
METHODDEF void compress_output
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr));
#endif


/*
 * Initialize for a processing pass.
 */

METHODDEF void
start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  coef->MCU_row_num = 0;

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (coef->whole_image[0] != NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_data;
    break;
#ifdef FULL_COEF_BUFFER_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_first_pass;
    break;
  case JBUF_CRANK_DEST:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_output;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data in the single-pass case.
 * Up to one MCU row is processed (less if suspension is forced).
 *
 * NB: input_buf contains a plane for each component in image.
 * For single pass, this is the same as the components in the scan.
 */

METHODDEF void
compress_data (j_compress_ptr cinfo,
	       JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_MCU_row = cinfo->MCU_rows_in_scan - 1;
  int blkn, bi, ci, yindex, blockcnt;
  JDIMENSION ypos, xpos;
  jpeg_component_info *compptr;

  /* Loop to write as much as one whole MCU row */

  for (MCU_col_num = *in_mcu_ctr; MCU_col_num <= last_MCU_col; MCU_col_num++) {
    /* Determine where data comes from in input_buf and do the DCT thing.
     * Each call on forward_DCT processes a horizontal row of DCT blocks
     * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks
     * sequentially.  Dummy blocks at the right or bottom edge are filled in
     * specially.  The data in them does not matter for image reconstruction,
     * so we fill them with values that will encode to the smallest amount of
     * data, viz: all zeroes in the AC entries, DC entries equal to previous
     * block's DC value.  (Thanks to Thomas Kinsman for this idea.)
     */
    blkn = 0;
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
					      : compptr->last_col_width;
      xpos = MCU_col_num * compptr->MCU_sample_width;
      ypos = 0;
      for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	if (coef->MCU_row_num < last_MCU_row ||
	    yindex < compptr->last_row_height) {
	  (*cinfo->fdct->forward_DCT) (cinfo, compptr,
				       input_buf[ci], coef->MCU_buffer[blkn],
				       ypos, xpos, (JDIMENSION) blockcnt);
	  if (blockcnt < compptr->MCU_width) {
	    /* Create some dummy blocks at the right edge of the image. */
	    jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
		      (compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));
	    for (bi = blockcnt; bi < compptr->MCU_width; bi++) {
	      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];
	    }
	  }
	} else {
	  /* Create a whole row of dummy blocks at the bottom of the image. */
	  jzero_far((void FAR *) coef->MCU_buffer[blkn],
		    compptr->MCU_width * SIZEOF(JBLOCK));
	  for (bi = 0; bi < compptr->MCU_width; bi++) {
	    coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];
	  }
	}
	blkn += compptr->MCU_width;
	ypos += DCTSIZE;
      }
    }
    /* Try to write the MCU.  In event of a suspension failure, we will
     * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
     */
    if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer))
      break;			/* suspension forced; exit loop */
  }
  if (MCU_col_num > last_MCU_col)
    coef->MCU_row_num++;	/* advance if we finished the row */
  *in_mcu_ctr = MCU_col_num;
}


#ifdef FULL_COEF_BUFFER_SUPPORTED

/*
 * Process some data in the first pass of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the image.
 * This amount of data is read from the source buffer, DCT'd and quantized,
 * and saved into the virtual arrays.  We also generate suitable dummy blocks
 * as needed at the right and lower edges.  (The dummy blocks are constructed
 * in the virtual arrays, which have been padded appropriately.)  This makes
 * it possible for subsequent passes not to worry about real vs. dummy blocks.
 *
 * We must also emit the data to the entropy encoder.  This is conveniently
 * done by calling compress_output() after we've loaded the current strip
 * of the virtual arrays.
 *
 * NB: input_buf contains a plane for each component in image.  All
 * components are DCT'd and loaded into the virtual arrays in this pass.
 * However, it may be that only a subset of the components are emitted to
 * the entropy encoder during this first pass; be careful about looking
 * at the scan-dependent variables (MCU dimensions, etc).
 */

METHODDEF void
compress_first_pass (j_compress_ptr cinfo,
		     JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_MCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION blocks_across, MCUs_across, MCUindex;
  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
  JCOEF lastDC;
  jpeg_component_info *compptr;
  JBLOCKARRAY buffer;
  JBLOCKROW thisblockrow, lastblockrow;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       coef->MCU_row_num * compptr->v_samp_factor, TRUE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (coef->MCU_row_num < last_MCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    blocks_across = compptr->width_in_blocks;
    h_samp_factor = compptr->h_samp_factor;
    /* Count number of dummy blocks to be added at the right margin. */
    ndummy = (int) (blocks_across % h_samp_factor);
    if (ndummy > 0)
      ndummy = h_samp_factor - ndummy;
    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
     * on forward_DCT processes a complete horizontal row of DCT blocks.
     */
    for (block_row = 0; block_row < block_rows; block_row++) {
      thisblockrow = buffer[block_row];
      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
				   input_buf[ci], thisblockrow,
				   (JDIMENSION) (block_row * DCTSIZE),
				   (JDIMENSION) 0, blocks_across);
      if (ndummy > 0) {
	/* Create dummy blocks at the right edge of the image. */
	thisblockrow += blocks_across; /* => first dummy block */
	jzero_far((void FAR *) thisblockrow, ndummy * SIZEOF(JBLOCK));
	lastDC = thisblockrow[-1][0];
	for (bi = 0; bi < ndummy; bi++) {
	  thisblockrow[bi][0] = lastDC;
	}
      }
    }
    /* If at end of image, create dummy block rows as needed.
     * The tricky part here is that within each MCU, we want the DC values
     * of the dummy blocks to match the last real block's DC value.
     * This squeezes a few more bytes out of the resulting file...
     */
    if (coef->MCU_row_num == last_MCU_row) {
      blocks_across += ndummy;	/* include lower right corner */
      MCUs_across = blocks_across / h_samp_factor;
      for (block_row = block_rows; block_row < compptr->v_samp_factor;
	   block_row++) {
	thisblockrow = buffer[block_row];
	lastblockrow = buffer[block_row-1];
	jzero_far((void FAR *) thisblockrow,
		  (size_t) (blocks_across * SIZEOF(JBLOCK)));
	for (MCUindex = 0; MCUindex < MCUs_across; MCUindex++) {
	  lastDC = lastblockrow[h_samp_factor-1][0];
	  for (bi = 0; bi < h_samp_factor; bi++) {
	    thisblockrow[bi][0] = lastDC;
	  }
	  thisblockrow += h_samp_factor; /* advance to next MCU in row */
	  lastblockrow += h_samp_factor;
	}
      }
    }
  }
  /* NB: compress_output will increment MCU_row_num */

  /* Emit data to the entropy encoder, sharing code with subsequent passes */
  compress_output(cinfo, input_buf, in_mcu_ctr);
}


/*
 * Process some data in subsequent passes of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the scan.
 * The data is obtained from the virtual arrays and fed to the entropy coder.
 *
 * Note that output suspension is not supported during multi-pass operation,
 * so the complete MCU row will always be emitted to the entropy encoder
 * before returning.
 *
 * NB: input_buf is ignored; it is likely to be a NULL pointer.
 */

METHODDEF void
compress_output (j_compress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION *in_mcu_ctr)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset, num_MCU_rows;
  JDIMENSION remaining_rows, start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan.
   * NB: during first pass, this is safe only because the buffers will
   * already be aligned properly, so jmemmgr.c won't need to do any I/O.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       coef->MCU_row_num * compptr->v_samp_factor, FALSE);
  }

  /* In an interleaved scan, we process exactly one MCU row.
   * In a noninterleaved scan, we need to process v_samp_factor MCU rows,
   * each of which contains a single block row.
   */
  if (cinfo->comps_in_scan == 1) {
    compptr = cinfo->cur_comp_info[0];
    num_MCU_rows = compptr->v_samp_factor;
    /* but watch out for the bottom of the image */
    remaining_rows = cinfo->MCU_rows_in_scan -
		     coef->MCU_row_num * compptr->v_samp_factor;
    if (remaining_rows < (JDIMENSION) num_MCU_rows)
      num_MCU_rows = (int) remaining_rows;
  } else {
    num_MCU_rows = 1;
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = 0; yoffset < num_MCU_rows; yoffset++) {
    for (MCU_col_num = 0; MCU_col_num < cinfo->MCUs_per_row; MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to write the MCU. */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
	ERREXIT(cinfo, JERR_CANT_SUSPEND); /* not supported */
      }
    }
  }

  coef->MCU_row_num++;		/* advance to next iMCU row */
  *in_mcu_ctr = cinfo->MCUs_per_row;
}

#endif /* FULL_COEF_BUFFER_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL void
jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;
  int ci, i;
  jpeg_component_info *compptr;
  JBLOCKROW buffer;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
  coef->pub.start_pass = start_pass_coef;

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef FULL_COEF_BUFFER_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note memmgr implicitly pads the vertical direction. */
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 compptr->height_in_blocks,
	 (JDIMENSION) compptr->v_samp_factor);
    }
#else
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->whole_image[0] = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\avi\mjpeg\pmjpeg32\jcapi.c ===
/*
 * jcapi.c
 *
 * Copyright (C) 1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the compression half of
 * the JPEG library.  Most of the routines intended to be called directly by
 * an application are in this file.  But also see jcparam.c for
 * parameter-setup helper routines, and jcomapi.c for routines shared by
 * compression and decompression.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Initialization of a JPEG compression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL void
jpeg_create_compress (j_compress_ptr cinfo)
{
  int i;

  /* For debugging purposes, zero the whole master structure.
   * But error manager pointer is already there, so save and restore it.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    MEMZERO(cinfo, SIZEOF(struct jpeg_compress_struct));
    cinfo->err = err;
  }
  cinfo->is_decompressor = FALSE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->dest = NULL;

  cinfo->comp_info = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  cinfo->input_gamma = 1.0;	/* in case application forgets */

  /* OK, I'm ready */
  cinfo->global_state = CSTATE_START;
}


/*
 * Destruction of a JPEG compression object
 */

GLOBAL void
jpeg_destroy_compress (j_compress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Forcibly suppress or un-suppress all quantization and Huffman tables.
 * Marks all currently defined tables as already written (if suppress)
 * or not written (if !suppress).  This will control whether they get emitted
 * by a subsequent jpeg_start_compress call.
 *
 * This routine is exported for use by applications that want to produce
 * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but
 * since it is called by jpeg_start_compress, we put it here --- otherwise
 * jcparam.o would be linked whether the application used it or not.
 */

GLOBAL void
jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
{
  int i;
  JQUANT_TBL * qtbl;
  JHUFF_TBL * htbl;

  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)
      qtbl->sent_table = suppress;
  }

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
  }
}


/*
 * Compression initialization.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * We require a write_all_tables parameter as a failsafe check when writing
 * multiple datastreams from the same compression object.  Since prior runs
 * will have left all the tables marked sent_table=TRUE, a subsequent run
 * would emit an abbreviated stream (no tables) by default.  This may be what
 * is wanted, but for safety's sake it should not be the default behavior:
 * programmers should have to make a deliberate choice to emit abbreviated
 * images.  Therefore the documentation and examples should encourage people
 * to pass write_all_tables=TRUE; then it will take active thought to do the
 * wrong thing.
 */

GLOBAL void
jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (write_all_tables)
    jpeg_suppress_tables(cinfo, FALSE);	/* mark all tables to be written */

  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Perform master selection of active modules */
  jinit_master_compress(cinfo);
  /* Set up for the first pass */
  (*cinfo->master->prepare_for_pass) (cinfo);
  /* Ready for application to drive first pass through jpeg_write_scanlines
   * or jpeg_write_raw_data.
   */
  cinfo->next_scanline = 0;
  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
}


/*
 * Write some scanlines of data to the JPEG compressor.
 *
 * The return value will be the number of lines actually written.
 * This should be less than the supplied num_lines only in case that
 * the data destination module has requested suspension of the compressor,
 * or if more than image_height scanlines are passed in.
 *
 * Note: we warn about excess calls to jpeg_write_scanlines() since
 * this likely signals an application programmer error.  However,
 * excess scanlines passed in the last valid call are *silently* ignored,
 * so that the application need not adjust num_lines for end-of-image
 * when using a multiple-scanline buffer.
 */

GLOBAL JDIMENSION
jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
		      JDIMENSION num_lines)
{
  JDIMENSION row_ctr, rows_left;

  if (cinfo->global_state != CSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height)
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_scanlines.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_scanlines.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Ignore any extra scanlines at bottom of image. */
  rows_left = cinfo->image_height - cinfo->next_scanline;
  if (num_lines > rows_left)
    num_lines = rows_left;

  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
  cinfo->next_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to write raw data.
 * Processes exactly one iMCU row per call.
 */

GLOBAL JDIMENSION
jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
		     JDIMENSION num_lines)
{
  JDIMENSION mcu_ctr, lines_per_MCU_row;

  if (cinfo->global_state != CSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_raw_data.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_raw_data.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Verify that at least one iMCU row has been passed. */
  lines_per_MCU_row = cinfo->max_v_samp_factor * DCTSIZE;
  if (num_lines < lines_per_MCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Directly compress the row. */
  mcu_ctr = 0;
  (*cinfo->coef->compress_data) (cinfo, data, &mcu_ctr);
  /* If compressor did not consume the whole row, then we must need to
   * suspend processing; this is not currently supported.
   */
  if (mcu_ctr != cinfo->MCUs_per_row)
    ERREXIT(cinfo, JERR_CANT_SUSPEND);

  /* OK, we processed one iMCU row. */
  cinfo->next_scanline += lines_per_MCU_row;
  return lines_per_MCU_row;
}


/*
 * Finish JPEG compression.
 *
 * If a multipass operating mode was selected, this may do a great deal of
 * work including most of the actual output.
 */

GLOBAL void
jpeg_finish_compress (j_compress_ptr cinfo)
{
  JDIMENSION iMCU_row, mcu_ctr;

  if (cinfo->global_state != CSTATE_SCANNING && 
      cinfo->global_state != CSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline < cinfo->image_height)
    ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
  /* Terminate first pass */
  (*cinfo->master->finish_pass) (cinfo);
  /* Perform any remaining passes */
  while (! cinfo->master->is_last_pass) {
    (*cinfo->master->prepare_for_pass) (cinfo);
    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) iMCU_row;
	cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* We bypass the main controller and invoke coef controller directly;
       * all work is being done from the coefficient buffer.
       */
      mcu_ctr = 0;
      (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL, &mcu_ctr);
      if (mcu_ctr != cinfo->MCUs_per_row)
	ERREXIT(cinfo, JERR_CANT_SUSPEND);
    }
    (*cinfo->master->finish_pass) (cinfo);
  }
  /* Write EOI, do final cleanup */
  (*cinfo->marker->write_file_trailer) (cinfo);
  (*cinfo->dest->term_destination) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
}


/*
 * Write a special marker.
 * This is only recommended for writing COM or APPn markers.
 * Must be called after jpeg_start_compress() and before
 * first call to jpeg_write_scanlines() or jpeg_write_raw_data().
 */

GLOBAL void
jpeg_write_marker (j_compress_ptr cinfo, int marker,
		   const JOCTET *dataptr, unsigned int datalen)
{
  if (cinfo->next_scanline != 0 ||
      (cinfo->global_state != CSTATE_SCANNING &&
       cinfo->global_state != CSTATE_RAW_OK))
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  (*cinfo->marker->write_any_marker) (cinfo, marker, dataptr, datalen);
}


/*
 * Alternate compression function: just write an abbreviated table file.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * To produce a pair of files containing abbreviated tables and abbreviated
 * image data, one would proceed as follows:
 *
 *		initialize JPEG object
 *		set JPEG parameters
 *		set destination to table file
 *		jpeg_write_tables(cinfo);
 *		set destination to image file
 *		j