igrates keys of the setup hive to the target hive.
    These keys are subkeys of \Registry\Machine\System\CurrentControlSet,
    and are listed on the section [SetupKeysToMigrate] on txtsetup.sif.

Arguments:

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    hDestLocalMachine - Handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet on the target hive.

    KeyPath - Path to the key to be migrated, relative to \Registry\Machine\System\CurrentControlSet.

    SifHandle - Handle to txtsetup.sif

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    HANDLE hSrcKey;
    HANDLE hTempSrcKey;
    HANDLE SaveHiveHandle;
    HANDLE hDestKey;

    PWSTR TempKeyPath = L"\\registry\\machine\\TempKey";
    PWSTR SaveHiveName;
    IO_STATUS_BLOCK   IoStatusBlock;
    PSECURITY_DESCRIPTOR Security = NULL;
    ULONG                ResultLength;


    //
    //  Open the key the key that needs to be saved
    //
    wcscpy(TemporaryBuffer,L"\\registry\\machine\\system\\currentcontrolset");
    SpConcatenatePaths(TemporaryBuffer,KeyPath);
    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hSrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return( Status ) ;
    }

    //
    //  Create the hive file
    //
    wcscpy(TemporaryBuffer,PartitionPath);
    SpConcatenatePaths(TemporaryBuffer,SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
    SpConcatenatePaths(TemporaryBuffer,L"TempKey");

    SaveHiveName = SpDupStringW(TemporaryBuffer);

    SpDeleteFile( SaveHiveName, NULL, NULL );

    INIT_OBJA(&Obja,&UnicodeString,SaveHiveName);

    Status = ZwCreateFile(
                    &SaveHiveHandle,
                    FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,                      // no sharing
                    FILE_OVERWRITE_IF,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create the hive file %ls. Status = %lx\n", SaveHiveName, Status));
        goto TempMigr_2;
    }

    Status = ZwSaveKey( hSrcKey, SaveHiveHandle );
    ZwClose( SaveHiveHandle );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save %ls key to the hive file %ls. Status = %lx\n", KeyPath, SaveHiveName, Status));
        goto TempMigr_3;
    }

    Status = SpLoadUnloadKey( NULL,
                              NULL,
                              TempKeyPath,
                              SaveHiveName );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load %ls key to the setup hive. Status = %lx\n", SaveHiveName, Status));
        goto TempMigr_3;
    }

    //
    //  Open TempKey
    //
    INIT_OBJA(&Obja,&UnicodeString,TempKeyPath);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hTempSrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open TempSrc key on the setup hive. Status = %lx\n", Status));
        goto TempMigr_4;
    }

    //
    // First, get the security descriptor from the source key so we can create
    // the destination key with the correct ACL.
    //
    Status = ZwQuerySecurityObject(hTempSrcKey,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &ResultLength
                                  );
    if(Status==STATUS_BUFFER_TOO_SMALL) {
        Security=SpMemAlloc(ResultLength);
        Status = ZwQuerySecurityObject(hTempSrcKey,
                                       DACL_SECURITY_INFORMATION,
                                       Security,
                                       ResultLength,
                                       &ResultLength);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security for key %ws in the source hive (%lx)\n",
                     TempKeyPath,
                     Status)
                   );
            SpMemFree(Security);
            Security=NULL;
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security size for key %ws in the source hive (%lx)\n",
                 TempKeyPath,
                 Status)
               );
        Security=NULL;
    }
    //
    // Open the key on the target hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = hDestControlSet;

    Status = ZwOpenKey(&hDestKey,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        //
        // Assume that failure was because the key didn't exist.  Now try creating
        // the key.

        Obja.SecurityDescriptor = Security;

        Status = ZwCreateKey(
                    &hDestKey,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open or create key %ws(%lx)\n",KeyPath, Status));

            if(Security) {
                SpMemFree(Security);
            }
            goto TempMigr_5;
        }
    } else if (OverwriteACLs) {

        Status = ZwSetSecurityObject(
                    hDestKey,
                    DACL_SECURITY_INFORMATION,
                    Security );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy ACL to existing key %ws(%lx)\n",KeyPath, Status));
        }
    }

    if(Security) {
        SpMemFree(Security);
    }

    Status = SppCopyKeyRecursive(
                 hTempSrcKey,
                 hDestKey,
                 NULL,
                 NULL,
                 OverwriteValues,
                 OverwriteACLs
                 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to the target hive. KeyPath, Status = %lx\n", Status));
    }

    ZwClose( hDestKey );

TempMigr_5:
    ZwClose( hTempSrcKey );

TempMigr_4:
    //
    //  Unload hive
    //
    SpLoadUnloadKey( NULL,
                     NULL,
                     TempKeyPath,
                     NULL );

TempMigr_3:
    SpDeleteFile( SaveHiveName, NULL, NULL );

TempMigr_2:
    SpMemFree( SaveHiveName );

    return( Status );
}



BOOLEAN
SpHivesFromInfs(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN LPCWSTR SourcePath1,
    IN LPCWSTR SourcePath2,     OPTIONAL
    IN HANDLE  SystemHiveRoot,
    IN HANDLE  SoftwareHiveRoot,
    IN HANDLE  DefaultUserHiveRoot,
    IN HANDLE  HKR
    )

/*++

Routine Description:

    This routine runs addreg and delreg sections as listed in txtsetup.sif,
    in order to create or perform the basic upgrade on the registry hives.

    Each line in the given section is expected to be in the following form:

        addreg = <filename>,<section>

    or

        delreg = <filename>,<section>

    Multiple addreg and delreg lines can be supplied, and the sections are
    processed in order listed.

    The filename specs are filename only; the files are expected to be
    in the source directory.

Arguments:

    SifHandle - supplies the handle to txtsetup.sif.

    SectionName - supplies the name of the section in txtsetuyp.sif that
        lists infs/sections to be processed.

    SourcePath - supplies NT-style path to the source files for installation.

    SystemHiveRoot - supplies handle to root key of system hive under
        construction.

    SoftwareHiveRoot - supplies handle to root key of software hive under
        construction.

    DefaultUserHiveRoot - supplies handle to root key of default hive under
        construction.

    HKR - supplies key to be used for HKR.

Return Value:

    Boolean value indicating outcome.

--*/

{

    LPCWSTR PreviousInf;
    LPCWSTR CurrentInf;
    ULONG LineNumber;
    LPCWSTR TypeSpec;
    LPCWSTR SectionSpec;
    PVOID InfHandle;
    ULONG ErrorLine;
    NTSTATUS Status;
    LPWSTR name;
    LPWSTR MediaShortname;
    LPWSTR MediaDirectory;

    //
    // Allocate a buffer for names.
    //
    name = SpMemAlloc(1000);

    LineNumber = 0;
    PreviousInf = L"";
    InfHandle = NULL;

    while((TypeSpec = SpGetKeyName(SifHandle,SectionName,LineNumber))
       && (CurrentInf = SpGetSectionLineIndex(SifHandle,SectionName,LineNumber,0))
       && (SectionSpec = SpGetSectionLineIndex(SifHandle,SectionName,LineNumber,1))) {

        //
        // Only load the inf if it's different than the previous one,
        // as a time optimization.
        //
        if(_wcsicmp(CurrentInf,PreviousInf)) {
            if(InfHandle) {
                SpFreeTextFile(InfHandle);
                InfHandle = NULL;
            }

            MediaShortname = SpLookUpValueForFile(SifHandle,(LPWSTR)CurrentInf,INDEX_WHICHMEDIA,TRUE);
            SpGetSourceMediaInfo(SifHandle,MediaShortname,NULL,NULL,&MediaDirectory);

            wcscpy(name,SourcePath1);
            if(SourcePath2) {
                SpConcatenatePaths(name,SourcePath2);
            }
            SpConcatenatePaths(name,MediaDirectory);
            SpConcatenatePaths(name,CurrentInf);
            Status = SpLoadSetupTextFile(name,NULL,0,&InfHandle,&ErrorLine,FALSE,FALSE);
            if(!NT_SUCCESS(Status)) {

                SpStartScreen(
                    SP_SCRN_INF_LINE_CORRUPT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    ErrorLine,
                    CurrentInf
                    );

                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

                SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;

                SpDone(0,FALSE,TRUE);
            }

            PreviousInf = CurrentInf;
        }

        if(!_wcsicmp(TypeSpec,L"addreg")) {

            Status = SpProcessAddRegSection(
                        InfHandle,
                        SectionSpec,
                        SystemHiveRoot,
                        SoftwareHiveRoot,
                        DefaultUserHiveRoot,
                        HKR
                        );

            SendSetupProgressEvent(SavingSettingsEvent, InitializeHiveEvent, NULL);
        } else {
            if(!_wcsicmp(TypeSpec,L"delreg")) {

                Status = SpProcessDelRegSection(
                            InfHandle,
                            SectionSpec,
                            SystemHiveRoot,
                            SoftwareHiveRoot,
                            DefaultUserHiveRoot,
                            HKR
                            );

                SendSetupProgressEvent(SavingSettingsEvent, InitializeHiveEvent, NULL);
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown hive section type spec %ws\n",TypeSpec));
                SpFreeTextFile(InfHandle);
                SpMemFree(name);
                return(FALSE);
            }
        }

        if(!NT_SUCCESS(Status)) {
            SpFreeTextFile(InfHandle);
            SpMemFree(name);
            return(FALSE);
        }

        LineNumber++;
    }

    if(InfHandle) {
        SpFreeTextFile(InfHandle);
    }

    SpMemFree(name);
    return(TRUE);
}




NTSTATUS
SpMigrateSetupKeys(
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE hDestControlSet,
    IN PVOID  SifHandle
    )

/*++

Routine Description:

    This routine migrates keys of the setup hive to the target hive.
    These keys are subkeys of \Registry\Machine\System\CurrentControlSet,
    and are listed on the section [SetupKeysToMigrate] on txtsetup.sif.

Arguments:

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    hDestLocalMachine - Handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet
                        on the target hive.

    SifHandle - Handle to txtsetup.sif

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    HANDLE hSrcKey;

    ULONG   LineIndex;
    PWSTR   KeyName;
    PWSTR   SectionName = L"SetupKeysToMigrate";
    BOOLEAN MigrateVolatileKeys;
    BOOLEAN OverwriteValues;
    BOOLEAN OverwriteACLs;
    BOOLEAN MigrateOnCleanInstall;
    BOOLEAN MigrateOnUpgrade;
    ULONG   InstType;
    PWSTR   p;

    SavedStatus = STATUS_SUCCESS;
    for( LineIndex = 0;
         ( KeyName = SpGetKeyName( SifHandle,
                                   SectionName,
                                   LineIndex ) ) != NULL;
         LineIndex++ ) {

        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   0 );
        MigrateVolatileKeys = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) == 0 ) )? FALSE : TRUE;

        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   1 );
        if( p != NULL ) {
            InstType = SpStringToLong( p, NULL, 10 );
            if( InstType > 2 ) {
                InstType = 2;
            }
        } else {
            InstType = 2;
        }
        MigrateOnCleanInstall = ( InstType != 1 );
        MigrateOnUpgrade = ( InstType != 0 );


        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   2 );
        OverwriteValues = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) == 0 ) )? FALSE : TRUE;


        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   3 );
        OverwriteACLs = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) != 0 ) );


        if( ( ( NTUpgrade == DontUpgrade ) && MigrateOnCleanInstall ) ||
            ( ( NTUpgrade != DontUpgrade ) && MigrateOnUpgrade ) ) {

            if( MigrateVolatileKeys ) {
                wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\" );
                SpConcatenatePaths(TemporaryBuffer, KeyName);

                //
                //  Open the source key
                //
                INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
                Obja.RootDirectory = NULL;

                Status = ZwOpenKey(&hSrcKey,KEY_ALL_ACCESS,&Obja);
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                    continue;
                }

                Status = SppCopyKeyRecursive(
                                 hSrcKey,
                                 hDestControlSet,
                                 NULL,
                                 KeyName,
                                 OverwriteValues,
                                 OverwriteACLs
                                 );

                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", KeyName, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                }

            } else {
                Status = SppMigrateSetupRegNonVolatileKeys( PartitionPath,
                                                            SystemRoot,
                                                            hDestControlSet,
                                                            KeyName,
                                                            OverwriteValues,
                                                            OverwriteACLs );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", KeyName, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                }

            }
        }
    }
    return( SavedStatus );
}

NTSTATUS
SppMigrateFtKeys(
    IN HANDLE hDestSystemHive
    )

/*++

Routine Description:

    This routine migrates the ftdisk related keys on the setup hive to the
    target hive.

Arguments:

    hDestSystemHive - Handle to the root of the system hive on the system
                      being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;


    PWSTR   FtDiskKeys[] = {
                           L"Disk",
                           L"MountedDevices"
                           };
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < sizeof(FtDiskKeys)/sizeof(PWSTR); i++ ) {
        //
        //  Open the source key
        //
        swprintf( KeyPath, L"\\registry\\machine\\system\\%ls", FtDiskKeys[i] );
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            //
            //  If the key doesn't exist, just assume success
            //
            if( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
                if( SavedStatus == STATUS_SUCCESS ) {
                    SavedStatus = Status;
                }
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      (((NTUpgrade == UpgradeFull) && !_wcsicmp( FtDiskKeys[i], L"MountedDevices"))? FALSE : TRUE),
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );
}

NTSTATUS
SppCleanupKeysFromRemoteInstall(
    VOID
    )

/*++

Routine Description:

    This routine cleans up some keys that remote install modified to get
    the network card working. This is so that PnP setup during GUI-mode is
    not confused by the card already being setup.

Arguments:

    None.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG ResultLength;
    HANDLE hKey;
    PWSTR DeviceInstance;

    //
    //  Open the remote boot key.
    //

    wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\control\\remoteboot" );
    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return Status;
    }

    //
    // Read the netboot card's device instance out.
    //

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DEVICE_INSTANCE);
    Status = ZwQueryValueKey(
                hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                &ResultLength
                );

    ZwClose(hKey);

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to read RemoteBoot\\DeviceInstance value (%lx)\n", Status));
        return Status;
    }

    DeviceInstance = SpDupStringW((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));

    //
    // Now open the device instance key under control\enum.
    //

    wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\enum\\" );
    SpConcatenatePaths(TemporaryBuffer, DeviceInstance);

    SpMemFree(DeviceInstance);

    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return Status;
    }

    //
    // Now delete the keys we added to get the card up -- Service,
    // ClassGUID, and Driver.
    //

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete Service (%lx)\n", Status));
        ZwClose(hKey);
        return Status;
    }

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwDeleteValueKey(hKey,&UnicodeString);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete ClassGUID (%lx)\n", Status));
            ZwClose(hKey);
            return Status;
        }
    }

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
        Status = ZwDeleteValueKey(hKey,&UnicodeString);
        ZwClose(hKey);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete Driver (%lx)\n", Status));
            return Status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SpDisableUnsupportedScsiDrivers(
    IN HANDLE hKeyControlSet
    )
{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    PHARDWARE_COMPONENT TmpHw;
    ULONG u;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetServices;
    ULONG val = SERVICE_DISABLED;

    //
    // Open controlset\services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwCreateKey(
                &hKeyControlSetServices,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open services key (%lx)\n",Status));
        return(Status);
    }

    SavedStatus = STATUS_SUCCESS;

    for( TmpHw = UnsupportedScsiHardwareToDisable;
         TmpHw != NULL;
         TmpHw = TmpHw->Next ) {

        Status = SpOpenSetValueAndClose(
                    hKeyControlSetServices,
                    TmpHw->IdString,
                    L"Start",
                    ULONG_VALUE(val)
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to disable unsupported driver %ls. Status = %lx \n", TmpHw->IdString, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unsupported driver %ls successfully disabled. \n", TmpHw->IdString));
        }
    }
    ZwClose( hKeyControlSetServices );
    return( SavedStatus );
}

NTSTATUS
SpAppendPathToDevicePath(
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  OemPnpDriversDirPath
    )

/*++

Routine Description:

    This routine should be called only on OEM preinstall.
    It appends the path to the directory that cntains the OEM drivers to be installed during GUI
    setup to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion!DevicePath.

Arguments:

    hKeySoftwareKey - Handle to the root of the software hive.

    OemPnpDriversDirPath - Path to the directory that contains the OEM pnp drivers (eg. \Dell).

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS    Status;
    ULONG       Length;
    PWSTR       szCurrentVersionKey = L"Microsoft\\Windows\\CurrentVersion";
    PWSTR       szDevicePath = L"DevicePath";

    Status = SpGetValueKey( hKeySoftwareHive,
                            szCurrentVersionKey,
                            szDevicePath,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    if( NT_SUCCESS(Status) ) {
        if( wcslen( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) ) != 0 ) {
        PWSTR   BeginStrPtr;
        PWSTR   EndStrPtr;
        BOOL    Done = FALSE;
            //
            // OemPnpDriversDirPath can have several entries, separated by
            // a semicolon.  For each entry, we need to:
            // 1. append a semicolon.
            // 2. append %SystemDrive%
            // 3. concatenate the entry.
            //

            BeginStrPtr = OemPnpDriversDirPath;
            do {
                //
                // Mark the end of this entry.
                //
                EndStrPtr = BeginStrPtr;
                while( (*EndStrPtr) && (*EndStrPtr != L';') ) {
                    EndStrPtr++;
                }

                //
                // Is this the last entry?
                //
                if( *EndStrPtr == 0 ) {
                    Done = TRUE;
                }
                *EndStrPtr = 0;

                wcscat( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L";" );
                wcscat( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L"%SystemDrive%" );
                SpConcatenatePaths((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), BeginStrPtr);

                BeginStrPtr = EndStrPtr + 1;

                //
                // Take care of the case where the user ended the
                // OemPnpDriversPath entry with a semicolon.
                //
                if( *BeginStrPtr == 0 ) {
                    Done = TRUE;
                }

            } while( !Done );

            //
            // Now put the entry back into the registry.
            //
            Status = SpOpenSetValueAndClose( hKeySoftwareHive,
                                             szCurrentVersionKey,
                                             szDevicePath,
                                             ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type,
                                             ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                                             (wcslen( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) ) +1 ) * sizeof(WCHAR) );
        }
    }
    return( Status );
}

NTSTATUS
SpAppendFullPathListToDevicePath (
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  PnpDriverFullPathList
    )

/*++

Routine Description:

    This routine appends the given full path list to the directory that cntains the OEM drivers to be installed during GUI
    setup to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion!DevicePath.

Arguments:

    hKeySoftwareKey - Handle to the root of the software hive.

    PnpDriverFullPathList - List of full paths to the directories that contain additional pnp drivers

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS    Status;
    ULONG       Length;
    PWSTR       szCurrentVersionKey = L"Microsoft\\Windows\\CurrentVersion";
    PWSTR       szDevicePath = L"DevicePath";

    Status = SpGetValueKey (
                hKeySoftwareHive,
                szCurrentVersionKey,
                szDevicePath,
                sizeof(TemporaryBuffer),
                (PCHAR)TemporaryBuffer,
                &Length
                );

    if (NT_SUCCESS (Status)) {
        if (*(WCHAR*)((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) {
            wcscat ((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L";");
        }
        wcscat ((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), PnpDriverFullPathList);
        //
        // Now put the entry back into the registry.
        //
        Status = SpOpenSetValueAndClose (
                        hKeySoftwareHive,
                        szCurrentVersionKey,
                        szDevicePath,
                        ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type,
                        ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                        (wcslen ((PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) + 1) * sizeof(WCHAR)
                        );
    }

    return( Status );
}

#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyRemoteBootKeyword(
    IN PVOID   SifHandle,
    IN PWSTR   KeywordName,
    IN HANDLE  hKeyCCSetControl
    )

/*++

Routine Description:

    This routine looks in a .sif file for the specified keyword
    in the [RemoteBoot] section. If it finds it, it creates a registry
    DWORD value with same name under System\CurrentControlSet\Control\
    RemoteBoot. The value will be set to 1 if the sif keyword was
    "Yes" and 0 if it was "No" (or anything else).

Arguments:

    SifHandle - The handle to the open SIF file.

    KeywordName - The name of the keyword.

    hKeyCCSetControl - The handle to CurrentControlSet\Control.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR KeywordSifValue;
    DWORD KeywordRegistryValue;
    NTSTATUS Status;

    //
    // First see if the value exists in the SIF.
    //

    KeywordSifValue = SpGetSectionKeyIndex(SifHandle,
                                           SIF_REMOTEBOOT,
                                           KeywordName,
                                           0);

    if (KeywordSifValue == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // This is the value we write to the registry.
    //

    if ((KeywordSifValue[0] == 'Y') || (KeywordSifValue[0] == 'y')) {
        KeywordRegistryValue = 1;
    } else {
        KeywordRegistryValue = 0;
    }

    //
    // Set the value.
    //

    Status = SpOpenSetValueAndClose(
                 hKeyCCSetControl,
                 SIF_REMOTEBOOT,
                 KeywordName,
                 ULONG_VALUE(KeywordRegistryValue)
                 );

    return Status;

}
#endif // defined(REMOTE_BOOT)


NTSTATUS
SppDisableDynamicVolumes(
    IN HANDLE hCCSet
    )

/*++

Routine Description:

    This routine disable dynamic volumes by disabling the appropriate services in the
    target hive.
    In addition, DmServer is reset to MANUAL start, so that it will only run when
    the LDM UI is open.

Arguments:

    hCCSet - Handle to CurrentControlSet of the target system hive.



Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    DWORD    u;
    ULONG    i;
    HANDLE   hServices;
    WCHAR    KeyPath[MAX_PATH];

    PWSTR    LDMServices[] = {
                             L"dmboot",
                             L"dmio",
                             L"dmload"
                             };
    PWSTR   LDMDmServer    = L"dmserver";

    //
    // Open ControlSet\Services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Services");
    Obja.RootDirectory = hCCSet;

    Status = ZwOpenKey(&hServices,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open CurrentControlSet\\Services. Status = %lx \n",Status));
        return(Status);
    }

    SavedStatus = STATUS_SUCCESS;
    u = 0x4;
    for( i = 0; i < sizeof(LDMServices)/sizeof(PWSTR); i++ ) {

        Status = SpOpenSetValueAndClose( hServices,
                                         LDMServices[i],
                                         L"Start",
                                         ULONG_VALUE(u)
                                       );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to disable HKLM\\SYSTEM\\CurrentControlSet\\Services\\%ls. Status = %lx\n", LDMServices[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
    }
    u = 0x3;
    Status = SpOpenSetValueAndClose( hServices,
                                     LDMDmServer,
                                     L"Start",
                                     ULONG_VALUE(u)
                                   );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set HKLM\\SYSTEM\\CurrentControlSet\\Services\\%ls to MANUAL start. Status = %lx\n", LDMDmServer, Status));
        if( SavedStatus == STATUS_SUCCESS ) {
            SavedStatus = Status;
        }
    }

    ZwClose( hServices );
    return( SavedStatus );
}

NTSTATUS
SpGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );
    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(!NT_SUCCESS(status));
        return status;
    }
    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = SpMemAlloc(keyValueLength);
    if (!infoBuffer) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {

        SpMemFree(infoBuffer);
        return status;
    }
    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

VOID
SpUpdateDeviceInstanceKeyData(
    IN  HANDLE          InstanceKey,
    IN  HANDLE          ClassBranchKey,
    IN  PUNICODE_STRING EnumName,
    IN  PUNICODE_STRING DeviceName,
    IN  PUNICODE_STRING InstanceName
    )

/*++

Routine Description:

    This routine updates (removes\changes type\names) the various values under
    the device instance key on an upgrade.

Arguments:

    InstanceKey - Handle to the device instance key.

    ClassBranchKey - Handle to the classes branch.

    EnumName - Enumerator name.

    DeviceName - Device name.

    InstanceName - Instance name.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    UNICODE_STRING valueName, guidString, drvInstString;
    DWORD length;
    GUID guid;
    PKEY_VALUE_FULL_INFORMATION info, guidInfo;
    PWCHAR  ids, className;
    ULONG   drvInst;
    WCHAR   driver[GUID_STRING_LEN + 5];
    OBJECT_ATTRIBUTES obja;
    HANDLE hClassKey;
    BOOLEAN guidAllocatedViaRtl;

    //
    // Preinit
    //
    RtlInitUnicodeString(&guidString, NULL);
    info = NULL;
    guidInfo = NULL;

    //
    // Look at the instance key to see if we are dealing with a WinXP Beta2
    // machine. If so, we need to convert it's compressed PnP data format back
    // to the original Win2K format (app compat):
    //
    // <Normal, Win2K/WinXP>                    <Compressed, XP Beta2>
    // "ClassGUID" (REG_SZ)                     "GUID" (REG_BINARY)
    // "Driver" (REG_SZ, ClassGUID\DrvInst)     "DrvInst" (REG_DWORD, DrvInst)
    // "HardwareID" (UNICODE, MultiSz)          "HwIDs" (ANSI-REG_BINARY, MultiSz)
    // "CompatibleIDs" (UNICODE, MultiSz)       "CIDs" (ANSI-REG_BINARY, MultiSz)
    // "Class" (UNICODE)                        none, retrieved using ClassGUID
    //

    //
    // Do we have the XP-Beta2 style "GUID" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_GUID, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change "GUID" (REG_BINARY) to "ClassGUID" (REG_SZ).
        //
        status = RtlStringFromGUID((GUID *)((PUCHAR)info + info->DataOffset), &guidString);
        SpMemFree(info);
        if (NT_SUCCESS(status)) {

            guidAllocatedViaRtl = TRUE;

            RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASSGUID);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_SZ,
                guidString.Buffer,
                guidString.Length + sizeof(UNICODE_NULL));

            //
            // Delete old "GUID" value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_GUID);
            ZwDeleteValueKey(InstanceKey, &valueName);
        }

    } else {

        //
        // This might be a rare Lab1 build where we've already done the
        // conversion but we forgot to restore the class name.
        //
        status = SpGetRegistryValue(InstanceKey, REGSTR_VAL_CLASS, &info);

        if (NT_SUCCESS(status) && info) {

            //
            // We successfully retrieved the class name from the device
            // instance key--no need to attempt further migration.
            //
            SpMemFree(info);

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = SpGetRegistryValue(InstanceKey, REGSTR_VAL_CLASSGUID, &guidInfo);

            if (NT_SUCCESS(status) && !guidInfo) {

                status = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS(status)) {

                //
                // The ClassGUID value exists.  Initialize our string with this
                // GUID so we can go to the corresponding key under the Class
                // Branch to lookup the Class name.
                //
                guidAllocatedViaRtl = FALSE;

                RtlInitUnicodeString(&guidString, 
                                     (PWCHAR)((PUCHAR)guidInfo + guidInfo->DataOffset)
                                    );
            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // While we are here we need to restore the class name as well.
        // Start by getting the class name from the class's branch itself.
        //
        InitializeObjectAttributes(
            &obja,
            &guidString,
            OBJ_CASE_INSENSITIVE,
            ClassBranchKey,
            NULL
            );

        status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &obja);

        ASSERT(NT_SUCCESS(status));

        if (NT_SUCCESS(status)) {

            status = SpGetRegistryValue(hClassKey, REGSTR_VAL_CLASS, &info);
            if (NT_SUCCESS(status) && !info) {

                status = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS(status)) {

                //
                // Copy the class name stored in the class branch to the
                // instance key.
                //
                className = (PWCHAR)((PUCHAR)info + info->DataOffset);

                RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASS);
                ZwSetValueKey(
                    InstanceKey,
                    &valueName,
                    0,
                    REG_SZ,
                    className,
                    (wcslen(className)+1)*sizeof(WCHAR)
                    );

                SpMemFree(info);
            }

            ZwClose(hClassKey);
        }
    }

    //
    // At this point, if status is successful, that means we migrated Class/
    // ClassGUID values, so there may be more to do...
    //
    if (NT_SUCCESS(status)) {
        //
        // Do we have the XP-Beta2 style "DrvInst" key?
        //
        status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_DRVINST, &info);
        if (NT_SUCCESS(status) && !info) {

            status = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(status)) {

            //
            // Change DrvInst (REG_DWORD) to Driver (REG_SZ) from "ClassGuid\DrvInst"
            //
            ASSERT(guidString.Length != 0);

            drvInst = *(PULONG)((PUCHAR)info + info->DataOffset);
            swprintf(driver,
                     TEXT("%wZ\\%04u"),
                     &guidString,
                     drvInst);

            SpMemFree(info);

            RtlInitUnicodeString(&valueName, REGSTR_VAL_DRIVER);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_SZ,
                driver,
                sizeof(driver)
                );

            //
            // Delete DrvInst value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_DRVINST);
            ZwDeleteValueKey(InstanceKey, &valueName);
        }
    }

    //
    // We don't need the class guid anymore.
    //
    if (guidString.Buffer) {

        if (guidAllocatedViaRtl) {

            RtlFreeUnicodeString(&guidString);
        } else {

            SpMemFree(guidInfo);
        }
    }

    //
    // Do we have the XP-Beta2 "HwIDs" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_HWIDS, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change HW IDs from ANSI to UNICODE.
        //
        ids = SpConvertMultiSzStrToWstr(((PUCHAR)info + info->DataOffset), info->DataLength);
        if (ids) {

            RtlInitUnicodeString(&valueName, REGSTR_VAL_HARDWAREID);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_MULTI_SZ,
                ids,
                info->DataLength * sizeof(WCHAR)
                );

            //
            // Delete HwIDs value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_HWIDS);
            ZwDeleteValueKey(InstanceKey, &valueName);
            SpMemFree(ids);
        }
        SpMemFree(info);
    }

    //
    // Do we have the XP-Beta2 "CIDs" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_CIDS, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change Compatible IDs from ANSI to UNICODE.
        //
        ids = SpConvertMultiSzStrToWstr(((PUCHAR)info + info->DataOffset), info->DataLength);
        if (ids) {

            RtlInitUnicodeString(&valueName, REGSTR_VAL_COMPATIBLEIDS);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_MULTI_SZ,
                ids,
                info->DataLength * sizeof(WCHAR)
                );

            //
            // Delete CIDs value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_CIDS);
            ZwDeleteValueKey(InstanceKey, &valueName);
            SpMemFree(ids);
        }
        SpMemFree(info);
    }
}

NTSTATUS
SpUpdateDeviceInstanceData(
    IN HANDLE ControlSet
    )
/*++

Routine Description:

    This routine enumerates all the keys under HKLM\System\CCS\Enum and call
    SpUpdateDeviceInstanceKeyData for each device instance key.

Arguments:

    ControlSet - Handle to the control set to update.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    HANDLE hEnumBranchKey, hClassBranchKey;
    UNICODE_STRING enumBranch, classBranch;
    HANDLE hEnumeratorKey, hDeviceKey, hInstanceKey;
    UNICODE_STRING enumeratorName, deviceName, instanceName;
    PKEY_BASIC_INFORMATION  enumBasicInfo, deviceBasicInfo, instBasicInfo;
    ULONG ulEnumerator, ulDevice, ulInstance, ulLength, ulBasicInfoSize;

    //
    // Preinit for error
    //
    hEnumBranchKey = NULL;
    hClassBranchKey = NULL;
    enumBasicInfo = NULL;

    //
    // First open the enum branch for this control set
    //
    RtlInitUnicodeString(&enumBranch, REGSTR_KEY_ENUM);
    InitializeObjectAttributes(
        &obja,
        &enumBranch,
        OBJ_CASE_INSENSITIVE,
        ControlSet,
        NULL
        );

    status = ZwOpenKey(&hEnumBranchKey, KEY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {

        ASSERT(NT_SUCCESS(status));
        goto Exit;
    }

    //
    // Now open the class key for this control set.
    //
    RtlInitUnicodeString(&classBranch, REGSTR_KEY_CONTROL L"\\" REGSTR_KEY_CLASS);
    InitializeObjectAttributes(
        &obja,
        &classBranch,
        OBJ_CASE_INSENSITIVE,
        ControlSet,
        NULL
        );

    status = ZwOpenKey(&hClassBranchKey, KEY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {

        ASSERT(NT_SUCCESS(status));
        goto Exit;
    }

    //
    // Allocate memory for enumeration
    //
    ulBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + REG_MAX_KEY_NAME_LENGTH;
    enumBasicInfo = SpMemAlloc(ulBasicInfoSize * 3);
    if (enumBasicInfo == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    //
    // Cast two pointers for future buffer usage.
    //
    deviceBasicInfo = (PKEY_BASIC_INFORMATION)((PUCHAR)enumBasicInfo + ulBasicInfoSize);
    instBasicInfo = (PKEY_BASIC_INFORMATION)((PUCHAR)deviceBasicInfo + ulBasicInfoSize);

    //
    // Walk each enumerator and then each device instance
    //
    status = STATUS_SUCCESS;
    for (ulEnumerator = 0; ; ulEnumerator++) {

        status = ZwEnumerateKey(
            hEnumBranchKey,
            ulEnumerator,
            KeyBasicInformation,
            enumBasicInfo,
            ulBasicInfoSize,
            &ulLength
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Open the enumerator
        //
        enumeratorName.Length = enumeratorName.MaximumLength = (USHORT)enumBasicInfo->NameLength;
        enumeratorName.Buffer = &enumBasicInfo->Name[0];
        InitializeObjectAttributes(
            &obja,
            &enumeratorName,
            OBJ_CASE_INSENSITIVE,
            hEnumBranchKey,
            NULL
            );

        status = ZwOpenKey(&hEnumeratorKey, KEY_ALL_ACCESS, &obja);

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Walk each device
        //
        for (ulDevice = 0; ; ulDevice++) {

            status = ZwEnumerateKey(
                hEnumeratorKey,
                ulDevice,
                KeyBasicInformation,
                deviceBasicInfo,
                ulBasicInfoSize,
                &ulLength
                );

            if (!NT_SUCCESS(status)) {

                break;
            }

            deviceName.Length = deviceName.MaximumLength = (USHORT)deviceBasicInfo->NameLength;
            deviceName.Buffer = &deviceBasicInfo->Name[0];
            InitializeObjectAttributes(
                &obja,
                &deviceName,
                OBJ_CASE_INSENSITIVE,
                hEnumeratorKey,
                NULL
                );

            status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &obja);

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Now walk each instance
            //
            for (ulInstance = 0; ; ulInstance++) {

                status = ZwEnumerateKey(
                    hDeviceKey,
                    ulInstance,
                    KeyBasicInformation,
                    instBasicInfo,
                    ulBasicInfoSize,
                    &ulLength
                    );

                if (!NT_SUCCESS(status)) {

                    break;
                }

                instanceName.Length = instanceName.MaximumLength = (USHORT)instBasicInfo->NameLength;
                instanceName.Buffer = &instBasicInfo->Name[0];
                InitializeObjectAttributes(
                    &obja,
                    &instanceName,
                    OBJ_CASE_INSENSITIVE,
                    hDeviceKey,
                    NULL
                    );

                status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &obja);

                if (!NT_SUCCESS(status)) {

                    break;
                }

                SpUpdateDeviceInstanceKeyData(
                    hInstanceKey,
                    hClassBranchKey,
                    &enumeratorName,
                    &deviceName,
                    &instanceName
                    );

                ZwClose(hInstanceKey);
            }

            ZwClose(hDeviceKey);

            if (status != STATUS_NO_MORE_ENTRIES) {

                break;
            }
        }

        ZwClose(hEnumeratorKey);

        if (status != STATUS_NO_MORE_ENTRIES) {

            break;
        }
    }

    //
    // STATUS_NO_MORE_ENTRIES isn't a failure, it just means we've exhausted
    // the number of enumerators.
    //
    if (status == STATUS_NO_MORE_ENTRIES) {

        status = STATUS_SUCCESS;
    }

Exit:

    if (enumBasicInfo) {

        SpMemFree(enumBasicInfo);
    }

    if (hEnumBranchKey) {

        ZwClose(hEnumBranchKey);
    }

    if (hClassBranchKey) {

        ZwClose(hClassBranchKey);
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}

NTSTATUS
SppDeleteRegistryValueRecursive(
    HANDLE  hKeyRoot,
    PWSTR   KeyPath,    OPTIONAL
    PWSTR   ValueToDelete
    )
/*++

Routine Description:

    This routine will recursively enumerate the specified hKeyRoot and KeyPath
    and delete any ValueToDelete registry values in those keys.

Arguments:

    hKeyRoot: Handle to root key

    KeyPath:  root key relative path to the subkey which needs to be
              recursively copied. if this is null hKeyRoot is the key
              from which the recursive copy is to be done.

    ValueToDelete  name of the value that needs to be deleted.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    ObjaSrc;
    UNICODE_STRING       UnicodeStringSrc, UnicodeStringValue;
    HANDLE               hKey=NULL;
    ULONG                ResultLength, Index;
    PWSTR                SubkeyName;

    PKEY_BASIC_INFORMATION      KeyInfo;

    //
    // Get a handle to the source key
    //
    if(KeyPath == NULL) {
        hKey = hKeyRoot;
    }
    else {
        //
        // Open the Src key
        //
        INIT_OBJA(&ObjaSrc,&UnicodeStringSrc,KeyPath);
        ObjaSrc.RootDirectory = hKeyRoot;
        Status = ZwOpenKey(&hKey,KEY_READ,&ObjaSrc);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open key %ws in the source hive (%lx)\n",KeyPath,Status));
            return(Status);
        }
    }

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //
    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateKey(
                    hKey,
                    Index,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(KeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in key %ws(%lx)\n",KeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        if (SubkeyName) {
            Status = SppDeleteRegistryValueRecursive(
                         hKey,
                         SubkeyName,
                         ValueToDelete
                         );

            SpMemFree(SubkeyName);
        }
    }

    //
    // Process any errors if found
    //
    if(!NT_SUCCESS(Status)) {

        if(KeyPath != NULL) {
            ZwClose(hKey);
        }

        return(Status);
    }

    //
    // Delete the ValueToDelete value in this key.  We won't check the status
    // since it doesn't matter if this succeeds or not.
    //
    RtlInitUnicodeString(&UnicodeStringValue, ValueToDelete);
    ZwDeleteValueKey(hKey,&UnicodeStringValue);

    //
    // cleanup
    //
    if(KeyPath != NULL) {
        ZwClose(hKey);
    }

    return(Status);
}

NTSTATUS
SpCleanUpHive(
    VOID
    )

/*++

Routine Description:

    This routine will cleanup the system hive before it is migrated to the
    target system hive.

Arguments:

    none

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKey;

    INIT_OBJA(&Obja,&UnicodeString,L"\\registry\\machine\\system\\currentcontrolset");
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", L"\\registry\\machine\\system\\currentcontrolset", Status));
        return( Status ) ;
    }

    //
    // Delete the DeviceDesc values from under the enum key.
    // The reason for this is that if we replace the DeviceDesc values on an
    // upgrade then GUI mode setup won't be able to backup any 3rd party drivers
    // that we are replaceing with our in-box drivers. This is because the
    // DeviceDesc is one of three values that setupapi uses to create a
    // unique driver node.
    //
    if (NTUpgrade == UpgradeFull) {
        Status = SppDeleteRegistryValueRecursive(
                        hKey,
                        REGSTR_KEY_ENUM,
                        REGSTR_VAL_DEVDESC
                        );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to the target hive. KeyPath, Status = %lx\n", Status));
        }
    }

    ZwClose( hKey );

    return( Status );
}

NTSTATUS
SpIterateRegistryKeyForKeys(
    IN HANDLE RootKeyHandle,
    IN PWSTR  KeyToIterate,
    IN SP_REGISTRYKEY_ITERATION_CALLBACK Callback,
    IN PVOID  Context
    )
/*++

Routine Description:

    Iterates the registry key looking for registry keys which are
    immediately below the current key.

    NOTE : To stop the iteration the callback function should return
        FALSE.

Arguments:

    RootKeyHandle - The root key which contains the key to iterate

    KeyToIterate - The relative path for the key to iterate w.r.t to 
        root key.

    Callback - The call function which will be called for each subkey
        found under the requested key.

    Context - Opaque context data that the caller needs and will be
        passed on by the iteration routine for each invocation of
        the callback function.
        
Return Value:

    Appropriate NT status error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate the arguments
    //
    if (RootKeyHandle && KeyToIterate && Callback) {
        HANDLE  KeyHandle = NULL; 
        UNICODE_STRING KeyName;
        OBJECT_ATTRIBUTES ObjAttrs;

        //
        // Open the key which needs to be iterated
        //
        INIT_OBJA(&ObjAttrs, &KeyName, KeyToIterate);
        ObjAttrs.RootDirectory = RootKeyHandle;

        Status = ZwOpenKey(&KeyHandle,
                    KEY_ALL_ACCESS,
                    &ObjAttrs);

        if (NT_SUCCESS(Status)) {
            ULONG BufferLength = 4096;
            PKEY_FULL_INFORMATION FullInfo = (PKEY_FULL_INFORMATION)SpMemAlloc(BufferLength);
            ULONG ResultLength = 0;

            if (FullInfo) {                
                //
                // Find out how many subkeys the current key has
                //
                Status = ZwQueryKey(KeyHandle,
                            KeyFullInformation,
                            FullInfo,
                            BufferLength,
                            &ResultLength);

                if (NT_SUCCESS(Status)) {
                    ULONG NumSubKeys = FullInfo->SubKeys;
                    ULONG Index;
                    BOOLEAN Done;
                    NTSTATUS LastError = STATUS_SUCCESS;

                    //
                    // Iterate each subkey of the current key and callback
                    // the subscriber function
                    //
                    for (Index = 0, Done = FALSE; 
                        NT_SUCCESS(Status) && !Done && (Index < NumSubKeys); 
                        Index++) {
                        
                        PKEY_BASIC_INFORMATION BasicInfo = (PKEY_BASIC_INFORMATION)FullInfo;

                        Status = ZwEnumerateKey(KeyHandle,
                                    Index,
                                    KeyBasicInformation,
                                    BasicInfo,
                                    BufferLength,
                                    &ResultLength);

                        if (NT_SUCCESS(Status)) {
                            NTSTATUS CallbackStatus = STATUS_SUCCESS;
                            SP_REGISTRYKEY_ITERATION_CALLBACK_DATA CallbackData;

                            CallbackData.InformationType = KeyBasicInformation;
                            CallbackData.Information = (PVOID)BasicInfo;
                            CallbackData.ParentKeyHandle = KeyHandle;

                            //
                            // Callback
                            //
                            Done = (Callback(Context, &CallbackData, &CallbackStatus) == FALSE);

                            //
                            // register any error and continue on
                            //
                            if (!NT_SUCCESS(CallbackStatus)) {
                                LastError = CallbackStatus;
                            }
                        } else if (Status == STATUS_NO_MORE_ENTRIES) {
                            //
                            // Done with iteration
                            //
                            Done = TRUE;
                            Status = STATUS_SUCCESS;
                        } 
                    }                    

                    if (!NT_SUCCESS(LastError)) {
                        Status = LastError;
                    }                        
                }

                SpMemFree(FullInfo);
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        }                                            
    }

    return Status;
}


//
// Context data structure for class filter deletion
//
typedef struct _SP_CLASS_FILTER_DELETE_CONTEXT {
    PVOID   Buffer;
    ULONG   BufferLength;
    PWSTR   DriverName;
} SP_CLASS_FILTER_DELETE_CONTEXT, *PSP_CLASS_FILTER_DELETE_CONTEXT;    

static
BOOLEAN 
SppFixUpperAndLowerFilterEntries(
    IN PVOID Context,
    IN PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA Data,
    OUT NTSTATUS *Status
    )
/*++

Routine Description:


Arguments:

    Context - The SP_CLASS_FILTER_DELETE_CONTEXT disguised as
        a void pointer.

    Data - The data the iterator passed to us, containing information
        about the current subkey.

    Status - Place holder for receiving the error status code which
        this function returns.

Return Value:

    TRUE if the iteration needs to be continued otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;    

    *Status = STATUS_INVALID_PARAMETER;

    if (Context && Data && (Data->InformationType == KeyBasicInformation)) {
        NTSTATUS UpperStatus, LowerStatus;
        PKEY_BASIC_INFORMATION  BasicInfo = (PKEY_BASIC_INFORMATION)(Data->Information);
        PSP_CLASS_FILTER_DELETE_CONTEXT DelContext = (PSP_CLASS_FILTER_DELETE_CONTEXT)Context;
        PWSTR KeyName = (PWSTR)(DelContext->Buffer);

        if (KeyName && (BasicInfo->NameLength < DelContext->BufferLength)) {
            wcsncpy(KeyName, BasicInfo->Name, BasicInfo->NameLength/sizeof(WCHAR));
            KeyName[BasicInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;

            //
            // Delete the string from upperfilters
            //
            UpperStatus = SpRemoveStringFromMultiSz(Data->ParentKeyHandle,
                                KeyName,
                                SP_UPPER_FILTERS,
                                DelContext->DriverName);

            //
            // Delete the string from lowerfilters
            //
            LowerStatus = SpRemoveStringFromMultiSz(Data->ParentKeyHandle,
                                KeyName,
                                SP_LOWER_FILTERS,
                                DelContext->DriverName);

            if (NT_SUCCESS(UpperStatus) || NT_SUCCESS(LowerStatus)) {
                *Status = STATUS_SUCCESS;
            } else if (((UpperStatus == STATUS_OBJECT_NAME_NOT_FOUND) ||
                        (UpperStatus == STATUS_OBJECT_NAME_INVALID)) && 
                       ((LowerStatus == STATUS_OBJECT_NAME_NOT_FOUND) ||
                        (LowerStatus == STATUS_OBJECT_NAME_INVALID))) {
                //
                // If the value was not found then continue on
                //
                *Status = STATUS_SUCCESS;
            }            

            // 
            // we want to continue iterating irrespective of the results
            //
            Result = TRUE;
        }            
    }

    return Result;
}



NTSTATUS
SpProcessServicesToDisable(
    IN PVOID WinntSifHandle,
    IN PWSTR SectionName,
    IN HANDLE CurrentControlSetKey
    )
/*++

Routine Description:

    Processess the winnt.sif's [ServiceToDisable] section to 
    remove the service entries from upper and lower filters.    

Arguments:

    WinntSifHandle - Handle to winnt.sif file.

    SectionName - The name of section in winnt.sif which contains
        a list of service name which need to be removed from
        the filter list.

    CurrentControlKey - The handle to CurrentControlSet root key.        

Return Value:

    Appropriate NTSTATUS error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate arguments
    //
    if (WinntSifHandle && SectionName && CurrentControlSetKey) {        
        ULONG EntriesToProcess = SpCountLinesInSection(WinntSifHandle,
                                    SP_SERVICES_TO_DISABLE);                                        

        //
        // If there are any entries to process -- then process them
        //
        if (EntriesToProcess) {                                        
            ULONG BufferLength = 16 * 1024;
            PVOID Buffer = SpMemAlloc(BufferLength);

            if (Buffer) {
                ULONG Index;
                PWSTR CurrentEntry;
                SP_CLASS_FILTER_DELETE_CONTEXT DeleteContext = {0};                
                NTSTATUS LastErrorStatus = STATUS_SUCCESS;

                //
                // Process each entry
                //
                DeleteContext.Buffer = Buffer;
                DeleteContext.BufferLength = BufferLength;

                for(Index = 0; Index < EntriesToProcess; Index++) {                            
                    CurrentEntry = SpGetSectionLineIndex(WinntSifHandle,
                                        SP_SERVICES_TO_DISABLE,
                                        Index,
                                        0);

                    if (CurrentEntry) {
                        DeleteContext.DriverName = CurrentEntry;
                        
                        Status = SpIterateRegistryKeyForKeys(CurrentControlSetKey,
                                        L"Class",
                                        SppFixUpperAndLowerFilterEntries,
                                        &DeleteContext);

                        //
                        // save away the error code and continue on
                        //
                        if (!NT_SUCCESS(Status)) {
                            LastErrorStatus = Status;
                        }
                    }                                        
                }

                //
                // Even one of the entries failed to delete correctly
                // then flag it as a failure
                //
                if (!NT_SUCCESS(LastErrorStatus)) {
                    Status = LastErrorStatus;
                }                    

                SpMemFree(Buffer);
            }                                
        } else {
            Status = STATUS_SUCCESS;    // nothing to process
        }                
    }

    return Status;
}


//
// Context data structure for device instance filter deletion
//
typedef struct _SP_DEVINSTANCE_FILTER_DELETE_CONTEXT {
    PVOID   Buffer;
    ULONG   BufferLength;
    PUNICODE_STRING *ClassGuids;
} SP_DEVINSTANCE_FILTER_DELETE_CONTEXT, *PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT;    


static
VOID
SppRemoveFilterDriversForClassDeviceInstances(
    IN HANDLE  SetupInstanceKeyHandle,
    IN HANDLE  UpgradeInstanceKeyHandle,
    IN BOOLEAN RootEnumerated,
    IN PVOID   Context
    )
/*++

Routine Description:

    Callback which removes the filter drivers for the 
    specified device instance

Arguments:

    SetupInstanceKeyHandle - Handle to device instance key in setupreg.hiv.

    UpgradeInstanceKeyHandle - Handle to device instance key in the
        system hive of the installation being upgraded.

    RootEnumerated - Whether this is root enumerated key or not.

    Context - SP_DEVINSTANCE_FILTER_DELETE_CONTEXT instance disguised 
        as PVOID context.

Return Value:

    None.

--*/
{
    //
    // Validate arguments
    //
    if (Context && SetupInstanceKeyHandle) {        
        PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT DelContext;

        //
        // get device instance filter deletion context
        //
        DelContext = (PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT)Context;

        //
        // Validate the context
        //
        if (DelContext->Buffer && DelContext->BufferLength && 
            DelContext->ClassGuids && DelContext->ClassGuids[0]) {

            PKEY_VALUE_FULL_INFORMATION  ValueInfo;
            UNICODE_STRING GuidValueName;
            ULONG BufferLength;
            NTSTATUS Status;
            BOOLEAN DeleteFilterValueKeys = FALSE;

            //
            // reuse the buffer allocated by the iterator caller
            //
            ValueInfo = (PKEY_VALUE_FULL_INFORMATION)(DelContext->Buffer);

            RtlInitUnicodeString(&GuidValueName, SP_CLASS_GUID_VALUE_NAME);

            //
            // Get the class GUID for the current device instance
            //
            Status = ZwQueryValueKey(SetupInstanceKeyHandle,
                        &GuidValueName,
                        KeyValueFullInformation,
                        ValueInfo,
                        DelContext->BufferLength - sizeof(WCHAR),
                        &BufferLength);

            if (NT_SUCCESS(Status)) {
                PWSTR CurrentGuid = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                ULONG Index;

                //
                // null terminate the string (NOTE:we assume buffer has space)
                //
                CurrentGuid[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;

                //
                // Is this the one of the class device instance we are looking for?
                //
                for (Index = 0; DelContext->ClassGuids[Index]; Index++) {
                    if (!_wcsicmp(CurrentGuid, DelContext->ClassGuids[Index]->Buffer)) {
                        DeleteFilterValueKeys = TRUE;

                        break;
                    }
                }                
            }

            //
            // Delete the upper and lower filter value keys
            //
            if (DeleteFilterValueKeys) {
                UNICODE_STRING  UpperValueName, LowerValueName;
                
                RtlInitUnicodeString(&UpperValueName, SP_UPPER_FILTERS);
                RtlInitUnicodeString(&LowerValueName, SP_LOWER_FILTERS);

                if (SetupInstanceKeyHandle) {
                    ZwDeleteValueKey(SetupInstanceKeyHandle, &UpperValueName);
                    ZwDeleteValueKey(SetupInstanceKeyHandle, &LowerValueName);
                }                    

                if (UpgradeInstanceKeyHandle) {
                    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UpperValueName);
                    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &LowerValueName);
                }                    
            }        
        }            
    }            
}


NTSTATUS
SpDeleteRequiredDeviceInstanceFilters(
    IN HANDLE CCSKeyHandle
    )
/*++

Routine Description:

    Deletes filter entries from keyboard and mouse class device
    instances in registry.

Arguments:

    CCSHandle - Handle to CCS key.

Return Value:

    Appropriate NT status code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (CCSKeyHandle) {
        UNICODE_STRING  MouseGuidStr = {0};
        UNICODE_STRING  KeyboardGuidStr = {0};
        PUNICODE_STRING ClassGuids[16] = {0};
        ULONG CurrentIndex = 0;
        NTSTATUS LastErrorCode = STATUS_SUCCESS;

        //
        // Get hold of keyboard class GUID string
        //
        Status = RtlStringFromGUID(&GUID_DEVCLASS_KEYBOARD, &KeyboardGuidStr);

        if (NT_SUCCESS(Status)) {
            ClassGuids[CurrentIndex++] = &KeyboardGuidStr;
        } else {
            LastErrorCode = Status;
        } 

        //
        // Get hold of mouse class GUID string
        //
        Status = RtlStringFromGUID(&GUID_DEVCLASS_MOUSE, &MouseGuidStr);

        if (NT_SUCCESS(Status)) {
            ClassGuids[CurrentIndex++] = &MouseGuidStr;
        } else {
            LastErrorCode = Status;
        }            

        //
        // If we could form atleast one class guid string
        //
        if (CurrentIndex) {
            SP_DEVINSTANCE_FILTER_DELETE_CONTEXT  DelContext = {0};
            ULONG BufferLength = 4096;
            PVOID Buffer = SpMemAlloc(BufferLength);

            if (Buffer) {            
                // 
                // null terminate the class GUID unicode string array
                //
                ClassGuids[CurrentIndex] = NULL;

                DelContext.Buffer = Buffer;
                DelContext.BufferLength = BufferLength;
                DelContext.ClassGuids = ClassGuids;

                //
                // Iterate through all the device instances
                //
                SpApplyFunctionToDeviceInstanceKeys(CCSKeyHandle,
                    SppRemoveFilterDriversForClassDeviceInstances,
                    &DelContext);  

                SpMemFree(Buffer);                    
            } else {
                LastErrorCode = STATUS_NO_MEMORY;
            }                

            //
            // free the allocated strings
            //
            if (MouseGuidStr.Buffer) {
                RtlFreeUnicodeString(&MouseGuidStr);
            }

            if (KeyboardGuidStr.Buffer) {
                RtlFreeUnicodeString(&KeyboardGuidStr);
            }            
        }            

        Status = LastErrorCode;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcopy.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spcopy.h

Abstract:

    Header file for file copying functions in text setup.

Author:

    Ted Miller (tedm) 29-October-1993

Revision History:

    02-Oct-1996  jimschm  Added SpMoveWin9xFiles
    24-Feb-1997  jimschm  Added SpDeleteWin9xFiles
    28-Feb-1997  marcw    Moved *Win9x* functions to i386\win9xupg.c.
                          Added declarations for SpMigDeleteFile and SpMigMoveFileOrDir

--*/


#ifndef _SPCOPY_DEFN_
#define _SPCOPY_DEFN_

//
// Define structure used to describe a file to be copied
// to the target installation.
//
typedef struct _FILE_TO_COPY {

    struct _FILE_TO_COPY *Next;

    //
    // Name of the file to be copied, as it exists on the source media
    // (file name part only -- no paths).
    //
    PWSTR SourceFilename;

    //
    // Directory to which this file is to be copied.
    //
    PWSTR TargetDirectory;

    //
    // Name of file as it should exist on the target.
    //
    PWSTR TargetFilename;

    //
    // Path to target partition.  This is useful because
    // be will have to copy files to the nt drive and system partition,
    // and we don't want to serialize these lists (ie, we don't want to
    // worry about where the target is).
    //
    PWSTR TargetDevicePath;

    //
    // Flag indicating whether TargetDirectory is absolute.  If not, then it
    // is relative to a directory determined at run time (ie, sysroot).
    // This is useful for files that get copied to the system partition.
    //
    BOOLEAN AbsoluteTargetDirectory;

    //
    // Disposition flag to indicate the conditions under which the file
    // is to be copied. Can be one of the following, which may be ORed with
    // any of the COPY_xxx flags below.
    //
    //   COPY_ALWAYS                : always copied
    //   COPY_ONLY_IF_PRESENT       : copied only if present on the target
    //   COPY_ONLY_IF_NOT_PRESENT   : not copied if present on the target
    //   COPY_NEVER                 : never copied
    //
    ULONG Flags;

} FILE_TO_COPY, *PFILE_TO_COPY;

typedef struct _DISK_FILE_LIST {

    PWSTR MediaShortname;

    PWSTR Description;

    PWSTR TagFile;

    PWSTR Directory;

    ULONG FileCount;

    PFILE_TO_COPY FileList;

} DISK_FILE_LIST, *PDISK_FILE_LIST;


typedef struct _INCOMPATIBLE_FILE_ENTRY {

    //
    // Next in line
    //
    struct _INCOMPATIBLE_FILE_ENTRY *Next;

    //
    // Future - currently always zero
    //
    ULONG Flags;

    //
    // Short name (no path) of the file that is incompatible
    //
    PWSTR IncompatibleFileName;

    //
    // Version string (future use) of this file
    //
    PWSTR VersionString;

    //
    // Where it lives on the target media
    //
    PWSTR FullPathOnTarget;

} INCOMPATIBLE_FILE_ENTRY, *PINCOMPATIBLE_FILE_ENTRY;

typedef struct _INCOMPATIBLE_FILE_LIST {

    //
    // First entry in the list
    //
    PINCOMPATIBLE_FILE_ENTRY Head;

    //
    // Count, to speed things up
    //
    ULONG EntryCount;

} INCOMPATIBLE_FILE_LIST, *PINCOMPATIBLE_FILE_LIST;


#define COPY_ALWAYS                 0x00000000
#define COPY_ONLY_IF_PRESENT        0x00000001
#define COPY_ONLY_IF_NOT_PRESENT    0x00000002
#define COPY_NEVER                  0x00000003
#define COPY_DISPOSITION_MASK       0x0000000f

#define COPY_DELETESOURCE           0x00000010
#define COPY_SMASHLOCKS             0x00000020
#define COPY_SOURCEISOEM            0x00000040
#define COPY_OVERWRITEOEMFILE       0x00000080
#define COPY_FORCENOCOMP            0x00000100
#define COPY_SKIPIFMISSING          0x00000200
#define COPY_NOVERSIONCHECK         0x00000400
#define COPY_NODECOMP               0x00000800
#define COPY_DECOMPRESS_SYSPREP     0x00001000 // decompress even if it's a sysprep image

//
// Flags in [FileFlags] section of txtsetup.sif
//
#define FILEFLG_SMASHLOCKS          0x00000001
#define FILEFLG_FORCENOCOMP         0x00000002
#define FILEFLG_UPGRADEOVERWRITEOEM 0x00000004
#define FILEFLG_NOVERSIONCHECK      0x00000008
#define FILEFLG_DONTDELETESOURCE    0x00000010

#define SP_DELETE_FILESTODELETE 0
#define SP_COUNT_FILESTODELETE 1

//
//  Structure used to build a list of OEM inf files copied during the installation of OEM drivers
//
typedef struct _OEM_INF_FILE {

    struct _OEM_INF_FILE *Next;

    PWSTR InfName;

} OEM_INF_FILE, *POEM_INF_FILE;

//
// Type of routine to be called from SpCopyFileWithRetry
// when the screen needs repainting.
//
typedef
VOID
(*PCOPY_DRAW_ROUTINE) (
    IN PWSTR   FullSourcePath,     OPTIONAL
    IN PWSTR   FullTargetPath,     OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    );

//
// Type of routine to be called from SpExpandFile
// for each file found in cabinet.
//

typedef enum {
    EXPAND_COPY_FILE,
    EXPAND_COPIED_FILE,
    EXPAND_QUERY_OVERWRITE,
    EXPAND_NOTIFY_CANNOT_EXPAND,
    EXPAND_NOTIFY_MULTIPLE,
    EXPAND_NOTIFY_CREATE_FAILED
} EXPAND_CALLBACK_MESSAGE;

typedef enum {
    EXPAND_NO_ERROR = 0,
    EXPAND_SKIP_THIS_FILE,
    EXPAND_COPY_THIS_FILE,
    EXPAND_CONTINUE,
    EXPAND_ABORT
} EXPAND_CALLBACK_RESULT;

typedef
EXPAND_CALLBACK_RESULT
(*PEXPAND_CALLBACK) (
    IN EXPAND_CALLBACK_MESSAGE  Message,
    IN PWSTR                    FileName,
    IN PLARGE_INTEGER           FileSize,
    IN PLARGE_INTEGER           FileTime,
    IN ULONG                    FileAttributes,
    IN PVOID                    CallbackContext
    );

VOID
SpCopyThirdPartyDrivers(
    IN PWSTR           SourceDevicePath,
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    );

NTSTATUS
SpCopyFileUsingNames(
    IN PWSTR   SourceFilename,
    IN PWSTR   TargetFilename,
    IN ULONG   TargetAttributes,
    IN ULONG   Flags
    );

VOID
SpValidateAndChecksumFile(
    IN  HANDLE   FileHandle, OPTIONAL
    IN  PWSTR    Filename,   OPTIONAL
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,
    IN PWSTR              SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,          OPTIONAL
    IN PWSTR              TargetRoot,               OPTIONAL
    IN ULONG              TargetFileAttributes,
    IN PCOPY_DRAW_ROUTINE DrawScreen,
    IN PULONG             CheckSum,
    IN PBOOLEAN           FileSkipped,
    IN ULONG              Flags
    );

VOID
SpCopyFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDirectory,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        ThirdPartySourceDevicePath
    );

VOID
SpDeleteAndBackupFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        TargetPath
    );

//
// The user may skip this operation, in which case SpCreateDirectory
// returns FALSE.
//
#define CREATE_DIRECTORY_FLAG_SKIPPABLE     (0x00000001)

BOOLEAN
SpCreateDirectory(
    IN PCWSTR DevicePath,
    IN PCWSTR RootDirectory, OPTIONAL
    IN PCWSTR Directory,
    IN ULONG DirAttrs,
    IN ULONG CreateFlags
    );

VOID
SpCreateDirectoryStructureFromSif(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory
    );


NTSTATUS
SpMoveFileOrDirectory(
    IN PWSTR   SrcPath,
    IN PWSTR   DestPath
    );

VOID
SpCopyDirRecursive(
    IN PWSTR   SrcPath,
    IN PWSTR   DestDevPath,
    IN PWSTR   DestDirPath,
    IN ULONG   CopyFlags
    );

//
// Diamond/decompression routines.
//
VOID
SpdInitialize(
    VOID
    );

VOID
SpdTerminate(
    VOID
    );

BOOLEAN
SpdIsCabinet(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize,
    OUT PBOOLEAN ContainsMultipleFiles
    );

BOOLEAN
SpdIsCompressed(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    );

NTSTATUS
SpdDecompressFile(
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle
    );

NTSTATUS
SpdDecompressCabinet(
    IN PVOID            SourceBaseAddress,
    IN ULONG            SourceFileSize,
    IN PWSTR            DestinationPath,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    );

NTSTATUS
SpdDecompressFileFromDriverCab(
    IN  PWSTR SourceFileName,
    IN  PVOID  SourceBaseAddress,
    IN  ULONG  SourceFileSize,
    IN  HANDLE DestinationHandle,
    OUT PUSHORT pDate,
    OUT PUSHORT pTime
    );

BOOLEAN
SpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    );

VOID
SpMigDeleteFile (
    PWSTR DosFileToDelete
    );

VOID
SpMigMoveFileOrDir (
    IN PWSTR         SourceFileOrDir,
    IN PWSTR         DestFileOrDir
    );

VOID
SpInitializeFileLists(
    IN  PVOID            SifHandle,
    OUT PDISK_FILE_LIST *DiskFileLists,
    OUT PULONG           DiskCount
    );

VOID
SpAddSectionFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SectionName,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp
    );

VOID
SpCopyFilesInCopyList(
    IN PVOID                    SifHandle,
    IN PDISK_FILE_LIST          DiskFileLists,
    IN ULONG                    DiskCount,
    IN PWSTR                    SourceDevicePath,
    IN PWSTR                    DirectoryOnSourceDevice,
    IN PWSTR                    TargetRoot,
    IN PINCOMPATIBLE_FILE_LIST  CompatibilityExceptionList OPTIONAL
    );

VOID
SpFreeCopyLists(
    IN OUT PDISK_FILE_LIST *DiskFileLists,
    IN     ULONG            DiskCount
    );

NTSTATUS
SpExpandFile(
    IN PWSTR            SourceFilename,
    IN PWSTR            TargetPathname,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    );

NTSTATUS
SpCreateIncompatibleFileEntry(
    OUT PINCOMPATIBLE_FILE_ENTRY *TargetEntry,
    IN PWSTR FileName,
    IN PWSTR VersionString          OPTIONAL,
    IN PWSTR TargetAbsolutePath     OPTIONAL,
    IN ULONG Flags                  OPTIONAL
    );


NTSTATUS
SpFreeIncompatibleFileList(
    IN PINCOMPATIBLE_FILE_LIST FileListHead
    );

BOOLEAN
SpIsFileIncompatible(
    IN  PINCOMPATIBLE_FILE_LIST FileList,
    IN  PFILE_TO_COPY           pFile,
    IN  PWSTR                   TargetRoot OPTIONAL
    );


NTSTATUS
SpInitializeCompatibilityOverwriteLists(
    IN  PVOID                   SifHandle,
    OUT PINCOMPATIBLE_FILE_LIST IncompatibleFileList
    );

#endif // ndef _SPCOPY_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdblspc.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblspc.h

Abstract:

    Header file for double space module in text setup.

Author:

    Jaime Sasson (jaimes) 01-October-1993

Revision History:

--*/

#ifndef _SPDBLSPACE_
#define _SPDBLSPACE_

#define CVF_NAME        L"DBLSPACE"
#define CVF_NAME_LENGTH 8+1+3

BOOLEAN
SpLoadDblspaceIni(
    );

VOID
SpInitializeCompressedDrives(
    );

VOID
SpDisposeCompressedDrives(
    PDISK_REGION    CompressedDrive
    );

BOOLEAN
SpUpdateDoubleSpaceIni(
    );

ULONG
SpGetNumberOfCompressedDrives(
    IN  PDISK_REGION    DiskRegion
);


#endif // _SPDBLSPACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdblspc.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblspc.c

Abstract:

    Code that detects compressed drives on a system that contains
    dblspace.ini in the root of c:.

Author:

    Jaime Sasson (jaimes) 01-October-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtFsControlFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;


#define KWD_ACT             L"ActivateDrive"
#define KWD_FIRST           L"FirstDrive"
#define KWD_LAST            L"LastDrive"
#define KWD_MAXREM          L"MaxRemovableDrives"
#define KWD_MAXFILE         L"MaxFileFragments"
#define KWD_AUTOMOUNT       L"Automount"
#define KWD_DOUBLEGUARD     L"Doubleguard"
#define KWD_ROMSERVER       L"Romserver"
#define KWD_SWITCHES        L"Switches"
#define CVF_SEQ_MAX         255
#define MINFILEFRAGMENTS    50
#define MAXFILEFRAGMENTS    10000
#define DBLSPACE_INI_FILE   L"\\dblspace.ini"
#define CVF_NAME_PATTERN    L"DBLSPACE.%03d"

typedef struct _ACTIVATE_DRIVE {
    struct _ACTIVATE_DRIVE* Next;
    struct _ACTIVATE_DRIVE* Previous;
    WCHAR    MountDrive;
    WCHAR    HostDrive;
    USHORT    SeqNumber;
    } ACTIVATE_DRIVE, *PACTIVATE_DRIVE;

typedef struct _DBLSPACE_INI_INFO {
    USHORT          MaxRemovableDrives;
    WCHAR           FirstDrive;
    WCHAR           LastDrive;
    USHORT          MaxFileFragments;
    WCHAR           DoubleGuard[2];
    WCHAR           RomServer[2];
    PACTIVATE_DRIVE CompressedDriveList;
    WCHAR           AutoMount[30];
    WCHAR           Switches[4];
    } DBLSPACE_INI_INFO, *PDBLSPACE_INI_INFO;

BOOLEAN             DblspaceModified = FALSE;
DBLSPACE_INI_INFO   DblspaceInfo = { 0,                // MaxRemovableDrives
                                     0,                // FirstDrive
                                     0,                // LastDrive
                                     0,                // MaxFileFragments
                                     { (WCHAR)'\0' },  // DoubleGuard
                                     { (WCHAR)'\0' },  // RomServer
                                     NULL,             // CompressedDriveList
                                     { (WCHAR)'\0' },  // AutoMount[0]
                                     { (WCHAR)'\0' }   // Switches[0]
                                   };


LONG
CompareDrive(
    IN  PACTIVATE_DRIVE Drive1,
    IN  PACTIVATE_DRIVE Drive2
    )

/*++

Routine Description:

    Compares two structures of type ACTIVATE_DRIVE.
    This routine is used to sort the list of compressed drives
    in the global variable DblspaceInfo.

    Drive1 < Drive2 if
        Drive1->HostDrive < Drive2->HostDrive or
        Drive1->HostDrive ==  Drive2->HostDrive and
        Drive1->SeqNumber < Drive2->SeqNumber

    Drive1 == Drive2 if
        Drive1->HostDrive == Drive2->HostDrive and
        Drive1->SeqNumber == Drive2->SeqNumber

    Drive1 > Drive2 if
        Drive1->HostDrive > Drive2->HostDrive or
        Drive1->HostDrive ==  Drive2->HostDrive and
        Drive1->SeqNumber > Drive2->SeqNumber


Arguments:

    Drive1, Drive2 - Pointer to  ACTIVATE_STRUCTUREs to be compared.

Return Value:

    LONG - Returns: -1 if Drive1 < Drive2
                     0 if Drive1 == Drive2
                     1 if Drive1 > Drive2


--*/
{
    if( ( Drive1->HostDrive < Drive2->HostDrive ) ||
        ( ( Drive1->HostDrive == Drive2->HostDrive ) &&
          ( Drive1->SeqNumber < Drive2->SeqNumber ) )
      ) {
        return( -1 );
    } else if ( ( Drive1->HostDrive > Drive2->HostDrive ) ||
                ( ( Drive1->HostDrive == Drive2->HostDrive ) &&
                ( Drive1->SeqNumber > Drive2->SeqNumber ) )
      ) {
        return( 1 );
    }
    return( 0 );
}




BOOLEAN
AddCompressedDrive(
    IN  WCHAR   MountDrive,
    IN  WCHAR   HostDrive,
    IN  USHORT  SeqNumber
    )
/*++

Routine Description:

    Add an ACTIVATE_DRIVE structure to the list of compressed drives
    kept in DblspaceInfo.

Arguments:

    MountDrive - Indicates the drive letter of the compressed drive.

    HostDrive - Indicates the drive letter of the host drive (drive that
                contains the file dblspace.nnn) for the compressed drive.

    SeqNumber - Sequence number for the CVF file associated to the compressed
                drive.

Return Value:

    BOOLEAN - Returns TRUE if the information was successfully added
              to the list of compressed drives.


--*/

{
    PACTIVATE_DRIVE     NewElement;
    PACTIVATE_DRIVE     Pointer;

    NewElement = SpMemAlloc( sizeof( ACTIVATE_DRIVE ) );
    if( NewElement == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory!\n" ) );
        return( FALSE );
    }
    NewElement->MountDrive = MountDrive;
    NewElement->HostDrive = HostDrive;
    NewElement->SeqNumber = SeqNumber;
    NewElement->Next = NULL;
    NewElement->Previous = NULL;

    if( ( Pointer = DblspaceInfo.CompressedDriveList ) == NULL ) {
        DblspaceInfo.CompressedDriveList = NewElement;
    } else {
        for( ; Pointer; Pointer = Pointer->Next ) {
            if( CompareDrive( NewElement, Pointer ) <= 0 ) {
                //
                //  Insert element
                //
                NewElement->Previous = Pointer->Previous;
                if( NewElement->Previous != NULL ) {
                    NewElement->Previous->Next = NewElement;
                } else {
                    DblspaceInfo.CompressedDriveList = NewElement;
                }
                NewElement->Next = Pointer;
                Pointer->Previous = NewElement;
                break;
            } else {
                if( Pointer->Next == NULL ) {
                    //
                    //  Insert element if element is greater than the last
                    //  element in the list
                    //
                    Pointer->Next = NewElement;
                    NewElement->Previous = Pointer;
                    break;
                }
            }
        }
    }
    DblspaceModified = TRUE;
    return( TRUE );
}



BOOLEAN
RemoveCompressedDrive(
    IN  WCHAR   Drive
    )

/*++

Routine Description:

    Remove a the entry from the list of compressed drives that describes
    a particular compressed drive.

Arguments:

    Drive - Drive letter that describes a compressed drive.

Return Value:


    BOOLEAN - Returns TRUE if the compressed drive was successfuly removed
              from the list of compressed drives. Returns FALSE
              if the drive was not found in the data base.

--*/
{
    PACTIVATE_DRIVE     Pointer;
    BOOLEAN             Status;

    Status = FALSE;

    Pointer = DblspaceInfo.CompressedDriveList;
    for( ; Pointer; Pointer = Pointer->Next ) {
        if( Pointer->MountDrive == Drive ) {
            if( Pointer->Previous != NULL ) {
                Pointer->Previous->Next = Pointer->Next;
            }
            if( Pointer->Next != NULL ) {
                Pointer->Next->Previous = Pointer->Previous;
            }
            if( Pointer == DblspaceInfo.CompressedDriveList ) {
                DblspaceInfo.CompressedDriveList = Pointer->Next;
            }
            SpMemFree( Pointer );
            Status = TRUE;
            DblspaceModified = TRUE;
            break;
        }
    }
    return( Status );
}


VOID
DumpDblspaceInfo()

/*++

Routine Description:

    Dump the information stored in the global variable DblspaceInfo
    into the debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PACTIVATE_DRIVE Pointer;

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "MaxRemovableDrives=%d\n",
              DblspaceInfo.MaxRemovableDrives ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "FirstDrive=%c\n",
              ( CHAR )DblspaceInfo.FirstDrive ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "LastDrive=%c\n",
              ( CHAR )DblspaceInfo.LastDrive ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "MaxFileFragments=%d\n",
              DblspaceInfo.MaxFileFragments ));

    for( Pointer = DblspaceInfo.CompressedDriveList;
         Pointer;
         Pointer = Pointer->Next ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "ActivateDrive=%c,%c%d\n",
                  ( CHAR )Pointer->MountDrive,
                  ( CHAR )Pointer->HostDrive,
                  Pointer->SeqNumber ));
    }
}


VOID
DumpCompressedDrives(
    IN  PDISK_REGION    HostRegion
    )

/*++

Routine Description:

    Dump the compressed drive list associated to a particular host drive,
    into the debugger

Arguments:

    None.

Return Value:


    None.

--*/

{
    PDISK_REGION    CurrentDrive;

    if( ( HostRegion->Filesystem == FilesystemFat ) &&
        ( HostRegion->NextCompressed != NULL ) ) {


        for( CurrentDrive = HostRegion;
             CurrentDrive;
             CurrentDrive = CurrentDrive->NextCompressed ) {
            if( CurrentDrive->Filesystem == FilesystemFat ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "HostDrive = %wc\n", CurrentDrive->HostDrive) );
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "CompressedDrive = %wc, HostDrive = %wc, CVF = %wc:DBLSPACE.%03d\n", CurrentDrive->MountDrive, CurrentDrive->HostRegion->HostDrive, CurrentDrive->HostDrive, CurrentDrive->SeqNumber ) );
            }
        }
    }
}



VOID
DumpAllCompressedDrives()
/*++

Routine Description:

    Traverse all the structures that represent partitions and dump
    all compressed drives into the debugger.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG             DiskNumber;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION      pRegion;
    unsigned          pass;

    for( DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++ ) {

        pDisk = &PartitionedDisks[DiskNumber];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                DumpCompressedDrives( pRegion );
            }
        }
    }
}



BOOLEAN
SpLoadDblspaceIni()
/*++

Routine Description:

    Read and parse dblspace.ini, if one is found.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if dblspace.ini was read successfully.
              Returns FALSE otherwise.

--*/

{
    PDISK_REGION CColonRegion;
    WCHAR        NtPath[ 512 ];
    NTSTATUS     Status;
    PVOID        Handle;
    ULONG        ErrorLine;

    ULONG   LineNumber;
    PWCHAR  Key;
    PWCHAR  Value1;
    PWCHAR  Value2;
    PWCHAR  Value3;
    UINT    ValueSize;
    ULONG   CvfNumber;
    ULONG   MaxNumber;
    PWCHAR  AuxPointer;


// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpLoadDblspaceIni\n"));
    //
    // See if there is a valid C: already.  If not, then silently fail.
    //
#ifndef _X86_

    return( FALSE );

#else

    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no dblspace.ini!\n"));
        return(FALSE);
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpPtValidSystemPartition\n"));

#endif
    //
    // Check the filesystem.  If not FAT, then silently fail.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, dblspace.ini!\n"));
        return(FALSE);
    }

    SpNtNameFromRegion(
        CColonRegion,
        NtPath,
        sizeof(NtPath),
        PartitionOrdinalCurrent
        );

    wcscat( NtPath, DBLSPACE_INI_FILE );

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpNtNameFromRegion\n"));

    Status = SpLoadSetupTextFile( NtPath,
                                  NULL,
                                  0,
                                  &Handle,
                                  &ErrorLine,
                                  TRUE,
                                  FALSE
                                  );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read dblspace.ini!\n"));
        return( FALSE );
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpLoadSetupTextFile\n"));

    //
    //  Read and interpret each line in dblspace.ini
    //
//    DblspaceInfo.ActivateDriveCount = 0;
    LineNumber = 0;
    while( ( Key = SpGetKeyName( Handle,
                                 DBLSPACE_SECTION,
                                 LineNumber ) ) != NULL ) {
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpGetKeyName\n"));
        if( _wcsicmp( Key, KWD_ACT ) == 0 ) {
            //
            //  Found an ActivateDrive= key
            //

            //
            //  Read mount drive letter
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read mount drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Mount Drive letter from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate Mount Drive letter
            //
            if( ( wcslen( Value1 ) != 1 ) ||
                ( !SpIsAlpha( *Value1 ) ) ) {
                //
                //  Mount Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Mount Drive letter in dblspace.ini is not legal!\n"));
                continue;
            }
            //
            //  Read host drive letter
            //
            Value2 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            1 );
            if( Value2 == NULL ) {
                //
                //  Unable to read host drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Host Drive letter from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate Host Drive letter
            //
            ValueSize = wcslen( Value2 );
            if( ( ( ValueSize < 2 ) || ( ValueSize > 4 ) ) ||
                ( !SpIsAlpha( *Value2 ) ) ) {
                //
                //  Mount Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Mount Drive letter in dblspace.ini is not legal!\n"));
                continue;
            }
            //
            //  Validate CVF string
            //
            Value3 = Value2 + 1;
            ValueSize--;
            while( ValueSize != 0 ) {
                if( !SpIsDigit( *Value3 ) ) {
                    //
                    //  CVF number is not valid
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read CVF number from dblspace.ini!\n"));
                    continue;
                }
                ValueSize--;
                Value3++;
            }
            //
            //  Validate CVF number
            //
            CvfNumber = (ULONG)SpStringToLong( Value2 + 1, &AuxPointer, 10 );
            if( CvfNumber > CVF_SEQ_MAX ) {
                //
                //  CVF number is out of range
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: found an invalid CVF number in dblspace.ini!\n"));
                continue;
            }
            //
            //  Save the values read in DblspaceInfo
            //
            if( !AddCompressedDrive( SpToUpper( *Value1 ),
                                     SpToUpper( *Value2 ),
                                     ( USHORT )CvfNumber ) ) {
                //
                //  CVF number is out of range
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to initialize DblspaceInfo: out of memory!\n"));
                continue;
            }

        } else if( ( _wcsicmp( Key, KWD_FIRST ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_LAST ) == 0 ) ) {
            //
            //  Read first drive
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read FirstDrive or LastDrive from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate the drive letter
            //
            if( ( wcslen( Value1 ) != 1 ) ||
                ( !SpIsAlpha( *Value1 ) ) ) {
                //
                //  Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: FirstDrive or LastDrive in dblspace.ini is not legal!\n"));
                continue;
            }
            if( _wcsicmp( Key, KWD_FIRST ) == 0 ) {
                DblspaceInfo.FirstDrive = SpToUpper( *Value1 );
            } else {
                DblspaceInfo.LastDrive = SpToUpper( *Value1 );
            }
        } else if( ( _wcsicmp( Key, KWD_MAXFILE ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_MAXREM ) == 0 ) ) {
            //
            //  Read MaxFileFragment or MaxRemovableDrives
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read MaxFileFragments or MaxRemovableDrives
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read MaxFileFragments or MaxRemovableDrives from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate MaxFileFragments or MaxRemovableDrives
            //
            Value2 = Value1;
            ValueSize = wcslen( Value2 );
            while( ValueSize != 0 ) {
                ValueSize--;
                if( !SpIsDigit( *Value2 ) ) {
                    //
                    //  Number is not valid
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: value of MaxFileFragments or MaxRemovableDrives in dblspace.ini is not valid!\n"));
                    ValueSize = 0;
                }
                Value2++;
            }
            //
            //  Validate number
            //
            MaxNumber = (ULONG)SpStringToLong( Value1, &AuxPointer, 10 );
            //
            //  Validate and initialize MaxFileFragments or MaxRemovableDrives
            //
            if( _wcsicmp( Key, KWD_MAXFILE ) == 0 ) {
                if( MaxNumber < MINFILEFRAGMENTS ) {
                    MaxNumber = MINFILEFRAGMENTS;
                } else if( MaxNumber > MAXFILEFRAGMENTS ) {
                    MaxNumber = MAXFILEFRAGMENTS;
                }
                DblspaceInfo.MaxFileFragments = ( USHORT )MaxNumber;
            } else {
                DblspaceInfo.MaxRemovableDrives = ( MaxNumber == 0 )?
                                                  1 : ( USHORT )MaxNumber;
            }
        } else if( ( _wcsicmp( Key, KWD_DOUBLEGUARD ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_ROMSERVER ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_SWITCHES ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_AUTOMOUNT ) == 0 ) ) {
            //
            //  Read Doubleguard, Romerver, Switches, or Automount
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read Doubleguard, Romerver, Switches, or Automount
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Doubleguard, Romerver, Switches, or Automount from dblspace.ini!\n"));
                continue;
            }
            if( _wcsicmp( Key, KWD_DOUBLEGUARD ) == 0 ) {
                wcsncpy( DblspaceInfo.DoubleGuard,
                         Value1,
                         sizeof( DblspaceInfo.DoubleGuard ) / sizeof( WCHAR ) );

            } else if( _wcsicmp( Key, KWD_ROMSERVER ) == 0 ) {
                wcsncpy( DblspaceInfo.RomServer,
                         Value1,
                         sizeof( DblspaceInfo.RomServer ) / sizeof( WCHAR ) );

            } else if( _wcsicmp( Key, KWD_SWITCHES ) == 0 ) {
                wcsncpy( DblspaceInfo.Switches,
                         Value1,
                         sizeof( DblspaceInfo.Switches ) / sizeof( WCHAR ) );

            } else {
                wcsncpy( DblspaceInfo.AutoMount,
                         Value1,
                         sizeof( DblspaceInfo.AutoMount ) / sizeof( WCHAR ) );

            }

        } else {
                //
                //  Invalid key in dblspace.ini
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: dblspace.ini contains invalid key!\n"));
                continue;
        }
        LineNumber++;
    }

    SpFreeTextFile( Handle );

    //
    // Clear DblspaceModified flag, so that dblspace.ini won't get updated when
    // SpUpdateDoubleSpaceIni() is called, and no compressed drive was added or
    // deleted.
    //
    DblspaceModified = FALSE;

// DumpDblspaceInfo();
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Exiting SpLoadDblspaceIni\n"));

    return( TRUE );
}


BOOLEAN
IsHostDrive(
    IN  WCHAR            Drive,
    OUT PACTIVATE_DRIVE* Pointer
    )
/*++

Routine Description:

    Find out whether a particular drive is the host for a compressed drive.

Arguments:

    Drive -

    Pointer - Variable that will contain the pointer for an entry in the
              list of compressed drives, that describes the compressed
              drive with the lowest sequence number, whose host drive
              is the drive received as parameter.

Return Value:


    BOOLEAN - Returns TRUE if the drive passed as argument is a host drive.
              Returns FALSE otherwise.


--*/

{
    PACTIVATE_DRIVE  p;
    BOOLEAN Status;

    Status = FALSE;
    for( p = DblspaceInfo.CompressedDriveList;
         ( p && ( p->HostDrive != Drive ) );
         p = p->Next );
    if( p ) {
        *Pointer = p;
        Status = TRUE;
    }
    return( Status );
}


NTSTATUS
MountDoubleSpaceDrive(
    IN  PDISK_REGION    HostRegion,
    IN  PACTIVATE_DRIVE CompressedDriveInfo
    )
/*++

Routine Description:

    Mount a double space drive.

Arguments:

    HostRegion - Pointer to the structure that describes a FAT partition, that
                 will be the host for the compressed drive.

    CompressedDriveInfo - Pointer to a structure that contains the information
                          about the compressed drive to be mounted.


Return Value:

    NTSTATUS - Returns an NT status code indicating whether or not the drive
               was mounted.

--*/

{
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    NTSTATUS                Status;
    WCHAR                   HostName[512];
    UNICODE_STRING          UnicodeDasdName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    PIO_STATUS_BLOCK        KernelModeIoStatusBlock;
    HANDLE                  Handle;
    PFILE_MOUNT_DBLS_BUFFER KernelModeMountFsctlBuffer;


    SpNtNameFromRegion(
        HostRegion,
        HostName,
        sizeof(HostName),
        PartitionOrdinalCurrent
        );

    RtlInitUnicodeString( &UnicodeDasdName, HostName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeDasdName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    Status = ZwCreateFile( &Handle,
                           GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           OPEN_EXISTING,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: NtCreateFile failed, Status = %x\n", Status ) );
        return( Status );
    }
    //
    // Note that since we use the NtFsControlFile API instead of the
    // Zw API (this one is not exported), we need a buffer for IoStatusBlock
    // and for MountBuffer, that can be used in kernel mode.
    // We use the the region of memory pointed by CommunicationParams for this
    // purpose.
    //
    KernelModeIoStatusBlock = ( PIO_STATUS_BLOCK )( &(CommunicationParams->Buffer[0]) );
    *KernelModeIoStatusBlock = IoStatusBlock;
    KernelModeMountFsctlBuffer = ( PFILE_MOUNT_DBLS_BUFFER )( &(CommunicationParams->Buffer[128]) );

    KernelModeMountFsctlBuffer->CvfNameLength =
                                 sizeof(WCHAR) * swprintf( KernelModeMountFsctlBuffer->CvfName,
                                                           CVF_NAME_PATTERN,
                                                           CompressedDriveInfo->SeqNumber );

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              KernelModeIoStatusBlock,
                              FSCTL_MOUNT_DBLS_VOLUME,
                              KernelModeMountFsctlBuffer,
                              sizeof( FILE_MOUNT_DBLS_BUFFER ) + 12*sizeof( WCHAR ),
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to mount %ls. NtFsControlFile returned Status = %x\n",
                  KernelModeMountFsctlBuffer->CvfName, Status ) );
    }
    ZwClose( Handle );
    return( Status );
#else //FULL_DOUBLE_SPACE_SUPPORT
    return( STATUS_SUCCESS );
#endif
}


VOID
MountCompressedDrives(
    IN  PDISK_REGION    HostRegion
    )
/*++

Routine Description:

    Mount all compressed drives detected on a partition.

Arguments:

    HostRegion - Pointer to the structure that describes a FAT partition.

Return Value:

    None.

--*/

{
    PDISK_REGION    CompressedList;
    PDISK_REGION    CurrentDrive;
    PDISK_REGION    TmpPointer;
    WCHAR           HostDrive;
    PACTIVATE_DRIVE Pointer;

    CompressedList = NULL;
    CurrentDrive = NULL;
    if( ( HostRegion != NULL ) &&
        ( HostRegion->Filesystem == FilesystemFat ) &&
        IsHostDrive( HostRegion->DriveLetter, &Pointer )
      ) {
        HostDrive = HostRegion->DriveLetter;
        for( ;
             ( Pointer && ( HostDrive == Pointer->HostDrive ));
             Pointer = Pointer->Next ) {
            //
            //  Mount the drive
            //
            if( NT_SUCCESS( MountDoubleSpaceDrive( HostRegion, Pointer) ) ) {
                //
                //  Drive was mounted successfully
                //
                TmpPointer =
                    SpPtAllocateDiskRegionStructure( HostRegion->DiskNumber,
                                                     HostRegion->StartSector,
                                                     HostRegion->SectorCount,
                                                     HostRegion->PartitionedSpace,
                                                     HostRegion->MbrInfo,
                                                     HostRegion->TablePosition );
                ASSERT( TmpPointer );
                if( TmpPointer == NULL ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory\n" ) );
                    //
                    //  Unmount drive
                    //
                    continue;
                }
                TmpPointer->NextCompressed = NULL;
                TmpPointer->HostRegion = HostRegion;
                TmpPointer->Filesystem = FilesystemDoubleSpace;
                TmpPointer->SeqNumber = Pointer->SeqNumber;
                if( TmpPointer->SeqNumber == 0 ) {
                    TmpPointer->MountDrive = Pointer->HostDrive;
                    TmpPointer->HostDrive = Pointer->MountDrive;
                    HostRegion->HostDrive = TmpPointer->HostDrive;
                } else {
                    TmpPointer->MountDrive = Pointer->MountDrive;
                    if( HostRegion->HostDrive == 0 ) {
                        HostRegion->HostDrive = Pointer->HostDrive;
                    }
                    TmpPointer->HostDrive = HostRegion->HostDrive;
                }
                swprintf( TmpPointer->TypeName,
                          CVF_NAME_PATTERN,
                          TmpPointer->SeqNumber );
                if( CompressedList == NULL ) {
                    TmpPointer->PreviousCompressed = NULL;
                    CompressedList = TmpPointer;
                } else {
                    TmpPointer->PreviousCompressed = CurrentDrive;
                    CurrentDrive->NextCompressed = TmpPointer;
                }
                CurrentDrive = TmpPointer;
            }
        }

    }
    HostRegion->NextCompressed = CompressedList;
}



VOID
SpInitializeCompressedDrives()
/*++

Routine Description:

    Traverse the structure that describes all the disks in the system,
    and mount all compressed drives previously identified.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG             DiskNumber;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION      pRegion;
    unsigned          pass;

    for( DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++ ) {

        pDisk = &PartitionedDisks[DiskNumber];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                MountCompressedDrives( pRegion );
            }
        }
    }
//    DumpAllCompressedDrives();
}


VOID
SpDisposeCompressedDrives(
    PDISK_REGION    CompressedDrive
    )
/*++

Routine Description:

    Delete the list of compressed drives found in a structure
    associated with a partition in the disk.
    This function is called when the user deletes a host partition
    that contains compressed drives.
    The list of compressed drives kept in the global variable DblspaceInfo
    is updated so that it reflects the changes made by the user.


Arguments:

    CompressedDrive - Pointer to the first element of a compressed drive list.

Return Value:

    None.

--*/

{
    ASSERT( CompressedDrive->Filesystem == FilesystemDoubleSpace );

    if( CompressedDrive->NextCompressed != NULL ) {
        SpDisposeCompressedDrives( CompressedDrive->NextCompressed );
    }

    if( CompressedDrive->SeqNumber != 0 ) {
        RemoveCompressedDrive( CompressedDrive->MountDrive );
    } else {
        RemoveCompressedDrive( CompressedDrive->HostDrive );
    }
    SpMemFree( CompressedDrive );
}


BOOLEAN
SpUpdateDoubleSpaceIni()

/*++

Routine Description:

    Update dblspace.ini to reflect all changes made by the user, with respect
    to compressed drives deleted or created.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if dblspace.ini was successfully updated.
              Returns FALSE otherwise.

--*/

{
    PDISK_REGION            CColonRegion;
    WCHAR                   NtPath[ 512 ];
    UNICODE_STRING          FileName;
    NTSTATUS                Status;
    HANDLE                  Handle;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    CHAR                    Buffer[ 512 ];
    PACTIVATE_DRIVE         Pointer;


// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpUpdateDblspaceIni\n"));

    //
    // If no compressed drive was created or deleted, then do not
    // touch dblspace.ini
    //

    if( !DblspaceModified ) {
        return( TRUE );
    }
    //
    // See if there is a valid C: already.  If not, then silently fail.
    //
#ifndef _X86_

    return( FALSE );

#else

    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no dblspace.ini!\n"));
        return(FALSE);
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpPtValidSystemPartition\n"));

#endif

    //
    // Check the filesystem.  If not FAT, then silently fail.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no dblspace.ini!\n"));
        return(FALSE);
    }

    SpNtNameFromRegion(
        CColonRegion,
        NtPath,
        sizeof(NtPath),
        PartitionOrdinalCurrent
        );

    wcscat( NtPath, DBLSPACE_INI_FILE );

    Status = SpDeleteFile( NtPath, NULL, NULL );
    if( !NT_SUCCESS( Status ) &&
        ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to delete dblspace.ini, Status = %x\n",Status ) );
        return( FALSE );
    }

    //
    //  If the user deleted all compressed drives, then don't create a new
    //  dblspace.ini
    //
    // if( DblspaceInfo.CompressedDriveList == NULL ) {
    //     return( TRUE );
    // }
    //
    //  Create and write a new dblspace.ini
    //

    RtlInitUnicodeString( &FileName, NtPath );

    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwCreateFile( &Handle,
                           FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                           0,
                           FILE_OVERWRITE_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create dblspace.ini, Status = %x\n", Status ) );
        return( FALSE );
    }

    sprintf( Buffer,
             "%ls=%d\r\n",
             KWD_MAXREM,
             DblspaceInfo.MaxRemovableDrives
            );


    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          Buffer,
                          strlen( Buffer ),
                          NULL,
                          NULL );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write MaxRemovableDrives to dblspace.ini, Status = %x\n", Status ));
        ZwClose( Handle );
        return( FALSE );
    }

    if( DblspaceInfo.FirstDrive != ( WCHAR )'\0' ) {
        sprintf( Buffer,
                 "%ls=%c\r\n",
                 KWD_FIRST,
                 DblspaceInfo.FirstDrive
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write FirstDrive to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( DblspaceInfo.LastDrive != ( WCHAR )'\0' ) {
        sprintf( Buffer,
                 "%ls=%c\r\n",
                 KWD_LAST,
                 DblspaceInfo.LastDrive
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write LastDrive to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    sprintf( Buffer,
             "%ls=%d\r\n",
             KWD_MAXFILE,
             DblspaceInfo.MaxFileFragments
            );


    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          Buffer,
                          strlen( Buffer ),
                          NULL,
                          NULL );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write LastDrive to dblspace.ini, Status = %x\n", Status ));
        ZwClose( Handle );
        return( FALSE );
    }

    if( wcslen( DblspaceInfo.DoubleGuard ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_AUTOMOUNT,
                 DblspaceInfo.AutoMount
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Automount to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }


    if( wcslen( DblspaceInfo.RomServer ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_ROMSERVER,
                 DblspaceInfo.RomServer
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Romserver to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( wcslen( DblspaceInfo.Switches ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_SWITCHES,
                 DblspaceInfo.Switches
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Switches to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( wcslen( DblspaceInfo.DoubleGuard ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_DOUBLEGUARD,
                 DblspaceInfo.DoubleGuard
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Doubleguard to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    for( Pointer = DblspaceInfo.CompressedDriveList;
         Pointer;
         Pointer = Pointer->Next ) {

        sprintf( Buffer,
                 "%ls=%c,%c%d\r\n",
                  KWD_ACT,
                  Pointer->MountDrive,
                  Pointer->HostDrive,
                  Pointer->SeqNumber
                );

        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    ZwClose( Handle );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Exiting SpUpdateDblspaceIni\n"));
    return( TRUE );
}



ULONG
SpGetNumberOfCompressedDrives(
    IN  PDISK_REGION    Partition
)

/*++

Routine Description:

    Determine the number of compressed volumes on a particular partition.

Arguments:

    Partition - Pointer to the structure that describes a partition.

Return Value:

    ULONG - Returns the number of compressed drives found on the partition.

--*/

{
    ULONG           Count;
    PDISK_REGION    Pointer;

    Count = 0;

    if( ( Partition != NULL ) &&
        ( Partition->Filesystem == FilesystemFat )
      ) {
        for( Pointer = Partition->NextCompressed;
             Pointer;
             Pointer = Pointer->NextCompressed ) {
                Count++;
        }
    }
    return( Count );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdbsfmt.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblfmt.c

Abstract:

    This file contains the functions that format an existing compressed
    drive.
    To format a compressed drive we have to unmount the drive, map its
    cvf file in memory, initialize its varios regions, unmap the file
    from memory, and mount the drive.

Author:

    Jaime Sasson (jaimes) 15-October-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

#include "cvf.h"

#define MIN_CLUS_BIG    4085        // Minimum clustre for a big fat.

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtSetInformationFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;

//
//  Global variables
//

HANDLE  _FileHandle = NULL;
HANDLE  _SectionHandle = NULL;
PVOID   _FileBaseAddress = NULL;
ULONG   _ViewSize = 0;
ULONG   _Maximumcapacity = 0;

NTSTATUS
SpChangeFileAttribute(
    IN  PWSTR   FileName,
    IN  ULONG   FileAttributes
    )

/*++

Routine Description:

    Change the attributes of a file.

Arguments:

    FileName - Contains the file's full path (NT name).

    FileAttributes - New desired file attributes.


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          UnicodeFileName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    PIO_STATUS_BLOCK        KernelModeIoStatusBlock;
    HANDLE                  Handle;
    PFILE_BASIC_INFORMATION KernelModeBasicInfo;

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Entering SpChangeFileAttribute() \n" ) );

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &Handle,
                         FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwOpenFile() failed. Status = %x\n",Status ) );
        return( Status );
    }

    //
    // Set attributes.
    // Note that since we use the NtSetInformationFile API instead of the
    // Zw API (this one is not exported), we need a buffer for IoStatusBlock
    // and for FileBasicInformation, that can be used in kernel mode.
    // We use the the region of memory pointed by CommunicationParams for this
    // purpose.
    //
    KernelModeIoStatusBlock = ( PIO_STATUS_BLOCK )( &(CommunicationParams->Buffer[0]) );
    *KernelModeIoStatusBlock = IoStatusBlock;
    KernelModeBasicInfo = ( PFILE_BASIC_INFORMATION )( &(CommunicationParams->Buffer[128]) );
    RtlZeroMemory( KernelModeBasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
    KernelModeBasicInfo->FileAttributes = ( FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS ) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile( Handle,
                                   KernelModeIoStatusBlock,
                                   KernelModeBasicInfo,
                                   sizeof( FILE_BASIC_INFORMATION ),
                                   FileBasicInformation );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtSetInformationFile failed, Status = %x\n", Status) );
    }
    ZwClose( Handle );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Exiting SpChangeFileAttribute() \n" ) );
    return( Status );
}

NTSTATUS
SpMapCvfFileInMemory(
    IN  PWSTR    FileName
    )

/*++

Routine Description:

    Map a CVF file in memory.

Arguments:

    FileName - Contains the file's full path (NT name).


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.
               If the file is mapped successfully, this function will
               initialize the global variables _FileHandle, _SectionHandle,
               and _FileBaseAddress.

--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeFileName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       SectionOffset;

    //
    //  Open the CVF file for READ and WRITE access
    //
    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &_FileHandle,
                         FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwOpenFile() failed. Status = %x\n",Status ) );
        return( Status );
    }

    //
    //  Map the CVF file in memory
    //
    Status =
        ZwCreateSection( &_SectionHandle,
                         STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
                         NULL,
                         NULL,       // entire file.
                         PAGE_READWRITE,
                         SEC_COMMIT,
                         _FileHandle
                       );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwCreateSection failed, Status = %x\n",Status));
        ZwClose( _FileHandle );
        _FileHandle = NULL;
        return(Status);
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    _ViewSize = 0;
    Status = ZwMapViewOfSection( _SectionHandle,
                                 NtCurrentProcess(),
                                 &_FileBaseAddress,
                                 0,
                                 0,
                                 &SectionOffset,
                                 &_ViewSize,
                                 ViewShare,
                                 0,
                                 PAGE_READWRITE
                               );

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "File size = %x\n", _ViewSize ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwMapViewOfSection failed, Status = %x\n", Status));
        ZwClose( _SectionHandle );
        ZwClose( _FileHandle );
        _FileBaseAddress = NULL;
        _SectionHandle = NULL;
        _FileHandle = NULL;
        return(Status);
    }
    return( Status );
}


NTSTATUS
SpUnmapCvfFileFromMemory(
    IN  BOOLEAN SaveChanges
    )

/*++

Routine Description:

    Unmap the CFV file previously mapped in memory.

Arguments:

    SaveChanges - Indicates whether or not the caller wants the changes made
                  to the file flushed to disk.


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.
               This function clears the global variables _FileHandle, _SectionHandle,
               and _FileBaseAddress.

--*/

{
    NTSTATUS        Status;
    NTSTATUS        PreviousStatus;


//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Entering SpUnmapCvfFileFromMemory \n" ) );
    PreviousStatus = STATUS_SUCCESS;
    if( SaveChanges ) {
        Status = SpFlushVirtualMemory( _FileBaseAddress,
                                       _ViewSize );
//
//        Status = NtFlushVirtualMemory( NtCurrentProcess(),
//                                       &_FileBaseAddress,
//                                       &_ViewSize,
//                                       &IoStatus );
//
        if( !NT_SUCCESS( Status ) ) {
            PreviousStatus = Status;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFlushVirtualMemory() failed, Status = %x\n", Status ) );
        }
    }
    Status = ZwUnmapViewOfSection( NtCurrentProcess(), _FileBaseAddress );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwUnmapViewOfSection() failed, Status = %x \n", Status ) );
    }
    ZwClose( _SectionHandle );
    ZwClose( _FileHandle );
    _FileHandle = NULL;
    _SectionHandle = NULL;
    _FileBaseAddress = NULL;
    if( !NT_SUCCESS( PreviousStatus ) ) {
        return( PreviousStatus );
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Exiting SpUnmapCvfFileFromMemory \n" ) );
    return( Status );
}

ULONG
ComputeMaximumCapacity(
    IN ULONG HostDriveSize
    )
/*++

Routine Description:

    This function computes the maximum capacity for a compressed
    volume file on a host volume of a given size.

Arguments:

    HostDriveSize   --  Supplies the size in bytes of the host drive.

Return Value:

    The appropriate Maximum Capacity.

--*/
{
    ULONG MaxCap;

    if( HostDriveSize < 20 * 1024L * 1024L ) {

        MaxCap = 16 * HostDriveSize;

    } else if ( HostDriveSize < 64 * 1024L * 1024L ) {

        MaxCap = 8 * HostDriveSize;

    } else {

        MaxCap = 4 * HostDriveSize;
    }

    if( MaxCap < 4 * 1024L * 1024L ) {

        MaxCap = 4 * 1024L * 1024L;

    } else if( MaxCap > 512 * 1024L * 1024L ) {

        MaxCap = 512 * 1024L * 1024L;
    }

    return MaxCap;
}


BOOLEAN
CreateCvfHeader(
    OUT    PCVF_HEADER  CvfHeader,
    IN     ULONG        MaximumCapacity
    )
/*++

Routine Description:

    This function creates a Compressed Volume File and fills in
    the first sector with a valid CVF Header.  The number of sectors
    in the DOS BPB is set to zero, to indicate that this volume
    file is not initialized.

Arguments:

    CvfHeader       --  Receives the created CVF header.
    MaximumCapacity --  Supplies the maximum capacity for the
                        double-space volume, in bytes.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG Sectors, Clusters, Offset, SectorsInBitmap, SectorsInCvfFatExtension;

    if( MaximumCapacity % (8L * 1024L * 1024L) ) {

        // The volume maximum capacity must be a multiple of
        // eight megabytes.
        //
        return FALSE;
    }

    // Most of the fields in the DOS BPB have fixed values:
    //
    CvfHeader->Jump = 0xEB;
    CvfHeader->JmpOffset = 0x903c;

    memcpy( CvfHeader->Oem, "MSDSP6.0", 8 );

    CvfHeader->Bpb.BytesPerSector = DoubleSpaceBytesPerSector;
    CvfHeader->Bpb.SectorsPerCluster = DoubleSpaceSectorsPerCluster;
    // ReservedSectors computed below.
    CvfHeader->Bpb.Fats = DoubleSpaceFats;
    CvfHeader->Bpb.RootEntries = DoubleSpaceRootEntries;
    CvfHeader->Bpb.Sectors = 0;
    CvfHeader->Bpb.Media = DoubleSpaceMediaByte;
    // SectorsPerFat computed below.
    CvfHeader->Bpb.SectorsPerTrack = DoubleSpaceSectorsPerTrack;
    CvfHeader->Bpb.Heads = DoubleSpaceHeads;
    CvfHeader->Bpb.HiddenSectors = DoubleSpaceHiddenSectors;
    CvfHeader->Bpb.LargeSectors = 0;

    // Compute the number of sectors and clusters for the given
    // maximum capacity:
    //
    Sectors = MaximumCapacity / CvfHeader->Bpb.BytesPerSector;
    Clusters = Sectors / CvfHeader->Bpb.SectorsPerCluster;

    // Reserve space for a 16-bit FAT that's big enough for the
    // maximum number of clusters.
    //
    CvfHeader->Bpb.SectorsPerFat =
        ( USHORT )( (2 * Clusters + CvfHeader->Bpb.BytesPerSector - 1)/
                    CvfHeader->Bpb.BytesPerSector );

    // DOS 6.2 requires that the first sector of the Sector Heap
    // be cluster aligned; since the Root Directory is one cluster,
    // this means that ReservedSectors plus SectorsPerFat must be
    // a multiple of SectorsPerCluster.
    //
    CvfHeader->Bpb.ReservedSectors = DoubleSpaceReservedSectors;

    Offset = (CvfHeader->Bpb.ReservedSectors + CvfHeader->Bpb.SectorsPerFat) %
             CvfHeader->Bpb.SectorsPerCluster;

    if( Offset != 0 ) {

        CvfHeader->Bpb.ReservedSectors +=
            ( USHORT )( CvfHeader->Bpb.SectorsPerCluster - Offset );
    }

    // So much for the DOS BPB.  Now for the Double Space
    // BPB extensions.  The location of the CVFFatExtension
    // table is preceded by sector zero, the bitmap, and
    // one reserved sector.  Note that MaximumCapacity must
    // be a multiple of 8 Meg (8 * 1024 * 1024), which simplifies
    // calculation of SectorsInBitmap, SectorsInCvfFatExtension,
    // and CvfBitmap2KSize.
    //
    SectorsInBitmap = (Sectors / 8) / CvfHeader->Bpb.BytesPerSector;
    SectorsInCvfFatExtension = (Clusters * 4) / CvfHeader->Bpb.BytesPerSector;

    CvfHeader->CvfFatExtensionsLbnMinus1 = ( UCHAR )( SectorsInBitmap + 1 );
    CvfHeader->LogOfBytesPerSector = DoubleSpaceLog2BytesPerSector;
    CvfHeader->DosBootSectorLbn = ( USHORT )( DoubleSpaceReservedSectors2 +
                                              CvfHeader->CvfFatExtensionsLbnMinus1 + 1 +
                                              SectorsInCvfFatExtension );
    CvfHeader->DosRootDirectoryOffset =
        CvfHeader->Bpb.ReservedSectors + CvfHeader->Bpb.SectorsPerFat;
    CvfHeader->CvfHeapOffset =
        CvfHeader->DosRootDirectoryOffset + DoubleSpaceSectorsInRootDir;
    CvfHeader->CvfFatFirstDataEntry =
        CvfHeader->CvfHeapOffset / CvfHeader->Bpb.SectorsPerCluster - 2;
    CvfHeader->CvfBitmap2KSize = ( UCHAR )( SectorsInBitmap / DSSectorsPerBitmapPage );
    CvfHeader->LogOfSectorsPerCluster = DoubleSpaceLog2SectorsPerCluster;
    CvfHeader->Is12BitFat = 1;

    CvfHeader->MinFile = 32L * DoubleSpaceRootEntries +
                           ( CvfHeader->DosBootSectorLbn    +
                             CvfHeader->Bpb.ReservedSectors +
                             CvfHeader->Bpb.SectorsPerFat   +
                             CVF_MIN_HEAP_SECTORS ) *
                           CvfHeader->Bpb.BytesPerSector;

    CvfHeader->CvfMaximumCapacity = (USHORT)(MaximumCapacity/(1024L * 1024L));

    return TRUE;
}

ULONG
ComputeVirtualSectors(
    IN  PCVF_HEADER CvfHeader,
    IN  ULONG       HostFileSize
    )
/*++

Routine Description:

    This function computes the appropriate number of virtual
    sectors for the given Compressed Volume File.  Note that
    it always uses a ratio of 2.

Arguments:

    CvfHeader       --  Supplies the Compressed Volume File Header.
    HostFileSize    --  Supplies the size of the host file in bytes.

Return Value:

    The number of virtual sectors appropriate to this Compressed
    Volume File.

--*/
{
    CONST DefaultRatio = 2;
    ULONG SystemOverheadSectors, SectorsInFile,
          VirtualSectors, MaximumSectors, VirtualClusters;

    if( CvfHeader == NULL                    ||
        CvfHeader->Bpb.BytesPerSector == 0   ||
        CvfHeader->Bpb.SectorsPerCluster == 0 ) {

        return 0;
    }

    SystemOverheadSectors = CvfHeader->DosBootSectorLbn +
                            CvfHeader->CvfHeapOffset +
                            2;

    SectorsInFile = HostFileSize / CvfHeader->Bpb.BytesPerSector;

    if( SectorsInFile < SystemOverheadSectors ) {

        return 0;
    }

    VirtualSectors = (SectorsInFile - SystemOverheadSectors) * DefaultRatio +
                     CvfHeader->CvfHeapOffset;

    // VirtualSectors cannot result in more that 0xfff8 clusters on
    // the volume, nor can it be greater than the volume's maximum
    // capacity.
    //
    VirtualSectors = min( VirtualSectors,
                          ( ULONG )( 0xfff8L * CvfHeader->Bpb.SectorsPerCluster ) );

    MaximumSectors = (CvfHeader->CvfMaximumCapacity * 1024L * 1024L) /
                     CvfHeader->Bpb.BytesPerSector;

    VirtualSectors = min( VirtualSectors, MaximumSectors );

    // To avoid problems with DOS, do not create a volume with
    // a number-of-clusters value in the range [0xFEF, 0xFF7].
    //
    VirtualClusters = VirtualSectors / CvfHeader->Bpb.SectorsPerCluster;

    if( VirtualClusters >= 0xFEF && VirtualClusters <= 0xFF7 ) {

        VirtualSectors = 0xFEEL * CvfHeader->Bpb.SectorsPerCluster;
    }

    return VirtualSectors;
}


NTSTATUS
SpDoubleSpaceFormat(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    This routine does a DoubleSpace format on the given partition.

    The caller should have cleared the screen and displayed
    any message in the upper portion; this routine will
    maintain the gas gauge in the lower portion of the screen.

Arguments:

    Region - supplies the disk region descriptor for the
        partition to be formatted.

Return Value:


--*/
{
    WCHAR       CvfFileName[ 512 ];
    NTSTATUS    Status;
    PUCHAR      BaseAddress;
    ULONG       BytesPerSector;
    PHARD_DISK  pHardDisk;
    ULONG       MaximumCapacity;
    CVF_HEADER  CvfHeader;
    ULONG       BitFatSize;
    ULONG       MdFatSize;
    ULONG       Reserved2Size;
    ULONG       SuperAreaSize;
    UCHAR       SystemId;
    ULONG       max_sec_per_sa;
    ULONG       FatSize;
    ULONG       RootDirectorySize;

    ASSERT(Region->Filesystem == FilesystemDoubleSpace);
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpFormatDoubleSpace() \n") );

    SpNtNameFromRegion(
        Region,
        CvfFileName,
        sizeof(CvfFileName),
        PartitionOrdinalCurrent
        );

    CvfFileName[ wcslen( CvfFileName ) - (3+1+8+1) ] = ( WCHAR )'\\';
    //
    // Change the CVF file attribute to NORMAL
    //
    Status = SpChangeFileAttribute( CvfFileName, FILE_ATTRIBUTE_NORMAL );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to change attribute of %ls \n", CvfFileName ) );
        return( Status );
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CvfFileName = %ls \n", CvfFileName ) );
    Status = SpMapCvfFileInMemory( CvfFileName );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to map CVF file in memory \n" ) );
        SpChangeFileAttribute( CvfFileName,
                               FILE_ATTRIBUTE_READONLY |
                               FILE_ATTRIBUTE_HIDDEN |
                               FILE_ATTRIBUTE_SYSTEM );
        return( Status );
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CVF file is mapped in memory \n" ) );

    //
    // Compute the maximum capacity of the compressed drive.
    // The capacity of the compressed drive is based on the
    // size of the host size.
    //
    // Note that MaximumCapacity is rounded up to the next
    // highest multiple of 8 Meg.
    //

    pHardDisk = &HardDisks[Region->HostRegion->DiskNumber];
    BytesPerSector = pHardDisk->Geometry.BytesPerSector;
    MaximumCapacity = ComputeMaximumCapacity( Region->HostRegion->SectorCount * BytesPerSector );
    MaximumCapacity = ( ( MaximumCapacity + EIGHT_MEG - 1 ) / EIGHT_MEG ) * EIGHT_MEG;
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: MaximumCapacity = %x\n", MaximumCapacity ));
    //
    // Create the Compressed Volume File Header:
    //
    CreateCvfHeader( &CvfHeader, MaximumCapacity );

    //
    // Now fill in the value of Virtual Sectors.
    //
    CvfHeader.Bpb.LargeSectors = ComputeVirtualSectors( &CvfHeader, _ViewSize );
    if( CvfHeader.Bpb.LargeSectors >= ( ULONG )( MIN_CLUS_BIG*DoubleSpaceSectorsPerCluster ) ) {
        CvfHeader.Is12BitFat = ( UCHAR )0;
    }

    BaseAddress = ( PUCHAR )_FileBaseAddress;
    memset( BaseAddress, 0, BytesPerSector );

    //
    //  Write the CVF Header
    //
    CvfPackCvfHeader( ( PPACKED_CVF_HEADER )_FileBaseAddress, &CvfHeader );

#if 0
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CalculatedMaximumCapacity = %x, MaximumCapacity = %x \n",
             (USHORT)CvfHeader.CvfMaximumCapacity,
            *((PUSHORT)((ULONG)_FileBaseAddress + 62))
            ) );
#endif

    //
    // Initialize the BitFAT area
    //
    BaseAddress += BytesPerSector;
    BitFatSize = MaximumCapacity / ( BytesPerSector*8 );
    memset( BaseAddress, 0, BitFatSize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: BitFAT address = %x, BitFAT size = %x\n", BaseAddress, BitFatSize ));

    //
    // Initialize the 1st reserved area (Reserved1)
    //
    BaseAddress += BitFatSize;
    memset( BaseAddress, 0, BytesPerSector );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Reserved1 address = %x, Reserved1 size = %x\n", BaseAddress, BytesPerSector ));

    //
    // Initialize MDFAT
    //

    BaseAddress += BytesPerSector;
    MdFatSize = 4*( MaximumCapacity/( BytesPerSector*CvfHeader.Bpb.SectorsPerCluster ) );
    memset( BaseAddress, 0, MdFatSize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: MDFAT address = %x, MDFAT size = %x\n", BaseAddress, MdFatSize ));

    //
    // Initialize the 2nd reserved area (Reserved2)
    //

    BaseAddress += MdFatSize;
    Reserved2Size = DoubleSpaceReservedSectors2*BytesPerSector;
    memset( BaseAddress, 0, Reserved2Size );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Reserved2 address = %x, Reserved2 size = %x\n", BaseAddress, Reserved2Size ));

    //
    // Initialize Boot Sector
    //

    max_sec_per_sa = 1 +
                     2*((2*65536 - 1)/BytesPerSector + 1) +
                     ((512*32 - 1)/BytesPerSector + 1);
    BaseAddress += Reserved2Size;
    FmtFillFormatBuffer( ( ULONG )CvfHeader.Bpb.LargeSectors,
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.BytesPerSector ),
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.SectorsPerTrack ),
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.Heads ),
                         ( ULONG )CvfHeader.Bpb.HiddenSectors,
                         BaseAddress,
                         max_sec_per_sa,
                         &SuperAreaSize,
                         NULL,
                         0,
                         &SystemId );


    //
    // Initialize the 3rd reserved area (Reserved3)
    //

    BaseAddress += BytesPerSector;
    memcpy( BaseAddress, FirstDbSignature, DbSignatureLength );

    //
    // Initialize the FAT area
    //
    BaseAddress += ( ( ULONG )CvfHeader.Bpb.ReservedSectors - 1 )*BytesPerSector;;
    FatSize = ( ULONG )CvfHeader.Bpb.SectorsPerFat * BytesPerSector;
    memset( BaseAddress, 0, FatSize );
    *BaseAddress = 0xF8;
    *( BaseAddress + 1 ) = 0xFF;
    *( BaseAddress + 2 ) = 0xFF;
    if( CvfHeader.Is12BitFat == 0 ) {
        *( BaseAddress + 3 ) = 0xFF;
    }
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: FAT address = %x, Fat size = %x\n", BaseAddress, FatSize ));

    //
    // Initialize the Root Directory area
    //

    BaseAddress += FatSize;
    RootDirectorySize = DoubleSpaceSectorsInRootDir*BytesPerSector;
    memset( BaseAddress, 0, RootDirectorySize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: RootDirectory address = %x, RootDirectory size = %x\n", BaseAddress, RootDirectorySize ));

    //
    // Initialization of the 4th reserved area (Reserved4) is not necessary
    //

    //
    // Initialization of the sector heap is not necessary
    //

    //
    // Initialize the 2nd stamp
    //

    BaseAddress = ( PUCHAR )(( ULONG )_FileBaseAddress + _ViewSize - BytesPerSector);
    memset( BaseAddress, 0, BytesPerSector );
    memcpy( BaseAddress, SecondDbSignature, DbSignatureLength );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SecondStamp address = %x, SecondStamp size = %x\n", BaseAddress, BytesPerSector ));

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: _FileBaseAddress = %lx, _ViewSize = %lx\n", _FileBaseAddress, _ViewSize ) );


    SpUnmapCvfFileFromMemory( TRUE );

    SpChangeFileAttribute( CvfFileName,
                           FILE_ATTRIBUTE_READONLY |
                           FILE_ATTRIBUTE_HIDDEN |
                           FILE_ATTRIBUTE_SYSTEM );
    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdisk.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdisk.h

Abstract:

    Hard disk manipulation support for text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <ntddscsi.h>

//
// The following will be TRUE if hard disks have been determined
// successfully (ie, if SpDetermineHardDisks was successfully called).
//
BOOLEAN HardDisksDetermined = FALSE;

//
// These two globals track the hard disks attached to the computer.
//
PHARD_DISK HardDisks;
ULONG      HardDiskCount;

//
// These flags get set to TRUE if we find any disks owned
// by ATDISK or ABIOSDSK.
//
BOOLEAN AtDisksExist = FALSE;
BOOLEAN AbiosDisksExist = FALSE;

//
// Structure to track scsi ports in the system and routine to initialize
// a list of them.
//
typedef struct _MY_SCSI_PORT_INFO {

    //
    // Port number, redundant if these are stored in an array.
    //
    ULONG PortNumber;

    //
    // Port number relative to the the first port owned by the
    // adapter that owns this port.
    //
    // For example, if there are 2 Future Domain controllers and an Adaptec
    // controller, the RelativePortNumbers would be 0, 1, and 0.
    //
    ULONG RelativePortNumber;

    //
    // Name of owning miniport driver (ie, aha154x or fd8xx).
    // NULL if unknown.
    //
    PWSTR MiniportName;

} MY_SCSI_PORT_INFO, *PMY_SCSI_PORT_INFO;


//
// Disk format type strings
//
// TBD : Use the localized strings
//
WCHAR   *DiskTags[] = { DISK_TAG_TYPE_UNKNOWN,
                        DISK_TAG_TYPE_PCAT,
                        DISK_TAG_TYPE_NEC98,
                        DISK_TAG_TYPE_GPT,
                        DISK_TAG_TYPE_RAW };

VOID
SpInitializeScsiPortList(
    VOID
    );

//
// Count of scsi ports in the system.
//
ULONG ScsiPortCount;
PMY_SCSI_PORT_INFO ScsiPortInfo;

//
// Key in registry of device map
//
PCWSTR szRegDeviceMap = L"\\Registry\\Machine\\Hardware\\DeviceMap";


PWSTR
SpDetermineOwningDriver(
    IN HANDLE Handle
    );

VOID
SpGetDiskInfo(
    IN  ULONG      DiskNumber,
    IN  PVOID      SifHandle,
    IN  PWSTR      OwningDriverName,
    IN  HANDLE     Handle,
    OUT PHARD_DISK Descriptor
    );

BOOLEAN
SpGetScsiAddress(
    IN  HANDLE         Handle,
    OUT PSCSI_ADDRESS  ScsiAddress,
    OUT PWSTR         *ScsiAdapterName
    );

NTSTATUS
SpDetermineInt13Hookers(
    IN HANDLE DiskHandle,
    IN OUT PHARD_DISK Disk
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    
    if (DiskHandle && Disk) {
        PVOID   UnalignedBuffer = SpMemAlloc(Disk->Geometry.BytesPerSector * 2);

        if (UnalignedBuffer) {
            PON_DISK_MBR    Mbr = ALIGN(UnalignedBuffer, Disk->Geometry.BytesPerSector);

            Disk->Int13Hooker = NoHooker;

            Status = SpReadWriteDiskSectors(DiskHandle,
                        0,
                        1,
                        Disk->Geometry.BytesPerSector,
                        (PVOID)Mbr,
                        FALSE);


            if (NT_SUCCESS(Status)) {
                switch (Mbr->PartitionTable[0].SystemId) {
                    case 0x54:
                        Disk->Int13Hooker = HookerOnTrackDiskManager;
                        break;
                        
                    case 0x55:
                        Disk->Int13Hooker = HookerEZDrive;
                        break;
                        
                    default:
                        break;
                }
            }                    

            SpMemFree(UnalignedBuffer);
        } else {
            Status = STATUS_NO_MEMORY;
        }            
    }

    return Status;
}

   
NTSTATUS
SpDetermineHardDisks(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine the hard disks attached to the computer and
    the state they are in (ie, on-line, off-line, removed, etc).

Arguments:

    SifHandle - handle to main setup information file.

Return Value:

    STATUS_SUCCESS   - operation successful.

    The global variables HardDisks and
    HardDiskCount are filled in if STATUS_SUCCESS.

--*/

{
    PCONFIGURATION_INFORMATION ConfigInfo;
    ULONG disk;
    PWSTR OwningDriverName;
    ULONG remainder;
    LARGE_INTEGER temp;
    PARTITION_INFORMATION PartitionInfo;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Determine the number of hard disks attached to the system
    // and allocate space for an array of Disk Descriptors.
    //
    ConfigInfo = IoGetConfigurationInformation();
    HardDiskCount = ConfigInfo->DiskCount;

    if ( HardDiskCount != 0 ) {
        HardDisks = SpMemAlloc(HardDiskCount * sizeof(HARD_DISK));
        RtlZeroMemory(HardDisks,HardDiskCount * sizeof(HARD_DISK));
    }

    SpInitializeScsiPortList();

    //
    // For each disk, fill in its device path in the nt namespace
    // and get information about the device.
    //

    for(disk=0; disk<HardDiskCount; disk++) {

        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;
        HANDLE Handle;
        PHARD_DISK Descriptor;
        FILE_FS_DEVICE_INFORMATION DeviceInfo;

        Descriptor = &HardDisks[disk];

        swprintf(Descriptor->DevicePath,L"\\Device\\Harddisk%u",disk);

        //
        // Assume off-line.
        //
        Descriptor->Status = DiskOffLine;

        SpFormatMessage(
            Descriptor->Description,
            sizeof(Descriptor->Description),
            SP_TEXT_UNKNOWN_DISK_0
            );

        //
        // Open partition0 of the disk.  This should succeed even if
        // there is no media in the drive.
        //
        Status = SpOpenPartition0(Descriptor->DevicePath,&Handle,FALSE);
        if(!NT_SUCCESS(Status)) {
            continue;
        }
        
        //
        // Determine device characteristics (fixed/removable).
        // If this fails, assume that the disk is fixed and off-line.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Save device characteristic information.
            //
            ASSERT(DeviceInfo.DeviceType == FILE_DEVICE_DISK);
            ASSERT((DeviceInfo.Characteristics & (FILE_FLOPPY_DISKETTE | FILE_REMOTE_DEVICE)) == 0);
            Descriptor->Characteristics = DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: unable to determine device characteristics for %ws (%lx)\n",Descriptor->DevicePath,Status));
            ZwClose(Handle);
            continue;
        }

        //
        // Attempt to get geometry.
        // If this fails, then assume the disk is off-line.
        //
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &Descriptor->Geometry,
                    sizeof(DISK_GEOMETRY)
                    );

        if(NT_SUCCESS(Status)) {

            Descriptor->CylinderCount = Descriptor->Geometry.Cylinders.QuadPart;

            //
            // Calculate some additional geometry information.
            //
            Descriptor->SectorsPerCylinder = Descriptor->Geometry.SectorsPerTrack
                                           * Descriptor->Geometry.TracksPerCylinder;

#if defined(_IA64_)            
            Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PARTITION_INFORMATION)
                );
            if (NT_SUCCESS(Status)) {
                Descriptor->DiskSizeSectors = (PartitionInfo.PartitionLength.QuadPart) / 
                    (Descriptor->Geometry.BytesPerSector);
            }
            else {
#endif
                Descriptor->DiskSizeSectors = RtlExtendedIntegerMultiply(
                                                    Descriptor->Geometry.Cylinders,
                                                    Descriptor->SectorsPerCylinder
                                                    ).LowPart;
#if defined(_IA64_)            
            }
#endif
            if (IsNEC_98) { //NEC98
                //
                // Used last cylinder by T&D
                //
                Descriptor->DiskSizeSectors -= Descriptor->SectorsPerCylinder;
            } //NEC98

            Descriptor->Status = DiskOnLine;

            //
            // Calculate the size of the disk in MB.
            //
            temp.QuadPart = UInt32x32To64(
                                Descriptor->DiskSizeSectors,
                                Descriptor->Geometry.BytesPerSector
                                );

            Descriptor->DiskSizeMB = RtlExtendedLargeIntegerDivide(temp,1024*1024,&remainder).LowPart;
            if(remainder >= 512) {
                Descriptor->DiskSizeMB++;
            }

            //
            // Now that we know how big the disk is, change the default disk name.
            //
            SpFormatMessage(
                Descriptor->Description,
                sizeof(Descriptor->Description),
                SP_TEXT_UNKNOWN_DISK_1,
                Descriptor->DiskSizeMB
                );

            //
            // Attempt to get the disk signature.
            //
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer)
                        );

            if(NT_SUCCESS(Status)) {
                PDRIVE_LAYOUT_INFORMATION_EX    DriveLayoutEx = 
                                (PDRIVE_LAYOUT_INFORMATION_EX)TemporaryBuffer;

                if (DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR)                               
                    Descriptor->Signature = (( PDRIVE_LAYOUT_INFORMATION )TemporaryBuffer)->Signature;

                Descriptor->DriveLayout = *DriveLayoutEx;

                switch (DriveLayoutEx->PartitionStyle) {
                    case PARTITION_STYLE_MBR:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_PCAT;

                        //
                        // Determine if any INT13 hookers are present
                        //
                        SpDetermineInt13Hookers(Handle, Descriptor);

#if defined(_IA64_)            
                        //
                        // Make sure that this is not a raw disk
                        // which is being faked as MBR disk
                        //
                        if (SpPtnIsRawDiskDriveLayout(DriveLayoutEx)) {
                            Descriptor->FormatType = DISK_FORMAT_TYPE_RAW;
                            SPPT_SET_DISK_BLANK(disk, TRUE);
                        }                                                    
#endif                    
                        
                        break;
                        
                    case PARTITION_STYLE_GPT:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_GPT;
                        break;
                        
                    case PARTITION_STYLE_RAW:                    
                        Descriptor->FormatType = DISK_FORMAT_TYPE_RAW;
                        SPPT_SET_DISK_BLANK(disk, TRUE);
                        
                        break;

                    default:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_UNKNOWN;
                        break;
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: failed to get signature for %ws (%lx)\n",Descriptor->DevicePath,Status));
                Descriptor->Signature = 0;
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: failed to get geometry for %ws (%lx)\n",Descriptor->DevicePath,Status));
            ZwClose(Handle);
            continue;
        }

        //
        // NEC98: force removable media to OFFLINE.
        // Because NEC98 doesnot support FLEX boot, so NT cannot boot up
        // from removable media.
        //
        if (IsNEC_98 && (Descriptor->Characteristics & FILE_REMOVABLE_MEDIA)) {
            Descriptor->Status = DiskOffLine;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found removable disk. force offline %ws\n", Descriptor->DevicePath));
        }

        //
        // Now go through the device object to determine the device driver
        // that owns this disk.
        //
        if(OwningDriverName = SpDetermineOwningDriver(Handle)) {

            SpGetDiskInfo(disk,SifHandle,OwningDriverName,Handle,Descriptor);
            SpMemFree(OwningDriverName);
        }

        ZwClose(Handle);
    }

    HardDisksDetermined = TRUE;
    return(STATUS_SUCCESS);
}


VOID
SpGetDiskInfo(
    IN  ULONG      DiskNumber,
    IN  PVOID      SifHandle,
    IN  PWSTR      OwningDriverName,
    IN  HANDLE     Handle,
    OUT PHARD_DISK Descriptor
    )
{
    PWSTR FormatString;
    PWSTR ScsiAdapterName;
    PWSTR PcCardInfoKey;
    SCSI_ADDRESS ScsiAddress;
    NTSTATUS Status;
    ULONG ValLength;
    PKEY_VALUE_PARTIAL_INFORMATION p;
    IO_STATUS_BLOCK IoStatusBlock;
    DISK_CONTROLLER_NUMBER ControllerInfo;

    PcCardInfoKey = NULL;

    //
    // Look up the driver in the map in txtsetup.sif.
    // Note that the driver could be one we don't recognize.
    //
    FormatString = SpGetSectionKeyIndex(SifHandle,SIF_DISKDRIVERMAP,OwningDriverName,0);

#ifdef _X86_
    //
    // Assume not SCSI and thus no scsi-style ARC name.
    //
    Descriptor->ArcPath[0] = 0;
    Descriptor->ScsiMiniportShortname[0] = 0;
#endif

    if(FormatString) {

        if(_wcsicmp(OwningDriverName,L"disk")) {

            //
            // Non-scsi.
            //
            SpFormatMessageText(
                Descriptor->Description,
                sizeof(Descriptor->Description),
                FormatString,
                Descriptor->DiskSizeMB
                );

            if(!_wcsicmp(OwningDriverName,L"atdisk")) {

                AtDisksExist = TRUE;

                //
                // Get controller number for atdisks.
                //
                Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_DISK_CONTROLLER_NUMBER,
                            NULL,
                            0,
                            &ControllerInfo,
                            sizeof(DISK_CONTROLLER_NUMBER)
                            );

                if(NT_SUCCESS(Status)) {

                    swprintf(
                        TemporaryBuffer,
                        L"%ws\\AtDisk\\Controller %u",
                        szRegDeviceMap,
                        ControllerInfo.ControllerNumber
                        );

                    PcCardInfoKey = SpDupStringW(TemporaryBuffer);

                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get controller number (%lx)\n",Status));
                }
            } else if(!IsNEC_98) {
                //
                // Not AT disk, might be abios disk. (NEC98 does not have ABIOS disk.)
                //
                if(!_wcsicmp(OwningDriverName,L"abiosdsk")) {
                    AbiosDisksExist = TRUE;
                }
            }

        } else {
            //
            // Scsi. Get disk address info.
            //
            if(SpGetScsiAddress(Handle,&ScsiAddress,&ScsiAdapterName)) {

                swprintf(
                    TemporaryBuffer,
                    L"%ws\\Scsi\\Scsi Port %u",
                    szRegDeviceMap,
                    ScsiAddress.PortNumber
                    );

                PcCardInfoKey = SpDupStringW(TemporaryBuffer);

                SpFormatMessageText(
                    Descriptor->Description,
                    sizeof(Descriptor->Description),
                    FormatString,
                    Descriptor->DiskSizeMB,
                    ScsiAddress.Lun,
                    ScsiAddress.TargetId,
                    ScsiAddress.PathId,
                    ScsiAdapterName
                    );

#ifdef _X86_
                //
                // Generate "secondary" arc path.
                //

                _snwprintf(
                    Descriptor->ArcPath,
                    sizeof(Descriptor->ArcPath)/sizeof(WCHAR),
                    L"scsi(%u)disk(%u)rdisk(%u)",
                    ScsiPortInfo[ScsiAddress.PortNumber].RelativePortNumber,
                    SCSI_COMBINE_BUS_TARGET(ScsiAddress.PathId, ScsiAddress.TargetId),
                    ScsiAddress.Lun
                    );

                wcsncpy(
                    Descriptor->ScsiMiniportShortname,
                    ScsiAdapterName,
                    (sizeof(Descriptor->ScsiMiniportShortname)/sizeof(WCHAR))-1
                    );
#endif

                SpMemFree(ScsiAdapterName);

            } else {

                //
                // Some drivers, like SBP2PORT (1394), don't support
                // IOCTL_SCSI_GET_ADDRESS, so just display driver name.
                //

                SpFormatMessage(
                    Descriptor->Description,
                    sizeof (Descriptor->Description),
                    SP_TEXT_UNKNOWN_DISK_2,
                    Descriptor->DiskSizeMB,
                    OwningDriverName
                    );
            }
        }
    }

    //
    // Determine whether the disk is pcmcia.
    //
    if(PcCardInfoKey) {

        Status = SpGetValueKey(
                    NULL,
                    PcCardInfoKey,
                    L"PCCARD",
                    sizeof(TemporaryBuffer),
                    (PCHAR)TemporaryBuffer,
                    &ValLength
                    );

        if(NT_SUCCESS(Status)) {

            p = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

            if((p->Type == REG_DWORD) && (p->DataLength == sizeof(ULONG)) && *(PULONG)p->Data) {

                Descriptor->PCCard = TRUE;
            }
        }

        SpMemFree(PcCardInfoKey);
    }
}


BOOLEAN
SpGetScsiAddress(
    IN  HANDLE         Handle,
    OUT PSCSI_ADDRESS  ScsiAddress,
    OUT PWSTR         *ScsiAdapterName
    )

/*++

Routine Description:

    Get scsi address information about a device.  This includes
    the port, bus, id, and lun, as well as the shortname of the miniport
    driver that owns the device.

Arguments:

    Handle - handle to open device.

    ScsiAddress - receives port, bus, id, and lun for the device described by Handle.

    ScsiAdapterName - receives pointer to buffer containing shortname
        for miniport driver that owns the device (ie, aha154x).
        The caller must free this buffer via SpMemFree().

Return Value:

    TRUE - scsi address information was determined successfully.
    FALSE - error determining scsi address information.

--*/

{
    NTSTATUS Status;
    PWSTR MiniportName = NULL;
    IO_STATUS_BLOCK IoStatusBlock;

    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_SCSI_GET_ADDRESS,
                NULL,
                0,
                ScsiAddress,
                sizeof(SCSI_ADDRESS)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get scsi address info (%lx)\n",Status));
        return(FALSE);
    }

    //
    // We can get the miniport name from the scsi port information list
    // we built earlier.
    //
    if(ScsiAddress->PortNumber < ScsiPortCount) {

        MiniportName = ScsiPortInfo[ScsiAddress->PortNumber].MiniportName;

    } else {

        //
        // This should not happen.
        //
        ASSERT(ScsiAddress->PortNumber < ScsiPortCount);

        MiniportName = TemporaryBuffer;
        SpFormatMessage(MiniportName,sizeof(TemporaryBuffer),SP_TEXT_UNKNOWN);
    }

    *ScsiAdapterName = SpDupStringW(MiniportName);

    return(TRUE);
}


PWSTR
SpDetermineOwningDriver(
    IN HANDLE Handle
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_INFORMATION HandleInfo;
    PFILE_OBJECT FileObject;
    ULONG ObjectNameLength;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    PWSTR OwningDriverName;

    //
    // Get the file object for the disk device.
    //
    Status = ObReferenceObjectByHandle(
                Handle,
                0L,
                *IoFileObjectType,
                ExGetPreviousMode(),
                &FileObject,
                &HandleInfo
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDetermineOwningDriver: unable to reference object (%lx)\n",Status));
        return(NULL);
    }

    //
    // Follow the links to the driver object and query the name.
    //
    ObjectNameInfo = (POBJECT_NAME_INFORMATION)TemporaryBuffer;

    Status = ObQueryNameString(
                FileObject->DeviceObject->DriverObject,
                ObjectNameInfo,
                sizeof(TemporaryBuffer),
                &ObjectNameLength
                );

    //
    // Dereference the file object now that we've got the name.
    //
    ObDereferenceObject(FileObject);

    //
    // Check the status of the name query.
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDetermineOwningDriver: unable to query name string (%lx)\n",Status));
        return(NULL);
    }

    //
    // Pull out the name of the owning driver.
    //
    if(OwningDriverName = wcsrchr(ObjectNameInfo->Name.Buffer,L'\\')) {
        OwningDriverName++;
    } else {
        OwningDriverName = ObjectNameInfo->Name.Buffer;
    }

    return(SpDupStringW(OwningDriverName));
}


VOID
SpInitializeScsiPortList(
    VOID
    )
{
    ULONG port;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE PortHandle;
    ULONG RelativeNumber;

    //
    // Get the number of scsi ports in the system.
    //
    ScsiPortCount = IoGetConfigurationInformation()->ScsiPortCount;

    //
    // Allocate an array to hold information about each port.
    //
    ScsiPortInfo = SpMemAlloc(ScsiPortCount * sizeof(MY_SCSI_PORT_INFO));
    RtlZeroMemory(ScsiPortInfo,ScsiPortCount * sizeof(MY_SCSI_PORT_INFO));

    //
    // Iterate through the ports.
    //
    for(port=0; port<ScsiPortCount; port++) {

        ScsiPortInfo[port].PortNumber = port;

        //
        // Open \device\scsiport<n> so we can determine the owning miniport.
        //
        swprintf(TemporaryBuffer,L"\\Device\\ScsiPort%u",port);

        INIT_OBJA(&ObjectAttributes,&UnicodeString,TemporaryBuffer);

        Status = ZwCreateFile(
                    &PortHandle,
                    FILE_GENERIC_READ,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            ScsiPortInfo[port].MiniportName = SpDetermineOwningDriver(PortHandle);

            ZwClose(PortHandle);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open \\device\\scsiport%u (%lx)\n",port,Status));
        }

        //
        // Determine relative port number.  If this is port 0 or the current port owner
        // doesn't match the previous port owner, then the relative port number is 0.
        // Otherwise the relative port number is one greater than the previous relative
        // port number.
        //

        if(port && ScsiPortInfo[port-1].MiniportName && ScsiPortInfo[port].MiniportName
        && !_wcsicmp(ScsiPortInfo[port-1].MiniportName,ScsiPortInfo[port].MiniportName)) {
            RelativeNumber++;
        } else {
            RelativeNumber = 0;
        }

        ScsiPortInfo[port].RelativePortNumber = RelativeNumber;
    }
}



NTSTATUS
SpOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    )
{
    PWSTR             PartitionPath;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;

    //
    // Form the pathname of partition.
    //
    PartitionPath = SpMemAlloc((wcslen(DiskDevicePath) * sizeof(WCHAR)) + sizeof(L"\\partition000"));
    if(PartitionPath == NULL) {
        return(STATUS_NO_MEMORY);
    }

    swprintf(PartitionPath,L"%ws\\partition%u",DiskDevicePath,PartitionNumber);

    //
    // Attempt to open partition0.
    //
    INIT_OBJA(&Obja,&UnicodeString,PartitionPath);

    Status = ZwCreateFile(
                Handle,
                FILE_GENERIC_READ | (NeedWriteAccess ? FILE_GENERIC_WRITE : 0),
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",PartitionPath,Status));
    }

    SpMemFree(PartitionPath);

    return(Status);
}


NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONGLONG SectorNumber,
    IN     ULONG  SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOLEAN Write
    )

/*++

Routine Description:

    Reads or writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //
    IoOffset.QuadPart = UInt32x32To64(SectorNumber,BytesPerSector);
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //
    Status = (NTSTATUS)(

                Write

             ?
                ZwWriteFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    AlignedBuffer,
                    IoSize,
                    &IoOffset,
                    NULL
                    )
             :
                ZwReadFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    AlignedBuffer,
                    IoSize,
                    &IoOffset,
                    NULL
                    )
             );


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to %s %u sectors starting at sector %u\n",Write ? "write" : "read" ,SectorCount,SectorNumber));
    }

    return(Status);
}


ULONG
SpArcDevicePathToDiskNumber(
    IN PWSTR ArcPath
    )

/*++

Routine Description:

    Given an arc device path, determine which NT disk it represents.

Arguments:

    ArcPath - supplies arc path.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

    -1 if cannot be determined.

--*/

{
    PWSTR NtPath;
    ULONG DiskNumber;
    ULONG PrefixLength;

    //
    // Assume failure.
    //
    DiskNumber = (ULONG)(-1);
    PrefixLength = wcslen(DISK_DEVICE_NAME_BASE);

    //
    // Convert the path to an nt path.
    //
    if((NtPath = SpArcToNt(ArcPath))
    && !_wcsnicmp(NtPath,DISK_DEVICE_NAME_BASE,PrefixLength))
    {
        DiskNumber = (ULONG)SpStringToLong(NtPath+PrefixLength,NULL,10);
        SpMemFree(NtPath);
    }

    return(DiskNumber);
}


BOOLEAN
SpIsRegionBeyondCylinder1024(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    This routine figures out whether a disk region contains sectors
    that are on cylinders beyond cylinder 1024.

Arguments:

    Region - supplies the disk region for the partition to be checked.

Return Value:

    BOOLEAN - Returns TRUE if the region contains a sector located in cylinder
              1024 or greater. Otherwise returns FALSE.

--*/

{
    ULONGLONG LastSector;
    ULONGLONG LastCylinder;

    if (IsNEC_98) { //NEC98
        //
        // NEC98 has no "1024th cylinder limit".
        //
        return((BOOLEAN)FALSE);
    } //NEC98

    if (Region->DiskNumber == 0xffffffff) {
        return FALSE; //  Partition is a redirected drive
    }

    LastSector = Region->StartSector + Region->SectorCount - 1;
    LastCylinder = LastSector / HardDisks[Region->DiskNumber].SectorsPerCylinder;

    return  ((BOOLEAN)(LastCylinder > 1023));

}

VOID
SpAppendDiskTag(
    IN PHARD_DISK   Disk
    )
{
    if (Disk) {
        PWSTR   TagStart = wcsrchr(Disk->Description, DISK_TAG_START_CHAR);

        if (TagStart) {
            if (wcscmp(TagStart, DiskTags[0]) && wcscmp(TagStart, DiskTags[1]) &&
                wcscmp(TagStart, DiskTags[2]) && wcscmp(TagStart, DiskTags[3]) &&
                wcscmp(TagStart, DiskTags[4])) {

                //
                // not the tag we were looking for
                //
                TagStart = Disk->Description + wcslen(Disk->Description);
            }         
        } else {
            TagStart = Disk->Description + wcslen(Disk->Description);
            *TagStart = L' ';
            TagStart++;            
        }            

        wcscpy(TagStart, DiskTags[Disk->FormatType]);
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcopy.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spcopy.c

Abstract:

    File copy/decompression routines for text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

    02-Oct-1996  jimschm  Added SpMoveWin9xFiles
    12-Dec-1996  jimschm  SpMoveWin9xFiles now moves paths
                          based on WINNT.SIF instructions
    24-Feb-1997  jimschm  Added SpDeleteWin9xFiles

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"

//
// This structure is used during an OEM preinstall.
// It is used to form the list of files that were installed in the system, that
// have a short target name, instead of the corresponding long target name.
//
typedef struct _FILE_TO_RENAME {

    struct _FILE_TO_RENAME *Next;

    //
    // Name of the file to be copied, as it exists on the source media
    // (short file name part only -- no paths).
    //
    PWSTR SourceFilename;

    //
    // Directory to which this file is to be copied.
    //
    PWSTR TargetDirectory;

    //
    // Name of file as it should exist on the target (long name).
    //
    PWSTR TargetFilename;

} FILE_TO_RENAME, *PFILE_TO_RENAME;

//
// Structures used to hold lists of files and directories for SpCopyDirRecursive.
//

typedef struct _COPYDIR_FILE_NODE {
    LIST_ENTRY SiblingListEntry;
    WCHAR Name[1];
} COPYDIR_FILE_NODE, *PCOPYDIR_FILE_NODE;

typedef struct _COPYDIR_DIRECTORY_NODE {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY SubdirectoryList;
    LIST_ENTRY FileList;
    struct _COPYDIR_DIRECTORY_NODE *Parent;
    WCHAR Name[1];
} COPYDIR_DIRECTORY_NODE, *PCOPYDIR_DIRECTORY_NODE;

//
//  List used on an OEM preinstall.
//  It contains the name of the files that need to be added to $$RENAME.TXT
//
PFILE_TO_RENAME RenameList = NULL;


//
// Remember whether or not we write out an ntbootdd.sys
//
BOOLEAN ForceBIOSBoot = FALSE;
HARDWAREIDLIST *HardwareIDList = NULL;

//
// global variables for delayed driver CAB opening during
// repair
//
extern PWSTR    gszDrvInfDeviceName;
extern PWSTR    gszDrvInfDirName;
extern HANDLE   ghSif;

#define ATTR_RHS (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE)

PVOID FileCopyGauge;
PVOID FileDeleteGauge;

PVOID   _SetupLogFile = NULL;
PVOID   _LoggedOemFiles = NULL;

extern PCMDCON_BLOCK  gpCmdConsBlock;

//
//  List of oem inf files installed as part of the installation of third party drivers
//
POEM_INF_FILE   OemInfFileList = NULL;
//
//  Name of the directory where OEM files need to be copied, if a catalog file (.cat) is part of
//  the third party driver package that the user provide using the F6 or F5 key.
//
PWSTR OemDirName = L"OemDir";

#if defined(REMOTE_BOOT)
HANDLE SisRootHandle = NULL;
#endif // defined(REMOTE_BOOT)


VOID
SpLogOneFile(
    IN PFILE_TO_COPY    FileToCopy,
    IN PWSTR            Sysroot,
    IN PWSTR            DirectoryOnSourceDevice,
    IN PWSTR            DiskDescription,
    IN PWSTR            DiskTag,
    IN ULONG            CheckSum
    );

BOOLEAN
SpRemoveEntryFromCopyList(
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory
    );


PVOID
SppRetrieveLoggedOemFiles(
    PVOID   OldLogFile
    );

VOID
SppMergeLoggedOemFiles(
    IN PVOID DestLogHandle,
    IN PVOID OemLogHandle,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR NtPartition
    );

BOOLEAN
SppIsFileLoggedAsOemFile(
    IN PWSTR FilePath
    );

BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

VOID
SppMergeRenameFiles(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    );

VOID
SppCopyOemDirectories(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    );

NTSTATUS
SpOpenFileInDriverCab(
    IN PCWSTR SourceFileName,
    IN PVOID SifHandle,
    OUT HANDLE *SourceHandle
    );

BOOLEAN
pSpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    );

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


BOOLEAN
SpCreateDirectory(
    IN PCWSTR DevicePath,       OPTIONAL
    IN PCWSTR RootDirectory,    OPTIONAL
    IN PCWSTR Directory,
    IN ULONG DirAttrs           OPTIONAL,
    IN ULONG CreateFlags        OPTIONAL
    )

/*++

Routine Description:

    Create a directory.  All containing directories are created to ensure
    that the directory can be created.  For example, if the directory to be
    created is \a\b\c, then this routine will create \a, \a\b, and \a\b\c
    in that order.

Arguments:

    DevicePath - supplies pathname to the device on which the directory
        is to be created.

    RootDirectory - if specified, supplies a fixed portion of the directory name,
        which may or may not have been already created. The directory being created will be
        concatenated to this value.

    Directory - supplies directory to be created on the device. You may use
        this to specify a full NT path (pass in NULL for DevicePath and
        RootDirectory).

Return Value:

    None.  Does not return if directry could not successfully be created.

--*/

{
    PWSTR p,q,r,EntirePath, z, NewName;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG DevicePartLen;
    BOOL TriedOnce;
    BOOLEAN SkippedFile = FALSE;
    static ULONG u = 0;

    ASSERT (Directory);

    NewName = NULL;

    //
    // Do not bother attempting to create the root directory.
    //
    if((Directory[0] == 0) || ((Directory[0] == L'\\') && (Directory[1] == 0))) {
        return TRUE;
    }

    //
    // Fill up TemporaryBuffer with the full pathname of the directory being
    // created. If DevicePath is NULL, TemporaryBuffer will be filled with one
    // backslash. Because Directory is required, this ensures the path starts
    // with a backslash.
    //
    p = TemporaryBuffer;
    *p = 0;
    SpConcatenatePaths(p,DevicePath);
    DevicePartLen = wcslen(p);

    if(RootDirectory) {
        SpConcatenatePaths(p,RootDirectory);
    }

    SpConcatenatePaths(p,Directory);

    //
    // Make a duplicate of the path being created.
    //
    EntirePath = SpDupStringW(p);

    if (!EntirePath) {
        return FALSE; // ran out of memory
    }

    //
    // Make q point to the first character in the directory
    // part of the pathname (ie, 1 char past the end of the device name).
    //
    q = EntirePath + DevicePartLen;

    //
    // Note: It is possible for the device path to end in a '\', so we may need
    // to backup one character
    //
    if (*q != L'\\') {
        q--;
    }
    ASSERT(*q == L'\\');

    //
    // Make r point to the first character in the directory
    // part of the pathname.  This will be used to keep the status
    // line updated with the directory being created.
    //
    r = q;

    //
    // Make p point to the first character following the first
    // \ in the directory part of the full path.
    //
    p = q+1;

    do {

        //
        // find the next \ or the terminating 0.
        //
        q = wcschr(p,L'\\');

        //
        // If we found \, terminate the string at that point.
        //
        if(q) {
            *q = 0;
        }

        do {
            if( !HeadlessTerminalConnected ) {
                SpDisplayStatusText(SP_STAT_CREATING_DIRS,DEFAULT_STATUS_ATTRIBUTE,r);
            } else {

                PWCHAR TempPtr = NULL;
                //
                // If we're headless, we need to be careful about displaying very long
                // file/directory names.  For that reason, just display a little spinner.
                //
                switch( u % 4) {
                case 0:
                    TempPtr = L"-";
                    break;
                case 1:
                    TempPtr = L"\\";
                    break;
                case 2:
                    TempPtr = L"|";
                    break;
                default:
                    TempPtr = L"/";
                    break;

                }

                SpDisplayStatusText( SP_STAT_CREATING_DIRS,DEFAULT_STATUS_ATTRIBUTE, TempPtr );

                u++;

            }

            //
            // Create or open the directory whose name is in EntirePath.
            //
            INIT_OBJA(&Obja,&UnicodeString,EntirePath);
            Handle = NULL;
            TriedOnce = FALSE;

tryagain:
            Status = ZwCreateFile(
                        &Handle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL | DirAttrs,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                        NULL,
                        0
                        );


            //
            // If it's an obdirectory, obsymlink, device, or directory, then they just didn't pass
            // a long enough DevicePath. Let this by.
            //
            if (Status == STATUS_NOT_A_DIRECTORY) {
                //
                //Could be that a file exists by that name. Rename it out of the way
                //

                if( SpFileExists( EntirePath, FALSE ) && !TriedOnce){

                    z = TemporaryBuffer;
                    wcscpy( z, EntirePath );
                    wcscat( z, L".SetupRenamedFile" );

                    NewName = SpDupStringW( z );
                    if( !NewName )
                        return FALSE; //out of memory - bugcheck (never gets here) - but this keeps PREFIX happy


                    Status = SpRenameFile( EntirePath, NewName, FALSE );

                    if( NT_SUCCESS(Status)){

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Renamed file %ws to %ws\n", r, NewName));

                        TriedOnce = TRUE;
                        goto tryagain;


                    }else{

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to rename file %ws (%lx)\n", r, Status));

                    }

                }
            }

            if(!NT_SUCCESS(Status)) {

                BOOLEAN b = TRUE;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create dir %ws (%lx)\n", r, Status));

                if (CreateFlags & CREATE_DIRECTORY_FLAG_SKIPPABLE) {
                    SkippedFile = TRUE;
                    goto SkippedFileQuit;
                }

                //
                // Tell user we couldn't do it.  Options are to retry or exit.
                //
                while(b) {

                    SpStartScreen(
                        SP_SCRN_DIR_CREATE_ERR,
                        3,
                        HEADER_HEIGHT+1,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE,
                        r
                        );

                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_RETRY,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

                    switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                    case ASCI_CR:
                        b = FALSE;
                        break;
                    case KEY_F3:
                        SpConfirmExit();
                        break;
                    }
                }
            }

        } while(!NT_SUCCESS(Status));

        if (Handle != NULL)
            ZwClose(Handle);

        //
        // Unterminate the current string if necessary.
        //
        if(q) {
            *q = L'\\';
            p = q+1;
        }

    } while(*p && q);       // *p catches string ending in '\'

SkippedFileQuit:
    SpMemFree(EntirePath);
    if( NewName )
        SpMemFree(NewName);

    return !SkippedFile;
}

VOID
SpCreateDirStructWorker(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

    Create a set of directories that are listed in a setup information file
    section.  The expected format is as follows:

    [SectionName]
    shortname = directory
    shortname = directory
            .
            .
            .

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection - supplies name of section in the setup information file
        containing directories to be created.

    DevicePath - supplies pathname to the device on which the directory
        structure is to be created.

    RootDirectory - supplies a root directory, relative to which the
        directory structure will be created.

Return Value:

    None.  Does not return if directory structure could not be created.

--*/

{
    ULONG Count;
    ULONG d;
    PWSTR Directory;


    //
    // Count the number of directories to be created.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);
    if(!Count) {
        if(Fatal) {
            SpFatalSifError(SifHandle,SifSection,NULL,0,0);
        } else {
            return;
        }
    }

    for(d=0; d<Count; d++) {

        Directory = SpGetSectionLineIndex(SifHandle,SifSection,d,0);
        if(!Directory) {
            SpFatalSifError(SifHandle,SifSection,NULL,d,0);
        }

        SpCreateDirectory(DevicePath,RootDirectory,Directory,0,0);
    }
}


VOID
SpCreateDirectoryStructureFromSif(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory
    )

/*++

Routine Description:

    Create a set of directories that are listed in a setup information file
    section. The expected format is as follows:

    [SectionName]
    shortname = directory
    shortname = directory
            .
            .
            .

    [SectionName.<platform>]
    shortname = directory
    shortname = directory
            .
            .
            .

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection - supplies name of section in the setup information file
        containing directories to be created.

    DevicePath - supplies pathname to the device on which the directory
        structure is to be created.

    RootDirectory - supplies a root directory, relative to which the
        directory structure will be created.

Return Value:

    None.  Does not return if directory structure could not be created.

--*/

{
    PWSTR p;

    //
    // Create the root directory.
    //
    SpCreateDirectory(DevicePath,NULL,RootDirectory,HideWinDir?FILE_ATTRIBUTE_HIDDEN:0,0);

    //
    // Create platform-indepdenent directories
    //
    SpCreateDirStructWorker(SifHandle,SifSection,DevicePath,RootDirectory,TRUE);

    //
    // Create platform-depdenent directories
    //
    p = SpMakePlatformSpecificSectionName(SifSection);

    if (p) {
        SpCreateDirStructWorker(SifHandle,p,DevicePath,RootDirectory,FALSE);
        SpMemFree(p);
    }
}


VOID
SpGetFileVersion(
    IN  PVOID      ImageBase,
    OUT PULONGLONG Version
    )

/*++

Routine Description:

    Get the version stamp out of the VS_FIXEDFILEINFO resource in a PE
    image.

Arguments:

    ImageBase - supplies the address in memory where the file is mapped in.

    Version - receives 64bit version number, or 0 if the file is not
        a PE image or has no version data.

Return Value:

    None.
--*/

{
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;
    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    *Version = 0;

    //
    // Do this to prevent the Ldr routines from faulting.
    //
    ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);

    IdPath[0] = (ULONG_PTR)RT_VERSION;
    IdPath[1] = (ULONG_PTR)MAKEINTRESOURCE(VS_VERSION_INFO);
    IdPath[2] = 0;

    try {
        Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return;
    }

    try {
        Status = LdrAccessResource(ImageBase,DataEntry,&Resource,&ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return;
    }

    try {
        if((ResourceSize >= sizeof(*Resource)) && !_wcsicmp(Resource->Name,L"VS_VERSION_INFO")) {

            *Version = ((ULONGLONG)Resource->FixedFileInfo.dwFileVersionMS << 32)
                     | (ULONGLONG)Resource->FixedFileInfo.dwFileVersionLS;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: invalid version resource\n"));
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Exception encountered processing bogus version resource\n"));
    }
}

#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyFileForRemoteBoot(
    IN PWSTR SourceFilename,
    IN PWSTR TargetFilename,
    IN ULONG TargetAttributes,
    IN ULONG Flags,
    OUT PULONG Checksum
    )

/*++

Routine Description:

    Check to see if the target file already exists in the master tree on
    the remote boot server, and if it does, create a single-instance store
    link to the existing file instead of doing the copy.

Arguments:

    SourceFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).

    Flags - bit mask specifying any special treatment necessary
        for the file.

    CheckSum - checksum of the file

Return Value:

    NT Status value indicating outcome of NtWriteFile of the data.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSI_COPYFILE copyFile;
    ULONG copyFileSize;
    ULONG sourceLength;
    ULONG targetLength;
    HANDLE targetHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    //
    // If the target file is not remote, then it must be on the local system
    // partition, and there's no use in trying an SIS copy.
    //
    // If there is no SIS root handle, there's no handle on which to issue the
    // SIS FSCTL.
    //

    if ( (_wcsnicmp(TargetFilename, L"\\Device\\LanmanRedirector", 24) != 0 ) ||
         (SisRootHandle == NULL) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Build the FSCTL command buffer.
    //

    sourceLength = (wcslen(SourceFilename) + 1) * sizeof(WCHAR);
    targetLength = (wcslen(TargetFilename) + 1) * sizeof(WCHAR);

    copyFileSize = FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) + sourceLength + targetLength;

    copyFile = SpMemAlloc( copyFileSize );
    copyFile->SourceFileNameLength = sourceLength;
    copyFile->DestinationFileNameLength = targetLength;
    copyFile->Flags = COPYFILE_SIS_REPLACE;

    RtlCopyMemory(
        copyFile->FileNameBuffer,
        SourceFilename,
        sourceLength
        );

    RtlCopyMemory(
        copyFile->FileNameBuffer + (sourceLength / sizeof(WCHAR)),
        TargetFilename,
        targetLength
        );

    //
    // Invoke the SIS CopyFile FsCtrl.
    //

    status = ZwFsControlFile(
                SisRootHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_SIS_COPYFILE,
                copyFile,               // Input buffer
                copyFileSize,           // Input buffer length
                NULL,                   // Output buffer
                0 );                    // Output buffer length

    if ( NT_SUCCESS(status) ) {

        //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws succeeded\n", SourceFilename, TargetFilename ));

        //
        // Open the target file so that CSC knows about it and pins it.
        //

        INIT_OBJA(&objectAttributes, &unicodeString, TargetFilename);

        status = ZwOpenFile(
                    &targetHandle,
                    FILE_GENERIC_READ,
                    &objectAttributes,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    0
                    );

        if ( NT_SUCCESS(status) ) {
            ZwClose(targetHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws succeeded, but open failed: %x\n", SourceFilename, TargetFilename, status ));
        }

    } else {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws failed: %x\n", SourceFilename, TargetFilename, status ));

        //
        // If it looks like SIS isn't active on the remote file system, close
        // the SIS root handle so that we can avoid repeatedly getting this
        // error.
        //
        // Note: NTFS returns STATUS_INVALID_PARAMETER. FAT returns
        // STATUS_INVALID_DEVICE_REQUEST.
        //

        if ( (status == STATUS_INVALID_PARAMETER) ||
             (status == STATUS_INVALID_DEVICE_REQUEST) ) {
            ZwClose( SisRootHandle );
            SisRootHandle = NULL;
        }
    }

    *Checksum = 0;

    SpMemFree( copyFile );

    return status;
}
#endif // defined(REMOTE_BOOT)

NTSTATUS
SpCopyFileUsingNames(
    IN PWSTR SourceFilename,
    IN PWSTR TargetFilename,
    IN ULONG TargetAttributes,
    IN ULONG Flags
    )

/*++

Routine Description:

    Attempt to copy or decompress a file based on filenames.

Arguments:

    SourceFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).

    Flags - bit mask specifying any special treatment necessary
        for the file.

Return Value:

    NT Status value indicating outcome of NtWriteFile of the data.

--*/

{
    NTSTATUS Status;
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    BOOLEAN b;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicFileInfo;
    FILE_BASIC_INFORMATION BasicFileInfo2;
    BOOLEAN GotBasicInfo;
    ULONG FileSize;
    PVOID ImageBase;
    HANDLE SectionHandle;
    BOOLEAN IsCompressed;
    BOOLEAN InDriverCab;
    PWSTR TempFilename,TempSourcename;
    PFILE_RENAME_INFORMATION RenameFileInfo;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    LARGE_INTEGER FileOffset;
    ULONGLONG SourceVersion;
    ULONGLONG TargetVersion;
    USHORT CompressionState;
    BOOLEAN Moved;
    BOOLEAN TargetExists;
    WCHAR   SmashedSourceFilename[ACTUAL_MAX_PATH];
    ULONG pathSize;

#if 0
#ifdef _X86_

    BOOL bUniprocFile = FALSE;

    //
    // If this file is on the list of files whose locks need to be smashed,
    // copy a file who's been smashed.  We do this by prepending our up
    // directory name infront of the filename in SourceFilename.
    //
    if((Flags & COPY_SMASHLOCKS) && !SpInstallingMp() && !RemoteSysPrepSetup) {
    WCHAR   *char_ptr;
        //
        // Find the last '\\' in the name.
        //
        char_ptr = SourceFilename + (wcslen(SourceFilename)) - 1;

        while( (char_ptr > SourceFilename) &&
               (*char_ptr != L'\\') ) {
            char_ptr--;
        }

        //
        // Now insert our special directory name inside
        // the specified source file name.
        //
        if( *char_ptr == L'\\' ) {
            *char_ptr = 0;
            wcscpy( SmashedSourceFilename, SourceFilename );
            *char_ptr = L'\\';
            char_ptr++;
            wcscat( SmashedSourceFilename, L"\\UniProc\\" );
            wcscat( SmashedSourceFilename, char_ptr );

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying:\n\t%ws\n\tinstead of:\n\t%ws\n", SmashedSourceFilename, SourceFilename));

            SourceFilename = SmashedSourceFilename;
            bUniprocFile = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to generate smashed source path for %ws\n", SourceFilename));
        }
    }
#endif // defined _x86_
#endif // 0

    //
    // Open the source file if it's not open already.
    // Note that the name may not be the actual name on disk.
    // We also try to open the name with the _ appended.
    //

    InDriverCab = FALSE;

    if (RemoteSysPrepSetup && ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

        INIT_OBJA(&Obja,&UnicodeString,SourceFilename);

        Status = ZwCreateFile(  &SourceHandle,
                                FILE_GENERIC_READ,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                0,
                                NULL,
                                0
                                );
    } else {

        if (!PrivateInfHandle && g_UpdatesSifHandle) {

            TempSourcename = wcsrchr(SourceFilename,L'\\');
            if (TempSourcename) {
                TempSourcename++;
            } else {
                TempSourcename = SourceFilename;
            }

#if 0
#ifdef _X86_
            //
            // If this file is on the list of files whose locks need to be smashed,
            // look in uniproc.cab first
            //
            if(bUniprocFile && g_UniprocSifHandle) {
                Status = SpOpenFileInDriverCab (
                            TempSourcename,
                            g_UniprocSifHandle,
                            &SourceHandle
                            );

                if (NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: using %ws from uniproc cab\n", TempSourcename));
                    InDriverCab = TRUE;
                    Flags &= ~COPY_DELETESOURCE;
                }
            }
#endif // defined _X86_
#endif // 0

            if (!InDriverCab) {
                //
                // look in updates cab first
                //
                Status = SpOpenFileInDriverCab (
                            TempSourcename,
                            g_UpdatesSifHandle,
                            &SourceHandle
                            );

                if (NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: using %ws from updates cab\n", TempSourcename));
                    InDriverCab = TRUE;
                    Flags &= ~COPY_DELETESOURCE;
                }
            }
        }

        if (!InDriverCab) {
            Status = SpOpenNameMayBeCompressed(
                        SourceFilename,
                        FILE_GENERIC_READ,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        0,
                        &SourceHandle,
                        &b
                        );

            if (!NT_SUCCESS(Status)) {
                //
                // if it's not the actual name and it's not compressed, it may be in the driver cab-file
                //
                TempSourcename = wcsrchr(SourceFilename,L'\\');
                if (TempSourcename) {
                    TempSourcename++;
                } else {
                    TempSourcename = SourceFilename;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: temp source name:  %ws\n", TempSourcename));



                Status = SpOpenFileInDriverCab(
                        TempSourcename,
                        NULL,
                        &SourceHandle
                        );

                InDriverCab = TRUE;
            }
        }
    }
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Unable to open source file %ws (%x)\n",SourceFilename,Status));
        return(Status);
    }

    //
    // Gather basic file info about the file. We only use the timestamp info.
    // If this fails this isn't fatal (we assume that if this fails, then
    // the copy will also fail; it not, the worst case is that the timestamps
    // might be wrong).
    //
    Status = ZwQueryInformationFile(
                SourceHandle,
                &IoStatusBlock,
                &BasicFileInfo,
                sizeof(BasicFileInfo),
                FileBasicInformation
                );

    if(NT_SUCCESS(Status)) {
        GotBasicInfo = TRUE;
    } else {
        GotBasicInfo = FALSE;
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Warning: unable to get basic file info for %ws (%x)\n",SourceFilename,Status));
    }


    //
    // Get the source file size, map in the file, and determine whether it's compressed.
    //
    Status = SpGetFileSize(SourceHandle,&FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get size of %ws (%x)\n",SourceFilename,Status));
        if (!InDriverCab) {
            ZwClose(SourceHandle);
        }
        return(Status);
    }

    if( FileSize == 0 ) {

        //
        // We'll soon indirectly call ZwCreateSection with a zero length.
        // This will fail, so let's deal with zero-length files up here so
        // they actually get copied.
        //
        // We know a couple of things that make our job much easier.
        // 1. We don't need to actually copy any data, just create an empty
        //    file.
        // 2. The source file isn't compressed, so don't worry about
        //    decompressing/renaming (by defintion, the smallest compressed
        //    file is non-zero).
        //

        INIT_OBJA(&Obja,&UnicodeString,TargetFilename);
        Status = ZwCreateFile( &TargetHandle,
                               FILE_GENERIC_WRITE,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                        // no sharing
                               FILE_OVERWRITE_IF,
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if( NT_SUCCESS(Status) ) {

            //
            //  if the source is off of a sysprep image, then we need to copy
            //  EAs and alternate data streams too.  we do this before setting
            //  attributes so that read only bit isn't set.
            //  Only do this if we're not grabbing additional drivers from the
            //  flat image.
            //

            if (RemoteSysPrepSetup && ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

                Status = SpCopyEAsAndStreams( SourceFilename,
                                              SourceHandle,
                                              TargetFilename,
                                              TargetHandle,
                                              FALSE );
            }

            if ( NT_SUCCESS(Status) ) {

                //
                // Try and set attributes on target.
                //
                BasicFileInfo.FileAttributes = TargetAttributes;
                ZwSetInformationFile(
                    TargetHandle,
                    &IoStatusBlock,
                    &BasicFileInfo,
                    sizeof(BasicFileInfo),
                    FileBasicInformation
                    );
            }

            //
            // Close target file
            //
            ZwClose( TargetHandle );

            //
            // Do we need to delete Source?
            //
            if( (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup && !InDriverCab) {
                ZwClose(SourceHandle);
                SourceHandle = NULL;
                SpDeleteFile(SourceFilename,NULL,NULL);
            }
        }
        else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Failed to create zero-length file %ws\n",TargetFilename));
        }

        //
        // Clean up this guy since we won't be needing him anymore.
        //
        if (SourceHandle != NULL) {
            if( !InDriverCab ) {
                ZwClose(SourceHandle);
            }
        }

        if (RemoteSysPrepSetup &&
            NT_SUCCESS(Status) &&
            ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

            Status = SpSysPrepSetExtendedInfo( SourceFilename,
                                               TargetFilename,
                                               FALSE,
                                               FALSE );
        }
        return(Status);
    }

    Status = SpMapEntireFile(SourceHandle,&SectionHandle,&ImageBase,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to map file %ws (%x)\n",SourceFilename,Status));
        if (!InDriverCab) {
            ZwClose(SourceHandle);
        }
        return(Status);
    }

    //
    // If we were told not to decompress, then treat any file like it is
    // uncompressed.
    //

    if (Flags & COPY_NODECOMP) {
        IsCompressed = FALSE;
    } else {
        if (InDriverCab) {
            IsCompressed = TRUE;
        } else {
            IsCompressed = SpdIsCompressed(ImageBase,FileSize);
        }

    }

    //
    // Create a temporary filename to be used for the target.
    //

    pathSize = (wcslen(TargetFilename)+12) * sizeof(WCHAR);

    TempFilename = SpMemAlloc(pathSize);
    wcscpy(TempFilename,TargetFilename);
    wcscpy(wcsrchr(TempFilename,L'\\')+1,L"$$TEMP$$.~~~");

    //
    // Allocate some space for the rename buffer.
    //
    RenameFileInfo = SpMemAlloc(sizeof(FILE_RENAME_INFORMATION) + pathSize );

    //
    // Create the temporary file. We first try to do this via a move
    // if the source isn't compressed and we're going to delete the source file.
    //
    if (!IsCompressed && (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup) {

        RenameFileInfo->ReplaceIfExists = TRUE;
        RenameFileInfo->RootDirectory = NULL;
        RenameFileInfo->FileNameLength = wcslen(TempFilename)*sizeof(WCHAR);
        wcscpy(RenameFileInfo->FileName,TempFilename);

        Status = ZwSetInformationFile(
                    SourceHandle,
                    &IoStatusBlock,
                    RenameFileInfo,
                    sizeof(FILE_RENAME_INFORMATION) + RenameFileInfo->FileNameLength,
                    FileRenameInformation
                    );

        Moved = TRUE;
    } else {
        //
        // Force us to fall into the copy case below.
        //
        Status = STATUS_UNSUCCESSFUL;
    }

    INIT_OBJA(&Obja,&UnicodeString,TempFilename);

    if(!NT_SUCCESS(Status)) {
        Moved = FALSE;

        //
        // OK, move failed, try decompress/copy instead.
        // Start by creating the temporary file.
        //
        Status = ZwCreateFile(
                    &TargetHandle,
                    FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,                      // no sharing
                    FILE_OVERWRITE_IF,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            if(IsCompressed &&
                ( (!RemoteSysPrepSetup) ||
                  ((Flags & COPY_DECOMPRESS_SYSPREP) != 0))) {

                if (InDriverCab) {
                    USHORT RealFileTime,RealFileDate;
                    LARGE_INTEGER RealTime;
                    ASSERT (TempSourcename != NULL );

                    //
                    // remove the file from the driver cab...
                    //
                    Status = SpdDecompressFileFromDriverCab(
                                                 TempSourcename,
                                                 ImageBase,
                                                 FileSize,
                                                 TargetHandle,
                                                 &RealFileDate,
                                                 &RealFileTime );

                    //
                    // ...now update the basic file information filetime...
                    //
                    if (GotBasicInfo) {
                        SpTimeFromDosTime(RealFileDate,RealFileTime,&RealTime);
                        BasicFileInfo.CreationTime = RealTime;
                    }
                } else{
                    Status = SpdDecompressFile(ImageBase,FileSize,TargetHandle);
                }

            } else {

                ULONG remainingLength;
                ULONG writeLength;
                PUCHAR base;

                //
                // Guard the write with a try/except because if there is an i/o error,
                // memory management will raise an in-page exception.
                //
                FileOffset.QuadPart = 0;
                base = ImageBase;
                remainingLength = FileSize;

                try {
                    while (remainingLength != 0) {
                        writeLength = 60 * 1024;
                        if (writeLength > remainingLength) {
                            writeLength = remainingLength;
                        }
                        Status = ZwWriteFile(
                                    TargetHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    base,
                                    writeLength,
                                    &FileOffset,
                                    NULL
                                    );
                        base += writeLength;
                        FileOffset.LowPart += writeLength;
                        remainingLength -= writeLength;
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    }

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = STATUS_IN_PAGE_ERROR;
                }
            }

            //
            //  if the source is off of a sysprep image, then we need to copy
            //  EAs and alternate data streams too.
            //

            if ( NT_SUCCESS(Status) &&
                 RemoteSysPrepSetup &&
                 ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

                Status = SpCopyEAsAndStreams( SourceFilename,
                                              SourceHandle,
                                              TargetFilename,
                                              TargetHandle,
                                              FALSE );
            }

            ZwClose(TargetHandle);
        }
    }

    SpUnmapFile(SectionHandle,ImageBase);
    if (!InDriverCab) {
        ZwClose(SourceHandle);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to create temporary file %ws (%x)\n",TempFilename,Status));
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    //
    // At this point we have a temporary target file that is now the source.
    // Open the file, map it in, and get its version.
    //
    Status = ZwCreateFile(
                &SourceHandle,
                FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,                      // don't bother with attributes
                0,                      // no sharing
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if((Status == STATUS_ACCESS_DENIED) && Moved) {
        //
        // The only way this could have happened is if the source file
        // is uncompressed and the delete-source flag is set, since in
        // that case we could have moved the source file to the temp file.
        // In any other case we would have created the temp file by copying,
        // and there's no problem reopening the file since we just created
        // and closed it ourselves, above.
        //
        // Reset attributes and try again. The file might have been read-only.
        // This can happen when doing a winnt32 directly from a CD since the
        // RO attribute of files from the CD are preserved.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: for file %ws, can't reopen temp file (access deined), trying again\n",SourceFilename));

        Status = ZwCreateFile(
                    &SourceHandle,
                    FILE_WRITE_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,                      // don't bother with attributes
                    FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            RtlZeroMemory(&BasicFileInfo2,sizeof(BasicFileInfo2));
            BasicFileInfo2.FileAttributes = FILE_ATTRIBUTE_NORMAL;

            Status = ZwSetInformationFile(
                        SourceHandle,
                        &IoStatusBlock,
                        &BasicFileInfo2,
                        sizeof(BasicFileInfo2),
                        FileBasicInformation
                        );

            ZwClose(SourceHandle);

            if(NT_SUCCESS(Status)) {

                Status = ZwCreateFile(
                            &SourceHandle,
                            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            0,                      // don't bother with attributes
                            0,                      // no sharing
                            FILE_OPEN,
                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );
            }
        }
    }

    //
    // Read-only failured win out over sharing violations -- ie, we'll get back
    // ACCESS_DEINED first for files that are both RO and in-use. So break out
    // this block so it gets executed even if we tried again above because the
    // file might be read-only.
    //
    if((Status == STATUS_SHARING_VIOLATION) && Moved) {
        //
        // The only way this can happen is if the source file is uncompressed
        // and the delete-source flag is set. In this case we renamed the file
        // to the temp filename and now we can't open it for write.
        // In any other case we would have created the temp file by copying,
        // and so there's no problem opening the file since we just closed it.
        //
        // Rename the temp file back to the source file and try again without
        // the delete source flag set. This forces a copy instead of a move.
        // The rename better work or else we're completely hosed -- because
        // there's a file we can't overwrite with the name we want to use for
        // the temp file for all our copy operations!
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: temporary file %ws is in use -- trying recursive call\n",TempFilename));

        Status = SpRenameFile(TempFilename,SourceFilename,FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: unable to restore temp file to %ws (%x)\n",SourceFilename,Status));
        }

        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);

        if(NT_SUCCESS(Status)) {
            Status = SpCopyFileUsingNames(
                        SourceFilename,
                        TargetFilename,
                        TargetAttributes,
                        Flags & ~COPY_DELETESOURCE
                        );
        }

        return(Status);
    }


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to reopen temporary file %ws (%x)\n",TempFilename,Status));
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    Status = SpGetFileSize(SourceHandle,&FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get size of %ws (%x)\n",TempFilename,Status));
        ZwClose(SourceHandle);
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    Status = SpMapEntireFile(SourceHandle,&SectionHandle,&ImageBase,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to map file %ws (%x)\n",TempFilename,Status));
        ZwClose(SourceHandle);
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    SpGetFileVersion(ImageBase,&SourceVersion);

    SpUnmapFile(SectionHandle,ImageBase);

    //
    // See if the target file is there by attempting to open it.
    // If the file is there, get its version.
    //
    INIT_OBJA(&Obja,&UnicodeString,TargetFilename);

    Status = ZwCreateFile(
                &TargetHandle,
                FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,                                  // don't bother with attributes
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,                          // open if exists, fail if not
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    TargetVersion = 0;
    if(NT_SUCCESS(Status)) {

        TargetExists = TRUE;

        //
        // If we're supposed to ignore versions, then keep the
        // target version at 0. This will guarantee that we'll overwrite
        // the target. We use the source filename here because it
        // allows more flexibility (such as with HALs, which all have
        // different source names but the same target name).
        //
        if(!(Flags & COPY_NOVERSIONCHECK)) {

            Status = SpGetFileSize(TargetHandle,&FileSize);
            if(NT_SUCCESS(Status)) {

                Status = SpMapEntireFile(TargetHandle,&SectionHandle,&ImageBase,FALSE);
                if(NT_SUCCESS(Status)) {

                    SpGetFileVersion(ImageBase,&TargetVersion);

                    SpUnmapFile(SectionHandle,ImageBase);

                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: warning: unable to map file %ws (%x)\n",TargetFilename,Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: warning: unable to get size of file %ws (%x)\n",TargetFilename,Status));
            }
        }

        ZwClose(TargetHandle);
    } else {
        TargetExists = FALSE;
    }

    //
    // OK, now we have a temporary source file and maybe an existing
    // target file, and version numbers for both. We will replace or create
    // the target file if:
    //
    // - The target file doesn't have version data (this also catches the case
    //   where the target file didn't exist)
    //
    // - The source version is newer than or equal to the target version.
    //
    // So that means we *won't* replace the target file only if both source and
    // target have version info and the source is older than the target.
    //
    // If the target version is 0 then the source version is always >= the target
    // so one simple test does everything we want.
    //
#if 0
    if(SourceVersion >= TargetVersion) {
#else
    //
    // Quit version-checking.  We need to install a stable OS.  If we
    // version check, then we never know what we're going to end up with.
    //
    if(1) {
#endif // if 0

        //
        // Delete the existing target in preparation.
        //
        if(TargetExists) {

             SpDeleteFile(TargetFilename,NULL,NULL);
        }

        //
        // Rename temp file to actual target file.
        //
        RenameFileInfo->ReplaceIfExists = TRUE;
        RenameFileInfo->RootDirectory = NULL;
        RenameFileInfo->FileNameLength = wcslen(TargetFilename)*sizeof(WCHAR);

        ASSERT( RenameFileInfo->FileNameLength < pathSize );

        wcscpy(RenameFileInfo->FileName,TargetFilename);

        Status = ZwSetInformationFile(
                    SourceHandle,
                    &IoStatusBlock,
                    RenameFileInfo,
                    sizeof(FILE_RENAME_INFORMATION) + RenameFileInfo->FileNameLength,
                    FileRenameInformation
                    );

        SpMemFree(RenameFileInfo);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to rename temp file to target %ws (%x)\n",TargetFilename,Status));
            ZwClose(SourceHandle);
            if(Moved) {
                SpRenameFile(TempFilename,SourceFilename,FALSE);
            }
            SpMemFree(TempFilename);
            return(Status);
        }

        //
        // If necessary, check if destination file is using NTFS compression, and
        // if so, uncompress it.
        //
        if(NT_SUCCESS(Status) && (Flags & COPY_FORCENOCOMP)) {

            Status = ZwQueryInformationFile(
                        SourceHandle,
                        &IoStatusBlock,
                        &BasicFileInfo2,
                        sizeof(BasicFileInfo2),
                        FileBasicInformation
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get basic file info on %ws (%x)\n",TargetFilename,Status));
                ZwClose(SourceHandle);
                if(Moved) {
                    SpRenameFile(TempFilename,SourceFilename,FALSE);
                }
                SpMemFree(TempFilename);
                return(Status);
            }

            if(BasicFileInfo2.FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

                CompressionState = 0;

                Status = ZwFsControlFile(
                             SourceHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_SET_COMPRESSION,
                             &CompressionState,
                             sizeof(CompressionState),
                             NULL,
                             0
                             );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to make %ws uncompressed (%lx)\n",TargetFilename,Status));
                    ZwClose(SourceHandle);
                    if(Moved) {
                        SpRenameFile(TempFilename,SourceFilename,FALSE);
                    }
                    SpMemFree(TempFilename);
                    return(Status);
                }
            }
        }

        SpMemFree(TempFilename);

        //
        // Delete the source if necessary. If the source is not
        // compressed and the deletesource flag is set, then we moved
        // the source file and so the source file is already gone.
        //
        if(IsCompressed && (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup  && !InDriverCab) {
            PWSTR   compname;

            //
            // Assume that the source name is on its compressed form, and attempt to
            // delete this file.
            //
            compname = SpGenerateCompressedName(SourceFilename);
            Status = SpDeleteFile(compname,NULL,NULL);
            SpMemFree(compname);
            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                //
                // If we couldn't delete the file with the compressed name, then the file name
                // was probably on its uncompressed format.
                //
                SpDeleteFile(SourceFilename,NULL,NULL);
            }
        }

        //
        // Apply attributes and timestamp.
        // Ignore errors.
        //
        if(!GotBasicInfo) {
            RtlZeroMemory(&BasicFileInfo,sizeof(BasicFileInfo));
        }

        //
        // Set the file attributes. Note that if the caller didn't specify any,
        // then 0 value will tell the I/O system to leave the attributes alone.
        //
        BasicFileInfo.FileAttributes = TargetAttributes;
        ZwSetInformationFile(
            SourceHandle,
            &IoStatusBlock,
            &BasicFileInfo,
            sizeof(BasicFileInfo),
            FileBasicInformation
            );

        ZwClose(SourceHandle);
        Status = STATUS_SUCCESS;

    } else {
        //
        // Delete the temporary source.
        //
        ZwClose(SourceHandle);
        SpDeleteFile(TempFilename,NULL,NULL);
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        Status = STATUS_SUCCESS;
    }

    if (RemoteSysPrepSetup &&
        NT_SUCCESS(Status) &&
        ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

        Status = SpSysPrepSetExtendedInfo( SourceFilename,
                                           TargetFilename,
                                           FALSE,
                                           FALSE );
    }

    return(Status);
}


VOID
SpValidateAndChecksumFile(
    IN  HANDLE   FileHandle, OPTIONAL
    IN  PWSTR    Filename,   OPTIONAL
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    FileHandle - supplies handle of file to check (if not present, then
        Filename specifies the file to be opened and checked)

    Filename - supplies full NT path of file to check (if not present, then
        FileHandle must be specified)

    IsNtImage = Receives flag indicating whether the file is an
        NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
        image (for nt images) and that we can read the image.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PVOID BaseAddress;
    ULONG FileSize;
    HANDLE hFile = FileHandle, hSection;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;

    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //
    Status = SpOpenAndMapFile(
                Filename,
                &hFile,
                &hSection,
                &BaseAddress,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return;
    }

    NtHeaders = SpChecksumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    SpUnmapFile(hSection,BaseAddress);

    if(!FileHandle) {
        ZwClose(hFile);
    }
}


VOID
SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,
    IN PWSTR              SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,         OPTIONAL
    IN PWSTR              TargetRoot,              OPTIONAL
    IN ULONG              TargetFileAttributes,    OPTIONAL
    IN PCOPY_DRAW_ROUTINE DrawScreen,
    IN PULONG             FileCheckSum,            OPTIONAL
    IN PBOOLEAN           FileSkipped,             OPTIONAL
    IN ULONG              Flags
    )

/*++

Routine Description:

    This routine copies a single file, allowing retry is an error occurs
    during the copy.  If the source file is LZ compressed, then it will
    be decompressed as it is copied to the target.

    If the file is not successfully copied, the user has the option
    to retry to copy or to skip copying that file after a profuse warning
    about how dangerous that is.

Arguments:

    FileToCopy - supplies structure giving information about the file
        being copied.

    SourceDevicePath - supplies path to device on which the source media
        is mounted (ie, \device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - Supplies the directory on the source where
        the file is to be found.

    TargetRoot - if specified, supplies the directory on the target
        to which the file is to be copied.

    TargetFileAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).
        If not specified, the attributes will be set to FILE_ATTRIBUTE_NORMAL.

    DrawScreen - supplies address of a routine to be called to refresh
        the screen.

    FileCheckSum - if specified, will contain the check sum of the file copied.

    FileSkipped - if specified, will inform the caller if there was no attempt
                  to copy the file.

    Flags - supplies flags to control special processing for this file, such as
        deleting the source file on successful copy or skip; smashing locks;
        specifying that the source file is oem; or to indicate that en oem file
        with the same name should be overwritten on upgrade. This value is ORed
        in with the Flags field of FileToCopy.

Return Value:

    None.

--*/

{
    PWSTR p = TemporaryBuffer;
    PWSTR FullSourceName,FullTargetName;
    NTSTATUS Status;
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    BOOLEAN IsNtImage,IsValid;
    ULONG Checksum;
    BOOLEAN Failure;
    ULONG MsgId;
    BOOLEAN DoCopy;
    ULONG CopyFlags;
    BOOLEAN PreinstallRememberFile;

    //
    // Form the full NT path of the source file.
    //
    wcscpy(p,SourceDevicePath);
    SpConcatenatePaths(p,DirectoryOnSourceDevice);
    if(SourceDirectory) {
        SpConcatenatePaths(p,SourceDirectory);
    }
    SpConcatenatePaths(p,FileToCopy->SourceFilename);

    FullSourceName = SpDupStringW(p);

    //
    // Form the full NT path of the target file.
    //
    wcscpy(p,FileToCopy->TargetDevicePath);
    if(TargetRoot) {
        SpConcatenatePaths(p,TargetRoot);
    }
    SpConcatenatePaths(p,FileToCopy->TargetDirectory);

    //
    //  On an OEM preinstall, if the target name is a long name, then use
    //  the short name as a target name, and later on, if the copy succeeds,
    //  add the file to RenameList, so that it can be added to $$rename.txt
    //
    if( !PreInstall ||
        ( wcslen( FileToCopy->TargetFilename ) <= 8 + 1 + 3 ) ) {
        SpConcatenatePaths(p,FileToCopy->TargetFilename);
        PreinstallRememberFile = FALSE;
    } else {
        SpConcatenatePaths(p,FileToCopy->SourceFilename);
        PreinstallRememberFile = TRUE;
    }
    FullTargetName = SpDupStringW(p);

    //
    // Call out to the draw screen routine to indicate that
    // a new file is being copied.
    //
    DrawScreen(FullSourceName,FullTargetName,FALSE);

    //
    // Build up the copy flags value.
    //
    CopyFlags = Flags | FileToCopy->Flags;

    do {
        DoCopy = TRUE;

        //
        // Check the copy options field.  The valid values here are
        //
        //    - COPY_ALWAYS
        //    - COPY_ONLY_IF_PRESENT
        //    - COPY_ONLY_IF_NOT_PRESENT
        //    - COPY_NEVER

        switch(CopyFlags & COPY_DISPOSITION_MASK) {

        case COPY_ONLY_IF_PRESENT:

            DoCopy = SpFileExists(FullTargetName, FALSE);
            break;

        case COPY_ONLY_IF_NOT_PRESENT:

            DoCopy = !SpFileExists(FullTargetName, FALSE);
            break;

        case COPY_NEVER:

            DoCopy = FALSE;

        case COPY_ALWAYS:
        default:
           break;
        }

        if(!DoCopy) {
            break;
        }

        //
        //  In the upgrade case, check if the file being copied
        //  replaces a third party file.
        //  If it does, then ask what the user wants to do about it
        //
        if( !RepairWinnt &&
            ( NTUpgrade == UpgradeFull ) &&
            SpFileExists(FullTargetName, FALSE) ) {
            //
            //  If necessary ask the user if he wants to overwrite the file.
            //  Otherwise go ahead and copy the file.
            //
            if(!(CopyFlags & COPY_OVERWRITEOEMFILE)) {
                PWSTR   TmpFilePath;
                BOOLEAN OverwriteFile;


                if(( TargetRoot == NULL ) ||
                   ( wcslen( FileToCopy->TargetDirectory ) == 0 ) ) {
                    wcscpy( p, FileToCopy->TargetFilename );
                } else {
                    wcscpy( p, TargetRoot );
                    SpConcatenatePaths( p, FileToCopy->TargetDirectory );
                    SpConcatenatePaths(p,FileToCopy->TargetFilename);
                }
                TmpFilePath = SpDupStringW(p);
                OverwriteFile = TRUE;

                if( ( (CopyFlags & COPY_SOURCEISOEM) == 0 ) &&
                    SppIsFileLoggedAsOemFile( TmpFilePath ) ) {

                    if( !UnattendedOperation ) {
                        ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
                        BOOLEAN ActionSelected = FALSE;
//                        ULONG Mnemonics[] = { MnemonicOverwrite, 0 };

                        //
                        //  Warn user that existing file is a third party file,
                        //  and ask if user wants to over write the file
                        //

                        while( !ActionSelected ) {
                            SpStartScreen(
                                SP_SCRN_OVERWRITE_OEM_FILE,
                                3,
                                HEADER_HEIGHT+1,
                                FALSE,
                                FALSE,
                                DEFAULT_ATTRIBUTE,
                                FileToCopy->TargetFilename
                                );

                            SpDisplayStatusOptions(
                                DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_REPLACE_FILE,
                                SP_STAT_ESC_EQUALS_SKIP_FILE,
                                0
                                );

                            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

                                case ASCI_CR:       // don't overwrite

                                OverwriteFile = TRUE;
                                ActionSelected = TRUE;
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: OEM file %ls, will be overwritten.\n", FullTargetName ));
                                break;

                                case ASCI_ESC:      // skip file

                                OverwriteFile = FALSE;
                                ActionSelected = TRUE;
                                break;


                            }
                        }

                        //
                        // Need to completely repaint gauge, etc.
                        //
                        DrawScreen(FullSourceName,FullTargetName,TRUE);

                    } else {
                        //
                        //  On unattended upgrade, do what is in the script file
                        //
                        OverwriteFile = UnattendedOverwriteOem;
                    }
                }
                SpMemFree( TmpFilePath );

                if( !OverwriteFile ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: OEM file %ls, will not be overwritten.\n", FullTargetName ));
                    if( ARGUMENT_PRESENT( FileSkipped ) ) {
                         *FileSkipped = TRUE;
                    }
                    //
                    // Free the source and target filenames.
                    //
                    SpMemFree(FullSourceName);
                    SpMemFree(FullTargetName);
                    return;
                }
            }
        }

        //
        // Copy the file.  If there is a target root specified, assume
        // the file is being copied to the system partition and make
        // the file readonly, system, hidden.
        //
#if defined(REMOTE_BOOT)
        // If this is a remote boot install, check to see if a copy of the
        // file already exists on the server, and if so, just make a link
        // to the file instead of copying it.
        //
        if (RemoteBootSetup) {
            Status = SpCopyFileForRemoteBoot(
                        FullSourceName,
                        FullTargetName,
                        TargetFileAttributes,
                        CopyFlags,
                        &Checksum);
            IsValid = TRUE;         // Checksum is known
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        if (!NT_SUCCESS(Status))
#endif // defined(REMOTE_BOOT)
        {
            Status = SpCopyFileUsingNames(
                        FullSourceName,
                        FullTargetName,
                        TargetFileAttributes,
                        CopyFlags
                        );
            IsValid = FALSE;        // Checksum is not known
        }

        //
        // If the file copied OK, verify the copy.
        //
        if(NT_SUCCESS(Status)) {

            if (!IsValid) {
                SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&Checksum,&IsValid);
            }
            if( ARGUMENT_PRESENT( FileCheckSum ) ) {
                *FileCheckSum = Checksum;
            }

            //
            // If the image is valid, then the file really did copy OK.
            //
            if(IsValid) {
                Failure = FALSE;
            } else {

                //
                // If it's an nt image, then the verify failed.
                // If it's not an nt image, then the only way the verify
                // can fail is if we get an i/o error reading the file back,
                // which means it didn't really copy correctly.
                //
                MsgId = IsNtImage ? SP_SCRN_IMAGE_VERIFY_FAILED : SP_SCRN_COPY_FAILED;
                Failure = TRUE;
                PreinstallRememberFile = FALSE;
            }

        } else {
            if((Status == STATUS_OBJECT_NAME_NOT_FOUND) && (Flags & COPY_SKIPIFMISSING)) {
                Failure = FALSE;
            } else {
                Failure = TRUE;
                MsgId = SP_SCRN_COPY_FAILED;
            }
           PreinstallRememberFile = FALSE;
        }

        if(Failure) {

            //
            // The copy or verify failed.  Give the user a message and allow retry.
            //
            repaint:
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                FileToCopy->SourceFilename
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_ESC_EQUALS_SKIP_FILE,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

            case ASCI_CR:       // retry

                break;

            case ASCI_ESC:      // skip file

                Failure = FALSE;
                break;

            case KEY_F3:        // exit setup

                SpConfirmExit();
                goto repaint;
            }

            //
            // Need to completely repaint gauge, etc.
            //
            DrawScreen(FullSourceName,FullTargetName,TRUE);
        }

    } while(Failure);

    if( ARGUMENT_PRESENT( FileSkipped ) ) {
        *FileSkipped = !DoCopy;
    }

    //
    // Free the source and target filenames.
    //
    SpMemFree(FullSourceName);
    SpMemFree(FullTargetName);

    //
    //  In the preinstall mode, add the file to RenameList
    //
    if( PreInstall && PreinstallRememberFile ) {
        PFILE_TO_RENAME  File;

        File = SpMemAlloc(sizeof(FILE_TO_RENAME));
        File->SourceFilename = SpDupStringW(FileToCopy->SourceFilename);
        wcscpy(TemporaryBuffer,L"\\");
        if(TargetRoot) {
            SpConcatenatePaths(TemporaryBuffer,TargetRoot);
        }
        SpConcatenatePaths(TemporaryBuffer,FileToCopy->TargetDirectory);
        File->TargetDirectory = SpDupStringW(TemporaryBuffer);
        File->TargetFilename = SpDupStringW((PWSTR)FileToCopy->TargetFilename);
        File->Next = RenameList;
        RenameList = File;
    }
}


VOID
SpCopyFilesScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    static ULONG u = 0;
    PWSTR p;
    UNREFERENCED_PARAMETER(FullTargetname);

    //
    // Repaint the entire screen if necessary.
    //
    if(RepaintEntireScreen) {

        SpStartScreen(SP_SCRN_SETUP_IS_COPYING,0,6,TRUE,FALSE,DEFAULT_ATTRIBUTE);
        if(FileCopyGauge) {
            SpDrawGauge(FileCopyGauge);
        }
    }

    //
    // Place the name of the file being copied on the rightmost
    // area of the status line.
    //
    if(FullSourcename) {

        if(RepaintEntireScreen) {

            SpvidClearScreenRegion(
                0,
                VideoVars.ScreenHeight-STATUS_HEIGHT,
                VideoVars.ScreenWidth,
                STATUS_HEIGHT,
                DEFAULT_STATUS_BACKGROUND
                );

            SpDisplayStatusActionLabel(SP_STAT_COPYING,12);
        }

        //
        // Isolate the filename part of the sourcename.
        //
        if(p = wcsrchr(FullSourcename,L'\\')) {
            p++;
        } else {
            p = FullSourcename;
        }

        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusActionObject(p);
        } else {


            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusActionObject( TempPtr );

            u++;

        }
    }
}


VOID
SpCopyFilesInCopyList(
    IN PVOID                    SifHandle,
    IN PDISK_FILE_LIST          DiskFileLists,
    IN ULONG                    DiskCount,
    IN PWSTR                    SourceDevicePath,
    IN PWSTR                    DirectoryOnSourceDevice,
    IN PWSTR                    TargetRoot,
    IN PINCOMPATIBLE_FILE_LIST  CompatibilityExceptionList OPTIONAL
    )

/*++

Routine Description:

    Iterate the copy list for each setup source disk and prompt for
    the disk and copy/decompress all the files on it.

Arguments:

    SifHandle - supplies handle to setup information file.

    DiskFileLists - supplies the copy list, in the form of an array
        of structures, one per disk.

    DiskCount - supplies number of elements in the DiskFileLists array,
        ie, the number of setup disks.

    SourceDevicePath - supplies the path of the device from which files
        are to be copied (ie, \device\floppy0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where files are to be found.

    TargetRoot - supplies root directory of target.  All target directory
        specifications are relative to this directory on the target.

    CompatibilityExceptionList - Singly-linked list of
        PINCOMPATIBLE_FILE_ENTRY objects that should be skipped during
        copying.  Optional, pass NULL if no exceptions are present.

Return Value:

    None.

--*/

{
    ULONG DiskNo;
    PDISK_FILE_LIST pDisk;
    PFILE_TO_COPY pFile;
    ULONG TotalFileCount;
    ULONG   CheckSum;
    BOOLEAN FileSkipped;
    ULONG CopyFlags;
    NTSTATUS status;

    //
    // Compute the total number of files.
    //
    for(TotalFileCount=DiskNo=0; DiskNo<DiskCount; DiskNo++) {
        TotalFileCount += DiskFileLists[DiskNo].FileCount;
    }


    //
    // If there are no files to copy, then we're done.
    //
    if( TotalFileCount == 0 ) {
        return;
    }

    SendSetupProgressEvent(FileCopyEvent, FileCopyStartEvent, &TotalFileCount);

    //
    // Create a gas gauge.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_COPYING);
    FileCopyGauge = SpCreateAndDisplayGauge(TotalFileCount,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
    ASSERT(FileCopyGauge);

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Copy files on each disk.
    //
    for(DiskNo=0; DiskNo<DiskCount; DiskNo++) {

        pDisk = &DiskFileLists[DiskNo];

        //
        // Don't bother with this disk if there are no files
        // to be copied from it.
        //
        if(pDisk->FileCount == 0) {
            continue;
        }

        //
        // Prompt the user to insert the disk.
        //
        SpPromptForDisk(
            pDisk->Description,
            SourceDevicePath,
            pDisk->TagFile,
            FALSE,              // no ignore disk in drive
            FALSE,              // no allow escape
            TRUE,               // warn multiple prompts
            NULL                // don't care about redraw flag
            );

        //
        // Passing the empty string as the first arg forces
        // the action area of the status line to be set up.
        // Not doing so results in the "Copying: xxxxx" to be
        // flush left on the status line instead of where
        // it belongs (flush right).
        //
        SpCopyFilesScreenRepaint(L"",NULL,TRUE);

        //
        // Copy each file on the source disk.
        //
        ASSERT(pDisk->FileList);
        for(pFile=pDisk->FileList; pFile; pFile=pFile->Next) {

            //
            // Copy the file.
            //
            // If the file is listed for lock smashing then we need to smash it
            // if installing UP on x86 (we don't bother with the latter
            // qualifications here).
            //
            // If there is an absolute target root specified, assume the
            // file is being copied to the system partition and make it
            // readonly/hidden/system.
            //
            // On upgrade, we need to know if the file is listed for oem overwrite.
            //

            //
            // "Copy" or "Move"??
            //
            if( (WinntSetup || RemoteInstallSetup)  &&
                (!WinntFromCd)                      &&
                (!NoLs)                             &&
                (NTUpgrade != UpgradeFull)          &&
                (!IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_DONTDELETESOURCE)) ) {

                //
                // We can delete the source (i.e. do a 'move')
                //
                CopyFlags = COPY_DELETESOURCE;
            } else {

                //
                // Do a 'copy'
                //
                CopyFlags = 0;
            }

#if 0
#ifdef _X86_
            //
            // Copy out of \uniproc (which contains lock-smashed binaries)?
            //
            if( IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_SMASHLOCKS) ) {
                CopyFlags |= COPY_SMASHLOCKS;
            }
#endif // defined _X86_
#endif // if 0

            //
            // What do we do if we can't find a file??
            //
            if( SkipMissingFiles ) {
                CopyFlags |= COPY_SKIPIFMISSING;
            }


            //
            // Do we overwrite files installed by the OEM?
            //
            if( (NTUpgrade == UpgradeFull) &&
                (IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_UPGRADEOVERWRITEOEM)) ) {

                CopyFlags |= COPY_OVERWRITEOEMFILE;
            }

            //
            // If the file is incompatible, and it's got the overwrite flag set,
            // the blow it away with our own one instead.
            //
            if ( SpIsFileIncompatible(
                    CompatibilityExceptionList,
                    pFile,
                    pFile->AbsoluteTargetDirectory ? NULL : TargetRoot
                    ) )
            {
                if (IsFileFlagSet(SifHandle,pFile->SourceFilename,FILEFLG_UPGRADEOVERWRITEOEM) ||
                    ( pFile->Flags & FILEFLG_UPGRADEOVERWRITEOEM ) ) {

                    CopyFlags = (CopyFlags & ~(COPY_DISPOSITION_MASK|COPY_OVERWRITEOEMFILE));
                    CopyFlags |= COPY_ALWAYS | COPY_NOVERSIONCHECK;

                    KdPrintEx((
                        DPFLTR_SETUP_ID,
                        DPFLTR_INFO_LEVEL,
                        "SETUP: OEM (or preexsting) file %ws is incompatible with gui-mode, set flag %08lx, forcing copy\n",
                        pFile->TargetFilename,
                        CopyFlags
                        ));

                }
            }

            //
            // What about any privates?  We don't want to ever 'move'
            // privates because they might be in the driver cab, in which
            // case, we want them in the ~LS directory when
            // we go into gui-mode setup.
            //
            if( (pSpIsFileInPrivateInf(pFile->TargetFilename)) ) {
                CopyFlags &= ~COPY_DELETESOURCE;
            }





            if(!WIN9X_OR_NT_UPGRADE || IsFileFlagSet(SifHandle,pFile->SourceFilename,FILEFLG_NOVERSIONCHECK)) {
                CopyFlags |= COPY_NOVERSIONCHECK;
            }

            SpCopyFileWithRetry(
                pFile,
                SourceDevicePath,
                DirectoryOnSourceDevice,
                pDisk->Directory,
                pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
                pFile->AbsoluteTargetDirectory ? ATTR_RHS : 0,
                SpCopyFilesScreenRepaint,
                &CheckSum,
                &FileSkipped,
                CopyFlags
                );

            //
            // Log the file
            //
            if( !FileSkipped ) {
                SpLogOneFile( pFile,
                              pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
                              NULL, // DirectoryOnSourceDevice,
                              NULL,
                              NULL,
                              CheckSum );
            }


            //
            // Advance the gauge.
            //
            SpTickGauge(FileCopyGauge);

            SendSetupProgressEvent(FileCopyEvent,
                                   OneFileCopyEvent,
                                   &((PGAS_GAUGE)FileCopyGauge)->CurrentPercentage);
        }
    }

    SendSetupProgressEvent(FileCopyEvent, FileCopyEndEvent, NULL);

    SpDestroyGauge(FileCopyGauge);
    FileCopyGauge = NULL;
}


NTSTATUS
SpCreateIncompatibleFileEntry(
    OUT PINCOMPATIBLE_FILE_ENTRY *TargetEntry,
    IN PWSTR FileName,
    IN PWSTR VersionString,             OPTIONAL
    IN PWSTR TargetAbsolutePath,        OPTIONAL
    IN ULONG Flags                      OPTIONAL
    )
/*++

Routine Description:

    Allocates enough space to store the incompatible file entry data in
    a contiguous blob, copies the values into it, and returns the blob
    created. Layout (using null-terminated strings) is as follows:

    [ Allocation                                    ]
    [ Header ][Filename][Version][TargetAbsolutePath]

Arguments:

    TargetEntry - Pointer to a PINCOMPATIBLE_FILE_ENTRY that will be
        returned to the caller.

    FileName - Name of the file, no path

    VersionString - Full version string of the file

    TargetAbsolutePath - Absolute path on the target media that this
        file will live in

    Flags - Any flags to be stored

Returns:

    STATUS_SUCCESS if TargetEntry contains a pointer to the allocated space

    STATUS_NO_MEMORY if the allocation failed

    STATUS_INVALID_PARAMETER_1 if TargetEntry was NULL

    STATUS_INVALID_PARAMETER_2 if FileName was NULL

--*/
{
    ULONG WCharsNeeded = 0;
    ULONG ActualBytes = 0;
    PINCOMPATIBLE_FILE_ENTRY LocalEntry;
    PWSTR Cursor;

    if ( TargetEntry )
        *TargetEntry = NULL;
    else
        return STATUS_INVALID_PARAMETER_1;

    //
    // Gather required sizes
    //
    if ( FileName != NULL )
        WCharsNeeded += wcslen(FileName) + 1;
    else
        return STATUS_INVALID_PARAMETER_2;

    if ( VersionString != NULL )
        WCharsNeeded += wcslen(VersionString) + 1;

    if ( TargetAbsolutePath != NULL )
        WCharsNeeded += wcslen(TargetAbsolutePath) + 1;

    //
    // Allocate the space, point the cursor at where we'll be copying
    // the strings.
    //
    ActualBytes = ( sizeof(WCHAR) * WCharsNeeded ) + sizeof(INCOMPATIBLE_FILE_ENTRY);
    LocalEntry = SpMemAlloc( ActualBytes );

    if ( LocalEntry == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Blank it out, point the write cursor at the end
    //
    ZeroMemory(LocalEntry, ActualBytes);
    Cursor = (PWSTR)(LocalEntry + 1);

    //
    // Copy strings and set pointers
    //
    wcscpy(Cursor, FileName);
    LocalEntry->IncompatibleFileName = Cursor;
    Cursor += wcslen(FileName) + 1;

    if ( VersionString != NULL ) {

        wcscpy(Cursor, VersionString);
        LocalEntry->VersionString = Cursor;
        Cursor += wcslen(VersionString) + 1;

    }

    if ( TargetAbsolutePath != NULL ) {

        wcscpy(Cursor, TargetAbsolutePath);
        LocalEntry->FullPathOnTarget = Cursor;

    }

    *TargetEntry = LocalEntry;

    return STATUS_SUCCESS;

}


NTSTATUS
SpFreeIncompatibleFileList(
    IN PINCOMPATIBLE_FILE_LIST FileListHead
    )
/*++

Routine Description:

    Cleans out the list of incompatible entries by freeing all the space
    that was allocated for the list.

Arguments:

    FileListHead - Pointer to the list containing INCOMPATIBLE_FILE_ENTRY
        items

Return values:

    STATUS_SUCCESS if the operation succeeds.

    STATUS_INVALID_PARAMETER if FileListHead is NULL

--*/
{
    PINCOMPATIBLE_FILE_ENTRY    IncListEntry;

    if ( !FileListHead )
        return STATUS_INVALID_PARAMETER;

    while ( FileListHead->Head != NULL ) {

        //
        // Simple list removal, some bookkeeping
        //
        IncListEntry = FileListHead->Head;

        FileListHead->Head = IncListEntry->Next;

        FileListHead->EntryCount--;

        SpMemFree( IncListEntry );
    }

    //
    // Toast the list structure as well.
    //
    FileListHead->Head = NULL;
    FileListHead->EntryCount = 0;

    return STATUS_SUCCESS;

}


BOOLEAN
SpIsFileIncompatible(
    IN  PINCOMPATIBLE_FILE_LIST FileList,
    IN  PFILE_TO_COPY           pFile,
    IN  PWSTR                   TargetRoot OPTIONAL
    )
/*++

Routine Description:

    Find out whether the given target media path and file name are listed
    as "incompatible."  Looks down FileList for an INCOMPATIBLE_FILE_ENTRY
    that contains FileName and TargetMediaPath.  If TargetMediaPath is not
    specified, indicates TRUE if a member with the name FileName is listed
    instead.  (Dangerous.)

Arguments:

    FileList - Header node of a list created with
        SpInitializeCompatibilityOverwriteLists.

    pFile - File to copy structure, containing all the relevant information
        about this file to scan for.

    TargetRoot - Copy target root directory, optional

Return Values:

    TRUE if the file "FileName" (with the optional path TargetMediaPath)
        is in the list of incompatible files.

    FALSE otherwise, or if FileList or FileName is NULL.

Remarks:

    This routine could be made more robust in the face of bad parameters,
    but this was deemed superfluous, since there's exactly one caller of
    this API whose values are already checked.  This function will then
    behave "properly" in all cases.

--*/
{
    INCOMPATIBLE_FILE_ENTRY *Entry;
    BOOLEAN                  Found = FALSE;
    PWSTR                    TargetFileName;

    if ( ( FileList == NULL ) || ( FileList->EntryCount == 0 ) )
        goto Exit;

    if ( pFile == NULL )
        goto Exit;

    Entry = FileList->Head;

    //
    // Cache locally
    //
    TargetFileName = pFile->TargetFilename;

    //
    // Generate the target media path from the file object
    //
#if 0
VOID
SpCopyFileWithRetry(    SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,        pFile,
    IN PWSTR              SourceDevicePath,        SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,        DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,         OPTIONAL        pDisk->Directory,
    IN PWSTR              TargetRoot,              OPTIONAL        pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
    IN ULONG              TargetFileAttributes,    OPTIONAL        pFile->AbsoluteTargetDirectory ? ATTR_RHS : 0,
    IN PCOPY_DRAW_ROUTINE DrawScreen,        SpCopyFilesScreenRepaint,
    IN PULONG             FileCheckSum,            OPTIONAL        &CheckSum,
    IN PBOOLEAN           FileSkipped,             OPTIONAL        &FileSkipped,
    IN ULONG              Flags        CopyFlags
        );

    VOID
    SpCopyFileWithRetry(
        IN PFILE_TO_COPY      FileToCopy,
        IN PWSTR              SourceDevicePath,
        IN PWSTR              DirectoryOnSourceDevice,
        IN PWSTR              SourceDirectory,         OPTIONAL
        IN PWSTR              TargetRoot,              OPTIONAL
        IN ULONG              TargetFileAttributes,    OPTIONAL
        IN PCOPY_DRAW_ROUTINE DrawScreen,
        IN PULONG             FileCheckSum,            OPTIONAL
        IN PBOOLEAN           FileSkipped,             OPTIONAL
        IN ULONG              Flags
        )

    //
    // Form the full NT path of the target file.
    //
    wcscpy(p,FileToCopy->TargetDevicePath);
    if(TargetRoot) {
        SpConcatenatePaths(p,TargetRoot);
    }
    SpConcatenatePaths(p,FileToCopy->TargetDirectory);

    //
    //  On an OEM preinstall, if the target name is a long name, then use
    //  the short name as a target name, and later on, if the copy succeeds,
    //  add the file to RenameList, so that it can be added to $$rename.txt
    //
    if( !PreInstall ||
        ( wcslen( FileToCopy->TargetFilename ) <= 8 + 1 + 3 ) ) {
        SpConcatenatePaths(p,FileToCopy->TargetFilename);
        PreinstallRememberFile = FALSE;
    } else {
        SpConcatenatePaths(p,FileToCopy->SourceFilename);
        PreinstallRememberFile = TRUE;
    }
    FullTargetName = SpDupStringW(p);
#endif // if 0

    //
    // Cycle through the list of incompatible file names, looking
    // for the one requested
    //
    while ( Entry != NULL ) {

        //
        // If the file names match, then check the media paths if
        // specified
        //
        if (_wcsicmp(TargetFileName, Entry->IncompatibleFileName) == 0) {


            //
            // CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE
            //
            // This was clipped from SpCopyFileWithRetry's code that generates the
            // actual target path.  I think the logic is supposed to look something
            // like the following:
            //
            // Target =
            //      File.TargetDevicePath +
            //      (File.AbsoluteTargetDirectory ? "" : TargetRoot) +
            //      File.TargetDirectory +
            //      ( (PreInstall || File.TargetFileName.Length > 12 ) ? File.SourceFilename : File.TargetFilename )
            //

            PWSTR TargetMediaPath = (PWSTR)TemporaryBuffer;

            wcscpy( TargetMediaPath, pFile->TargetDevicePath );

            if ( !pFile->AbsoluteTargetDirectory && ( TargetRoot != NULL ) ) {
                SpConcatenatePaths(TargetMediaPath, TargetRoot);
            }

            SpConcatenatePaths(TargetMediaPath,pFile->TargetDirectory);

            if ( !PreInstall || ( wcslen( pFile->TargetFilename ) <= 8 + 1 + 3 ) ) {
                SpConcatenatePaths(TargetMediaPath, pFile->TargetFilename);
            } else {
                SpConcatenatePaths(TargetMediaPath, pFile->SourceFilename);
            }


            //
            // When requesting an exact match, check it
            //
            if (Entry->FullPathOnTarget != NULL) {

                if (_wcsicmp(TargetMediaPath, Entry->FullPathOnTarget) == 0) {

                    Found = TRUE;
                    goto Exit;

                }

            //
            // Otherwise, the target media path was NULL, so just care if
            // the short names matched
            //
            } else {

                Found = TRUE;
                goto Exit;

            }

        }

        Entry = Entry->Next;
    }

Exit:
    return Found;

}



NTSTATUS
SpInitializeCompatibilityOverwriteLists(
    IN  PVOID                   SifHandle,
    OUT PINCOMPATIBLE_FILE_LIST IncompatibleFileList
    )
/*++

Routine Description:

    Reads the list of files that were marked as "incompatible" or "wrong
    version" in Winnt32, and stored in the IncompatibleFilesToOverWrite
    section of the sif file.  The data should be in the format

    [IncompatibleFilesToOverWrite]
    <shortname> = <version>,<full file path>

Arguments:

    SifHandle - Handle to the INF that this list will be loaded from.

    IncompatibleFileLists - Filled out to

Returns:

    STATUS_SUCCESS on good completion.

    STATUS_INVALID_PARAMETER_1 if SifHandle is NULL.

    STATUS_INVALID_PARAMETER_2 if IncompatibleFileList is NULL.

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    INCOMPATIBLE_FILE_LIST      fileListHead;
    PINCOMPATIBLE_FILE_ENTRY    fileListSingle = NULL;
    PWSTR                       SectionName = WINNT_OVERWRITE_EXISTING_W;
    PWSTR                       VersionString;
    PWSTR                       TargetMediaName;
    PWSTR                       FileName;
    PWSTR                       FullNtPathOfTargetName;
    ULONG                       SectionItemCount;
    ULONG                       i;

    if ( !SifHandle )
        return STATUS_INVALID_PARAMETER_1;

    if ( !IncompatibleFileList )
        return STATUS_INVALID_PARAMETER_2;

    //
    // Construct our local copy
    //
    IncompatibleFileList->Head = NULL;
    IncompatibleFileList->EntryCount = 0;
    fileListHead.Head = NULL;
    fileListHead.EntryCount = 0;

    SectionItemCount = SpCountLinesInSection(SifHandle, SectionName);

    for ( i = 0; i < SectionItemCount; i++ ) {

        FileName = SpGetKeyName( SifHandle, SectionName, i );

        if (!FileName){
            SpFatalSifError(SifHandle,SectionName,NULL,i,(ULONG)(-1));
        }

        //
        // Get the version string
        //
        VersionString = SpGetSectionKeyIndex(
            SifHandle,
            SectionName,
            FileName,
            0 );

        //
        // And name on the target media, if specified.
        //
        TargetMediaName = SpGetSectionKeyIndex(
            SifHandle,
            SectionName,
            FileName,
            1 );

        //
        // We can't, unfortunately, just use the path we got from the sif
        // file, as it's a Win32 path (c:\foo\bar\zot.foom).  We need a full
        // NT path (\Device\Harddisk0\Partition1\foo\bar\zot.foom) instead.
        // So, we convert with SpNtPathFromDosPath, which has the side-
        // effect of allocating space, which we don't necessarily care
        // about.
        //
        FullNtPathOfTargetName = SpNtPathFromDosPath( TargetMediaName );

        //
        // Create the file list entry, and store it for
        // later use.
        //
        status = SpCreateIncompatibleFileEntry(
            &fileListSingle,
            FileName,
            VersionString,
            FullNtPathOfTargetName,
            0 );

        //
        // If that failed and we have a full path, it should get freed
        // before we fail this code path to avoid a leak.
        //
        if ( FullNtPathOfTargetName != NULL ) {

            SpMemFree(FullNtPathOfTargetName);
            FullNtPathOfTargetName = NULL;

        }


        if (!NT_SUCCESS(status))
            goto Exit;

        //
        // Head insertion, indicate it was added
        //
        fileListSingle->Next = fileListHead.Head;
        fileListHead.Head = fileListSingle;
        fileListHead.EntryCount++;

        fileListSingle = NULL;

    }

    //
    // And store the list from here to there.
    //
    *IncompatibleFileList = fileListHead;

Exit:
    //
    // Did we accidentally create one but fail to insert it?  Hmm...
    //
    if( fileListSingle != NULL ) {
        SpMemFree(fileListSingle);
        fileListSingle = NULL;
    }

    //
    // If there was a failure and the list is nonempty, free its
    // entries.  It will not have been copied over to IncompatibleFileLists
    // (the only point of failure is SpCreateIncompatibleFileEntry, which
    // if it fails leaps out to Exit: without assigning IFL.)
    //
    if ( fileListHead.EntryCount != 0 && !NT_SUCCESS(status)) {
        SpFreeIncompatibleFileList( &fileListHead );
    }

    return status;
}



VOID
SpInitializeFileLists(
    IN  PVOID            SifHandle,
    OUT PDISK_FILE_LIST *DiskFileLists,
    OUT PULONG           DiskCount
    )

/*++

Routine Description:

    Initialize disk file lists.  This involves looking in a given section
    in the sectup information file and fetching information for each
    disk specified there.  The data is expected to be in the format

    [<SifSection>]
    <MediaShortname> = <Description>,<TagFile>[,,<Directory>]
    ...


    (Note that <Directory> is the third field -- the 2 commas
    are not a typo -- field 2 is unused.)

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - receives pointer to an array of disk file list
        structures, one per line in SifSection.  The caller must free
        this buffer when finished with it.

    DiskCount - receives number of elements in DiskFileLists array.

Return Value:

    None.

--*/

{
    unsigned pass;
    PWSTR mediaShortname,description,tagFile,directory;
    PDISK_FILE_LIST diskFileLists;
    PWSTR SectionName;
    ULONG TotalCount;
    ULONG SectionCount;
    ULONG i,u;
    BOOLEAN Found;

    diskFileLists = SpMemAlloc(0);
    TotalCount = 0;

    for(pass=0; pass<2; pass++) {

        //
        // On first pass do the platform-specific section.
        //
        SectionName = pass
                    ? SIF_SETUPMEDIA
                    : SpMakePlatformSpecificSectionName(SIF_SETUPMEDIA);

        //
        // Determine the number of media specifications
        // in the given section.
        //
        if (SectionName) {
            SectionCount = SpCountLinesInSection(SifHandle,SectionName);

            diskFileLists = SpMemRealloc(
                                diskFileLists,
                                (TotalCount+SectionCount) * sizeof(DISK_FILE_LIST)
                                );

            //
            // Zero out the new part of the buffer we just reallocated.
            //
            RtlZeroMemory(
                diskFileLists + TotalCount,
                SectionCount * sizeof(DISK_FILE_LIST)
                );

            for(i=0; i<SectionCount; i++) {

                //
                // Fetch parameters for this disk.
                //
                mediaShortname = SpGetKeyName(SifHandle,SectionName,i);
                if(!mediaShortname) {
                    SpFatalSifError(SifHandle,SectionName,NULL,i,(ULONG)(-1));
                }

                //
                // Ignore if we've already processed a media with this
                // shortname. This lets the platform-specific one override
                // the platform-independent one.
                //
                Found = FALSE;
                for(u=0; u<TotalCount; u++) {
                    if(!_wcsicmp(mediaShortname,diskFileLists[u].MediaShortname)) {
                        Found = TRUE;
                        break;
                    }
                }

                if(!Found) {
                    SpGetSourceMediaInfo(SifHandle,mediaShortname,&description,&tagFile,&directory);

                    //
                    // Initialize the disk file list structure.
                    //
                    diskFileLists[TotalCount].MediaShortname = mediaShortname;
                    diskFileLists[TotalCount].Description = description;
                    diskFileLists[TotalCount].TagFile = tagFile;
                    diskFileLists[TotalCount].Directory = directory;
                    TotalCount++;
                }
            }

            if(!pass) {
                SpMemFree(SectionName);
            }
        }
    }

    *DiskFileLists = diskFileLists;
    *DiskCount = TotalCount;
}


VOID
SpFreeCopyLists(
    IN OUT PDISK_FILE_LIST *DiskFileLists,
    IN     ULONG            DiskCount
    )
{
    ULONG u;
    PFILE_TO_COPY Entry,Next;

    //
    // Free the copy list on each disk.
    //
    for(u=0; u<DiskCount; u++) {

        for(Entry=(*DiskFileLists)[u].FileList; Entry; ) {

            Next = Entry->Next;

            SpMemFree(Entry);

            Entry = Next;
        }
    }

    SpMemFree(*DiskFileLists);
    *DiskFileLists = NULL;
}


BOOLEAN
SpCreateEntryInCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN ULONG           DiskNumber,
    IN PWSTR           SourceFilename,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory,
    IN ULONG           CopyFlags
    )

/*++

Routine Description:

    Adds an entry to a disk's file copy list after first verifying that
    the file is not already on the disk copy list.

Arguments:

    SifHandle - supplies handle to loaded text setup information file
        (txtsetup.sif).

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SourceFilename - supplies the name of the file as it exists on the
        distribution media.

    TargetDirectory - supplies the directory on the target media
        into which the file will be copied.

    TargetFilename - supplies the name of the file as it will exist
        in the target tree.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - indicates whether TargetDirectory is a path from the
        root, or relative to a root to specified later.

    CopyFlags -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied

Return Value:

    TRUE if a new copy list entry was created; FALSE if not (ie, the file was
        already on the copy list).

--*/

{
    PDISK_FILE_LIST pDiskList;
    PFILE_TO_COPY pListEntry;
    PFILE_TO_COPY pLastEntry = NULL;

    UNREFERENCED_PARAMETER(DiskCount);

#if defined(REMOTE_BOOT)
    //
    // If TargetDevicePath is NULL, this file is destined for the system
    // partition on a diskless remote boot machine. In this case, we just
    // skip this file.
    //
    if (TargetDevicePath == NULL) {
        return FALSE;
    }
#endif // defined(REMOTE_BOOT)

    pDiskList = &DiskFileLists[DiskNumber];

    for(pListEntry=pDiskList->FileList; pListEntry; pListEntry=pListEntry->Next) {

        //
        // Remember the last entry in the list.
        //
        pLastEntry = pListEntry;

        if(!_wcsicmp(pListEntry->TargetFilename,TargetFilename)
        && !_wcsicmp(pListEntry->SourceFilename,SourceFilename)
        && !_wcsicmp(pListEntry->TargetDirectory,TargetDirectory)
        && !_wcsicmp(pListEntry->TargetDevicePath,TargetDevicePath)
        && (pListEntry->AbsoluteTargetDirectory == AbsoluteTargetDirectory)
//      && (   (pListEntry->CopyOptions == COPY_ALWAYS)
//          || (CopyOptions == COPY_ALWAYS)
//          || (CopyOptions == pListEntry->CopyOptions)
//         )
          )
        {
            //
            // Return code indicates that we did not add a new entry.
            //
            return(FALSE);
        }
    }

    //
    // File not already found; create new entry
    // and link into relevent disk's file list.
    //
    pListEntry = SpMemAlloc(sizeof(FILE_TO_COPY));

    pListEntry->SourceFilename          = SourceFilename;
    pListEntry->TargetDirectory         = TargetDirectory;
    pListEntry->TargetFilename          = TargetFilename;
    pListEntry->TargetDevicePath        = TargetDevicePath;
    pListEntry->AbsoluteTargetDirectory = AbsoluteTargetDirectory;
    pListEntry->Flags                   = CopyFlags;

#if 0
    pListEntry->Next = pDiskList->FileList;
    pDiskList->FileList = pListEntry;
#else
    if( pLastEntry ) {
        pListEntry->Next = NULL;
        pLastEntry->Next = pListEntry;
    } else {
        pListEntry->Next = pDiskList->FileList;
        pDiskList->FileList = pListEntry;
    }
#endif // if 0

    pDiskList->FileCount++;

    //
    // Return code indicates that we added a new entry.
    //
    return(TRUE);
}


VOID
SpAddMasterFileSectionToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           AbsoluteTargetDirectory,
    IN ULONG           CopyOptionsIndex
    )

/*++

Routine Description:

    Adds files listed in a setup information master file section to the
    copy list.

    Each line in the section is expected to be in a standard format:

    [Section]
    <source_filename> = <disk_ordinal>,
                        <target_directory_shortname>,
                        <copy_options_for_upgrade>,
                        <copy_options_for_textmode>,
                        <rename_name>

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device onto which the files
        are to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - If specified, supplies the directory into which the files
        are to be copied on the target; overrides values specified on the lines
        in [<SectionName>].  This allows the caller to specify an absolute directory
        for the files instead of using indirection via a target directory shortname.

    CopyOptionsIndex -
        This specifies which index to look up to get the copy options field. If
        the field is not present it is assumed that this this file is not to
        be copied. Use:
           INDEX_UPGRADE   for upgrade copy options
           INDEX_WINNTFILE for fresh installation copy options

--*/

{
    ULONG Count,u,u1,CopyOptions;
    PWSTR CopyOptionsString, sourceFilename,targetFilename,targetDirSpec,mediaShortname,TargetDirectory;
    BOOLEAN  fAbsoluteTargetDirectory;
    PWSTR section;
    unsigned i;

    for(i=0; i<2; i++) {

        section = i
                ? SpMakePlatformSpecificSectionName(SIF_FILESONSETUPMEDIA)
                : SIF_FILESONSETUPMEDIA;

        //
        // Determine the number of files listed in the section.
        // This value may be zero.
        //
        Count = SpCountLinesInSection(SifHandle,section);
        if (fAbsoluteTargetDirectory = (AbsoluteTargetDirectory != NULL)) {
            TargetDirectory = AbsoluteTargetDirectory;
        }

        for(u=0; u<Count; u++) {

            //
            // Get the copy options using the index provided.  If the field
            // is not present, we don't need to add this to the copy list
            //
            CopyOptionsString = SpGetSectionLineIndex(SifHandle,section,u,CopyOptionsIndex);
            if((CopyOptionsString == NULL) || (*CopyOptionsString == 0)) {
                continue;
            }
            CopyOptions = (ULONG)SpStringToLong(CopyOptionsString,NULL,10);
            if(CopyOptions == COPY_NEVER) {
                continue;
            }

            //
            // get the source file name
            //
            sourceFilename = SpGetKeyName(SifHandle,section, u);

            if(!sourceFilename) {
                SpFatalSifError(SifHandle,section,NULL,u,0);
            }

            //
            // get the destination target dir spec
            //
            targetDirSpec  = SpGetSectionLineIndex(SifHandle,section,u,INDEX_DESTINATION);
            if(!targetDirSpec) {
                SpFatalSifError(SifHandle,section,NULL,u,INDEX_DESTINATION);
            }
            targetFilename = SpGetSectionLineIndex(SifHandle,section,u,INDEX_TARGETNAME);
            if(!targetFilename || !(*targetFilename)) {
                targetFilename = sourceFilename;
            }

            //
            // Look up the actual target directory if necessary.
            //
            if(!fAbsoluteTargetDirectory) {
                TargetDirectory = SpLookUpTargetDirectory(SifHandle,targetDirSpec);
            }

            //
            // get the media shortname
            //
            mediaShortname = SpGetSectionLineIndex(SifHandle,section,u,INDEX_WHICHMEDIA);
            if(!mediaShortname) {
                SpFatalSifError(SifHandle,section,NULL,u,INDEX_WHICHMEDIA);
            }

            //
            // Look up the disk in the disk file lists array.
            //
            for(u1=0; u1<DiskCount; u1++) {
                if(!_wcsicmp(mediaShortname,DiskFileLists[u1].MediaShortname)) {
                    break;
                }
            }

            //
            // If we didn't find the media descriptor, then it's invalid.
            //
            if(u1 == DiskCount) {
                SpFatalSifError(SifHandle,section,sourceFilename,0,INDEX_WHICHMEDIA);
            }

            //
            // Create a new file list entry if the file is not already being copied.
            //
            SpCreateEntryInCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                u1,
                sourceFilename,
                TargetDirectory,
                targetFilename,
                TargetDevicePath,
                fAbsoluteTargetDirectory,
                CopyOptions
                );
        }

        if(i) {
            SpMemFree(section);
        }
    }
}


VOID
SpAddSingleFileToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SifSection,
    IN PWSTR           SifKey,             OPTIONAL
    IN ULONG           SifLine,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,    OPTIONAL
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp
    )

/*++

Routine Description:

    Adds a single file to the list of files to be copied.

    The file, along with the directory into which it is to be copied
    n the target and the name it is to receive on the target, is listed
    in a section in the setup information file.

    The filename is used to index the master file list to determine the
    source media where it resides.

    All this information is recorded in a structure associated with
    the disk on which the file resides.

    [SpecialFiles]
    mpkernel = ntkrnlmp.exe,4,ntoskrnl.exe
    upkernel = ntoskrnl.exe,4,ntoskrnl.exe
    etc.

    [MasterFileList]
    ntkrnlmp.exe = d2
    ntoskrnl.exe = d3
    etc.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SifSection - supplies the name of the section that lists the file
        being added to the copy list.

    SifKey - if specified, supplies the keyname for the line in SifSection
        that lists the file to be added to the copy list.

    SifLine - if SifKey is not specified, this parameter supplies the 0-based
        line number of the line in SifSection that lists the file to be added
        to the copy list.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    TargetDirectory - If specified, supplies the directory into which the file
        is to be copied on the target; overrides the value specified on the line
        in SifSection.  This allows the caller to specify an absolute directory
        for the file instead of using indirection.

    CopyOptions -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied                            None.

    CheckForNoComp - if true, check this file to see if it must remain uncompressed
        on an NTFS system partition supporting compression.
        If so, then OR the CopyOptions value with COPY_FORCENOCOMP.

Return Value:

    None.

--*/

{
    PWSTR sourceFilename,targetDirSpec,targetFilename;
    ULONG u;
    PWSTR mediaShortname;
    BOOLEAN absoluteTargetDirectory;

    //
    // Get the source filename, target directory spec, and target filename.
    //
    if(SifKey) {

        sourceFilename = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,0);
        targetDirSpec  = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,1);
        targetFilename = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,2);

    } else {

        sourceFilename = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,0);
        targetDirSpec  = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,1);
        targetFilename = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,2);
    }


    //
    // Validate source filename, target directory spec, and target filename.
    //
    if(!sourceFilename) {
        SpFatalSifError(SifHandle,SifSection,SifKey,SifLine,0);

        return;
    }

    if(!targetDirSpec) {
        SpFatalSifError(SifHandle,SifSection,SifKey,SifLine,1);

        return;
    }

    if(!targetFilename ||
        (!_wcsicmp(SifSection, L"SCSI.Load") &&
         !_wcsicmp(targetFilename,L"noload"))) {
        targetFilename = sourceFilename;
    }

    //
    // Look up the actual target directory if necessary.
    //
    if(TargetDirectory) {

        absoluteTargetDirectory = TRUE;

    } else {

        absoluteTargetDirectory = FALSE;
        TargetDirectory = SpLookUpTargetDirectory(SifHandle,targetDirSpec);
    }

    //
    // Look up the file in the master file list to get
    // the media shortname of the disk where the file is located.
    //
    mediaShortname = SpLookUpValueForFile(SifHandle,sourceFilename,INDEX_WHICHMEDIA,TRUE);

    //
    // Look up the disk in the disk file lists array.
    //
    for(u=0; u<DiskCount; u++) {
        if(!_wcsicmp(mediaShortname,DiskFileLists[u].MediaShortname)) {
            break;
        }
    }

    //
    // If we didn't find the media descriptor, then it's invalid.
    //
    if(u == DiskCount) {
        SpFatalSifError(SifHandle,SIF_FILESONSETUPMEDIA,sourceFilename,0,INDEX_WHICHMEDIA);
    }

    //
    // If necessary, check to see whether this file cannot use NTFS compression. If it cannot,
    // then OR the CopyOptions with COPY_FORCENOCOMP.
    //
    if(CheckForNoComp && IsFileFlagSet(SifHandle,targetFilename,FILEFLG_FORCENOCOMP)) {

        CopyOptions |= COPY_FORCENOCOMP;
    }

    //
    // Create a new file list entry if the file is not already being copied.
    //
    SpCreateEntryInCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        u,
        sourceFilename,
        TargetDirectory,
        targetFilename,
        TargetDevicePath,
        absoluteTargetDirectory,
        CopyOptions
        );
}


VOID
SpAddSectionFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SectionName,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp
    )

/*++

Routine Description:

    Adds files listed in a setup information file section to the copy list.

    Each line in the section is expected to be in a standard format:

    [Section]
    <source_filename>,<target_directory_shortname>[,<target_filename>]

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SectionName - supplies the name of the section that lists the files
        being added to the copy list.

    TargetDevicePath - supplies the NT name of the device onto which the files
        are to be copied (ie, \device\harddisk1\partition2, etc).

    TargetDirectory - If specified, supplies the directory into which the files
        are to be copied on the target; overrides values specified on the lines
        in [<SectionName>].  This allows the caller to specify an absolute directory
        for the files instead of using indirection via a target directory shortname.

    CopyOptions -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied

    CheckForNoComp - if true, then check each file to see if it must exist uncompressed
        on an NTFS partition supporting compression (ie, NTLDR on x86).
--*/

{
    ULONG Count,u;

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SectionName);

    for(u=0; u<Count; u++) {

        //
        // Add this line to the copy list.
        //

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SectionName,
            NULL,
            u,
            TargetDevicePath,
            TargetDirectory,
            CopyOptions,
            CheckForNoComp
            );
    }
}

VOID
SpAddHalKrnlDetToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           SystemPartition,
    IN PWSTR           SystemPartitionDirectory,
    IN BOOLEAN         Uniprocessor
    )
/*++

Routine Description:

    Add the following files based on configuration:

    - the up or mp kernel.
    - the HAL
    - the detect module [x86 only]

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.

    SystemPartition - supplies the NT name of the device that will hold the
        system partition.

    SystemPartitionDirectoty - supplies the directory on the system partition
        into which files that go on the system partition will be copied.

    Uniprocessor - if true, then we are installing/upgrading a UP system.
        Note that this a different question than the number of processors
        in the system.

Return Value:

    None.

--*/

{
    PHARDWARE_COMPONENT pHw;

    //
    // Add the right kernel to the copy list.
    //
    SpAddSingleFileToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SIF_SPECIALFILES,
        Uniprocessor ? SIF_UPKERNEL : SIF_MPKERNEL,
        0,
        TargetDevicePath,
        NULL,
        COPY_ALWAYS,
        FALSE
        );

#ifdef _X86_

    // Check to see if we should add the PAE kernel to the copy list.
    // Since some skus like pro/per don't have these kernels, they should not list them in the txtsetup.sif.

    if ( SpGetSectionKeyIndex(SifHandle,SIF_SPECIALFILES,Uniprocessor ? L"UPKrnlPa" : L"MPKrnlPa",0)) {
        //
        // Add the right PAE kernel to the copy list.
        //
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            Uniprocessor ? L"UPKrnlPa" : L"MPKrnlPa",
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }
#endif // defined _X86_


    //
    // Add the hal to the file copy list.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentComputer] == NULL) ) {
        pHw = HardwareComponents[HwComponentComputer];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentComputer];
    }
    if(!pHw->ThirdPartyOptionSelected) {
        SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_HAL,
                pHw->IdString,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
    }

#ifdef _X86_

    if (SpIsArc()) {
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_BOOTVID,
            pHw->IdString,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }


    //
    // If a third party computer was not specified, then there will be a
    // detect module specified in the [ntdetect] section of the inf file
    // for the computer.
    // If a third-party computer was specified, then there may or may not
    // be a detect module.  If there is no detect module specified, then
    // copy the 'standard' one.
    //
    {
        PWSTR NtDetectId = NULL;

        if(!pHw->ThirdPartyOptionSelected) {
            NtDetectId = pHw->IdString;
        } else {
            if(!IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileDetect)) {
                NtDetectId = SIF_STANDARD;
            }
        }

        if(NtDetectId) {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_NTDETECT,
                NtDetectId,
                0,
                SystemPartition,
                SystemPartitionDirectory,
                COPY_ALWAYS,
                FALSE
                );
        }
    }
#endif

}

VOID
SpAddBusExtendersToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath
    )

/*++

Routine Description:

    Add to the copy list the bus extender related files and the mouse and keyboard related files,
    that are copied based on the configuration of the machine.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.


Return Value:

    None.

--*/

{
    ULONG i;
    PHARDWARE_COMPONENT pHw;
    PWSTR SectionName;
    PHARDWARE_COMPONENT DeviceLists[] = {
                                        BootBusExtenders,
                                        BusExtenders,
                                        InputDevicesSupport
                                        };
    PWSTR   SectionNames[] = {
                             SIF_BOOTBUSEXTENDERS,
                             SIF_BUSEXTENDERS,
                             SIF_INPUTDEVICESSUPPORT
                             };


    //
    //  Add the bus extender and input device drivers to the copy list
    //
    for( i = 0; i < sizeof(DeviceLists) / sizeof(PDETECTED_DEVICE); i++ ) {
        for( pHw = DeviceLists[i]; pHw; pHw=pHw->Next) {

            //
            // Get the name of the section containing files for this device.
            //
            SectionName = SpGetSectionKeyIndex(
                                    SifHandle,
                                    SectionNames[i],
                                    pHw->IdString,
                                    INDEX_FILESECTION
                                    );

            if(!SectionName) {
                SpFatalSifError(
                    SifHandle,
                    SectionNames[i],
                    pHw->IdString,
                    0,
                    INDEX_FILESECTION
                    );

                return;  // for prefix
            }

            //
            // Add that section's files to the copy list.
            //
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SectionName,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
        }
    }
}


VOID
SpAddConditionalFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           SystemPartition,
    IN PWSTR           SystemPartitionDirectory,
    IN BOOLEAN         Uniprocessor
    )

/*++

Routine Description:

    Add files to the copy list that are copied based on the configuration
    of the machine and user selections.

    This may include:

    - the up or mp kernel.
    - abiosdsk
    - vga files [x86 only]
    - files for computer, keyboard, mouse, display, and layout
    - scsi miniport drivers
    - mouse and keyboard class drivers
    - the HAL
    - the detect module [x86 only]
    - bus extender drivers

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.

    SystemPartition - supplies the NT name of the device that will hold the
        system partition.

    SystemPartitionDirectoty - supplies the directory on the system partition
        into which files that go on the system partition will be copied.

    Uniprocessor - if true, then we are installing/upgrading a UP system.
        Note that this a different question than the number of processors
        in the system.

Return Value:

    None.

--*/

{
    ULONG i;
    PHARDWARE_COMPONENT pHw;
    PWSTR SectionName;

    //
    // Add the hal, kernel and ntdetect to the copy list
    //

    SpAddHalKrnlDetToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        TargetDevicePath,
        SystemPartition,
        SystemPartitionDirectory,
        Uniprocessor
        );

    //
    // If there are any abios disks, copy the abios disk driver.
    //
    if(AbiosDisksExist) {

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            SIF_ABIOSDISK,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }

    //
    // Always copy vga files.
    //
    SpAddSectionFilesToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SIF_VGAFILES,
        TargetDevicePath,
        NULL,
        COPY_ALWAYS,
        FALSE
        );

    //
    // Add the correct device driver files to the copy list.
    //
    for(i=0; i<HwComponentMax; i++) {

        //
        // Layout is handled elsewhere.
        //
        if(i == HwComponentLayout) {
            continue;
        }

        if( !PreInstall ||
            ( PreinstallHardwareComponents[i] == NULL ) ) {
            pHw = HardwareComponents[i];
        } else {
            pHw = PreinstallHardwareComponents[i];
        }

        for( ; pHw != NULL; pHw = pHw->Next ) {
            //
            // No files to copy here for third-party options.
            // This is handled elsewhere.
            //
            if(pHw->ThirdPartyOptionSelected) {
                continue;
            }

            //
            // Get the name of the section containing files for this device.
            //
            SectionName = SpGetSectionKeyIndex(
                                SifHandle,
                                NonlocalizedComponentNames[i],
                                pHw->IdString,
                                INDEX_FILESECTION
                                );

            if(!SectionName) {
                SpFatalSifError(
                    SifHandle,
                    NonlocalizedComponentNames[i],
                    pHw->IdString,
                    0,
                    INDEX_FILESECTION
                    );

                return; // for prefix
            }

            //
            // Add that section's files to the copy list.
            //
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SectionName,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
        }
    }

    //
    // Add the keyboard layout dll to the copy list.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentLayout] == NULL) ) {
        pHw = HardwareComponents[HwComponentLayout];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentLayout];
    }
    //
    if(!pHw->ThirdPartyOptionSelected) {

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_KEYBOARDLAYOUTFILES,
            pHw->IdString,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }

    //
    // Add scsi miniport drivers to the copy list.
    // Because miniport drivers are only a single file,
    // we just use the filename specified in [SCSI.Load] --
    // no need for separate [files.xxxx] sections.
    //
    if( !PreInstall ||
        ( PreinstallScsiHardware == NULL ) ) {
        pHw = ScsiHardware;
    } else {
        pHw = PreinstallScsiHardware;
    }
    for( ; pHw; pHw=pHw->Next) {
        if(!pHw->ThirdPartyOptionSelected) {

            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                L"SCSI.Load",
                pHw->IdString,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
        }
    }

    SpAddBusExtendersToCopyList( SifHandle,
                                 DiskFileLists,
                                 DiskCount,
                                 TargetDevicePath );


#if 0
    //
    // If not being replaced by third-party ones, add keyboard and mouse
    // class drivers.
    // Note that in the pre-install case, keyboard and class drivers will
    // be added if at least one retail mouse or keyborad driver are
    // to be pre-installed.
    //
    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentMouse] == NULL ) ) {
        pHw=HardwareComponents[HwComponentMouse];
    } else {
        pHw=PreinstallHardwareComponents[HwComponentMouse];
    }
    for( ;pHw;pHw=pHw->Next ) {
        if(!pHw->ThirdPartyOptionSelected
        || !IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileClass))
        {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_MOUSECLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
            //
            //  We don't need to continue to look at the other mouse drivers
            //  since we have already added the class driver
            //
            break;
        }
    }

    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentKeyboard] == NULL ) ) {
        pHw=HardwareComponents[HwComponentKeyboard];
    } else {
        pHw=PreinstallHardwareComponents[HwComponentKeyboard];
    }
    for( ;pHw;pHw=pHw->Next ) {
        if(!pHw->ThirdPartyOptionSelected
        || !IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileClass))
        {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_KEYBOARDCLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
            //
            //  We don't need to continue to look at the other keyboard drivers
            //  since we have already added the class driver
            //
            break;
        }
    }
#endif // if 0

    if( ( HardwareComponents[HwComponentMouse] != NULL ) &&
        ( _wcsicmp( (HardwareComponents[HwComponentMouse])->IdString, L"none" ) != 0)
      ) {
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            SIF_MOUSECLASS,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }

    if( HardwareComponents[HwComponentKeyboard] != NULL ) {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_KEYBOARDCLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
    }

}


VOID
SpDontOverwriteMigratedDrivers (
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    )
{
    PLIST_ENTRY ListEntry;
    PSP_MIG_DRIVER_ENTRY MigEntry;

    while (!IsListEmpty(&MigratedDriversList)) {

        ListEntry = RemoveHeadList(&MigratedDriversList);
        MigEntry = CONTAINING_RECORD(ListEntry, SP_MIG_DRIVER_ENTRY, ListEntry);

        SpRemoveEntryFromCopyList (
            DiskFileLists,
            DiskCount,
            L"system32\\drivers",
            MigEntry->BaseDllName,
            SysrootDevice,
            FALSE
            );

        SpMemFree(MigEntry->BaseDllName);
        SpMemFree(MigEntry);
    }
}


VOID
SpCopyThirdPartyDrivers(
    IN PWSTR           SourceDevicePath,
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    )
{
    ULONG component;
    PHARDWARE_COMPONENT pHw;
    PHARDWARE_COMPONENT_FILE pHwFile;
    FILE_TO_COPY FileDescriptor;
    PWSTR TargetRoot;
    PWSTR InfNameBases[HwComponentMax+1] = { L"cpt", L"vio", L"kbd", L"lay", L"ptr", L"scs" };
    ULONG InfCounts[HwComponentMax+1] = { 0,0,0,0,0,0 };
    WCHAR InfFilename[20];
    ULONG CheckSum;
    BOOLEAN FileSkipped;
    ULONG TargetFileAttribs;
    ULONG CopyFlags;
    PWSTR OemDirPath;
    BOOLEAN OemDirExists;
    PWSTR NtOemSourceDevicePath;

    //
    //  Find out if the %SystemRoot%\OemDir exists. This directory will be needed if the third party drivers
    //  istalled contain a catalog.
    //
    OemDirPath = SpMemAlloc(ACTUAL_MAX_PATH * sizeof(WCHAR));
    wcscpy( OemDirPath, SysrootDevice );
    SpConcatenatePaths( OemDirPath, Sysroot );
    SpConcatenatePaths( OemDirPath, OemDirName );
    OemDirExists = SpFileExists( OemDirPath, TRUE );
    SpMemFree( OemDirPath );
    OemDirPath = NULL;

    for(component=0; component<=HwComponentMax; component++) {

        //
        // If we're upgrading, then we only want to copy third-party HALs or SCSI
        // drivers (if supplied)
        //
        if((NTUpgrade == UpgradeFull) &&
           !((component == HwComponentComputer) || (component == HwComponentMax))) {
            continue;
        }

        //
        // Handle scsi specially.
        //
        pHw = (component==HwComponentMax) ? ( ( !PreInstall ||
                                                ( PreinstallScsiHardware == NULL )
                                              )?
                                              ScsiHardware :
                                              PreinstallScsiHardware
                                            )
                                            :
                                            ( ( !PreInstall ||
                                                ( PreinstallHardwareComponents[component] == NULL )
                                              )?
                                              HardwareComponents[component] :
                                              PreinstallHardwareComponents[component]
                                            );

        //
        // Look at each instance of this component.
        //
        for( ; pHw; pHw=pHw->Next) {
            BOOLEAN CatalogIsPresent;
            BOOLEAN DynamicUpdateComponent = (IS_FILETYPE_PRESENT(pHw->FileTypeBits, HwFileDynUpdt) != 0);
            
            //
            // Skip this device if not a third-party selection.
            //
            if(!pHw->ThirdPartyOptionSelected) {
                continue;
            }

            //
            //  Create the OemDir if necessary
            //
            if( !OemDirExists ) {
                SpCreateDirectory( SysrootDevice,
                                   Sysroot,
                                   OemDirName,
                                   0,
                                   0 );
                OemDirExists = TRUE;
            }

            //
            //  Find out if a catalog was provided with this third party driver
            //
            for(CatalogIsPresent=FALSE, pHwFile=pHw->Files; pHwFile; pHwFile=pHwFile->Next) {
                if(pHwFile->FileType == HwFileCatalog) {
                    CatalogIsPresent = TRUE;
                    break;
                }
            }

            //
            // Loop through the list of files associated with this selection.
            //
            for(pHwFile=pHw->Files; pHwFile; pHwFile=pHwFile->Next) {
                //
                // Assume the file goes on the nt drive (as opposed to
                // the system partition drive) and that the target name
                // is the same as the source name.  Also, assume no special
                // attributes (ie, FILE_ATTRIBUTE_NORMAL)
                //
                FileDescriptor.Next             = NULL;
                FileDescriptor.SourceFilename   = pHwFile->Filename;
                FileDescriptor.TargetDevicePath = SysrootDevice;
                FileDescriptor.TargetFilename   = FileDescriptor.SourceFilename;
                FileDescriptor.Flags            = COPY_ALWAYS;
                FileDescriptor.AbsoluteTargetDirectory = FALSE;
                TargetFileAttribs = 0;
                NtOemSourceDevicePath = NULL;

                if (pHwFile->ArcDeviceName) {
                    NtOemSourceDevicePath = SpArcToNt(pHwFile->ArcDeviceName);
                }

                if (!NtOemSourceDevicePath) {
                    NtOemSourceDevicePath = SourceDevicePath;
                }


                switch(pHwFile->FileType) {


                //
                // Driver, port, and class type files are all device drivers
                // and are treated the same -- they get copied to the
                // system32\drivers directory.
                //
                case HwFileDriver:
                case HwFilePort:
                case HwFileClass:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32\\drivers";
                    break;

                //
                // Dlls get copied to the system32 directory.
                //
                case HwFileDll:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32";
                    break;

                //
                // Catalogs get copied to the OemDir directory.
                //
                case HwFileCatalog:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = OemDirName;
                    break;

                //
                // Inf files get copied to the system32 directory and are
                // renamed based on the component.
                //
                case HwFileInf:

                    if(InfCounts[component] < 99) {

                        InfCounts[component]++;         // names start at 1

                        swprintf(
                            InfFilename,
                            L"oem%s%02d.inf",
                            InfNameBases[component],
                            InfCounts[component]
                            );

                        FileDescriptor.TargetFilename = InfFilename;
                    }

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = OemDirName;
                    break;

                //
                // Hal files are renamed to hal.dll and copied to the system32
                // directory
                //
                case HwFileHal:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32";
                    FileDescriptor.TargetFilename = L"hal.dll";
                    break;

                //
                // Detect modules are renamed to ntdetect.com and copied to
                // the root of the system partition (C:).
                //
                case HwFileDetect:

                    TargetRoot = NULL;
                    FileDescriptor.TargetDevicePath = SyspartDevice;
                    FileDescriptor.TargetDirectory = SyspartDirectory;
                    FileDescriptor.TargetFilename = L"ntdetect.com";
                    TargetFileAttribs = ATTR_RHS;
                    break;
                }

                if( !PreInstall && !DynamicUpdateComponent) {
                    //
                    // Prompt for the disk.
                    //
                    SpPromptForDisk(
                        pHwFile->DiskDescription,
                        NtOemSourceDevicePath,
                        pHwFile->DiskTagFile,
                        FALSE,                  // don't ignore disk in drive
                        FALSE,                  // don't allow escape
                        FALSE,                  // don't warn about multiple prompts
                        NULL                    // don't care about redraw flag
                        );
                }

                //
                // Passing the empty string as the first arg forces
                // the action area of the status line to be set up.
                // Not doing so results in the "Copying: xxxxx" to be
                // flush left on the status line instead of where
                // it belongs (flush right).
                //
                SpCopyFilesScreenRepaint(L"",NULL,TRUE);

                //
                // Copy the file.
                //
                SpCopyFileWithRetry(
                    &FileDescriptor,
                    NtOemSourceDevicePath,
                    (PreInstall) ? PreinstallOemSourcePath : pHwFile->Directory,
                    NULL,
                    TargetRoot,
                    TargetFileAttribs,
                    SpCopyFilesScreenRepaint,
                    &CheckSum,
                    &FileSkipped,
                    COPY_SOURCEISOEM
                    );

                //
                // Log the file
                //
                if( !FileSkipped ) {
                    //
                    //  Catalog files don't need to be logged, since they don't need to be repaired.
                    //
                    if ( pHwFile->FileType != HwFileCatalog ) {
                        SpLogOneFile( &FileDescriptor,
                                      TargetRoot,
                                      pHwFile->Directory,
                                      pHwFile->DiskDescription,
                                      pHwFile->DiskTagFile,
                                      CheckSum );
                    }

                    //
                    //  If a catalog is part of the third party driver being installed, then we need to copy
                    //  the file to OemDir also. Note that we don't copy the catalog to the OemDir directory,
                    //  since it was already copied.
                    //
                    if(pHwFile->FileType != HwFileCatalog){
                        //
                        // Save off original target directory.
                        //
                        PWSTR   SpOriginalTargetDir = FileDescriptor.TargetDirectory;
                        
                        FileDescriptor.TargetDirectory = OemDirName;

                        SpCopyFileWithRetry(
                            &FileDescriptor,
                            NtOemSourceDevicePath,
                            (PreInstall)? PreinstallOemSourcePath : pHwFile->Directory,
                            NULL,
                            TargetRoot,
                            TargetFileAttribs,
                            SpCopyFilesScreenRepaint,
                            &CheckSum,
                            &FileSkipped,
                            COPY_SOURCEISOEM
                        );

                        //
                        //  If this was an inf file then we need to remember its name
                        //
                        if( pHwFile->FileType == HwFileInf ) {
                            POEM_INF_FILE   p;

                            p = SpMemAlloc( sizeof(OEM_INF_FILE) );
                            p->InfName = SpDupStringW( FileDescriptor.TargetFilename );
                            p->Next = OemInfFileList;
                            OemInfFileList = p;
                        }

                        //
                        // Restore original target directory so as to remove the correct 
                        // entry from the file list to copy.
                        //
                        if (SpOriginalTargetDir){
                            FileDescriptor.TargetDirectory = SpOriginalTargetDir;
                            SpOriginalTargetDir = NULL;
                        }
                    }

                }
                //
                // Remove the file from the copy list so that it won't be overwritten
                //
                SpRemoveEntryFromCopyList( DiskFileLists,
                                           DiskCount,
                                           FileDescriptor.TargetDirectory,
                                           FileDescriptor.TargetFilename,
                                           FileDescriptor.TargetDevicePath,
                                           FileDescriptor.AbsoluteTargetDirectory );

            }
        }
    }
}


#ifdef _X86_
VOID
SpCopyNtbootddScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    UNREFERENCED_PARAMETER(FullSourcename);
    UNREFERENCED_PARAMETER(FullTargetname);
    UNREFERENCED_PARAMETER(RepaintEntireScreen);

    //
    // Just put up a message indicating that we are setting up
    // boot params.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_DOING_NTBOOTDD,DEFAULT_STATUS_ATTRIBUTE);
}

BOOLEAN
FindFalsexInt13Support(
    IN PVOID        SifHandle
    )

/*++

Routine Description:

    Go look through the devices installed and see if any match our
    list of known devices that may lie to us about their support for
    xInt13.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    TRUE - We found a match.

    FALSE otherwise

--*/

{
    HARDWAREIDLIST     *MyHardwareIDList = HardwareIDList;

    while( MyHardwareIDList ) {
        if( MyHardwareIDList->HardwareID ) {
            if( SpGetSectionKeyExists(SifHandle, L"BadXInt13Devices", MyHardwareIDList->HardwareID) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FindFalsexInt13Support: Found it.\n" ));
                return TRUE;
            }
        }

        MyHardwareIDList = MyHardwareIDList->Next;
    }

    return FALSE;
}


BOOL
SpUseBIOSToBoot(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PVOID        SifHandle
    )
/*++

Routine Description:

    Determine if we need a mini port driver to boot or if we can rely
    on the BIOS.


Arguments:

    NtPartitionRegion - supplies the region descriptor for the disk region
        onto which the user chose to install Windows NT.

    NtPartitionDevicePath - supplies the nt namespace pathname for the
        partition onto which the user chose to install Windows NT.

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    TRUE - we can safely rely on the BIOS to boot.

    FALSE - we will need a mini port driver to boot.

--*/
{
    PDISK_SIGNATURE_INFORMATION DiskSignature;
    PWSTR p;

    if( ForceBIOSBoot ) {
        //
        // Either the user has asked us to force the use of the BIOS
        // to boot, or we've already manually checked and determined
        // that it's okay to use the BIOS.
        //
        return TRUE;
    }


    //
    // This may be the first time we've been called.  see if the user
    // wants us to force a BIOS boot.
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"UseBIOSToBoot",0);
    if( p != NULL ) {
        //
        // The user wants us to use the BIOS.  Set our global and
        // get out of here.
        //
        ForceBIOSBoot = TRUE;
        return TRUE;
    }



    //
    // The NtPartitionDevicePath may or may not be available to the
    // caller.  If it isn't, then attempt to derive it from the
    // NtPartitionRegion.
    //
    if( NtPartitionDevicePath ) {
        p = SpNtToArc( NtPartitionDevicePath, PrimaryArcPath );
    } else {
        p = SpMemAlloc( (MAX_PATH*2) );
        if( p ) {
            SpArcNameFromRegion( NtPartitionRegion,
                                 p,
                                 (MAX_PATH*2),
                                 PartitionOrdinalOnDisk,
                                 PrimaryArcPath );
        }
    }

    if(p) {
        if( _wcsnicmp(p,L"multi(",6) == 0 ) {

            if( !SpIsRegionBeyondCylinder1024(NtPartitionRegion) ) {
                //
                // This region is very small, so we won't be needing
                // a miniport to boot.
                //
                ForceBIOSBoot = TRUE;
            } else {
                //
                // Hang on.  This disk is big, but it may support xint13.  In
                // that case we won't need a miniport.  Luckily, we have that
                // information stored away.
                //
                DiskSignature = DiskSignatureInformation;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: About to search through the DiskSignatureInformation database for a device called %ws\n", p ));

                while( DiskSignature != NULL ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: this DiskSignatureInformation entry is called %ws\n", DiskSignature->ArcPath ));

                    if( !_wcsnicmp( p, DiskSignature->ArcPath, wcslen(DiskSignature->ArcPath) ) ) {

                        //
                        // We found our disk.  Now just check his support for xint13.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I think they matched.\n" ));

                        if( DiskSignature->xInt13 ) {
                            //
                            // Yep, he's going to support xint13, so there's
                            // nothing for us to do here.
                            //

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I think he's got xInt13 support.\n" ));

                            //
                            // But it's possible that the BIOS has lied to us about his xInt13
                            // support.  We want to go check txtsetup.sif and see if this is a
                            // known controller that we don't support.
                            //
                            if( HardDisks[NtPartitionRegion->DiskNumber].Description[0] ) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: His description is: %ws\n", HardDisks[NtPartitionRegion->DiskNumber].Description ));
                            } else {
                                //
                                // Odd...  This guy doesn't have a description.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: This device has no description!\n" ));
                            }


                            //
                            // Now go look in txtsetup.sif and see if this is listed as a device
                            // that I don't believe.
                            //

                            if( FindFalsexInt13Support(SifHandle) ) {
                                //
                                // We think this guy might be lying to us when he tells
                                // us that he supports xint13.  Assume that he really
                                // doesn't, which means we'll be using a miniport to
                                // boot.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: This machine has a device that may erroneously indicate its xint13 support.\n" ));
                                break;
                            } else {

                                //
                                // This device isn't lised in the list that
                                // we don't believe, so assume that he
                                // really does have xint13 support.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpCreateNtbootddSys: I trust this device when he tells me he has xint13 support.\n" ));

                                //
                                // Remember that we're going to use the BIOS to boot rather than
                                // a miniport.
                                //
                                ForceBIOSBoot = TRUE;
                                break;
                            }

                        } else {

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I don't think he has xInt13 support.\n" ));
                        }
                    } else {
                        //
                        // This isn't the right region.  Fall through and look at
                        // the next one.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: They didn't match.\n" ));
                    }

                    DiskSignature = DiskSignature->Next;
                }

            }

        }

        SpMemFree(p);

    }

    return ForceBIOSBoot;

}


VOID
SpCreateNtbootddSys(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDevicePath,
    IN PVOID        SifHandle,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Create c:\ntbootdd.sys if necessary.

    The scsi miniport driver file will be copied from the drivers directory
    (where it was copied during the earlier file copy phase) to c:\ntbootdd.sys.

    In the atapi case, the file ataboot.sys will be copied from the media to
    c:\ntbootdd.sys.

    NOTE: We're not going to support this on atapi devices anymore.  However,
    I'm leaving the code here in case we want to do it again later.  This code
    should execute early because I've modifed SpGetDiskInfo, so that
    ScsiMiniportShortname won't ever get set for atapi devices. -matth

Arguments:

    NtPartitionRegion - supplies the region descriptor for the disk region
        onto which the user chose to install Windows NT.

    NtPartitionDevicePath - supplies the nt namespace pathname for the
        partition onto which the user chose to install Windows NT.

    Sysroot - supplies the directory on the target partition.

    SystemPartitionDevicePath - supplies the nt device path of the partition
        onto which to copy ntbootdd.sys (ie, C:\).

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath- Path to the device that contains the source.

    DirectoryOnSourceDevice - Supplies the directory on the source where
        the file is to be found.


Return Value:

    None.

--*/

{
    PWSTR MiniportDriverBasename;
    PWSTR MiniportDriverFilename;
    FILE_TO_COPY Descriptor;
    PWSTR DriversDirectory,p;
    ULONG CheckSum;
    BOOLEAN FileSkipped;
    ULONG CopyFlags;
    BOOLEAN IsAtapi = FALSE;

    //
    // no PC98 need NTBOOTDD.SYS.
    //
    if (IsNEC_98) {
        return;
    }

#if defined(REMOTE_BOOT)
    //
    // If the NT partition is on DiskNumber -1, this is a remote boot setup,
    // so there's nothing to do.
    //
    if (NtPartitionRegion->DiskNumber == 0xffffffff) {
        return;
    }
#endif // defined(REMOTE_BOOT)

    //
    // If the Nt Partition is not on a scsi disk, there's nothing to do.
    //
    MiniportDriverBasename = HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname;
    if(*MiniportDriverBasename == 0) {
        return;
    }

    if( SpUseBIOSToBoot(NtPartitionRegion, NtPartitionDevicePath, SifHandle) ) {
        //
        // We can use the BIOS, so there's no reason to continue.
        //
        return;
    }

    IsAtapi = (_wcsicmp(MiniportDriverBasename,L"atapi") == 0);

    if( !IsAtapi ) {
        //
        // Form the name of the scsi miniport driver.
        //
        wcscpy(TemporaryBuffer,MiniportDriverBasename);
        wcscat(TemporaryBuffer,L".sys");
    } else {
        wcscpy(TemporaryBuffer,L"ataboot.sys");
    }
    MiniportDriverFilename = SpDupStringW(TemporaryBuffer);

    if( !IsAtapi ) {
        //
        // Form the full path to the drivers directory.
        //
        wcscpy(TemporaryBuffer,Sysroot);
        SpConcatenatePaths(TemporaryBuffer,L"system32\\drivers");
    } else {
        //
        // If it is atapi then make DriversDirectory point to the source media
        //

        PWSTR   MediaShortName;
        PWSTR   MediaDirectory;

        MediaShortName = SpLookUpValueForFile( SifHandle,
                                               MiniportDriverFilename,  // L"ataboot.sys",
                                               INDEX_WHICHMEDIA,
                                               TRUE );

        SpGetSourceMediaInfo(SifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

        wcscpy(TemporaryBuffer,DirectoryOnSourceDevice);
        SpConcatenatePaths(TemporaryBuffer,MediaDirectory);
    }
    DriversDirectory = SpDupStringW(TemporaryBuffer);

    //
    //
    // Fill in the fields of the file descriptor.
    //
    Descriptor.SourceFilename   = MiniportDriverFilename;
    Descriptor.TargetDevicePath = SystemPartitionDevicePath;
    Descriptor.TargetDirectory  = L"";
    Descriptor.TargetFilename   = L"NTBOOTDD.SYS";
    Descriptor.Flags            = COPY_ALWAYS;

    CopyFlags = 0;
    if(!WIN9X_OR_NT_UPGRADE || IsFileFlagSet(SifHandle,Descriptor.TargetFilename,FILEFLG_NOVERSIONCHECK)) {
        CopyFlags |= COPY_NOVERSIONCHECK;
    }

    //
    // Copy the file.
    //
    SpCopyFileWithRetry(
        &Descriptor,
        (IsAtapi) ? SourceDevicePath : NtPartitionDevicePath,
        DriversDirectory,
        NULL,
        NULL,
        ATTR_RHS,
        SpCopyNtbootddScreenRepaint,
        &CheckSum,
        &FileSkipped,
        CopyFlags
        );

    //
    // Log the file
    //
    if( !FileSkipped ) {
        SpLogOneFile( &Descriptor,
                      Sysroot,
                      NULL,
                      NULL,
                      NULL,
                      CheckSum );
    }

    //
    // Clean up.
    //
    SpMemFree(MiniportDriverFilename);
    SpMemFree(DriversDirectory);
}
#endif

VOID
SpCopyFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDirectory,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        ThirdPartySourceDevicePath
    )
{
    PDISK_FILE_LIST DiskFileLists;
    ULONG   DiskCount;
    PWSTR   NtPartition,SystemPartition;
    PWSTR   p;
    BOOLEAN Uniprocessor;
    ULONG n;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NtPartitionString;
    IO_STATUS_BLOCK IoStatusBlock;
    INCOMPATIBLE_FILE_LIST IncompatibleFileListHead;

    CLEAR_CLIENT_SCREEN();

    Uniprocessor = !SpInstallingMp();

    //
    // open a handle to the driver inf file
    //
    SpInitializeDriverInf(SifHandle,
                          SourceDevicePath,
                          DirectoryOnSourceDevice);

    //
    // initialize alternate sources (if any)
    //
    SpInitAlternateSource ();

    //
    // Skip copying if directed to do so in the setup information file.
    //
    if((p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_DONTCOPY,0))
    && SpStringToLong(p,NULL,10))
    {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DontCopy flag is set in .sif; skipping file copying\n"));
        return;
    }

    //
    // Initialize the diamond decompression engine. In the remote boot
    // case this will already have been initialized.
    //
    if (!RemoteInstallSetup) {
        SpdInitialize();
    }

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Get the device path of the system partition.
    //
    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion(
            SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Create the system partition directory.
    //
    if (SystemPartition != NULL) {
        SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
#ifdef _IA64_
        {
        PWSTR SubDirPath = SpGetSectionKeyIndex(
                                SifHandle,
                                L"SetupData",
                                L"EfiUtilPath",
                                0
                                );

        SpCreateDirectory(SystemPartition,NULL,SubDirPath,0,0);

        }

#endif // defined _IA64_
    }

    //
    // Create the nt tree.
    //
    SpCreateDirectoryStructureFromSif(SifHandle,SIF_NTDIRECTORIES,NtPartition,Sysroot);

    //
    // We may be installing into an old tree, so delete all files
    // in the system32\config subdirectory (unless we're upgrading).
    //
    if(NTUpgrade != UpgradeFull) {

        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths(TemporaryBuffer, Sysroot);
        SpConcatenatePaths(TemporaryBuffer, L"system32\\config");
        p = SpDupStringW(TemporaryBuffer);

        //
        // Enumerate and delete all files in system32\config subdirectory.
        //
        SpEnumFiles(p, SpDelEnumFile, &n, NULL);

        SpMemFree(p);
    } else {
        //
        // We go off and try to load the setup.log file for the
        // installation we're about to upgrade.  We do this because we
        // need to transfer any loggged OEM files to our new setup.log.
        // Otherwise, these entries would be lost in our new log file,
        // and we would have an unrepairable installation if the OEM files
        // lost were vital for booting.
        //

        ULONG    RootDirLength;
        NTSTATUS Status;
        PVOID    Inf;

        //
        //  We first find out if the repair directory exists.  If it does exist
        //  load setup.log from the repair directory. Otherwise, load setup.log
        //  from the WinNt directory
        //
        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths(TemporaryBuffer, Sysroot);
        RootDirLength = wcslen(TemporaryBuffer);

        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);

        if(!SpFileExists(TemporaryBuffer, FALSE)) {
            (TemporaryBuffer)[RootDirLength] = UNICODE_NULL;
            SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);
        }

        p = SpDupStringW(TemporaryBuffer);

        //
        // Attempt to load old setup.log.  If we can't, it's no big deal,  We just
        // won't have any old logged OEM files to merge in.
        //
        Status = SpLoadSetupTextFile(p, NULL, 0, &Inf, &n, TRUE, FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFiles: can't load old setup.log (%lx)\n", Status));
        } else {
            //
            // We found setup.log, so go and pull out anything pertinent.
            //
            _LoggedOemFiles = SppRetrieveLoggedOemFiles(Inf);
            SpFreeTextFile(Inf);
        }
        SpMemFree(p);

        //
        // Prepare fonts for upgrade.
        //
        wcscpy(TemporaryBuffer,NtPartition);
        SpConcatenatePaths(TemporaryBuffer,Sysroot);
        SpConcatenatePaths(TemporaryBuffer,L"SYSTEM");

        p = SpDupStringW(TemporaryBuffer);
        SpPrepareFontsForUpgrade(p);
        SpMemFree(p);
    }

    SpDisplayStatusText(SP_STAT_BUILDING_COPYLIST,DEFAULT_STATUS_ATTRIBUTE);

    //
    //  Create the buffer for the log file.
    //
    _SetupLogFile = SpNewSetupTextFile();
    if( _SetupLogFile == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create buffer for setup.log \n"));
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, open the root of the NT partition
    // so that single-instance store links may be created instead of
    // copying files.
    //

    SisRootHandle = NULL;

    if (RemoteBootSetup) {

        RtlInitUnicodeString( &NtPartitionString, NtPartition );
        InitializeObjectAttributes(
            &ObjectAttributes,
            &NtPartitionString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);
        Status = ZwCreateFile(
                    &SisRootHandle,
                    GENERIC_READ,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    OPEN_EXISTING,
                    0,
                    NULL,
                    0);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFiles: Unable to open SIS volume %ws: %x\n", NtPartition, Status ));
            SisRootHandle = NULL;
        }
    }
#endif // defined(REMOTE_BOOT)

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists(
        SifHandle,
        &DiskFileLists,
        &DiskCount
        );

    //
    // And gather the list of files deemed 'incompatible' during
    // winnt32, if any
    //
    if ( WinntSifHandle != NULL ) {

        //
        // We'll do this for fun because we have to.
        //
        SpInitializeCompatibilityOverwriteLists(
            WinntSifHandle,
            &IncompatibleFileListHead
            );

    }

    if(NTUpgrade != UpgradeFull) {

        SpAddMasterFileSectionToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            NULL,
            INDEX_WINNTFILE
            );

        //
        // Add the section of system partition files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTCOPYALWAYS,
            SystemPartition,
            SystemPartitionDirectory,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );

#ifdef _IA64_
        {
        PWSTR SubDirPath;
        //
        // Add the section of system partition root files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTROOT,
            SystemPartition,
            L"\\",
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );

        //
        // Add the section of system partition utility files that are always copied.
        //
        SubDirPath = SpGetSectionKeyIndex(
                            SifHandle,
                            L"SetupData",
                            L"EfiUtilPath",
                            0
                            );

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTUTIL,
            SystemPartition,
            SubDirPath,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );
        }
#endif // defined _IA64_

        //
        // Add conditional files to the copy list.
        //
        SpAddConditionalFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            SystemPartition,
            SystemPartitionDirectory,
            Uniprocessor
            );

    }
    else {

        PHARDWARE_COMPONENT pHw;

        //
        // Add the section of system partition files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTCOPYALWAYS,
            SystemPartition,
            SystemPartitionDirectory,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );

#ifdef _IA64_
        {
        PWSTR SubDirPath;
        //
        // Add the section of system partition root files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTROOT,
            SystemPartition,
            L"\\",
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );

        //
        // Add the section of system partition utility files that are always copied.
        //
        SubDirPath = SpGetSectionKeyIndex(
                            SifHandle,
                            L"SetupData",
                            L"EfiUtilPath",
                            0
                            );

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTUTIL,
            SystemPartition,
            SubDirPath,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs)
            );
        }
#endif // defined _IA64_


        //
        // Add the detected scsi miniport drivers to the copy list.
        // Note that they are always copied to the target.
        // These files have to be added to the copy list, before the ones marked
        // as COPY_ONLY_IF_PRESENT. This is because in most cases, these files
        // will be listed in [Files] with COPY_ONLY_IF_PRESENT set, and the
        // function that creates entries in the copy list, will not create more
        // than one entry for the same file. So if we add the file to the copy
        // list, with COPY_ONLY_IF_PRESENT, there will be no way to replace
        // or overwrite this entry in the list, and the file will end up not
        // being copied.
        //
        // we just use the filename specified in [SCSI.Load] --
        // no need for separate [files.xxxx] sections.
        //
        if( !PreInstall ||
            ( PreinstallScsiHardware == NULL ) ) {
            pHw = ScsiHardware;
        } else {
            pHw = PreinstallScsiHardware;
        }
        for( ; pHw; pHw=pHw->Next) {
            if(!pHw->ThirdPartyOptionSelected) {

                SpAddSingleFileToCopyList(
                    SifHandle,
                    DiskFileLists,
                    DiskCount,
                    L"SCSI.Load",
                    pHw->IdString,
                    0,
                    NtPartition,
                    NULL,
                    COPY_ALWAYS,
                    FALSE
                    );
            }
        }

        //
        //  Add the bus extender drivers to the copy list
        //
        SpAddBusExtendersToCopyList( SifHandle,
                                     DiskFileLists,
                                     DiskCount,
                                     NtPartition );



        //
        // Add the files in the master file list with the copy options
        // specified in each line on the INDEX_UPGRADE index. The options
        // specify whether the file is to be copied at all or copied always
        // or copied only if there on the target or not copied if there on
        // the target.
        //

        SpAddMasterFileSectionToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            NULL,
            INDEX_UPGRADE
            );

        //
        // Add the section of files that are upgraded only if it is not
        // a Win31 upgrade
        //

        if(WinUpgradeType != UpgradeWin31) {
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_FILESUPGRADEWIN31,
                NtPartition,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
        }

        //
        // Add the files for kernel, hal and detect module, these are
        // handled specially because they involve renamed files (it is
        // not possible to find out just by looking at the target file
        // how to upgrade it).
        // NOTE: This does not handle third-party HAL's (they get copied
        // by SpCopyThirdPartyDrivers() below).
        //

        SpAddHalKrnlDetToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            SystemPartition,
            SystemPartitionDirectory,
            Uniprocessor
            );

        //
        // Add the new hive files so that our config stuff can get at them
        // to extract new configuration information.  These new hive files
        // are renamed on the target so that they don't overwrite the
        // existing hives.

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_FILESNEWHIVES,
            NtPartition,
            NULL,
            COPY_ALWAYS,
            FALSE
            );

        //
        // Copy third-party migrated drivers.
        // The driver files are actually already in place (since it's an upgrade)
        // but the function makes sure they are not overwriten with inbox drivers
        // if there's a filename collision
        //
        SpDontOverwriteMigratedDrivers (
            NtPartition,
            Sysroot,
            SystemPartition,
            SystemPartitionDirectory,
            DiskFileLists,
            DiskCount
            );

    }

#if defined(REMOTE_BOOT)
    //
    // If remote booting, add the [Files.RemoteBoot] section.
    //

    if (RemoteBootSetup) {
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_REMOTEBOOTFILES,
            NtPartition,
            NULL,
            COPY_ALWAYS,
            FALSE
            );
    }
#endif // defined(REMOTE_BOOT)

    //
    // Copy third-party files.
    // We do this here just in case there is some error in the setup information
    // file -- we'd have caught it by now, before we start copying files to the
    // user's hard drive.
    // NOTE: SpCopyThirdPartyDrivers has a check to make sure it only copies the
    // HAL and PAL if we're in an upgrade (in which case, we want to leave the other
    // drivers alone).
    //
    SpCopyThirdPartyDrivers(
        ThirdPartySourceDevicePath,
        NtPartition,
        Sysroot,
        SystemPartition,
        SystemPartitionDirectory,
        DiskFileLists,
        DiskCount
        );

#if 0
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: Sysroot = %ls \n", Sysroot ) );
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: SystemPartitionDirectory = %ls \n", SystemPartitionDirectory ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: SourceDevicePath = %ls \n", SourceDevicePath ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: DirectoryOnSourceDevice = %ls \n", DirectoryOnSourceDevice ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: ThirdPartySourceDevicePath = %ls \n", ThirdPartySourceDevicePath ));
//    SpCreateSetupLogFile( DiskFileLists, DiskCount, NtPartitionRegion, Sysroot, DirectoryOnSourceDevice );
#endif // if 0

    //
    // Copy files in the copy list.
    //
    SpCopyFilesInCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SourceDevicePath,
        DirectoryOnSourceDevice,
        Sysroot,
        &IncompatibleFileListHead
        );

#ifdef _X86_
    if(!SpIsArc()){
        //
        // Take care of ntbootdd.sys.
        //
        SpCreateNtbootddSys(
            NtPartitionRegion,
            NtPartition,
            Sysroot,
            SystemPartition,
            SifHandle,
            SourceDevicePath,
            DirectoryOnSourceDevice
            );


        //
        // Now get rid of x86-ARC turd files that
        // we won't need (because we're not on an
        // arc machine.
        //
        wcscpy( TemporaryBuffer, NtBootDevicePath );
        SpDeleteFile( TemporaryBuffer, L"arcsetup.exe", NULL );
        wcscpy( TemporaryBuffer, NtBootDevicePath );
        SpDeleteFile( TemporaryBuffer, L"arcldr.exe", NULL );

    }
#endif // defined _X86_

    if( PreInstall ) {
        SppCopyOemDirectories( SourceDevicePath,
                               NtPartition,
                               Sysroot );
    }

    //
    //  Create the log file in disk
    //
    if( _SetupLogFile != NULL ) {

        PWSTR   p;
        PWSTR   TempName;
        PWSTR   Values[] = {
                           SIF_NEW_REPAIR_NT_VERSION
                           };

        //
        // Merge in the OEM files retrived from the previous setup.log
        //
        if(_LoggedOemFiles) {
            SppMergeLoggedOemFiles(_SetupLogFile,
                                   _LoggedOemFiles,
                                   SystemPartition,
                                   ( *SystemPartitionDirectory != (WCHAR)'\0' )? SystemPartitionDirectory :
                                                                  ( PWSTR )L"\\",
                                   NtPartition );
            SpFreeTextFile(_LoggedOemFiles);
        }

        //
        //  Add signature
        //
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_SIGNATURE,
                            SIF_NEW_REPAIR_VERSION_KEY,
                            Values,
                            1 );

        //
        // Add section that contains the paths
        //

        Values[0] = SystemPartition;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,
                            Values,
                            1 );

        Values[0] = ( *SystemPartitionDirectory != (WCHAR)'\0' )? SystemPartitionDirectory :
                                                                  ( PWSTR )L"\\";
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY,
                            Values,
                            1 );

        Values[0] = NtPartition;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,
                            Values,
                            1 );

        Values[0] = Sysroot;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY,
                            Values,
                            1 );

        //
        // Flush to disk
        //
        TempName = SpMemAlloc( ( wcslen( SETUP_REPAIR_DIRECTORY ) + 1 +
                                 wcslen( SETUP_LOG_FILENAME ) + 1 ) * sizeof( WCHAR ) );
        wcscpy( TempName, SETUP_REPAIR_DIRECTORY );
        SpConcatenatePaths(TempName, SETUP_LOG_FILENAME );
        SpWriteSetupTextFile(_SetupLogFile,NtPartition,Sysroot,TempName);
        SpMemFree( TempName );
        SpFreeTextFile( _SetupLogFile );
        _SetupLogFile = NULL;
    }

    //
    // Free the media descriptors.
    //
    SpFreeCopyLists(&DiskFileLists,DiskCount);

    //
    // Free incompatible file lists
    //
    if ( IncompatibleFileListHead.EntryCount ) {

        SpFreeIncompatibleFileList(&IncompatibleFileListHead);

    }

    SpMemFree(NtPartition);
    if (SystemPartition != NULL) {
        SpMemFree(SystemPartition);
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, close the root of the NT partition.
    //

    if (SisRootHandle != NULL) {
        ZwClose(SisRootHandle);
        SisRootHandle = NULL;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Terminate diamond.
    //
    SpdTerminate();
    SpUninitAlternateSource ();
}




VOID
SppDeleteDirectoriesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    them from the system tree.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to delete

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR RelativePath, DirOrdinal, TargetDir, NtDir, DirPath;
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();


    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        DirOrdinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        RelativePath = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);

        //
        // Validate the filename and dirordinal
        //
        if(!DirOrdinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!RelativePath) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //

        DirPath = SpLookUpTargetDirectory(SifHandle,DirOrdinal);

        wcscpy( TemporaryBuffer, Sysroot );
        SpConcatenatePaths( TemporaryBuffer, DirPath );
        SpConcatenatePaths( TemporaryBuffer, RelativePath );

        TargetDir = SpDupStringW( TemporaryBuffer );

        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TargetDir);
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TempPtr);

        }

        //
        // delete the directory
        //
        SpDeleteExistingTargetDir(NtPartitionRegion, TargetDir, FALSE, 0);
        SpMemFree(TargetDir);

    }

}



VOID
SppDeleteFilesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    them from the system tree.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to delete

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR filename, dirordinal, targetdir, ntdir;
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,Sysroot);
    ntdir = SpDupStringW(TemporaryBuffer);

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        filename   = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        dirordinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);

        //
        // Validate the filename and dirordinal
        //
        if(!filename) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!dirordinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //
        targetdir = SpLookUpTargetDirectory(SifHandle,dirordinal);

        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, filename);
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TempPtr);

        }

        //
        // delete the file
        //
        while(TRUE) {
            Status = SpDeleteFile(ntdir, targetdir, filename);
            if(!NT_SUCCESS(Status)
                && Status != STATUS_OBJECT_NAME_NOT_FOUND
                && Status != STATUS_OBJECT_PATH_NOT_FOUND
                ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete file %ws (%lx)\n",filename, Status));
                //
                // We can ignore this error since this just means that we have
                // less free space on the hard disk.  It is not critical for
                // install.
                //
                if(!SpNonCriticalError(SifHandle, SP_SCRN_DELETE_FAILED, filename, NULL)) {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    SpMemFree(ntdir);
}















VOID
SppBackupFilesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    backs them up in the given NT tree if found by renaming.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to backup

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR filename, dirordinal, backupfile, targetdir, ntdir;
    WCHAR OldFile[ACTUAL_MAX_PATH];
    WCHAR NewFile[ACTUAL_MAX_PATH];
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,Sysroot);
    ntdir = SpDupStringW(TemporaryBuffer);

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        filename   = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        dirordinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);
        backupfile = SpGetSectionLineIndex(SifHandle, SifSection, u, 2);

        //
        // Validate the filename and dirordinal
        //
        if(!filename) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!dirordinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }
        if(!backupfile) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,2);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //
        targetdir = SpLookUpTargetDirectory(SifHandle,dirordinal);

        //
        // display status bar
        //
        SpDisplayStatusText(SP_STAT_BACKING_UP_FILE,DEFAULT_STATUS_ATTRIBUTE, filename, backupfile);

        //
        // Form the complete pathnames of the old file name and the new file
        // name
        //
        wcscpy(OldFile, ntdir);
        SpConcatenatePaths(OldFile, targetdir);
        wcscpy(NewFile, OldFile);
        SpConcatenatePaths(OldFile, filename);
        SpConcatenatePaths(NewFile, backupfile);

        while(TRUE) {
            if(!SpFileExists(OldFile, FALSE)) {
                break;
            }

            if(SpFileExists(NewFile, FALSE)) {
                SpDeleteFile(NewFile, NULL, NULL);
            }

            Status = SpRenameFile(OldFile, NewFile, FALSE);
            if(!NT_SUCCESS(Status) && Status != STATUS_OBJECT_NAME_NOT_FOUND && Status != STATUS_OBJECT_PATH_NOT_FOUND) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to rename file %ws to %ws(%lx)\n",OldFile, NewFile, Status));
                //
                // We can ignore this error, since it is not critical
                //
                if(!SpNonCriticalError(SifHandle, SP_SCRN_BACKUP_FAILED, filename, backupfile)) {
                    break;
                }
            }
            else {
                break;
            }

        }
    }
    SpMemFree(ntdir);
}

VOID
SpDeleteAndBackupFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        TargetPath
    )
{
    //
    // If we are not upgrading or installing into the same tree, then
    // we have nothing to do
    //
    if(NTUpgrade == DontUpgrade) {
        return;
    }

    //
    // Below is code for NT-to-NT upgrade only
    //

    //
    //  The order in which the tasks below are performed is important.
    //  So do not change it!!!
    //  This is necessary in order to upgrade 3rd party video drivers
    //  (eg. rename sni543x.sys to cirrus.sys, so that we only upgrade
    //  the driver if it was present).
    //

    //
    // Backup files
    //
    SppBackupFilesInSection(
        SifHandle,
        (NTUpgrade == UpgradeFull) ? SIF_FILESBACKUPONUPGRADE : SIF_FILESBACKUPONOVERWRITE,
        TargetRegion,
        TargetPath
        );

    //
    // Delete files
    //
    SppDeleteFilesInSection(
        SifHandle,
        SIF_FILESDELETEONUPGRADE,
        TargetRegion,
        TargetPath
        );

    //
    // Delete directories
    //
    SppDeleteDirectoriesInSection(
        SifHandle,
        SIF_DIRSDELETEONUPGRADE,
        TargetRegion,
        TargetPath
        );

}


BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
{
    PWSTR FileName;
    static ULONG u = 0;

    //
    // Ignore subdirectories
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;    // continue processing
    }

    //
    // We have to make a copy of the filename, because the info struct
    // we get isn't NULL-terminated.
    //
    wcsncpy(
        TemporaryBuffer,
        FileInfo->FileName,
        FileInfo->FileNameLength
        );
    (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;
    FileName = SpDupStringW(TemporaryBuffer);

    //
    // display status bar
    //
    if( !HeadlessTerminalConnected ) {
        SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, FileName );
    } else {

        PWCHAR TempPtr = NULL;
        //
        // If we're headless, we need to be careful about displaying very long
        // file/directory names.  For that reason, just display a little spinner.
        //
        switch( u % 4) {
        case 0:
            TempPtr = L"-";
            break;
        case 1:
            TempPtr = L"\\";
            break;
        case 2:
            TempPtr = L"|";
            break;
        default:
            TempPtr = L"/";
            break;

        }

        SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, TempPtr );

        u++;
    }

    //
    // Ignore return status of delete
    //

    SpDeleteFile(DirName, FileName, NULL);

    SpMemFree(FileName);
    return TRUE;    // continue processing
}


BOOLEAN
SpDelEnumFileAndDirectory(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
{
    PWSTR FileName = NULL;
    NTSTATUS Del_Status;
    DWORD FileOrDir;
    static ULONG u = 0;


    if(*(PULONG)Pointer == SP_DELETE_FILESTODELETE ){

        //
        // We have to make a copy of the filename, because the info struct
        // we get isn't NULL-terminated.
        //
        wcsncpy(
            TemporaryBuffer,
            FileInfo->FileName,
            FileInfo->FileNameLength
            );
        (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;


        FileName = SpDupStringW(TemporaryBuffer);


        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, FileName );
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, TempPtr );

            u++;

        }

        //
        // Ignore return status of delete
        //



        if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DELETING DirName-%ws : FileName-%ws\n", DirName, FileName ));
        }

        Del_Status = SpDeleteFileEx( DirName,
                        FileName,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );

        if(!NT_SUCCESS(Del_Status))
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: File Not Deleted - Status - %ws (%lx)\n", TemporaryBuffer, Del_Status));

        if( FileDeleteGauge )
            SpTickGauge(FileDeleteGauge);
        SpMemFree(FileName);
    }
    else
        *(PULONG)Pointer = *(PULONG)Pointer + 1;


    return TRUE;    // continue processing
}


VOID
SpLogOneFile(
    IN PFILE_TO_COPY    FileToCopy,
    IN PWSTR            Sysroot,
    IN PWSTR            DirectoryOnSourceDevice,
    IN PWSTR            DiskDescription,
    IN PWSTR            DiskTag,
    IN ULONG            CheckSum
    )

{

    PWSTR   Values[ 5 ];
    LPWSTR  NtPath;
    ULONG   ValueCount;
    PFILE_TO_COPY   p;
    WCHAR   CheckSumString[ 9 ];

    if( _SetupLogFile == NULL ) {
        return;
    }

    Values[ 1 ] = CheckSumString;
    Values[ 2 ] = DirectoryOnSourceDevice;
    Values[ 3 ] = DiskDescription;
    Values[ 4 ] = DiskTag;

    swprintf( CheckSumString, ( LPWSTR )L"%lx", CheckSum );
    p = FileToCopy;

#if 0
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: Source Name = %ls, \t\tTargetDirectory = %ls \t\tTargetName = %ls\t\tTargetDevice = %ls, \tAbsoluteDirectory = %d \n",
             p->SourceFilename,
             p->TargetDirectory,
             p->TargetFilename,
             p->TargetDevicePath,
             p->AbsoluteTargetDirectory ));
#endif // if 0

    Values[0] = p->SourceFilename;
    ValueCount = ( DirectoryOnSourceDevice == NULL )? 2 : 5;

    if( ( Sysroot == NULL ) ||
        ( wcslen( p->TargetDirectory ) == 0 )
      ) {

        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_SYSPARTFILES,
                            p->TargetFilename,
                            Values,
                            ValueCount );

    } else {

        NtPath = SpDupStringW( Sysroot );

        if (NtPath) {
            NtPath = SpMemRealloc( NtPath,
                           sizeof( WCHAR ) * ( wcslen( Sysroot ) +
                               wcslen( p->TargetDirectory ) +
                               wcslen( p->TargetFilename ) +
                               2 +    // for possible two extra back slashes
                               1      // for the terminating NULL
                          ) );


            if (NtPath) {
                SpConcatenatePaths( NtPath, p->TargetDirectory );
                SpConcatenatePaths( NtPath, p->TargetFilename );

                SpAddLineToSection( _SetupLogFile,
                                    SIF_NEW_REPAIR_WINNTFILES,
                                    NtPath,
                                    Values,
                                    ValueCount );

                SpMemFree( NtPath );
            }
        }
   }
}


PVOID
SppRetrieveLoggedOemFiles(
    PVOID   OldLogFile
    )
{
    PVOID   NewLogFile;
    BOOLEAN OldFormatSetupLogFile, FilesRetrieved = FALSE;
    PWSTR   SectionName[2];
    ULONG   FileCount, SectionIndex, i;
    PWSTR   TargetFileName;
    PWSTR   OemDiskDescription, OemDiskTag, OemSourceDirectory;
    PWSTR   Values[5];

    //
    // Create a new setup.log file to merge the OEM files into
    //
    NewLogFile = SpNewSetupTextFile();
    if(!NewLogFile) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create new setup.log buffer for OEM merging.\n"));
        return NULL;
    }

    //
    //  Determine whether setup.log has the new or old style
    //
    if(OldFormatSetupLogFile = !IsSetupLogFormatNew(OldLogFile)) {
        SectionName[0] = SIF_REPAIRSYSPARTFILES;
        SectionName[1] = SIF_REPAIRWINNTFILES;
    } else {
        SectionName[0] = SIF_NEW_REPAIR_SYSPARTFILES;
        SectionName[1] = SIF_NEW_REPAIR_WINNTFILES;
    }

    if(OldFormatSetupLogFile) {
        //
        // I don't know if we even want to mess with this.
        // The format of setup.log in NT 3.1 makes it impossible
        // to identify any OEM files except for SCSI files, and
        // even then the tagfile name is lost. I would have to use
        // the driver filename itself as a substitute for the tagfile
        // name (which is what NT 3.1 repair did--UGGHH!!)
        //
    } else {
        //
        // Retrieve logged OEM files first from system partition, then
        // from winnt directory.
        //
        for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
            FileCount = SpCountLinesInSection(OldLogFile, SectionName[SectionIndex]);

            for(i=0; i<FileCount; i++) {
                OemSourceDirectory = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 2);
                OemDiskTag = NULL;
                if(OemSourceDirectory) {
                    OemDiskDescription = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 3);
                    if(OemDiskDescription) {
                        OemDiskTag = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 4);
                    }
                }

                if(OemDiskTag) {    // then we have an OEM file

                    TargetFileName = SpGetKeyName(OldLogFile, SectionName[SectionIndex], i);
                    Values[0] = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 0);
                    Values[1] = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 1);
                    Values[2] = OemSourceDirectory;
                    Values[3] = OemDiskDescription;
                    Values[4] = OemDiskTag;

                    SpAddLineToSection(NewLogFile,
                                       SectionName[SectionIndex],
                                       TargetFileName,
                                       Values,
                                       5
                                       );

                    FilesRetrieved = TRUE;
                }
            }
        }
    }

    if(FilesRetrieved) {
        return NewLogFile;
    } else {
        SpFreeTextFile(NewLogFile);
        return NULL;
    }
}


VOID
SppMergeLoggedOemFiles(
    IN PVOID DestLogHandle,
    IN PVOID OemLogHandle,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR NtPartition
    )
{
    PWSTR SectionName[2] = {SIF_NEW_REPAIR_SYSPARTFILES, SIF_NEW_REPAIR_WINNTFILES};
    PWSTR FullPathNames[2] = {NULL, NULL};
    ULONG FileCount, SectionIndex, i, j;
    PWSTR TargetFileName;
    PWSTR Values[5];

    //
    //  First build the target path. It will be used to check if
    //  an existing OEM file still exists on the new installation
    //  (An OEM file could listed in the FilesToDelete section of txtsetup.sif)
    //

    wcscpy( TemporaryBuffer, SystemPartition );
    SpConcatenatePaths(TemporaryBuffer, SystemPartitionDirectory );
    FullPathNames[0] = SpDupStringW(TemporaryBuffer);
    FullPathNames[1] = SpDupStringW(NtPartition);

    //
    // Merge logged OEM files first from system partition, then
    // from winnt directory.
    //
    for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
        FileCount = SpCountLinesInSection(OemLogHandle, SectionName[SectionIndex]);

        for(i=0; i<FileCount; i++) {
            TargetFileName = SpGetKeyName(OemLogHandle, SectionName[SectionIndex], i);
            //
            // Find out if there's already an entry for this file. If so, then don't
            // merge in the OEM file.
            //
            if(!SpGetSectionKeyExists(DestLogHandle, SectionName[SectionIndex], TargetFileName)) {
                PWSTR   p;

                //
                //  Find out if the OEM file still exists on the target system.
                //  If it doesn't exist, don't merge in the OEM file.
                //
                wcscpy( TemporaryBuffer, FullPathNames[SectionIndex] );
                SpConcatenatePaths(TemporaryBuffer, TargetFileName );
                p = SpDupStringW(TemporaryBuffer);

                if(SpFileExists(p, FALSE)) {
                    for(j = 0; j < 5; j++) {
                        Values[j] = SpGetSectionLineIndex(OemLogHandle, SectionName[SectionIndex], i, j);
                    }

                    SpAddLineToSection(DestLogHandle,
                                       SectionName[SectionIndex],
                                       TargetFileName,
                                       Values,
                                       5
                                       );
                }
                SpMemFree(p);
            }
        }
    }
    SpMemFree( FullPathNames[0] );
    SpMemFree( FullPathNames[1] );
}

BOOLEAN
SppIsFileLoggedAsOemFile(
    IN PWSTR TargetFileName
    )
{
    PWSTR SectionName[2] = {SIF_NEW_REPAIR_SYSPARTFILES, SIF_NEW_REPAIR_WINNTFILES};
    ULONG FileCount, SectionIndex;
    BOOLEAN FileIsOem;

//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SppIsFileLoggedAsOemFile() is checking %ls \n", TargetFileName ));
    FileIsOem = FALSE;
    if( _LoggedOemFiles ) {
        //
        // Look first in the from system partition section, then
        // in the winnt section.
        //
        for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
            if( SpGetSectionKeyExists( _LoggedOemFiles, SectionName[SectionIndex], TargetFileName)) {
                FileIsOem = TRUE;
                break;
            }
        }
    }
    return( FileIsOem );
}

BOOLEAN
SpRemoveEntryFromCopyList(
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory
    )

/*++

Routine Description:

    Removes an entry from a disk's file copy list.

Arguments:

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDirectory - supplies the directory on the target media
        into which the file will be copied.

    TargetFilename - supplies the name of the file as it will exist
        in the target tree.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - indicates whether TargetDirectory is a path from the
        root, or relative to a root to specified later.

Return Value:

    TRUE if a new copy list entry was created; FALSE if not (ie, the file was
        already on the copy list).

--*/

{
    PDISK_FILE_LIST pDiskList;
    PFILE_TO_COPY   pListEntry;
    ULONG           DiskNumber;

    for(DiskNumber=0; DiskNumber<DiskCount; DiskNumber++) {
        pDiskList = &DiskFileLists[DiskNumber];
        for(pListEntry=pDiskList->FileList; pListEntry; pListEntry=pListEntry->Next) {
            if(!_wcsicmp(pListEntry->TargetFilename,TargetFilename)
            && !_wcsicmp(pListEntry->TargetDirectory,TargetDirectory)
            && !_wcsicmp(pListEntry->TargetDevicePath,TargetDevicePath)
            && (pListEntry->AbsoluteTargetDirectory == AbsoluteTargetDirectory)) {
                pListEntry->Flags &= ~COPY_DISPOSITION_MASK;
                pListEntry->Flags |= COPY_NEVER;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpRemoveEntryFromCopyList() removed %ls from copy list \n", TargetFilename ));
                return( TRUE );
            }
        }
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: SpRemoveEntryFromCopyList() failed to remove %ls from copy list \n", TargetFilename ));
    return( FALSE );
}

NTSTATUS
SpMoveFileOrDirectory(
    IN PWSTR   SrcPath,
    IN PWSTR   DestPath
    )
/*++

Routine Description:

    This routine attempts to move a source file or  directory, to a target
    file or directory.

    Note: This function will fail if the source and destination paths do not
    point to the same volume.

Arguments:

    SrcPath:  Absolute path to the source file or directory.
              This path should include the path to the source device.

    DestPath: Absolute path to the destination file or directory.
              This path should include the path to the source device.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES        Obja;
    IO_STATUS_BLOCK          IoStatusBlock;
    UNICODE_STRING           SrcName;
    HANDLE                   hSrc;
    NTSTATUS                 Status;
    BYTE                     RenameFileInfoBuffer[ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_RENAME_INFORMATION)];
    PFILE_RENAME_INFORMATION RenameFileInfo;

    if(wcslen(DestPath) >= ACTUAL_MAX_PATH){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                   "SETUP:SpMoveFileOrDirectory, Actual length of Dest path is %d more that %d - skipping %ws move", 
                   wcslen(DestPath), ACTUAL_MAX_PATH, DestPath));
        return STATUS_NAME_TOO_LONG;
    }
    //
    // Initialize names and attributes.
    //
    INIT_OBJA(&Obja,&SrcName,SrcPath);

    Status = ZwCreateFile( &hSrc,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open source file %ws. Status = %lx\n",SrcPath, Status));
        return( Status );
    }

    memset(RenameFileInfoBuffer, 0, sizeof(RenameFileInfoBuffer));
    RenameFileInfo = (PFILE_RENAME_INFORMATION)RenameFileInfoBuffer;
    RenameFileInfo->ReplaceIfExists = TRUE;
    RenameFileInfo->RootDirectory = NULL;
    RenameFileInfo->FileNameLength = wcslen( DestPath )*sizeof( WCHAR );
    RtlMoveMemory(RenameFileInfo->FileName,DestPath,(wcslen( DestPath )+1)*sizeof(WCHAR));
    Status = ZwSetInformationFile( hSrc,
                                   &IoStatusBlock,
                                   RenameFileInfo,
                                   sizeof(RenameFileInfoBuffer),
                                   FileRenameInformation );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set attribute on  %ws. Status = %lx\n",SrcPath, Status));
    }

    ZwClose(hSrc);

    return( Status );
}


BOOLEAN
SppCopyDirRecursiveCallback(
    IN  PCWSTR                      SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG                      ReturnData,
    IN  PVOID                       Params
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for each
    file or subdirectory found in the parent directory. It creates a node
    for the file or subdirectory and appends it to the appropriate list.

Arguments:

    SrcPath - Absolute path to the parent directory. Unused.
              the path to the source device.

    FileInfo - supplies find data for a file or directory in the parent directory.

    ReturnData - receives an error code if an error occurs.
                 We ignore errors in this routine and thus we always
                 just fill this in with NO_ERROR.

    Params - Contains a pointer to the COPYDIR_DIRECTORY_NODE for the parent directory.

Return Value:

    TRUE if successful otherwise FALSE (if ran out of memory).

--*/

{
    PCOPYDIR_FILE_NODE fileEntry;
    PCOPYDIR_DIRECTORY_NODE directoryEntry;
    PCOPYDIR_DIRECTORY_NODE parentDirectory = Params;
    ULONG nameLength;
    BOOLEAN Result = TRUE;

    *ReturnData = NO_ERROR;

    nameLength = FileInfo->FileNameLength / sizeof(WCHAR);

    if( (FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

        //
        // This is a file. Create a node for it, linked to the parent directory.
        //
        fileEntry = SpMemAlloc(sizeof(COPYDIR_FILE_NODE) + FileInfo->FileNameLength);

        if (fileEntry) {
            wcsncpy(fileEntry->Name, FileInfo->FileName, nameLength);
            fileEntry->Name[nameLength] = 0;
            InsertTailList(&parentDirectory->FileList, &fileEntry->SiblingListEntry);
        } else {
            Result = FALSE; // ran out of memory
        }
    } else {

        //
        // This is a directory. Skip it if it's "." or "..". Otherwise,
        // create a node for it, linked to the parent directory.
        //
        ASSERT(nameLength != 0);
        if ( (FileInfo->FileName[0] == L'.') &&
             ( (nameLength == 1) ||
               ( (nameLength == 2) && (FileInfo->FileName[1] == L'.') ) ) ) {
            //
            // Skip . and ..
            //
        } else {
            directoryEntry = SpMemAlloc(sizeof(COPYDIR_DIRECTORY_NODE) + FileInfo->FileNameLength);

            if (directoryEntry) {
                InitializeListHead(&directoryEntry->FileList);
                InitializeListHead(&directoryEntry->SubdirectoryList);
                directoryEntry->Parent = parentDirectory;
                wcsncpy( directoryEntry->Name,
                         FileInfo->FileName,
                         FileInfo->FileNameLength/sizeof(WCHAR) );
                directoryEntry->Name[FileInfo->FileNameLength/sizeof(WCHAR)] = 0;
                InsertTailList( &parentDirectory->SubdirectoryList,
                                &directoryEntry->SiblingListEntry );
            } else {
                Result = FALSE; // ran out of memory
            }
        }
    }

    return Result;
}

VOID
SpCopyDirRecursive(
    IN PWSTR   SrcPath,
    IN PWSTR   DestDevPath,
    IN PWSTR   DestDirPath,
    IN ULONG   CopyFlags
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SrcPath:  Absolute path to the source directory. This path should include
              the path to the source device.

    DestDevPath:  Path to the destination device.

    DestDirPath:  Path to the destination directory.

    CopyFlags: Flags to pass to SpCopyFilesUsingNames()

Return Value:

    None.

--*/

{
    ULONG n;
    NTSTATUS Status;
    PWSTR currentSrcPath;
    PWSTR currentDestPath;
    LIST_ENTRY directoryList;
    LIST_ENTRY fileList;
    COPYDIR_DIRECTORY_NODE rootDirectory;
    PCOPYDIR_DIRECTORY_NODE currentDirectory;
    PCOPYDIR_DIRECTORY_NODE oldDirectory;
    PCOPYDIR_FILE_NODE fileEntry;
    PLIST_ENTRY listEntry;

    //
    // Allocate a buffer to hold the working source and destination paths.
    //

#define COPYDIR_MAX_PATH 16384 // characters

    currentSrcPath = SpMemAlloc(2 * COPYDIR_MAX_PATH * sizeof(WCHAR));
    currentDestPath = currentSrcPath + COPYDIR_MAX_PATH;

    wcscpy(currentSrcPath, SrcPath);
    wcscpy(currentDestPath, DestDevPath);
    SpConcatenatePaths(currentDestPath, DestDirPath);

    //
    //  Create the target directory
    //

    if( !SpFileExists( currentDestPath, TRUE ) ) {

        //
        //  If the directory doesn't exist, then try to move (rename) the
        //  source directory.
        //
        if (!RemoteSysPrepSetup) {

            Status = SpMoveFileOrDirectory( SrcPath, currentDestPath );
            if( NT_SUCCESS( Status ) ) {
                SpMemFree(currentSrcPath);
                return;
            }
        }

        //
        //  If unable to rename the source directory, then create the
        //  target directory
        //
        SpCreateDirectory( DestDevPath,
                           NULL,
                           DestDirPath,
                           0,
                           0 );

        if (RemoteSysPrepSetup) {

            Status = SpCopyEAsAndStreams( currentSrcPath,
                                          NULL,
                                          currentDestPath,
                                          NULL,
                                          TRUE );


            if ( NT_SUCCESS( Status )) {

                Status = SpSysPrepSetExtendedInfo( currentSrcPath,
                                                   currentDestPath,
                                                   TRUE,
                                                   FALSE );
            }

            if (! NT_SUCCESS( Status )) {

                SpMemFree(currentSrcPath);
                return;
            }
        }
    }

    //
    // Initialize the screen.
    //

    SpCopyFilesScreenRepaint(L"", NULL, TRUE);

    //
    // Create directory node for the starting directory.
    //

    InitializeListHead( &rootDirectory.SubdirectoryList );
    InitializeListHead( &rootDirectory.FileList );
    rootDirectory.Parent = NULL;

    currentDirectory = &rootDirectory;

    do {

        //
        // Enumerate the files and directories in the current source directory.
        //

        SpEnumFiles(currentSrcPath, SppCopyDirRecursiveCallback, &n, currentDirectory);

        //
        // Copy all files in the current source directory to the destination directory.
        //

        while ( !IsListEmpty(&currentDirectory->FileList) ) {

            listEntry = RemoveHeadList(&currentDirectory->FileList);
            fileEntry = CONTAINING_RECORD( listEntry,
                                           COPYDIR_FILE_NODE,
                                           SiblingListEntry );

            SpConcatenatePaths(currentSrcPath, fileEntry->Name);
            SpConcatenatePaths(currentDestPath, fileEntry->Name);

            SpMemFree(fileEntry);

            SpCopyFilesScreenRepaint(currentSrcPath, NULL, FALSE);

            Status = SpCopyFileUsingNames( currentSrcPath,
                                           currentDestPath,
                                           0,
                                           CopyFlags );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy %ws. Status = %lx\n", currentSrcPath, Status));
                SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            }

            *wcsrchr(currentSrcPath, L'\\') = 0;
            *wcsrchr(currentDestPath, L'\\') = 0;
        }

        //
        // If the current directory has no subdirectories, walk back up the
        // tree looking for an unprocessed directory.
        //

        while ( IsListEmpty(&currentDirectory->SubdirectoryList) ) {

            //
            // If the current directory is the root directory, we're done. Otherwise,
            // move up to the parent directory entry and delete the current one.
            //

            oldDirectory = currentDirectory;
            currentDirectory = currentDirectory->Parent;

            if ( currentDirectory == NULL ) {
                break;
            }

            ASSERT(IsListEmpty(&oldDirectory->FileList));
            ASSERT(IsListEmpty(&oldDirectory->SiblingListEntry));
            SpMemFree(oldDirectory);

            //
            // Strip the name of the current directory off of the path.
            //

            *wcsrchr(currentSrcPath, L'\\') = 0;
            *wcsrchr(currentDestPath, L'\\') = 0;
        }

        if ( currentDirectory != NULL ) {

            //
            // We found another directory to work on.
            //

            listEntry = RemoveHeadList(&currentDirectory->SubdirectoryList);
            currentDirectory = CONTAINING_RECORD( listEntry,
                                                  COPYDIR_DIRECTORY_NODE,
                                                  SiblingListEntry );
#if DBG
            InitializeListHead(&currentDirectory->SiblingListEntry);
#endif

            //
            // Create the target directory.
            //
            SpCreateDirectory( currentDestPath,
                               NULL,
                               currentDirectory->Name,
                               0,
                               0 );
            SpCopyFilesScreenRepaint(L"",NULL,TRUE);

            SpConcatenatePaths(currentSrcPath, currentDirectory->Name);
            SpConcatenatePaths(currentDestPath, currentDirectory->Name);

            if (RemoteSysPrepSetup) {

                Status = SpCopyEAsAndStreams( currentSrcPath,
                                              NULL,
                                              currentDestPath,
                                              NULL,
                                              TRUE );


                if ( NT_SUCCESS( Status )) {

                    Status = SpSysPrepSetExtendedInfo( currentSrcPath,
                                                       currentDestPath,
                                                       TRUE,
                                                       FALSE );
                }

                if (! NT_SUCCESS( Status )) {

                    goto cleanup;
                }
            }
        }

    } while ( currentDirectory != NULL );

    ASSERT(IsListEmpty(&rootDirectory.FileList));
    ASSERT(IsListEmpty(&rootDirectory.SubdirectoryList));

cleanup:

    //
    // Normally everything will already be cleaned up by the time we get here.
    // But if the above loop is aborted, there may be some cleanup to do.
    // Walk the lists in the same manner as the above loop, freeing memory
    // along the way.
    //

    currentDirectory = &rootDirectory;

    do {

        while ( !IsListEmpty(&currentDirectory->FileList) ) {
            listEntry = RemoveHeadList(&currentDirectory->FileList);
            fileEntry = CONTAINING_RECORD( listEntry,
                                           COPYDIR_FILE_NODE,
                                           SiblingListEntry );
            SpMemFree(fileEntry);
        }

        while ( IsListEmpty(&currentDirectory->SubdirectoryList) ) {

            oldDirectory = currentDirectory;
            currentDirectory = currentDirectory->Parent;

            if ( currentDirectory == NULL ) {
                break;
            }

            ASSERT(IsListEmpty(&oldDirectory->FileList));
            ASSERT(IsListEmpty(&oldDirectory->SiblingListEntry));
            SpMemFree(oldDirectory);
        }

        if ( currentDirectory != NULL ) {

            listEntry = RemoveHeadList(&currentDirectory->SubdirectoryList);
            currentDirectory = CONTAINING_RECORD( listEntry,
                                                  COPYDIR_DIRECTORY_NODE,
                                                  SiblingListEntry );
#if DBG
            InitializeListHead(&currentDirectory->SiblingListEntry);
#endif
        }

    } while ( currentDirectory != NULL );

    //
    // Free the buffer allocated at the beginning.
    //

    SpMemFree(currentSrcPath);

    return;

} // SpCopyDirRecursive


VOID
SppCopyOemDirectories(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SourceDevicePath: Path to the device that contains the source.

    NtPartition:  Path to the drive that contains the system.

    Systroot:     Directory where the system is installed.

Return Value:

    None.

--*/

{
    PWSTR   r, s, t;
    WCHAR   Drive[3];
    PDISK_REGION TargetRegion;

    //
    //  Check if the subdirectory $OEM$\\$$ exists on the source directory.
    //  If it exists, then tree copy the directory on top of %SystemRoot%
    //
    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
    r = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );
    if( r != NULL ) {
        *r = (WCHAR)'\0';
    }
    //
    //  Make a copy of the path that we have so far. It will be used to build the
    //  path to $OEM$\$1
    //
    s = SpDupStringW(TemporaryBuffer);

    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_FILES_SYSROOT_W );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            SpCopyDirRecursive( r,
                                NtPartition,
                                Sysroot,
                                COPY_DELETESOURCE
                              );
        }

        SpMemFree( r );
    }

    //
    //  Check if the subdirectory $OEM$\\$1 exists on the source directory.
    //  If it exists, then tree copy the directory to the root of %SystemDrive%
    //
    wcscpy(TemporaryBuffer, s);
    SpMemFree( s );
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_FILES_SYSDRVROOT_W );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            SpCopyDirRecursive( r,
                                NtPartition,
                                L"\\",
                                COPY_DELETESOURCE
                              );
        }
        SpMemFree( r );
    }


    //
    //  Copy the subdirectories $OEM$\<drive letter> to the root of each
    //  corresponding drive.
    //  These directories are:
    //
    //      $OEM$\C
    //      $OEM$\D
    //      $OEM$\E
    //          .
    //          .
    //          .
    //      $OEM$\Z
    //
    //
    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
    r = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );

    if( r != NULL ) {
        *r = (WCHAR)'\0';
    }

    SpConcatenatePaths( TemporaryBuffer, L"\\C" );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        s = wcsrchr( r, (WCHAR)'\\' );
        s++;

        Drive[1] = (WCHAR)':';
        Drive[2] = (WCHAR)'\0';

        for( Drive[0] = (WCHAR)'C'; Drive[0] <= (WCHAR)'Z'; Drive[0] = Drive[0] + 1) {
            //
            //  If the subdirectory $OEM$\<drive letter> exists on the source,
            //  and if there is a FAT or NTFS partition in the target machine that
            //  has the same drive letter specification, then tree copy
            //  $OEM$\<drive letter> to the corresponding partition in the target
            //  machine.
            //
            *s = Drive[0];
            if( SpFileExists( r, TRUE ) ) {
                if( ( ( TargetRegion = SpRegionFromDosName( Drive ) ) != NULL ) &&
                    TargetRegion->PartitionedSpace &&
                    ( ( TargetRegion->Filesystem  == FilesystemFat   ) ||
                      ( TargetRegion->Filesystem  == FilesystemFat32 ) ||
                      ( TargetRegion->Filesystem  == FilesystemNtfs  ) )
                  ) {
                    SpNtNameFromRegion( TargetRegion,
                                        TemporaryBuffer,
                                        sizeof(TemporaryBuffer),
                                        PartitionOrdinalCurrent );
                    t = SpDupStringW(TemporaryBuffer);
                    SpCopyDirRecursive( r,
                                        t,
                                        L"",
                                        COPY_DELETESOURCE
                                      );
                    SpMemFree( t );
                }
            }
        }
        SpMemFree( r );
    }

    //
    //  Merge %SystemRoot%\$$rename.txt with $$rename.txt in the root of the
    //  NT partition.
    //
    SppMergeRenameFiles( SourceDevicePath, NtPartition, Sysroot );
}



VOID
SppMergeRenameFiles(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SourceDevicePath: Path to the device that contains the source.

    NtPartition:  Path to the drive that contains the system.

    Systroot:     Directory where the system is installed.

Return Value:

    None.

--*/

{
    PWSTR        r, s;
    PDISK_REGION TargetRegion;
    NTSTATUS     Status;
    PVOID        RootRenameFile;
    PVOID        SysrootRenameFile;
    ULONG        ErrorLine;
    ULONG        SectionCount;
    ULONG        LineCount;
    ULONG        i,j;
    PWSTR        SectionName;
    PWSTR        NewSectionName;
    PWSTR        KeyName;
    PWSTR        Values[1];
    PFILE_TO_RENAME File;

    //
    //  Build the ful path to %sysroot%\$$rename.txt
    //
    wcscpy(TemporaryBuffer, NtPartition);
    SpConcatenatePaths( TemporaryBuffer, Sysroot );
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_LFNLIST_W );
    s = SpDupStringW(TemporaryBuffer);

    //
    //  Load %sysroot%\$$rename.txt, if one exists
    //
    if( SpFileExists( s, FALSE ) ) {
        //
        //  Load Sysroot\$$rename.txt
        //
        Status = SpLoadSetupTextFile( s,
                                      NULL,
                                      0,
                                      &SysrootRenameFile,
                                      &ErrorLine,
                                      TRUE,
                                      FALSE
                                      );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load file %ws. Status = %lx \n", s, Status ));
            goto merge_rename_exit;
        }
    } else {
        SysrootRenameFile = NULL;
    }

    //
    //  If there is a $$rename.txt on sysroot, then it needs to be merged
    //  (or appended) to the one in the NtPartition.
    //  If RenameList is not empty, then the files in this list need to be
    //  added to $$rename.txt on the NtPartition.
    //  Otherwise, don't do any merge.
    //
    if( ( SysrootRenameFile != NULL )
        || ( RenameList != NULL )
      ) {

        //
        //  Find out if the NtPartition contains a $$rename.txt
        //
        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_LFNLIST_W );
        r = SpDupStringW(TemporaryBuffer);
        if( !SpFileExists( r, FALSE ) ) {
            //
            //  If the NT partition doesn't contain $$rename.txt, then
            //  create a new $$rename.txt in memory
            //
            RootRenameFile = SpNewSetupTextFile();
            if( RootRenameFile == NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpNewSetupTextFile() failed \n"));
                if( SysrootRenameFile != NULL ) {
                    SpFreeTextFile( SysrootRenameFile );
                }
                SpMemFree( r );
                goto merge_rename_exit;
            }

        } else {
            //
            //  Load $$rename on the NTPartition
            //
            Status = SpLoadSetupTextFile( r,
                                          NULL,
                                          0,
                                          &RootRenameFile,
                                          &ErrorLine,
                                          TRUE,
                                          FALSE
                                          );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load file %ws. Status = %lx \n", r, Status ));
                if( SysrootRenameFile != NULL ) {
                    SpFreeTextFile( SysrootRenameFile );
                }
                SpMemFree( r );
                goto merge_rename_exit;
            }
        }

        if( SysrootRenameFile != NULL ) {
            //
            //  Add the section of Sysroot\$$rename.txt to $$rename.txt in memory
            //  Note that we need to prepend Sysroot to the section name
            //
            SectionCount = SpCountSectionsInFile( SysrootRenameFile );
            for( i = 0; i < SectionCount; i++ ) {
                SectionName = SpGetSectionName( SysrootRenameFile, i );
                if( SectionName != NULL ) {
                    wcscpy(TemporaryBuffer, L"\\");
                    SpConcatenatePaths( TemporaryBuffer, Sysroot);
                    SpConcatenatePaths( TemporaryBuffer, SectionName );
                    NewSectionName = SpDupStringW(TemporaryBuffer);
                    LineCount = SpCountLinesInSection( SysrootRenameFile, SectionName );
                    for( j = 0; j < LineCount; j++ ) {
                        KeyName = SpGetKeyName( SysrootRenameFile, SectionName, j );
                        Values[0] = SpGetSectionKeyIndex( SysrootRenameFile, SectionName, KeyName, 0 );
                        SpAddLineToSection( RootRenameFile,
                                            NewSectionName,
                                            KeyName,
                                            Values,
                                            1 );
                    }
                    SpMemFree( NewSectionName );
                }
            }
            //
            //  $$rename.txt on Sysroot is no longer needed
            //
            SpFreeTextFile( SysrootRenameFile );
            SpDeleteFile( s, NULL, NULL );
        }

        //
        //  Add the files in RenameList to \$$rename.txt
        //
        if( RenameList != NULL ) {
            do {
                File = RenameList;
                RenameList = File->Next;
                Values[0] = File->TargetFilename;
                SpAddLineToSection( RootRenameFile,
                                    File->TargetDirectory,
                                    File->SourceFilename,
                                    Values,
                                    1 );
                SpMemFree( File->SourceFilename );
                SpMemFree( File->TargetFilename );
                SpMemFree( File->TargetDirectory );
                SpMemFree( File );
            } while( RenameList != NULL );
        }

        //
        //  Create a new \$$rename.txt
        //
        SpWriteSetupTextFile( RootRenameFile, r, NULL, NULL );
        //
        //  $$rename.txt on memory is no longer needed
        //
        SpFreeTextFile( RootRenameFile );
    }

merge_rename_exit:

    SpMemFree( s );
}


BOOLEAN
SpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    )
{
    //
    // steal time from windows\base\client\datetime.c, DosDateTimeToFileTime()
    // and LocalFileTimeToFileTime()
    //

    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;
    LARGE_INTEGER Bias;

    TimeFields.Year         = (CSHORT)((Date & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((Date & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((Date & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((Time & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((Time & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((Time & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {

        //
        // now convert to utc time
        //
        do {
            Bias.HighPart = USER_SHARED_DATA->TimeZoneBias.High1Time;
            Bias.LowPart = USER_SHARED_DATA->TimeZoneBias.LowPart;
        } while (Bias.HighPart != USER_SHARED_DATA->TimeZoneBias.High2Time);
        UtcTime->QuadPart = Bias.QuadPart + FileTime.QuadPart;

        return(TRUE);
    }

    RtlSecondsSince1980ToTime( 0, UtcTime );  // default = 1-1-1980

    return(FALSE);

}



BOOLEAN
pSpIsFileInDriverInf(
    IN PCWSTR FileName,
    IN PVOID SifHandle,
    HANDLE *CabHandle
    )
{
    PWSTR  InfFileName, CabFileName;
    UINT   FileCount,i,j;
    PWSTR  szSetupSourceDevicePath = 0;
    PWSTR  szDirectoryOnSetupSource = 0;
    HANDLE hSif = (HANDLE)0;
    CABDATA *MyCabData;


    if (!DriverInfHandle) {
        if (gpCmdConsBlock) {
            szSetupSourceDevicePath = gpCmdConsBlock->SetupSourceDevicePath;
            szDirectoryOnSetupSource = gpCmdConsBlock->DirectoryOnSetupSource;
            hSif = (HANDLE)(gpCmdConsBlock->SifHandle);

        } else {
            if (ghSif && gszDrvInfDeviceName && gszDrvInfDirName) {
                hSif = ghSif;
                szSetupSourceDevicePath = gszDrvInfDeviceName;
                szDirectoryOnSetupSource = gszDrvInfDirName;
            }
        }

        if (szSetupSourceDevicePath && szDirectoryOnSetupSource &&
                hSif) {
            //
            // try to open handle to drvindex.inf and to driver.cab,
            // prompting for media if required
            //
            SpInitializeDriverInf( hSif,
                                   szSetupSourceDevicePath,
                                   szDirectoryOnSetupSource );

            if (!DriverInfHandle)
                return(FALSE);
        } else {
            return FALSE;
        }
    }

    //
    // look for the file in all loaded cabs, in order
    //
    MyCabData = CabData;
    while (MyCabData) {
        if (MyCabData->CabHandle && MyCabData->CabSectionName && MyCabData->CabInfHandle) {
            if (!SifHandle || SifHandle == MyCabData->CabInfHandle) {
                //
                // look for entries in this inf
                //
                FileCount = SpCountLinesInSection(MyCabData->CabInfHandle, MyCabData->CabSectionName);
                for (i=0; i< FileCount; i++) {
                    InfFileName = SpGetSectionLineIndex( MyCabData->CabInfHandle, MyCabData->CabSectionName, i, 0);
                    if (InfFileName && _wcsicmp (InfFileName, FileName) == 0) {
                        //
                        // Got him. Return the handle.
                        //
                        *CabHandle = MyCabData->CabHandle;
                        return TRUE;
                    }
                }
            }
        }

        MyCabData = MyCabData->Next;
    }

    return(FALSE);

}

NTSTATUS
SpOpenFileInDriverCab(
    PCWSTR SourceFileName,
    IN PVOID SifHandle,
    HANDLE *SourceHandle
    )
{
    if (!pSpIsFileInDriverInf( SourceFileName, SifHandle, SourceHandle )) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return STATUS_SUCCESS;

}


#ifdef _X86_
//
// Structure used by next few routines below.  The SpMigMoveFileOrDir
// moves the file/dir with ntos rtl, but the rtl resets the attributes!!
// We have no choice but to traverse the file/dir and save the attributes
// in a list, then do the move, then restore the attributes from the list.
//

typedef struct {
    ULONG BaseDirChars;
    PWSTR BaseDir;
    ULONG FileCount;
    ULONG BytesNeeded;
    PBYTE OriginalPos;
    PBYTE CurrentPos;       // NULL if callback should determine size and count
} ATTRIBS_LIST, *PATTRIBS_LIST;


VOID
SppAddAttributeToList (
    IN      ULONG Attributes,
    IN      PWSTR FileOrDir,
    OUT     PATTRIBS_LIST List
    )

/*++

Routine Description:

    This private function updates the attribute list.  It has two modes:
    (A) the size is being calculated or (B) the list is being created.

Arguments:

    Attributes:   The attributes of the file (needed for (B) only)

    FileOrDir:    Partial path to file or dir (it is relative to the
                  base path)

    List:         List structure that is updated

Return Value:

    None.

--*/

{
    ULONG BytesNeeded;

    BytesNeeded = sizeof (ULONG) + (wcslen (FileOrDir) + 1) * sizeof (WCHAR);

    if (List->CurrentPos) {
        *((PULONG) List->CurrentPos) = Attributes;
        wcscpy ((PWSTR) (List->CurrentPos + sizeof (ULONG)), FileOrDir);
        List->CurrentPos += BytesNeeded;
    } else {
        List->BytesNeeded += BytesNeeded;
        List->FileCount += 1;
    }
}


BOOLEAN
SpAttribsEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )

/*++

Routine Description:

    SpAttribsEnumFile is an EnumFilesRecursive callback.  It
    recieves every file, dir, subfile and subdir for a file/dir
    being moved.  (It does not recieve the . and .. dirs.)

    For each file, the attributes and file name are added to
    the attribute list.

Arguments:

    DirName:        Path to the current directory

    FileInfo:       Structure containing information about the file or
                    subdir being enumerated.

    ret:            Return code used for failuers

    Pointer:        A pointer to an ATTRIBS_LIST structure.

Return Value:

    TRUE unless an error occurs (errors stop enumeration).

--*/

{
    PATTRIBS_LIST BufferInfo;
    PWSTR p;
    ULONG Attributes;
    NTSTATUS Status;
    PWSTR temp;
    ULONG Len;
    PWSTR FullPath;

    BufferInfo = (PATTRIBS_LIST) Pointer;

    //
    // Check state of BufferInfo
    //

    ASSERT (wcslen(DirName) >= BufferInfo->BaseDirChars);

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // Get attributes and add file to the list
    //

    Status = SpGetAttributes (FullPath, &Attributes);
    if (NT_SUCCESS (Status)) {
        SppAddAttributeToList (
            Attributes,
            FullPath + BufferInfo->BaseDirChars,
            BufferInfo
            );
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get attributes for %ws, Status=%lx\n", FullPath, Status));
    }

    SpMemFree (FullPath);

    return TRUE;
}


NTSTATUS
SpSaveFileOrDirAttribs (
    IN      PWSTR SourceFileOrDir,
    OUT     PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine determines if SourceFileOrDir is a file or dir.
    For a file, it obtains the attributes and puts it in the
    supplied attribs list.  For a dir, it obtains the attributes
    of the dir, plus all attributes of subdirs and subfiles and
    puts them in the supplied attribs list.  This function uses
    EnumFilesRecursive to enumerate everything in a directory.

Arguments:

    SourceFileOrDir: Full path to a file or directory to build
                     an attribute list from.

    BufferInfo:      A caller-allocated ATTRIBS_LIST struct that
                     recieves a list of attributes and relative
                     paths.

Return Value:

    Standard NT Status code.

--*/

{
    LONG                BaseAttribute;
    NTSTATUS            Status;

    //
    // Get attributes of base file or directory provided
    //

    Status = SpGetAttributes (SourceFileOrDir, &BaseAttribute);
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP:SpSaveFileOrDirAttribs, Failed to get attributes %ws - status 0x%08X.\n", 
            SourceFileOrDir, 
            Status));
        return Status;
    }

    //
    // Set the size required and file count for base file or dir
    //
    RtlZeroMemory (BufferInfo, sizeof (ATTRIBS_LIST));
    BufferInfo->BaseDirChars = wcslen (SourceFileOrDir);
    SppAddAttributeToList (BaseAttribute, L"", BufferInfo);

    //
    // If the supplied path is to a directory, find the number of bytes
    // needed to hold a list of all subfiles and subdirectories.
    //

    if (BaseAttribute & FILE_ATTRIBUTE_DIRECTORY) {
        // Determine space needed to hold all file names
        SpEnumFilesRecursive (
            SourceFileOrDir,
            SpAttribsEnumFile,
            &Status,
            BufferInfo
            );
    }

    //
    // Allocate the file list
    //

    BufferInfo->OriginalPos = SpMemAlloc (BufferInfo->BytesNeeded);
    BufferInfo->CurrentPos = BufferInfo->OriginalPos;

    //
    // Add the base attributes for real this time
    //

    SppAddAttributeToList (BaseAttribute, L"", BufferInfo);

    //
    // For directories, add all subfiles and subdirectories
    //

    if (BaseAttribute & FILE_ATTRIBUTE_DIRECTORY) {
        // Add all files, dirs, subfiles and subdirs to the list
        SpEnumFilesRecursive (
             SourceFileOrDir,
             SpAttribsEnumFile,
             &Status,
             BufferInfo
             );
    }

    return Status;
}

VOID
SppRestoreAttributesFromList (
    IN OUT  PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine restores the attributes associated with a file
    in the supplied attribs list.  After the attributes are set,
    the list size is decremented.  A few sanity checks are also
    done.

Arguments:

    BufferInfo:   The attribs structure that has at least one
                  file/dir and attribute pair in it.  The
                  list pointer is advanced and the file count
                  is decremented.

Return Value:

    None.

--*/

{
    ULONG Attributes;
    PWSTR Path;
    ULONG BytesNeeded;
    PWSTR FullPath;
    NTSTATUS Status;

    Attributes = *((PULONG) BufferInfo->CurrentPos);
    Path       = (PWSTR) (BufferInfo->CurrentPos + sizeof (ULONG));

    BytesNeeded = sizeof (ULONG) + (wcslen (Path) + 1) * sizeof (WCHAR);

    // guard against abnormal failure
    if (BytesNeeded > BufferInfo->BytesNeeded ||
        !BufferInfo->BaseDir) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppRestoreAttributesFromList failed abnormally\n"));
        BufferInfo->FileCount = 0;
        return;
    }

    //
    // Prepare full path
    //

    wcscpy (TemporaryBuffer, BufferInfo->BaseDir);
    if (*Path) {
        SpConcatenatePaths(TemporaryBuffer, Path);
    }

    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // Set attributes
    //

    Status = SpSetAttributes (FullPath, Attributes);
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not set attributes for %ws, Status=%lx\n", FullPath, Status));
    }

    //
    // Adjust position state
    //

    BufferInfo->CurrentPos += BytesNeeded;
    BufferInfo->BytesNeeded -= BytesNeeded;
    BufferInfo->FileCount -= 1;

    //
    // Cleanup
    //

    SpMemFree (FullPath);
}


VOID
SpCleanUpAttribsList (
    IN      PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This is the cleanup routine needed by SpRestoreFileOrDirAttribs,
    or by the ATTRIBS_LIST allocating function if the attributes
    don't get restored.

    This routine cannot be called twice on the same structure.

Arguments:

    BufferInfo:   The attribs structure to clean up.

Return Value:

    None.

--*/

{
    if (BufferInfo->OriginalPos) {
        SpMemFree (BufferInfo->OriginalPos);
    }
}


VOID
SpRestoreFileOrDirAttribs (
    IN      PWSTR DestFileOrDir,
    IN      PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine calls SppRestoreAttributesFromList for every
    file/dir and attribute pair in the supplied attribute list.
    The attributes are applied to a new base dir.  This function
    is used to restore attributes after a file or directory has
    been moved.

Arguments:

    DestFileOrDir:  The new full path of the file or dir

    BufferInfo:     The caller-allocated ATTRIBS_LIST that was
                    prepared by SpSaveFileOrDirAttribs.

Return Value:

    None.  (Errors are ignored.)

--*/

{
    ULONG BaseAttributes;
    NTSTATUS Status;

    BufferInfo->CurrentPos = BufferInfo->OriginalPos;
    BufferInfo->BaseDir = DestFileOrDir;

    while (BufferInfo->FileCount > 0) {
        SppRestoreAttributesFromList (BufferInfo);
    }

    SpCleanUpAttribsList (BufferInfo);
}


VOID
SpMigMoveFileOrDir (
    IN      PWSTR SourceFileOrDir,
    IN      PWSTR DestFileOrDir
    )

/*++

Routine Description:

  SpMigMoveFileOrDir sets the attribute of the source file to be
  normal, moves the file into the destination, and resets the
  attribute.  If an error occurs, it is ignored.  There's nothing
  the user can do about the error, and it will be detected in GUI
  mode.  In an error condition, the user's settings will not be
  completely migrated, but NT will install OK.  (Any error would
  be really bad news for the user anyhow, like a hardware failure.)

Arguments:

    SourceFileOrDir:       The source path (with DOS drive)

    DestFileOrDir:         The destination path (with DOS drive)

Return Value:

    None.  Errors ignored.

--*/


{
    NTSTATUS Status;
    PDISK_REGION SourceRegion;              // source region (converted from DOS path)
    PDISK_REGION DestRegion;                // destination region (also converted)
    PWSTR SrcNTPath;                        // buffer for full source path
    PWSTR DestPartition;                    // buffer for destination partition in NT namespace
    PWSTR DestNTPath;                       // buffer for full source dest
    PWSTR DestDir;                          // DestFileOrDir with last subdir or file chopped off
    PWSTR DestDirWack;                      // Used to find last subdir or file in DestDir path
    ATTRIBS_LIST AttribsList;               // used to save attribute list


    // We are guaranteed to have drive letters because of WINNT32's behavior.
    // However, let's verify and ignore messed up data.

    if (!(SourceFileOrDir && SourceFileOrDir[0] && SourceFileOrDir[1] == L':')) {
        return;
    }

    if (!(DestFileOrDir && DestFileOrDir[0] && DestFileOrDir[1] == L':')) {
        return;
    }

    // Get regions for DOS paths
    SourceRegion = SpRegionFromDosName (SourceFileOrDir);

    if (!SourceRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpRegionFromDosName failed for %ws\n", SourceFileOrDir));

        return;
    }

    DestRegion = SpRegionFromDosName (DestFileOrDir);

    if (!DestRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpRegionFromDosName failed for %ws\n", DestFileOrDir));

        return;
    }

    // Make full paths
    SpNtNameFromRegion(
                    SourceRegion,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    // no repartioning is possible, so this is the same ordinal
                    // as the original
                    PartitionOrdinalCurrent
                    );

    SpConcatenatePaths( TemporaryBuffer, &SourceFileOrDir[2]);
    SrcNTPath = SpDupStringW(TemporaryBuffer);

    SpNtNameFromRegion(
                    DestRegion,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalCurrent
                    );

    DestPartition = SpDupStringW(TemporaryBuffer);
    SpConcatenatePaths( TemporaryBuffer, &DestFileOrDir[2]);
    DestNTPath = SpDupStringW(TemporaryBuffer);

    // Save file attribs
    Status = SpSaveFileOrDirAttribs (SrcNTPath, &AttribsList);

    if (NT_SUCCESS (Status)) {
        // Reset file attribs
        Status = SpSetAttributes (SrcNTPath, FILE_ATTRIBUTE_NORMAL);

        if (NT_SUCCESS (Status)) {
            // Ensure destination exists
            DestDir = SpDupStringW (&DestFileOrDir[2]);

            if (DestDir) {
                DestDirWack = wcsrchr (DestDir, L'\\');

                if (DestDirWack) {
                    *DestDirWack = 0;
                }

                SpCreateDirectory (DestPartition,
                                   NULL,
                                   DestDir,
                                   0,
                                   0);

                SpMemFree (DestDir);
            }

            // Move the file or directory tree
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP: Moving %ws to %ws\n", SrcNTPath, DestNTPath));

            Status = SpMoveFileOrDirectory (SrcNTPath, DestNTPath);

            // Restore attributes
            if (NT_SUCCESS (Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP: Restoring attributes on %ws\n", DestNTPath));

                SpRestoreFileOrDirAttribs (DestNTPath, &AttribsList);
            } else {
                SpCleanUpAttribsList (&AttribsList);
            }
        }
        else {
            KdPrintEx((
                DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP:SpMigMoveFileOrDir, Could not set attributes for %ws, Status=%lx\n", 
                SrcNTPath, 
                Status));
        }
    }
    else{
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP:SpMigMoveFileOrDir, Function \"SpSaveFileOrDirAttribs\" failed with %ws, Status=%lx\n", 
            SrcNTPath, 
            Status));
    }

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to move file %ws to %ws. Status = %lx \n",
            SrcNTPath, DestNTPath, Status ));
    }

    // Clean up
    SpMemFree( SrcNTPath );
    SpMemFree( DestNTPath );
    SpMemFree( DestPartition );
}


VOID
SpMigDeleteFile (
    PWSTR DosFileToDelete
    )

/*++

Routine Description:

  SpMigDeleteFile sets the attribute of the source file to be
  normal, and then deletes the file.  If an error occurs, it
  is ignored.  There's nothing the user can do about the error,
  and it will be detected in file copy.  In an error condition,
  there is a potential for two copies of the same file--an NT
  version and a Win9x version.  Any error would be really
  bad news for the user anyhow, like a hardware failure, and
  textmode's file copy won't succeed.

Arguments:

    DosFileToDelete:       The source path (with DOS drive)

Return Value:

    None.  Errors ignored.

--*/

{
    NTSTATUS Status;
    PDISK_REGION SourceRegion;              // source region (converted from DOS path)
    PWSTR SrcNTPath;                        // buffer for full source path

    // We are guaranteed to have drive letters because of WINNT32's behavior.
    // However, let's verify and ignore messed up data.

    if (!(DosFileToDelete && DosFileToDelete[0] && DosFileToDelete[1] == L':'))
        return;

    // Get region for DOS path
    SourceRegion = SpRegionFromDosName (DosFileToDelete);
    if (!SourceRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRegionFromDosName failed for %ws\n", DosFileToDelete));
        return;
    }

    SpNtNameFromRegion(
        SourceRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        // no repartioning is possible, so this is the same ordinal
        // as the original
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths (TemporaryBuffer, &DosFileToDelete[2]);
    SrcNTPath = SpDupStringW (TemporaryBuffer);

    SpSetAttributes (SrcNTPath, FILE_ATTRIBUTE_NORMAL);

    if (SpFileExists (SrcNTPath, FALSE)) {

        //
        // Delete the file
        //

        Status = SpDeleteFile (SrcNTPath, NULL, NULL);

    } else if (SpFileExists (SrcNTPath, TRUE)) {

        //
        // Delete the empty directory
        //

        Status = SpDeleteFileEx (
                    SrcNTPath,
                    NULL,
                    NULL,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_FOR_BACKUP_INTENT
                    );
    } else {
        //
        // Doesn't exist -- ignore delete request
        //

        Status = STATUS_SUCCESS;
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to delete %ws. Status = %lx \n",
            SrcNTPath,
            Status
            ));
    }

    // Clean up
    SpMemFree( SrcNTPath );
}

#endif // defined _X86_


NTSTATUS
SpExpandFile(
    IN PWSTR            SourceFilename,
    IN PWSTR            TargetPathname,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    )

/*++

Routine Description:

    Attempt to decompress contents of a file, reporting progress via callback.

Arguments:

    SourceFilename - supplies fully qualified name of compressed file
        in the NT namespace.

    TargetPathname - supplies fully qualified path for target file(s)
        in the NT namespace.

Return Value:

    NT Status value indicating outcome.

--*/

{
    NTSTATUS Status;
    HANDLE SourceHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG FileSize;
    PVOID ImageBase;
    HANDLE SectionHandle = INVALID_HANDLE_VALUE;
    BOOLEAN IsCabinet = FALSE;
    BOOLEAN IsMultiFileCabinet;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    //
    // Open the source file.
    //

    INIT_OBJA(&Obja,&UnicodeString,SourceFilename);

    Status = ZwCreateFile( &SourceHandle,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: Unable to open source file %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    Status = SpGetFileSize( SourceHandle, &FileSize );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: unable to get size of %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    Status = SpMapEntireFile( SourceHandle, &SectionHandle, &ImageBase, FALSE );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: Unable to map source file %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    IsCabinet = SpdIsCabinet( ImageBase, FileSize, &IsMultiFileCabinet );

    if ( !IsCabinet ) {

        LARGE_INTEGER Zero;

        Zero.QuadPart = 0;

        Callback( EXPAND_NOTIFY_CANNOT_EXPAND,
                  SourceFilename,
                  &Zero,
                  &Zero,
                  0,
                  CallbackContext );

        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Advise client if the source contains multiple files
    //

    if ( IsMultiFileCabinet ) {

        EXPAND_CALLBACK_RESULT rc;
        LARGE_INTEGER Zero;

        Zero.QuadPart = 0;

        rc = Callback( EXPAND_NOTIFY_MULTIPLE,
                       SourceFilename,
                       &Zero,
                       &Zero,
                       0,
                       CallbackContext );

        if ( rc == EXPAND_ABORT ) {
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
    }

    Status = SpdDecompressCabinet( ImageBase,
                                   FileSize,
                                   TargetPathname,
                                   Callback,
                                   CallbackContext );

exit:

    if (SectionHandle != INVALID_HANDLE_VALUE) {
        SpUnmapFile( SectionHandle, ImageBase );
    }

    if ( SourceHandle != INVALID_HANDLE_VALUE ) {
        ZwClose( SourceHandle );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spddlang.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddlang.h

Abstract:

    Header file for language/locale support interface
    for Far East localizations.

Author:

    Ted Miller (tedm) 4-July-1995

Revision History:

--*/

#ifndef _SPDDLANG_H_
#define _SPDDLANG_H_

NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage,
    IN ULONG BootFontImageLength
    );

NTSTATUS
SplangTerminateFontSupport(
    VOID
    );

typedef enum {
    SpVideoVga = 0,
    SpVideoFrameBuffer,
    SpVideoMax
} SpVideoType;

PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    );

ULONG
SplangGetColumnCount(
    IN PCWSTR String
    );

PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    );

VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    );

WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    );

WCHAR
SplangGetCursorChar(
    VOID
    );

NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    );

BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    );

#endif // _SPDDLANG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdisk.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdisk.h

Abstract:

    Public header file for disk support module in text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#ifndef _SPDISK_
#define _SPDISK_


//
// The following will be TRUE if hard disks have been determined
// successfully (ie, if SpDetermineHardDisks was successfully called).
//
extern BOOLEAN HardDisksDetermined;



NTSTATUS
SpDetermineHardDisks(
    IN PVOID SifHandle
    );

NTSTATUS
SpOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    );

#define SpOpenPartition0(path,handle,write)  SpOpenPartition((path),0,(handle),(write))

NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONGLONG SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOLEAN Write
    );

ULONG
SpArcDevicePathToDiskNumber(
    IN PWSTR ArcPath
    );

#define DISK_DEVICE_NAME_BASE   L"\\device\\harddisk"

//
// Define enumerated type for possible states a hard disk can be in.
//
typedef enum {
    DiskOnLine,
    DiskOffLine
} DiskStatus;

//
// Int13 hooker types.
//
typedef enum {
    NoHooker = 0,
    HookerEZDrive,
    HookerOnTrackDiskManager,
    HookerMax
} Int13HookerType;




//
// Define per-disk structure used internally to track hard disks.
//
typedef struct _HARD_DISK {

    //
    // Cylinder count we got back from the i/o system.
    //
    ULONGLONG     CylinderCount;

    //
    // Path in the NT namespace of the device.
    //
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];

    //
    // Geometry information.
    //
    DISK_GEOMETRY Geometry;
    ULONG         SectorsPerCylinder;
    ULONGLONG     DiskSizeSectors;
    ULONG         DiskSizeMB;

    //
    // Characteristics of the device (remoavable, etc).
    //
    ULONG Characteristics;

    //
    // Status of the device.
    //
    DiskStatus Status;

    //
    // Human-readable description of the disk device.
    //
    WCHAR Description[256];

    //
    // If the disk is a scsi disk, then the shortname of the
    // scsi miniport driver is stored here. If this string
    // is empty, then the disk is not a scsi disk.
    //
    WCHAR ScsiMiniportShortname[24];

    //
    // scsi-style ARC path of the disk device if possible for the disk.
    // Empty string if not. This is used to translate between scsi-style ARC
    // NT names because the 'firmware' cannot see scsi devices without BIOSes
    // and so they do not appear in the arc disk info passed by the osloader.
    // (IE, there are no arc names in the system for such disks).
    //
    WCHAR ArcPath[128];

    //
    // Int13 hooker support (ie, EZDrive).
    //
    Int13HookerType Int13Hooker;

    //
    // This tells us whether the disk is PCMCIA or not.
    //
    BOOLEAN PCCard;

    //
    // Contains the signature of the disk. This is used during the
    // identification of FT partitions, on the upgrade case.
    //
    ULONG Signature;

    //
    // MBR type: formatted for PC/AT or NEC98.
    //
    UCHAR FormatType;

    //
    // Wether the disk completely free
    //
    BOOLEAN NewDisk;    

    //
    // The drive information we read
    // 
    DRIVE_LAYOUT_INFORMATION_EX     DriveLayout;
    
#if 0
    //
    // Number of partition tables (are different between PC/AT and NEC98).
    //
    USHORT MaxPartitionTables;
#endif //0

} HARD_DISK, *PHARD_DISK;

#define DISK_FORMAT_TYPE_UNKNOWN 0x00
#define DISK_FORMAT_TYPE_PCAT    0x01
#define DISK_FORMAT_TYPE_NEC98   0x02
#define DISK_FORMAT_TYPE_GPT     0x03
#define DISK_FORMAT_TYPE_RAW     0x04

#define DISK_TAG_TYPE_UNKNOWN   L"[Unknown]"
#define DISK_TAG_TYPE_PCAT      L"[MBR]"
#define DISK_TAG_TYPE_NEC98     L"[NEC98]"
#define DISK_TAG_TYPE_GPT       L"[GPT]"
#define DISK_TAG_TYPE_RAW       L"[Raw]"
#define DISK_TAG_START_CHAR     L'['

extern WCHAR   *DiskTags[];

VOID
SpAppendDiskTag(
    IN PHARD_DISK Disk
    );

//
// These two globals track the hard disks attached to the computer.
//
extern PHARD_DISK HardDisks;
extern ULONG      HardDiskCount;

//
// These flags get set to TRUE if we find any disks owned
// by ATDISK or ABIOSDSK.
//
extern BOOLEAN AtDisksExist,AbiosDisksExist;

#endif // ndef _SPDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdriver.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdriver.c

Abstract:

    Device-driver interface routines for text setup.

Author:

    Ted Miller (tedm) 11-August-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"


PSETUP_COMMUNICATION CommunicationParams;

PVOID                RequestReadyEventObjectBody;
PVOID                RequestReadyEventWaitObjectBody;

PVOID                RequestServicedEventObjectBody;
PVOID                RequestServicedEventWaitObjectBody;

PEPROCESS            UsetupProcess;
PAUTOCHK_MSG_PROCESSING_ROUTINE pAutochkCallbackRoutine;


SYSTEM_BASIC_INFORMATION SystemBasicInfo;

BOOLEAN AutochkRunning = FALSE;
BOOLEAN AutofrmtRunning = FALSE;

NTSTATUS
SetupOpenCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SetupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SetupDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SetupUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpInitialize0(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
pSpVerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    );

ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the setup driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;

    //
    // Create exclusive device object.
    //

    RtlInitUnicodeString(&unicodeString,DD_SETUP_DEVICE_NAME_U);

    status = IoCreateDevice(
                DriverObject,
                0,
                &unicodeString,
                FILE_DEVICE_UNKNOWN,
                0,
                FALSE,
                &deviceObject
                );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create device object (%lx)\n",status));
        return(status);
    }

    //
    // Set up device driver entry points.
    //
  //DriverObject->DriverStartIo = NULL;
    DriverObject->DriverUnload = SetupUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SetupOpenCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SetupClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SetupDeviceControl;
  //DriverObject->MajorFunction[IRP_MJ_CLEANUP] = NULL;

    return((ULONG)SpInitialize0(DriverObject));
}




VOID
SetupUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the setup driver unload routine.

Arguments:

    DriverObject - Pointer to driver object.

Return Value:

    None.

--*/

{
    //
    // Delete the device object.
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    return;
}



NTSTATUS
SetupOpenCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for open/create.
    When the setup device is opened, text setup begins.
    The open/create does not complete until text setup is done.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}




NTSTATUS
SetupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for close.
    Close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}



NTSTATUS
SetupDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PSETUP_START_INFO SetupStartInfo;
    BOOLEAN b;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_SETUP_START:

        //
        // Make sure we've been passed a suitable input buffer.
        //

        if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SETUP_START_INFO)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Save away relevent fields in the setup information
            // parameters.
            //
            SetupStartInfo = (PSETUP_START_INFO)Irp->AssociatedIrp.SystemBuffer;

            ResourceImageBase =  SetupStartInfo->UserModeImageBase;

            CommunicationParams = SetupStartInfo->Communication;

            UsetupProcess = PsGetCurrentProcess();
            // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: usetup process = %lx \n", UsetupProcess));

            b = pSpVerifyEventWaitable(
                    SetupStartInfo->RequestReadyEvent,
                    &RequestReadyEventObjectBody,
                    &RequestReadyEventWaitObjectBody
                    );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            b = pSpVerifyEventWaitable(
                    SetupStartInfo->RequestServicedEvent,
                    &RequestServicedEventObjectBody,
                    &RequestServicedEventWaitObjectBody
                    );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                ObDereferenceObject(RequestReadyEventObjectBody);
                break;
            }

            SystemBasicInfo = SetupStartInfo->SystemBasicInfo;

            //
            // Start Setup going.
            //
            SpStartSetup();

            ObDereferenceObject(RequestReadyEventObjectBody);
            ObDereferenceObject(RequestServicedEventObjectBody);

            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_SETUP_FMIFS_MESSAGE:

        //
        // Make sure that we were not called by usetup.exe.
        // Make sure we've been passed a suitable input buffer.
        //
        if( (UsetupProcess == PsGetCurrentProcess()) ||
            (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SETUP_FMIFS_MESSAGE)) ) {

            ASSERT( UsetupProcess != PsGetCurrentProcess() );

            Status = STATUS_INVALID_PARAMETER;

        } else {
            PSETUP_FMIFS_MESSAGE    SetupFmifsMessage;
            SetupFmifsMessage = (PSETUP_FMIFS_MESSAGE)Irp->AssociatedIrp.SystemBuffer;

            Status = STATUS_SUCCESS;
            //
            // If there's a callback override specified, use it.
            //
            if(pAutochkCallbackRoutine) {
                Status = pAutochkCallbackRoutine(SetupFmifsMessage);
                break;
            }

            //
            //  If there is a gauge defined, then process the message.
            //  Otherwise, don't bother processing it.
            //
            if( UserModeGauge != NULL ) {
                //
                // Save away relevent fields in the setup information
                // parameters.
                //
                // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: caller process = %lx \n", PsGetCurrentProcess()));
                // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FmIfsPacketType = %d \n", SetupFmifsMessage->FmifsPacketType));
                //
                //  Find out if the FmIfs packet is one of those that we care about
                //
                if( SetupFmifsMessage->FmifsPacketType == FmIfsPercentCompleted ) {
                    ULONG   PercentCompleted;

                    // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: PercentCompleted = %d \n", ((PFMIFS_PERCENT_COMPLETE_INFORMATION)SetupFmifsMessage->FmifsPacket)->PercentCompleted ));
                    //
                    //  Save the percentage in a local variable, before we attach to
                    //  usetup address space
                    //
                    PercentCompleted = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)SetupFmifsMessage->FmifsPacket)->PercentCompleted;

                    //
                    //  We need to adjust the percentage, depending on the partition
                    //  (System or NT partition) that is currently being accessed.
                    //  We use this because we want to use only one gauge to display
                    //  the progress on both System and NT partitions.
                    //  When autochk is running, 50% of the gauge will be used to
                    //  display the progress on the system partition, and the remaining
                    //  50% will be used for the NT partition.
                    //  Note that when there are two partitions, the range of the
                    //  gauge is initialized as 200. When there is only one partition
                    //  the range is initialized as 100.
                    //  Note also that when autofmt is running, we always set CurrentDiskIndex
                    //  to 0.
                    //
                    ASSERT( CurrentDiskIndex <= 1 );
                    PercentCompleted += 100*CurrentDiskIndex;

                    //
                    //  Attach to usetup.exe address space
                    //
                    KeAttachProcess( (PKPROCESS)UsetupProcess );

                    //
                    //  Call the function that processes FmIfsPackets
                    //
                    // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Calling ProcessFmIfsPacket \n"));
                    // Status = ProcessFmIfsPacket( SetupFmifsMessage );

                    SpFillGauge( UserModeGauge, PercentCompleted );

                    if (AutochkRunning) {
                        SendSetupProgressEvent(PartitioningEvent, ValidatePartitionEvent, &PercentCompleted);
                    } else if (AutofrmtRunning) {
                        SendSetupProgressEvent(PartitioningEvent, FormatPartitionEvent, &PercentCompleted);
                    }

                    //
                    //  Now that the message was processed, detach from usetup.exe
                    //  address space
                    //
                    KeDetachProcess();
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FmIfsPacketType = %d \n", SetupFmifsMessage->FmifsPacketType));
                }
            }
        }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return(Status);
}


VOID
SpSetAutochkCallback(
    IN PAUTOCHK_MSG_PROCESSING_ROUTINE AutochkCallbackRoutine
    )
{
    pAutochkCallbackRoutine = AutochkCallbackRoutine;
}


BOOLEAN
pSpVerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    )
{
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;

    //
    // Reference the event and verify that it is waitable.
    //
    Status = ObReferenceObjectByHandle(
                hEvent,
                EVENT_ALL_ACCESS,
                NULL,
                KernelMode,
                EventObjectBody,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to reference event object (%lx)\n",Status));
        return(FALSE);
    }

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(*EventObjectBody);
    if(!ObjectHeader->Type->TypeInfo.UseDefaultObject) {

        *EventWaitObjectBody = (PVOID)((PCHAR)(*EventObjectBody) +
                              (ULONG_PTR)ObjectHeader->Type->DefaultObject);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: event object not waitable!\n"));
        ObDereferenceObject(*EventObjectBody);
        return(FALSE);
    }

    return(TRUE);
}



NTSTATUS
SpInvokeUserModeService(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Set the event indicating that the communication buffer is
    // ready for the user-mode process. Because this is a synchronization
    // event, it automatically resets after releasing the waiting
    // user-mode thread.  Note that we specify WaitNext to prevent the
    // race condition between setting this synchronization event and
    // waiting on the next one.
    //
    KeSetEvent(RequestReadyEventObjectBody,EVENT_INCREMENT,TRUE);

    //
    // Wait for the user-mode process to indicate that it is done
    // processing the request.  We wait in user mode so that we can be 
    // interrupted if necessary -- say, by an exit APC.
    //
    Status = KeWaitForSingleObject(
                RequestServicedEventWaitObjectBody,
                Executive,
                UserMode,
                FALSE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: KeWaitForSingleObject returns %lx\n",Status));
        return(Status);
    }

    //
    // Return the status returned by the user mode process.
    //
    return(CommunicationParams->u.Status);
}



NTSTATUS
SpExecuteImage(
    IN  PWSTR  ImagePath,
    OUT PULONG ReturnStatus,    OPTIONAL
    IN  ULONG  ArgumentCount,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PSERVICE_EXECUTE RequestBuffer;
    NTSTATUS Status;

    //
    // Locate the request buffer and set up the request number.
    //
    CommunicationParams->u.RequestNumber = SetupServiceExecute;
    RequestBuffer = (PSERVICE_EXECUTE)&CommunicationParams->Buffer;

    //
    // Determine the lcoations of the two strings that get copied
    // into the request buffer for this service.
    //
    RequestBuffer->FullImagePath = RequestBuffer->Buffer;
    RequestBuffer->CommandLine = RequestBuffer->FullImagePath + wcslen(ImagePath) + 1;

    //
    // Copy the image path into the request buffer.
    //
    wcscpy(RequestBuffer->FullImagePath,ImagePath);

    //
    // Move the arguments into the request buffer one by one
    // starting with the image path.
    //
    wcscpy(RequestBuffer->CommandLine,ImagePath);
    va_start(arglist,ArgumentCount);
    for(i=0; i<ArgumentCount; i++) {

        wcscat(RequestBuffer->CommandLine,L" ");
        wcscat(RequestBuffer->CommandLine,va_arg(arglist,PWSTR));
    }
    va_end(arglist);

    //
    // Invoke the service.
    //
    Status = SpInvokeUserModeService();

    //
    // Set process's return status (if required)
    //
    if(NT_SUCCESS(Status) && ReturnStatus) {
        *ReturnStatus = RequestBuffer->ReturnStatus;
    }

    return Status;
}

NTSTATUS
SpLoadUnloadKey(
    IN HANDLE TargetKeyRootDirectory,  OPTIONAL
    IN HANDLE SourceFileRootDirectory, OPTIONAL
    IN PWSTR  TargetKeyName,
    IN PWSTR  SourceFileName           OPTIONAL
    )
{
    //
    // This was once a user-mode service but now the relevent apis
    // are exported from the kernel so don't bother.
    //
    UNICODE_STRING KeyName,FileName;
    OBJECT_ATTRIBUTES ObjaKey,ObjaFile;
    NTSTATUS Status;
    BOOLEAN Loading;
    BOOLEAN bFileExists = FALSE;

    //
    // Loading if we have a source filename, otherwise unloading.
    //
    Loading = (BOOLEAN)(SourceFileName != NULL);

    INIT_OBJA(&ObjaKey,&KeyName,TargetKeyName);
    ObjaKey.RootDirectory = TargetKeyRootDirectory;

    if(Loading) {

        INIT_OBJA(&ObjaFile,&FileName,SourceFileName);
        ObjaFile.RootDirectory = SourceFileRootDirectory;

        //
        // NOTE:ZwLoadKey(...) creates the file if does not exist
        // so we need to check for the existence of the file
        //
        if (SpFileExists(SourceFileName, FALSE))
            Status = ZwLoadKey(&ObjaKey,&ObjaFile);
        else
            Status = STATUS_NO_SUCH_FILE;
    } else {
        Status = ZwUnloadKey(&ObjaKey);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP: %wskey of %ws failed (%lx)\n",
            Loading ? L"load" : L"unload",
            TargetKeyName,
            Status
            ));
    }

    return(Status);
}

NTSTATUS
SpDeleteKey(
    IN HANDLE  KeyRootDirectory, OPTIONAL
    IN PWSTR   Key
    )
{
    PSERVICE_DELETE_KEY RequestBuffer;

    //
    // Locate the request buffer and set up the request number.
    //
    CommunicationParams->u.RequestNumber = SetupServiceDeleteKey;

    RequestBuffer = (PSERVICE_DELETE_KEY)&CommunicationParams->Buffer;

    //
    // Determine the lcoation of the strings that get copied
    // into the request buffer for this service.
    //
    RequestBuffer->Key = RequestBuffer->Buffer;

    //
    // Copy the string into the request buffer.
    //
    wcscpy(RequestBuffer->Buffer,Key);

    //
    // Initialize the root directory fields.
    //
    RequestBuffer->KeyRootDirectory  = KeyRootDirectory;

    //
    // Invoke the service.
    //
    return(SpInvokeUserModeService());
}

NTSTATUS
SpQueryDirectoryObject(
    IN     HANDLE  DirectoryHandle,
    IN     BOOLEAN RestartScan,
    IN OUT PULONG  Context
    )
{
    PSERVICE_QUERY_DIRECTORY_OBJECT RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceQueryDirectoryObject;

    RequestBuffer = (PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer;

    RequestBuffer->DirectoryHandle = DirectoryHandle;
    RequestBuffer->Context = *Context;
    RequestBuffer->RestartScan = RestartScan;

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        *Context = RequestBuffer->Context;
    }

    return(Status);
}


NTSTATUS
SpFlushVirtualMemory(
    IN PVOID BaseAddress,
    IN ULONG RangeLength
    )
{
    PSERVICE_FLUSH_VIRTUAL_MEMORY RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceFlushVirtualMemory;

    RequestBuffer = (PSERVICE_FLUSH_VIRTUAL_MEMORY)&CommunicationParams->Buffer;

    RequestBuffer->BaseAddress = BaseAddress;
    RequestBuffer->RangeLength = RangeLength;

    return(SpInvokeUserModeService());
}

VOID
SpShutdownSystem(
    VOID
    )
{
    SendSetupProgressEvent(SetupCompletedEvent, ShutdownEvent, NULL);

    CommunicationParams->u.RequestNumber = SetupServiceShutdownSystem;

    SpInvokeUserModeService();

    //
    // Shouldn't get here, but just in case...
    //
    HalReturnToFirmware(HalRebootRoutine);

}

NTSTATUS
SpLoadKbdLayoutDll(
    IN  PWSTR  Directory,
    IN  PWSTR  DllName,
    OUT PVOID *TableAddress
    )
{
    PSERVICE_LOAD_KBD_LAYOUT_DLL RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceLoadKbdLayoutDll;

    RequestBuffer = (PSERVICE_LOAD_KBD_LAYOUT_DLL)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->DllName,Directory);
    SpConcatenatePaths(RequestBuffer->DllName,DllName);

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        *TableAddress = RequestBuffer->TableAddress;
    }

    return(Status);
}

NTSTATUS
SpLockUnlockVolume(
    IN HANDLE   Handle,
    IN BOOLEAN  LockVolume
    )
{
    PSERVICE_LOCK_UNLOCK_VOLUME RequestBuffer;

    CommunicationParams->u.RequestNumber = (LockVolume)? SetupServiceLockVolume :
                                                         SetupServiceUnlockVolume;

    RequestBuffer = (PSERVICE_LOCK_UNLOCK_VOLUME)&CommunicationParams->Buffer;

    RequestBuffer->Handle = Handle;

    return(SpInvokeUserModeService());
}

NTSTATUS
SpDismountVolume(
    IN HANDLE   Handle
    )
{
    PSERVICE_DISMOUNT_VOLUME RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceDismountVolume;

    RequestBuffer = (PSERVICE_DISMOUNT_VOLUME)&CommunicationParams->Buffer;

    RequestBuffer->Handle = Handle;

    return(SpInvokeUserModeService());
}


NTSTATUS
SpSetDefaultFileSecurity(
    IN PWSTR FileName
    )
{
    PSERVICE_DEFAULT_FILE_SECURITY RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceSetDefaultFileSecurity;

    RequestBuffer = (PSERVICE_DEFAULT_FILE_SECURITY)&CommunicationParams->Buffer;

    wcscpy( RequestBuffer->FileName, FileName );

    return(SpInvokeUserModeService());
}

NTSTATUS
SpVerifyFileAccess(
    IN  PWSTR       FileName,
    IN  ACCESS_MASK DesiredAccess
    )
{
    PSERVICE_VERIFY_FILE_ACCESS RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceVerifyFileAccess;

    RequestBuffer = (PSERVICE_VERIFY_FILE_ACCESS)&CommunicationParams->Buffer;

    wcscpy( RequestBuffer->FileName, FileName );
    RequestBuffer->DesiredAccess = DesiredAccess;
    return(SpInvokeUserModeService());
}

NTSTATUS
SpCreatePageFile(
    IN PWSTR FileName,
    IN ULONG MinSize,
    IN ULONG MaxSize
    )
{
    PSERVICE_CREATE_PAGEFILE RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceCreatePageFile;

    RequestBuffer = (PSERVICE_CREATE_PAGEFILE)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->FileName,FileName);
    RequestBuffer->MinSize.HighPart = 0;
    RequestBuffer->MinSize.LowPart = MinSize;
    RequestBuffer->MaxSize.HighPart = 0;
    RequestBuffer->MaxSize.LowPart = MaxSize;

    return(SpInvokeUserModeService());
}

NTSTATUS
SpGetFullPathName(
    IN OUT PWSTR FileName
    )
{
    PSERVICE_GETFULLPATHNAME RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceGetFullPathName;

    RequestBuffer = (PSERVICE_GETFULLPATHNAME)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->FileName,FileName);

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        wcscpy(FileName,RequestBuffer->NameOut);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdrmmgr.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrmmgr.c

Abstract:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.Dec.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

#define THIS_MODULE L"spdrmmgr.c"
#define THIS_MODULE_CODE  L"M"

#define DOS_DEVICES             L"\\DosDevices\\?:"
#define DOS_DEVICES_DRV_LTR_POS 12

typedef struct _NAMETABLE {
    ULONG Elements;
    PWSTR SymbolicName[1];
} NAMETABLE, *PNAMETABLE;


// Imported from sppartit.c
extern WCHAR
SpDeleteDriveLetter(IN PWSTR DeviceName);


NTSTATUS
SpAsrOpenMountManager(
    OUT HANDLE *Handle
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    INIT_OBJA(&objectAttributes, &unicodeString, MOUNTMGR_DEVICE_NAME);
    status = ZwOpenFile(Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
                );

    if (!NT_SUCCESS(status)) {
        DbgErrorMesg((_asrerr, "Could not open the mount manager (0x%x). \n", status));
        ASSERT(0 && L"Could not open mount manager");
    }
    return status;
}


VOID
SpAsrAllocateMountPointForCreate(
    IN PWSTR PartitionDeviceName,
    IN PWSTR MountPointNameString,
    OUT PMOUNTMGR_CREATE_POINT_INPUT *pMpt,
    OUT ULONG *MountPointSize
    )
{
    PMOUNTMGR_CREATE_POINT_INPUT pMountPoint = NULL;

    *pMpt = NULL;
    *MountPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
        (wcslen(PartitionDeviceName) + wcslen(MountPointNameString)) * sizeof(WCHAR);

    pMountPoint = (PMOUNTMGR_CREATE_POINT_INPUT) SpAsrMemAlloc(*MountPointSize, TRUE); // does not return on failure

    pMountPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    pMountPoint->SymbolicLinkNameLength = wcslen(MountPointNameString) * sizeof(WCHAR);
    RtlCopyMemory(((PCHAR) pMountPoint + pMountPoint->SymbolicLinkNameOffset),
        MountPointNameString,
        pMountPoint->SymbolicLinkNameLength
        );

    pMountPoint->DeviceNameLength = (USHORT) (wcslen(PartitionDeviceName) * sizeof(WCHAR));
    pMountPoint->DeviceNameOffset = (USHORT) pMountPoint->SymbolicLinkNameOffset +
        pMountPoint->SymbolicLinkNameLength;
    RtlCopyMemory(((PCHAR)pMountPoint + pMountPoint->DeviceNameOffset),
        PartitionDeviceName, 
        pMountPoint->DeviceNameLength
        );

    *pMpt = pMountPoint;
}



NTSTATUS
SpAsrCreateMountPoint(
    IN PWSTR PartitionDeviceName,
    IN PWSTR MountPointNameString
    )
/*++
Description:

    Creates the specified mount point for the specified partition region.
    These strings will usually be in the form of a symbolic names, such as:

                "\DosDevices\?:"

    Where ? can be any supported drive letter,
    or,
    a GUID string in the form of, for example:
    
                "\??\Volume{1234abcd-1234-5678-abcd-000000000000}"


Arguments:

    PartitionDeviceName    Specifies the partitioned region portion of the 
                           mount point.

    MountPointNameString   Specifies the symbolic name to be associated with
                           the specified partition.

Returns:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE handle = NULL;
    ULONG mountPointSize = 0;
    PMOUNTMGR_CREATE_POINT_INPUT pMountPoint = NULL;

    //
    // Create the input structure.
    //
    SpAsrAllocateMountPointForCreate(PartitionDeviceName,
        MountPointNameString,
        &pMountPoint,
        &mountPointSize
        );

    status = SpAsrOpenMountManager(&handle);
    if (!NT_SUCCESS(status)) {
        
        DbgFatalMesg((_asrerr, "SpAsrCreateMountPoint([%ws],[%ws]). SpAsrOpenMountManager failed (0x%x). mountPointSize:%lu handle:0x%x.\n",
            PartitionDeviceName, 
            MountPointNameString, 
            status, 
            mountPointSize, 
            handle
            ));

        SpMemFree(pMountPoint);
        //
        // There's nothing the user can do in this case. 
        //
        INTERNAL_ERROR(L"SpAsrOpenMountManager() Failed");            // ok
        // does not return
    }

    //
    // IOCTL_CREATE_POINT
    //
    status = ZwDeviceIoControlFile(handle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        IOCTL_MOUNTMGR_CREATE_POINT,
        pMountPoint,
        mountPointSize,
        NULL,
        0
        );

    if (!NT_SUCCESS(status)) {
        //
        // We couldn't restore the volume guid for this volume.  This is expected if the
        // volume is on a non-critical disk--we only recreate critical disks in textmode
        // Setup.
        //
        DbgErrorMesg((_asrwarn, "SpAsrCreateMountPoint([%ws], [%ws]). ZwDeviceIoControlFile(IOCTL_MOUNTMGR_CREATE_POINT) failed (0x%x). handle:0x%x, pMountPoint:0x%x, mountPointSize:0x%x\n",
            PartitionDeviceName,
            MountPointNameString,
            status,
            handle,
            pMountPoint,
            mountPointSize
            ));
    }

    SpMemFree(pMountPoint);
    ZwClose(handle);

    return status;
}

//////////////////////////////////////////////////////////////////////////////
//                      EXPORTED FUNCTIONS                                  //
//////////////////////////////////////////////////////////////////////////////


NTSTATUS
SpAsrSetPartitionDriveLetter(
    IN PDISK_REGION pRegion,
    IN WCHAR NewDriveLetter
    )
/*++
Description:

    Checks whether a drive letter exists for the specified partitioned region.
    If one does, then if the existing drive letter is the same as the 
    specified drive letter, return STATUS_SUCCESS.  If the existing drive 
    letter is different from that specified by the caller, delete and recreate
    the region's mount point using the symbolic name built from the drive letter
    parameter.

Arguments:

    pRegion         A pointer to a partitioned region descriptor.

    NewDriveLetter     Specifies the drive letter to be assigned to the region.

Returns:

    NTSTATUS
--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    WCHAR existingDriveLetter = 0;
    PWSTR partitionDeviceName = NULL;
    PWSTR symbolicName = NULL;

    //
    // Check input parameters:  these better be valid
    //
    if (!pRegion || !SPPT_IS_REGION_PARTITIONED(pRegion)) {
        DbgErrorMesg((_asrwarn,
            "SpAsrSetPartitionDriveLetter. Invalid Parameter, pRegion %p is NULL or not partitioned.\n",
            pRegion
            )); 
        ASSERT(0 && L"Invalid Parameter, pRegion is NULL or not partitioned."); // debug
        return STATUS_INVALID_PARAMETER;
    }

    if (NewDriveLetter < ((!IsNEC_98) ? L'C' : L'A') || NewDriveLetter > L'Z') {
        DbgErrorMesg((_asrwarn, "SpAsrSetPartitionDriveLetter. Invalid Parameter, NewDriveLetter [%wc].\n", NewDriveLetter)); 
        ASSERT(0 && L"Invalid Parameter, NewDriveLetter"); // debug
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check if the drive letter already exists
    //
    partitionDeviceName = SpAsrGetRegionName(pRegion);
    existingDriveLetter = SpGetDriveLetter(partitionDeviceName, NULL);

    if (NewDriveLetter == existingDriveLetter) {
        
        DbgStatusMesg((_asrinfo, 
            "SpAsrSetPartitionDriveLetter. Ptn [%ws] already has drv letter %wc.\n",
            partitionDeviceName, 
            NewDriveLetter
            ));

        SpMemFree(partitionDeviceName);
        return STATUS_SUCCESS;
    }

    //
    // The existing drive letter does not match.  Delete it.
    //
    if (existingDriveLetter) {
        
        DbgStatusMesg((_asrinfo,
            "SpAsrSetPartitionDriveLetter. [%ws] has driveLetter %wc, deleting.\n",
            partitionDeviceName,
            existingDriveLetter
            ));
        
        SpDeleteDriveLetter(partitionDeviceName);    
    }

    symbolicName = SpDupStringW(DOS_DEVICES);
    pRegion->DriveLetter = symbolicName[DOS_DEVICES_DRV_LTR_POS] = NewDriveLetter;
 
    //
    // Create the mount point with the correct drive letter
    //
    status = SpAsrCreateMountPoint(partitionDeviceName, symbolicName);

    if (NT_SUCCESS(status)) {
        
        DbgStatusMesg((_asrinfo,
            "SpAsrSetPartitionDriveLetter. [%ws] is drive %wc.\n",
            partitionDeviceName,
            NewDriveLetter
            ));

    }
    else  {

        DbgErrorMesg((_asrwarn, 
            "SpAsrSetPartitionDriveLetter. SpAsrCreateMountPoint([%ws],[%ws]) failed (0x%x). Drive letter %wc not assigned to [%ws].\n",
            partitionDeviceName, 
            symbolicName,
            status,
            NewDriveLetter,
            partitionDeviceName
            ));
    }

    SpMemFree(partitionDeviceName);
    SpMemFree(symbolicName);

    return status;
}


NTSTATUS
SpAsrDeleteMountPoint(IN PWSTR PartitionDevicePath)
{
    //
    // Check the DevicePath:  it better not be NULL.
    //
    if (!PartitionDevicePath) {

        DbgErrorMesg((_asrwarn,
            "SpAsrDeleteMountPoint. Invalid Parameter, ParititionDevicePath is NULL.\n"
            ));
        
        ASSERT(0 && L"Invalid Parameter, ParititionDevicePath is NULL."); // debug
        return STATUS_INVALID_PARAMETER;

    }

    DbgStatusMesg((_asrinfo, 
        "SpAsrDeleteMountPoint.  Deleting drive letter for [%ws]\n", 
        PartitionDevicePath
        ));

    SpDeleteDriveLetter(PartitionDevicePath);
    return STATUS_SUCCESS;
}


NTSTATUS
SpAsrSetVolumeGuid(
    IN PDISK_REGION pRegion,
    IN PWSTR VolumeGuid
    )
/*++

Description:
    Delete and recreate the region's mount point using the passed-in symbolic 
    name GUID parameter.

Arguments:
    pRegion         A pointer to a partitioned region descriptor.
    VolumeGuid      Specifies the GUID string to be assigned to the region.
    DeleteDriveLetter Specifies if the existing drive letter for the volume
                    should be deleted.  This should be TRUE for all volumes 
                    except the boot volume.

Returns:
    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR partitionDeviceName = NULL;

    //
    // Check input parameters
    // 
    if (!pRegion || !SPPT_IS_REGION_PARTITIONED(pRegion)) {

        DbgErrorMesg((_asrwarn,
            "SpAsrSetVolumeGuid. Invalid Param: pRegion (%p) NULL/not partitioned\n",
            pRegion
            )); 

        return STATUS_INVALID_PARAMETER;
    }

    if (!VolumeGuid || !wcslen(VolumeGuid)) {
        
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetVolumeGuid. Invalid Param: VolumeGuid (%p) NULL/blank.\n",
            VolumeGuid
            )); 

        return STATUS_INVALID_PARAMETER;
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);

    //
    // Create the mount point with the correct Guid string.  
    //
    status = SpAsrCreateMountPoint(partitionDeviceName, VolumeGuid);

    SpMemFree(partitionDeviceName);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdr.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:
    spdr.c

Abstract:
    Source file for Automated System Recovery (ASR) functions for text-mode
    setup.  The services defined in this module recreate the boot and system
    partitions based on information obtained by reading records from a 
    configuration file, the asr.sif file (aka SIF).


Terminology
    The following terms are used:

    1.  The "system" partition is the partition that contains the OS loader
    programs (i.e., On x86 platforms these are the boot.ini. ntldr, and
    ntdetect.com files, among others).

    2.  The "boot" (aka NT) partition is the partition that contains the %SystemRoot%
    directory, i.e., the directory containing the NT system files.  In the
    text-mode setup sources, this directory is also called the
    "TargetDirectory" since, when running normal textmode setup, this is the
    directory into which NT gets installed.

    3.  Extended partition and Logical Disk Terminology

    In the SIF file two kinds of extended partition records can be found.  The
    first kind, of which there may be zero, one, or more, are called Logical
    Disk Descriptor records, or LDDs.  LDDs describe a partition within an
    extended partition. The second kind are called Container Partition
    Descriptor records, or CPDs, because they describe extended partitions.
    For any disk, at most one extended partition may exist and, therefore, only
    one CPD per disk record may exist in the SIF file.


    Extended partitions and logical disk support in Windows NT 5.0:
    1) Windows NT 5.0 supports 0 or 1 extended partition per disk.
    2) Logical disks only exist within extended partitions.
    3) An extended partition may contain zero (0) or more logical disk
    partitions.


    Algorithm for Recovering the System and NT Partitions (see
    SpDrPtPrepareDisks()):
    For each disk
    {
        Check whether its capacity is sufficient to contain all the partitions
        specified in the asr.sif file for that disk (ie the partition set).

        if (Existing Physical Disk Partitions != asr.sif configuration)
        {
            - Remove disk's existing partitions;
            - Recreate disk's partitions according to the asr.sif
              specifications.
        }
        else
        {
            - Replace all corrupt boot and NT system files, excluding
              registry files.
            - Set Repaired Flag.
        }

    }

    - Reinstall NT from CDROM into NT directory specified by asr.sif.
    - If specified, copy 3rd-party files per asr.sif file.
    - Reboot and execute gui-mode disaster recover.

ASR Restrictions:
    For the boot and system volumes ASR requires that the restored (new) 
    system have:
        Same number of drives as the old system.
        Capacity of each new drive >= capacity of corresponding old drive.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.May.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop
#include <oemtypes.h>

//
// Defaults used for textmode ASR.  The static ones aren't accessed from outside
// this file, and are grouped here so that it's easy to change them if need be.
//
static PWSTR ASR_CONTEXT_KEY   = L"\\CurrentControlSet\\Control\\Session Manager\\Environment";
static PWSTR ASR_CONTEXT_VALUE = L"ASR_C_CONTEXT";
static PWSTR ASR_CONTEXT_DATA  = L"AsrInProgress";

static PWSTR ASR_BOOT_PARTITION_VALUE     = L"ASR_C_WINNT_PARTITION_DEVICE";
static PWSTR ASR_SYSTEM_PARTITION_VALUE   = L"ASR_C_SYSTEM_PARTITION_DEVICE";

static PWSTR ASR_SIF_NAME                 = L"asr.sif";
static PWSTR ASR_SIF_PATH                 = L"\\Device\\Floppy0\\asr.sif";
static PWSTR ASR_SIF_TARGET_PATH          = L"\\repair\\asr.sif";

static PWSTR ASR_SETUP_LOG_NAME           = L"setup.log";
static PWSTR ASR_DEFAULT_SETUP_LOG_PATH   = L"\\Device\\Floppy0\\Setup.log";

extern const PWSTR SIF_ASR_PARTITIONS_SECTION;
extern const PWSTR SIF_ASR_SYSTEMS_SECTION;

PWSTR ASR_FLOPPY0_DEVICE_PATH = L"\\Device\\Floppy0";
PWSTR ASR_CDROM0_DEVICE_PATH  = L"\\Device\\CdRom0";
PWSTR ASR_TEMP_DIRECTORY_PATH = L"\\TEMP";


PWSTR ASR_SIF_SYSTEM_KEY      = L"1";     // we only handle one system per sif

static PWSTR Gbl_SourceSetupLogFileName = NULL;

PWSTR Gbl_SystemPartitionName       = NULL;
PWSTR Gbl_SystemPartitionDirectory  = NULL;
PWSTR Gbl_BootPartitionName         = NULL;
PWSTR Gbl_BootPartitionDirectory    = NULL;

ULONG Gbl_FixedDiskCount = 0;

WCHAR Gbl_BootPartitionDriveLetter;

PVOID Gbl_HandleToSetupLog = NULL;
PVOID Gbl_SifHandle = NULL;

BOOLEAN Gbl_RepairWinntFast = FALSE; // Put in spdrfix.c
BOOLEAN Gbl_NtPartitionIntact = TRUE;
BOOLEAN Gbl_RepairFromErDisk = FALSE;
BOOLEAN Gbl_AsrSifOnInstallationMedia = FALSE;

ASRMODE Gbl_AsrMode = ASRMODE_NONE;

PDISK_REGION Gbl_BootPartitionRegion   = NULL;
PDISK_REGION Gbl_SystemPartitionRegion = NULL;

PSIF_PARTITION_RECORD Gbl_SystemPartitionRecord = NULL;
DWORD                 Gbl_SystemDiskIndex       = 0;

PSIF_PARTITION_RECORD Gbl_BootPartitionRecord   = NULL;
DWORD                 Gbl_BootDiskIndex         = 0;

PSIF_INSTALLFILE_LIST Gbl_3rdPartyFileList  = NULL; 
PCONFIGURATION_INFORMATION Gbl_IoDevices    = NULL;

PWSTR RemoteBootAsrSifName = NULL;


// 
// delay the driver cab opening until required 
// (while repair is being performed)
//
PWSTR gszDrvInfDeviceName = 0;
PWSTR gszDrvInfDirName = 0;
HANDLE ghSif = 0;

//
// To Enable/Disable Emergency repair
//
BOOLEAN DisableER = TRUE;


// Module identification for debug traces
#define THIS_MODULE L"    spdr.c"
#define THIS_MODULE_CODE L"A"

// Keys valid on various menu screens

#define ASCI_C 67
#define ASCI_c 99

#define ASCI_F 70
#define ASCI_f 102

#define ASCI_M 77
#define ASCI_m 109

#define ASCI_R 82
#define ASCI_r 114

// Useful macros
#define FilesystemNotApplicable ((FilesystemType) FilesystemMax)

// External functions and variables
extern BOOLEAN ForceConsole;

extern const PWSTR SIF_ASR_GPT_PARTITIONS_SECTION; 
extern const PWSTR SIF_ASR_MBR_PARTITIONS_SECTION;

extern PWSTR NtBootDevicePath;
extern PWSTR DirectoryOnBootDevice;

extern VOID SpInitializePidString(
    IN HANDLE MasterSifHandle,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice
    );

extern NTSTATUS SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName,  OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    );

extern BOOLEAN
SpPtnCreateLogicalDrive(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,
    IN  BOOLEAN       ForNT,   
    IN  BOOLEAN       AlignToCylinder,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

extern ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    );

extern ULONG
SpPtnGetContainerPartitionCount(
    IN ULONG DiskId
    );

extern NTSTATUS
SpPtnZapSectors(
    IN HANDLE DiskHandle,
    IN ULONG BytesPerSector,
    IN ULONGLONG StartSector,
    IN ULONG SectorCount
    );

extern PDISK_REGION
SpPtnLocateESP(
    VOID
    );


VOID
SpAsrInitIoDeviceCount(VOID)
/*++

Routine Description:
    Gets the IO Devices counts and updates Gbl_IoDevices. Prints out
    debug information with the deves counts.

Arguments:
    None

Return Value:
    void

Side Effect:
    Updates Gbl_IoDevices with configuration information

--*/
{
    ULONG diskIndex;
    
    Gbl_IoDevices = IoGetConfigurationInformation();

    //!!review null?

    DbgStatusMesg((_asrinfo, "----- I/O Device Configurations: -----\n"));
    DbgMesg((_asrinfo, "  SCSI ports:         %lu\n", Gbl_IoDevices->ScsiPortCount));
    DbgMesg((_asrinfo, "  Floppy disk drives: %lu\n", Gbl_IoDevices->FloppyCount));
    DbgMesg((_asrinfo, "  CDROM disk drives:  %lu\n", Gbl_IoDevices->CdRomCount));

    if (Gbl_IoDevices->TapeCount) {
        DbgMesg((_asrinfo, "  Tape drives:        %lu\n", Gbl_IoDevices->TapeCount));
    }

    if (Gbl_IoDevices->MediumChangerCount) {
        DbgMesg((_asrinfo, "  Media changers:     %lu\n", Gbl_IoDevices->MediumChangerCount));
    }
    
    DbgMesg((_asrinfo, "  Hard disk drives:   %lu\n", Gbl_IoDevices->DiskCount));

    for (diskIndex = 0; diskIndex < Gbl_IoDevices->DiskCount; diskIndex++) {
        DbgMesg((_asrinfo, "   %ws %s %ws\n", 
            (PWSTR) HardDisks[diskIndex].DevicePath,
            DISK_IS_REMOVABLE(diskIndex) ?  "(rmvable):" : "(fixed):  ",
            (PWSTR) HardDisks[diskIndex].Description));
    }
    DbgStatusMesg((_asrinfo, "----- End of I/O Device Configurations: -----\n\n"));
}    


VOID
SpAsrDbgDumpRegion(
    IN PDISK_REGION pRegion
    )
{
    UCHAR partitionType = 0;
    PWSTR partitionPath = NULL;
   
    if (!pRegion) {
         KdPrintEx((_asrinfo, "pRegion is NULL.  Cannot be examined.\n"));
        return;
    }

    if (!SPPT_IS_REGION_PARTITIONED(pRegion)) {
          KdPrintEx((_asrinfo, "[/]: non-partitioned region.\n"));
          return;
    }
    else {
        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        partitionPath = SpDupStringW(TemporaryBuffer);

        partitionType = SPPT_GET_PARTITION_TYPE(pRegion);

        KdPrintEx((_asrinfo, "[%ws]: partitioned. type:0x%x dynamicVol:%s\n",
            partitionPath,
            partitionType,
            pRegion->DynamicVolume ? "Yes" : "No"));

        SpMemFree(partitionPath);
    }

}


VOID
SpAsrDbgDumpDisk(IN ULONG Disk)
{
    PDISK_REGION primaryRegion = NULL, 
        extRegion = NULL;

    DbgMesg((_asrinfo,        
        "\n     SpAsrDbgDumpDisk. Existing regions on disk %lu (sig:0x%x):\n",
        Disk,
        SpAsrGetActualDiskSignature(Disk)
        ));

    primaryRegion = SPPT_GET_PRIMARY_DISK_REGION(Disk);
    extRegion = SPPT_GET_EXTENDED_DISK_REGION(Disk);

    if (!primaryRegion && !extRegion) {
        DbgMesg((_asrinfo, "*** No Partitions ***\n"));
        return;
    }
    
    while (primaryRegion) {
        DbgMesg((_asrinfo, "(pri) "));
        SpAsrDbgDumpRegion(primaryRegion);
        primaryRegion = primaryRegion->Next;
    }

    while (extRegion) {
        DbgMesg((_asrinfo, "(ext) "));
        SpAsrDbgDumpRegion(extRegion);
        extRegion = extRegion->Next;
    }
}


VOID
SpAsrDeletePartitions(
    IN ULONG DiskNumber,
    IN BOOLEAN PreserveInterestingPartitions,  // ESP for GPT, InterestingPartitionType for MBR
    IN UCHAR InterestingMbrPartitionType,   // see above
    OUT BOOLEAN *IsBlank // this is set FALSE if disk contains partitions that weren't deleted 
    )
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION    CurrRegion = NULL;

    BOOLEAN         Changes = FALSE;
    NTSTATUS        Status, InitStatus;
    BOOLEAN         preserveThisPartition = FALSE;

    *IsBlank = TRUE;

    DbgStatusMesg((_asrinfo, 
        "Deleting partitions on DiskNumber %lu "
        "(partition count: %lu + %lu)\n", 
        DiskNumber,
        SpPtnGetPartitionCountDisk(DiskNumber),
        SpPtnGetContainerPartitionCount(DiskNumber)
        ));

    //
    // Check if disk has any partitions 
    //
    pDisk = &PartitionedDisks[DiskNumber];
    if (!pDisk) {
        return;
    }

    // 
    // Mark partitions for deletion
    //
    CurrRegion = pDisk->PrimaryDiskRegions;
    while (CurrRegion) {
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {

            preserveThisPartition = FALSE;

            if (PreserveInterestingPartitions) {
                if (SPPT_IS_GPT_DISK(DiskNumber)) {

                    if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                        preserveThisPartition = TRUE;
                    }

                    //
                    // TODO:  OEM partitions on GPT, do we preserve them?
                    //
                }
                else {
                    // 
                    // Preserve the MBR partition, if it matches the OEM partition type
                    //
                    if ((PARTITION_ENTRY_UNUSED != InterestingMbrPartitionType) &&
                        (InterestingMbrPartitionType == SPPT_GET_PARTITION_TYPE(CurrRegion))) {

                        preserveThisPartition = TRUE;

                    }
                }
            }

            if (preserveThisPartition) {

                DbgStatusMesg((_asrinfo, "Preserving partition with start sector: %I64u\n", 
                    CurrRegion->StartSector));
                
                *IsBlank = FALSE;
                SPPT_SET_REGION_DELETED(CurrRegion, FALSE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            }
            else {
                
                DbgStatusMesg((_asrinfo, "Deleting partition with start sector: %I64u\n", 
                    CurrRegion->StartSector));

                SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                
                //
                // If this is a container partition, make sure we zero it
                //
                if (SPPT_IS_REGION_CONTAINER_PARTITION(CurrRegion)) {
                    WCHAR    DiskPath[MAX_PATH];
                    HANDLE   DiskHandle;

                    //
                    // form the name
                    //
                    DbgStatusMesg((_asrinfo, 
                        "Zapping first sector for container partition with start sector: %I64u\n", 
                        CurrRegion->StartSector
                        ));

                    swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskNumber);        
                    Status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

                    if (NT_SUCCESS(Status)) {
                        SpPtnZapSectors(DiskHandle, SPPT_DISK_SECTOR_SIZE(DiskNumber), CurrRegion->StartSector, 2);
                        ZwClose(DiskHandle);
                    }
                    else {
                        DbgStatusMesg((_asrinfo, 
                            "Could not open handle to disk %lu to zap sector: %I64u (0x%x)\n", 
                            DiskNumber,
                            CurrRegion->StartSector,
                            Status
                            ));
                    }
                }

                //
                // Remove any boot sets pointing to this region.
                //
                SpPtDeleteBootSetsForRegion(CurrRegion);

                //
                //  Get rid of the compressed drives, if any
                //
                if (CurrRegion->NextCompressed != NULL) {
                    SpDisposeCompressedDrives(CurrRegion->NextCompressed);
                    CurrRegion->NextCompressed = NULL;
                    CurrRegion->MountDrive = 0;
                    CurrRegion->HostDrive = 0;
                }
            }
        }

        CurrRegion = CurrRegion->Next;
    }

    //
    // Commit the changes
    //
    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Initialize region structure for the disk again
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(Status) || !Changes || !NT_SUCCESS(InitStatus)) {

        DbgFatalMesg((_asrerr,
            "Could not successfully delete partitions on disk %lu (0x%x)",
            DiskNumber,
            Status
            ));

        //
        // If this is going to be a serious problem, we will hit a fatal error 
        // when we try to create partitions on this disk.  Let's defer
        // any UI error messages till then.
        //

    }
    else {
        DbgStatusMesg((_asrinfo, "Deleted all partitions on disk %lu.\n", DiskNumber));
    }
}


BOOLEAN
SpAsrProcessSetupLogFile(
    PWSTR FullLogFileName,
    BOOLEAN AllowRetry
    )
{

    PDISK_REGION region = NULL;
    BOOLEAN result = FALSE;

    DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. (ER) Loading setup log file [%ws]\n", FullLogFileName));

    result = SpLoadRepairLogFile(FullLogFileName, &Gbl_HandleToSetupLog);

    if (!result) {

        if (AllowRetry) {
            
            DbgErrorMesg((_asrwarn, 
                "ProcessSetupLogFile. Error loading setup log file [%ws]. AllowRetry:TRUE. continuing.\n", 
                FullLogFileName));
            
            return FALSE;
        
        } 
        else {
            
            DbgFatalMesg((_asrerr, "ProcessSetupLogFile. Error loading setup log file [%ws]. AllowRetry:FALSE. Terminating.\n", 
                FullLogFileName));

            SpAsrRaiseFatalError(SP_TEXT_DR_NO_SETUPLOG,  L"Setup.log file not loaded successfully");
        }

    }

    //
    // Determine the system partition, system partition directory, NT partition,
    // and the NT partition directory from the setup.log file.
    //
    SppGetRepairPathInformation(Gbl_HandleToSetupLog,
        &Gbl_SystemPartitionName,
        &Gbl_SystemPartitionDirectory,
        &Gbl_BootPartitionName,
        &Gbl_BootPartitionDirectory);

    if (!(Gbl_SystemPartitionName && Gbl_SystemPartitionDirectory 
        && Gbl_BootPartitionName && Gbl_BootPartitionDirectory)) {

        DbgFatalMesg((_asrerr, 
            "ProcessSetupLogFile. Invalid NULL value in one of the following: \n"
            ));
        
        DbgMesg((_asrinfo, 
            "\tGbl_SystemPartitionName: %p      Gbl_SystemPartitionDirectory: %p\n",
            Gbl_SystemPartitionName,
            Gbl_SystemPartitionDirectory
            ));

        DbgMesg((_asrinfo, 
            "\tGbl_BootPartitionName:  %p      Gbl_BootPartitionDirectory:  %p\n",
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory
            ));

        SpAsrRaiseFatalError(SP_TEXT_DR_BAD_SETUPLOG, L"One or more directory and partition names from setup.log were NULL.");

    }
            
    //
    // Check whether the system and nt partition regions exist on this machine
    //
    Gbl_SystemPartitionRegion = SpRegionFromNtName(Gbl_SystemPartitionName, PartitionOrdinalCurrent);
    if (!Gbl_SystemPartitionRegion) {
        DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. System partition [%ws] does not yet exist\n", Gbl_SystemPartitionName));
    }

    Gbl_BootPartitionRegion = SpRegionFromNtName(Gbl_BootPartitionName, PartitionOrdinalCurrent);
    if (!Gbl_BootPartitionRegion) {
        DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. Boot partition [%ws] does not yet exist\n", Gbl_BootPartitionName));
    }

    DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. (ER) DONE loading setup log file [%ws]\n", 
        FullLogFileName));

    return TRUE;
}


BOOLEAN
SpAsrRegionCanBeFormatted(IN PDISK_REGION pRegion)
{
    UCHAR partitionType = 0x0;
    BOOLEAN canBeFormatted = FALSE;

    partitionType = SPPT_GET_PARTITION_TYPE(pRegion);

    switch (partitionType) {
        case PARTITION_HUGE:
        case PARTITION_FAT32:
        case PARTITION_IFS:
            canBeFormatted = TRUE;
            break;
    }

    return canBeFormatted;
}


FilesystemType
SpAsrGetFsTypeFromPartitionType(
    IN UCHAR PartitionType
    )
{
    FilesystemType fileSystemType = FilesystemUnknown;

    // if this is an extended partition, or logical disk, skip it.
    if (IsContainerPartition(PartitionType)) {
        return FilesystemNotApplicable;
    }

    if (IsRecognizedFatPartition(PartitionType)) {
        fileSystemType = FilesystemFat;
    } 
    else if (IsRecognizedFat32Partition(PartitionType)) {
        fileSystemType = FilesystemFat32;
    } 
    else if (IsRecognizedNtfsPartition(PartitionType)) {
        fileSystemType = FilesystemNtfs;
    } 
    else {
        fileSystemType = FilesystemUnknown;
    }
    return fileSystemType;
}


BOOLEAN
SpAsrPartitionNeedsFormatting(
    IN PDISK_REGION pRegion,
    IN UCHAR NewFileSystemType
    )
/*++

  Description:
    This routine is only called when checking whether an existing partition
    needs to be [re]formatted.

--*/
{
    BOOLEAN needsFormatting = FALSE;
    FilesystemType fsType;

    ASSERT(pRegion);

//    if (!SpAsrRegionCanBeFormatted(pRegion)) {
//        return FALSE;
//    }

//    *NewFilesystemType = SpAsrGetFsTypeFromPartitionType(RequiredSysId);

    fsType = SpIdentifyFileSystem(HardDisks[pRegion->DiskNumber].DevicePath,
                                  HardDisks[pRegion->DiskNumber].Geometry.BytesPerSector,
                                  SpPtGetOrdinal(pRegion,PartitionOrdinalCurrent));

    switch (fsType) {

    case FilesystemFat:
        if (!IsRecognizedFatPartition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;

    case FilesystemNtfs:
        if (!IsRecognizedNtfsPartition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;
    
    case FilesystemFat32: 
        if (!IsRecognizedFat32Partition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;

    case FilesystemDoubleSpace:
        needsFormatting = FALSE;
        break;
    
    case FilesystemUnknown:
    case FilesystemNewlyCreated:
    default: 
        needsFormatting = TRUE;
        break;
    }

    DbgStatusMesg((_asrinfo, "SpAsrPartitionNeedsFormatting. DiskRegion %p Disk:%lu SS:%I64u SC:%I64u fsType:0x%x NewFsType:0x%x NeedsFmt:%s\n",
        pRegion,
        pRegion->DiskNumber, 
        pRegion->StartSector, 
        pRegion->SectorCount, 
        fsType, 
        NewFileSystemType, 
        needsFormatting ? "TRUE" : "FALSE"));

    return needsFormatting;
}


//
// Called only for boot and system partitions.
//
BOOLEAN
SpAsrReformatPartition(
    IN PDISK_REGION pRegion,
    IN UCHAR PartitionType,
    IN PVOID SifHandle,
    IN DWORD ClusterSize,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN BOOL  IsBootPartition        // TRUE=>Boot, FALSE=>System
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR partitionDeviceName = NULL;
    FilesystemType Filesystem;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle = NULL;

    WCHAR formatStr[6];     // okay to hardcode "6".

    //
    // For the recognised partitions, ensure that the partition type matches the 
    // filesystem type.  For other partitions, we cannot perform this check.
    //
    switch (PartitionType) {

    case PARTITION_FAT32: {
        wcscpy(formatStr, L"FAT32");
        Filesystem = FilesystemFat32;
        break;
    }

    case PARTITION_HUGE: {
        wcscpy(formatStr, L"FAT");
        Filesystem = FilesystemFat;
        break;
    }

    case PARTITION_IFS: {
        wcscpy(formatStr, L"NTFS");
        Filesystem = FilesystemNtfs;
        break;
    }

    default: {
        //
        //  This is fatal, we need to format the boot and system drive.
        //
        DbgErrorMesg((_asrerr, 
            "Region %p, Partition Type 0x%x, SifHandle %p, SetupSrc [%ws], Dir [%ws], IsBoot %d\n", 
            pRegion, PartitionType, SifHandle, Local_SetupSourceDevicePath, 
            Local_DirectoryOnSetupSource, IsBootPartition
            ));

        ASSERT(0 && "Cannot format boot or system partition");

        swprintf(TemporaryBuffer, L"Partition type 0x%x for %s partition is not recognised\n", 
            PartitionType,
            (IsBootPartition ? "boot" : "system")
            );

        SpAsrRaiseFatalError(
            (IsBootPartition ? SP_TEXT_DR_UNKNOWN_NT_FILESYSTEM : SP_TEXT_DR_UNKNOWN_LOADER_FILESYSTEM), 
            TemporaryBuffer
            );
    }
    }

    if (SPPT_IS_MBR_DISK(pRegion->DiskNumber)) {
        //
        // This should only be set for MBR disks
        //
        SPPT_SET_PARTITION_TYPE(pRegion, PartitionType);
    }
    partitionDeviceName = SpAsrGetRegionName(pRegion);

    DbgStatusMesg((_asrinfo, "About to format [%ws] for [%ws].\n", partitionDeviceName, formatStr));

    //
    // If automated ASR tests are in progress, we won't actually format the drives
    //
    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        DbgStatusMesg((_asrerr, "ASR Quick Tests in Progress, skipping format\n"));
        status = STATUS_SUCCESS;

    }
    else {
        status = SpDoFormat(partitionDeviceName,
            pRegion,
            Filesystem,
            TRUE,                       // IsFailureFatal
            FALSE,                      // Check FAT Size, FALSE since we automatically convert if needed
#ifdef PRERELEASE
            TRUE,                       // To reduce testing time, we can quick format in pre-release
#else
            FALSE,                      // Quick Format
#endif
            SifHandle,
            ClusterSize,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource
            );
    }

    //
    // Won't get here if SpDoFormat failed, we set IsFailureFatal = TRUE.
    //
    ASSERT(NT_SUCCESS(status) && L"SpDoFormat returned on failure");

    //
    // To make sure the file system mounts, we'll open a handle to the 
    // partition and close it right back. 
    //
    INIT_OBJA(&Obja, &UnicodeString, partitionDeviceName);

    status = ZwCreateFile(
        &Handle,
        FILE_GENERIC_READ,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    ZwClose(Handle);
    ASSERT(NT_SUCCESS(status) && L"Couldn't open the partition after formatting it");

    DbgStatusMesg((_asrinfo, "ReformatPartition. Done [%ws] for [%ws].\n", partitionDeviceName, formatStr));
    SpMemFree(partitionDeviceName);
    
    return TRUE;
}


VOID
SpAsrRemoveDiskMountPoints(IN ULONG Disk)
/*++

Description:
    For each partition on the specified disk, its drive letter (if 
    present) is removed.

Arguments:
    Disk    Specifies the disk containing the partitions whose drive letters 
            are to be removed.

Returns:
    None

  --*/
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION pDiskRegion = NULL;
    PWSTR partitionPath = NULL;
    UCHAR partitionType = 0;
    
    pDisk = &PartitionedDisks[Disk];

 
    DbgStatusMesg((_asrinfo, "SpAsrRemoveDiskMountPoints. Removing mount points for Disk %lu.\n", Disk));

    //
    // We first delete the primary partitions (other than the container partition)
    //
    pDiskRegion = pDisk->PrimaryDiskRegions;
    while (pDiskRegion) {

        if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
            //
            //  We don't want to delete the container partition yet
            //
            partitionType = SPPT_GET_PARTITION_TYPE(pDiskRegion);
            if (!IsContainerPartition(partitionType)) {

                partitionPath = SpAsrGetRegionName(pDiskRegion);
                SpAsrDeleteMountPoint(partitionPath);
                SpMemFree(partitionPath);

            }
        }

        pDiskRegion = pDiskRegion->Next;
    }
    
    // 
    // Next, delete the extended region mount points
    //
    pDiskRegion = pDisk->ExtendedDiskRegions;
    while (pDiskRegion) {

        if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {

            partitionPath = SpAsrGetRegionName(pDiskRegion);
            SpAsrDeleteMountPoint(partitionPath);
            SpMemFree(partitionPath);

        }

        pDiskRegion = pDiskRegion->Next;
    }
}


VOID
SpAsrRemoveMountPoints(VOID)
{
    ULONG driveCount;
    
    // remove the mount points associated with all removable disk drives (Jaz, Zip, etc.,)
    for (driveCount = 0; driveCount < Gbl_IoDevices->DiskCount; driveCount++) {
        if (DISK_IS_REMOVABLE(driveCount)) {
            swprintf(TemporaryBuffer, L"%ws\\Partition1", (PWSTR) HardDisks[driveCount].DevicePath);
            SpAsrDeleteMountPoint(TemporaryBuffer);
        }
    }

    // next, unlink CD-ROM drive letters.
    // NB: the device name is case sensitive - Must be CdRom.
    for (driveCount = 0; driveCount < Gbl_IoDevices->CdRomCount; driveCount++) {
        swprintf(TemporaryBuffer, L"\\Device\\CdRom%u", driveCount);
        SpAsrDeleteMountPoint(TemporaryBuffer);
    }
    
    // finally, remove the mount points for all partitions on all fixed
    // disks attached to the system.
    for (driveCount = 0; driveCount < HardDiskCount; driveCount++) {
        if (Gbl_PartitionSetTable2[driveCount]) {
            SpAsrRemoveDiskMountPoints(driveCount);
        }
    }
}


VOID
SpAsrSetRegionMountPoint(
    IN PDISK_REGION pRegion,
    IN PSIF_PARTITION_RECORD pRec
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR partitionDeviceName = NULL;
    BOOLEAN isBoot = FALSE;

    //
    // Make sure that the input's okay ...
    //
    if (!pRec) {
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetRegionMountPoint. Rec %p is NULL!\n",
	        pRec
            ));
        return;
    }

    if (!pRegion || !(SPPT_IS_REGION_PARTITIONED(pRegion))) {
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetRegionMountPoint. Region %p is NULL/unpartitioned for ptn-rec:[%ws].\n",
	        pRegion, pRec->CurrPartKey
            ));
        return;
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);

    //
    // If this is the boot volume, set the drive letter
    //
    isBoot = SpAsrIsBootPartitionRecord(pRec->PartitionFlag);
    if (isBoot) {

        DbgStatusMesg((_asrinfo, "Setting [%ws] boot drive-letter to [%wc]\n", 
            partitionDeviceName, 
            Gbl_BootPartitionDriveLetter
            ));

        status = SpAsrSetPartitionDriveLetter(pRegion, Gbl_BootPartitionDriveLetter);

        if (!NT_SUCCESS(status)) {
        
            DbgErrorMesg((_asrwarn, "SpAsrSetRegionMountPoint. SpAsrSetPartitionDriveLetter failed for boot-drive. boot-ptn:[%ws], ptn-rec:[%ws]. (0x%x)\n",
                partitionDeviceName,
                pRec->CurrPartKey,
                status
                ));
        }
    }

    //
    // And if the volume guid is present, set the volume guid
    //
    if ((pRec->VolumeGuid) && (wcslen(pRec->VolumeGuid) > 0)) {
        
        DbgStatusMesg((_asrinfo, 
            "SpAsrSetRegionMountPoint. Setting [%ws] guid to [%ws]\n", 
            partitionDeviceName, pRec->VolumeGuid 
            ));
    
        status = SpAsrSetVolumeGuid(pRegion, pRec->VolumeGuid);

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn, 
                "SpAsrSetRegionMountPoint. SpAsrSetVolumeGuid failed. device:[%ws], ptn-rec:[%ws]. (0x%x)\n",
                partitionDeviceName, pRec->CurrPartKey, status
                ));

        }
    }

    SpMemFree(partitionDeviceName);            
}


VOID
SpAsrRestoreDiskMountPoints(IN ULONG DiskIndex)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    PDISK_REGION pRegion = NULL;
    
    //
    // Make sure there is a partition list for the disk
    //
    if (Gbl_PartitionSetTable2[DiskIndex] == NULL ||
        Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord == NULL ||
        Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord->PartitionList == NULL) {
        return;
    }

    //
    // Go through the paritions and set their mount points.  This will also 
    // set the drive letter for the boot volume.  (We have to set it now
    // since we can't change it in GUI-mode Setup)
    //
    pRec = Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord->PartitionList->First;

    while (pRec) {

        pRegion = SpAsrDiskPartitionExists(DiskIndex, pRec);
        if (!pRegion) {
            //
            // We don't expect to find the regions for the non-critical disks.
            //
            DbgErrorMesg((_asrwarn, 
                "RestoreDiskMountPoints: Disk region not found, physical-disk %lu, ptn-rec-key %ws.\n",
                DiskIndex,
                pRec->CurrPartKey
                ));

        }
        else {

            SpAsrSetRegionMountPoint(pRegion, pRec);
        }

        pRec = pRec->Next;
    }
}


VOID
SpAsrUpdatePartitionRecord(
    IN ULONG Disk,
    IN ULONGLONG NewStartSector,
    IN ULONGLONG PrevStartSector,
    IN ULONGLONG NewSectorCount
    )
{
    PSIF_PARTITION_RECORD pRecNew = NULL;

    //
    // Update the partition record whose disk and partition start sector
    // match that of the Disk and PrevStartSector parameters.
    //
    pRecNew = Gbl_PartitionSetTable2[Disk]->pDiskRecord->PartitionList->First;
    while (pRecNew) {
        if (pRecNew->StartSector == PrevStartSector) {
            pRecNew->StartSector = NewStartSector;
            pRecNew->SectorCount = NewSectorCount;
            break;
        }
        pRecNew = pRecNew->Next;
    }      
}    


VOID
SpAsrGetFirstFreespace(
    IN ULONG DiskNumber,
    IN BOOLEAN IsAPrimaryPartition,
    OUT ULONGLONG *StartSector,
    OUT ULONGLONG *FreeSectors,
    OUT ULONGLONG *SizeMbFree,
    IN CONST ULONGLONG MinimumSectorCount
    )
{
    PDISK_REGION pRegion = NULL;
    ULONG NumPartitions = 0;

    BOOLEAN extendedExists;

    *StartSector = 0;
    *FreeSectors = 0;
    *SizeMbFree = 0;

    NumPartitions = SpPtnGetPartitionCountDisk(DiskNumber) 
        + SpPtnGetContainerPartitionCount(DiskNumber);

    DbgStatusMesg((_asrinfo, 
        "SpAsrGetFirstFreespace. Dsk %lu. PartitionCount= %lu\n",
        DiskNumber, 
        NumPartitions
        ));

    pRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if (0 == NumPartitions) {

        if (pRegion) {
            *StartSector = pRegion->StartSector;
            *FreeSectors = pRegion->SectorCount;
            if ((*FreeSectors) < MinimumSectorCount) {
                *FreeSectors = 0;
            }

            *SizeMbFree =  SpAsrConvertSectorsToMB(*FreeSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
            return;
        }
        else {
            //
            // We have the whole disk at our disposal.
            //
            *FreeSectors = SpAsrGetTrueDiskSectorCount(DiskNumber);
            if ((*FreeSectors) < MinimumSectorCount) {
                *FreeSectors = 0;
            }

            *SizeMbFree = SpAsrConvertSectorsToMB(*FreeSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
            *StartSector = 0;

            return;
        }
    }


    while (pRegion) {
        DbgStatusMesg((_asrinfo, 
            "SpAsrGetFirstFreespace: MinSC: %I64u. Dsk %lu. Region: %p SS %I64u, SC %I64u, %spartitioned, %sfree-space \n",
            MinimumSectorCount,
            DiskNumber,
            pRegion,
            pRegion->StartSector,
            pRegion->SectorCount,
            (SPPT_IS_REGION_PARTITIONED(pRegion) ? "" : "non-"),
            (SPPT_IS_REGION_FREESPACE(pRegion) ? "IS " : "not ")
            ));

        if (SPPT_IS_REGION_FREESPACE(pRegion)) {
            ULONGLONG AvailableSectors = 0;
            BOOLEAN Found = (IsAPrimaryPartition ? 
                (!SPPT_IS_REGION_CONTAINER_PARTITION(pRegion) && !SPPT_IS_REGION_INSIDE_CONTAINER(pRegion)) : 
                (SPPT_IS_REGION_INSIDE_CONTAINER(pRegion))
                );

            AvailableSectors = pRegion->SectorCount;
            //
            // If we're trying to create a logical drive, we need to take into account that
            // the size of the Free region is not fully available to us for use--the first 
            // track will be used for the EBR.  So we must subtract out the first track
            // from the AvailableSectors.  
            //
            if (!IsAPrimaryPartition) {
                AvailableSectors -= SPPT_DISK_TRACK_SIZE(DiskNumber);
            }

            DbgStatusMesg((_asrinfo, 
                "SpAsrGetFirstFreespace: For this region %p, AvailableSectors:%I64u, Found is %s kind of free space)\n",
                pRegion,
                AvailableSectors,
                (Found ? "TRUE. (right" : "FALSE (wrong")
                ));

            if ((Found) && (pRegion->StartSector > 0) && (AvailableSectors >= MinimumSectorCount)) {
                *StartSector = pRegion->StartSector;
                *FreeSectors = AvailableSectors;
                *SizeMbFree =  SpAsrConvertSectorsToMB(AvailableSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
                return;
            }
        }
        pRegion = pRegion->Next;
    }
}


VOID
SpAsrRecreatePartition(
    IN PSIF_PARTITION_RECORD pRec,
    IN ULONG DiskNumber,
    IN CONST BOOLEAN IsAligned
    )
{
    NTSTATUS status     = STATUS_SUCCESS;
    
    BOOLEAN diskChanged = FALSE, 
            result      = FALSE;

    ULONGLONG sizeMbFree    = 0,
            freeSectors     = 0,
            oldStartSector  = 0,
            oldSectorCount  = 0,
            alignedSector   = 0;

    WCHAR    DiskPath[MAX_PATH];
    HANDLE   DiskHandle = NULL;

    PDISK_REGION pRegion    = NULL;
    PARTITION_INFORMATION_EX PartInfo;

    DbgStatusMesg((_asrinfo, 
        "Recreating Ptn %p [%ws] (%s, SS %I64u, SC %I64u type 0x%x)\n",
        pRec,
        pRec->CurrPartKey,
        pRec->IsPrimaryRecord ? "Pri" : 
            pRec->IsContainerRecord ? "Con" :
            pRec->IsLogicalDiskRecord ? "Log" :
            pRec->IsDescriptorRecord ? "Des" :"ERR",
        pRec->StartSector,
        pRec->SectorCount,
        pRec->PartitionType
        ));

    //
    // Get needed parameters (start sector and remaining free space) from the
    // first unpartitioned region on the disk.
    //
    SpAsrGetFirstFreespace(DiskNumber,
        (pRec->IsPrimaryRecord || pRec->IsContainerRecord),
        &pRec->StartSector,
        &freeSectors,   // Sector count of this free space
        &sizeMbFree,
        pRec->SectorCount
        );

    //
    // We fail if the number of free sectors are less than the number 
    // of sectors required to create the partition.  
    //
    if (!freeSectors) {

        DbgFatalMesg((_asrerr, 
            "Ptn-record [%ws]: Disk %lu. reqSec %I64u > available sectors\n",
            pRec->CurrPartKey,
            DiskNumber,
            pRec->SectorCount
            ));
        
         SpAsrRaiseFatalError(
            SP_TEXT_DR_INSUFFICIENT_CAPACITY,
            L"Not enough free space left to create partition"
            );
    }

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, BYTES_PER_SECTOR(DiskNumber));

    //
    // Check if this is an LDM partition on the boot/sys disk.  If so,
    // all the 0x42 partitions on that disk need to be retyped to a basic
    // type (6, 7 or B).  This is to prevent LDM from getting confused on
    // reboot.  At the end of GUI-Setup, asr_ldm will do the needful to 
    // reset the partition types as needed.
    //
    if (pRec->NeedsLdmRetype) {

        if (PARTITION_STYLE_MBR == pRec->PartitionStyle) {
            if (!IsRecognizedPartition(pRec->FileSystemType)) {
                //
                // This is an 0x42 partition on the boot/sys disk, but it is
                // not the boot or system partition.  The FileSystemType is not
                // recognised since it  is set to be 0x42 as well.  (The 
                // FileSystemType is only valid for the boot and system 
                // partitions--for all other partitions,
                // it is set to be the same as the PartitionType)
                //
                // We set it to 0x7 for the time being.  The actual file-system type
                // will be set later in GUI-Setup by asr_ldm and asr_fmt.
                //
                DbgStatusMesg((_asrinfo, 
                    "MBR ptn-rec %ws re-typed (0x%x->0x7) \n", 
                    pRec->CurrPartKey, pRec->FileSystemType));
                pRec->FileSystemType = PARTITION_IFS;
                pRec->PartitionType = PARTITION_IFS;
            }
            else {
                DbgStatusMesg((_asrinfo, 
                    "MBR ptn-rec %ws re-typed (0x%x->0x%x).\n", 
                    pRec->CurrPartKey, pRec->PartitionType, 
                    pRec->FileSystemType));
                pRec->PartitionType = pRec->FileSystemType;
            }
        }
        else if (PARTITION_STYLE_GPT == pRec->PartitionStyle) {

            DbgStatusMesg((_asrinfo, 
                "GPT ptn-rec %ws re-typed (%ws to basic).\n", 
                pRec->CurrPartKey, pRec->PartitionTypeGuid));

            CopyMemory(&(pRec->PartitionTypeGuid), 
                &PARTITION_BASIC_DATA_GUID, sizeof(GUID));

        }
        else {
            ASSERT(0 && L"Unrecognised partition style");
        }
    }

    RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));

    //
    // Fill out the PARTITION_INFORMATION_EX structure that SpPtnCreate uses
    //
    PartInfo.PartitionStyle = pRec->PartitionStyle;

    if (PARTITION_STYLE_MBR == pRec->PartitionStyle) {
        PartInfo.Mbr.PartitionType = pRec->PartitionType;
        PartInfo.Mbr.BootIndicator =
                SpAsrIsSystemPartitionRecord(pRec->PartitionFlag);
    }
    else if (PARTITION_STYLE_GPT == pRec->PartitionStyle) {
        CopyMemory(&(PartInfo.Gpt.PartitionType), &(pRec->PartitionTypeGuid), 
            sizeof(GUID));
        CopyMemory(&(PartInfo.Gpt.PartitionId), &(pRec->PartitionIdGuid), 
            sizeof(GUID));
        PartInfo.Gpt.Attributes = pRec->GptAttributes;
        wcscpy(PartInfo.Gpt.Name, pRec->PartitionName);
    }
    else {
        //
        // Unrecognised disk layout?
        //
        return;
    }

    DbgStatusMesg((_asrinfo, 
        "Recreating Ptn [%ws] (%s, Adjusted SS %I64u, type 0x%x)\n",
        pRec->CurrPartKey, pRec->IsPrimaryRecord ? "Pri" : 
            pRec->IsContainerRecord ? "Con" :
            pRec->IsLogicalDiskRecord ? "Log" :
            pRec->IsDescriptorRecord ? "Des" :"ERR",
        pRec->StartSector, pRec->PartitionType));

    //
    // Before creating the partition, let's zero out the first few
    // sectors in that partition, so that we forcibly nuke any 
    // stale file-system or other information present
    //
    DbgStatusMesg((_asrinfo, 
        "Zeroing 2 sectors starting with sector: %I64u\n",pRec->StartSector));

    swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskNumber);        
    status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

    if (NT_SUCCESS(status)) {
        
        status = SpPtnZapSectors(DiskHandle, 
            SPPT_DISK_SECTOR_SIZE(DiskNumber),
            pRec->StartSector, 
            2);

        if (!NT_SUCCESS(status)) {
            DbgStatusMesg((_asrwarn, 
                "Could not zero sector %I64u on disk %lu (0x%x)\n", 
                pRec->StartSector, DiskNumber, status));
        }

        //
        // If the first partition we're creating is a container partition,
        // SpPtnCreate will align it to a cylinder boundary.  The problem
        // is that since we haven't zero'ed that sector (at the first
        // cylinder boundary), it may contain some stale EBR info, and we will
        // end up thinking that that EBR is valid.
        // 
        // So if this is a container partition, let's do one additional 
        // thing--check what the cylinder aligned boundary will be, and
        // zero that out if needed.
        //
        if (IsAligned && pRec->IsContainerRecord) {
            alignedSector = SpPtAlignStart(SPPT_GET_HARDDISK(DiskNumber), pRec->StartSector, TRUE);

            if (alignedSector != pRec->StartSector) {
                status = SpPtnZapSectors(DiskHandle, 
                    SPPT_DISK_SECTOR_SIZE(DiskNumber),
                    alignedSector,                
                    2);
                if (!NT_SUCCESS(status)) {
                    DbgStatusMesg((_asrwarn, 
                        "Could not zero aligned-sector %I64u on disk %lu (0x%x)\n", 
                        alignedSector, DiskNumber, status));
                }
            }
        }

        ZwClose(DiskHandle);
    }
    else {
        DbgStatusMesg((_asrwarn, 
            "Could not open handle to disk %lu to zap sector: %I64u (0x%x)\n", 
            DiskNumber,
            pRec->StartSector,
            status
            ));
    }

    //
    // Create this partition on disk.  If we aren't successful, we treat it as a fatal error.
    //
    if (pRec->IsLogicalDiskRecord) {
        //
        // For logical disks, we need to call SpPtnCreateLogicalDrive, which
        // will take care of creating the descriptor records as needed.
        //
        result = SpPtnCreateLogicalDrive(
            DiskNumber,
            pRec->StartSector,
            pRec->SectorCount,
            TRUE,
            IsAligned,
            pRec->SizeMB,
            &PartInfo,
            &pRegion
            );

    }
    else {
        //
        // If this is a container partition, make sure we zero the
        // first sector of the partition before creating it
        //
        result = SpPtnCreate(
            DiskNumber,
            pRec->StartSector,
            pRec->SectorCount,
            pRec->SizeMB,
            IsContainerPartition(pRec->PartitionType),
            IsAligned,
            &PartInfo,
            &pRegion
            );

    }

    if (!result) {

        DbgFatalMesg((_asrerr, "SpPtnCreate failed for ptn-rec %ws at %p (Disk %lu, SS %I64u, Size %I64u)\n",
            pRec->CurrPartKey,
            pRec,
            DiskNumber,
            pRec->StartSector,
            pRec->SizeMB
            ));
        
        SpAsrRaiseFatalError(
            SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION,
            TemporaryBuffer
            );

        // does not return
    }


    if (pRec->NeedsLdmRetype) {

        pRec->NeedsLdmRetype = FALSE;
        pRegion->DynamicVolume = TRUE;
        pRegion->DynamicVolumeSuitableForOS = TRUE;

    }
    
    SpUpdateDoubleSpaceIni();

    //
    // If the new disk geometry is different, the start sector and sector count 
    // of the newly created region wil be different from the old values.
    //
    if ((pRec->StartSector != pRegion->StartSector) ||
        (pRec->SectorCount != pRegion->SectorCount)) {

        pRec->StartSector = pRegion->StartSector;
        pRec->SectorCount = pRegion->SectorCount;
    }

    DbgStatusMesg((_asrinfo, "Created %ws at sector %I64u for key [%ws], type 0x%x, region %p.\n",
        pRec->IsPrimaryRecord ? L"primary partition" : 
            pRec->IsContainerRecord ? L"container partition" :
            pRec->IsLogicalDiskRecord ? L"logical disk partition" : L"LDM Partition",
        pRegion->StartSector,
        pRec->CurrPartKey,
        pRec->PartitionType,
        pRegion
        ));
}


ULONGLONG
RoundUp(
    IN ULONGLONG Number,
    IN ULONG MultipleOf
    )
{
    if (Number % MultipleOf) {
        return (Number + (ULONGLONG) MultipleOf - (Number % (ULONGLONG) MultipleOf));

    }
    else {
        return Number;
    }
}


BOOLEAN
SpAsrRecreateDiskPartitions(
    IN ULONG Disk,
    IN BOOLEAN SkipSpecialPartitions,  // OEM partitions for x86, ESP for ia64
    IN UCHAR MbrOemPartitionType
    )
{
    ULONGLONG oldStartSector = 0,
        oldSectorCount = 0;
    PSIF_PARTITION_RECORD pRec = NULL;
    PSIF_PARTITION_RECORD_LIST pList = NULL;

    SIF_PARTITION_RECORD_LIST logicalDiskList;
    SIF_PARTITION_RECORD_LIST primaryPartList;
    ULONG count = 0,
        SectorsPerCylinder = 0;

    BOOLEAN isAligned = TRUE;
    BOOLEAN moveToNext = TRUE;

    ZeroMemory(&logicalDiskList, sizeof(SIF_PARTITION_RECORD_LIST));
    ZeroMemory(&primaryPartList, sizeof(SIF_PARTITION_RECORD_LIST));

    SectorsPerCylinder = HardDisks[Disk].SectorsPerCylinder;

    if (!Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList) {
        //
        // No partitions to recreate
        //
        return TRUE;
    }

    //
    // Split the partitions into two lists, one containing
    // just the primary partitions, and the second containing
    // the logical drives.  The primary partition list will
    // also include the container record if any.
    //
//    pList = SpAsrCopyPartitionRecordList(Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList);

    pList = Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList;
    ASSERT(pList);

    isAligned = Gbl_PartitionSetTable1[Disk]->IsAligned;

    pRec = SpAsrPopNextPartitionRecord(pList);
    while (pRec) {
        if (pRec->IsPrimaryRecord || pRec->IsContainerRecord) {
            //
            // Primary records go into the primaryPartList
            //
            if (SkipSpecialPartitions) {
                if ((PARTITION_STYLE_MBR == pRec->PartitionStyle) &&
                    (MbrOemPartitionType == pRec->PartitionType)) {
                    //
                    // This is an OEM partition that already exists on the 
                    // target machine.  Discard this record.
                    //
                    SpMemFree(pRec);
                    pRec = NULL;
                }
                else if ((PARTITION_STYLE_GPT == pRec->PartitionStyle) &&
                    (RtlEqualMemory(&(pRec->PartitionTypeGuid), &PARTITION_SYSTEM_GUID, sizeof(GUID)))
                    ) {
                    //
                    // This is the EFI System Partition, and it already 
                    // exists on the taget machine.  Discard this 
                    // record.
                    //
                    SpMemFree(pRec);
                    pRec = NULL;
                }
            }

            if (pRec) {
                SpAsrInsertPartitionRecord(&primaryPartList, pRec);
            }
        }
        else if (pRec->IsLogicalDiskRecord) {
            //
            // LogicalDiskRecords go into the logicalDisklist
            //
            SpAsrInsertPartitionRecord(&logicalDiskList, pRec);
        }
        else if (pRec->IsDescriptorRecord) {
            //
            // Discard the descriptor records 
            //
            SpMemFree(pRec);
        }
        else {
            ASSERT(0 && L"Partition record has incorrect flags set");
            SpMemFree(pRec);
        }
        pRec = SpAsrPopNextPartitionRecord(pList);
    }

    //
    // Recreate the primary partitions first.  
    //
    pRec = SpAsrPopNextPartitionRecord(&primaryPartList);
    while (pRec) {
        //
        // If it's the container partition, we need to make sure it's big
        // enough to hold all the logical drives
        // 
        if (pRec->IsContainerRecord) {
            ULONGLONG sectorCount = 0;
            PSIF_PARTITION_RECORD pLogicalDiskRec = NULL;

            pLogicalDiskRec = logicalDiskList.First;
            while (pLogicalDiskRec) {
                sectorCount += RoundUp(pLogicalDiskRec->SectorCount, SectorsPerCylinder);
                pLogicalDiskRec = pLogicalDiskRec->Next;
            }

            if (pRec->SectorCount < sectorCount) {
                pRec->SectorCount = sectorCount;
            }

        }

        oldStartSector = pRec->StartSector;
        oldSectorCount = pRec->SectorCount; 

        count = SpPtnGetPartitionCountDisk(Disk) + SpPtnGetContainerPartitionCount(Disk);
        SpAsrRecreatePartition(pRec, Disk, isAligned);

        if ((pRec->StartSector != oldStartSector) ||
            (pRec->SectorCount != oldSectorCount)) {

            SpAsrUpdatePartitionRecord(
                Disk,
                pRec->StartSector,
                oldStartSector,
                pRec->SectorCount
                );
        }

        SpMemFree(pRec);

        if (SpPtnGetPartitionCountDisk(Disk) + SpPtnGetContainerPartitionCount(Disk)  > (count + 1)) {
//            moveToNext = FALSE;
//            pRec = NULL;

            ASSERT(0 && L"Partition count differs from expected value (stale data?)");
        }
//        else {

        pRec = SpAsrPopNextPartitionRecord(&primaryPartList);
//        }
    }

    if (moveToNext) {
        //
        // Recreate the logical drives next
        //
        pRec = SpAsrPopNextPartitionRecord(&logicalDiskList);
        while (pRec) {

            oldStartSector = pRec->StartSector;
            oldSectorCount = pRec->SectorCount; 

            count = SpPtnGetPartitionCountDisk(Disk);
            SpAsrRecreatePartition(pRec, Disk, isAligned);

            if ((pRec->StartSector != oldStartSector) ||
                (pRec->SectorCount != oldSectorCount)) {

                SpAsrUpdatePartitionRecord(
                    Disk,
                    pRec->StartSector,
                    oldStartSector,
                    pRec->SectorCount
                    );
            }


            SpMemFree(pRec);

            if (SpPtnGetPartitionCountDisk(Disk) > (count + 1)) {
//                moveToNext = FALSE;
//                pRec = NULL;

                ASSERT(0 && L".. Partition count differs from expected value .. (stale data?)");

            }
//            else {
                pRec = SpAsrPopNextPartitionRecord(&logicalDiskList);
//            }
        }
    }

    return moveToNext;
}


BOOLEAN
SpAsrAttemptRepair(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource
    )
/*++

Routine Description:
    This routine attempts to replace any missing or corrupted system files with
    their counterparts from an installation source (CDROM, Harddisk, etc).  If
    successful, a full-scale installation is not required and the recovery can
    proceed much faster.

    To accomplish this, AsrAttemptRepair() employs the following logic:

        * If \Device\floppy0\setup.log cannot be opened, then repair can
        not proceed and a full-scale install must be performed.  Otherwise, the
        repair is begun.

        * The first step in the repair is to verify that the directories
        forming the NT tree are present and accessible.  If any of these
        directories are missing or inaccessible, they are recreated and made
        accessible.

        * The second step is to copy any missing or corrupted files from
        installation source.  To accomplish this, SppRepairWinntFiles() is
        called.  This function checks whether each file enumerated in the
        setup.log file is present on the disk AND that its checksum matches
        that specified in setup.log.  If either of these two conditions are
        not met, a new version of the file is copied from the installation
        source (e.g., the CDROM) to the disk.


Arguments:
    SifHandle       Handle to txtsetup.inf

    SetupSourceDevicePath   The physical device path of the media containing the
                            installation files.

    DirectoryOnSetupSource  The name of the directory on the source media (see
                            previous parameter) containing the installation files.


Returns:
    TRUE    if the attempted repair operation is successful.  
    FALSE   if the setup.log file was not opened (ie it wasn't present 
            on the ASR/ER floppy), or the system or boot partitions were NULL

--*/
{
    if (!(Gbl_HandleToSetupLog && 
        Gbl_SystemPartitionRegion && 
        Gbl_BootPartitionRegion)) {
        return FALSE;
    }

    // run autochk on boot and system partitions
    DbgStatusMesg((_asrinfo, 
        "AttemptRepair. Running AutoChk on boot and sys ptns\n"
        ));

    SpRunAutochkOnNtAndSystemPartitions(
        SifHandle,
        Gbl_BootPartitionRegion,
        Gbl_SystemPartitionRegion,
        Local_SetupSourceDevicePath,
        Local_DirectoryOnSetupSource,
        NULL
        );

    // 
    // Verify and repair security of the directories that form the NT tree
    // using the information obtained from the setup.log file.
    //
    DbgStatusMesg((_asrinfo, 
        "AttemptRepair. Verifying and repairing directory structure\n"
        ));

    SppVerifyAndRepairNtTreeAccess(SifHandle,
        Gbl_BootPartitionName,
        Gbl_BootPartitionDirectory,
        Gbl_SystemPartitionName,
        Gbl_SystemPartitionDirectory
        );

    // initialize the diamond compression engine.
    SpdInitialize();

    //
    // At this point, we are safe in assuming that the partition and directory
    // structures required to recover the system are still intact.  That being
    // the case, replace the files whose state is preventing the system from
    // booting.
    //
    if (RepairItems[RepairFiles]) {

        //
        // initialize PID only in case of normal ASR
        //
        if ((ASRMODE_NORMAL == SpAsrGetAsrMode()) && !RepairWinnt) {
            SpInitializePidString(SifHandle,
                Local_SetupSourceDevicePath,
                Local_DirectoryOnSetupSource
                );
        }                          

        SppRepairWinntFiles(Gbl_HandleToSetupLog,
            SifHandle,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource,
            Gbl_SystemPartitionName,
            Gbl_SystemPartitionDirectory,
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory
            );

        SppRepairStartMenuGroupsAndItems(Gbl_BootPartitionName, Gbl_BootPartitionDirectory);
    }

    //
    // Repair the hives. This action is only available if the Fast Repair
    // option was chosen.
    //
    if (Gbl_RepairWinntFast) {

        PWSTR directoryOnHiveRepairSource = NULL;
        BOOLEAN tmpRepairFromErDisk = Gbl_RepairFromErDisk;

        // 
        // Create the complete hive repair path
        //
        wcscpy(TemporaryBuffer, Gbl_BootPartitionDirectory);
        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        directoryOnHiveRepairSource = SpDupStringW(TemporaryBuffer);
        Gbl_RepairFromErDisk = FALSE;

        SppRepairHives(SifHandle,
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory,
            Gbl_BootPartitionName,
            directoryOnHiveRepairSource
            );

        SpMemFree(directoryOnHiveRepairSource);
        Gbl_RepairFromErDisk = tmpRepairFromErDisk;
    }

    SpdTerminate();
    return TRUE;
}

BOOLEAN
SpDoRepair(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource,
    IN PWSTR RepairPath,
    IN PULONG RepairOptions
    )
{
    
    ULONG count = 0;
    ASRMODE prevMode = ASRMODE_NONE;
    BOOLEAN returnValue = FALSE;

    for (count = 0; count < RepairItemMax; count++) {
        RepairItems[count] = RepairOptions[count];
    }

    prevMode = SpAsrSetAsrMode(TRUE);
    Gbl_SourceSetupLogFileName = RepairPath;
    SpAsrProcessSetupLogFile(Gbl_SourceSetupLogFileName, FALSE);

    returnValue = SpAsrAttemptRepair(SifHandle,
        SetupSourceDevicePath,
        DirectoryOnSetupSource,
        AutoSourceDevicePath,
        AutoDirectoryOnSetupSource
        );

    SpAsrSetAsrMode(prevMode);
    return returnValue;
}


VOID
SpAsrRepairOrDRMenu(VOID)
/*++

Routine Description:
    Display a screen allowing the user to choose among the repair
    options: Recovery Console, Conventional Repair, ASR or Exit.

Arguments:
    None.

Return Value:
    None.

Side Effects:
    Sets the following global flags to indicate user's selection:
    ForceConsole        set to TRUE if user wants Recovery Console
    RepairWinnt         set to TRUE if user wants Conventional Repair
    SpAsrSetAsrMode(ASRMODE_NORMAL)   if user wants Conventional Repair or ASR

--*/

{

    ULONG repairKeys[] = {KEY_F3, KEY_F10, 0};
    ULONG mnemonicKeys[] = {MnemonicConsole, MnemonicRepair, 0};
    BOOLEAN done = TRUE;
    ULONG UserOption;

    do {
        done = TRUE;

        if (SpIsERDisabled()) {
            UserOption = (MnemonicConsole | KEY_MNEMONIC);    // only Command console
        } else {
            // display the choice screen for the user.
            SpDisplayScreen(SP_SCRN_DR_OR_REPAIR,3,4);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                                    SP_STAT_C_EQUALS_CMDCONS,
                                    SP_STAT_R_EQUALS_REPAIR,
                                    SP_STAT_F3_EQUALS_EXIT,
                                    0
                                   );

            // wait for keypress.  Valid keys:
            // F3 = exit
            // F10,C = Recovery Console
            // R = Repair Winnt
            // A = Automated System Recovery (ASR)
            SpInputDrain();
            UserOption = SpWaitValidKey(repairKeys,NULL,mnemonicKeys);
        }            

        switch(UserOption) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            done = FALSE;
            break;

        case KEY_F10:
        case (MnemonicConsole | KEY_MNEMONIC):
            // User wants the recovery console.
            ForceConsole = TRUE;
            SpAsrSetAsrMode(ASRMODE_NONE);
            RepairWinnt = FALSE;
            break;            

        case (MnemonicRepair | KEY_MNEMONIC):
            // User wants conventional repair.
            SpAsrSetAsrMode(ASRMODE_NORMAL);
            RepairWinnt = TRUE;
            break;

        default:
            // User doesn't want any of our choices. Show him the same screen again.
            done = FALSE;
            break;

        }
    } while (!done);
}


BOOLEAN
SpAsrRepairManualOrFastMenu(VOID)
/*++

Routine Description:
    Display a screen allowing the user to choose between Manual and Fast
    Repair modes. Manual--user will select options on next screen, 
    Fast--defaults are used

Arguments:
    None.

Return Value:
    TRUE    if the user selected a repair mode
    FALSE   if the user hit <ESC> to cancel

Side Effect:
    Gbl_RepairWinntFast is set to TRUE if user selects Fast Repair, FALSE otherwise
                        
--*/
{
    ULONG repairKeys[] = {KEY_F3, ASCI_ESC, 0};
    ULONG mnemonicKeys[] = {MnemonicFastRepair, MnemonicManualRepair, 0};
    BOOLEAN done;

    do {
        done = TRUE;

        // 
        // Display the choice screen for the user.
        //
        SpDisplayScreen(SP_SCRN_REPAIR_MANUAL_OR_FAST,3,4);
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_M_EQUALS_REPAIR_MANUAL,
            SP_STAT_F_EQUALS_REPAIR_FAST,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        // 
        // wait for keypress.  Valid keys:
        // F3 = exit
        // ESC = cancel
        // M = Manual Repair
        // F = Fast Repair
        //
        SpInputDrain();
        switch(SpWaitValidKey(repairKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            break;

        case (MnemonicManualRepair | KEY_MNEMONIC):
            // User wants manual repair, i.e., choose from the list.
            Gbl_RepairWinntFast = FALSE;
            break;

        case (MnemonicFastRepair | KEY_MNEMONIC):
            // User wants fast repair, i.e., don't show the list.
            Gbl_RepairWinntFast = TRUE;
            break;

        case ASCI_ESC:
            // User wants to cancel
            return FALSE;

        default:
            // User doesn't want any of our choices
            done = FALSE;
            break;

        }
    } while (!done);

    return TRUE;
}


//
// Returns true if this physical disk is to be skipped while 
// repartitioning all the disks.  (i.e., this disk is intact,
// or is removable, etc)
//
BOOLEAN
SpAsrpSkipDiskRepartition(
    IN DWORD DiskIndex,
    IN BOOLEAN SkipNonCritical  // should we skip non-critical disks?
    ) 
{
    // 
    // Skip removable disks.  They are not counted in the 
    // partition set table, hence their entry is NULL.
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]) {
        return TRUE;
    }

    //
    // Skip disks for which no disk record exists in asr.sif
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord) {
        return TRUE;
    }
    
    //
    // Skip disks for which a disk record may exist but no 
    // partition records reference that disk record.
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord->PartitionList) {
        return TRUE;
    }

    //
    // Skip non-critical disks if told to.
    //
    if ((SkipNonCritical) && (FALSE == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord->IsCritical)) {
        return TRUE;
    }

    //
    // Skip disks that are intact
    //
    if (Gbl_PartitionSetTable1[DiskIndex]->PartitionsIntact) {
        return TRUE;
    }

    return FALSE;
}


VOID
SpAsrClobberDiskWarning(VOID)
/*++

Routine Description:
    Display a screen warning the user that when a partition on a disk is
    to be recreated, *all* partitions on that disk are clobbered, and
    allowing the user to abort.

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG validKeys[] = {KEY_F3, 0};
    ULONG mnemonicKeys[] = {MnemonicContinueSetup, 0};
    BOOLEAN done = FALSE,
        skip = FALSE;
    DWORD diskIndex = 0;
    ULONG Keypress = 0;
    PVOID Menu;
    ULONG MenuTopY;

    //
    // Dummy variables for user selection data, we don't use these
    //
    ULONG_PTR FirstData = 0,
        ReturnedData = 0;


    if ((ASRMODE_NORMAL != SpAsrGetAsrMode()) || SpAsrGetSilentRepartitionFlag(ASR_SIF_SYSTEM_KEY)) {
        //
        // Automated tests; don't display warning menu
        //
        return;
    }


    // 
    // Display the "your disks will be repartitioned" warning message
    //
    SpDisplayScreen(SP_SCRN_DR_DISK_REFORMAT_WARNING,3,CLIENT_TOP+1);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_C_EQUALS_CONTINUE_SETUP,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // And generate the list of disks that will be repartitioned.
    // Calculate menu placement.  Leave one blank line and one 
    // line for a frame.
    //
    MenuTopY = NextMessageTopLine + 2;

    //
    // Create a menu.
    //
    Menu = SpMnCreate(3, MenuTopY, (VideoVars.ScreenWidth-6),
        (VideoVars.ScreenHeight - MenuTopY - 
            (SplangQueryMinimizeExtraSpacing() ? 1 : 2) - STATUS_HEIGHT)
        );
    if (!Menu) {
        SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"SpMnCreate failed");
    }

    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {

        skip = SpAsrpSkipDiskRepartition(diskIndex, FALSE);

        if (!skip) {
            PHARD_DISK Disk = SPPT_GET_HARDDISK(diskIndex);

            if (!FirstData) {
                FirstData = (ULONG_PTR)Disk;
            }
         
            if (!SpMnAddItem(Menu, Disk->Description, 3, (VideoVars.ScreenWidth-6), TRUE, (ULONG_PTR)Disk)) {
                SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"SpMnAddItem failed");
            }
        }
    }

    SpInputDrain();

    do {

        //
        // wait for keypress.  Valid keys:
        // C  = continue
        // F3 = exit
        //
        SpMnDisplay(Menu,
            FirstData,
            TRUE,
            validKeys,
            mnemonicKeys,
            NULL,      // no new highlight callback
            &Keypress, 
            &ReturnedData
            );


        switch(Keypress) {
        case KEY_F3:
            // 
            // User wants to exit--confirm.
            //
            SpConfirmExit();
            break;

        case (MnemonicContinueSetup | KEY_MNEMONIC):
            // 
            // User wants to continue with Setup
            //
            done = TRUE;
            break;
        }
    } while (!done);

    SpMnDestroy(Menu);
}


VOID
SpAsrCannotDoER(VOID)
/*++

Routine Description:
    Display a screen informing the user that ER canot be performed on
    the system because the boot partition in not intact, i.e., ASR
    recreated/reformatted that partition.

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG warningKeys[] = { KEY_F3, 0 };
    ULONG mnemonicKeys[] = { 0 };

    // display the message screen
    SpDisplayScreen(SP_SCRN_DR_CANNOT_DO_ER,3,4);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    // wait for keypress.  Valid key:
    // F3 = exit
    SpInputDrain();
    do {
        switch(SpWaitValidKey(warningKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            return;
        }
    } while (TRUE);
}


VOID
SpAsrQueryRepairOrDr()
/*++

  -pending code description

--*/
{
    BOOLEAN done = TRUE;

    do {
        done = TRUE;

        // ask the user if he wants repair or ASR
        SpAsrRepairOrDRMenu();

        if (RepairWinnt) {
            // User wants to repair, check Manual or Fast
           if (done = SpAsrRepairManualOrFastMenu()) {
                if (Gbl_RepairWinntFast) {              // Fast Repair
                    RepairItems[RepairNvram]    = 1;
                    RepairItems[RepairFiles]    = 1;
#ifdef _X86_
                    RepairItems[RepairBootSect] = 1;
#endif
                }
                else {                                  // Manual Repair
                    done = SpDisplayRepairMenu();
                }
            }
        }
    } while (!done);
}


BOOLEAN
SpAsrOpenAsrStateFile(ULONG *ErrorLine, PWSTR AsrSifPath)
{
    NTSTATUS status;

    ASSERT(ErrorLine);
    *ErrorLine = 0;

    // load asr.sif
    status = SpLoadSetupTextFile(
        AsrSifPath,
        NULL,
        0,
        &Gbl_HandleToDrStateFile,
        ErrorLine,
        TRUE,
        FALSE
        );

    if (!NT_SUCCESS(status)) {
        DbgErrorMesg((_asrerr, "SpAsrOpenAsrStateFile. Unable to open %ws. status:0x%x ErrorLine:%lu\n", 
            AsrSifPath,
            status, 
            *ErrorLine));

        Gbl_HandleToDrStateFile = NULL;
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
SpAsrLoadAsrDiskette(VOID)
/*++

Routine Description:
    This routine checks for a floppy drive. If one is not found, this routine 
    never returns, Setup terminates with an error. If a floppy drive is found, 
    this routine prompts for the ASR disk. If the disk is loaded, it reads and 
    parses the asr.sif file.

Arguments:
    None.

Return Values:
    TRUE  if disk was loaded successfully
    DOES NOT RETURN if no floppy drive was found, or if asr.sif is corrupt.

--*/
{
    ULONG errorAtLine = 0, 
        diskIndex = 0;

    PWSTR diskName = NULL;
    PWSTR diskDeviceName = NULL;
    PWSTR localAsrSifPath = NULL;

    BOOLEAN result = FALSE;

    if (!RemoteBootSetup) {
        //
        // Look for the asr.sif in the boot directory.  If it isn't present
        // in the boot directory, we'll look for it on the floppy drive.
        //
        localAsrSifPath = SpMemAlloc((wcslen(NtBootDevicePath)+wcslen(ASR_SIF_NAME)+2) * sizeof(WCHAR));

        if (localAsrSifPath) {
            localAsrSifPath[0] = UNICODE_NULL;
            wcscpy(localAsrSifPath,NtBootDevicePath);
            SpConcatenatePaths(localAsrSifPath,ASR_SIF_NAME);

            result = SpAsrOpenAsrStateFile(&errorAtLine, localAsrSifPath);
            Gbl_AsrSifOnInstallationMedia = result;
            
            SpMemFree(localAsrSifPath);
            localAsrSifPath = NULL;
        }

        if (!result) {
            // 
            // Check if the machine has a floppy drive.  This is kind of redundant,
            // since he couldn't have got this far if there isn't a floppy drive.
            // However, we've had cases where setupldr recognises the floppy drive, 
            // but we then loose the floppy by the time we get here.
            //
            if (SpGetFloppyDriveType(0) == FloppyTypeNone) {
                SpAsrRaiseFatalError(
                    SP_TEXT_DR_NO_FLOPPY_DRIVE,
                    L"Floppy drive does not exist"
                    );     
                // does not return
            }

            SpFormatMessage(TemporaryBuffer, sizeof(TemporaryBuffer), SP_TEXT_DR_DISK_NAME);
            diskName = SpDupStringW(TemporaryBuffer);
            diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);

            // 
            // Prompt for the disk.  We don't allow him to hit ESC to cancel,
            // since he can't quit out of ASR at this point.
            //
            SpPromptForDisk(
                diskName,
                diskDeviceName,
                ASR_SIF_NAME,
                FALSE,              // no ignore disk in drive
                FALSE,              // no allow escape
                FALSE,              // no warn multiple prompts
                NULL                // don't care about redraw flag
                );

            DbgStatusMesg((_asrinfo, 
                "SpAsrLoadAsrDiskette. Disk [%ws] loaded successfully on %ws\n", 
                diskName, diskDeviceName
                ));

            SpMemFree(diskName);
            SpMemFree(diskDeviceName);

            // 
            // Open asr.sif from the floppy.  If we can't read it, it's a fatal
            // error.
            //
            result = SpAsrOpenAsrStateFile(&errorAtLine, ASR_SIF_PATH);
        }

    } else {
        //
        // open the file from the remote location
        //
        RemoteBootAsrSifName = SpGetSectionKeyIndex(
                                        WinntSifHandle,
                                        L"OSChooser", 
                                        L"ASRINFFile",
                                        0);

        if (!RemoteBootAsrSifName) {
            SpAsrRaiseFatalError(
                SP_TEXT_DR_NO_ASRSIF_RIS,
                L"Couldn't get ASRINFFile from winnt.sif in RIS case"
                );     
            // does not return
        }

        result = SpAsrOpenAsrStateFile(&errorAtLine, RemoteBootAsrSifName);
    }

    if (!result) {

        swprintf(TemporaryBuffer, L"Failed to load/parse asr.sif at line %lu\n",
            errorAtLine);

        if (errorAtLine > 0) {
            SpAsrRaiseFatalErrorLu(SP_TEXT_DR_STATEFILE_BAD_LINE,
                TemporaryBuffer,
                errorAtLine
                );
        }
        else {
            SpAsrRaiseFatalError(SP_TEXT_DR_STATEFILE_ERROR, TemporaryBuffer);
        }
        // does not return
    }

    // 
    // Set Gbl_FixedDiskCount
    //
    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {
        Gbl_FixedDiskCount += DISK_IS_REMOVABLE(diskIndex) ? 0 : 1;
    }

    AutoPartitionPicker = FALSE;
    return TRUE;
}


BOOLEAN
SpAsrLoadErDiskette(VOID)
/*++

Routine Description:
    This routine checks for a floppy drive, and prompts for the ER 
    Diskette if a drive is found. If a floppy drive is not found, 
    this routine never returns, Setup terminates with an error.

Arguments:
    None.

Return Values:
    TRUE  if disk was loaded successfully
    FALSE otherwise (user hit cancel, or there was no floppy drive present)

--*/
{
    BOOLEAN diskLoaded = FALSE;
    PWSTR diskName = NULL,
        diskDeviceName = NULL;

    // check if an A: drive exists.
    if (SpGetFloppyDriveType(0) == FloppyTypeNone) {
        SpAsrRaiseFatalError(
            SP_TEXT_DR_NO_FLOPPY_DRIVE,
            L"Floppy drive does not exist"
            );     
        // does not return
    }

    SpFormatMessage(TemporaryBuffer, sizeof(TemporaryBuffer),
                    SP_TEXT_REPAIR_OR_DR_DISK_NAME);
    diskName = SpDupStringW(TemporaryBuffer);
	diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);

    // prompt for the disk.
    diskLoaded = SpPromptForDisk(
        diskName,
        diskDeviceName,
        ASR_SETUP_LOG_NAME,
        TRUE,
        TRUE,
        FALSE,
        NULL
        );

    DbgStatusMesg((_asrinfo, "SpAsrLoadErDiskette. ER disk [%ws] %s loaded successfully on %s\n", 
        diskName, diskLoaded?"":"NOT", diskDeviceName));

    SpMemFree(diskName);
    SpMemFree(diskDeviceName);

    return diskLoaded;
}


BOOLEAN
SpAsrGetErFromHardDrive(
    IN PVOID MasterSifHandle,
    OUT PVOID *RepairSifHandle,
    OUT PWSTR *FullLogFileName 
   )
/*++

  -pending code description

--*/

{
    BOOLEAN foundRepairableSystem = FALSE,
        result = FALSE;

    DbgStatusMesg((_asrinfo, "SpAsrGetErFromHardDrive. ER: Attempting to load ER data from Hard drive"));

    // 
    // If user has no emergency repair diskette, we need to find out
    // if there is any NT to repair and which one to repair.
    //
    result = SpFindNtToRepair(MasterSifHandle,
        &Gbl_BootPartitionRegion,
        &Gbl_BootPartitionDirectory,
        &Gbl_SystemPartitionRegion,
        &Gbl_SystemPartitionDirectory,
        &foundRepairableSystem
        );

    if (result) {
        
        //
        // Repairable systems were found, and the user selected one to repair
        //

        //
        // Get the device path of the system and boot partitions.
        //
        SpNtNameFromRegion(Gbl_SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        Gbl_SystemPartitionName = SpDupStringW(TemporaryBuffer);

        SpNtNameFromRegion(Gbl_BootPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        Gbl_BootPartitionName = SpDupStringW(TemporaryBuffer);

        // 
        // Form the full NT path of the setup.log file in the chosen
        // system on the hard drive.
        //
        SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);
        *FullLogFileName = SpDupStringW(TemporaryBuffer);

        DbgStatusMesg((_asrinfo, 
            "ER: User picked system to repair. boot-ptn:[%ws] sys-ptn:[%ws] log-file:[%ws]\n",
            Gbl_BootPartitionName, 
            Gbl_SystemPartitionName, 
            *FullLogFileName
            ));

        // 
        // Read and process the setup.log file.
        //
        result = SpLoadRepairLogFile(*FullLogFileName, RepairSifHandle);
        if (!result) {
            // 
            // Load setup.log failed. Ask user to insert a ER diskette again.
            //
            DbgErrorMesg((_asrwarn, 
                "ER: Attempt to load log file [%ws] FAILED\n", 
                *FullLogFileName
                ));
            return FALSE;
        }

        // 
        // Setup file was read. Will return TRUE
        // 
         Gbl_RepairFromErDisk = FALSE;
    }
    else {
        //
        // User did not select a system to repair
        //

        if (foundRepairableSystem) {
            // 
            // Setup found a WINNT installation, but no installation was 
            // chosen by the user.  We will go back to ask for the ER 
            // diskette again.
            //
            DbgErrorMesg((_asrwarn, "ER: Repairable systems were found, but user did not select any\n"));
            return FALSE;
        }
        else {
            //  
            // Couldn't find any NT to repair
            //
            ULONG validKeys[] = {KEY_F3, ASCI_CR, 0};
            ULONG mnemonicKeys[] = {MnemonicCustom, 0};

            DbgErrorMesg((_asrwarn, "ER: No repairable systems were found\n"));

            SpStartScreen(SP_SCRN_REPAIR_NT_NOT_FOUND,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_ENTER_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpInputDrain();

            switch (SpWaitValidKey(validKeys,NULL,NULL)) {
            case KEY_F3:
                // 
                // User wants to exit Setup
                //
                SpDone(0,TRUE,TRUE);
                break;

            default:
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN 
SpAsrGetErDiskette(IN PVOID SifHandle)
/*++

  -pending code description
  
--*/
{
    PWSTR fullLogFileName = NULL;
    BOOLEAN done = FALSE,
        hasErDisk = FALSE;

    while (!done) {
        // 
        // display message to let user know he can either provide his
        // own ER disk or let setup search for him.
        //
        if (!SpErDiskScreen(&hasErDisk)) {    
            return FALSE;        
        }

        Gbl_HandleToSetupLog = NULL;
        fullLogFileName = NULL;

        if (hasErDisk) {
            // 
            // Ask for emergency repair diskette until either we get it or
            // user cancels the request.
            //
            done = SpAsrLoadErDiskette();
            if (done) {
                Gbl_SourceSetupLogFileName = ASR_DEFAULT_SETUP_LOG_PATH;
                done = SpAsrProcessSetupLogFile(Gbl_SourceSetupLogFileName, TRUE);
            }
        }
        else {
            done = SpAsrGetErFromHardDrive(SifHandle, &Gbl_HandleToSetupLog, &fullLogFileName);

            if (fullLogFileName) {
                Gbl_SourceSetupLogFileName = SpDupStringW(fullLogFileName);
                SpMemFree(fullLogFileName);
            }
        }
    }

    DbgStatusMesg((_asrinfo, "SpAsrGetErDiskette. ER: %s Floppy. Using setup log file [%ws]\n", 
        hasErDisk?"Using":"NO", (Gbl_SourceSetupLogFileName ? Gbl_SourceSetupLogFileName : L"")));

    return TRUE;
}



PSIF_PARTITION_RECORD
SpAsrGetBootPartitionRecord(VOID)
{
    ULONG diskIndex = 0;
    PSIF_PARTITION_RECORD pRecord = NULL;

    if (Gbl_BootPartitionRecord) {
        return Gbl_BootPartitionRecord;
    }
    
    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {
        //
        // Find NT partition record from the partition set table.
        //
        if (Gbl_PartitionSetTable2[diskIndex] == NULL ||
            Gbl_PartitionSetTable2[diskIndex]->pDiskRecord == NULL ||
            Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList == NULL) {
            continue;
        }

        DbgStatusMesg((_asrinfo, "Disk %lu ptn records: ", diskIndex));
        pRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;

        while (pRecord) {
        
            DbgMesg((_asrinfo, "[%ws]", pRecord->CurrPartKey));
            
            if (SpAsrIsBootPartitionRecord(pRecord->PartitionFlag)) {
                ASSERT((pRecord->NtDirectoryName) && L"Boot partition is missing NT directory name.");
                return pRecord;
            }
        
            pRecord = pRecord->Next;            
        }

        DbgMesg((_asrinfo, "\n"));
    }

    DbgFatalMesg((_asrerr, "SpAsrGetBootPartitionRecord. No boot partition record was found.\n"));
    SpAsrRaiseFatalErrorWs(
        SP_SCRN_DR_SIF_BAD_RECORD,
        L"No boot partition found in asr.sif",
        SIF_ASR_PARTITIONS_SECTION
        );
    //
    // Never gets here
    //
    return NULL;
}


PWSTR
SpDrGetNtDirectory(VOID)
/*++

Routine Description:
    Returns the target path according to the value found in the asr.sif
    file, but without the leading drive letter and colon.

Arguments:
    None

Return Value:
    A pointer to a string containing the NT directory path.  This will be of
    the form:
            \WINDOWS
    and not:
            C:\WINDOWS
--*/
{
    PSIF_PARTITION_RECORD pRecord = SpAsrGetBootPartitionRecord();
    return (pRecord ? pRecord->NtDirectoryName : NULL);
}


ASRMODE
SpAsrGetAsrMode(VOID)
/*++

Routine Description:
    Returns whether ASR is in progress

Return Value:
    The Asr type currently in progress.

--*/
{
    return Gbl_AsrMode;
}


ASRMODE
SpAsrSetAsrMode(
    IN CONST ASRMODE NewAsrMode
    )
/*++

Routine Description:
    Sets the Gbl_AsrMode state variable to the value of NewAsrMode.

Arguments:
    NewAsrMode - new Asr mode

Return Value:
    Returns the previous Asr mode

--*/
{
    ASRMODE oldMode = Gbl_AsrMode;
    Gbl_AsrMode = NewAsrMode;
    return oldMode;
}



BOOLEAN
SpDrEnabled(VOID) {

    //
    // Asr is enabled if Gbl_AsrMode is set to anything other than
    // ASRMODE_NONE
    //
    return (ASRMODE_NONE != Gbl_AsrMode);
}

BOOLEAN
SpAsrIsQuickTest(VOID) {
    return (
        (ASRMODE_QUICKTEST_TEXT == Gbl_AsrMode) || 
        (ASRMODE_QUICKTEST_FULL == Gbl_AsrMode)
        );
}

BOOLEAN
SpDrIsRepairFast(VOID)
/*++

Routine Description:
    Tests whether the "Fast" Emergency Repair flag is set.

Return Value:
    TRUE    if "Fast" ER flag is set
    FALSE   otherwise

--*/
{
    return Gbl_RepairWinntFast;
}


BOOLEAN
SpDrSetRepairFast(BOOLEAN NewValue)
/*++

Routine Description:
  Sets the "Fast" Emergency Repair flag.

Arguments:
    Value   New Value (TRUE or FALSE) to which to set the
            Gbl_RepairWinntFast flag

Return Value:
    Previous value of Gbl_RepairWinntFast;

--*/
{
    BOOLEAN oldValue = Gbl_RepairWinntFast;

    Gbl_RepairWinntFast = NewValue;
    return oldValue;
}


extern VOID
SpAsrDbgDumpSystemMountPoints(VOID);

VOID
SpDrCleanup(VOID)
/*++

  -pending code description

--*/
{
    ULONG diskIndex = 0;
    
    //
    // Remove all the mountpoints in the system, we shall recreate them.
    //
    SpAsrRemoveMountPoints();

    DbgStatusMesg((_asrinfo, "Restoring volume mount points.\n"));

    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {

        if (!(DISK_IS_REMOVABLE(diskIndex))) {
            SpAsrRestoreDiskMountPoints(diskIndex);
            SpAsrDbgDumpDisk(diskIndex);
        }
    }

//    DbgStatusMesg((_asrinfo, "Dumping mount points AFTER text-mode ASR:\n"));
//    SpAsrDbgDumpSystemMountPoints();
}


VOID
SpAsrCopyStateFile(VOID)
{
    NTSTATUS status = STATUS_SUCCESS;

    PWSTR diskName      = NULL,
        targetFilePath  = NULL,
        sourceFilePath  = NULL,
        bootPartition   = NULL,
        diskDeviceName  = NULL;

    SpdInitialize();

    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_DR_DISK_NAME
        );

    diskName = SpDupStringW(TemporaryBuffer);

    if (RemoteBootAsrSifName == NULL) {

        if (Gbl_AsrSifOnInstallationMedia) {
            wcscpy(TemporaryBuffer,NtBootDevicePath);
            SpConcatenatePaths(TemporaryBuffer,ASR_SIF_NAME);
            sourceFilePath = SpDupStringW(TemporaryBuffer);
        }
        else {
            // 
            // Prompt the user to insert the ASR disk, if it isn't
            // already in the drive
            //
            diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);
            sourceFilePath = SpDupStringW(ASR_SIF_PATH);
        
            SpPromptForDisk(
                diskName,
                diskDeviceName,
                ASR_SIF_NAME,
                FALSE,              // no ignore disk in drive
                FALSE,              // no allow escape
                TRUE,               // warn multiple prompts
                NULL                // don't care about redraw flag
                );

            SpMemFree(diskDeviceName);
        }
    } else {
        sourceFilePath = SpDupStringW(RemoteBootAsrSifName);
    }

    //
    // Build the full path to the directory into which the file will be
    // written.
    //
    bootPartition = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    if (!Gbl_BootPartitionDirectory) {
        Gbl_BootPartitionDirectory = SpDrGetNtDirectory();
    }
    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
    SpConcatenatePaths(TemporaryBuffer, ASR_SIF_TARGET_PATH);
    targetFilePath = SpDupStringW(TemporaryBuffer);
    SpMemFree(bootPartition);

    //
    // Copy the file.  In case of errors, user will have the option
    // to retry, or quit Setup.  We cannot skip this file.
    //
    do {

        if (SpFileExists(targetFilePath, FALSE)) {
            SpDeleteFile(targetFilePath, NULL, NULL);
        }

        status = SpCopyFileUsingNames(
            sourceFilePath,
            targetFilePath,
            0,
            0
            );

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn, "SpAsrCopyFiles. Could not copy asr.sif. src:[%ws] dest:[%ws]. (0x%x)\n",
                ASR_SIF_PATH,
                targetFilePath,
                status
                ));
            
            SpAsrFileErrorRetrySkipAbort(
                SP_SCRN_DR_SIF_NOT_FOUND,
                ASR_SIF_PATH,
                diskName,
                NULL,
                FALSE           // no allow skip
                );
        }
    } while (!NT_SUCCESS(status));


    SpdTerminate();
    SpMemFree(diskName);
    SpMemFree(targetFilePath);
    SpMemFree(sourceFilePath);
}


NTSTATUS
SpAsrCopy3rdPartyFiles(
    VOID
    )
{
    PWSTR bootPartition  = NULL,
        fullTargetPath   = NULL, 
        fullSourcePath   = NULL,
        windirPathPrefix = NULL,
        tempPathPrefix   = NULL;
        
    BOOL moveToNext = FALSE,
        diskLoaded  = FALSE;

    NTSTATUS status = STATUS_SUCCESS;
    PSIF_INSTALLFILE_RECORD pRec = NULL;

    if (!Gbl_3rdPartyFileList) {
        //
        // No files to copy, we're done
        //
        return STATUS_SUCCESS;  
    }

    //
    // Build the expansion strings for 
    //  %TEMP%, %TMP%, and %SYSTEMROOT%
    //
    bootPartition = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    if (!Gbl_BootPartitionDirectory) {
        Gbl_BootPartitionDirectory = SpDrGetNtDirectory();
    }

    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
    windirPathPrefix = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, ASR_TEMP_DIRECTORY_PATH);
    tempPathPrefix = SpDupStringW(TemporaryBuffer);

    //
    // Create the TEMP directory
    // 
    SpCreateDirectory(
        bootPartition,
        NULL,
        ASR_TEMP_DIRECTORY_PATH,
        0,
        0
        );

    SpMemFree(bootPartition);

    //
    // Initialize the compression engine. We may have to uncompress files
    //
    SpdInitialize();

    //
    // Begin copying the files over
    //

    //! display status setup is copying ...
    while (pRec = SpAsrRemoveInstallFileRecord(Gbl_3rdPartyFileList)) {

        if ((!pRec->DestinationFilePath) || 
            (!pRec->SourceFilePath) || 
            (!pRec->DiskDeviceName) ||
            (!pRec->SourceMediaExternalLabel)
            ) {
            ASSERT(0 && L"InstallFiles: Invalid record, one or more attributes are NULL");
            continue;
        }

        diskLoaded = TRUE;
    
        //
        // Prompt the user for the media if needed
        //
        if ((pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA) ||
            (pRec->Flags & ASR_PROMPT_USER_ON_MEDIA_ERROR)
            ) {

            do {
                moveToNext = TRUE;

                //
                // Prompt the user to insert the appropriate disk
                //
                diskLoaded = SpPromptForDisk(
                    pRec->SourceMediaExternalLabel,
                    pRec->DiskDeviceName,   // if this isn't CD or floppy, SpPromptForDisk will always return true
                    pRec->SourceFilePath,
                    (BOOLEAN)(pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA),     // IgnoreDiskInDrive if PromptAlways
                    ! (BOOLEAN)(pRec->Flags & ASR_FILE_IS_REQUIRED),           // AllowEscape if the File is not Required
                    TRUE,       // WarnMultiplePrompts
                    NULL
                    );

                //
                // If the user hit <ESC> to cancel, we put up a prompt allowing
                // him to retry, skip this file and continue, or exit from Setup.
                //
                if (!diskLoaded)  {

                    moveToNext = SpAsrFileErrorRetrySkipAbort(
                        SP_SCRN_DR_SIF_INSTALL_FILE_NOT_FOUND,
                        pRec->SourceFilePath,
                        pRec->SourceMediaExternalLabel,
                        pRec->VendorString,
                        !(pRec->Flags & ASR_FILE_IS_REQUIRED)            // allow skip
                        );

                }

            } while (!moveToNext);
        }


        if (!diskLoaded) {
            //
            // Disk was not loaded and the user wants to skip this file
            //
            DbgErrorMesg((_asrwarn, 
                "SpDrCopy3rdPartyFiles: User skipped file (disk not loaded), src:[%ws] dest[%ws]\n",
                pRec->SourceFilePath,
                pRec->DestinationFilePath
                ));

            continue;
        }

        //
        // The correct disk was loaded. Build the full target path.  pRec->CopyToDirectory 
        // indicates which prefix we should use.
        //
        switch (pRec->CopyToDirectory) {
            case _SystemRoot:
                wcscpy(TemporaryBuffer, windirPathPrefix);
                break;

            case _Temp:
            case _Tmp:
            case _Default:
            default:
                wcscpy(TemporaryBuffer, tempPathPrefix);
                break;
        }

        SpConcatenatePaths(TemporaryBuffer, pRec->DestinationFilePath);
        fullTargetPath = SpDupStringW(TemporaryBuffer);

        //
        // If the file already exists, prompt the user if needed.  We allow him
        // to over-write (delete the existing file), preserve existing
        // (skip copying this file), or exit from Setup.
        //
        if (SpFileExists(fullTargetPath, FALSE)) {
            BOOL deleteFile = FALSE;

            if (pRec->Flags & ASR_PROMPT_USER_ON_COLLISION) {
                if (SpAsrFileErrorDeleteSkipAbort(SP_SCRN_DR_OVERWRITE_EXISTING_FILE, fullTargetPath)) {
                    deleteFile = TRUE;
                }
            }
            else if (pRec->Flags & ASR_OVERWRITE_ON_COLLISION) {
                deleteFile = TRUE;
            }

            if (deleteFile) {
                //
                // User chose to overwrite (or OVERWRITE_ON_COLLISION flag was set)
                //
                SpDeleteFile(fullTargetPath, NULL, NULL);

                DbgErrorMesg((_asrwarn, 
                    "SpDrCopy3rdPartyFiles: Over-writing file, src:[%ws] dest[%ws]\n",
                    pRec->SourceFilePath,
                    fullTargetPath
                    ));
            }
            else {
                // 
                // User chose to preserve existing file
                // 
                DbgErrorMesg((_asrwarn, 
                    "SpDrCopy3rdPartyFiles: File exists, existing file was preserved. src:[%ws] dest[%ws]\n",
                    pRec->SourceFilePath,
                    fullTargetPath
                    ));
                continue;
            }
        }

        // 
        // Combine the devicepath ("\device\cdrom0") and the sourcefilepath 
        // ("i386\driver.sys") to get the full path ("\device\cdrom0\i386\driver.sys")
        // SpConcatenatePaths takes care of adding in the \ between the two if needed
        //
        wcscpy(TemporaryBuffer, pRec->DiskDeviceName);
        SpConcatenatePaths(TemporaryBuffer, pRec->SourceFilePath);
        fullSourcePath = SpDupStringW(TemporaryBuffer);

        moveToNext = FALSE;
        while (!moveToNext) {

            moveToNext = TRUE;
            status = SpCopyFileUsingNames(
                fullSourcePath,
                fullTargetPath,
                0,  // no attributes
                0   // no flags
                );

            if (!NT_SUCCESS(status)) {

                DbgErrorMesg((_asrwarn, "SpDrCopy3rdPartyFiles. SpCopyFileUsingNames failed. src:[%ws] dest:[%ws]. (0x%x)\n",
                    pRec->SourceFilePath,
                    fullTargetPath,
                    status
                    ));

                //
                // File copy was unsuccessful, we put up a prompt allowing
                // the user to retry, skip this file and continue, or exit 
                // from Setup.
                //
                if ((pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA) || 
                    (pRec->Flags & ASR_PROMPT_USER_ON_MEDIA_ERROR)) {

                    moveToNext = SpAsrFileErrorRetrySkipAbort(
                        SP_SCRN_DR_SIF_INSTALL_FILE_NOT_FOUND,
                        pRec->SourceFilePath,
                        pRec->SourceMediaExternalLabel,
                        pRec->VendorString,
                        TRUE            // allow skip
                        );
                }
                else {
                    moveToNext = TRUE;
                }
            }
        }

        if (!NT_SUCCESS(status)) {
            DbgErrorMesg((_asrwarn, "SpDrCopy3rdPartyFiles: Unable to copy file (copy error), src:[%ws] dest[%ws]\n",
                pRec->SourceFilePath,
                fullTargetPath
                ));
        } 
        else {
           DbgStatusMesg((_asrinfo, "SpDrCopy3rdPartyFiles. Copied [%ws] to [%ws]\n", 
               pRec->SourceFilePath, 
               fullTargetPath
               ));
        }
        
        SpMemFree(fullSourcePath);
        SpMemFree(fullTargetPath);
        SpAsrDeleteInstallFileRecord(pRec);
    }

    //
    // Done.  Shut down the compression engine.
    //
    SpdTerminate();
    SpMemFree(Gbl_3rdPartyFileList);
    SpMemFree(tempPathPrefix);
    SpMemFree(windirPathPrefix);

    return STATUS_SUCCESS;
}


NTSTATUS
SpDrCopyFiles(VOID) 
{
    SpAsrCopyStateFile();
    return SpAsrCopy3rdPartyFiles();
}



#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)

NTSTATUS
SpDrSetEnvironmentVariables(HANDLE *HiveRootKeys)
{
    NTSTATUS status;

    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_CONTEXT_VALUE,
                STRING_VALUE(ASR_CONTEXT_DATA));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_CONTEXT_VALUE,
                ASR_CONTEXT_DATA, 
                status));

    if (!NT_SUCCESS(status)) {
        return status;
    }
    
    Gbl_SystemPartitionName = SpAsrGetRegionName(Gbl_SystemPartitionRegion);
    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_SYSTEM_PARTITION_VALUE,
                STRING_VALUE(Gbl_SystemPartitionName));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_SYSTEM_PARTITION_VALUE,
                Gbl_SystemPartitionName,
                status));

    if (!NT_SUCCESS(status)) {
        return status;
    }

    Gbl_BootPartitionName = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_BOOT_PARTITION_VALUE,
                STRING_VALUE(Gbl_BootPartitionName));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_BOOT_PARTITION_VALUE,
                Gbl_BootPartitionName,
                status));

    return status;
}


PDISK_REGION
SpAsrPrepareBootRegion(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource
    )
/*++

  -pending code description

--*/
{
    PWSTR systemKey = ASR_SIF_SYSTEM_KEY;
    PWSTR ntDir = NULL;
    ULONG diskIndex = 0;
    PSIF_PARTITION_RECORD ppartitionRecord = NULL;
    FilesystemType regionFsType = FilesystemUnknown;
    BOOLEAN isBoot = FALSE;
    
    //
    // Initialize Gbl_BootPartitionDriveLetter.
    //
    ntDir = SpAsrGetNtDirectoryPathBySystemKey(systemKey);

    if (!SpAsrIsValidBootDrive(ntDir)) {
        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"Windows directory specified in asr.sif is invalid",
            SIF_ASR_SYSTEMS_SECTION
            );
        // Does not return 
    }

    Gbl_BootPartitionDriveLetter = ntDir[0];

    //
    // Find boot partition region from the partition set table. 
    // from the records in the global partition set.
    //
    Gbl_BootPartitionRegion = NULL;
    for (diskIndex = 0; (diskIndex < HardDiskCount); diskIndex++) {

        if (!(Gbl_PartitionSetTable2[diskIndex] &&
              Gbl_PartitionSetTable2[diskIndex]->pDiskRecord &&
              Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList)) {
            continue;
        }

        ppartitionRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;
        
        while (ppartitionRecord) {
            isBoot = SpAsrIsBootPartitionRecord(ppartitionRecord->PartitionFlag);
            if (isBoot) {
                
                Gbl_BootPartitionRegion = SpAsrDiskPartitionExists(diskIndex, ppartitionRecord);

                if (!Gbl_BootPartitionRegion) {
                    DbgFatalMesg((_asrerr, 
                        "Partition record with boot region found, but boot (winnt) region is NULL\n"
                        ));

                    SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                        L"Boot pRegion is NULL"
                        );
                }

                Gbl_BootPartitionRecord = SpAsrCopyPartitionRecord(ppartitionRecord);
                break;
            }

            ppartitionRecord = ppartitionRecord->Next;            
        }

    }

    if (!Gbl_BootPartitionRegion) {
        
        DbgFatalMesg((_asrerr, "No partition record with boot region found, boot (winnt) region is NULL\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No boot partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    SpAsrReformatPartition(Gbl_BootPartitionRegion,
        Gbl_BootPartitionRecord->FileSystemType,
        SifHandle,
        Gbl_BootPartitionRecord->ClusterSize,
        Local_SetupSourceDevicePath,
        Local_DirectoryOnSetupSource,
        TRUE
        );

    return Gbl_BootPartitionRegion;
}


PDISK_REGION
SpAsrPrepareSystemRegion(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource
    )
/*++

  -pending code description

--*/
{
    ULONG diskIndex = 0;
    BOOLEAN found = FALSE;

    BOOLEAN diskChanged = FALSE;

    PWSTR partitionDeviceName = NULL;
    PDISK_REGION pRegion = NULL;
    PSIF_PARTITION_RECORD ppartitionRecord = NULL;
            
    ULONGLONG startSector = 0;
    DWORD diskNumber = 0;


    if (IsNEC_98) {
        // This is a NEC x86 machine

        pRegion = Gbl_BootPartitionRegion;
        ASSERT(pRegion);

    } else {
        // This is not a NEC x86 machine

#ifdef _IA64_

        WCHAR   RegionName[MAX_PATH];

        if (!(pRegion = SpPtnLocateESP())) {
            SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                L"System Region is NULL"
                );
        }

        SPPT_MARK_REGION_AS_SYSTEMPARTITION(pRegion, TRUE);
        SPPT_SET_REGION_DIRTY(pRegion, TRUE);
        ValidArcSystemPartition = TRUE;
        //
        // Remove the drive letter also
        //
        swprintf(RegionName, 
            L"\\Device\\Harddisk%u\\Partition%u",
            pRegion->DiskNumber,
            pRegion->PartitionNumber);
        
        SpDeleteDriveLetter(RegionName);            
        pRegion->DriveLetter = 0;

#else 
    
        if (!(pRegion = SpPtValidSystemPartition())) {
            SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                L"System Region is NULL"
                );
        }
    
#endif
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);
    DbgStatusMesg((_asrinfo, "PrepareSystemRegion. sys-ptn:[%ws]. Making Active\n", 
        partitionDeviceName));

    startSector = pRegion->StartSector;
    diskNumber = pRegion->DiskNumber;

#ifndef _IA64_
    
    SpPtnMakeRegionActive(pRegion);

#endif

    SpPtnCommitChanges(pRegion->DiskNumber, &diskChanged);
    DbgStatusMesg((
        _asrinfo, 
        "PrepareSystemRegion. sys-region made active. Disk %lu. %s.\n", 
        pRegion->DiskNumber, 
        diskChanged ? "Disk not changed.":"Disk changed"
        ));


    pRegion = SpPtLookupRegionByStart(SPPT_GET_PARTITIONED_DISK(diskNumber), FALSE, startSector);

    //
    // Consistency checks.  These can eventually be removed 
    //
    ASSERT(pRegion);

    diskIndex = pRegion->DiskNumber;
    ASSERT(Gbl_PartitionSetTable2[diskIndex]);
    ASSERT(Gbl_PartitionSetTable2[diskIndex]->pDiskRecord);
    ASSERT(Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList);
    
    //
    // Ensure that the partition is correctly formatted.  To accomplish this,
    // we need to find the record corresponding to this pRegion. We use the 
    // record to check for the correct file format.
    //
    ppartitionRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;
    while (ppartitionRecord) {
        if ((ULONGLONG)ppartitionRecord->StartSector == pRegion->StartSector) {
            found = TRUE;
            break;
        }

        ppartitionRecord = ppartitionRecord->Next;
    }

    if (!found) {
        DbgFatalMesg((_asrerr, 
            "Did not find system partition, start sector: %I64u\n", 
            pRegion->StartSector
            ));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No system partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }
    
    //
    // Format the system partition if needed.  We don't re-format the system
    // partition if it's intact.
    //
    if (SpAsrPartitionNeedsFormatting(pRegion, ppartitionRecord->FileSystemType)) {

        SpAsrReformatPartition(
            pRegion,
            ppartitionRecord->FileSystemType,
            SifHandle,
            ppartitionRecord->ClusterSize,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource,
            FALSE
            );                        
    }

    SpMemFree(partitionDeviceName);

    Gbl_SystemPartitionRegion = pRegion;
    return Gbl_SystemPartitionRegion;
}


#if 0
//
// We don't convert the partition types any more--it is okay to leave
// them as type 0x42 if the partitions are intact.
//
BOOLEAN
SpAsrChangeLdmPartitionTypes(VOID)
/*++

Routine Description
    Changes disk types from 0x42 to 0x7 if needed
    (If the disk is intact, it would not have been re-created
    and hence re-typed above)

--*/

{
    ULONG setIndex;
    ULONG ptnIndex;
    PDISK_PARTITION_SET ppartitionSet;
    PSIF_DISK_RECORD pdiskRecord;
    PSIF_PARTITION_RECORD ppartitionRecord;
    BOOLEAN madeAChange = FALSE;

    // Look for any disks which were marked to change from type 0x42 to
    // type 0x7.

    for (setIndex = 0; setIndex < HardDiskCount; setIndex++) {

        ppartitionSet = Gbl_PartitionSetTable2[setIndex];

        if (ppartitionSet && ppartitionSet->pDiskRecord) {
            pdiskRecord = ppartitionSet->pDiskRecord;

            if (pdiskRecord->ContainsNtPartition  ||
                pdiskRecord->ContainsSystemPartition) {
                
                ppartitionRecord = pdiskRecord->PartitionList->First;

                while (ppartitionRecord)  {

                    if (ppartitionRecord->NeedsLdmRetype) {

                        // Disk type needs to be changed

                        PPARTITIONED_DISK pDisk;
                        PDISK_REGION pRegion = NULL;

                        pDisk = &PartitionedDisks[setIndex];

                        // try finding the disk region in the main list
                        pRegion = SpPtLookupRegionByStart(pDisk, FALSE, ppartitionRecord->StartSector);

                        if (!pRegion) {
                            // that failed, try finding disk region using the 
                            // extended partitions list
                            pRegion = SpPtLookupRegionByStart(pDisk, TRUE, ppartitionRecord->StartSector);
                        }

                        if (!pRegion) {
                            // the disk region couldn't be found
                            DbgErrorMesg((_asrwarn, "SpAsrChangeLdmPartitionTypes. Unable to reset LDM partition record %ws at SS %I64u\n",
                                        ppartitionRecord->CurrPartKey,
                                        ppartitionRecord->StartSector));

                            ppartitionRecord = ppartitionRecord->Next;
                            continue;
                        }

                        // The disk region was found, now change the disk type
                        if (!IsRecognizedPartition(ppartitionRecord->FileSystemType)) {
                            //
                            // This is an 0x42 partition on the boot/sys disk, but it is
                            // not the boot or system partition.  The FileSystemType is not
                            // recognised since it  is set to be 0x42 as well.  (The 
                            // FileSystemType is only valid for the boot and system 
                            // partitions--for all other partitions,
                            // it is set to be the same as the PartitionType)
                            //
                            // We set it to 0x7 for the time being.  The actual file-system type
                            // will be set later in GUI-Setup by asr_ldm and asr_fmt.
                            //
                            DbgStatusMesg((_asrinfo, 
                                "MBR ptn-rec %ws re-typed (0x%x->0x7) \n", 
                                ppartitionRecord->CurrPartKey, 
                                ppartitionRecord->FileSystemType
                                ));
                            ppartitionRecord->FileSystemType = PARTITION_IFS;
                            ppartitionRecord->PartitionType = PARTITION_IFS;

                        }
                        else {

                            DbgStatusMesg((_asrinfo, 
                                "MBR ptn-rec %ws re-typed (0x%x->0x%x).\n", 
                                ppartitionRecord->CurrPartKey, 
                                ppartitionRecord->PartitionType, 
                                ppartitionRecord->FileSystemType
                                ));
                            ppartitionRecord->PartitionType = ppartitionRecord->FileSystemType;

                        }
 
                        ppartitionRecord->NeedsLdmRetype = FALSE;

                        SPPT_SET_PARTITION_TYPE(pRegion, ppartitionRecord->FileSystemType);
                        SPPT_SET_REGION_DIRTY(pRegion, TRUE);
                        
                        pRegion->DynamicVolume = TRUE;
                        pRegion->DynamicVolumeSuitableForOS = TRUE;
                        madeAChange = TRUE;
 
                        DbgStatusMesg((_asrinfo, "SpAsrChangeLdmPartitionTypes. Changed disk [%ws] ptn [%ws] type to 0x%x\n", 
                                   pdiskRecord->CurrDiskKey, ppartitionRecord->CurrPartKey, ppartitionRecord->PartitionType));
                    }

                    ppartitionRecord = ppartitionRecord->Next;
                }
            }

        }
    }

    return madeAChange;
}
#endif  // 0

extern VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList);

VOID
SpAsrSetNewDiskID(
    IN ULONG DiskNumber,
    IN GUID *NewGuid,       // valid only for GPT disks
    IN ULONG NewSignature   // valid only for MBR disks
    ) 
{
    PPARTITIONED_DISK pDisk = &PartitionedDisks[DiskNumber];
    PDISK_REGION pFirstRegion = NULL;
    BOOLEAN Changes = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (PARTITION_STYLE_GPT == (PARTITION_STYLE) (pDisk->HardDisk->DriveLayout.PartitionStyle)) {
        //
        // Set the new disk GUID 
        //
        CopyMemory(&(pDisk->HardDisk->DriveLayout.Gpt.DiskId), NewGuid, sizeof(GUID));
    }
    else if (PARTITION_STYLE_MBR == (PARTITION_STYLE) (pDisk->HardDisk->DriveLayout.PartitionStyle)) {
        //
        // Set the new disk signature
        //
        pDisk->HardDisk->DriveLayout.Mbr.Signature = NewSignature;
    }
    else {
        return;
    }


    //
    // For Commit to pick up the new Guid, at least one region on the
    // disk must be marked dirty.
    //
    pFirstRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    SPPT_SET_REGION_DIRTY(pFirstRegion, TRUE);

    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Reset the dirty flag on the first region
    //
    pFirstRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    SPPT_SET_REGION_DIRTY(pFirstRegion, FALSE);

}


NTSTATUS
SpDrPtPrepareDisks(
    IN  PVOID           SifHandle,
    OUT PDISK_REGION    *BootPartitionRegion,
    OUT PDISK_REGION    *SystemPartitionRegion,
    IN  PWSTR           SetupSourceDevicePath,
    IN  PWSTR           DirectoryOnSetupSource,
    OUT BOOLEAN         *RepairedNt
    )
/*++

  Description:
    If necessary, SpDrPtPrepareDisks() restores (recreates and formats) the
    system and boot partitions based on information obtained from the
    asr.sif file.

  Arguments:
    SifHandle               - Handle to txtsetup.sif

    BootPartitionRegion    - Receives a pointer to the partition into 
                              which NT will be installed (e.g., \WINNT).
    
    SystemPartitionRegion   - Receives a pointer to the partition into 
                              which the boot loader will be installed.

    SetupSourceDevicePath   - Path to the CDROM

    DirectoryOnSetupSource  - The directory on the installation CDROM.  
                              (usually "\I386" for x86 installations)
    
    RepairedNt  - Receives a pointer to a boolean value that is set to:
                  TRUE: Indicates the partition structure on the loader 
                        disk and he partition structure on the NT disk were 
                        intact and that ASR attempted to perform a repair 
                        operation.
                  FALSE: Indicates the partition structure on either the
                        loader disk or the NT disk (or both) were removed
                        and recreated. When SpStartSetup() sees this value, 
                        it will proceed with a normal installation.

  Return Value:
    STATUS_SUCCESS, always! (as of now, anyway)

--*/
{
    BOOL done = TRUE,
        next = TRUE,
        warningScreenDone = FALSE;

    NTSTATUS status;

    ULONG diskIndex = 0;

    PWSTR setupSourceDevicePath = NULL, 
        directoryOnSetupSource = NULL;
 
    DbgStatusMesg((_asrinfo, "Entering SpDrPtPrepareDisks. Beginning ASR/ER/RC Processing\n"));
    DbgStatusMesg((_asrinfo, "SetupSourceDevicePath:[%ws], DirectoryOnSetupSource:[%ws]\n",
        SetupSourceDevicePath, DirectoryOnSetupSource));

    *RepairedNt = FALSE;

    //
    // find out if the user wants Recovery Console, traditional Emergency 
    // Repair (ER), or full scale Automated System Recovery (ASR)
    //
    Gbl_SifHandle = SifHandle;
    setupSourceDevicePath = SpDupStringW(SetupSourceDevicePath);
    directoryOnSetupSource = SpDupStringW(DirectoryOnSetupSource);

    do {

        if (!done) {
            DbgStatusMesg((_asrinfo, "User hit <ESC> to cancel. Prompting for ASR/ER/RC again\n"));
        }

        if (!SpDrEnabled() || RepairWinnt) {
            SpAsrQueryRepairOrDr();
        }

        if(ForceConsole) {          // Recovery Console
            DbgStatusMesg((_asrinfo, "User chose Recovery Console. Exiting SpDrPtPrepareDisks.\n"));
            return STATUS_SUCCESS;
        }

        DbgStatusMesg((_asrinfo, "User chose %s, sys-drive:[%wc], nt/boot-drive:[%wc]\n",
                    RepairWinnt ? Gbl_RepairWinntFast ? "Fast ER" : "Manual ER" : "ASR",
                    (Gbl_SystemPartitionRegion ? Gbl_SystemPartitionRegion->DriveLetter : L'\\'),
                    (Gbl_BootPartitionRegion ? Gbl_BootPartitionRegion->DriveLetter : L'\\') ));

        //
        // Prompt for ER/ASR floppy
        //
        if (RepairWinnt) {          // ER
            done = SpAsrGetErDiskette(SifHandle);
        }    
        else {                      // ASR
            if (ASRMODE_NORMAL == SpAsrGetAsrMode()) {
                SpInitializePidString(SifHandle, SetupSourceDevicePath, DirectoryOnSetupSource);
            }
            done = SpAsrLoadAsrDiskette();
        }
    } while (!done);


    //
    //  At this point, if RepairWinnt is TRUE, user wants ER, else user 
    //  wants ASR. (If he wanted Recovery Console we would've returned 
    //  STATUS_SUCCESS above.) In either case, the appropriate disk is 
    //  already in the drive
    //
    if (RepairWinnt) {              // ER

        //
        // if the boot partition was not repaired (deleted, recreated, and
        // reformatted), then attempt an emergency repair of the system.
        //
        if (Gbl_NtPartitionIntact == TRUE) {
            
            *RepairedNt = SpAsrAttemptRepair(
                SifHandle,
                SetupSourceDevicePath,
                DirectoryOnSetupSource,
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );
                
            if (*RepairedNt) {
                WinntSetup = FALSE;
            }

            *SystemPartitionRegion = Gbl_SystemPartitionRegion;
            *BootPartitionRegion = Gbl_BootPartitionRegion;
        }
        else {
            //
            // If the NT partition is not intact, we cannot do an ER.
            //
            SpAsrCannotDoER();
            SpDone(0, FALSE, TRUE);
        }
    }
    else {                          // ASR
        SpAsrInitIoDeviceCount();
        SpAsrCheckAsrStateFileVersion();
        SpAsrCreatePartitionSets(setupSourceDevicePath, directoryOnSetupSource);
        Gbl_3rdPartyFileList = SpAsrInit3rdPartyFileList(SetupSourceDevicePath);
        SpAsrDbgDumpPartitionSets();
        SpAsrDeleteMountedDevicesKey();
        SpAsrRemoveMountPoints();     // restored by asr_fmt.exe etc

        //
        // Check hard disks and repartition as needed
        //
        next = TRUE;
        for (diskIndex = 0; diskIndex < HardDiskCount; (diskIndex += (next ? 1 : 0))) {

            BOOLEAN skip = FALSE;

            next = TRUE;
            SpAsrDbgDumpDisk(diskIndex);

            if (!warningScreenDone) {
                skip = SpAsrpSkipDiskRepartition(diskIndex, FALSE);
                if (!skip) {
                    // 
                    // If we are going to repartition a disk, put up the 
                    // warning screen to make sure the user knows all 
                    // partitions on the disk are going to get clobbered, 
                    // but only once - after the first disk with a problem, 
                    // don't display the screen again.
                    //
                    SpAsrClobberDiskWarning();
                    warningScreenDone = TRUE;
                }
            }

            skip = SpAsrpSkipDiskRepartition(diskIndex, TRUE);
            if (!skip) {
                CREATE_DISK CreateDisk;
                PSIF_DISK_RECORD pCurrentDisk = Gbl_PartitionSetTable1[diskIndex]->pDiskRecord;
                PHARD_DISK HardDisk = SPPT_GET_HARDDISK(diskIndex);
                BOOLEAN IsBlank = TRUE;
                BOOLEAN preservePartitions = FALSE;
                UCHAR MbrPartitionType = PARTITION_ENTRY_UNUSED;

                //
                // We're here because the partition structure of the disk does not
                // match with that specified by the SIF file.  As a consequence
                // all of the partitions on this disk will be removed and recreated.
                //
                if (SpPtnGetPartitionCountDisk(diskIndex) || 
                    SpPtnGetContainerPartitionCount(diskIndex)) {
                    //
                    // The physical disk has partitions, clear them
                    //
                    // On GPT disks, we erase all the partitions with the 
                    // exception of the EFI System Partition.  Note that we
                    // delete all foreign/unrecognised partitions as
                    // well.
                    //
                    // For MBR disks, we erase all the partitions with the
                    // exception of any OEM partitions.  Note that as in the
                    // case of GPT disks, we delete unrecognised/foriegn
                    // partitions.
                    // 

                    //
                    // Get the partition type of the first partition on the
                    // sifDisk.  If this is an OEM partition, and the
                    // current disk has a partition with the same exact
                    // partition type, we should preserve it.
                    //
                    if (PARTITION_STYLE_MBR == pCurrentDisk->PartitionStyle) {

                        if (((pCurrentDisk->ContainsNtPartition) 
                                || (pCurrentDisk->ContainsSystemPartition)) &&
                            (pCurrentDisk->PartitionList) &&
                            (pCurrentDisk->PartitionList->First)) {

                            MbrPartitionType = pCurrentDisk->PartitionList->First->PartitionType;
                        }

                        if (IsOEMPartition(MbrPartitionType)) {
                            preservePartitions = TRUE;
                        }

                    }
                    else if (PARTITION_STYLE_GPT == pCurrentDisk->PartitionStyle) {

                        preservePartitions = TRUE;
                    }


                    SpAsrDeletePartitions(diskIndex, preservePartitions, MbrPartitionType, &IsBlank); 
                }

                if (IsBlank) {
                    //
                    // The disk is blank, set the appropriate signature/ID
                    //
                    ZeroMemory(&CreateDisk, sizeof(CREATE_DISK));
                    CreateDisk.PartitionStyle = pCurrentDisk->PartitionStyle;

                    if (PARTITION_STYLE_MBR == pCurrentDisk->PartitionStyle) {
                        CreateDisk.Mbr.Signature = pCurrentDisk->SifDiskMbrSignature;
                    }
                    else if (PARTITION_STYLE_GPT == pCurrentDisk->PartitionStyle) {

                        CopyMemory(&(CreateDisk.Gpt.DiskId), 
                            &(pCurrentDisk->SifDiskGptId), 
                            sizeof(GUID));

                        CreateDisk.Gpt.MaxPartitionCount = pCurrentDisk->MaxGptPartitionCount;
                    }
                    else {
                        ASSERT(0 && L"Unrecognised partition style");
                        continue;
                    }

                    SPPT_SET_DISK_BLANK(diskIndex, TRUE);

                    //
                    // Intialise the disk to the appropriate style
                    //
                    status = SpPtnInitializeDiskStyle(diskIndex, pCurrentDisk->PartitionStyle, &CreateDisk);

                    if (NT_SUCCESS(status)) {
                        status = SpPtnInitializeDiskDrive(diskIndex);
                    }
                }
                else {
                    //
                    // Special case:  the EFI system partition, or some OEM 
                    // partition, was preserved.  We should just update 
                    // the disk GUID or signature.
                    //
                    SpAsrSetNewDiskID(diskIndex, &(pCurrentDisk->SifDiskGptId), pCurrentDisk->SifDiskMbrSignature);
                }

                //
                // Create the new paritions
                //
                SpAsrRecreateDiskPartitions(diskIndex, (preservePartitions && (!IsBlank)), MbrPartitionType);
            }
        }

        SpAsrDbgDumpPartitionLists(2, L"After partition recreation.");

        //
        // Format the Boot partition.  (Always, EXCEPT in automated tests)
        // This won't return if the boot partition region doesn't exist
        //
        *BootPartitionRegion = SpAsrPrepareBootRegion(
            SifHandle,
            setupSourceDevicePath,
            directoryOnSetupSource
            );

        //
        // Format the system partition only if necessary.
        // This won't return if the system partition region doesn't exist
        //
        *SystemPartitionRegion = SpAsrPrepareSystemRegion(
            SifHandle,
            setupSourceDevicePath,
            directoryOnSetupSource
            );

    }  // RepairWinnt

    SpMemFree(setupSourceDevicePath);
    SpMemFree(directoryOnSetupSource);

    DbgStatusMesg((_asrinfo, "Exiting SpDrPtPrepareDisks\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdr.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdr.h

Abstract:

    Header file for Automated System Recovery functions in text-mode setup.

Author:

    Michael Peterson (v-michpe) 13-May-1997
    Guhan Suriyanarayanan (guhans) 21-Aug-1999

Revision History:
    13-May-1997 v-michpe Created file
    21-Aug-1999 guhans   Clean-up

--*/
#ifndef _SPDR_DEFN_
#define _SPDR_DEFN_

typedef enum _ASRMODE {
    ASRMODE_NONE = 0,
    ASRMODE_NORMAL,
    ASRMODE_QUICKTEST_TEXT,
    ASRMODE_QUICKTEST_FULL
} ASRMODE;


//
// Returns the current ASR (Automated System Recovery) mode
//
ASRMODE
SpAsrGetAsrMode(VOID);

//
// Sets the current ASR mode
//
ASRMODE
SpAsrSetAsrMode(
    IN CONST ASRMODE NewAsrMode
    );

//
// Returns TRUE if we're in any of the ASR modes other than ASRMODE_NONE.
//
BOOLEAN
SpDrEnabled(VOID);

//
// Returns TRUE if we're in any of the ASR QuickTest modes.
//
BOOLEAN
SpAsrIsQuickTest(VOID);

//
// Returns TRUE if the user is doing a fast repair
//
BOOLEAN
SpDrIsRepairFast(VOID);

//
// Set or reset the fast-repair flag
//
BOOLEAN
SpDrSetRepairFast(BOOLEAN Value);


//
// Returns the Boot directory
//
PWSTR
SpDrGetNtDirectory(VOID);

PWSTR
SpDrGetNtErDirectory(VOID);


//
// Copies the recovery device drivers (e.g., tape drivers) specified
// in the asr.sif file.  If no device drivers are specified, nothing gets
// copied.  Source media can be Floppy or CDROM.
//
// Also copies asr.sif from the ASR floppy to the %windir%\repair 
// directory.
//
NTSTATUS
SpDrCopyFiles(VOID);


PWSTR
SpDrGetSystemPartitionDirectory(VOID);

//
// Cleanup.  This function removes the "InProgress" flag.
//
VOID
SpDrCleanup(VOID);

//
// This is the main ASR / ER entry point.  
// 
//
NTSTATUS
SpDrPtPrepareDisks(
    IN PVOID SifHandle,
    OUT PDISK_REGION *NtPartitionRegion,
    OUT PDISK_REGION *LoaderPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    OUT BOOLEAN *RepairedNt);


BOOLEAN
SpDoRepair(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource,
    IN PWSTR RepairPath,
    IN PULONG RepairOptions
    );



NTSTATUS
SpDrSetEnvironmentVariables(HANDLE *HiveRootKeys);

extern BOOLEAN DisableER;

__inline
BOOLEAN
SpIsERDisabled(
    VOID
    ) 
{    
    return DisableER;
}    

__inline
VOID
SpSetERDisabled(
    IN BOOLEAN Disable
    )
{
    DisableER = Disable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdrpriv.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrpriv.h

Abstract:
 
    Header file for disaster recovery symbols in text-mode setup.  These
    symbols are not to be referenced by modules other than those in the
    ASR family.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.May.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#pragma once
#if defined(ULONG_MAX) && !defined(_INC_LIMITS)
#undef ULONG_MAX
#endif
#include <limits.h>

#ifndef _SPDRPRIV_DEFN_
#define _SPDRPRIV_DEFN_

///////////////////////////////////////////////////////////////////////////////
//                      Data Types                                           //
///////////////////////////////////////////////////////////////////////////////


//
// For the InstallFiles section, we allow the file to end up on 
// one of the following directories.
//
typedef enum _AsrCopyDirEnum {
    _Temp = 0,
    _Tmp,
    _SystemRoot,
    _Default
} AsrCopyDirEnum;


#define ASR_ALWAYS_PROMPT_FOR_MEDIA     0x00000001
#define ASR_PROMPT_USER_ON_MEDIA_ERROR  0x00000002
#define ASR_FILE_IS_REQUIRED            0x00000004

#define ASR_OVERWRITE_ON_COLLISION      0x00000010
#define ASR_PROMPT_USER_ON_COLLISION    0x00000020



typedef struct _SIF_INSTALLFILE_RECORD {
    struct _SIF_INSTALLFILE_RECORD *Next;
    PWSTR SystemKey;
    PWSTR CurrKey;
    PWSTR SourceMediaExternalLabel;
    PWSTR DiskDeviceName;
    PWSTR SourceFilePath;
    PWSTR DestinationFilePath;
    PWSTR VendorString;
    DWORD Flags;
    AsrCopyDirEnum CopyToDirectory;
} SIF_INSTALLFILE_RECORD, *PSIF_INSTALLFILE_RECORD;

typedef struct _SIF_INSTALLFILE_LIST {

    PSIF_INSTALLFILE_RECORD First;
    ULONG                   Count;

} SIF_INSTALLFILE_LIST, *PSIF_INSTALLFILE_LIST;


typedef struct _SIF_PARTITION_RECORD {

    GUID    PartitionTypeGuid;  // GPT only
    GUID    PartitionIdGuid;    // GPT only

    ULONG64 GptAttributes;      // GPT only

    ULONGLONG   StartSector;
    ULONGLONG   SectorCount;

    ULONGLONG SizeMB;           // value is calculated

    struct _SIF_PARTITION_RECORD *Next;
    struct _SIF_PARTITION_RECORD *Prev;

    PWSTR   PartitionName;  // GPT only

    //
    // This member is valid iff this a boot partition record.  Otherwise, this
    // member is NULL
    //
    PWSTR   NtDirectoryName; 

    PWSTR   CurrPartKey;

    PWSTR   DiskKey;

    PWSTR   VolumeGuid;     // May be NULL

    //
    // If this is a descriptor or container record, then this member
    // refers to the logical disk record it contains.  Otherwise, the
    // value of this member is NULL.  Valid only for MBR partitions.
    //
    PWSTR   LogicalDiskKey;

    //
    // If this is a logical disk partition record, then this member
    // refers to its Descriptor or Container partition record.  Otherwise,
    // the value of this member is NULL.  Valid only for MBR partitions.
    //
    PWSTR   DescriptorKey;

    //
    // This is a bit mask. Valid bits are
    //  1: Boot partition   (ASR_PTN_MASK_BOOT)
    //  2: System partition (ASR_PTN_MASK_SYS)
    //  4: DC1--tbd         (ASR_PTN_MASK_DC1)
    //  8: DC2--tbd         (ASR_PTN_MASK_DC1)
    //
    ULONG   PartitionFlag;

    DWORD ClusterSize;

    DWORD   PartitionTableEntryIndex;

    //
    // GPT or MBR
    //
    PARTITION_STYLE PartitionStyle;
    
    //
    // The values of these members are read directly from the asr.sif file
    //
    UCHAR   PartitionType;  // mbr only
    UCHAR   ActiveFlag;     // mbr only

    UCHAR   FileSystemType;

    BOOLEAN IsPrimaryRecord;

    //
    // These can only be true for MBR partitions.  All GPT partitions are 
    // primary partitions.
    //
    BOOLEAN IsContainerRecord;
    BOOLEAN IsDescriptorRecord;
    BOOLEAN IsLogicalDiskRecord;
    BOOLEAN WillBeAutoextended;

    // Used for dynamic disks. 
    BOOLEAN NeedsLdmRetype;

    BOOLEAN IsAligned;

} SIF_PARTITION_RECORD, *PSIF_PARTITION_RECORD;


typedef struct _SIF_PARTITION_RECORD_LIST {

    ULONGLONG DiskSectorCount;
    ULONGLONG LastUsedSector;
    ULONGLONG TotalMbRequired;

    PSIF_PARTITION_RECORD First;
    PSIF_PARTITION_RECORD Last;
    
    ULONG ElementCount;

} SIF_PARTITION_RECORD_LIST, *PSIF_PARTITION_RECORD_LIST;


typedef struct _SIF_DISK_RECORD {

    GUID        SifDiskGptId;     // Valid only for GPT disks

    ULONGLONG   TotalSectors;

    //
    // The values of these members are calculated from the partition records
    // referencing this disk.  If the disk does not contain an extended
    // partition, then the value of the ExtendedPartitionStartSector is
    // ULONG_MAX and the ExtendedPartitionSectorCount is zero (0).
    //
    ULONGLONG   ExtendedPartitionStartSector;
    ULONGLONG   ExtendedPartitionSectorCount;
    ULONGLONG   ExtendedPartitionEndSector;

    ULONGLONG   LastUsedSector;
    ULONGLONG   LastUsedAlignedSector;

    PSIF_PARTITION_RECORD_LIST  PartitionList;
    
    struct _DISK_PARTITION_SET  *pSetRecord;
    
    //
    // The values of these members are read directly from the asr.sif
    // file.
    //
    PWSTR SystemKey;
    PWSTR CurrDiskKey;

    ULONG SifDiskNumber;

    DWORD BytesPerSector;
    DWORD SectorsPerTrack;
    DWORD TracksPerCylinder;

    ULONG BusKey;

    //
    // This is only valid if this is an MBR disk
    //
    ULONG SifDiskMbrSignature;

    ULONG MaxGptPartitionCount;


    STORAGE_BUS_TYPE BusType;
    //
    // Either an MBR or a GPT Disk
    //
    PARTITION_STYLE PartitionStyle;

    //
    // If this record has been assigned to a partition set, this value
    // is TRUE.  Unassigned disk records are FALSE;
    //
    BOOLEAN Assigned;
    BOOLEAN ContainsSystemPartition;
    BOOLEAN ContainsNtPartition;

    BOOLEAN IsCritical;
    
} SIF_DISK_RECORD, *PSIF_DISK_RECORD;


typedef struct _DISK_PARTITION_SET {
    
    ULONGLONG           ActualDiskSizeMB;

    PSIF_DISK_RECORD    pDiskRecord;
    
    PWSTR               NtPartitionKey;

    ULONG               ActualDiskSignature;
    ULONG               Index;
    
    PARTITION_STYLE     PartitionStyle;
    
    BOOLEAN             PartitionsIntact;
    BOOLEAN             IsReplacementDisk;
    BOOLEAN             IsAligned;

} DISK_PARTITION_SET, *PDISK_PARTITION_SET, **DISK_PARTITION_SET_TABLE;


typedef struct _ASR_PHYSICAL_DISK_INFO { 

    ULONGLONG           TrueDiskSize;       // size of partition0
    
    ULONG               BusKey;             // used for grouping
    DWORD               ControllerNumber;

    STORAGE_BUS_TYPE    BusType;            // scsi, ide, 1394, etc
    UCHAR               PortNumber;

} ASR_PHYSICAL_DISK_INFO, *PASR_PHYSICAL_DISK_INFO;

///////////////////////////////////////////////////////////////////////////////
//                      Macro Declaration Section                            //
///////////////////////////////////////////////////////////////////////////////

#define BYTES_PER_SECTOR(d)         (HardDisks[(d)].Geometry.BytesPerSector)

#define SECTORS_PER_TRACK(disk)     (HardDisks[(disk)].Geometry.SectorsPerTrack)
#define DISK_IS_REMOVABLE(d)        (HardDisks[(d)].Characteristics & FILE_REMOVABLE_MEDIA)

#define STRING_TO_LONG(s)           (SpStringToLong((s),NULL,10))
#define COMPARE_KEYS(k1,k2)         (STRING_TO_LONG(k1) == STRING_TO_LONG(k2))

#define STRING_TO_ULONG(str)        (ULONG) SpAsrStringToULong(str, NULL, 10)
#define STRING_TO_ULONGLONG(str)    (ULONGLONG) SpAsrStringToULongLong(str, NULL, 10)
#define STRING_TO_LONGLONG(str)     (LONGLONG) SpAsrStringToLongLong(str, NULL, 10)
#define STRING_TO_HEX(str)          SpStringToLong(str + 2, NULL, 16)

#define IsRecognizedFatPartition(PartitionType) ( \
    (PartitionType == PARTITION_HUGE) \
    )

#define IsRecognizedFat32Partition(PartitionType) ( \
    (PartitionType == PARTITION_FAT32) \
    )

#define IsRecognizedNtfsPartition(PartitionType) ( \
   (PartitionType == PARTITION_IFS) \
    )


#define INTERNAL_ERROR(msg) \
    SpAsrRaiseInternalError(THIS_MODULE,THIS_MODULE_CODE,__LINE__,msg)

#define BYTES_PER_MB 1048576  // 2^20, or 1024*1024

#define ASR_PTN_MASK_BOOT   1
#define ASR_PTN_MASK_SYS    2
#define ASR_PTN_MASK_DC1    4
#define ASR_PTN_MASK_DC2    8


// 
// Debug Trace Messages
//
#define _asrinfo    DPFLTR_SETUP_ID, ((ASRMODE_NORMAL == SpAsrGetAsrMode()) ? DPFLTR_INFO_LEVEL: DPFLTR_ERROR_LEVEL)
#define _asrwarn    DPFLTR_SETUP_ID, ((ASRMODE_NORMAL == SpAsrGetAsrMode()) ? DPFLTR_WARNING_LEVEL: DPFLTR_ERROR_LEVEL)
#define _asrerr     DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL

#define DbgMesg \
    KdPrintEx((_asrinfo, "      ")); \
    KdPrintEx

#define DbgStatusMesg  \
    KdPrintEx((_asrinfo, "ASR [%ws:%4d] (.) ", THIS_MODULE, __LINE__)); \
    KdPrintEx

#define DbgErrorMesg \
    KdPrintEx((_asrwarn, "ASR [%ws:%4d] (!) ", THIS_MODULE, __LINE__)); \
    KdPrintEx

#define DbgFatalMesg \
    KdPrintEx((_asrerr, "ASR [%ws:%4d] (X) ", THIS_MODULE, __LINE__)); \
    KdPrintEx



///////////////////////////////////////////////////////////////////////////////
//                      Global Variable Declarations                         //
///////////////////////////////////////////////////////////////////////////////


//      Defined in spdrpset.c
DISK_PARTITION_SET_TABLE     Gbl_PartitionSetTable1;
DISK_PARTITION_SET_TABLE     Gbl_PartitionSetTable2;

PVOID Gbl_HandleToDrStateFile;

//      Imported from non-Asr modules
extern WCHAR                        TemporaryBuffer[];


//
PWSTR ASR_SIF_SYSTEM_KEY;


///////////////////////////////////////////////////////////////////////////////
//                      Functions Declaration Section                        //
///////////////////////////////////////////////////////////////////////////////

//
//      Exported from spdrsif.c
//

//
// [VERSION] section functions
//
VOID
SpAsrCheckAsrStateFileVersion();

//
// [SYSTEMS] section functions
//
PWSTR   
SpAsrGetNtDirectoryPathBySystemKey(IN PWSTR SystemKey);

BOOLEAN
SpAsrGetAutoExtend(IN PWSTR SystemKey);

//
// [ASRFLAGS] section functions
//
BOOLEAN
SpAsrGetSilentRepartitionFlag(IN PWSTR SystemKey);

//
// [DISKS.MBR] and [DISKS.GPT] sections functions
//
ULONG   
SpAsrGetMbrDiskRecordCount(VOID);

ULONG   
SpAsrGetGptDiskRecordCount(VOID);

ULONG
SpAsrGetDiskRecordCount();

PWSTR   
SpAsrGetDiskKey(
    IN PARTITION_STYLE Style,   // GPT or MBR
    IN ULONG Index
    );

PSIF_DISK_RECORD
SpAsrGetDiskRecord(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
    );

PSIF_DISK_RECORD    
SpAsrCopyDiskRecord(IN PSIF_DISK_RECORD pInput);

//
// [PARTITIONS.MBR] and [PARTITIONS.GPT] section functions
//
ULONG   
SpAsrGetMbrPartitionRecordCount(VOID);

ULONG   
SpAsrGetGptPartitionRecordCount(VOID);

PWSTR   
SpAsrGetMbrPartitionKey(IN ULONG Index);

PWSTR   
SpAsrGetGptPartitionKey(IN ULONG Index);

PWSTR
SpAsrGetDiskKeyByMbrPartitionKey(IN PWSTR PartitionKey);

PWSTR
SpAsrGetDiskKeyByGptPartitionKey(IN PWSTR PartitionKey);

ULONGLONG
SpAsrGetSectorCountByMbrDiskKey(IN PWSTR DiskKey);

ULONGLONG
SpAsrGetSectorCountByGptDiskKey(IN PWSTR DiskKey);

PSIF_PARTITION_RECORD
SpAsrGetMbrPartitionRecord(IN PWSTR PartitionKey);

PSIF_PARTITION_RECORD
SpAsrGetGptPartitionRecord(IN PWSTR PartitionKey);

PSIF_PARTITION_RECORD   
SpAsrCopyPartitionRecord(IN PSIF_PARTITION_RECORD pInput);

PSIF_PARTITION_RECORD_LIST 
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList);

VOID
SpAsrInsertPartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST   pList,
    IN PSIF_PARTITION_RECORD        pRec
    );


PSIF_PARTITION_RECORD
SpAsrPopNextPartitionRecord(IN PSIF_PARTITION_RECORD_LIST pList);


// [INSTALLFILES] section functions

PSIF_INSTALLFILE_RECORD
SpAsrRemoveInstallFileRecord(IN SIF_INSTALLFILE_LIST *InstallFileList);

VOID
SpAsrDeleteInstallFileRecord(IN OUT PSIF_INSTALLFILE_RECORD pRec);

PSIF_INSTALLFILE_LIST
SpAsrInit3rdPartyFileList(IN PCWSTR SetupSourceDevicePath);


//
//  Exported from spdrpset.c
//

ULONGLONG
SpAsrGetTrueDiskSectorCount(IN ULONG Disk);

VOID
SpAsrCreatePartitionSets(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    );

PDISK_REGION
SpAsrDiskPartitionExists(
    IN ULONG Disk,
    IN PSIF_PARTITION_RECORD pRec
    );

VOID SpAsrDbgDumpPartitionSets(VOID);

VOID SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg);


//
// Exported from spdrmmgr.c
//
NTSTATUS
SpAsrDeleteMountPoint(IN PWSTR PartitionDevicePath);


NTSTATUS
SpAsrSetVolumeGuid(
    IN PDISK_REGION pRegion,
    IN PWSTR VolumeGuid
    );

WCHAR
SpAsrGetPartitionDriveLetter(IN PDISK_REGION pRegion);

NTSTATUS
SpAsrSetPartitionDriveLetter(
    IN  PDISK_REGION    pRegion,
    IN  WCHAR           DriveLetter);

//
//      Exported from spdrutil.c
//

ULONGLONG
SpAsrConvertSectorsToMB(
    IN  ULONGLONG   SectorCount,
    IN  ULONG   BytesPerSector);


PWSTR
SpAsrGetRegionName(IN PDISK_REGION pRegion);

ULONG
SpAsrGetActualDiskSignature(IN ULONG Disk);


PVOID
SpAsrMemAlloc(
    IN  ULONG   Size,
    IN  BOOLEAN IsErrorFatal);

BOOLEAN
SpAsrIsValidBootDrive(PWSTR NtDir);

BOOLEAN
SpAsrIsBootPartitionRecord(IN ULONG CriticalPartitionFlag);

BOOLEAN
SpAsrIsSystemPartitionRecord(IN ULONG CriticalPartitionFlag);

VOID
SpAsrDeleteStorageVolumes();

VOID
SpAsrRaiseFatalError(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr);


VOID
SpAsrRaiseFatalErrorWs(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr
    );

VOID
SpAsrRaiseFatalErrorWsWs(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr1,
    IN  PWSTR   MessagStr2
    );

VOID
SpAsrRaiseFatalErrorWsLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr,
    IN  ULONG   MessagVal
    );

VOID
SpAsrRaiseFatalErrorLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  ULONG   MessagVal
    );

VOID
SpAsrRaiseFatalErrorLuLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  ULONG   MessagVal1,
    IN  ULONG   MessagVal2
    );


BOOL
SpAsrFileErrorDeleteSkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR DestinationFile
    );

BOOL
SpAsrFileErrorRetrySkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR SourceFile,
    IN PWSTR Label,
    IN PWSTR Vendor,
    IN BOOL AllowSkip
    );

VOID
SpAsrRaiseInternalError(
    IN  PWSTR   ModuleName,
    IN  PWSTR   ModuleCode,
    IN  ULONG   LineNumber, 
    IN  PWSTR   KdPrintStr);

ULONGLONG
SpAsrStringToULongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

LONGLONG
SpAsrStringToLongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

ULONG
SpAsrStringToULong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );


VOID
SpAsrGuidFromString(
    IN OUT GUID* Guid,
    IN PWSTR GuidString
    );

BOOLEAN
SpAsrIsZeroGuid(
    IN GUID * Guid
    );

VOID SpAsrDeleteMountedDevicesKey(VOID);

#endif // _SPDRPRIV_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdrpset.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrpset.c

Abstract:

    Contains all routines that create and initialize the partition sets.
    
Terminology

Restrictions:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     21.Aug.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

#include "spdrpriv.h"
#include "ntddscsi.h"
//
// Module identification for debug traces
//
#define THIS_MODULE             L"spdrpset.c"
#define THIS_MODULE_CODE        L"P"

extern PVOID   Gbl_SifHandle;
extern const PWSTR SIF_ASR_MBR_DISKS_SECTION;
extern const PWSTR SIF_ASR_GPT_DISKS_SECTION;
extern const PWSTR SIF_ASR_DISKS_SECTION;
extern const PWSTR SIF_ASR_PARTITIONS_SECTION;

//
// Useful macros
//
#define DISK_SIZE_MB(n)         ((ULONGLONG) HardDisks[(n)].DiskSizeMB)

//
// constants
//
#define ASR_FREE_SPACE_FUDGE_FACTOR_BYTES  (16*1024*1024)
#define ASR_LDM_RESERVED_SPACE_BYTES (1024*1024)

//
// Variables global to this module.  
// These are not referenced outside of spdrpset.c.
//
ULONG                       Gbl_PartitionSetCount;
PSIF_DISK_RECORD            *Gbl_SifDiskTable;
BOOLEAN                     Gbl_AutoExtend;


// used to see if a disk can hold the private region at the end,
// and for bus-groupings
PASR_PHYSICAL_DISK_INFO    Gbl_PhysicalDiskInfo;

//
// Forward declarations
//
VOID SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg);

BOOLEAN
SpAsrDoesListFitOnDisk(
    IN PSIF_DISK_RECORD pDisk,
    IN ULONG DiskIndex,
    OUT BOOLEAN *IsAligned
    );


//
// Function definitions
//
PSIF_PARTITION_RECORD_LIST
SpAsrGetMbrPartitionListByDiskKey(
    IN PWSTR DiskKey
	)
{
    ULONG   numRecords = 0,
            index      = 0;

    PWSTR   diskKeyFromPartitionRec   = NULL,
            partitionKey              = NULL;

    PSIF_PARTITION_RECORD       pRec  = NULL;
    PSIF_PARTITION_RECORD_LIST  pList = NULL;

    ASSERT(DiskKey);

    numRecords = SpAsrGetMbrPartitionRecordCount();  // won't return if count < 1
    ASSERT(numRecords);

    pList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);

    for (index = 0; index < numRecords; index++) {

        partitionKey = SpAsrGetMbrPartitionKey(index);
        if (!partitionKey) {
            ASSERT(0 && L"Partition key is NULL!");
            continue;
        }

        diskKeyFromPartitionRec = SpAsrGetDiskKeyByMbrPartitionKey(partitionKey);
        if (!diskKeyFromPartitionRec) {
            ASSERT(0 && L"Disk key is NULL!");
            partitionKey = NULL;
            continue;
        }

        if (COMPARE_KEYS(diskKeyFromPartitionRec, DiskKey)) {
            //
            // This partition is on this disk
            //
            pRec = SpAsrGetMbrPartitionRecord(partitionKey);

            if (!pRec) {
                ASSERT(0 && L"Partition record is NULL!");
                partitionKey = NULL;
                diskKeyFromPartitionRec = NULL;
                continue;
            }

            SpAsrInsertPartitionRecord(pList, pRec);

            if ((pRec->StartSector + pRec->SectorCount) > pList->LastUsedSector) {
                pList->LastUsedSector = pRec->StartSector + pRec->SectorCount;
            }
        }

        partitionKey = NULL;
        diskKeyFromPartitionRec = NULL;
    }

    if (pList->ElementCount == 0) {

        DbgStatusMesg((_asrinfo, "Disk [%ws] appears to have no partitions\n", DiskKey));
        SpMemFree(pList);
        pList = NULL;

    }
    else {
        //
        // Get the sector count of the disk that this list used to be on
        //
        pList->DiskSectorCount = SpAsrGetSectorCountByMbrDiskKey(DiskKey);

    }
    return pList;
}


PSIF_PARTITION_RECORD_LIST
SpAsrGetGptPartitionListByDiskKey(
    IN PWSTR DiskKey
	)
{
    ULONG   numRecords = 0,
            index      = 0;

    PWSTR   diskKeyFromPartitionRec   = NULL,
            partitionKey              = NULL;

    PSIF_PARTITION_RECORD       pRec  = NULL;
    PSIF_PARTITION_RECORD_LIST  pList = NULL;

    ASSERT(DiskKey);

    numRecords = SpAsrGetGptPartitionRecordCount();  // won't return if count < 1
    ASSERT(numRecords);

    pList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);

    for (index = 0; index < numRecords; index++) {

        partitionKey = SpAsrGetGptPartitionKey(index);
        if (!partitionKey) {
            ASSERT(0 && L"Partition key is NULL!");
            continue;
        }

        diskKeyFromPartitionRec = SpAsrGetDiskKeyByGptPartitionKey(partitionKey);
        if (!diskKeyFromPartitionRec) {
            ASSERT(0 && L"Disk key is NULL!");
            partitionKey = NULL;
            continue;
        }

        if (COMPARE_KEYS(diskKeyFromPartitionRec, DiskKey)) {
            //
            // This partition is on this disk
            //
            pRec = SpAsrGetGptPartitionRecord(partitionKey);

            if (!pRec) {
                ASSERT(0 && L"Partition record is NULL!");
                partitionKey = NULL;
                diskKeyFromPartitionRec = NULL;
                continue;
            }

            SpAsrInsertPartitionRecord(pList, pRec);
            if ((pRec->StartSector + pRec->SectorCount) > pList->LastUsedSector) {
                pList->LastUsedSector = pRec->StartSector + pRec->SectorCount;
            }
        }

        partitionKey = NULL;
        diskKeyFromPartitionRec = NULL;
    }

    if (pList->ElementCount == 0) {

        DbgStatusMesg((_asrinfo, "Disk [%ws] appears to have no partitions\n", DiskKey));
        SpMemFree(pList);
        pList = NULL;

    }
    else {
        //
        // Get the sector count of the disk that this list used to be on
        //
        pList->DiskSectorCount = SpAsrGetSectorCountByGptDiskKey(DiskKey);

    }
    
    return pList;
}


PSIF_PARTITION_RECORD_LIST
SpAsrGetPartitionListByDiskKey(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
	)
{

    switch (PartitionStyle) {
    case PARTITION_STYLE_MBR:
        return SpAsrGetMbrPartitionListByDiskKey(DiskKey);
        break;

    case PARTITION_STYLE_GPT:
        return SpAsrGetGptPartitionListByDiskKey(DiskKey);
        break;
    }

    ASSERT(0 && L"Unrecognised partition style");
    return NULL;
}

//
// Sets the extendedstartsector and extendedsectorcount values.  Only
// makes sense in the context of an MBR disk
//
VOID
SpAsrSetContainerBoundaries(IN ULONG Index)
{
    BOOLEAN hasExtendedPartition = FALSE;
    USHORT consistencyCheck = 0;
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONGLONG extSectorCount = 0,
            extStartSector = -1,
            extEndSector = 0;
    
    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_MBR != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {
        ASSERT(0 && L"SetContainerBoundaries called with invalid Index");
        return;
    }
    
    Gbl_SifDiskTable[Index]->LastUsedSector = 0;
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {

        if ((pRec->StartSector + pRec->SectorCount) > Gbl_SifDiskTable[Index]->LastUsedSector) {
            Gbl_SifDiskTable[Index]->LastUsedSector = pRec->StartSector + pRec->SectorCount;
        }

        //
        // Find the lowest-valued start-sector and highest-valued
        // end-sector of all of the extended (0x05 or 0x0f) partitions.
        //
        if (IsContainerPartition(pRec->PartitionType)) {
            hasExtendedPartition = TRUE;

            if (pRec->StartSector < extStartSector) {
                
                extStartSector = pRec->StartSector;

                if ((pRec->StartSector + pRec->SectorCount) > extEndSector) {
                    extEndSector = pRec->StartSector + pRec->SectorCount;
                }
                else {

                    DbgErrorMesg((_asrwarn,
                        "SpAsrSetContainerBoundaries. Extended partition with lowest SS (%ld) does not have highest EndSec (This EndSec: %ld, Max EndSec: %ld)\n",
                        extStartSector, 
                        extStartSector+pRec->SectorCount, 
                        extEndSector
                        ));
                    
                    ASSERT(0 && L"Extended partition with lowest SS does not have highest EndSec");
                }
            }

            if ((pRec->StartSector + pRec->SectorCount) > extEndSector) {
                
                DbgErrorMesg((_asrwarn,
                    "SpAsrSetContainerBoundaries. Extended partition with highest EndSec (%ld) does not have lowest SS (this SS:%ld, MaxEndSec:%ld, LowestSS: %ld)\n",
                    pRec->StartSector + pRec->SectorCount, 
                    pRec->StartSector,
                    extEndSector,
                    extStartSector
                    ));
                
                ASSERT(0 && L"Extended partition with highest EndSec does not have lowest SS");
            }
        }

        pRec = pRec->Next;
    }
    extSectorCount = extEndSector - extStartSector;
    //
    // Update the table for the disk
    //
    if (!hasExtendedPartition) {
        Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector = -1;
        Gbl_SifDiskTable[Index]->ExtendedPartitionSectorCount = 0;
        Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector   = -1;
        return;
    }
    Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector = extStartSector;
    Gbl_SifDiskTable[Index]->ExtendedPartitionSectorCount = extSectorCount;
    Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector   = extEndSector;
    // 
    // Mark the container partition
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;
    while (pRec) {
        pRec->IsContainerRecord = FALSE;

        if (pRec->StartSector == extStartSector) {
            consistencyCheck++;

            ASSERT((consistencyCheck == 1) && L"Two partitions start at the same sector");

            pRec->IsContainerRecord = TRUE;
            pRec->IsDescriptorRecord = FALSE;
            pRec->IsLogicalDiskRecord = FALSE;
            pRec->IsPrimaryRecord = FALSE;
        }
        pRec = pRec->Next;
    }
}


VOID
SpAsrDetermineMbrPartitionRecordTypes(IN ULONG Index)
{
    
    PSIF_PARTITION_RECORD pRec = NULL,
        pLogical = NULL,
        pDescr = NULL;

    ULONGLONG extStartSector = 0, 
        extEndSector = 0;

    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_MBR != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {

        ASSERT(0 && L"DetermineMbrPartitionRecordTypes called with invalid Index");
        return;
    }

    extStartSector = Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector;
    extEndSector  = Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector;

    //
    // Check for descriptor, logical or primary
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {

        //
        // To start off, assume it's none of the recognised types
        //
        pRec->IsDescriptorRecord = FALSE;
        pRec->IsLogicalDiskRecord = FALSE;
        pRec->IsPrimaryRecord = FALSE;

        if (IsContainerPartition(pRec->PartitionType)) {
            //
            // Extended partition: this is either the container 
            // or a descriptor partition record.
            //
            if (pRec->StartSector != extStartSector) {

                ASSERT(pRec->StartSector > extStartSector);
                ASSERT(FALSE == pRec->IsContainerRecord); // should've been marked above

                pRec->IsContainerRecord = FALSE; // just in case
                //
                // Not the container, so it must be a descriptor partition record.
                //
                pRec->IsDescriptorRecord = TRUE;
            }  
        }
        else {  

            ASSERT(FALSE == pRec->IsContainerRecord); // should've been marked above
            pRec->IsContainerRecord = FALSE; // just in case

            //
            // Not an extended partition. It's a primary record if its 
            // StartSector lies outside of the container partition's 
            // boundaries. Otherwise, it's a logical disk partition record.
            //
            if (pRec->StartSector < extStartSector ||
                pRec->StartSector >= extEndSector) {
                pRec->IsPrimaryRecord = TRUE;
            }
            else {
                pRec->IsLogicalDiskRecord = TRUE;
            }
        }
        pRec = pRec->Next;
    }

    //
    // -guhans! this is O(n-squared)
    // Next, loop through the list once more and, for each logical disk 
    // record, find its descriptor partition.  For each descriptor partition
    // find its logical disk.  NB: All logical disk records will have a
    // descriptor record.  All descriptor records will have a logical disk
    // record.
    //
    // To determine this we make use of the observation that a logical disk
    // record's start sector and sector count have the following relationship
    // to its descriptor partition:
    //
    // Logical Disk Record          Descriptor Record
    //
    //  Start Sector        >=       Start Sector
    //  Sector Count        <=       Sector Count
    //
    // NB: In most cases, the container partition record also acts as a 
    // descriptor partition record for the first logical disk in the extended 
    // partition.
    //
    pLogical = Gbl_SifDiskTable[Index]->PartitionList->First;
    while (pLogical) {
        //
        // we're only interested in logical disks.
        //
        if (pLogical->IsLogicalDiskRecord) {
            //
            // Determine the descriptor record describing pLogical and vice versa.
            //
            pDescr = Gbl_SifDiskTable[Index]->PartitionList->First;
            while (pDescr) {
                //
                // skip this record itself.
                //
                if (pLogical == pDescr) {
                    pDescr = pDescr->Next;
                    continue;
                }
                //
                // skip primary or logical disk records.
                //
                if (pDescr->IsPrimaryRecord || pDescr->IsLogicalDiskRecord) {
                    pDescr = pDescr->Next;
                    continue;
                }
                //
                // At this point, the record describes a container or a descriptor
                // partition.  If the end sectors match, we this is the descriptor
                // record for our logical rec.
                //
                if ((pLogical->StartSector + pLogical->SectorCount) == 
                    (pDescr->StartSector   + pDescr->SectorCount)) {

                    pLogical->DescriptorKey = pDescr->CurrPartKey;
                    pDescr->LogicalDiskKey = pLogical->CurrPartKey;
            
                    break;
                }

                pDescr = pDescr->Next;
            }

        }
        pLogical = pLogical->Next;
    }
}


VOID
SpAsrDetermineGptPartitionRecordTypes(IN ULONG Index)
{

    PSIF_PARTITION_RECORD pRec = NULL;

    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_GPT != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {

        ASSERT(0 && L"DetermineGptPartitionRecordTypes called with invalid Index");
        return;
    }

    //
    // Check for descriptor, logical or primary
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {
        //
        // All GPT partitions are "primary"
        //
        pRec->IsContainerRecord = FALSE; 
        pRec->IsDescriptorRecord = FALSE;
        pRec->IsLogicalDiskRecord = FALSE;

        pRec->IsPrimaryRecord = TRUE;

        pRec = pRec->Next;
    }
}

VOID
SpAsrDeterminePartitionRecordTypes(IN ULONG Index)
{
    switch (Gbl_SifDiskTable[Index]->PartitionStyle) {
    case PARTITION_STYLE_MBR:
        SpAsrDetermineMbrPartitionRecordTypes(Index);
        break;

    case PARTITION_STYLE_GPT:
        SpAsrDetermineGptPartitionRecordTypes(Index);
        break;

    default:
        ASSERT(0 && L"Unrecognised partition style");
        break;
    }
}


VOID
SpAsrSetDiskSizeRequirement(IN ULONG Index)
{
    PSIF_PARTITION_RECORD_LIST pList = NULL;
    PSIF_PARTITION_RECORD pRec = NULL;

    ASSERT(Gbl_SifDiskTable[Index]);
    
    pList = Gbl_SifDiskTable[Index]->PartitionList;
    if (!pList) {
        return;
    }

    pRec = pList->First;
    pList->TotalMbRequired = 0;
    
    while (pRec) {
        //
        // No need to sum the disk requirements of the descriptor and
        // logical disk partition records.
        //
        // In a GPT disk, all partitions are primary.
        //
        if (pRec->IsContainerRecord || pRec->IsPrimaryRecord) {
            pList->TotalMbRequired += pRec->SizeMB;
        }

        pRec = pRec->Next;
    }
}


VOID
SpAsrInitSifDiskTable(VOID)
{
    LONG count = 0,
        index = 0,
        mbrDiskRecordCount = 0,
        gptDiskRecordCount = 0;
    
    PWSTR diskKey = NULL,
        systemKey = ASR_SIF_SYSTEM_KEY;

    PSIF_DISK_RECORD pCurrent = NULL;

    BOOLEAN done = FALSE;

    Gbl_AutoExtend = SpAsrGetAutoExtend(systemKey);

    //
    // Allocate the array for the disk records.
    //
    mbrDiskRecordCount  = (LONG) SpAsrGetMbrDiskRecordCount();
    gptDiskRecordCount  = (LONG) SpAsrGetGptDiskRecordCount();
    if ((mbrDiskRecordCount + gptDiskRecordCount) <= 0) {
        //
        // We need at least one disk in asr.sif
        //
		SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
			L"No records in the disks sections",
			SIF_ASR_DISKS_SECTION
            );
    }

    Gbl_SifDiskTable = SpAsrMemAlloc(sizeof(PSIF_DISK_RECORD) * (mbrDiskRecordCount + gptDiskRecordCount), TRUE);

    //
    // Get each MBR disk's partition list from the sif.
    //
    for (count = 0; count < mbrDiskRecordCount; count++) {
        
        diskKey = SpAsrGetDiskKey(PARTITION_STYLE_MBR, count);
        if (!diskKey) {
            ASSERT(0 && L"Disk key is NULL!");
            continue;
        }

        pCurrent = SpAsrGetDiskRecord(PARTITION_STYLE_MBR, diskKey);
        if (!pCurrent) {
            ASSERT(0 && L"Disk Record is NULL!");
            continue;
        }

        //
        // Determine the index where this record is to be added.
        //
        index = count - 1;  // last entry added so far
        done = FALSE;
        while ((index >= 0) && (!done)) {
            if (Gbl_SifDiskTable[index]->TotalSectors > pCurrent->TotalSectors) {
                Gbl_SifDiskTable[index+1] = Gbl_SifDiskTable[index];
                --index;
            }
            else {
                done = TRUE;
            }
        }
        ++index;

        Gbl_SifDiskTable[index] = pCurrent;

        Gbl_SifDiskTable[index]->Assigned = FALSE;
        Gbl_SifDiskTable[index]->ContainsNtPartition = FALSE;
        Gbl_SifDiskTable[index]->ContainsSystemPartition = FALSE;
        //
        // Get the partitions on this disk.
        //
        Gbl_SifDiskTable[index]->PartitionList = SpAsrGetPartitionListByDiskKey(PARTITION_STYLE_MBR, diskKey);

        if (Gbl_SifDiskTable[index]->PartitionList) {
            //
            // Set the extended partition record boundaries, if any.
            //
            SpAsrSetContainerBoundaries(index);
            //
            // Walk the partition list and determine the type of each
            // partition record (i.e., IsDescriptorRecord, IsPrimaryRecord, 
            // IsLogicalDiskRecord).
            //
            SpAsrDeterminePartitionRecordTypes(index);
            //
            // Set the SizeMB member
            //
            SpAsrSetDiskSizeRequirement(index);
        }
    }

    //
    // Repeat for GPT disks.
    //
    for (count = 0; count < gptDiskRecordCount; count++) {
        
        diskKey = SpAsrGetDiskKey(PARTITION_STYLE_GPT, count);
        if (!diskKey) {
            ASSERT(0 && L"Disk key is NULL!");
            continue;
        }

        pCurrent = SpAsrGetDiskRecord(PARTITION_STYLE_GPT, diskKey);
        if (!pCurrent) {
            ASSERT(0 && L"Disk Record is NULL!");
            continue;
        }

        //
        // Determine the index where this record is to be added.
        //
        index = mbrDiskRecordCount + count - 1;  // last entry added so far
        done = FALSE;
        while ((index >= 0) && (!done)) {
            if (Gbl_SifDiskTable[index]->TotalSectors > pCurrent->TotalSectors) {
                Gbl_SifDiskTable[index+1] = Gbl_SifDiskTable[index];
                --index;
            }
            else {
                done = TRUE;
            }
        }
        ++index;

        Gbl_SifDiskTable[index] = pCurrent;

        Gbl_SifDiskTable[index]->Assigned = FALSE;
        Gbl_SifDiskTable[index]->ContainsNtPartition = FALSE;
        Gbl_SifDiskTable[index]->ContainsSystemPartition = FALSE;
        //
        // Get the partitions on this disk.
        //
        Gbl_SifDiskTable[index]->PartitionList = SpAsrGetPartitionListByDiskKey(PARTITION_STYLE_GPT, diskKey);

        if (Gbl_SifDiskTable[index]->PartitionList) {

            //
            // Mark all partitions as primary
            //
            SpAsrDeterminePartitionRecordTypes(index);
            //
            // Set the SizeMB member
            //
            SpAsrSetDiskSizeRequirement(index);
        }
    }
}


NTSTATUS
SpAsrGetPartitionInfo(
    IN  PWSTR                   PartitionPath,
    OUT PARTITION_INFORMATION  *PartitionInfo
    )
{
    NTSTATUS         status          = STATUS_SUCCESS;
    HANDLE           partitionHandle = NULL;
    IO_STATUS_BLOCK  ioStatusBlock;

    //
    // Open partition0 of the disk. This should always succeed.
    // Partition 0 is an alias for the entire disk.
    //
    status = SpOpenPartition0(
        PartitionPath,
        &partitionHandle,
        FALSE
        );

    if (!NT_SUCCESS(status)) {

        DbgErrorMesg((_asrerr,
            "SpAsrGetPartitionInfo. SpOpenPartition0 failed for [%ws]. (0x%lx)\n" ,
            PartitionPath,
            status));

        ASSERT(0 && L"SpOpenPartition0 failed");
        return status;
    }

    //
    // Use the Partition0 handle to get a PARTITION_INFORMATION structure.
    //
    status = ZwDeviceIoControlFile(
        partitionHandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO,
        NULL,
        0,
        PartitionInfo,
        sizeof(PARTITION_INFORMATION)
        );
    ZwClose(partitionHandle);

    if(!NT_SUCCESS(status)) {
        
        DbgErrorMesg((_asrerr,
            "IOCTL_DISK_GET_PARTITION_INFO failed for [%ws]. (0x%lx)\n", 
            PartitionPath, 
            status
            ));
        
//        ASSERT(0 && L"IOCTL_DISK_GET_PARTITION_INFO failed");
    }

    return status;
}


ULONGLONG
SpAsrGetTrueDiskSectorCount(IN ULONG Disk)
/*++

  Description:
    Gets the sector count of this disk by using the PARTITION_INFORMATION structure
    obtained by using the disk's device name in the IOCTL_GET_PARTITION_INFO ioct.

  Arguments:
    Disk    The physical number of the disk whose sectors are to be obtained.

  Returns:
        The total number of sectors on this disk.
--*/
{
    NTSTATUS status     = STATUS_SUCCESS;
    PWSTR devicePath    = NULL;
    ULONGLONG sectorCount = 0;
    PARTITION_INFORMATION partitionInfo;

    swprintf(TemporaryBuffer, L"\\Device\\Harddisk%u", Disk);
    devicePath = SpDupStringW(TemporaryBuffer);

    status = SpAsrGetPartitionInfo(devicePath, &partitionInfo);

    if (!NT_SUCCESS(status)) {

        DbgFatalMesg((_asrerr, 
            "Could not get true disk size (0x%x). devicePath [%ws], Disk %lu\n", 
            status, devicePath, Disk));

        swprintf(TemporaryBuffer, L"Failed to get partition info for %ws", devicePath);
        sectorCount = 0;
    }

    else {
        sectorCount = (ULONGLONG) (partitionInfo.PartitionLength.QuadPart / BYTES_PER_SECTOR(Disk));
    }
    
    SpMemFree(devicePath);
    return sectorCount;
}


VOID
DetermineBuses() 
{

    HANDLE handle = NULL;
    PWSTR devicePath = NULL;
    ULONG physicalIndex = 0;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;
    STORAGE_PROPERTY_QUERY propertyQuery;
    STORAGE_DEVICE_DESCRIPTOR deviceDesc;
    DISK_CONTROLLER_NUMBER ControllerInfo;
    SCSI_ADDRESS scsiAddress;
    BOOLEAN newBus, done;
    DWORD targetController;
    ULONG targetBusKey;
    UCHAR targetPort;

    //
    // 
    //
    for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

        Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber = (DWORD) (-1);
        Gbl_PhysicalDiskInfo[physicalIndex].PortNumber = (UCHAR) (-1);
        Gbl_PhysicalDiskInfo[physicalIndex].BusKey = 0;
        Gbl_PhysicalDiskInfo[physicalIndex].BusType = BusTypeUnknown;
        //
        // Get a handle to the disk by opening partition 0 
        //
        swprintf(TemporaryBuffer, L"\\Device\\Harddisk%u", physicalIndex);
        devicePath = SpDupStringW(TemporaryBuffer);

        status = SpOpenPartition0(devicePath, &handle, FALSE);

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn,
                "DetermineBuses: SpOpenPartition0 failed for [%ws]. (0x%lx) Assumed to be unknown bus.\n" ,
                devicePath, status));

            ASSERT(0 && L"SpOpenPartition0 failed, assuming unknown bus");
            continue;
        }

        //
        // We have a handle to the disk now.  Get the controller number.
        //
        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_DISK_CONTROLLER_NUMBER,
            NULL,
            0,
            &ControllerInfo,
            sizeof(DISK_CONTROLLER_NUMBER)
            );

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn,
                "DetermineBuses: Couldn't get controller number for [%ws]. (0x%lx)\n" ,
                devicePath,
                status
                ));

        }
        else {
            Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber = ControllerInfo.ControllerNumber;
        }

        //
        // Figure out the bus that this disk is on. 
        //
        propertyQuery.QueryType     = PropertyStandardQuery;
        propertyQuery.PropertyId    = StorageDeviceProperty;

        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_STORAGE_QUERY_PROPERTY,
            &propertyQuery,
            sizeof(STORAGE_PROPERTY_QUERY),
            &deviceDesc,
            sizeof(STORAGE_DEVICE_DESCRIPTOR)
            );
        if (NT_SUCCESS(status)) {
            Gbl_PhysicalDiskInfo[physicalIndex].BusType = deviceDesc.BusType;
        }
        else {
           DbgErrorMesg((_asrwarn,
                "DetermineBuses: Couldn't get bus type for [%ws]. (0x%lx)\n" ,
                devicePath,
                status
                ));
        }

        //
        // Try to get the scsi address.  This will fail for non-SCSI/IDE disks.
        //
        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_SCSI_GET_ADDRESS,
            NULL,
            0,
            &scsiAddress,
            sizeof(SCSI_ADDRESS)
            );
        if (NT_SUCCESS(status)) {
            Gbl_PhysicalDiskInfo[physicalIndex].PortNumber = scsiAddress.PortNumber;
        }

        SpMemFree(devicePath);
        ZwClose(handle);
    }


    //
    // Now we have the controller number and scsi port info for each of the disks
    // Group the disks based on this.
    //
    targetBusKey = 0;
    newBus = TRUE; done = FALSE;
    while (!done) {

        newBus = TRUE;
        
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

            if (newBus) {
                if (!(Gbl_PhysicalDiskInfo[physicalIndex].BusKey)) {
                    //
                    // This disk doesn't have a bus key yet.
                    //
                    newBus = FALSE;
                    ++targetBusKey; // we found a new bus

                    targetController = Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber;
                    targetPort = Gbl_PhysicalDiskInfo[physicalIndex].PortNumber;
                    Gbl_PhysicalDiskInfo[physicalIndex].BusKey = targetBusKey;
                }

            }
            else {
                if ((Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber == targetController) &&
                    (Gbl_PhysicalDiskInfo[physicalIndex].PortNumber == targetPort)) {
                    Gbl_PhysicalDiskInfo[physicalIndex].BusKey = targetBusKey;
               }
            }
        }

        if (newBus) {
            //
            // We went through the entire table without finding even a single disk
            // with BusKey = 0, ie, we've assigned BusKeys to all of them.
            //
            done = TRUE;
        }
    }
}


//
// Sets the disk sizes by getting info about partition 0
//
VOID
SpAsrInitPhysicalDiskInfo() 
{
    ULONG index = 0;
    IO_STATUS_BLOCK IoStatusBlock;
    DISK_CONTROLLER_NUMBER ControllerInfo;
    ULONGLONG TrueSectorCount = 0;


    Gbl_PhysicalDiskInfo = SpAsrMemAlloc((sizeof(ASR_PHYSICAL_DISK_INFO) * HardDiskCount), TRUE);

    DbgStatusMesg((_asrinfo, "Setting true disk sizes:\n"));

    for (index = 0; index < HardDiskCount; index++) {


        TrueSectorCount = SpAsrGetTrueDiskSectorCount(index);
        if (0 == TrueSectorCount) {
            Gbl_PhysicalDiskInfo[index].TrueDiskSize = HardDisks[index].DiskSizeSectors;
        }
        else {
            Gbl_PhysicalDiskInfo[index].TrueDiskSize = TrueSectorCount;
        }
    
        DbgStatusMesg((_asrinfo,
            "Disk %lu: %I64u sectors\n", 
            index, 
            Gbl_PhysicalDiskInfo[index].TrueDiskSize
            ));


    }

    //
    // Now determine the bus-topology of the disks.  This will be used later when
    // we're trying to find a match for the sif-disks.
    //
    DetermineBuses();

} // SpAsrInitPhysicalDiskInfo


VOID
SpAsrAllocateGblPartitionSetTable(VOID)
{
    ULONG size;

    //
    // Allocate memory for the partition set table.  One entry
    // for each physical disk attached to the system, including
    // removable disks (e.g., Jaz).  NB: HardDiskCount does not
    // include CDROMs.
    //
    size = sizeof(PDISK_PARTITION_SET) * HardDiskCount;
    Gbl_PartitionSetTable1 = SpAsrMemAlloc(size, TRUE);
}


VOID
SpAsrFreePartitionRecord(IN PSIF_PARTITION_RECORD pRec)
{
    if (pRec) {

        if (pRec->NtDirectoryName) {
            SpMemFree(pRec->NtDirectoryName);
        }

        SpMemFree(pRec);
    }
}


VOID
SpAsrFreePartitionList(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD pRec;

    if (!pList) {
        return;
    }

    while (pRec = SpAsrPopNextPartitionRecord(pList)) {
        SpAsrFreePartitionRecord(pRec);
    }
    
    SpMemFree(pList);
}


VOID
SpAsrFreePartitionDisk(IN PSIF_DISK_RECORD pDisk)
{
    if (!pDisk) {
        return;
    }

    if (pDisk->PartitionList) {
        SpAsrFreePartitionList(pDisk->PartitionList);
    }

    SpMemFree(pDisk);
}


VOID
SpAsrFreePartitionSet(IN PDISK_PARTITION_SET pSet)
{
    if (!pSet) {
        return;
    }
    
    if (pSet->pDiskRecord) {
    
        if (pSet->pDiskRecord->PartitionList) {
            SpAsrFreePartitionList(pSet->pDiskRecord->PartitionList);
        }

        SpMemFree(pSet->pDiskRecord);
        pSet->pDiskRecord = NULL;

    }

    SpMemFree(pSet);
    pSet = NULL;
}



VOID
SpAsrFreePartitionSetTable(IN DISK_PARTITION_SET_TABLE Table)
{
    ULONG index;
    
    if (!Table) {
        return;
    }

    for (index = 0; index < HardDiskCount; index++) {            
        if (Table[index]) {
            SpAsrFreePartitionSet(Table[index]);
        }
    }

    SpMemFree(Table);
    Table = NULL;
}


PDISK_PARTITION_SET
SpAsrCopyPartitionSet(IN PDISK_PARTITION_SET pSetOriginal)
{
    PDISK_PARTITION_SET pSetNew;

    if (!pSetOriginal) {
        return NULL;
    }

    pSetNew = SpAsrMemAlloc(sizeof(DISK_PARTITION_SET), TRUE);
    pSetNew->ActualDiskSignature = pSetOriginal->ActualDiskSignature;
    pSetNew->PartitionsIntact = pSetOriginal->PartitionsIntact;
    pSetNew->IsReplacementDisk = pSetOriginal->IsReplacementDisk;
    pSetNew->NtPartitionKey = pSetOriginal->NtPartitionKey;

    if (pSetOriginal->pDiskRecord == NULL) {
        pSetNew->pDiskRecord = NULL;
    }
    else {
        pSetNew->pDiskRecord = SpAsrCopyDiskRecord(pSetOriginal->pDiskRecord);
        pSetNew->pDiskRecord->pSetRecord = pSetNew;
    }

    return pSetNew;
}


DISK_PARTITION_SET_TABLE
SpAsrCopyPartitionSetTable(IN DISK_PARTITION_SET_TABLE SrcTable)
{
    ULONG index = 0;
    DISK_PARTITION_SET_TABLE destTable = NULL;
    PSIF_PARTITION_RECORD_LIST pList = NULL;

    if (!SrcTable) {
        ASSERT(0 && L"SpAsrCopyPartitionSetTable: Copy failed, source partition table is NULL.");
        return NULL;
    }
        
    destTable = SpAsrMemAlloc(sizeof(PDISK_PARTITION_SET) * HardDiskCount, TRUE);

    for (index = 0; index < HardDiskCount; index++) {

        if (SrcTable[index]) {
            destTable[index] = SpAsrCopyPartitionSet(SrcTable[index]);
        }
        else {
            destTable[index] = NULL;
        }
    }
    
    return destTable;
}  // SpAsrCopyPartitionSetTable


BOOLEAN
PickABootPartition(
    IN OUT PSIF_PARTITION_RECORD    pCurrent,
    IN OUT PSIF_PARTITION_RECORD    pNew
    )
{

    ASSERT(pCurrent && pNew);
    
    // 
    // They must both be marked boot or sys.
    //
    ASSERT(SpAsrIsBootPartitionRecord(pCurrent->PartitionFlag)
            && SpAsrIsBootPartitionRecord(pNew->PartitionFlag));


    //
    // If this is a mirrored partition, then the volume guids must
    // be the same.  And they should be on different spindles.  But
    // in the interests of being nice to the user, we don't enforce this
    // here, we just ASSERT.
    //
    // We pick one of the two partitions marked as boot, based on:
    // 1.  If one of the partitions is marked active and the other isn't,
    // we use the active partition.
    // 2.  If they are of different sizes, we pick the smaller partition
    // since we don't want to mirror a partition to a smaller one.
    // 3.  Just pick the first one.
    //
    ASSERT(wcscmp(pCurrent->VolumeGuid, pNew->VolumeGuid) == 0);
    ASSERT(wcscmp(pCurrent->DiskKey, pNew->DiskKey) != 0);

    //
    // 1. Check active flags
    //
    if ((pCurrent->ActiveFlag) && (!pNew->ActiveFlag)) {
        //
        // pCurrent is marked active and pNew isn't
        //
        pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
        return FALSE;
    }

    if ((!pCurrent->ActiveFlag) && (pNew->ActiveFlag)) {
        //
        // pNew is marked active and pCurrent isn't
        //
        pCurrent->PartitionFlag -= ASR_PTN_MASK_BOOT;
        return TRUE;    // new boot ptn rec
    }

    //
    // 2. Check sizes
    //
    if (pCurrent->SizeMB != pNew->SizeMB) {
        if (pCurrent->SizeMB > pNew->SizeMB) {
            //
            // pNew is smaller, so that becomes the new boot ptn
            //
            pCurrent->PartitionFlag -= ASR_PTN_MASK_BOOT;
            return TRUE;
        } 
        else {
            //
            // pCurrent is smaller, so that is the boot ptn
            //
            pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
            return FALSE;
        }
    }

    //
    // 3. Just pick the first (pCurrent)
    //
    pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
    return FALSE;
}


BOOLEAN
PickASystemPartition(
    IN PSIF_PARTITION_RECORD    FirstPartition,
    IN PSIF_DISK_RECORD         FirstDisk,
    IN PSIF_PARTITION_RECORD    SecondPartition,
    IN PSIF_DISK_RECORD         SecondDisk,
    IN CONST DWORD              CurrentSystemDiskNumber,
    IN CONST BOOL               BootSameAsSystem
    )
{

    PHARD_DISK CurrentSystemDisk = NULL;
    BOOLEAN IsAligned = TRUE;

    if (CurrentSystemDiskNumber != (DWORD)(-1)) {
        CurrentSystemDisk = &HardDisks[CurrentSystemDiskNumber];
    }

    ASSERT(FirstPartition && SecondPartition);
    ASSERT(FirstDisk && SecondDisk);
    
    // 
    // They must both be marked system
    //
    ASSERT(SpAsrIsSystemPartitionRecord(FirstPartition->PartitionFlag)
            && SpAsrIsSystemPartitionRecord(SecondPartition->PartitionFlag));

    //
    // If this is a mirrored partition, then the volume guids must
    // be the same.  And they should be on different spindles.  But
    // in the interests of being nice to the user, we don't enforce this
    // here, we just ASSERT.
    //
    ASSERT(wcscmp(FirstPartition->VolumeGuid, SecondPartition->VolumeGuid) == 0);
    ASSERT(wcscmp(FirstPartition->DiskKey, SecondPartition->DiskKey) != 0);

    // 
    // If the partitioning style of either disk is different from the 
    // current system disk (very unlikely) then we should pick the other
    //
    if ((CurrentSystemDisk) && 
        ((PARTITION_STYLE)CurrentSystemDisk->DriveLayout.PartitionStyle != SecondDisk->PartitionStyle)
        ) {
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    if ((CurrentSystemDisk) &&
        (PARTITION_STYLE)CurrentSystemDisk->DriveLayout.PartitionStyle != FirstDisk->PartitionStyle) {
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        
        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return TRUE;
    }

    //
    // All three have the same partitioning style.  Check signatures/GUID.
    //
    if (PARTITION_STYLE_MBR == FirstDisk->PartitionStyle) {

        if ((CurrentSystemDisk) && 
           (CurrentSystemDisk->DriveLayout.Mbr.Signature == FirstDisk->SifDiskMbrSignature)) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }
            
            return FALSE;
        }

        if ((CurrentSystemDisk) &&
            (CurrentSystemDisk->DriveLayout.Mbr.Signature == SecondDisk->SifDiskMbrSignature)) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
            
            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        }
    }
    else if (PARTITION_STYLE_GPT == FirstDisk->PartitionStyle) {

        if ((CurrentSystemDisk) && 
            !RtlCompareMemory(
                &(CurrentSystemDisk->DriveLayout.Gpt.DiskId),
                &(FirstDisk->SifDiskGptId), 
                sizeof(GUID)
            )) {

            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
        
        if (!RtlCompareMemory(
            &(CurrentSystemDisk->DriveLayout.Gpt.DiskId), 
            &(SecondDisk->SifDiskGptId), 
            sizeof(GUID)
            )) {

            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        }

    }
    else {
        ASSERT(0 && L"Unrecognised partition style found");

        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    //
    // The signatures didn't match.  Now try to see which might be a better fit
    //    
        

    //
    // Else, look for the better fit of the two disks.
    // 
    if ((!SpAsrDoesListFitOnDisk(SecondDisk, CurrentSystemDiskNumber, &IsAligned)) || 
        (!IsAligned)
        ) {
        //
        // The current system disk isn't big enough to hold the partitions
        // on the second disk, so return the first disk as our chosen one.
        //
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }


    if ((!SpAsrDoesListFitOnDisk(FirstDisk, CurrentSystemDiskNumber,  &IsAligned)) ||
        (!IsAligned)
        ) {
        //
        // The current system disk isn't big enough to hold the partitions
        // on the first disk, so return the second disk as our chosen one.
        //
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        
        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }


        return TRUE;
    }

    //
    // The current system disk is big enough to hold either of the two
    // disks we're trying to decide between.
    //

    //
    // Check active flags
    //
    if ((FirstPartition->ActiveFlag) && (!SecondPartition->ActiveFlag)) {
        //
        // FirstPartition is marked active and SecondPartition isn't
        //
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    if ((!FirstPartition->ActiveFlag) && (SecondPartition->ActiveFlag)) {
        //
        // SecondPartition is marked active and FirstPartition isn't
        //
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return TRUE;    // new sys ptn rec
    }

    //
    // Check sizes
    //
    if (FirstPartition->SizeMB != SecondPartition->SizeMB) {
        if (FirstPartition->SizeMB > SecondPartition->SizeMB) {
            //
            // SecondPartition is smaller, so that becomes the new system ptn
            //
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        } 
        else {
            //
            // FirstPartition is smaller, so that is the system ptn
            //
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
    }

    //
    // Check sizes of the original disks
    //
    if (FirstDisk->TotalSectors != SecondDisk->TotalSectors) {
        if (FirstDisk->TotalSectors > SecondDisk->TotalSectors) {
            // 
            // First disk used to be bigger than the second (and
            // fits in our current system disk), so pick that
            //
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
        else {
            // 
            // Second disk used to be bigger than the first (and
            // fits in our current system disk), so pick that
            //
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;    // new sys ptn rec
        }
    }

    //
    // Just pick the first (FirstPartition)
    //
    SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
    if (BootSameAsSystem) {
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
    }

    return FALSE;

}


//
// This sets the "NeedsLdmRetype" flag to true for all the partitions on
// the system/boot disk, if the system/boot partition is of an 
// unrecognised partition type.  We need to do this because we can't install
// to unrecognised partition types.
//
VOID
MarkPartitionLdmRetypes(
    PSIF_PARTITION_RECORD pPartition,   // system/boot partition
    PSIF_PARTITION_RECORD pFirst        // first partition rec on the sys/boot disk
    )
{
    PSIF_PARTITION_RECORD pPtnRec = pFirst;

    //
    // Make sure it's an MBR or a GPT disk.  Also, if the system partition
    // is NOT a special partition--such as an 0x42 LDM partition or some other
    // third party FS type that we can't install to--then we don't need to 
    // retype any of the partitions.
    //
    if (PARTITION_STYLE_MBR == pPartition->PartitionStyle) {
        if (IsRecognizedPartition(pPartition->PartitionType)) {
            //
            // They system/boot partition has a recognised FS, such as FAT 
            // or NTFS.  We don't need any special handling.
            //
            return;
        }
    }
    else if (PARTITION_STYLE_GPT == pPartition->PartitionStyle) {
        if (!memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_BASIC_DATA_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_ENTRY_UNUSED_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_SYSTEM_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_MSFT_RESERVED_GUID, sizeof(GUID))
            )  {
            //
            // They system/boot partition is a basic partition type
            // We don't need any special handling.
            //
            return;
        }
    }
    else {
        ASSERT(0 && L"Unrecognised partition type");
        return;
    }

    //
    // The partition of interest is an LDM, or some other special third party
    // partition.  We need to mark all the partitions on that disk of the
    // same type (ie all LDM partitions on the disk) to be retyped to a basic 
    // partition.
    //
    while (pPtnRec) {
        //
        // They both better be the same--either MBR or GPT.
        //
        ASSERT(pPtnRec->PartitionStyle == pPartition->PartitionStyle);

        if (PARTITION_STYLE_MBR == pPtnRec->PartitionStyle) {

            if (pPtnRec->PartitionType == pPartition->PartitionType) {
                //
                // This partition has the same partition-type as the
                // partition of interest.  We need to retype it.
                //
                pPtnRec->NeedsLdmRetype = TRUE;

                DbgStatusMesg((_asrinfo, 
                    "Marked disk [%ws] ptn [%ws] to change (Ptn:0x%x Fs:0x%x)\n", 
                    pPtnRec->DiskKey,
                    pPtnRec->CurrPartKey, 
                    pPtnRec->PartitionType, 
                    pPtnRec->FileSystemType
                    ));
            }
        }
        else if (PARTITION_STYLE_GPT == pPtnRec->PartitionStyle) {
            if (!memcmp(&(pPtnRec->PartitionTypeGuid), &(pPartition->PartitionTypeGuid), sizeof(GUID))) {
                //
                // This partition has the same partition-type as the
                // partition of interest.  We need to retype it.
                //
                pPtnRec->NeedsLdmRetype = TRUE;

                DbgStatusMesg((_asrinfo, 
                    "Marked disk %d ptn [%ws] to change (%ws to basic)\n", 
                    pPtnRec->DiskKey,
                    pPtnRec->CurrPartKey, 
                    pPtnRec->PartitionTypeGuid
                    ));
            }
        }
        pPtnRec = pPtnRec->Next;
    }
}


//
// If more than one system/boot partitions exist (because of mirrors), this
// will mark one as the sys/boot ptns, and reset the others.
//
VOID
SpAsrCheckSifDiskTable(IN CONST DWORD CurrentSystemDiskNumber)
{
    ULONG numDiskRecords = 0,
        diskIndex = 0,
        partitionIndex = 0;

    USHORT numNtPartitionsFound = 0,
        numSysPartitionsFound = 0;
    
    PSIF_DISK_RECORD pDiskRec = NULL,
        pBootDiskRec = NULL, 
        pSysDiskRec = NULL;

    PSIF_PARTITION_RECORD pPtnRec = NULL,
        pBootPtnRec = NULL,
        pSysPtnRec = NULL;

    DWORD dwConsistencyCheck = 0;

    BOOLEAN needToRetypeBoot = TRUE;

    //
    // Go through the sif-disk list.  We check each partition on each of
    // these disks to see if it is marked as boot/sys.  We need
    // at least one boot/sys ptn.
    //
    numDiskRecords = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();

    for (diskIndex = 0; diskIndex < numDiskRecords; diskIndex++) {

        pDiskRec = Gbl_SifDiskTable[diskIndex];
        
        if (!pDiskRec || !(pDiskRec->PartitionList)) {
            continue;
        }
        
        pPtnRec = Gbl_SifDiskTable[diskIndex]->PartitionList->First;
        while (pPtnRec) {
            
            //
            // A system could end up having multiple boot and/or system
            // partitions.  For instance, LDM-Pro supports 3-way mirrors, 
            // and we would hence have three partitions marked as boot/sys.
            // 
            // We will reset this to have only one boot partition, 
            // and only one system partition.
            //
            
            if (SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag) &&
                SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag)) {

                //
                // The boot and system volumes are the same
                //

                ASSERT((0 == dwConsistencyCheck) || (1 == dwConsistencyCheck));

                if (0 == dwConsistencyCheck) {
                    DbgStatusMesg((_asrinfo,
                    "Boot and system partitions are the same\n"
                    ));
                }

                dwConsistencyCheck = 1;

                numSysPartitionsFound++;
                numNtPartitionsFound++;

                if (numSysPartitionsFound == 1) {
                    //
                    // This is the first system/boot partition we found.  Save
                    // a pointer to it.
                    //
                    pDiskRec->ContainsSystemPartition = TRUE;

                    pSysPtnRec  = pPtnRec;
                    pSysDiskRec = pDiskRec;

                    pDiskRec->ContainsNtPartition = TRUE;

                    pBootPtnRec  = pPtnRec;
                    pBootDiskRec = pDiskRec;


                }
                else {
                    //
                    // We found more than one system/boot partition.  Pick one
                    // of them as the system/boot  partition and reset the 
                    // other for now.  (It will be recreated at the end of
                    // gui setup by the appropriate vol mgr utils).
                    //
                    BOOLEAN newSys = PickASystemPartition(pSysPtnRec, 
                        pSysDiskRec, 
                        pPtnRec, 
                        pDiskRec, 
                        CurrentSystemDiskNumber,
                        TRUE        // Boot and system are the same
                        );

                    if (newSys) {
                        //
                        // pPtnRec is the new system partition
                        //
                        pSysDiskRec->ContainsSystemPartition = FALSE;
                        pDiskRec->ContainsSystemPartition = TRUE;
                        pSysDiskRec = pDiskRec;
                        pSysPtnRec  = pPtnRec;


                        pBootDiskRec->ContainsNtPartition = FALSE;
                        pDiskRec->ContainsNtPartition = TRUE;
                        pBootDiskRec = pDiskRec;
                        pBootPtnRec  = pPtnRec;
                   }
                }
            }
            else {

                //
                // The boot and system volumes are distinct
                //

                if (SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag)) {

                    if (0 == dwConsistencyCheck) {
                        DbgStatusMesg((_asrinfo,
                        "Boot and system partitions different\n"
                        ));
                    }

                    ASSERT((0 == dwConsistencyCheck) || (2 == dwConsistencyCheck));
                    dwConsistencyCheck = 2;

                    numNtPartitionsFound++;

                    if (numNtPartitionsFound == 1) {
                        //
                        // This is the first boot partition we found, save
                        // a pointer to it.
                        //
                        pDiskRec->ContainsNtPartition = TRUE;

                        pBootPtnRec  = pPtnRec;
                        pBootDiskRec = pDiskRec;
                    } 
                    else {
                        //
                        // We found more than one boot partition.  Pick 
                        // one of them as the boot partition, reset the other
                        // for now.  (It will be recreated at the end of
                        // gui setup by the appropriate vol mgr utils).
                        //
                        BOOLEAN newBoot = PickABootPartition(pBootPtnRec, pPtnRec);

                        if (newBoot) {
                            // 
                            // pPtnRec is our new boot record
                            //
                            pBootDiskRec->ContainsNtPartition = FALSE;
                            pDiskRec->ContainsNtPartition = TRUE;
                            pBootDiskRec = pDiskRec;
                            pBootPtnRec  = pPtnRec;
                        }
                    }
                }

                if (SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag)) {
                    
                    ASSERT((0 == dwConsistencyCheck) || (2 == dwConsistencyCheck));
                    dwConsistencyCheck = 2;

                    numSysPartitionsFound++;

                    if (numSysPartitionsFound == 1) {
                        //
                        // This is the first system partition we found.  Save
                        // a pointer to it.
                        //
                        pDiskRec->ContainsSystemPartition = TRUE;

                        pSysPtnRec  = pPtnRec;
                        pSysDiskRec = pDiskRec;

                    }
                    else {
                        //
                        // We found more than one system partition.  Pick one of
                        // them as the system partition and reset the other
                        // for now.  (It will be recreated at the end of
                        // gui setup by the appropriate vol mgr utils).
                        //
                        BOOLEAN newSys = PickASystemPartition(pSysPtnRec, 
                            pSysDiskRec, 
                            pPtnRec, 
                            pDiskRec, 
                            CurrentSystemDiskNumber,
                            FALSE   // Boot and system are distinct
                            );

                        if (newSys) {
                            //
                            // pPtnRec is the new system partition
                            //
                            pSysDiskRec->ContainsSystemPartition = FALSE;
                            pDiskRec->ContainsSystemPartition = TRUE;
                            pSysDiskRec = pDiskRec;
                            pSysPtnRec  = pPtnRec;

                        }
                    }
                }

            }

            pPtnRec = pPtnRec->Next;
        }
    }

    DbgStatusMesg((_asrinfo,
        "Found %hu boot partition(s) and %hu system partition(s) in asr.sif\n",
        numNtPartitionsFound,
        numSysPartitionsFound
        ));

    //
    // We should have at least one boot and one system volume
    // We can't proceed without them, so this has to be a fatal error.
    //
    if (numNtPartitionsFound < 1) {
        DbgFatalMesg((_asrerr, "Error in asr.sif: No boot partitions found.\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No boot partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    if (numSysPartitionsFound < 1) {
        DbgFatalMesg((_asrerr, "Error in asr.sif: No system partitions found.\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No system partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    //
    // Now, look for the disk(s) which contain the boot and system partitions.
    // If any partitions on these disks are not recognised (recognised implies
    // types 6, 7 and B--if they aren't recognised, they could be LDM (0x42), 
    // LDM-Pro, etc) then *all* the partitions on the disk that have the 
    // same type as the system or boot partition are changed to the basic type.
    // 
    // For the boot and system partitions, since we actually format them in text-
    // mode, we will change the type to the FS type.  For everything else, we
    // don't format them till the volumes are actually exposed by LDM/LDM-Pro.
    // So we just use type 0x7 as a place-holder.
    //
    // LDM needs this to recover its state after textmode setup. Mark them.
    //
    needToRetypeBoot = TRUE;
    if (PARTITION_STYLE_MBR == pSysDiskRec->PartitionStyle) {
        MarkPartitionLdmRetypes(pSysPtnRec, pSysDiskRec->PartitionList->First);
        if (pBootDiskRec == pSysDiskRec) {
            needToRetypeBoot = FALSE;
        }
    }
    
    if (needToRetypeBoot) {
        MarkPartitionLdmRetypes(pBootPtnRec, pBootDiskRec->PartitionList->First);
    }

} // SpAsrCheckSifDiskTable


PDISK_REGION
SpAsrDiskPartitionExists(
    IN ULONG Disk,
    IN PSIF_PARTITION_RECORD pRec
    )
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION pRegion = NULL;
    ULONGLONG startSector = 0;
    BOOLEAN isLogical = FALSE;

    pDisk = &PartitionedDisks[Disk];

    isLogical = pRec->IsLogicalDiskRecord;
    startSector = pRec->StartSector;// - (isLogical? SECTORS_PER_TRACK(Disk) : 0);

    pRegion = SpPtLookupRegionByStart(
        pDisk,
        (BOOLEAN) (pRec->IsPrimaryRecord ? 0 : 1),
        startSector
        );

    if (!pRegion && isLogical) {
        //
        // For logical drives, try finding their descriptor.
        //
        startSector = pRec->StartSector - SECTORS_PER_TRACK(Disk);
        pRegion = SpPtLookupRegionByStart(
            pDisk,
            (BOOLEAN) (pRec->IsPrimaryRecord ? 0 : 1),
            startSector
            );
    }

    if (!pRegion) {
        //
        // No primary or extended partition could be found at the specified start sector.
        //
        DbgErrorMesg((_asrwarn, "partition for record [%ws] not found at start sector %I64u (disk %lu)\n",
            pRec->CurrPartKey,
            startSector,
            Disk
            ));

        return NULL;
    }

    DbgStatusMesg((_asrinfo, "Partition for record [%ws] found at SS %I64u\n",
        pRec->CurrPartKey,
        startSector
        ));

    return pRegion;
}


//
// Goes through the list of sif-disks ("partition sets") and checks if
// they are intact.  A disk is intact if its signature and the partition 
// layout are intact.
//
VOID
MarkIntactSifDisk(IN ULONG Disk, IN PDISK_PARTITION_SET pSet)
{
    PSIF_PARTITION_RECORD pRec  = NULL;
    ULONG diskSignature = 0;
    PDISK_REGION pRegion = NULL;

    if (!pSet || !pSet->pDiskRecord) {
        DbgStatusMesg((_asrinfo, "Disk %lu contains no partition set\n", Disk));
        return;
    }

    pSet->IsReplacementDisk = TRUE;
    pSet->PartitionsIntact = FALSE;

    //
    // If one's an MBR and the other's a GPT, it's not the same disk
    //
    if (pSet->pDiskRecord->PartitionStyle != (PARTITION_STYLE) HardDisks[Disk].DriveLayout.PartitionStyle) {
        return;
    }

    //
    // If signatures (MBR) or disk ID's (GPT) are different, it 
    // is a replacement disk
    //
    if (PARTITION_STYLE_MBR == pSet->pDiskRecord->PartitionStyle) {
        diskSignature = SpAsrGetActualDiskSignature(Disk);
        if (pSet->pDiskRecord->SifDiskMbrSignature != diskSignature) {
            return;
        }
    }
    else if (PARTITION_STYLE_GPT == pSet->pDiskRecord->PartitionStyle) {

        if (memcmp(&(HardDisks[Disk].DriveLayout.Gpt.DiskId),
            &(pSet->pDiskRecord->SifDiskGptId),
            sizeof(GUID)
            )) {
            return;
        }
    }


    //
    // This is the same disk as the original system.  Now, determine whether 
    // the disk is intact.
    //
    pSet->IsReplacementDisk = FALSE;
    pSet->PartitionsIntact  = TRUE;

    // 
    // The disk had no partitions to begin with, we'll assume it's intact
    //
    if (!(pSet->pDiskRecord->PartitionList)) {
        DbgStatusMesg((_asrinfo,
            "MarkIntactSifDisk. ptn-list for disk %lu NULL, assuming it is intact\n", 
            Disk));
        return;
    }

    //
    // check if each partition exists
    //
    pRec = pSet->pDiskRecord->PartitionList->First;
    while (pRec) {
        //
        // we're interested only in primary partitions and logical disks
        //
        if ((pRec->IsPrimaryRecord) || (pRec->IsLogicalDiskRecord)) {

            //
            // Make sure the region exists
            //
            pRegion = SpAsrDiskPartitionExists(Disk, pRec);
            if (!pRegion) {
                
                DbgStatusMesg((_asrinfo, "Partition %p [%ws], SS "
                    "%I64u NOT intact: Region not found\n",
                    pRec, pRec->CurrPartKey, pRec->StartSector));

                pSet->PartitionsIntact = FALSE;
                break;
            }

            //
            // And it's not free space
            //
            if (!(SPPT_IS_REGION_PARTITIONED(pRegion))) {

                DbgStatusMesg((_asrinfo, "Partition %p [%ws], SS %I64u NOT "
                    "intact: Region %p not partitioned\n",
                    pRec, pRec->CurrPartKey, pRec->StartSector, pRegion));

                pSet->PartitionsIntact = FALSE;
                break;

            }

            //
            // And that the partition lengths match
            //
            if (pRegion->SectorCount != pRec->SectorCount) {

                DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, SS "
                    "%I64u NOT intact (Sector count orig-ptn: %I64u, Region: "
                    " %I64u)\n", pRec, pRec->CurrPartKey, pRegion, 
                    pRec->StartSector, pRec->SectorCount, pRegion->SectorCount));

                pSet->PartitionsIntact = FALSE;
                break;
            }

            //
            // And that the partition type is the same
            //
            if (PARTITION_STYLE_MBR == pSet->pDiskRecord->PartitionStyle) {
                if (pRegion->PartInfo.Mbr.PartitionType != pRec->PartitionType) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, SS "
                        "%I64u NOT intact (Ptn types orig-ptn: 0x%x, Region: "
                        "0x%x)\n", pRec, pRec->CurrPartKey, pRegion,
                        pRec->StartSector, pRec->PartitionType,
                        pRegion->PartInfo.Mbr.PartitionType));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }
            }
            else if (PARTITION_STYLE_GPT == pSet->pDiskRecord->PartitionStyle) {

                if (memcmp(&(pRegion->PartInfo.Gpt.PartitionId),
                    &(pRec->PartitionIdGuid), sizeof(GUID))) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, "
                        "SS %I64u NOT intact (GPT partition Id's don't match)\n",
                        pRec, pRec->CurrPartKey,pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }

                if (memcmp(&(pRegion->PartInfo.Gpt.PartitionType),
                    &(pRec->PartitionTypeGuid), sizeof(GUID))) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, "
                        "SS %I64u NOT intact (GPT partition types don't match)\n",
                        pRec, pRec->CurrPartKey, pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }

                //
                // Note that I'm not checking the GPT attributes here.  If 
                // the attributes are not intact, but everything else above 
                // is, we'll assume that the partition is intact.
                //
            }

            //
            // And finally, if the boot/system region is dynamic, we 
            // repartition the disk.
            //
            if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag) || 
                SpAsrIsSystemPartitionRecord(pRec->PartitionFlag)) {

                if (pRegion->DynamicVolume) {

                    DbgStatusMesg((_asrinfo, "Boot/system partition %p [%ws] "
                        "Region %p,  SS %I64u NOT intact (Dynamic region)\n",
                        pRec, pRec->CurrPartKey, pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }
            }
        }

        pRec = pRec->Next;
    }

    DbgStatusMesg((_asrinfo, "Disk %lu is %wsintact\n", 
        Disk, (pSet->PartitionsIntact ? L"" : L"NOT ")));
}


VOID
MarkIntactSifDisks(VOID)
{
    ULONG disk;

    for (disk = 0; disk < HardDiskCount; disk++) {
        if (Gbl_PartitionSetTable1[disk]) {
           MarkIntactSifDisk(disk, Gbl_PartitionSetTable1[disk]);
        }
    }
}


//
// Snaps the partitions in the list pRecord to cylinder boundaries, using the
// disk geometry from HardDisks[PhysicalIndex].
//
// This should only be called for MBR partitions, though it should work for GPT
// partitions as well.
//
//
ULONGLONG
CylinderAlignPartitions(
    IN ULONG PhysicalIndex,
    IN PSIF_PARTITION_RECORD pFirst
    ) 
{
    ULONGLONG endSector = 0,
        logicalDisksNeed = 0;

    PSIF_PARTITION_RECORD pRecord = pFirst;

    //
    // First, figure out how much the logical disks need. The container 
    // partition must be big enough to hold these.
    //
    while (pRecord) {
        
        if (pRecord->IsLogicalDiskRecord) {

            logicalDisksNeed += SpPtAlignStart(
                &HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );

        }
        pRecord = pRecord->Next;
    }

    //
    // Next, calculate how much the primary partitions and the container need.
    //
    pRecord = pFirst;
    while (pRecord) {

        if (pRecord->IsPrimaryRecord) {
            endSector += SpPtAlignStart(&HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );
        }
        else if (pRecord->IsContainerRecord) {
            //
            // The container partition must be at least as big as the logical
            // drives inside it.
            //
            ULONGLONG ContainerNeeds = SpPtAlignStart(&HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );

            endSector += ((logicalDisksNeed > ContainerNeeds) ? logicalDisksNeed : ContainerNeeds);
        }

        pRecord = pRecord->Next;
    }

    return endSector;
}


VOID
SpAsrAssignPartitionSet(
    IN ULONG PhysicalDisk, 
    IN ULONG SifDisk,
    IN CONST BOOLEAN IsAligned
    )
{
    PDISK_PARTITION_SET pSet = NULL;
    PSIF_PARTITION_RECORD pRec = NULL;

    //
    // Ensure that the partition set isn't already assigned.  This is
    // a serious enough problem to report a fatal internal error if
    // it happens.
    //
    if (Gbl_PartitionSetTable1[PhysicalDisk]) {

        DbgFatalMesg((_asrerr,
            "SpAsrAssignPartitionSet. SifDisk Index %lu: Gbl_PartitionSetTable1[%lu] already assigned.\n",
            SifDisk, 
            PhysicalDisk
            ));

        swprintf(
            TemporaryBuffer,
            L"SifDisk Index %lu - Gbl_PartitionSetTable1[%lu] already assigned.",
            SifDisk, PhysicalDisk
            );

        INTERNAL_ERROR(TemporaryBuffer);         // ok
        // does not return
    }

    //
    // Assign the partition set
    //
    pSet = SpAsrMemAlloc(sizeof(DISK_PARTITION_SET), TRUE);
    pSet->pDiskRecord = Gbl_SifDiskTable[SifDisk];
    pSet->pDiskRecord->Assigned = TRUE;
    pSet->pDiskRecord->pSetRecord = pSet;
    pSet->PartitionStyle = pSet->pDiskRecord->PartitionStyle;

    if (PARTITION_STYLE_MBR == pSet->PartitionStyle) {
        pSet->ActualDiskSignature = pSet->pDiskRecord->SifDiskMbrSignature;
    }

    pSet->ActualDiskSizeMB = DISK_SIZE_MB(PhysicalDisk);
    pSet->PartitionsIntact = FALSE;
    pSet->IsReplacementDisk = TRUE;
    pSet->NtPartitionKey = NULL;
    pSet->Index = PhysicalDisk;
    pSet->IsAligned = IsAligned;

    //
    // Check for boot or system partitions
    //
    if (pSet->pDiskRecord->PartitionList) {
        pRec = pSet->pDiskRecord->PartitionList->First;
        while (pRec) {
            if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {
                pSet->NtPartitionKey = pRec->CurrPartKey;
                ASSERT(pSet->pDiskRecord->ContainsNtPartition);
    //            pSet->pDiskRecord->ContainsNtPartition = TRUE;    // should've already been set
            }

            if (SpAsrIsSystemPartitionRecord(pRec->PartitionFlag)) {
               ASSERT(pSet->pDiskRecord->ContainsSystemPartition);  // should've already been set
            }

            pRec = pRec->Next;
        }                    

        //
        // Cylinder align the partitions.
        //
        Gbl_SifDiskTable[SifDisk]->LastUsedAlignedSector = CylinderAlignPartitions(
            PhysicalDisk, 
            Gbl_SifDiskTable[SifDisk]->PartitionList->First
            );
    }
    else {
        Gbl_SifDiskTable[SifDisk]->LastUsedAlignedSector = 0;
    }
     
    Gbl_PartitionSetTable1[PhysicalDisk] = pSet;
    Gbl_PartitionSetCount += 1;
}


//
// We only extend FAT32, NTFS and Container partitions.  We don't extend
// FAT or unknown (including LDM) partitions
//
BOOLEAN
IsExtendable(UCHAR PartitionType) 
{
    switch (PartitionType) {

        case PARTITION_EXTENDED:

        case PARTITION_IFS:
    
        case PARTITION_XINT13:
        case PARTITION_XINT13_EXTENDED:

            return TRUE;
    }

    if (IsContainerPartition(PartitionType)) {
        return TRUE;
    }

    return FALSE;
}


//
// Will resize (extend) the last partition on the disk if there is free space
// at the end (and there was no free space at the end of the original disk).
// The last partition must be FAT32 or NTFS--we don't extend FAT or unknown
// partitions.  This routine also extends any container partitions that
// contained the last partition.
//
BOOLEAN
SpAsrAutoExtendDiskPartition(
    IN ULONG PhysicalIndex, 
    IN ULONG SifIndex
    )
{

    ULONGLONG oldFreeSpace = 0,
        newEndSector = 0,
        newEndOfDisk = 0,
        extraSpace = 0;

    BOOLEAN didAnExtend = FALSE;

    DWORD bytesPerSector = Gbl_SifDiskTable[SifIndex]->BytesPerSector;

    PSIF_PARTITION_RECORD pPtnRecord = NULL;

    //
    // We won't extend GPT partitions
    //
    if (PARTITION_STYLE_MBR != Gbl_SifDiskTable[SifIndex]->PartitionStyle) {
        return FALSE;
    }

    //
    // Check if there was free space at the end of the original disk
    //
    oldFreeSpace = (Gbl_SifDiskTable[SifIndex]->TotalSectors - 
        Gbl_SifDiskTable[SifIndex]->LastUsedSector) *
        bytesPerSector;


    if ((oldFreeSpace > ASR_FREE_SPACE_FUDGE_FACTOR_BYTES) ||  // free space at the end of old disk
        (!Gbl_AutoExtend) ||                                // auto-extend is disabled in the sif
        (!Gbl_SifDiskTable[SifIndex]->PartitionList)) {     // no partitions on disk

        return FALSE;
    }

    //
    // We can auto-extend.  Check how many free sectors are available at the end of 
    // the new disk.
    //
    newEndSector = Gbl_SifDiskTable[SifIndex]->LastUsedAlignedSector;
    
    //
    // Find the last cylinder boundary that we can use.  This is usually the last cylinder
    // boundary on the disk.  The only exception is when the "fall off sectors" after the
    // end of the last cylinder boundary are less than the 1 MB needed for LDM private region.
    //
    newEndOfDisk = HardDisks[PhysicalIndex].SectorsPerCylinder * 
        HardDisks[PhysicalIndex].Geometry.Cylinders.QuadPart;

    if (((newEndOfDisk - Gbl_PhysicalDiskInfo[PhysicalIndex].TrueDiskSize) * BYTES_PER_SECTOR(PhysicalIndex))
        < ASR_LDM_RESERVED_SPACE_BYTES) {
        newEndOfDisk -=  HardDisks[PhysicalIndex].SectorsPerCylinder;
    }

    extraSpace = newEndOfDisk - newEndSector;

    //
    // Go through all the partitions, and for partitions that end on the newEndSector,
    // add the extra space to their SectorCounts.
    //
    pPtnRecord = Gbl_SifDiskTable[SifIndex]->PartitionList->First;

    while (pPtnRecord) {

        if (((pPtnRecord->StartSector) + (pPtnRecord->SectorCount) == newEndSector) 
            && (IsExtendable(pPtnRecord->PartitionType))) {
            didAnExtend = TRUE;
            pPtnRecord->SectorCount += extraSpace;

            pPtnRecord->SizeMB = SpAsrConvertSectorsToMB(pPtnRecord->SectorCount, bytesPerSector);
    
        }
        pPtnRecord = pPtnRecord->Next;
    }

    return didAnExtend;
}



VOID
SpAsrSystemWasDataWarning()
/*++

Routine Description:
    Display a screen warning the user that his current system
    disk used to be a data disk that we recognise and will 
    destroy, and allow him to abort

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG warningKeys[] = {KEY_F3, ASCI_CR, 0};
    ULONG mnemonicKeys[] = {0};
    BOOLEAN done = FALSE;

    //
    // We currently display a list of disks that will be repartitioned
    // anyway.  
    //
    return;

/*
// put this back in user\msg.mc if reactivating this bit of code.
MessageId=12429 SymbolicName=SP_SCRN_DR_SYSTEM_DISK_WAS_DATA_DISK
Language=English
The current system disk used to be a data disk.

To continue, press Enter

To quit Setup, press F3. No changes will be
made to any of the disks on the system.
.

  do {
        // display the warning message
        SpDisplayScreen(SP_SCRN_DR_SYSTEM_DISK_WAS_DATA_DISK,3,4);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0
                               );

        // wait for keypress.  Valid keys:
        // ENTER = continue
        // F3 = exit
        SpInputDrain();
        switch(SpWaitValidKey(warningKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            break;

        case ASCI_CR:
            // User wants to continue.
            done = TRUE;
            break;
        }
    } while (!done);

*/

}


//
// This assigns a disk based on signature (for MBR disks) or diskId (for GPT disks)
//
//
VOID
SpAsrAssignDisksBySignature(DWORD PhysicalSystemIndex)
{
    ULONG index =0,
        sifIndex = 0, 
        physicalIndex = 0,
        numDiskRecords = 0, 
        diskSignature = 0;

    BOOLEAN done = FALSE,
        matchFound = FALSE,
        IsAligned = TRUE;

    WCHAR physicalDiskGuid[MAX_PATH + 1];

    numDiskRecords = SpAsrGetDiskRecordCount();

    // 
    // Loop through the list of sif disks, and attempt to find a 
    // physical disk with the same signature.  
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        if (
            ((PARTITION_STYLE_MBR == Gbl_SifDiskTable[sifIndex]->PartitionStyle) && 
            !(Gbl_SifDiskTable[sifIndex]->SifDiskMbrSignature)) ||

            ((PARTITION_STYLE_GPT == Gbl_SifDiskTable[sifIndex]->PartitionStyle) && 
            SpAsrIsZeroGuid(&(Gbl_SifDiskTable[sifIndex]->SifDiskGptId)))
            
            ) {
            //
            // Skip GPT disks that have no ID, and MBR disks that have no signature
            //
            continue;
        }

        if (Gbl_SifDiskTable[sifIndex]->ContainsSystemPartition) {
            //
            // The system disk would have already been assigned
            //
            ASSERT(Gbl_SifDiskTable[sifIndex]->Assigned && L"System disk should be assigned");
        }

        done = FALSE;
        for (physicalIndex = 0; (physicalIndex < HardDiskCount) && (!done); physicalIndex++) {

            matchFound = FALSE;

            if (DISK_IS_REMOVABLE(physicalIndex)) { 
                continue;
            }

            if (Gbl_SifDiskTable[sifIndex]->PartitionStyle != 
                (PARTITION_STYLE) HardDisks[physicalIndex].DriveLayout.PartitionStyle
                ) {
                //
                // The sif disk's MBR, and the physical disk's GPT, or vice-versa.
                //
                continue;
            }

            if (PARTITION_STYLE_MBR == Gbl_SifDiskTable[sifIndex]->PartitionStyle) {

                diskSignature = SpAsrGetActualDiskSignature(physicalIndex);
                if (!diskSignature) {   
                    //
                    // we won't assign disks with no signature here
                    //
                    continue;
                }

                if (diskSignature == Gbl_SifDiskTable[sifIndex]->SifDiskMbrSignature) {

                    if (Gbl_PartitionSetTable1[physicalIndex]) {
                        //
                        // The signatures match, but this physical-disk has already 
                        // been assigned.  This can be because this physical disk is
                        // the current system disk, or (!) there were duplicate
                        // signatures.
                        // 
                        if (Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord &&
                            Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord->ContainsSystemPartition) {
                        
                            if (PhysicalSystemIndex == physicalIndex) {
                                //
                                // This is the original system disk
                                //
                                Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;
                            }
                            else {
                                //
                                // We recognise the physical disk to be some other data
                                // disk in the original system.  
                                //
                                SpAsrSystemWasDataWarning();
                            }
                        }
                        else {
                            ASSERT(0 && L"Disk already assigned");
                        }

                        continue;
                    }

                    //
                    // We found a disk with matching signatures
                    //
                    matchFound = TRUE;
                }
            }
            else if (PARTITION_STYLE_GPT == Gbl_SifDiskTable[sifIndex]->PartitionStyle) {

                if (!memcmp(&(HardDisks[physicalIndex].DriveLayout.Gpt.DiskId),
                    &(Gbl_SifDiskTable[sifIndex]->SifDiskGptId), 
                    sizeof(GUID)
                    )) {

                    if (Gbl_PartitionSetTable1[physicalIndex]) {
                        //
                        // The signatures match, but this physical-disk has already 
                        // been assigned.  This can be because this physical disk is
                        // the current system disk, or (!) there were duplicate
                        // signatures.
                        // 
                        if (Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord &&
                            Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord->ContainsSystemPartition) {
                            if (PhysicalSystemIndex == physicalIndex) {
                                Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;
                            }
                            else {
                                //
                                // We recognise the physical disk to be some other data
                                // disk in the original system.  
                                //
                                SpAsrSystemWasDataWarning();
                            }
                        }
                        else {
                            ASSERT(0 && L"Disk already assigned");
                        }
                        continue;
                    }

                    //
                    // We found a disk with matching signatures
                    //
                    matchFound = TRUE;
                }
            }

            if (matchFound) {
                //
                // Make sure it fits (!)
                //
                if (SpAsrDoesListFitOnDisk(Gbl_SifDiskTable[sifIndex], physicalIndex, &IsAligned)) {

                    SpAsrAssignPartitionSet(physicalIndex, sifIndex, IsAligned);
                    //
                    // Will not auto-extend disks that match by signature
                    //

                    //
                    // The signatures match, so we assume it's original (may not be
                    // intact, but it's the original)
                    //
                    Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;

                    DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by signature).\n",
                        sifIndex,
                        physicalIndex
                        ));
                }
                else {

                    DbgStatusMesg((_asrerr, "Disk signatures match, but partitions don't fit!  Partition list %lu, disk %lu.  Not assigned\n",
                        sifIndex,
                        physicalIndex
                        ));
                }

                done = TRUE;
            }
        }
    }
} // SpAsrAssignDisksBySignature


//
// Checks if the partition list fits on the disk.  In addition to checking
// the total sizeSectors of the disk and the SectorCount of the partition list,
// we also need to try and "lay out" the partitions on the disk to make sure 
// that they fit--because of different disk geometries and the requirement that 
// partitions must be cylinder-aligned, we may have a list that doesn't fit on 
// a disk even if the total sectors it requires is less than the sectors on the 
// disk
//
BOOLEAN
SpAsrDoesListFitOnDisk(
    IN PSIF_DISK_RECORD pSifDisk,
    IN ULONG DiskIndex,
    OUT BOOLEAN *IsAligned
    )
{
    ULONGLONG endSector = 0;
    PSIF_PARTITION_RECORD_LIST pList = NULL;
    BOOLEAN tryNoAlign = FALSE;
    
    if ((DWORD)(-1) == DiskIndex) {
        return FALSE;
    }

    if (!(pSifDisk && pSifDisk->PartitionList)) {
        return TRUE;
    }

    ASSERT(pSifDisk && pSifDisk->PartitionList);
    pList = pSifDisk->PartitionList;
    *IsAligned = FALSE;
    
    //
    // Requirement 1.  The replacement disk must have at least as many 
    //  "true" sectors as the original disk.  This is a little more
    //  restrictive than is absolutely required, but it somewhat simplifies
    //  the LDM requirement of making sure we have enough cylinders to create
    //  the LDM private database at the end.  
    //
    if (pList->DiskSectorCount >  Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize) {

        DbgStatusMesg((_asrinfo, 
            "Original Disk sector count %I64u, Current Disk %lu true sector count %I64u.  Not big enough\n",
            pList->DiskSectorCount, DiskIndex, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize
            ));
     
        return FALSE;
    }

    //
    // Requirement 2:
    //
    // "If the replacement disk has a different geometry, ASR will cylinder-
    // align the partitions--this may result in some partitions being marginally 
    // bigger than they used to be.  The requirement in this case is that the 
    // replacement disk must have at least as many true sectors as the original 
    // disk, plus the number of sectors required to cylinder-align all 
    // partitions."
    // 
    //

    //
    // Cylinder-align the partitions
    //
    endSector = CylinderAlignPartitions(DiskIndex, pList->First);
    *IsAligned = TRUE;

    //
    // And make sure that the space at the end is at least as much as it 
    // used to be
    //
    if ((pList->DiskSectorCount - pList->LastUsedSector) 
        > (Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize - endSector)) {

        DbgStatusMesg((_asrinfo, 
            "List->DiskSectorCount: %I64u, LastUsedSector:%I64u, Disk->TrueDiskSize: %I64u, EndSector: %I64u.  Not big enough\n",
            pList->DiskSectorCount, pList->LastUsedSector, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
            ));
     
        tryNoAlign = TRUE;
    }

    if (endSector > Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize) {

        DbgStatusMesg((_asrinfo, 
            "List->DiskSectorCount: %I64u, Disk->TrueDiskSize: %I64u < EndSector: %I64u.  Not big enough\n",
            pList->DiskSectorCount, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
            ));
     
        tryNoAlign = TRUE;
    }


    if (tryNoAlign) {
        //
        // We couldn't fit the partitions on the disk after cylinder-aligning
        // them.  If the disk has the exact same geometry as it used to, we
        // can try to fit the partitions on it without cylinder aligning them.
        //
        if ((pSifDisk->BytesPerSector == HardDisks[DiskIndex].Geometry.BytesPerSector) &&
            (pSifDisk->SectorsPerTrack == HardDisks[DiskIndex].Geometry.SectorsPerTrack) &&
            (pSifDisk->TracksPerCylinder == HardDisks[DiskIndex].Geometry.TracksPerCylinder)
            ) {
            //
            // The geometries are the same.  We don't really need to *check*
            // if the partitions will fit, since we already know that the disk
            // is large enough to hold them (we checked the sector count above)
            //
            *IsAligned = FALSE;
            return TRUE;
        }

        //
        // The partitions didn't fit, and the disk has a different geometry. 
        // Oh well.
        //
        return FALSE;
    }

    //
    // This disk is okay to hold this list
    //
    DbgStatusMesg((_asrinfo, 
        "List->DiskSectorCount: %I64u, LastUsedSector: %I64u, Disk->TrueDiskSize: %I64u, EndSector: %I64u.  Disk okay.\n",
        pList->DiskSectorCount, pList->LastUsedSector, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
        ));

    return TRUE;
}


BOOLEAN
SpAsrIsThisDiskABetterFit(
    IN DWORD CurrentBest,
    IN DWORD PhysicalIndex,
    IN DWORD SifIndex,
    OUT BOOLEAN *IsAligned
    )
{

    if ((CurrentBest == HardDiskCount) || 
        (DISK_SIZE_MB(PhysicalIndex) < DISK_SIZE_MB(CurrentBest))) {
        
        if ((!DISK_IS_REMOVABLE(PhysicalIndex)) &&
            (BYTES_PER_SECTOR(PhysicalIndex) == (Gbl_SifDiskTable[SifIndex]->BytesPerSector)) &&
            SpAsrDoesListFitOnDisk(Gbl_SifDiskTable[SifIndex], PhysicalIndex, IsAligned)) {

            return TRUE;
        }
    }

    return FALSE;
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on the same bus as the sif disk originally was (ie if
// any other disk on that bus has been assigned, this tries to assign
// this disk to the same bus)
//
VOID
SpAsrAssignCriticalDisksByBus()
{
    DWORD sifIndex = 0,
        sifIndex2 = 0,
        physicalIndex = 0,
        currentBest = 0,
        targetBusId = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    //
    // Loop through the list of sif disks, and for each disk that 
    // hasn't been assigned yet, attempt to find a sif-disk "X" that used
    // to be on the same bus, and has been assigned.  Then, attempt
    // to find other disks on the same physical bus that X is on.
    //
    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        //
        // Skip sif-disks that have already been assigned, and
        // disks for which we don't have any bus info in the 
        // sif file
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||    // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) || // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned) ||       // assigned
            !(Gbl_SifDiskTable[sifIndex]->BusKey)) {        // no bus info

            continue;
        }

        //
        // Find another (sif) disk that used to be on the same (sif) bus, 
        // and has already been assigned to a physical disk.
        //
        targetBusId = 0;
        done = FALSE;
        for (sifIndex2 = 0; (sifIndex2 < numDiskRecords) && (!done); sifIndex2++) {

            if ((Gbl_SifDiskTable[sifIndex2]->BusKey == Gbl_SifDiskTable[sifIndex]->BusKey) // same bus
                && (Gbl_SifDiskTable[sifIndex2]->pSetRecord)) {                             // assigned

                ULONG index = Gbl_SifDiskTable[sifIndex2]->pSetRecord->Index; // set when disk was assigned
                targetBusId = Gbl_PhysicalDiskInfo[index].BusKey; // the physical bus

                //
                // If this physical disk is on an unknown bus, 
                // (target id = sifbuskey = 0) then we want to try and look 
                // for another disk on the same (sif) bus.  Hence done is 
                // TRUE only if targetId != 0
                //
                if (targetBusId) {  
                    done = TRUE;
                }
            }
        
        }   // for sifIndex2


        if (targetBusId) {      // we found another disk on the same sif bus
            //
            // Go through the physical disks on the same bus, and try to
            // find the best fit for this disk.  Best fit is the smallest
            // disk on the bus that's big enough for us.
            //
            currentBest = HardDiskCount;
            for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

                if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                    (Gbl_PhysicalDiskInfo[physicalIndex].BusKey == targetBusId) && // same bus
                    (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                    
                    isAligned = isAlignedTemp;
                    currentBest = physicalIndex;
                }
            }

            if (currentBest < HardDiskCount) {      // we found a match
                //
                // Assign the disks, and extend the last partition if needed.
                //
                SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
                SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

                DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by bus).\n",
                    sifIndex,
                    currentBest
                    ));
            }
        }
    }   // for sifIndex
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on any bus of the same type (SCSI, IDE, etc) as the sif disk 
// originally was
//
VOID
SpAsrAssignCriticalDisksByBusType()
{
    DWORD sifIndex = 0,
        physicalIndex = 0,
        currentBest = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        //
        // Skip sif-disks that have already been assigned, and
        // disks for which we don't have any bus info in the 
        // sif file
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||                // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) ||             // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned) ||                    // assigned
            (BusTypeUnknown == Gbl_SifDiskTable[sifIndex]->BusType)) {  // no bus info

            continue;
        }

        //
        // Go through the physical disks, and try to
        // find the best fit for this disk.  Best fit is the smallest
        // disk on any bus of the same bus type that's big enough for us.
        //
        currentBest = HardDiskCount;
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {


            if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                (Gbl_PhysicalDiskInfo[physicalIndex].BusType == Gbl_SifDiskTable[sifIndex]->BusType) && // same bus
                (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                
                isAligned = isAlignedTemp;
                currentBest = physicalIndex;
            }
        }

        if (currentBest < HardDiskCount) {      // we found a match
            //
            // Assign the disks, and extend the last partition if needed.
            //
            SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
            SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

            DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by bus type).\n",
                sifIndex,
                currentBest
                ));
        
            //
            // Now call AssignByBus again
            //
            SpAsrAssignCriticalDisksByBus();

        }
    }   // for sifIndex
}


//
// Okay, so by now we've tried putting disks on the same bus, and
// the same bus type.  For disks that didn't fit using either of those
// rules (or for whom we didn't have any bus info at all), let's just 
// try to fit them where ever possible on the system.
//
BOOL
SpAsrAssignRemainingCriticalDisks(VOID)
{
   DWORD sifIndex = 0,
        physicalIndex = 0,
        currentBest = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        //
        // Skip sif-disks that have already been assigned
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||    // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) || // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned)) {       // already assigned

            continue;
        }

        //
        // Go through the physical disks, and try to find the best 
        // fit for this disk.  Best fit is the smallest disk anywhere
        // on the system that's big enough for us.
        //
        currentBest = HardDiskCount;
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

            if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                
                isAligned = isAlignedTemp;
                currentBest = physicalIndex;
            }
        }

        if (currentBest < HardDiskCount) {      // we found a match
            //
            // Assign the disks, and extend the last partition if needed.
            //
            SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
            SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

            DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by size).\n",
                sifIndex,
                currentBest
                ));

            
            SpAsrAssignCriticalDisksByBus();

            SpAsrAssignCriticalDisksByBusType();
        }
    }   // for sifIndex

    //
    // There should be no unassigned critical disks at this point
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        if ((Gbl_SifDiskTable[sifIndex]->IsCritical) &&
            (Gbl_SifDiskTable[sifIndex]->PartitionList) &&
            (!Gbl_SifDiskTable[sifIndex]->Assigned)) {
            return FALSE;
        }
    }

    return TRUE;
}


VOID
SpAsrInitInternalData(VOID)
{
    SpAsrInitSifDiskTable();
    SpAsrAllocateGblPartitionSetTable();
    SpAsrInitPhysicalDiskInfo();
}


VOID
SpAsrFreeSifData(VOID)
{
    ULONG numDiskRecords;
    ULONG diskIndex;

//    SpAsrUnassignPartitionSets(TRUE);

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (diskIndex = 0; diskIndex < numDiskRecords; diskIndex++) {
        SpAsrFreePartitionDisk(Gbl_SifDiskTable[diskIndex]);
    }        
}

DWORD 
SpAsrGetCurrentSystemDiskNumber(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    ) 
{

    DWORD physicalIndex = (DWORD) (-1);

    //
    // Get the index of the current (physical) system disk
    //

/*  (guhans, 10.May.2001) Turns out that SpDetermineDisk0 should work on
	IA-64 as well.
  
	if (SpIsArc()) {
        PDISK_REGION systemPartitionArea = NULL;

        systemPartitionArea = SpPtnValidSystemPartitionArc(Gbl_SifHandle,
                                    SetupSourceDevicePath,
                                    DirectoryOnSetupSource,
                                    FALSE
                                    );
        if (systemPartitionArea) {
            physicalIndex =  systemPartitionArea->DiskNumber;
        }


    }
    else {
*/
        physicalIndex = SpDetermineDisk0();
//  }

    return physicalIndex;
}



//
// This goes through the list of physical disks, and checks which disk
// is marked as the system disk.  It then assigns the system-disk in the
// sif file to the current disk.  
//
// If the current system disk isn't "compatible" with the sif-system-disk
// (ie it isn't big enough, it doesn't have the same bytes-per-sector), 
// it's a fatal error.
//
// If the current system disk is recognised as a data disk that used to 
// exist in the sif-file, a warning is displayed to the user 
//
VOID
SpAsrAssignSystemDisk(
    IN DWORD CurrentPhysicalSystemDisk
    ) 
{

    DWORD sifIndex = 0,
        numDiskRecords = 0;

    BOOLEAN isAligned = FALSE;

    numDiskRecords = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();

    //
    // Find the index of the system-disk in the sif 
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        if (Gbl_SifDiskTable[sifIndex]->ContainsSystemPartition) {
            break;
        }
    }

    if (SpAsrIsThisDiskABetterFit(HardDiskCount, CurrentPhysicalSystemDisk, sifIndex, &isAligned)) {
        SpAsrAssignPartitionSet(CurrentPhysicalSystemDisk, sifIndex, isAligned);

        DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (system disk).\n",
            sifIndex,
            CurrentPhysicalSystemDisk
            ));

    }
    else {
        //
        // Fatal Error
        //

        DbgErrorMesg((_asrerr, 
            "Current sytem disk smaller than original system disk.  Curr:%lu  sifIndex:%lu\n" ,
            CurrentPhysicalSystemDisk,
            sifIndex
            ));
        ASSERT(0 && L"Current sytem disk smaller than original system disk");

        SpAsrRaiseFatalError(
            SP_SCRN_DR_SYSTEM_DISK_TOO_SMALL,
            L"The current system disk is too small to hold the partitions"
            );
    }
}


VOID
SpAsrCreatePartitionSets(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    )
/*++

Description:
    This is the top-level routine from which all of the partition set services
    are called.  When complete, all partitions in the asr.sif file will
    have been assigned to a physical disks attached to the system.

    The list of partitions associated with a physical disk is called a
    partition set.  Partition lists exist in one of two states: Unassigned and
    Assigned.  Physical disks exist in one of two states: Unassigned or
    Assigned.  A disk is assigned if it is a member of a partition set, that is
    the disk is associated with a list of partitions.  Like an assigned disk, a
    partition list is assigned if it is a member of a partition set, i.e., it
    is associated with a physical disk.

    The rules by which partition sets are constructed are executed in the
    following sequence:

        0. Assign-system-disk

  
        1. Assign-by-signature:

        ASR attempts to assign each partition list found in the asr.sif
        file to the physical disk on the system whose disk signature is
        identical to the disk signature specified in the asr.sif file.


        2. Assign-by-bus
        
        3. Assign-by-bus-type

        4. Assign-by-size:

        All remaining unassigned partition lists are assigned to disks on the
        basis of their storage requirements.  The partition list with the
        smallest storage requirement is assigned to the disk with the smallest
        storage capacity where partition list's storage capacity is less than
        or equal to the disk's storage capacity.


Returns:
    None
--*/ 
{

    BOOL    result = TRUE;
    DWORD   systemDiskNumber = (DWORD)(-1);

    //
    // Initialise our global structs.  If there's a fatal error, these
    // won't return
    //
    SpAsrInitInternalData();
    
    systemDiskNumber = SpAsrGetCurrentSystemDiskNumber(SetupSourceDevicePath, DirectoryOnSetupSource);

    SpAsrCheckSifDiskTable(systemDiskNumber);

    if (systemDiskNumber != (DWORD) (-1)) {
        SpAsrAssignSystemDisk(systemDiskNumber);
    }

    //
    // If the signatures of the sif-disks match that of the physical-disks,
    // assign them to each other.
    //
    SpAsrAssignDisksBySignature(systemDiskNumber);

    //
    // If this is a new system disk, we should extend the last partition if 
    // needed.
    //
    if (Gbl_PartitionSetTable1[systemDiskNumber] && 
        Gbl_PartitionSetTable1[systemDiskNumber]->IsReplacementDisk &&
        Gbl_PartitionSetTable1[systemDiskNumber]->pDiskRecord) {
        SpAsrAutoExtendDiskPartition(systemDiskNumber, 
            Gbl_PartitionSetTable1[systemDiskNumber]->pDiskRecord->SifDiskNumber);
    }

    //
    // Attempt to assign the remaining critical disks.  We first attempt 
    // to assign disks to the buses they used to be on, then by bus-types, 
    // and finally just by smallest-fit.
    //
    SpAsrAssignCriticalDisksByBus();

    SpAsrAssignCriticalDisksByBusType();

    result = SpAsrAssignRemainingCriticalDisks();
    
    if (!result) {
         SpAsrRaiseFatalError(
            SP_TEXT_DR_INSUFFICIENT_CAPACITY,
            L"Some critical disks could not be assigned"
            );
    }

    MarkIntactSifDisks();

    SpAsrDbgDumpPartitionLists(1, L"After validate ...");
    Gbl_PartitionSetTable2 = SpAsrCopyPartitionSetTable(Gbl_PartitionSetTable1);
}


// Debug routines
VOID
SpAsrDbgDumpPartitionSet(IN ULONG Disk, PDISK_PARTITION_SET pSet)
{
    PSIF_PARTITION_RECORD pRec;

    if (!pSet->pDiskRecord) {
        
        DbgMesg((_asrinfo,
            "No disk (or partition) records assigned to [%ws] (0x%lx)\n\n",
           (PWSTR) HardDisks[Disk].DevicePath,
           pSet->ActualDiskSignature
           ));

        return;
    }

    if (!pSet->pDiskRecord->PartitionList) {
        DbgMesg((_asrinfo, "Disk record [%ws] ([%ws] (0x%lx)). Not referenced by any partition record.\n\n",
                pSet->pDiskRecord->CurrDiskKey,
                (PWSTR) HardDisks[Disk].DevicePath,
                pSet->ActualDiskSignature));
        return;
    }
    
    // dump the partition table.
    DbgMesg((_asrinfo, "Disk record [%ws] assigned to [%ws] (0x%lx)\n",
            pSet->pDiskRecord->CurrDiskKey,
            (PWSTR) HardDisks[Disk].DevicePath,
            pSet->ActualDiskSignature));

    DbgMesg((_asrinfo, "[%ws] Capacity:%lu Mb. Partitions require:%I64u Mb\n",
            (PWSTR) HardDisks[Disk].DevicePath,
            HardDisks[Disk].DiskSizeMB,
            pSet->pDiskRecord->PartitionList->TotalMbRequired));

    if (pSet->pDiskRecord->ExtendedPartitionStartSector != -1) {
        DbgMesg((_asrinfo, "Extended partition exists. SS:%I64u  SC:%I64u\n",
            pSet->pDiskRecord->ExtendedPartitionStartSector,
            pSet->pDiskRecord->ExtendedPartitionSectorCount));
    }

    DbgMesg((_asrinfo, "Ptns-intact: %s  Ptn-recs: ", pSet->PartitionsIntact? "Yes" : "No" ));

    pRec = pSet->pDiskRecord->PartitionList->First;
    while (pRec) {
        KdPrintEx((_asrinfo, "[%ws] ", pRec->CurrPartKey));
        pRec = pRec->Next;
    }
    
    KdPrintEx((_asrinfo, "\n\n"));
}


VOID
SpAsrDbgDumpPartitionSets(VOID)
{
    ULONG i;

    DbgMesg((_asrinfo, "     ----- Partition Set Tables -----\n\n"));
    
    for (i = 0; i < HardDiskCount; i++) {
        if (!Gbl_PartitionSetTable1[i]) {
            if (DISK_IS_REMOVABLE(i)) {
                DbgMesg((_asrinfo, "- No disk records assigned to removable drive [%ws].\n",
                        (PWSTR) HardDisks[i].DevicePath));
            } 
            else {
                DbgMesg((_asrinfo, "- No disk records assigned to %ws (0x%lx).\n",
                        (PWSTR) HardDisks[i].DevicePath,
                        SpAsrGetActualDiskSignature(i)));
            }
        }
        else {
            SpAsrDbgDumpPartitionSet(i, Gbl_PartitionSetTable1[i]);
        }
    }  
    DbgMesg((_asrinfo, "----- End of Partition Set Tables -----\n\n"));

}
                                    
VOID
SpAsrDbgDumpADisk(PSIF_DISK_RECORD pDiskRec)
{
    PSIF_PARTITION_RECORD pPtnRec;
    PSIF_PARTITION_RECORD_LIST pList;

    pList = pDiskRec->PartitionList;

    DbgMesg((_asrinfo, "DiskRec %ws. sig:0x%x%s%s\n", 
                      pDiskRec->CurrDiskKey,
                      pDiskRec->SifDiskMbrSignature,
                      pDiskRec->ContainsNtPartition ? " [Boot]" : "",
                      pDiskRec->ContainsSystemPartition ? " [Sys]" : ""));

    if (pDiskRec->Assigned) {
        DbgMesg((_asrinfo, "Assigned-to:0x%x  [%sintact]  [%s]  size:%I64u MB\n",
                    pDiskRec->pSetRecord->ActualDiskSignature,
                    pDiskRec->pSetRecord->PartitionsIntact ? "" : "not ",
                    pDiskRec->pSetRecord->IsReplacementDisk ? "replacement" : "original",
                    pDiskRec->pSetRecord->ActualDiskSizeMB));
    }

    if (!pList) {
        DbgMesg((_asrinfo, "No partition records.\n\n"));
        return;
    }

    DbgMesg((_asrinfo, "Partition records. count:%lu,  totalMbRequired:%I64u\n",
                      pList->ElementCount, pList->TotalMbRequired));

    pPtnRec = pList->First;
    while (pPtnRec) {

        DbgMesg((_asrinfo, "Ptn %2ws. sz:%4I64u SS:%8I64u SC:%8I64u type:%s FS:0x%-2x %s %s\n",
                pPtnRec->CurrPartKey,
                pPtnRec->SizeMB,
                pPtnRec->StartSector,
                pPtnRec->SectorCount,
                pPtnRec->IsPrimaryRecord ? "Pri" : 
                  pPtnRec->IsContainerRecord ? "Con" :
                    pPtnRec->IsLogicalDiskRecord ? "Log" :
                        pPtnRec->IsDescriptorRecord ? "Des" :"ERR",
                pPtnRec->PartitionType,
                SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag) ? "boot" : "",
                SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag) ? "sys" : ""));

        pPtnRec = pPtnRec->Next;
    }
    DbgMesg((_asrinfo, "\n"));
}

VOID
SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg)
{
    ULONG DiskRecords;
    ULONG DiskIndex;
    ULONG SetIndex;
    PSIF_DISK_RECORD pDiskRec;
    PDISK_PARTITION_SET pSetRec;

    DbgMesg((_asrinfo, "     ----- Partition Lists: [%ws] -----\n\n", Msg));

    if (DataOption == 1) {
        DiskRecords = SpAsrGetDiskRecordCount();
    
        for (DiskIndex = 0; DiskIndex < DiskRecords; DiskIndex++) {
            pDiskRec = Gbl_SifDiskTable[DiskIndex];
            if (pDiskRec != NULL) {
                SpAsrDbgDumpADisk(pDiskRec);
            }
        }
    }
    else if (DataOption == 2) {
        ULONG SetRecords = sizeof(Gbl_PartitionSetTable2) / sizeof(PDISK_PARTITION_SET);        

        for (SetIndex = 0; SetIndex < HardDiskCount; SetIndex++) {
            pSetRec = Gbl_PartitionSetTable2[SetIndex];

            if (pSetRec != NULL && pSetRec->pDiskRecord != NULL) {
                SpAsrDbgDumpADisk(pSetRec->pDiskRecord);
            }
        }
    }

    DbgMesg((_asrinfo, "----- End of Partition Lists: [%ws] -----\n\n", Msg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdrutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spdrutil.c

Abstract:

    This module contains general utility and helper functions used by ASR
    in textmode Setup.

Authors:

    Michael Peterson, Seagate Software (v-michpe) 13-May-1997
    Guhan Suriyanarayanan (guhans)  21-Aug-1999

Environment:

    Textmode Setup, Kernel-mode.

Revision History:
    
    21-Aug-1999 guhans
        Code clean-up and re-write.

    13-May-1997 v-michpe
        Initial implementation.

--*/

#include "spprecmp.h"
#pragma hdrstop

#define THIS_MODULE L"spdrutil.c"
#define THIS_MODULE_CODE L"U"

static const PCWSTR ASR_MOUNTED_DEVICES_KEY = L"\\registry\\machine\\SYSTEM\\MountedDevices";
static const PCWSTR ASR_HKLM_SYSTEM_KEY     = L"\\registry\\machine\\SYSTEM";

#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX   (0xFFFFFFFFFFFFFFFF)
#endif

//
// Caller must free the string
//
PWSTR
SpAsrGetRegionName(IN PDISK_REGION pRegion)
{
    SpNtNameFromRegion(
        pRegion,
        (PWSTR) TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    return SpDupStringW((PWSTR)TemporaryBuffer);
}


ULONG
SpAsrGetActualDiskSignature(IN ULONG DiskNumber)
{
    PHARD_DISK pDisk = &HardDisks[DiskNumber];
    ULONG Signature = 0;
    
    if (PARTITION_STYLE_MBR == (PARTITION_STYLE) pDisk->DriveLayout.PartitionStyle) {

        Signature = pDisk->DriveLayout.Mbr.Signature;
    }

    return Signature;
}

ULONGLONG
SpAsrConvertSectorsToMB(
    IN ULONGLONG SectorCount,
    IN ULONG BytesPerSector
    )
{
    ULONGLONG mb = 1024 * 1024;

    if ((ULONGLONG) (SectorCount / mb) > (ULONGLONG) (ULONGLONG_MAX / BytesPerSector)) {
        //
        // This is strange.  The sizeMB of the disk is too big to fit in 64-bits,
        // yet the SectorCount does.  This implies that this disk has more than 
        // 1 MB Per Sector.  Since this is very improbable (disks commonly have 512 
        // BytesPerSector today), we bail out with an internal error.
        // 
        DbgFatalMesg((_asrerr, "SpAsrConvertSectorsToMB. Disk has too many sectors\n"));
        INTERNAL_ERROR((L"Disk has too many sectors\n"));   // ok
    }

    return (ULONGLONG) ((SectorCount * BytesPerSector) / mb);
}

extern 
VOID
SpDeleteStorageVolumes (
    IN HANDLE SysPrepRegHandle,
    IN DWORD ControlSetNumber
    );

extern 
NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    );


VOID
SpAsrDeleteMountedDevicesKey(VOID)
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttrib;
    UNICODE_STRING      unicodeString;
    HANDLE              keyHandle;

    // 
    // Delete HKLM\SYSTEM\MountedDevices.
    //
    INIT_OBJA(&objAttrib, &unicodeString, ASR_MOUNTED_DEVICES_KEY);

    objAttrib.RootDirectory = NULL;

    status = ZwOpenKey(&keyHandle, KEY_ALL_ACCESS, &objAttrib);
    if(NT_SUCCESS(status)) {
        status = ZwDeleteKey(keyHandle);
        DbgStatusMesg((_asrinfo, 
            "SpAsrDeleteMountedDevicesKey. DeleteKey [%ls] on the setup hive returned 0x%lx. \n",
            ASR_MOUNTED_DEVICES_KEY, 
            status
            ));
        
        ZwClose(keyHandle);
    } 
    else {
        DbgErrorMesg((_asrwarn, 
            "SpAsrDeleteMountedDevicesKey. No [%ls] on the setup hive.\n", 
            ASR_MOUNTED_DEVICES_KEY));
    }
}


PVOID
SpAsrMemAlloc(
    ULONG Size, 
    BOOLEAN IsErrorFatal
    )
{
    PVOID ptr = SpMemAlloc(Size);

    if (ptr) {
        RtlZeroMemory(ptr, Size);
    }
    else {          // allocation failed
        if (IsErrorFatal) {
            DbgFatalMesg((_asrerr, 
                "SpAsrMemAlloc. Memory allocation failed, SpMemAlloc(%lu) returned NULL.\n",
                Size
                ));
            SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"Out of memory.");
        }
        else {
            DbgErrorMesg((_asrerr, 
                "SpAsrMemAlloc. Memory allocation failed, SpMemAlloc(%lu) returned NULL. Continuing.\n",
                Size
                ));
        }
    }

    return ptr;
}



BOOLEAN
SpAsrIsValidBootDrive(IN OUT PWSTR NtDir)
/*
    Returns TRUE if NtDir starts with ?:\, 
    where ? is between C and Z or c and z,
    and wcslen(NtDir) <= SpGetMaxNtDirLen().
    
    
    Converts the drive letter to uppercase.

*/
{
    if (!NtDir ||
        wcslen(NtDir) > SpGetMaxNtDirLen()
        ) {
        return FALSE;
    }



    // convert drive-letter to upper-case
    if (NtDir[0] >= L'c' && NtDir[0] <= L'z') {
        NtDir[0] = NtDir[0] - L'a' + L'A';
    }

    // check drive letter
    if (NtDir[0] < L'C' || NtDir[0] > L'Z') {
        return FALSE;
    }

    // check " :\"
    if (NtDir[1] == L':' && NtDir[2] == L'\\') {
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SpAsrIsBootPartitionRecord(IN ULONG CriticalPartitionFlag)
{
    return (BOOLEAN) (CriticalPartitionFlag & ASR_PTN_MASK_BOOT);
}


BOOLEAN
SpAsrIsSystemPartitionRecord(IN ULONG CriticalPartitionFlag)
{
    return (BOOLEAN) (CriticalPartitionFlag & ASR_PTN_MASK_SYS);
}



// Fatal Error Routines
//	-guhans! Lots of code-repitition here, there must be a more efficient way.


VOID
SpAsrRaiseFatalError(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr
	)
            
/*++
Routine:
  Terminate setup

Returns:

    None.
--*/
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
                  3,
                  HEADER_HEIGHT+1,
                  FALSE,
                  FALSE,
                  DEFAULT_ATTRIBUTE);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                           SP_STAT_F3_EQUALS_EXIT,
                           0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}


VOID
SpAsrRaiseFatalErrorWs(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr
        );
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorWsWs(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr1,
	IN PWSTR MessageStr2
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr1,
        MessageStr2
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorWsLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr,
	IN ULONG MessageVal
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr,
        MessageVal
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN ULONG MessageVal
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageVal
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorLuLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN ULONG MessageVal1,
	IN ULONG MessageVal2
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageVal1,
        MessageVal2
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}


#define ASCI_O 79
#define ASCI_o 111

//
// SpAsrFileErrorRetryIgnoreAbort
//  Display an error screen if the file that we are trying to
//  copy already exists on target system.  Allows user to
//  O   = Over-write existing file
//  ESC = Skip this file (preserve existing file)
//  F3  = Exit from Setup
//
//  Returns TRUE if the user chose overwrite
//          FALSE if the user chose skip
//  Does not return if the user hit ESC
//
BOOL
SpAsrFileErrorDeleteSkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR DestinationFile
    )
{
    ULONG optionKeys[] = {KEY_F3, ASCI_ESC};
    ULONG mnemonicKeys[] = {MnemonicOverwrite, 0};
    ULONG *keysPtr;
    BOOL done = FALSE, 
        overwriteFile = FALSE;

    while (!done) {

        SpStartScreen(
            ErrorCode,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            DestinationFile
            );

        keysPtr = optionKeys;

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_O_EQUALS_OVERWRITE,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        SpInputDrain();
    
        switch(SpWaitValidKey(keysPtr,NULL,mnemonicKeys)) {
            case (MnemonicOverwrite | KEY_MNEMONIC):
                overwriteFile = TRUE;
                done = TRUE;
                break;

            case ASCI_ESC:
                overwriteFile = FALSE;
                done = TRUE;
                break;

            case KEY_F3:
                SpDone(0, FALSE, TRUE);
                break;

        }
    }

    return overwriteFile;
}


//
// SpAsrFileErrorRetryIgnoreAbort
//  Display an error screen if the file could not be copied
//  over to the target system.  Allows user to
//  ENTER   = Retry
//  ESC     = Skip this file and continue
//  F3      = Exit from Setup
//
//  Returns TRUE if the user chose skip
//          FALSE if the user chose retry
//  Does not return if the user hit ESC
//
BOOL
SpAsrFileErrorRetrySkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR SourceFile,
    IN PWSTR Label,
    IN PWSTR Vendor,
    IN BOOL  AllowSkip
    )
{
    ULONG optionKeys[] = {KEY_F3, ASCI_CR, ASCI_ESC};
    ULONG mnemonicKeys[] = {0};
    ULONG *keysPtr;
    BOOL    done     = FALSE, 
            skipFile = FALSE;

    while (!done) {

        SpStartScreen(
            ErrorCode,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            SourceFile,
            Label,
            Vendor);

        keysPtr = optionKeys;

        if (AllowSkip) {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_ESC_EQUALS_SKIP_FILE,
                SP_STAT_F3_EQUALS_EXIT,
                0);
        }
        else {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_F3_EQUALS_EXIT,
                0);
        }

        SpInputDrain();
    
        switch(SpWaitValidKey(keysPtr,NULL,mnemonicKeys)) {
            case ASCI_CR:
                skipFile = FALSE;
                done = TRUE;
                break;

            case ASCI_ESC:
                if (AllowSkip) {
                    skipFile = TRUE;
                    done = TRUE;
                }
                break;

            case KEY_F3:
                SpDone(0, FALSE, TRUE);
                break;

        }
    }

    return skipFile;
}


VOID
SpAsrRaiseInternalError(
    IN  PWSTR   ModuleName,
    IN  PWSTR   ModuleCode,
    IN  ULONG   LineNumber,
    IN  PWSTR   KdPrintStr)
{
    PWSTR TmpMsgBuf = SpAsrMemAlloc(4096 * sizeof(WCHAR), TRUE);
    swprintf(TmpMsgBuf, L"%ws%lu", ModuleCode, LineNumber);

    DbgFatalMesg((_asrerr, 
        " Internal Error (%ws:%lu %ws) %ws\n", 
        ModuleName,
        LineNumber,
        TmpMsgBuf,
        KdPrintStr
        ));

    SpAsrRaiseFatalErrorWs(SP_TEXT_DR_INTERNAL_ERROR,
       KdPrintStr,
       TmpMsgBuf
       );
    //
    // Never gets here
    //

}


ULONGLONG
SpAsrStringToULongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    ULONGLONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

LONGLONG
SpAsrStringToLongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    LONGLONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

ULONG
SpAsrStringToULong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    ULONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


USHORT
SpAsrStringToUShort(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  USHORT    Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    USHORT Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


int
SpAsrCharToInt(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  USHORT    Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    USHORT Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


PWSTR
SpAsrHexStringToUChar (
    IN PWSTR String,
    OUT unsigned char * Number
    )
/*++
Routine Description:

    This routine converts the hex representation of a number into an
    unsigned char.  The hex representation is assumed to be a full
    two characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned char.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    WCHAR Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 2; Count++, String++) {
        if ((*String >= L'0') && (*String <= L'9')) {
            Result = (Result << 4) + *String - L'0';
        }
        else if ((*String >= L'A') && (*String <= L'F')) {
            Result = (Result << 4) + *String - L'A' + 10;
        }
        else if ((*String >= L'a') && (*String <= L'f')) {
            Result = (Result << 4) + *String - L'a' + 10;
        }
    }
    *Number = (unsigned char)Result;
    
    return String;
}


VOID
SpAsrGuidFromString(
    IN OUT GUID* Guid,
    IN PWSTR GuidString
    )
/*++

Routine Description:

  Gets a GUID from a string
    
Arguments:

    Guid    -   The GUID that holds string representation
    Buffer  -   The string version of the guid, in the form
    "%x-%x-%x-%x%x%x%x%x%x%x%x"

Return Value:

    Returns the converted string version of the given GUID

--*/            
{
    PWSTR Buffer = GuidString;
    int i = 0;

    if (Guid) {
        ZeroMemory(Guid, sizeof(GUID));
    }

    if (Guid && Buffer) {

        Guid->Data1 = SpAsrStringToULong(Buffer, NULL, 16);
        Buffer += 9;

        Guid->Data2 = SpAsrStringToUShort(Buffer, NULL, 16);
        Buffer += 5;

        Guid->Data3 = SpAsrStringToUShort(Buffer, NULL, 16);
        Buffer += 5;

        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[0]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[1]));
        ++Buffer;
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[2]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[3]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[4]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[5]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[6]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[7]));
    }
}


BOOLEAN
SpAsrIsZeroGuid(
    IN GUID * Guid
    ) 
{

    GUID ZeroGuid;

    ZeroMemory(&ZeroGuid, sizeof(GUID));

    if (!memcmp(&ZeroGuid, Guid, sizeof(GUID))) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdrsif.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:
    spdrsif.c

Abstract:
    Contains all routines involved in reading attributes from the asr.sif
    file and constructing partition records.

Terminology

Restrictions:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     21.Aug.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

// Module identification for debug traces
#define THIS_MODULE L" spdrsif.c"
#define THIS_MODULE_CODE L"S"
#define ASR_NULL_STRING (L"")

//
// Section names and other data used for retrieving information from the
// asr.sif file
//
const PWSTR SIF_ASR_VERSION_SECTION = L"VERSION";
const PWSTR SIF_ASR_SYSTEMS_SECTION = L"SYSTEMS";
const PWSTR SIF_ASRFLAGS_SECTION    = L"ASRFLAGS";
const PWSTR SIF_ASR_BUSES_SECTION = L"BUSES";
const PWSTR SIF_ASR_PARTITIONS_SECTION = L"PARTITIONS";
const PWSTR SIF_ASR_DISKS_SECTION = L"DISKS";
const PWSTR SIF_ASR_MBR_DISKS_SECTION = L"DISKS.MBR";
const PWSTR SIF_ASR_GPT_DISKS_SECTION = L"DISKS.GPT";
const PWSTR SIF_ASR_MBR_PARTITIONS_SECTION = L"PARTITIONS.MBR";
const PWSTR SIF_ASR_GPT_PARTITIONS_SECTION = L"PARTITIONS.GPT";
const PWSTR SIF_ASR_INSTALLFILES_SECTION = L"INSTALLFILES";

const PWSTR SIF_ASR_SIGNATURE_KEY = L"Signature";
const PWSTR SIF_ASR_PROVIDER_KEY = L"Provider";
const PWSTR SIF_ASR_SIFVERSION_KEY = L"ASR-Version";
const PWSTR ASR_SIF_RECOGNISED_SIGNATURE = L"$Windows NT$";
const PWSTR ASR_SIF_RECOGNISED_VERSION = L"1.";

const PWSTR ASR_FLOPPY_DEVICE_ALIAS     = L"%FLOPPY%";
const PWSTR ASR_CDROM_DEVICE_ALIAS      = L"%CDROM%";
const PWSTR ASR_SOURCE_DEVICE_ALIAS     = L"%SETUPSOURCE%";

const PWSTR ASR_SIF_TEMP_DIRECTORY_ALIAS   = L"%TEMP%\\";
const PWSTR ASR_SIF_TMP_DIRECTORY_ALIAS    = L"%TMP%\\";
const PWSTR ASR_SIF_SYSTEM_ROOT_ALIAS      = L"%SystemRoot%\\";

const PWSTR ASR_SIF_SILENT_REPARTITION_VALUE = L"SilentRepartition";

extern const PWSTR ASR_FLOPPY0_DEVICE_PATH;
extern const PWSTR ASR_CDROM0_DEVICE_PATH;
extern const PWSTR ASR_TEMP_DIRECTORY_PATH;
extern ULONG SuiteType;


// Indices for the [SYSTEMS] section.
typedef enum _SIF_SYSTEM_FIELD_INDEX {
    SIF_SYSTEM_NAME = 0,                    // Computer name    (not used in textmode ASR)
    SIF_SYSTEM_PLATFORM,                    // x86 or ia64
    SIF_SYSTEM_OSVERSION,                   // Windows version
    SIF_SYSTEM_NT_DIRECTORY_NAME,           // Windows directory
    SIF_SYSTEM_PARTITION_AUTOEXTEND_OPTION, // [optional]

    SIF_SYSTEM_PRODUCT_SUITE,               // SKU information

    //
    // Time Zone Information (not used in textmode ASR)
    //
    SIF_SYSTEM_TIMEZONE_INFORMATION,
    SIF_SYSTEM_TIMEZONE_STANDARD_NAME,
    SIF_SYSTEM_TIMEZONE_DAYLIGHT_NAME,

    SIF_SYSTEM_NUMFIELDS                // Must always be last
} SIF_SYSTEM_FIELD_INDEX;

// Indices for the [ASRFLAGS] section.
typedef enum _SIF_ASRFLAGS_FIELD_INDEX {
    SIF_ASRFLAGS_SILENT_REPARTITION_OPTION = 0,
    SIF_ASRFLAGS_NUMFIELDS                // Must always be last
} SIF_ASRFLAGS_FIELD_INDEX;


// Indices for the [BUSES] section.
typedef enum _SIF_BUSES_FIELD_INDEX {
    SIF_BUSES_SYSTEMKEY = 0,
    SIF_BUSES_BUS_TYPE,
    SIF_BUSES_NUMFIELDS                // Must always be last
} SIF_BUSES_FIELD_INDEX;


//
// Indices for the [DISKS.MBR] section.
//
// [DISKS.MBR] format
//
// disk-key = 0.system-key, 1.bus-key, 2.critical-flag,
//              3.disk-signature, 4.bytes-per-sector, 5.total-sectors
//
typedef enum _SIF_MBR_DISK_FIELD_INDEX {
    SIF_MBR_DISK_SYSTEMKEY = 0,
    SIF_MBR_DISK_BUSKEY,
    SIF_MBR_DISK_CRITICAL_FLAG,
    SIF_MBR_DISK_SIGNATURE,
    SIF_MBR_DISK_BYTES_PER_SECTOR,
    SIF_MBR_DISK_SECTORS_PER_TRACK,
    SIF_MBR_DISK_TRACKS_PER_CYLINDER,
    SIF_MBR_DISK_TOTALSECTORS,
    SIF_MBR_DISK_NUMFIELDS                // Must always be last
} SIF_MBR_DISK_FIELD_INDEX;


//
// Indices for the [DISKS.GPT] section.
//
// [DISKS.GPT] format
//
// disk-key = 0.system-key, 1.bus-key, 2.critical-flag, 3.disk-id,
//              4.min-partition-count, 5.bytes-per-sector, 6.total-sectors
//
typedef enum _SIF_GPT_DISK_FIELD_INDEX {
    SIF_GPT_DISK_SYSTEMKEY = 0,
    SIF_GPT_DISK_BUSKEY,
    SIF_GPT_DISK_CRITICAL_FLAG,
    SIF_GPT_DISK_DISK_ID,
    SIF_GPT_DISK_MAX_PTN_COUNT,
    SIF_GPT_DISK_BYTES_PER_SECTOR,
    SIF_GPT_DISK_SECTORS_PER_TRACK,
    SIF_GPT_DISK_TRACKS_PER_CYLINDER,
    SIF_GPT_DISK_TOTALSECTORS,
    SIF_GPT_DISK_NUMFIELDS                // Must always be last
} SIF_GPT_DISK_FIELD_INDEX;


//
// Indices for the [PARTITIONS.MBR] section.
//
// [PARTITIONS.MBR]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4.active-flag, 5.partition-type,
//                 6.file-system-type, 7.start-sector, 8.sector-count,
//                 9.fs-cluster-size
//
typedef enum _SIF_MBR_PARTITION_FIELD_INDEX {
    SIF_MBR_PARTITION_DISKKEY = 0,
    SIF_MBR_PARTITION_SLOT_INDEX,
    SIF_MBR_PARTITION_SYSBOOT_FLAGS,
    SIF_MBR_PARTITION_VOLUME_GUID,      //optional
    SIF_MBR_PARTITION_ACTIVE_FLAG,
    SIF_MBR_PARTITION_PTN_TYPE,
    SIF_MBR_PARTITION_FS_TYPE,
    SIF_MBR_PARTITION_STARTSECTOR,
    SIF_MBR_PARTITION_SECTORCOUNT,
    SIF_MBR_PARTITION_CLUSTER_SIZE,
    SIF_MBR_PARTITION_NUMFIELDS                // Must always be last
} SIF_MBR_PARTITION_FIELD_INDEX;


//
// Indices for the [PARTITIONS.GPT] section.
//
// [PARTITIONS.GPT]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4."partition-type-guid", 5."partition-id-guid"
//                 6.gpt-attributes, 7."partition-name", 8.file-system-type,
//                 9.start-sector, 10.sector-count, 11.fs-cluster-size
//
typedef enum _SIF_GPT_PARTITION_FIELD_INDEX {
    SIF_GPT_PARTITION_DISKKEY = 0,
    SIF_GPT_PARTITION_SLOT_INDEX,
    SIF_GPT_PARTITION_SYSBOOT_FLAGS,
    SIF_GPT_PARTITION_VOLUME_GUID,      //optional
    SIF_GPT_PARTITION_TYPE_GUID,
    SIF_GPT_PARTITION_ID_GUID,
    SIF_GPT_PARTITION_GPT_ATTRIBUTES,
    SIF_GPT_PARTITION_NAME,
    SIF_GPT_PARTITION_FS_TYPE,
    SIF_GPT_PARTITION_STARTSECTOR,
    SIF_GPT_PARTITION_SECTORCOUNT,
    SIF_GPT_PARTITION_CLUSTER_SIZE,
    SIF_GPT_PARTITION_NUMFIELDS                // Must always be last
} SIF_GPT_PARTITION_FIELD_INDEX;


// Indices for the [INSTALLFILES] section.
typedef enum _SIF_INSTALLFILE_FIELD_INDEX {
    SIF_INSTALLFILE_SYSTEM_KEY = 0,
    SIF_INSTALLFILE_SOURCE_MEDIA_LABEL,
    SIF_INSTALLFILE_SOURCE_DEVICE,
    SIF_INSTALLFILE_SOURCE_FILE_PATH,
    SIF_INSTALLFILE_DESTFILE,
    SIF_INSTALLFILE_VENDORSTRING,
    SIF_INSTALLFILE_FLAGS,
    SIF_INSTALLFILE_NUMFIELDS        // Must always be last
} SIF_INSTALLFILE_FIELD_INDEX;

// Global
PVOID           Gbl_HandleToDrStateFile;
extern PWSTR    Gbl_SifSourcePath;


// Forward Declarations
VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList);

PSIF_PARTITION_RECORD_LIST
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList);


///////////////////////////////
// Generic functions for all sections
//

//
// The string returned should not be freed, since it's part of Setup's internal sif
// data structure!
//
PWSTR
SpAsrGetSifDataBySectionAndKey(
    IN const PWSTR Section,
    IN const PWSTR Key,
    IN const ULONG Value,
    IN const BOOLEAN NonNullRequired
    )                               // does not return on error if NonNullRequired is TRUE
{
    PWSTR data = NULL;
    ASSERT(Section && Key);  // debug

    data = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        Section,
        Key,
        Value
        );

    if (NonNullRequired) {
        if (!data || !wcscmp(data, ASR_NULL_STRING)) {
            DbgFatalMesg((_asrerr, "SpAsrGetSifDataBySectionAndKey. Data is "
                "NULL. Section:[%ws], Key:[%ws], Value:[%lu]\n",
                Section, Key, Value));
            swprintf(TemporaryBuffer, L"%lu value not specified in %ws "
                L"record %ws", Value, Section, Key);
            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                TemporaryBuffer, Section);
            // does not return
        }
    }

    return data;
}


ULONG
SpAsrGetRecordCount(
    IN PWSTR Section,
    IN ULONG MinimumValid
    )
{
    ULONG count;
    ASSERT(Section);

    count = SpCountLinesInSection(Gbl_HandleToDrStateFile, Section);

    if (count < MinimumValid) {
        DbgFatalMesg((_asrerr, "SpAsrGetRecordCount. No records in [%ws] section.\n",
                             Section));

        swprintf(TemporaryBuffer, L"No records in section");

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                           TemporaryBuffer,
                           Section);
        // does not return
    }

    return count;
}


PWSTR
SpAsrGetSifKeyBySection(
    IN PWSTR Section,
    IN ULONG Index
    )                           // does not return on error
{
    PWSTR key;
    ULONG count = SpAsrGetRecordCount(Section, 1);

    // is index too big?
    if (Index > count) {
        DbgFatalMesg((_asrerr,
            "SpAsrGetSifKeyBySection. Section [%ws]. Index (%lu) greater than NumRecords (%lu)\n",
            Section,
            Index,
            count
            ));

        swprintf(TemporaryBuffer, L"Index too large: Key not found.");

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
            TemporaryBuffer,
            Section
            );
        // does not return
    }

    key = SpGetKeyName(Gbl_HandleToDrStateFile, Section, Index);

    if (!key || !wcscmp(key, ASR_NULL_STRING)) {

        DbgFatalMesg((_asrerr,
            "SpAsrGetSifKeyBySection. SpGetKeyName failed in Section:[%ws] for Index:%lu.\n",
            Section,
            Index
            ));

        swprintf(TemporaryBuffer, L"%ws key not found for record %lu", Section, Index + 1);

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
            TemporaryBuffer,
            Section
            );
        // does not return
     }

    return key;
}


///////////////////////////////
// [SYSTEMS] section functions
//

#define ASR_PRODUCTSUITES_TO_MATCH ((  VER_SUITE_SMALLBUSINESS               \
                                 | VER_SUITE_ENTERPRISE                  \
                                 | VER_SUITE_BACKOFFICE                  \
                                 | VER_SUITE_COMMUNICATIONS              \
                                 | VER_SUITE_SMALLBUSINESS_RESTRICTED    \
                                 | VER_SUITE_EMBEDDEDNT                  \
                                 | VER_SUITE_DATACENTER                  \
                                 | VER_SUITE_PERSONAL))

//
// This checks to make sure that Windows media being used for the recovery
// is the same SKU as that in asr.sif  (so the user isn't trying to recover
// an ADS installation with a PRO CD, for instance), and that the platform
// of the target machine is the same as that in asr.sif  (so the user isn't
// trying to recover an ia64 with an x86 asr.sif, for instance)
//
VOID
SpAsrCheckSystemCompatibility()
{
    PWSTR sifPlatform = NULL;
    WCHAR currentPlatform[10];
    DWORD suiteInSif = 0, currentSuite = 0, productInSif = 0;
    BOOLEAN validSKU = TRUE;

    sifPlatform = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        ASR_SIF_SYSTEM_KEY,
        SIF_SYSTEM_PLATFORM,
        TRUE
        );

    wcscpy(currentPlatform, L"unknown");
#if defined(_X86_)
    wcscpy(currentPlatform, L"x86");
#elif defined(_IA64_)
    wcscpy(currentPlatform, L"ia64");
#endif

    if (_wcsicmp(sifPlatform, currentPlatform)) {

        DbgFatalMesg((_asrerr,
            "asr.sif SYSTEM section. Invalid platform [%ws] (does not match the current platform)\n",
            sifPlatform
            ));

        SpAsrRaiseFatalError(
            SP_SCRN_DR_INCOMPATIBLE_MEDIA,
            L"Invalid platform"
            );
    }

    suiteInSif = STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        ASR_SIF_SYSTEM_KEY,
        SIF_SYSTEM_PRODUCT_SUITE,
        TRUE
        ));

    productInSif = HIWORD(suiteInSif);
    suiteInSif = LOWORD(suiteInSif) & ASR_PRODUCTSUITES_TO_MATCH;

    if (suiteInSif) {
        if (!SuiteType) {
            //
            // SuiteType is set to 0 for PRO and SRV, and so cannot directly be
            // used in SpIsProductSuite().  These are the values that SuiteType
            // seems to be set to:
            //
            // PER  0x200   VER_SUITE_PERSONAL
            // BLA  0x400   VER_SUITE_BLADE
            // PRO  0x0	
            // SRV  0x0
            // ADS  0x2	    VER_SUITE_ENTERPRISE
            // DTC  0x82    VER_SUITE_DATACENTER | VER_SUITE_ENTERPRISE
            //
            //
            //
            // Not sure of the reasoning behind this, but let's make use of this
            // fact (cf SpGetHeaderTextId)
            //

            //
            // Since SuiteType is 0, this must be PRO or SRV.  This can be determined
            // by checking the global AdvancedServer
            //
            validSKU = (AdvancedServer ?
                (
                 ((productInSif == VER_NT_SERVER) ||             // must be SRV
                 (productInSif == VER_NT_DOMAIN_CONTROLLER)) &&  //
                 !(suiteInSif | VER_SUITE_ENTERPRISE)            // and not ADS or DTC
                )
                :
                ( (productInSif == VER_NT_WORKSTATION) &&       // must be PRO
                  !(suiteInSif | VER_SUITE_PERSONAL)            // and not PER
                )
            );
        }
        else if (
            ((productInSif != VER_NT_SERVER) && (productInSif != VER_NT_DOMAIN_CONTROLLER)) ||
            !SpIsProductSuite(suiteInSif)
            ) {
            validSKU = FALSE;
        }
    }

    if (!validSKU) {
        DbgFatalMesg((_asrerr,
            "asr.sif SYSTEM Section. Invalid suite 0x%08x (does not match the current media).\n",
            suiteInSif
            ));

        SpAsrRaiseFatalError(
            SP_SCRN_DR_INCOMPATIBLE_MEDIA,
            L"Invalid version"
            );
    }
}


ULONG
SpAsrGetSystemRecordCount(VOID)   // does not return on error
{
    return SpAsrGetRecordCount(SIF_ASR_SYSTEMS_SECTION, 1);
}


PWSTR
SpAsrGetNtDirectoryPathBySystemKey(IN PWSTR SystemKey)        // does not return on error
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        SystemKey,
        SIF_SYSTEM_NT_DIRECTORY_NAME,
        TRUE
        );
}


BOOLEAN
SpAsrGetAutoExtend(IN PWSTR SystemKey)
{
    PWSTR value = NULL;
    ASSERT(SystemKey);

    value = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        SIF_ASR_SYSTEMS_SECTION,
        SystemKey,
        SIF_SYSTEM_PARTITION_AUTOEXTEND_OPTION
        );

    if (!value || !wcscmp(value, ASR_NULL_STRING)) {
        DbgErrorMesg((_asrwarn, "Auto-extend not specified, assuming Enabled\n"));
        return TRUE;
    }
    else {
        return (BOOLEAN) STRING_TO_LONG(value);
    }
}


///////////////////////////////
// [ASRFLAGS] section functions
//

BOOLEAN
SpAsrGetSilentRepartitionFlag(IN PWSTR SystemKey)
{
    PWSTR value = NULL;
    ASSERT(SystemKey);

    value = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        SIF_ASRFLAGS_SECTION,
        SystemKey,
        SIF_ASRFLAGS_SILENT_REPARTITION_OPTION
        );

    if (value && !_wcsicmp(value, ASR_SIF_SILENT_REPARTITION_VALUE)) {
        DbgErrorMesg((_asrwarn, "SilentRepartition flag is set; will NOT prompt before repartitioning disks!\n"));
        return TRUE;
    }

    DbgStatusMesg((_asrinfo, "SilentRepartition flag not set; will prompt user before repartitioning disks\n"));
    return FALSE;
}


///////////////////////////////
// [VERSION] section functions
//

VOID
SpAsrCheckAsrStateFileVersion()
{
    PWSTR signature = NULL,
        provider = NULL,
        sifVersion = NULL;

    signature = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_SIGNATURE_KEY,
        0,
        TRUE
        );

    provider = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_PROVIDER_KEY,
        0,
        FALSE
        );     // ProviderName is optional

    sifVersion = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_SIFVERSION_KEY,
        0,
        TRUE
        );

    DbgStatusMesg((_asrinfo,
        "Asr Sif Version. sig:[%ws], provider:[%ws], sifVer:[%ws]\n",
        signature,
        provider ? provider : L"",
        sifVersion
        ));

    if (_wcsicmp(signature, ASR_SIF_RECOGNISED_SIGNATURE)) {

        DbgFatalMesg((_asrerr,
            "asr.sif VERSION section. Invalid signature [%ws] (it MUST be $Windows NT$).\n",
            signature
            ));

        SpAsrRaiseFatalError(
            SP_TEXT_DR_STATEFILE_ERROR,
            L"Invalid signature"
            );
    }

    if (_wcsnicmp(sifVersion, ASR_SIF_RECOGNISED_VERSION, wcslen(ASR_SIF_RECOGNISED_VERSION))) {

        DbgFatalMesg((_asrerr,
            "asr.sif VERSION Section. Invalid asr.sif version [%ws] (it MUST be 1.x).\n",
            sifVersion
            ));

        SpAsrRaiseFatalError(
            SP_TEXT_DR_STATEFILE_ERROR,
            L"Invalid version"
            );
    }

    SpAsrCheckSystemCompatibility();
}


/////////////////////////////////
// InstallFiles section functions
//

ULONG
SpAsrGetInstallFilesRecordCount(VOID)         // does not return on error
{
    return SpAsrGetRecordCount(SIF_ASR_INSTALLFILES_SECTION, 0);
}


PSIF_INSTALLFILE_RECORD
SpAsrGetInstallFileRecord(IN PWSTR InstallFileKey, IN PCWSTR SetupSourceDevicePath)
{
    PSIF_INSTALLFILE_RECORD pRec = NULL;
    PWSTR   tempStr = NULL;
    BOOL    isValid = FALSE;

    if (!InstallFileKey) {
        DbgFatalMesg((_asrerr, "SpAsrGetInstallFileRecord. InstallFileKey is NULL\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"InstallFileKey is NULL",
            SIF_ASR_INSTALLFILES_SECTION
            );
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_INSTALLFILE_RECORD), TRUE);

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SYSTEM_KEY,
        TRUE
        );

    pRec->CurrKey = InstallFileKey;

    pRec->SourceMediaExternalLabel = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_MEDIA_LABEL,
        TRUE
        );


    tempStr = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_DEVICE,
        TRUE
        );

    //
    // Check if the device is specified as %FLOPPY%, %CDROM% or %SETUPSOURCE%,
    // and use the full path (\device\floppy0 or \device\CdRom0 or 
    // SetupSourceDevicePath) if so.
    //
    if (!_wcsicmp(tempStr, ASR_FLOPPY_DEVICE_ALIAS)) {
        pRec->DiskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);
    }
    else if (!_wcsicmp(tempStr, ASR_CDROM_DEVICE_ALIAS)) {
        pRec->DiskDeviceName = SpDupStringW(ASR_CDROM0_DEVICE_PATH);
    }
    else if (!_wcsicmp(tempStr, ASR_SOURCE_DEVICE_ALIAS) && SetupSourceDevicePath) {
        pRec->DiskDeviceName = SpDupStringW(SetupSourceDevicePath);
    }
    else {
        //
        // It wasn't any of the aliases--he's allowed to specify
        // the full device path, so we use it as is.
        //
        pRec->DiskDeviceName = SpDupStringW(tempStr);
    }

    pRec->SourceFilePath = (PWSTR) SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_FILE_PATH,
        TRUE
        );

    tempStr = (PWSTR) SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_DESTFILE,
        TRUE
        );

    //
    //  Set the CopyToDirectory based on the tempStr path
    //
    if (!_wcsnicmp(tempStr, ASR_SIF_TEMP_DIRECTORY_ALIAS, wcslen(ASR_SIF_TEMP_DIRECTORY_ALIAS))) {
        //
        // Begins is %TEMP%\
        //
        pRec->CopyToDirectory = _Temp;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_TEMP_DIRECTORY_ALIAS)]));
    }
    else if (!_wcsnicmp(tempStr, ASR_SIF_TMP_DIRECTORY_ALIAS, wcslen(ASR_SIF_TMP_DIRECTORY_ALIAS))) {
        //
        // Begins is %TMP%\
        //
        pRec->CopyToDirectory = _Tmp;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_TMP_DIRECTORY_ALIAS)]));
    }
    else if (!_wcsnicmp(tempStr, ASR_SIF_SYSTEM_ROOT_ALIAS, wcslen(ASR_SIF_SYSTEM_ROOT_ALIAS))) {
        //
        // Begins is %SYSTEMROOT%\
        //
        pRec->CopyToDirectory = _SystemRoot;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_SYSTEM_ROOT_ALIAS)]));
    }
    else {
        //
        // Not specified, or unknown: use default.
        //
        pRec->CopyToDirectory = _Default;
        pRec->DestinationFilePath = SpDupStringW(tempStr);
    }

    pRec->VendorString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_VENDORSTRING,
        TRUE
        );

    tempStr = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_FLAGS,
        FALSE
        );
    if (tempStr) {
        pRec->Flags = STRING_TO_HEX(tempStr);
    }

    return pRec;
}


VOID
SpAsrInsertInstallFileRecord(
    IN SIF_INSTALLFILE_LIST *InstallFileList,
    IN PSIF_INSTALLFILE_RECORD pRec
    )
{
    pRec->Next = InstallFileList->First;
    InstallFileList->First = pRec;
    InstallFileList->Count += 1;
}


PSIF_INSTALLFILE_RECORD
SpAsrRemoveInstallFileRecord(IN SIF_INSTALLFILE_LIST *InstallFileList)
{
    PSIF_INSTALLFILE_RECORD pRec = NULL;

    if (InstallFileList->Count > 0) {
        pRec = InstallFileList->First;
        InstallFileList->First = pRec->Next;
        InstallFileList->Count -= 1;
    }

    return pRec;
}


VOID
SpAsrDeleteInstallFileRecord(
    IN OUT PSIF_INSTALLFILE_RECORD pRec
    )
{
    //
    // Free the memory we allocated.  The other fields are pointers to
    // setup's internal inf data structure, we shouldn't free those
    // else they'd get freed twice.
    //
    if (pRec->DiskDeviceName) {
        SpMemFree(pRec->DiskDeviceName);
        pRec->DiskDeviceName = NULL;
    }

    if (pRec->DestinationFilePath) {
        SpMemFree(pRec->DestinationFilePath);
        pRec->DestinationFilePath = NULL;
    }

    SpMemFree(pRec);
    pRec = NULL;
}


PSIF_INSTALLFILE_LIST
SpAsrInit3rdPartyFileList(IN PCWSTR SetupSourceDevicePath)
{
    PSIF_INSTALLFILE_RECORD pRec;
    PSIF_INSTALLFILE_LIST pList = NULL;
    ULONG count, index;

    if ((count = SpAsrGetInstallFilesRecordCount()) == 0) {
        return NULL;
    }

    pList = SpAsrMemAlloc(sizeof(SIF_INSTALLFILE_LIST), TRUE);

    for (index = 0; index < count; index++) {

        pRec = SpAsrGetInstallFileRecord(SpAsrGetSifKeyBySection(SIF_ASR_INSTALLFILES_SECTION, index), SetupSourceDevicePath);
        DbgStatusMesg((_asrinfo, "SpAsrInit3rdPartyFileList. Adding [%ws] to list\n", pRec->SourceFilePath));
        SpAsrInsertInstallFileRecord(pList, pRec);
    }

    return pList;
}



////////////////////////////
// [BUSES] section function
//

STORAGE_BUS_TYPE
SpAsrGetBusType(IN ULONG Index)
{

    STORAGE_BUS_TYPE BusType;

    PWSTR BusKey = SpAsrGetSifKeyBySection(SIF_ASR_BUSES_SECTION, Index);

    BusType = (STORAGE_BUS_TYPE) (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_BUSES_SECTION,
            BusKey,
            SIF_BUSES_BUS_TYPE,
            TRUE
             )));

    return BusType;
}




////////////////////////////
// [DISKS] section function
//

//
// Returns the total number of disk records (both MBR and GPT)
//
ULONG
SpAsrGetGptDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Count = (ULONG) (-1);

    if ((ULONG) (-1) == Count) {
        Count = SpAsrGetRecordCount(SIF_ASR_GPT_DISKS_SECTION, 0);
    }

    return Count;
}


ULONG
SpAsrGetMbrDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Count = (ULONG) (-1);

    if ((ULONG) (-1) == Count) {
        Count = SpAsrGetRecordCount(SIF_ASR_MBR_DISKS_SECTION, 0);
    }

    return Count;
}

ULONG
SpAsrGetDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Total = (ULONG) (-1);

    if ((ULONG) (-1) == Total ) {
        Total = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();
    }

    return Total;
}



PWSTR
SpAsrGetDiskKey(
    IN PARTITION_STYLE Style,   // GPT or MBR
    IN ULONG Index
    )       // does not return on error
{
    switch (Style) {

    case PARTITION_STYLE_GPT:
        return SpAsrGetSifKeyBySection(SIF_ASR_GPT_DISKS_SECTION, Index);
        break;

    case PARTITION_STYLE_MBR:
        return SpAsrGetSifKeyBySection(SIF_ASR_MBR_DISKS_SECTION, Index);
        break;

    }

    ASSERT(0 && L"Illegal partition style specified");
    return NULL;
}


PSIF_DISK_RECORD
SpAsrGetMbrDiskRecord(
    IN PWSTR DiskKey
    )
{
    PSIF_DISK_RECORD pRec;

    if (!DiskKey) {
        ASSERT(0 && L"SpAsrGetMbrDiskRecord:  DiskKey is NULL!");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);
    //
    // This is an MBR disk
    //
    pRec->PartitionStyle = PARTITION_STYLE_MBR;

    //
    // [DISKS.MBR] format
    //
    // 0.disk-key = 1.system-key, 2.bus-key, 3.critical-flag,
    //              4.disk-signature, 5.bytes-per-sector, 6.total-sectors
    //

    pRec->CurrDiskKey = DiskKey;

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SYSTEMKEY,
        TRUE
        );

    pRec->BusKey = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_BUSKEY,
        TRUE
        ));
    pRec->BusType = SpAsrGetBusType(pRec->BusKey - 1);   // our key is 1 based, AsrGetBusType index is 0 based

    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        pRec->IsCritical = TRUE;
    }
    else {
        pRec->IsCritical = (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_MBR_DISKS_SECTION ,
            DiskKey,
            SIF_MBR_DISK_CRITICAL_FLAG,
            TRUE
            ))) ? TRUE : FALSE;
    }

    pRec->SifDiskMbrSignature = STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SIGNATURE,
        TRUE
        ));

    pRec->BytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SectorsPerTrack = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SECTORS_PER_TRACK,
        TRUE
        ));

    pRec->TracksPerCylinder = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_TRACKS_PER_CYLINDER,
        TRUE
        ));

    pRec->TotalSectors = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_TOTALSECTORS,
        TRUE
        ));

    return pRec;
}


PSIF_DISK_RECORD
SpAsrGetGptDiskRecord(
    IN PWSTR DiskKey
    )
{
    PSIF_DISK_RECORD pRec = NULL;
    PWSTR GuidString = NULL;

    if (!DiskKey) {
        ASSERT(0 && L"SpAsrGetGptDiskRecord:  DiskKey is NULL!");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);

    pRec->PartitionStyle = PARTITION_STYLE_GPT;

    //
    // [DISKS.GPT] format
    //
    // 0.disk-key = 1.system-key, 2.bus-key, 3.critical-flag, 4.disk-id,
    //              5.min-partition-count, 6.bytes-per-sector, 7.total-sectors
    //

    pRec->CurrDiskKey = DiskKey;

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION,
        DiskKey,
        SIF_GPT_DISK_SYSTEMKEY,
        TRUE
        );

    pRec->BusKey = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_BUSKEY,
        TRUE
        ));

    pRec->BusType = SpAsrGetBusType(pRec->BusKey - 1);   // our key is 1 based, AsrGetBusType index is 0 based

    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        pRec->IsCritical = TRUE;
    }
    else {
        pRec->IsCritical = (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_GPT_DISKS_SECTION ,
            DiskKey,
            SIF_GPT_DISK_CRITICAL_FLAG,
            TRUE
            ))) ? TRUE : FALSE;
    }

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_DISK_ID,
        TRUE
        );
    SpAsrGuidFromString(&(pRec->SifDiskGptId), GuidString);

    pRec->MaxGptPartitionCount = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_MAX_PTN_COUNT,
        TRUE
        ));

    pRec->BytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SectorsPerTrack = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_SECTORS_PER_TRACK,
        TRUE
        ));

    pRec->TracksPerCylinder = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_TRACKS_PER_CYLINDER,
        TRUE
        ));

    pRec->TotalSectors = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_TOTALSECTORS,
        TRUE
        ));

    return pRec;
}


PSIF_DISK_RECORD
SpAsrGetDiskRecord(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
    )
{
    switch (PartitionStyle) {
    case PARTITION_STYLE_MBR:
        return SpAsrGetMbrDiskRecord(DiskKey);
        break;

    case PARTITION_STYLE_GPT:
        return SpAsrGetGptDiskRecord(DiskKey);
        break;
    }

    ASSERT(0 && L"Invalid partition type specified");
    return NULL;

}



PSIF_DISK_RECORD
SpAsrCopyDiskRecord(IN PSIF_DISK_RECORD pInput)
{
    PSIF_DISK_RECORD pRec;

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);

    CopyMemory(pRec, pInput, sizeof(SIF_DISK_RECORD));

    pRec->PartitionList = NULL;

    // copy the list of partitions, if any.
    if (pInput->PartitionList) {
        pRec->PartitionList = SpAsrCopyPartitionRecordList(pInput->PartitionList);
    }

    return pRec;
}


////////////////////////////////
// [PARTITIONS] section function
//

ULONG
SpAsrGetMbrPartitionRecordCount(VOID)
{
    return SpAsrGetRecordCount(SIF_ASR_MBR_PARTITIONS_SECTION, 0);
}

ULONG
SpAsrGetGptPartitionRecordCount(VOID)
{
    return SpAsrGetRecordCount(SIF_ASR_GPT_PARTITIONS_SECTION, 0);
}

PWSTR
SpAsrGetMbrPartitionKey(ULONG Index)
{
    return SpAsrGetSifKeyBySection(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        Index);
}


PWSTR
SpAsrGetGptPartitionKey(ULONG Index)
{
    return SpAsrGetSifKeyBySection(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        Index);
}


PWSTR
SpAsrGetDiskKeyByMbrPartitionKey(IN PWSTR PartitionKey)
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_DISKKEY,
        TRUE);
}


PWSTR
SpAsrGetDiskKeyByGptPartitionKey(IN PWSTR PartitionKey)
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_DISKKEY,
        TRUE);
}

ULONGLONG
SpAsrGetSectorCountByMbrDiskKey(
    IN PWSTR DiskKey
    )
{
    return STRING_TO_ULONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION,
        DiskKey,
        SIF_MBR_DISK_TOTALSECTORS,
        FALSE
        ));
}

ULONGLONG
SpAsrGetSectorCountByGptDiskKey(
    IN PWSTR DiskKey
    )
{
    return STRING_TO_ULONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION,
        DiskKey,
        SIF_GPT_DISK_TOTALSECTORS,
        FALSE
        ));
}


//
// Reads in a partition record from the [PARTITIONS.MBR] section.
//
// [PARTITIONS.MBR]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4.active-flag, 5.partition-type,
//                 6.file-system-type, 7.start-sector, 8.sector-count
//
PSIF_PARTITION_RECORD
SpAsrGetMbrPartitionRecord(IN PWSTR PartitionKey)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONG bytesPerSector = 0;
    ULONG ntSysMask = 0;

    //
    // PartitionKey better not be null
    //
    if (!PartitionKey) {
        DbgErrorMesg((_asrwarn, "SpAsrGetPartitionRecord. PartitionKey is NULL\n"));
        ASSERT(0 && L"Partition key is NULL");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);

    //
    // Read in the fields
    //
    pRec->CurrPartKey = PartitionKey;
    pRec->PartitionStyle = PARTITION_STYLE_MBR;

    pRec->DiskKey = SpAsrGetDiskKeyByMbrPartitionKey(PartitionKey);

    pRec->PartitionTableEntryIndex = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SLOT_INDEX,
        TRUE
        ));

    pRec->PartitionFlag = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SYSBOOT_FLAGS,
        TRUE
        ));

    pRec->VolumeGuid = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_VOLUME_GUID,
        FALSE
        );

    pRec->ActiveFlag = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_ACTIVE_FLAG,
        TRUE
        ));

    pRec->PartitionType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_PTN_TYPE,
        TRUE
        ));

    pRec->FileSystemType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_FS_TYPE,
        TRUE
        ));

    pRec->StartSector = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_STARTSECTOR,
        TRUE
        ));

    pRec->SectorCount = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SECTORCOUNT,
        TRUE
        ));

    pRec->ClusterSize = (DWORD) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_CLUSTER_SIZE,
        TRUE
        ));

    if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {

        // do not free!
        PWSTR ntDirPath = SpAsrGetNtDirectoryPathBySystemKey(ASR_SIF_SYSTEM_KEY);

        if (!SpAsrIsValidBootDrive(ntDirPath)) {

            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                L"ASSERT FAILURE: Improperly formed NT Directory Name",
                SIF_ASR_MBR_PARTITIONS_SECTION
                );
            // does not return
        }

        pRec->NtDirectoryName = SpAsrMemAlloc((SpGetMaxNtDirLen()*sizeof(WCHAR)), TRUE);

        wcsncpy(pRec->NtDirectoryName, ntDirPath + 2, wcslen(ntDirPath) - 2);
    }
    else {
        pRec->NtDirectoryName = NULL;
    }

    bytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        pRec->DiskKey,
        SIF_MBR_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, bytesPerSector);

    return pRec;
}


PSIF_PARTITION_RECORD
SpAsrGetGptPartitionRecord(IN PWSTR PartitionKey)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONG bytesPerSector = 0;
    ULONG ntSysMask = 0;
    PWSTR GuidString = NULL;

    if (!PartitionKey) {

        DbgErrorMesg((_asrwarn, "SpAsrGetPartitionRecord. PartitionKey is NULL\n"));

        ASSERT(0 && L"Partition key is NULL");

        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);

    //
    // Read in the fields
    //
    pRec->CurrPartKey = PartitionKey;
    pRec->PartitionStyle = PARTITION_STYLE_GPT;

    pRec->DiskKey = SpAsrGetDiskKeyByGptPartitionKey(PartitionKey);

    pRec->PartitionTableEntryIndex = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SLOT_INDEX,
        TRUE
        ));

    pRec->PartitionFlag = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SYSBOOT_FLAGS,
        TRUE
        ));

    pRec->VolumeGuid = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_VOLUME_GUID,
        FALSE
        );

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_TYPE_GUID,
        FALSE
        );
    SpAsrGuidFromString(&(pRec->PartitionTypeGuid), GuidString);

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_ID_GUID,
        FALSE
        );
    SpAsrGuidFromString(&(pRec->PartitionIdGuid), GuidString);

    pRec->PartitionName = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_NAME,
        FALSE
        );

    pRec->GptAttributes = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_GPT_ATTRIBUTES,
        TRUE
        ));

    pRec->FileSystemType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_FS_TYPE,
        TRUE
        ));

    pRec->StartSector = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_STARTSECTOR,
        TRUE
        ));

    pRec->SectorCount = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SECTORCOUNT,
        TRUE
        ));


    pRec->ClusterSize = (DWORD) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_CLUSTER_SIZE,
        TRUE
        ));

    if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {

        // do not free!
        PWSTR ntDirPath = SpAsrGetNtDirectoryPathBySystemKey(ASR_SIF_SYSTEM_KEY);

        if (!SpAsrIsValidBootDrive(ntDirPath)) {

            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                L"ASSERT FAILURE: Improperly formed NT Directory Name",
                SIF_ASR_GPT_PARTITIONS_SECTION
                );
            // does not return
        }


        pRec->NtDirectoryName = SpAsrMemAlloc((SpGetMaxNtDirLen()*sizeof(WCHAR)), TRUE);

        wcsncpy(pRec->NtDirectoryName, ntDirPath + 2, wcslen(ntDirPath) - 2);

    }
    else {
        pRec->NtDirectoryName = NULL;
    }

    bytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        pRec->DiskKey,
        SIF_GPT_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, bytesPerSector);

    return pRec;
}


PSIF_PARTITION_RECORD
SpAsrCopyPartitionRecord(IN PSIF_PARTITION_RECORD pInput)
{
    PSIF_PARTITION_RECORD pRec = NULL;

    if (!pInput) {
        ASSERT(0 && L"SpAsrCopyPartitionRecord: Invalid NULL input parameter");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);
    //
    // Won't return if pRec is NULL
    //
    ASSERT(pRec);

    //
    // Copy the record over
    //
    CopyMemory(pRec, pInput, sizeof(SIF_PARTITION_RECORD));

    //
    // And allocate space for the directory name
    //
    pRec->NtDirectoryName = NULL;
    if (
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag)  &&
        pInput->NtDirectoryName
        ) {

        pRec->NtDirectoryName = SpAsrMemAlloc(
            (wcslen(pInput->NtDirectoryName) + 1) * sizeof(WCHAR),
            TRUE
            );
        //
        // Won't return NULL
        //
        ASSERT(pRec->NtDirectoryName);

        wcscpy(pRec->NtDirectoryName, pInput->NtDirectoryName);
    }

    return pRec;
}


VOID
SpAsrInsertPartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST pList,
    IN PSIF_PARTITION_RECORD pRec
    )
/*++
Description:

    Inserts a partition record into a list of partition records.  Partition
    records are ordered in ascending order by start sector.  That is, the
    partition record with the lowest numbered start sector will be the first
    partition record in the list.

Arguments:

    pList   The list into which the record is to be inserted.

    pRec    The record to insert.

Returns:

    None.
--*/
{
    SIF_PARTITION_RECORD *curr = NULL, *prev = NULL;

    ASSERT(pList && pRec);

    // set the initial conditions.
    pRec->Next = NULL;
    pRec->Prev = NULL;

    pList->ElementCount += 1;


    // special Case I:  Insert into an empty list.
    if( pList->ElementCount == 1 ) {
        pList->First = pList->Last = pRec;
        return;
    }


    // Special Case II: pRec must be inserted before the first element.
    if( pRec->StartSector < pList->First->StartSector ) {
        pRec->Next = pList->First;
        pList->First = pRec;
        pRec->Next->Prev = pRec;
        return;
    }


    // Special Case III:  pRec must be appended after the last element
    // because pRec's start sector is greater than the last element
    // on the list (which, by construction, must have the largest
    // start sector).
    //
    if( pList->Last->StartSector < pRec->StartSector ) {
        pRec->Prev = pList->Last;
        pList->Last->Next = pRec;
        pList->Last = pRec;
        return;
    }

    // If we're here, then pRec's start sector must be greater than
    // the start sector of the first element on the list but less than
    // the start sector of the list's last element.  We walk the list
    // to find the insertion point, i.e., immediately before the first
    // element in the list whose start sector is greater than that of
    // pRec's.
    curr = prev = pList->First;
    while (pRec->StartSector > curr->StartSector && curr->Next) {
        prev = curr;
        curr = curr->Next;
    }


    // insert pRec between curr and prev
    pRec->Next = curr;
    pRec->Prev = prev;

    curr->Prev = pRec;
    prev->Next = pRec;

    ASSERT (pRec->Prev->Next == pRec);
    ASSERT (pRec->Next->Prev == pRec);
}


VOID
SpAsrRemovePartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST pList,
    IN PSIF_PARTITION_RECORD pRec
    )
/*++

  Description:
    Unhook a partition record from a list of partition records.

--*/
{
    ASSERT(pList && pRec);

    // unhook it from the list.
    if (pRec->Prev) {
        pRec->Prev->Next = pRec->Next;
    }

    if (pRec->Next) {
        pRec->Next->Prev = pRec->Prev;
    }

    // was this the first record in the list?
    if (pList->First == pRec) {
        pList->First = pRec->Next;
    }

    // or the last record?
    if (pList->Last == pRec) {
        pList->Last = pRec->Prev;
    }

    pRec->Next = pRec->Prev = NULL;
}


PSIF_PARTITION_RECORD
SpAsrPopNextPartitionRecord(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD poppedRecord = NULL;

    if (!pList) {
//        ASSERT(0 && L"Trying to pop records off of a NULL list");
        return NULL;
    }

    // get the first node in the list
    if (poppedRecord = pList->First) {

        // advance the First pointer to the next node
        if (pList->First = pList->First->Next) {

            // and make the Prev of the new first-node be NULL
            pList->First->Prev = NULL;
        }

        pList->ElementCount -= 1;

        // the poppedRecord is not part of the list any more
        poppedRecord->Next = NULL;
        poppedRecord->Prev = NULL;
    }

    return poppedRecord;
}


PSIF_PARTITION_RECORD_LIST
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList)
{
    PSIF_PARTITION_RECORD_LIST pDestList = NULL;
    PSIF_PARTITION_RECORD pRec = NULL, pNew = NULL;

    if (!pSrcList) {
        ASSERT(0 && L"SpAsrCopyPartitionRecordList:  Invalid NULL input parameter");
        return NULL;
    }

    pDestList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);
    //
    // Won't return if pDestList is NULL.
    //
    ASSERT(pDestList);

    pRec = pSrcList->First;
    while (pRec) {

        pNew = SpAsrCopyPartitionRecord(pRec);
        ASSERT(pNew);

        SpAsrInsertPartitionRecord(pDestList, pNew);

        pRec = pRec->Next;
    }

    pDestList->TotalMbRequired = pSrcList->TotalMbRequired;

    return pDestList;
}



VOID
SpAsrCheckAsrSifVersion()
{

    return;
}


//
// Debug routines
//
#if 0
VOID
SpAsrDbgDumpSystemRecord(IN PWSTR Key)
{

    PWSTR osVer = SpAsrGetSifDataBySectionAndKey(SIF_ASR_SYSTEMS_SECTION,
                                               Key,
                                               SIF_SYSTEM_OSVERSION,
                                               FALSE);

    DbgMesg((_asrinfo,
        "Key:%ws = SysName:[%ws], OsVer:[%ws], NtDir:[%ws], AutoExt:[%ws]\n",
        Key,
        SpAsrGetSifDataBySectionAndKey(SIF_ASR_SYSTEMS_SECTION, Key, SIF_SYSTEM_NAME, TRUE),
        osVer? osVer : L"",
        SpAsrGetNtDirectoryPathBySystemKey(Key),
        SpAsrGetAutoExtend(Key)
        ));
}


VOID
SpAsrDbgDumpSystemRecords(VOID)
{
    ULONG index, count = SpAsrGetSystemRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [SYSTEM] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpSystemRecord(SpAsrGetSifKeyBySection(SIF_ASR_SYSTEMS_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [SYSTEM] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpDiskRecord(IN PWSTR Key)
{
    PSIF_DISK_RECORD pRec = NULL;

    if (!Key) {
        return;
    }

    pRec = SpAsrGetDiskRecord(Key);
    if (!pRec) {
        return;
    }

    DbgMesg((_asrinfo,
        "Key:[%ws] = Sys:[%ws] SifDskNum:[%ws], SifDskSig:0x%lx, ScSz:%lu, TtlSc:%I64u",
        pRec->CurrDiskKey,
        pRec->SystemKey,
        pRec->SifDiskSignature,
        pRec->BytesPerSector,
        pRec->TotalSectors
        ));


    if (pRec->ExtendedPartitionStartSector > -1) {
        KdPrintEx((_asrinfo, ", extSS:%I64u, extSC:%I64u",
                    pRec->ExtendedPartitionStartSector,
                    pRec->ExtendedPartitionSectorCount));
    }

    KdPrintEx((_asrinfo, "\n"));
    SpMemFree(pRec);
}


VOID
SpAsrDbgDumpDiskRecords(VOID)
{
    ULONG index, count = SpAsrGetMbrDiskRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [DISK.MBR] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpDiskRecord(SpAsrGetSifKeyBySection(SIF_ASR_MBR_DISKS_SECTION , index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [DISK.MBR] Section (%lu Records) -----\n", count));

    count = SpAsrGetGptDiskRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [DISK.GPT] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpDiskRecord(SpAsrGetSifKeyBySection(SIF_ASR_GPT_DISKS_SECTION , index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [DISK.GPT] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpPartitionRecord(IN PARTITION_STYLE PartitinStyle, IN PWSTR Key)
{
    PSIF_PARTITION_RECORD pRec =  SpAsrGetPartitionRecord(Key);

    DbgMesg((_asrinfo,
        "Key:[%ws] = Dsk %ws, ntDir:[%ws], volGd:[%ws], actv:0x%x, type:0x%x, fs:0x%x boot:%ws, sys:%ws, SS:%I64u SC:%I64u sz:%I64u\n",
        pRec->CurrPartKey,
        pRec->DiskKey,
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag) ? pRec->NtDirectoryName : L"n/a",
        pRec->VolumeGuid ? pRec->VolumeGuid : L"n/a",
        pRec->ActiveFlag,
        pRec->PartitionType,
        pRec->FileSystemType,
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag) ? "Y" : "N",
        SpAsrIsSystemPartitionRecord(pRec->PartitionFlag) ? "Y" : "N",
        pRec->StartSector,
        pRec->SectorCount,
        pRec->SizeMB
        ));

    SpMemFree(pRec);
}


VOID
SpAsrDbgDumpPartitionList(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD pRec;
    ASSERT(pList);
    DbgStatusMesg((_asrinfo, "----- Dumping Partition List: -----\n"));

    pRec = pList->First;
    while (pRec) {
        SpAsrDbgDumpPartitionRecord(pRec->CurrPartKey);
        pRec = pRec->Next;
    }
    DbgStatusMesg((_asrinfo, "----- End of Partition List -----\n"));
}


VOID
SpAsrDbgDumpPartitionRecords(VOID)
{
    ULONG index, count = SpAsrGetPartitionRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [PARTITION] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpPartitionRecord(SpAsrGetSifKeyBySection(SIF_ASR_MBR_PARTITIONS_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [PARTITION] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpInstallFileRecord(IN PWSTR Key)
{
    PSIF_INSTALLFILE_RECORD pRec = SpAsrGetInstallFileRecord(Key,NULL);

    DbgMesg((_asrinfo,
        "Key:[%ws] = SysKey:[%ws], MediaLabel:[%ws], Media:[%ws], Src:[%ws], Dest:[%ws], Vendor:[%ws]",
        Key,
        pRec->SystemKey,
        pRec->SourceMediaExternalLabel,
        pRec->DiskDeviceName,
        pRec->SourceFilePath,
        pRec->DestinationFilePath,
        pRec->VendorString
        ));

    SpMemFree(pRec);
}

VOID
SpAsrDbgDumpInstallFileRecords(VOID)
{
    ULONG index, count = SpAsrGetInstallFilesRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [INSTALLFILE] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpInstallFileRecord(SpAsrGetSifKeyBySection(SIF_ASR_INSTALLFILES_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [INSTALLFILE] Section (%lu Records) -----\n", count));
}

VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList)
{
    PSIF_INSTALLFILE_RECORD pRec;

    if (pList == NULL) {
        DbgStatusMesg((_asrinfo, "No 3rd party files are specified.\n"));
    }
    else {
        DbgStatusMesg((_asrinfo, "----- Dumping Install-file List: -----\n"));
        pRec = pList->First;
        while (pRec) {
            SpAsrDbgDumpInstallFileRecord(pRec->CurrKey);
            pRec = pRec->Next;
        }
        DbgStatusMesg((_asrinfo, "----- End of Install-file List -----\n"));
    }
}

VOID
SpAsrDbgTestSifFunctions(VOID)
{
    SpAsrDbgDumpSystemRecords();
    SpAsrDbgDumpDiskRecords();
    SpAsrDbgDumpPartitionRecords();
    SpAsrDbgDumpInstallFileRecords();
}
#endif // Debug routines
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfile.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfile.h

Abstract:

    Public header file for file-related functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPFILE_DEFN_
#define _SPFILE_DEFN_


NTSTATUS
SpGetFileSize(
    IN  HANDLE hFile,
    OUT PULONG Size
    );

NTSTATUS
SpMapEntireFile(
    IN  HANDLE   hFile,
    OUT PHANDLE  Section,
    OUT PVOID   *ViewBase,
    IN  BOOLEAN  WriteAccess
    );

BOOLEAN
SpUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    );

NTSTATUS
SpOpenAndMapFile(
    IN     PWSTR    FileName,
    IN OUT PHANDLE  FileHandle,
    OUT    PHANDLE  SectionHandle,
    OUT    PVOID   *ViewBase,
    OUT    PULONG   FileSize,
    IN     BOOLEAN  WriteAccess
    );

NTSTATUS
SpSetInformationFile(
    IN HANDLE                 Handle,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG                  Length,
    IN PVOID                  FileInformation
    );

NTSTATUS
SpDeleteFileEx(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    );

NTSTATUS
SpDeleteFile(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3  OPTIONAL
    );

NTSTATUS
SpSetAttributes (
    IN      PWSTR SrcNTPath,
    IN      ULONG FileAttributes
    );

NTSTATUS
SpGetAttributes (
    IN      PWSTR SrcNTPath,
    OUT     PULONG FileAttributesPtr
    );

BOOLEAN
SpFileExists(
    IN PCWSTR PathName,
    IN BOOLEAN Directory
    );

NTSTATUS
SpRenameFile(
    IN PWSTR   OldName,
    IN PWSTR   NewName,
    IN BOOLEAN AllowDirectoryRename
    );

PIMAGE_NT_HEADERS
SpChecksumMappedFile(
    IN  PVOID  BaseAddress,
    IN  ULONG  FileSize,
    OUT PULONG HeaderSum,
    OUT PULONG Checksum
    );

NTSTATUS
SpOpenNameMayBeCompressed(
    IN  PWSTR    FullPath,
    IN  ULONG    OpenAccess,
    IN  ULONG    FileAttributes,
    IN  ULONG    ShareFlags,
    IN  ULONG    Disposition,
    IN  ULONG    OpenFlags,
    OUT PHANDLE  Handle,
    OUT PBOOLEAN OpenedCompressedName   OPTIONAL
    );

NTSTATUS
SpGetFileSizeByName(
    IN  PWSTR DevicePath OPTIONAL,
    IN  PWSTR Directory  OPTIONAL,
    IN  PWSTR FileName,
    OUT PULONG Size
    );

VOID
SpVerifyNoCompression(
    IN PWSTR FileName
    );

#endif // ndef _SPFILE_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdsputl.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdsputl.c

Abstract:

    Display utility routines for text setup.

Author:

    Ted Miller (tedm) 12-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

extern BOOLEAN ForceConsole;
BOOLEAN DisableCmdConsStatusText = TRUE;

//
// This value will hold the localized mnemonic keys,
// in order indicated by the MNEMONIC_KEYS enum.
//
PWCHAR MnemonicValues;


//
// As messages are built on on-screen, this value remembers where
// the next message in the screen should be placed.
//
ULONG NextMessageTopLine = 0;


ULONG
SpDisplayText(
    IN PWCHAR  Message,
    IN ULONG   MsgLen,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y
    )

/*++

Routine Description:

    Worker routine for vSpDisplayFormattedMessage().

Arguments:

    Message - supplies message text.

    MsgLen - supplies the number of unicode characters in the message,
        including the terminating nul.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    arglist - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen, unless CenterVertically
    is TRUE, in which case n is the line number of the first line below where
    the text was displayed.

--*/

{
    PWCHAR p,q;
    WCHAR c;
    ULONG y;
    int i;

    //
    // Must have at least one char + terminating nul in there.
    //
    if(MsgLen <= 1) {
        return(CenterVertically ? (VideoVars.ScreenHeight/2) : 0);
    }

    //
    // MsgLen includes terminating nul.
    //
    p = Message + MsgLen - 1;

    //
    // Find last non-space char in message.
    //
    while((p > Message) && SpIsSpace(*(p-1))) {
        p--;
    }

    //
    // Find end of the last significant line and terminate the message
    // after it.
    //
    if(q = wcschr(p,L'\n')) {
        *(++q) = 0;
    }

    for(i = (CenterVertically ? 0 : 1); i<2; i++) {

        for(y=Y, p=Message; q = SpFindCharFromListInString(p,L"\n\r"); y++) {

            c = *q;
            *q = 0;

            if(i) {

                BOOLEAN Intense = (BOOLEAN)((p[0] == L'%') && (p[1] == L'I'));

                SpvidDisplayString(
                    Intense ? p+2 : p,
                    (UCHAR)(Attribute | (Intense ? ATT_FG_INTENSE : 0)),
                    CenterHorizontally
                        ? (VideoVars.ScreenWidth-(SplangGetColumnCount(p)-(Intense ? 2 : 0)))/2 : X,
                    y
                    );
            }

            *q = c;

            //
            // If cr/lf terminated the line, make sure we skip both chars.
            //
            if((c == L'\r') && (*(q+1) == L'\n')) {
                q++;
            }

            p = ++q;
        }

        //
        // Write the final line (if there is one).
        //
        if(i) {
            if(wcslen(p)) {
                SpvidDisplayString(
                    p,
                    Attribute,
                    CenterHorizontally ? (VideoVars.ScreenWidth-SplangGetColumnCount(p))/2 : X,
                    y++
                    );
            }
        }

        if(i == 0) {
            //
            // Center the text on the screen (not within the client area).
            //
            Y = (VideoVars.ScreenHeight - (y-Y)) / 2;
        }
    }

    return(CenterVertically ? y : (y-Y));
}


ULONG
vSpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    IN va_list arglist
    )

/*++

Routine Description:

    A formatted multiline message may be displayed with this routine.
    The format string is fetched from setup's text resources; arguments
    are substituted into the format string according to FormatMessage
    semantics.

    The screen is NOT cleared by this routine.

    If a line starts with %I (ie, the first 2 characters at the
    start of the message, or after a newline), it will be displayed
    with the intensity attribute on.

Arguments:

    MessageId - supplies id of message resource containing the text,
        which is treated as a format string for FormatMessage.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    arglist - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen, unless CenterVertically
    is TRUE, in which case n is the line number of the first line below where
    the text was displayed.

--*/

{
    ULONG BytesInMsg;
    ULONG n;

    vSpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),MessageId,&BytesInMsg,&arglist);

    //
    // Must have at least one char + terminating nul in there.
    //
    if(BytesInMsg <= sizeof(WCHAR)) {
        return(CenterVertically ? (VideoVars.ScreenHeight/2) : 0);
    }

    n = SpDisplayText(
            TemporaryBuffer,
            BytesInMsg / sizeof(WCHAR),
            CenterHorizontally,
            CenterVertically,
            Attribute,
            X,
            Y
            );

    return(n);
}



ULONG
SpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    ...
    )

/*++

Routine Description:

    Display a message on the screen.  Does not clear the screen first.

Arguments:

    MessageId - supplies id of message resource containing the text,
        which is treated as a format string for FormatMessage.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    ... - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen.

--*/

{
    va_list arglist;
    ULONG   n;

    va_start(arglist,Y);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            CenterVertically,
            Attribute,
            X,
            Y,
            arglist
            );

    va_end(arglist);

    return(n);
}




VOID
SpDisplayHeaderText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute
    )

/*++

Routine Description:

    Display text in the header area of the screen. The header area will be
    cleared to the given attribute before displaying the text. We will
    draw a double-underline under the text also.

Arguments:

    MessageId - supplies id of message resource containing the text.

    Attribute - supplies attributes for text.

Return Value:

    none.

--*/

{
    ULONG Length,i;
    WCHAR Underline;
    WCHAR *p;

    SpvidClearScreenRegion(0,0,VideoVars.ScreenWidth,HEADER_HEIGHT,(UCHAR)(Attribute >> 4));

    //
    // Get message and display at (1,1)
    //
    vSpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),MessageId,NULL,NULL);
    p = (WCHAR *)TemporaryBuffer;
    SpvidDisplayString(p,Attribute,1,1);

    //
    // Build a row of underline characters.
    //
    Length = SplangGetColumnCount(p) + 2;
    Underline = SplangGetLineDrawChar(LineCharDoubleHorizontal);

    for(i=0; i<Length; i++) {
        p[i] = Underline;
    }
    p[Length] = 0;

    SpvidDisplayString(p,Attribute,0,2);

}


#define MAX_STATUS_ACTION_LABEL 50
WCHAR StatusActionLabel[MAX_STATUS_ACTION_LABEL];
ULONG StatusActionLeftX;
ULONG StatusActionObjectX;
BOOLEAN StatusActionLabelDisplayed = FALSE;

VOID
SpDisplayStatusActionLabel(
    IN ULONG ActionMessageId,   OPTIONAL
    IN ULONG FieldWidth
    )
{
    ULONG l;

    if(ActionMessageId) {
        //
        // Prefix the text with a separating vertical bar.
        //
        StatusActionLabel[0] = SplangGetLineDrawChar(LineCharSingleVertical);

        //
        // Fetch the action verb (something like "Copying:")
        //
        SpFormatMessage(
            StatusActionLabel+1,
            sizeof(StatusActionLabel)-sizeof(WCHAR),
            ActionMessageId
            );

        //
        // Now calculate the position on the status line
        // for the action label.  We want to leave 1 space
        // between the colon and the object, and a space between
        // the object and the rightmost column on the screen.
        //
        l = SplangGetColumnCount(StatusActionLabel);

        StatusActionObjectX = VideoVars.ScreenWidth - FieldWidth - 1;
        StatusActionLeftX = StatusActionObjectX - l - 1;

        //
        // Display the label and clear out the rest of the line.
        //
        SpvidDisplayString(
            StatusActionLabel,
            DEFAULT_STATUS_ATTRIBUTE,
            StatusActionLeftX,
            VideoVars.ScreenHeight-STATUS_HEIGHT
            );

        SpvidClearScreenRegion(
            StatusActionObjectX-1,
            VideoVars.ScreenHeight-STATUS_HEIGHT,
            VideoVars.ScreenWidth-StatusActionObjectX+1,
            STATUS_HEIGHT,
            DEFAULT_STATUS_BACKGROUND
            );

        StatusActionLabelDisplayed = TRUE;
    } else {
        //
        // Caller wants to clear out the previous area.
        //
        StatusActionLabel[0] = 0;
        SpvidClearScreenRegion(
            StatusActionLeftX,
            VideoVars.ScreenHeight-STATUS_HEIGHT,
            VideoVars.ScreenWidth-StatusActionLeftX,
            STATUS_HEIGHT,
            DEFAULT_STATUS_BACKGROUND
            );
        StatusActionLabelDisplayed = FALSE;
    }
}

VOID
SpDisplayStatusActionObject(
    IN PWSTR ObjectText
    )
{
    //
    // clear the area and draw the text.
    //
    SpvidClearScreenRegion(
        StatusActionObjectX,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth-StatusActionObjectX,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    SpvidDisplayString(
        ObjectText,
        DEFAULT_STATUS_ATTRIBUTE,
        StatusActionObjectX,
        VideoVars.ScreenHeight-STATUS_HEIGHT
        );
}

VOID
SpCmdConsEnableStatusText(
  IN BOOLEAN EnableStatusText
  )
{
  DisableCmdConsStatusText = !EnableStatusText;
}


VOID
SpDisplayStatusText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute,
    ...
    )
{
    va_list arglist;

    if (ForceConsole && DisableCmdConsStatusText) {
        return;
    }

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        (UCHAR)(Attribute >> 4)      // background part of attribute
        );

    va_start(arglist,Attribute);

    vSpDisplayFormattedMessage(
        MessageId,
        FALSE,FALSE,            // no centering
        Attribute,
        2,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        arglist
        );

    va_end(arglist);
}


VOID
SpDisplayStatusOptions(
    IN UCHAR Attribute,
    ...
    )
{
    WCHAR StatusText[79];
    WCHAR Option[79];
    va_list arglist;
    ULONG MessageId;


    StatusText[0] = 0;

    va_start(arglist,Attribute);

    while(MessageId = va_arg(arglist,ULONG)) {

        //
        // Fetch the message text for this option.
        //
        Option[0] = 0;
        SpFormatMessage(Option,sizeof(Option),MessageId);

        //
        // If the option fits, place it in the status text line we're
        // building up.
        //
        if((SplangGetColumnCount(StatusText) + SplangGetColumnCount(Option) + 2)
                                                     < (sizeof(StatusText)/sizeof(StatusText[0]))) {
            wcscat(StatusText,L"  ");
            wcscat(StatusText,Option);
        }
    }

    va_end(arglist);

    //
    // Display the text.
    //

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        (UCHAR)(Attribute >> (UCHAR)4)      // background part of attribute
        );

    SpvidDisplayString(StatusText,Attribute,0,VideoVars.ScreenHeight-STATUS_HEIGHT);
}



VOID
SpStartScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   TopLine,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    ...
    )

/*++

Routine Description:

    Display a formatted message on the screen, treating it as the first
    message in what might be a multi-message screen.

    The client area of the screen will be cleared before displaying the message.

Arguments:

    MessageId - supplies id of message resource containing the text.

    LeftMargin - supplies the 0-based x-coordinate for the each line of the text.

    TopLine - supplies the 0-based y-coordinate for the topmost line of the text.

    CenterHorizontally - if TRUE, each line in the message will be printed
        centered horizontally.  In this case, LeftMargin is ignored.

    CenterVertically - if TRUE, the message will approximately centered vertically
        within the client area of the screen.  In this case, TopLine is ignored.

    Attribute - supplies attribute for text.

    ... - supply arguments for insertion/substitution into the message text.

Return Value:

    none.

--*/

{
    va_list arglist;
    ULONG   n;

    CLEAR_CLIENT_SCREEN();

    va_start(arglist,Attribute);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            CenterVertically,
            Attribute,
            LeftMargin,
            TopLine,
            arglist
            );

    va_end(arglist);

    //
    // Remember where the message ended.
    //
    NextMessageTopLine = CenterVertically ? n : TopLine+n;
}



VOID
SpContinueScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   SpacingLines,
    IN BOOLEAN CenterHorizontally,
    IN UCHAR   Attribute,
    ...
    )

/*++

Routine Description:

    Display a formatted message on the screen, treating it as the continuation
    of a multi-message screen previously begun by calling SpStartScreen().
    The message will be placed under the previously displayed message.

Arguments:

    MessageId - supplies id of message resource containing the text.

    LeftMargin - supplies the 0-based x-coordinate for the each line of the text.

    SpacingLines - supplies the number of lines to leave between the end of the
        previous message and the start of this message.

    CenterHorizontally - if TRUE, each line in the message will be printed
        centered horizontally.  In this case, LeftMargin is ignored.

    Attribute - supplies attribute for text.

    ... - supply arguments for insertion/substitution into the message text.

Return Value:

    none.

--*/

{
    va_list arglist;
    ULONG   n;

    va_start(arglist,Attribute);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            FALSE,
            Attribute,
            LeftMargin,
            NextMessageTopLine + SpacingLines,
            arglist
            );

    va_end(arglist);

    //
    // Remember where the message ended.
    //
    NextMessageTopLine += n + SpacingLines;
}


VOID
vSpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    IN va_list arglist
    )

/*++

Routine Description:

    This routine outputs a multiline message to the screen, dumping it
    terminal style, to the console.

    The format string is fetched from setup's text resources; arguments are
    substituted into the format string according to FormatMessage semantics;
    and then the resulting unicode string is translated into an ANSI string
    suitable for the HAL printing routine.

    The screen is NOT cleared by this routine.

Arguments:

    MessageId    - supplies id of message resource containing the text,
                   which is treated as a format string for FormatMessage.

    SpacingLines - supplies the number of lines to skip down before starting this
                   message.

    arglist      - supply arguments for insertion into the given message.

Return Value:

    none.

--*/

{
    ULONG BytesInMsg, BufferLeft, i;
    PWCHAR p, q;
    WCHAR  c;
    PUCHAR HalPrintString;

    vSpFormatMessage(
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            MessageId,
            &BytesInMsg,
            &arglist
            );

    //
    // Must have at least one char + terminating nul in there.
    //
    if(BytesInMsg <= sizeof(WCHAR)) {
        return;
    } else {
        for(i=0; i<SpacingLines; i++) {
            InbvDisplayString("\r\n");
        }
    }

    //
    // BytesInMsg includes terminating nul.
    //
    p = TemporaryBuffer + (BytesInMsg / sizeof(WCHAR)) - 1;

    //
    // Find last non-space char in message.
    //
    while((p > TemporaryBuffer) && SpIsSpace(*(p-1))) {
        p--;
    }

    //
    // Find end of the last significant line and terminate the message
    // after it.
    //
    if(q = wcschr(p, L'\n')) {
        *(++q) = 0;
        q++;
    } else {
        q = TemporaryBuffer + (BytesInMsg / sizeof(WCHAR));
    }

    //
    // Grab rest of buffer to put ANSI translation into
    //
    HalPrintString = (PUCHAR)q;
    BufferLeft = (ULONG)(sizeof(TemporaryBuffer) - ((PUCHAR)q - (PUCHAR)TemporaryBuffer));

    //
    // Print out message, line-by-line
    //
    for(p=TemporaryBuffer; q = SpFindCharFromListInString(p, L"\n\r"); ) {

        c = *q;
        *q = 0;

        RtlUnicodeToOemN(
            HalPrintString,
            BufferLeft,
            &BytesInMsg,
            p,
            (ULONG)((PUCHAR)q - (PUCHAR)p + sizeof(WCHAR))
            );

        if(BytesInMsg) {
            InbvDisplayString(HalPrintString);
        }

        InbvDisplayString("\r\n");

        *q = c;

        //
        // If cr/lf terminated the line, make sure we skip both chars.
        //
        if((c == L'\r') && (*(q+1) == L'\n')) {
            q++;
        }

        p = ++q;
    }

    //
    // Write the final line (if there is one).
    //
    if(wcslen(p)) {

        RtlUnicodeToOemN(
            HalPrintString,
            BufferLeft,
            &BytesInMsg,
            p,
            (wcslen(p) + 1) * sizeof(WCHAR)
            );

        if(BytesInMsg) {
            InbvDisplayString(HalPrintString);
        }
        InbvDisplayString("\r\n");

    }
}


VOID
SpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    ...
    )

/*++

Routine Description:

    Output a message to the screen using the HAL-supplied console output routine.
    The message is merely dumped, line-by-line, to the screen, terminal-style.

Arguments:

    MessageId    - supplies id of message resource containing the text,
                   which is treated as a format string for FormatMessage.

    SpacingLines - supplies the number of lines to skip down before starting this
                   message.

    ...          - supply arguments for insertion into the given message.

Return Value:

    none.

--*/

{
    va_list arglist;

    va_start(arglist, SpacingLines);

    vSpDisplayRawMessage(
            MessageId,
            SpacingLines,
            arglist
            );

    va_end(arglist);
}


VOID
SpBugCheck(
    IN ULONG BugCode,
    IN ULONG Param1,
    IN ULONG Param2,
    IN ULONG Param3
    )

/*++

Routine Description:

    Display a message on the screen, informing the user that a fatal
    Setup error has occurred, and that they should reboot the machine.

Arguments:

    BugCode     - Bugcheck code number as defined in spmisc.h and documented in
                  ntos\nls\bugcodes.txt

    Param1      - 1st informative parameter

    Param2      - 2nd informative parameter

    Param3      - 3rd informative parameter

Return Value:

    DOES NOT RETURN

--*/

{
    if(VideoInitialized) {

        //
        // If we are in upgrade graphics mode then
        // switch to textmode
        //
        SpvidSwitchToTextmode();


        SpStartScreen(
                SP_SCRN_FATAL_SETUP_ERROR,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                BugCode,
                Param1,
                Param2,
                Param3
                );

        if(KbdLayoutInitialized) {
            SpContinueScreen(
                    SP_SCRN_F3_TO_REBOOT,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT, DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0,FALSE, TRUE);

        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpContinueScreen(
                    SP_SCRN_POWER_DOWN,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);

            while(TRUE);    // Loop forever
        }
    } else {
        SpDisplayRawMessage(
                SP_SCRN_FATAL_SETUP_ERROR,
                2,
                BugCode,
                Param1,
                Param2,
                Param3
                );
        SpDisplayRawMessage(SP_SCRN_POWER_DOWN, 1);

        while(TRUE);    // loop forever
    }
}


VOID
SpDrawFrame(
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN ULONG   TopY,
    IN ULONG   Height,
    IN UCHAR   Attribute,
    IN BOOLEAN DoubleLines
    )
{
    PWSTR Buffer;
    ULONG u;
    WCHAR w;

    Buffer = SpMemAlloc((Width+1) * sizeof(WCHAR));
    ASSERT(Buffer);
    if(!Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to allocate memory for buffer to draw frame\n"));
        return;
    }

    Buffer[Width] = 0;

    //
    // Top.
    //
    w = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleHorizontal : LineCharSingleHorizontal);
    for(u=1; u<Width-1; u++) {
        Buffer[u] = w;
    }

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleUpperLeft  : LineCharSingleUpperLeft);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleUpperRight : LineCharSingleUpperRight);

    SpvidDisplayString(Buffer,Attribute,LeftX,TopY);

    //
    // Bottom.
    //

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleLowerLeft  : LineCharSingleLowerLeft);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleLowerRight : LineCharSingleLowerRight);

    SpvidDisplayString(Buffer,Attribute,LeftX,TopY+Height-1);

    //
    // Interior lines.
    //
    for(u=1; u<Width-1; u++) {
        Buffer[u] = L' ';
    }

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleVertical : LineCharSingleVertical);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleVertical : LineCharSingleVertical);

    for(u=1; u<Height-1; u++) {
        SpvidDisplayString(Buffer,Attribute,LeftX,TopY+u);
    }

    SpMemFree(Buffer);
}



ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2,  OPTIONAL
    IN PULONG MnemonicKeys OPTIONAL
    )

/*++

Routine Description:

    Wait for a key to be pressed that appears in a list of valid keys.

Arguments:

    ValidKeys1 - supplies list of valid keystrokes.  The list must be
        terminated with a 0 entry.

    ValidKeys2 - if specified, supplies an additional list of valid keystrokes.

    MnemonicKeys - if specified, specifies a list of indices into the
        SP_MNEMONICS message string (see the MNEMONIC_KEYS enum).
        If the user's keystroke is not listed in ValidKeys, it will be
        uppercased and compared against each character indexed by a value
        in MnemonicKeys.  If a match is found, the returned value is the
        index (ie,MNEMONIC_KEYS enum value), and the high bit will be set.

Return Value:

    The key that was pressed (see above).

--*/

{
    ULONG c;
    ULONG i;


    SpInputDrain();

    while(1) {

        c = SpInputGetKeypress();

        //
        // Check for normal key.
        //

        for(i=0; ValidKeys1[i]; i++) {
            if(c == ValidKeys1[i]) {
                return(c);
            }
        }

        //
        // Check secondary list.
        //
        if(ValidKeys2) {
            for(i=0; ValidKeys2[i]; i++) {
                if(c == ValidKeys2[i]) {
                    return(c);
                }
            }
        }

        //
        // Check for mnemonic keys.
        //
        if(MnemonicKeys && !(c & KEY_NON_CHARACTER)) {

            c = (ULONG)RtlUpcaseUnicodeChar((WCHAR)c);

            for(i=0; MnemonicKeys[i]; i++) {

                if((WCHAR)c == MnemonicValues[MnemonicKeys[i]]) {

                    return((ULONG)MnemonicKeys[i] | KEY_MNEMONIC);
                }
            }
        }
    }
}

//
// Attributes for text edit fields.
//
#define EDIT_FIELD_BACKGROUND ATT_WHITE
#define EDIT_FIELD_TEXT       (ATT_FG_BLACK | ATT_BG_WHITE)


BOOLEAN
SpGetInput(
    IN     PKEYPRESS_CALLBACK ValidateKey,
    IN     ULONG              X,
    IN     ULONG              Y,
    IN     ULONG              MaxLength,
    IN OUT PWCHAR             Buffer,
    IN     BOOLEAN            ValidateEscape
    )

/*++

Routine Description:

    Allow the user to enter text in an edit field of a specified size.

    Some special keys are interpreted and handled locally; others are passed
    to a caller-supplied routine for validation.

    Keys handled locally include ENTER, BACKSPACE, and ESCAPE (subject to ValidateEscape):
    these keys will never be passed to the callback routine.

    Other keys are passed to the callback function.  This specifically includes
    function keys, which may have special meaning to the caller, and upon which
    the caller must act before returning.  (IE, if the user presses F3, the caller
    might put up an exit confirmation dialog.

Arguments:

    ValidateKey - supplies address of a function to be called for each keypress.
        The function takes the keypress as an argument, and returns one of the
        following values:

        ValidationAccept - acecpt the keystroke into the string being input.
            If the keystroke is not a unicode character (ie, is a function key)
            then this value must not be returned.

        ValidationIgnore - do not accept the keystroke into the string.

        ValidationReject - same as ValidationIgnore, except that there may be some
            addition action, such as beeping the speaker.

        ValidationTerminate - end input ad return from SpGetInput immediately
            with a value of FALSE.

        ValidationRepaint - same as ValidationIgnore, except that the input field is
            repainted.

    X,Y - specify the coordinate for the leftmost character in the edit field.

    MaxLength - supplies the maximum number of characters in the edit field.

    Buffer - On input supplies a default string for the edit field. On output,
        receives the string entered by the user.  This buffer should be large
        enough to contain MaxLength +1 unicode characters (ie, should be able to
        hold a nul-terminated string of length MaxLength).

    ValidateEscape - if TRUE, treat escape like a normal character, passing it to
        the validation routine.  If FALSE, escape clears the input field.

Return Value:

    TRUE if the user's input was terminated normally (ie, by he user pressed ENTER).
    FALSE if terminated by ValidateKey returning ValidationTerminate.

--*/

{
    ULONG c;
    ValidationValue vval;
    ULONG CurrentCharCount;
    WCHAR str[3];
    WCHAR CURSOR = SplangGetCursorChar();

    //
    // Make sure edit field is in a reasonable place on the screen.
    //
    ASSERT(X + MaxLength + 1 < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight - STATUS_HEIGHT);

    //
    // Prime the pump.
    //
    vval = ValidateRepaint;
    CurrentCharCount = wcslen(Buffer);
    str[1] = 0;
    str[2] = 0;

    ASSERT(CurrentCharCount <= MaxLength);

    while(1) {

        //
        // Perform action based on previous state.
        //
        switch(vval) {

        case ValidateAccept:

            //
            // Insert the previous key into the input.
            //
            ASSERT(Buffer[CurrentCharCount] == 0);
            ASSERT(CurrentCharCount < MaxLength);
            ASSERT(!(c & KEY_NON_CHARACTER));

            Buffer[CurrentCharCount++] = (USHORT)c;
            Buffer[CurrentCharCount  ] = 0;
            break;

        case ValidateRepaint:

            //
            // Repaint the edit field in its current state.
            // The edit field is one character too large, to accomodate
            // the cursor after the last legal character in the edit field.
            //
            SpvidClearScreenRegion(X,Y,MaxLength+1,1,EDIT_FIELD_BACKGROUND);
            SpvidDisplayString(Buffer,EDIT_FIELD_TEXT,X,Y);

            //
            // Draw the cursor.
            //
            str[0] = CURSOR;
            SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);
            break;

        case ValidateIgnore:
        case ValidateReject:

            //
            // Ignore the previous keystroke.
            //
            break;


        case ValidateTerminate:

            //
            // Callback wants us to terminate.
            //
            return(FALSE);
        }

        //
        // Get a keystroke.
        //
        c = SpInputGetKeypress();

        //
        // Do something with the key.
        //
        switch(c) {

        case ASCI_CR:

            //
            // Input is terminated. We're done.
            //
            return(TRUE);

        case ASCI_BS:

            //
            // Backspace character.  If we're not at the beginning
            // of the edit field, erase the previous character, replacing it
            // with the cursor character.
            //
            if(CurrentCharCount) {

                Buffer[--CurrentCharCount] = 0;
                str[0] = CURSOR;
                str[1] = L' ';
                SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);
                str[1] = 0;
            }

            vval = ValidateIgnore;
            break;

        case ASCI_ESC:

            //
            // Escape character. Clear the edit field.
            //
            if(!ValidateEscape) {
                RtlZeroMemory(Buffer,(MaxLength+1) * sizeof(WCHAR));
                CurrentCharCount = 0;
                vval = ValidateRepaint;
                break;
            }

            //
            // Otherwise, we want to validate escape like a normal character.
            // So just fall through.
            //

        default:

            //
            // Some other character. Pass it to the callback function
            // for validation.
            //
            vval = ValidateKey(c);

            if(vval == ValidateAccept) {

                //
                // We want to accept the keystroke.  If there is not enough
                // room in the buffer, convert acceptance to ignore.
                // Otherwise (ie, there is enough room), put the character
                // up on the screen and advance the cursor.
                //
                if(CurrentCharCount < MaxLength) {

                    ASSERT(!(c & KEY_NON_CHARACTER));

                    str[0] = (WCHAR)c;
                    SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);

                    str[0] = CURSOR;
                    SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount+1,Y);

                } else {

                    vval = ValidateIgnore;
                }
            }

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfontup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfontup.c

Abstract:

    Code to handle upgrading fonts.

    Around build 1150 or so, fonts were moved from the system
    directory to the fonts directory to be compatible with win95.
    In Setup, we want to preserve the user's existing font situation
    (ie, only upgrade the fonts that he already had, etc) and at
    the same time layout.inf/txtsetup.sif needed to be changed to
    put/locate the font files in fonts instead of system.

    So what we do is 'precopy' all font files from the system dir
    to the fonts. Then when the rest of the upgrade runs, it does
    the usual thing (upgrading font files according to how they are
    marked for upgrade in txtsetup.sif).

    Later when GDI runs it will take care of cleaning up wierd references
    to fonts (lile .fots that points to .ttfs that were not in the
    system dir).

Author:

    Ted Miller (tedm) 16-Oct-195

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop


BOOLEAN
SpFontSystemDirEnumCallback(
    IN  PCWSTR                      Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG                      ReturnData,
    IN  PVOID                       Pointer
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for
    each file found in the system directory. We examine the file
    and if it's a font file, we copy it to the fonts directory.

Arguments:

    Directory - supplies the full NT path to the system directory.

    FileInfo - supplies find data for a file in the system dir.

    ReturnData - receives an error code if an error occurs.
        We ignore errors in this routine and thus we always
        just fill this in with NO_ERROR.

    Pointer - An optional pointer. Not used in this function.

Return Value:

    Always TRUE.

--*/

{
    ULONG Len;
    PWSTR temp,p;
    PWSTR SourceFilename,TargetFilename;
    NTSTATUS Status;

    ReturnData = NO_ERROR;

    ASSERT(NTUpgrade == UpgradeFull);
    if(NTUpgrade != UpgradeFull) {
        return(FALSE);
    }

    //
    // Ignore directories.
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return(TRUE);
    }

    //
    // Break out the filename, which is not nul terminated
    // in the dir information structure.
    // Form the fully qualified source filename.
    //
    // Note how we use the temporary buffer. Be careful if you
    // change this code.
    //
    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,Directory);
    SpConcatenatePaths(TemporaryBuffer,temp);

    SourceFilename = SpDupStringW(TemporaryBuffer);

    //
    // Check to see whether we care about this file.
    //
    if (SourceFilename) {
        temp = wcsrchr(SourceFilename,L'\\');
    } else {
        temp = NULL;
    }
    
    if(temp) {
        temp++;
        Len = wcslen(temp);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: That's strange: system dir font enum got file %ws\n",SourceFilename));
        return(TRUE);
    }

    //
    // At this point temp points at the filename part and len is its length.
    // See whether we care about this file.
    //
    if((Len > 4)
    && (   !_wcsicmp(temp+Len-4,L".ttf")
        || !_wcsicmp(temp+Len-4,L".fot")
        || !_wcsicmp(temp+Len-4,L".ttc")
        || !_wcsicmp(temp+Len-4,L".fon")
        || !_wcsicmp(temp+Len-4,L".jfr")))
    {
        //
        // Font file. Needs to be moved.
        // Locate the backslash just prior to SYSTEM in the source filename.
        //
        for(p=temp-2; (p>SourceFilename) && (*p != L'\\'); --p) {
            ;
        }
        if(p > SourceFilename) {

            *p = 0;
            wcscpy(TemporaryBuffer,SourceFilename);
            *p = L'\\';
            wcscat(TemporaryBuffer,L"\\FONTS\\");
            wcscat(TemporaryBuffer,temp);

            TargetFilename = SpDupStringW(TemporaryBuffer);
            SpDisplayStatusText(SP_STAT_FONT_UPGRADE,DEFAULT_STATUS_ATTRIBUTE,temp);

            //
            // Copy the file. Note that if it's one of our fonts,
            // it will get overwritten with the latest version anyway,
            // so we're not worried about whether the target file is
            // already there in the fonts directory and newer, etc.
            // Ignore errors.
            //
            Status = SpCopyFileUsingNames(SourceFilename,TargetFilename,0,COPY_DELETESOURCE);
            SpDisplayStatusText(SP_STAT_EXAMINING_CONFIG,DEFAULT_STATUS_ATTRIBUTE);
            SpMemFree(TargetFilename);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: That's strange: system dir font enum got file %ws\n",SourceFilename));
        }
    }

    SpMemFree(SourceFilename);
    return(TRUE);
}


VOID
SpPrepareFontsForUpgrade(
    IN PCWSTR SystemDirectory
    )

/*++

Routine Description:

    Prepares the system to upgrade fonts by copying all font files
    that are in the system directory into the fonts directory.

    Note: this routine should only be called in the upgrade case.

Arguments:

Return Value:

    Always TRUE.

--*/
{
    ULONG x;

    ASSERT(NTUpgrade == UpgradeFull);
    if(NTUpgrade != UpgradeFull) {
        return;
    }

    SpDisplayStatusText(SP_STAT_EXAMINING_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    SpEnumFiles(SystemDirectory,SpFontSystemDirEnumCallback,&x, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfatfmt.c ===
#include "spprecmp.h"
#pragma hdrstop

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtFsControlFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;

#define VERIFY_SIZE   65536


typedef struct {
    UCHAR   IntelNearJumpCommand[1];    // Intel Jump command
    UCHAR   BootStrapJumpOffset[2];     // offset of boot strap code
    UCHAR   OemData[8];                 // OEM data
    UCHAR   BytesPerSector[2];          // BPB
    UCHAR   SectorsPerCluster[1];       //
    UCHAR   ReservedSectors[2];         //
    UCHAR   Fats[1];                    //
    UCHAR   RootEntries[2];             //
    UCHAR   Sectors[2];                 //
    UCHAR   Media[1];                   //
    UCHAR   SectorsPerFat[2];           //
    UCHAR   SectorsPerTrack[2];         //
    UCHAR   Heads[2];                   //
    UCHAR   HiddenSectors[4];           //
    UCHAR   LargeSectors[4];            //
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // not used by fs utils
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // serial number
    UCHAR   Label[11];                  // volume label, aligned padded
    UCHAR   SystemIdText[8];            // system ID, FAT for example
} UNALIGNED_SECTOR_ZERO, *PUNALIGNED_SECTOR_ZERO;


#define CSEC_FAT32MEG   65536
#define CSEC_FAT16BIT   32680
#define MIN_CLUS_BIG    4085    // Minimum clusters for a big FAT.
#define MAX_CLUS_BIG    65525   // Maximum + 1 clusters for big FAT.


USHORT
ComputeSecPerCluster(
    IN  ULONG   NumSectors,
    IN  BOOLEAN SmallFat
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster.

Arguments:

    NumSectors  - Supplies the number of sectors on the disk.
    SmallFat    - Supplies whether or not the FAT should be small.

Return Value:

    The number of sectors per cluster necessary.

--*/
{
    ULONG   threshold;
    USHORT  sec_per_clus;
    USHORT  min_sec_per_clus;

    threshold = SmallFat ? MIN_CLUS_BIG : MAX_CLUS_BIG;
    sec_per_clus = 1;

    while (NumSectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    if (SmallFat) {
        min_sec_per_clus = 8;
    } else {
        min_sec_per_clus = 4;
    }

    return max(sec_per_clus, min_sec_per_clus);
}


ULONG
SpComputeSerialNumber(
    VOID
    )
/*++

Routine Description:

    This routine computes a new serial number for a volume.

Arguments:

    Seed    - Supplies a seed for the serial number.

Return Value:

    A new volume serial number.

--*/
{
    PUCHAR p;
    ULONG i;
    TIME_FIELDS time_fields;
    static ULONG Seed = 0;
    ULONG SerialNumber;
    BOOLEAN b;

    //
    // If this is the first time we've entered this routine,
    // generate a seed value based on the real time clock.
    //
    if(!Seed) {

        b = HalQueryRealTimeClock(&time_fields);
        ASSERT(b);

        Seed = ((time_fields.Year - 1970) *366*24*60*60) +
               (time_fields.Month *31*24*60*60) +
               (time_fields.Day *24*60*60) +
               (time_fields.Hour *60*60) +
               (time_fields.Minute *60) +
               time_fields.Second +
               ((ULONG)time_fields.Milliseconds << 10);

        ASSERT(Seed);
        if(!Seed) {
            Seed = 1;
        }

    }

    SerialNumber = Seed;
    p = (PUCHAR)&SerialNumber;

    for(i=0; i<sizeof(ULONG); i++) {

        SerialNumber += p[i];
        SerialNumber = (SerialNumber >> 2) + (SerialNumber << 30);
    }

    if(++Seed == 0) {       // unlikely, but possible.
        Seed++;
    }

    return SerialNumber;
}


VOID
EditFat(
    IN      USHORT  ClusterNumber,
    IN      USHORT  ClusterEntry,
    IN OUT  PUCHAR  Fat,
    IN      BOOLEAN SmallFat
    )
/*++

Routine Description:

    This routine edits the FAT entry 'ClusterNumber' with 'ClusterEntry'.

Arguments:

    ClusterNumber   - Supplies the number of the cluster to edit.
    ClusterEntry    - Supplies the new value for that cluster number.
    Fat             - Supplies the FAT to edit.
    SmallFat        - Supplies whether or not the FAT is small.

Return Value:

    None.

--*/
{
    ULONG   n;

    if (SmallFat) {

        n = ClusterNumber*3;
        if (n%2) {
            Fat[n/2] = (UCHAR) ((Fat[n/2]&0x0F) | ((ClusterEntry&0x000F)<<4));
            Fat[n/2 + 1] = (UCHAR) ((ClusterEntry&0x0FF0)>>4);
        } else {
            Fat[n/2] = (UCHAR) (ClusterEntry&0x00FF);
            Fat[n/2 + 1] = (UCHAR) ((Fat[n/2 + 1]&0xF0) |
                                    ((ClusterEntry&0x0F00)>>8));
        }

    } else {

        ((PUSHORT) Fat)[ClusterNumber] = ClusterEntry;

    }
}


NTSTATUS
FmtFillFormatBuffer(
    IN  ULONGLONG  NumberOfSectors,
    IN  ULONG    SectorSize,
    IN  ULONG    SectorsPerTrack,
    IN  ULONG    NumberOfHeads,
    IN  ULONGLONG NumberOfHiddenSectors,
    OUT PVOID    FormatBuffer,
    IN  ULONG    FormatBufferSize,
    OUT PULONGLONG SuperAreaSize,
    IN  PULONG   BadSectorsList,
    IN  ULONG    NumberOfBadSectors,
    OUT PUCHAR   SystemId
    )
/*++

Routine Description:

    This routine computes a FAT super area based on the disk size,
    disk geometry, and bad sectors of the volume.

Arguments:

    NumberOfSectors         - Supplies the number of sectors on the volume.
    SectorSize              - Supplies the number of bytes per sector.
    SectorsPerTrack         - Supplies the number of sectors per track.
    NumberOfHeads           - Supplies the number of heads.
    NumberOfHiddenSectors   - Supplies the number of hidden sectors.
    FormatBuffer            - Returns the super area for the volume.
    FormatBufferSize        - Supplies the number of bytes in the supplied
                                buffer.
    SuperAreaSize           - Returns the number of bytes in the super area.
    BadSectorsList          - Supplies the list of bad sectors on the volume.
    NumberOfBadSectors      - Supplies the number of bad sectors in the list.

Return Value:

    ENOMEM  - The buffer wasn't big enough.
    E2BIG   - The disk is too large to be formatted.
    EIO     - There is a bad sector in the super area.
    EINVAL  - There is a bad sector off the end of the disk.
    ESUCCESS

--*/
{
    PUNALIGNED_SECTOR_ZERO  psecz;
    PUCHAR                  puchar;
    USHORT                  tmp_ushort;
    ULONG                   tmp_ulong;
    BOOLEAN                 small_fat;
    ULONG                   num_sectors;
    UCHAR                   partition_id;
    ULONG                   sec_per_fat;
    ULONG                   sec_per_root;
    ULONG                   sec_per_clus;
    ULONG                   i;
    ULONG                   sec_per_sa;


    RtlZeroMemory(FormatBuffer,FormatBufferSize);

    // Make sure that there's enough room for the BPB.

    if(!FormatBuffer || FormatBufferSize < SectorSize) {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    // Compute the number of sectors on disk.
    num_sectors = (ULONG)NumberOfSectors;

    // Compute the partition identifier.
    partition_id = num_sectors < CSEC_FAT16BIT ? PARTITION_FAT_12 :
                   num_sectors < CSEC_FAT32MEG ? PARTITION_FAT_16 :
                                                 PARTITION_HUGE;

    // Compute whether or not to have a big or small FAT.
    small_fat = (BOOLEAN) (partition_id == PARTITION_FAT_12);


    psecz = (PUNALIGNED_SECTOR_ZERO) FormatBuffer;
    puchar = (PUCHAR) FormatBuffer;

    //
    // Copy the fat boot code into the format buffer.
    //
    if (!IsNEC_98) { //NEC98
        ASSERT(sizeof(FatBootCode) == 512);
        RtlMoveMemory(psecz,FatBootCode,sizeof(FatBootCode));

        // Set up the jump instruction.
        psecz->IntelNearJumpCommand[0] = 0xeb;
        psecz->IntelNearJumpCommand[1] = 0x3c;
        psecz->IntelNearJumpCommand[2] = 0x90;
    } else {
        ASSERT(sizeof(PC98FatBootCode) == 512);
        RtlMoveMemory(psecz,PC98FatBootCode,sizeof(PC98FatBootCode));

        //
        // Already written jump instruction to bootcode.
        // So,do not reset jump code.
        //
    } //NEC98

    // Set up the OEM data.
    memcpy(psecz->OemData, "MSDOS5.0", 8);

    // Set up the bytes per sector.
    U_USHORT(psecz->BytesPerSector) = (USHORT)SectorSize;

    // Set up the number of sectors per cluster.
    sec_per_clus = ComputeSecPerCluster(num_sectors, small_fat);
    if (sec_per_clus > 128) {

        // The disk is too large to be formatted.
        return(STATUS_INVALID_PARAMETER);
    }
    psecz->SectorsPerCluster[0] = (UCHAR) sec_per_clus;

    // Set up the number of reserved sectors.
    U_USHORT(psecz->ReservedSectors) = (USHORT)max(1,512/SectorSize);

    // Set up the number of FATs.
    psecz->Fats[0] = 2;

    // Set up the number of root entries and number of sectors for the root.
    U_USHORT(psecz->RootEntries) = 512;
    sec_per_root = (512*32 - 1)/SectorSize + 1;

    // Set up the number of sectors.
    if (num_sectors >= 1<<16) {
        tmp_ushort = 0;
        tmp_ulong = num_sectors;
    } else {
        tmp_ushort = (USHORT) num_sectors;
        tmp_ulong = 0;
    }
    U_USHORT(psecz->Sectors) = tmp_ushort;
    U_ULONG(psecz->LargeSectors) = tmp_ulong;

    // Set up the media byte.
    psecz->Media[0] = 0xF8;

    // Set up the number of sectors per FAT.
    if (small_fat) {
        sec_per_fat = num_sectors/(2 + SectorSize*sec_per_clus*2/3);
    } else {
        sec_per_fat = num_sectors/(2 + SectorSize*sec_per_clus/2);
    }
    sec_per_fat++;
    U_USHORT(psecz->SectorsPerFat) = (USHORT)sec_per_fat;

    // Set up the number of sectors per track.
    U_USHORT(psecz->SectorsPerTrack) = (USHORT)SectorsPerTrack;

    // Set up the number of heads.
    U_USHORT(psecz->Heads) = (USHORT)NumberOfHeads;

    // Set up the number of hidden sectors.
    U_ULONG(psecz->HiddenSectors) = (ULONG)NumberOfHiddenSectors;

    // Set up the physical drive number.
    psecz->PhysicalDrive[0] = 0x80;
    psecz->CurrentHead[0] = 0;

    // Set up the BPB signature.
    psecz->Signature[0] = 0x29;

    // Set up the serial number.
    U_ULONG(psecz->SerialNumber) = SpComputeSerialNumber();

    // Set up the volume label.
    memcpy(psecz->Label, "NO NAME    ",11);

    // Set up the system id.
    memcpy(psecz->SystemIdText, small_fat ? "FAT12   " : "FAT16   ", 8);

    // Set up the boot signature.
    puchar[510] = 0x55;
    puchar[511] = 0xAA;

    // Now make sure that the buffer has enough room for both of the
    // FATs and the root directory.

    sec_per_sa = 1 + 2*sec_per_fat + sec_per_root;
    *SuperAreaSize = SectorSize*sec_per_sa;
    if (*SuperAreaSize > FormatBufferSize) {
        return(STATUS_BUFFER_TOO_SMALL);
    }


    // Set up the first FAT.

    puchar[SectorSize] = 0xF8;
    puchar[SectorSize + 1] = 0xFF;
    puchar[SectorSize + 2] = 0xFF;

    if (!small_fat) {
        puchar[SectorSize + 3] = 0xFF;
    }


    for (i = 0; i < NumberOfBadSectors; i++) {

        if (BadSectorsList[i] < sec_per_sa) {
            // There's a bad sector in the super area.
            return(STATUS_UNSUCCESSFUL);
        }

        if (BadSectorsList[i] >= num_sectors) {
            // Bad sector out of range.
            return(STATUS_NONEXISTENT_SECTOR);
        }

        // Compute the bad cluster number;
        tmp_ushort = (USHORT)
                     ((BadSectorsList[i] - sec_per_sa)/sec_per_clus + 2);

        EditFat(tmp_ushort, (USHORT) 0xFFF7, &puchar[SectorSize], small_fat);
    }


    // Copy the first FAT onto the second.

    memcpy(&puchar[SectorSize*(1 + sec_per_fat)],
           &puchar[SectorSize],
           (unsigned int) SectorSize*sec_per_fat);

    *SystemId = partition_id;

    return(STATUS_SUCCESS);
}


VOID
FmtVerifySectors(
    IN  HANDLE      Handle,
    IN  ULONG       NumberOfSectors,
    IN  ULONG       SectorSize,
    OUT PULONG*     BadSectorsList,
    OUT PULONG      NumberOfBadSectors
    )
/*++

Routine Description:

    This routine verifies all of the sectors on the volume.
    It returns a pointer to a list of bad sectors.  The pointer
    will be NULL if there was an error detected.

Arguments:

    Handle              - Supplies a handle to the partition for verifying.
    NumberOfSectors     - Supplies the number of partition sectors.
    SectorSize          - Supplies the number of bytes per sector.
    BadSectorsList      - Returns the list of bad sectors.
    NumberOfBadSectors  - Returns the number of bad sectors in the list.

Return Value:

    None.

--*/
{
    ULONG           num_read_sec;
    ULONG           i, j;
    PULONG          bad_sec_buf;
    ULONG           max_num_bad;
    PVOID           Gauge;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        Status;
    VERIFY_INFORMATION VerifyInfo;


    max_num_bad = 100;
    bad_sec_buf = SpMemAlloc(max_num_bad*sizeof(ULONG));
    ASSERT(bad_sec_buf);

    *NumberOfBadSectors = 0;

    num_read_sec = VERIFY_SIZE/SectorSize;

    //
    // Initialize the Gas Gauge
    //
    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_FORMATTING
        );

    Gauge = SpCreateAndDisplayGauge(
                NumberOfSectors/num_read_sec,
                0,
                VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                TemporaryBuffer,
                NULL,
                GF_PERCENTAGE,
                0
                );

    VerifyInfo.StartingOffset.QuadPart = 0;

    for (i = 0; i < NumberOfSectors; i += num_read_sec) {

        if (i + num_read_sec > NumberOfSectors) {
            num_read_sec = NumberOfSectors - i;
        }

        //
        // Verify this many sectors at the current offset.
        //
        VerifyInfo.Length = num_read_sec * SectorSize;
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_VERIFY,
                    &VerifyInfo,
                    sizeof(VerifyInfo),
                    NULL,
                    0
                    );
        //
        // I/O should be synchronous.
        //
        ASSERT(Status != STATUS_PENDING);

        if(!NT_SUCCESS(Status)) {

            //
            // Range is bad -- verify individual sectors.
            //
            VerifyInfo.Length = SectorSize;

            for (j = 0; j < num_read_sec; j++) {

                Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_DISK_VERIFY,
                            &VerifyInfo,
                            sizeof(VerifyInfo),
                            NULL,
                            0
                            );

                ASSERT(Status != STATUS_PENDING);

                if(!NT_SUCCESS(Status)) {

                    if (*NumberOfBadSectors == max_num_bad) {

                        max_num_bad += 100;
                        bad_sec_buf = SpMemRealloc(
                                        bad_sec_buf,
                                        max_num_bad*sizeof(ULONG)
                                        );

                        ASSERT(bad_sec_buf);
                    }

                    bad_sec_buf[(*NumberOfBadSectors)++] = i + j;
                }

                //
                // Advance to next sector.
                //
                VerifyInfo.StartingOffset.QuadPart += SectorSize;
            }
        } else {

            //
            // Advance to next range of sectors.
            //
            VerifyInfo.StartingOffset.QuadPart += VerifyInfo.Length;
        }

        if(Gauge) {
            SpTickGauge(Gauge);
        }
    }

    if(Gauge) {
        SpTickGauge(Gauge);
    }

    *BadSectorsList = bad_sec_buf;

    //return(STATUS_SUCCESS);
}


#if 0
//
// Code not used, we call autoformat
//
NTSTATUS
SpFatFormat(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    This routine does a FAT format on the given partition.

    The caller should have cleared the screen and displayed
    any message in the upper portion; this routine will
    maintain the gas gauge in the lower portion of the screen.

Arguments:

    Region - supplies the disk region descriptor for the
        partition to be formatted.

Return Value:


--*/
{
    ULONG           hidden_sectors;
    PULONG          bad_sectors;
    ULONG           num_bad_sectors;
    PVOID           format_buffer;
    PVOID           unaligned_format_buffer;
    ULONG           max_sec_per_sa;
    ULONG           super_area_size;
    PHARD_DISK      pHardDisk;
    ULONG           PartitionOrdinal;
    NTSTATUS        Status;
    HANDLE          Handle;
    ULONG           BytesPerSector;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER   LargeZero;
    UCHAR           SysId;
    ULONG           ActualSectorCount;
    SET_PARTITION_INFORMATION PartitionInfo;


    ASSERT(Region->PartitionedSpace);
    ASSERT(Region->TablePosition < PTABLE_DIMENSION);
    ASSERT(Region->Filesystem != FilesystemDoubleSpace);
    pHardDisk = &HardDisks[Region->DiskNumber];
    BytesPerSector = pHardDisk->Geometry.BytesPerSector;
    PartitionOrdinal = SpPtGetOrdinal(Region,PartitionOrdinalCurrent);

    //
    // Make SURE it's not partition0!  The results of formatting partition0
    // are so disasterous that theis warrants a special check.
    //
    if(!PartitionOrdinal) {
        SpBugCheck(
            SETUP_BUGCHECK_PARTITION,
            PARTITIONBUG_B,
            Region->DiskNumber,
            0
            );
    }

#ifdef _X86_
    //
    // If we're going to format C:, then clear the previous OS entry
    // in boot.ini.
    //
    if(Region == SpPtValidSystemPartition()) {
        *OldSystemLine = '\0';
    }
#endif

    //
    // Query the number of hidden sectors and the actual number
    // of sectors in the volume.
    //
    SpPtGetSectorLayoutInformation(Region,&hidden_sectors,&ActualSectorCount);

    //
    // Open the partition for read/write access.
    // This shouldn't lock the volume so we need to lock it below.
    //
    Status = SpOpenPartition(
                pHardDisk->DevicePath,
                PartitionOrdinal,
                &Handle,
                TRUE
                );

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpFatFormat: unable to open %ws partition %u (%lx)\n",
            pHardDisk->DevicePath,
            PartitionOrdinal,
            Status
            ));

        return(Status);
    }

    //
    //  Lock the drive
    //
    Status = SpLockUnlockVolume( Handle, TRUE );

    //
    //  We shouldn't have any file opened that would cause this volume
    //  to already be locked, so if we get failure (ie, STATUS_ACCESS_DENIED)
    //  something is really wrong.  This typically indicates something is
    //  wrong with the hard disk that won't allow us to access it.
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to lock drive \n",Status));
        ZwClose(Handle);
        return(Status);
    }

    bad_sectors = NULL;

    FmtVerifySectors(
        Handle,
        ActualSectorCount,
        BytesPerSector,
        &bad_sectors,
        &num_bad_sectors
        );

    max_sec_per_sa = 1 +
                     2*((2*65536 - 1)/BytesPerSector + 1) +
                     ((512*32 - 1)/BytesPerSector + 1);


    unaligned_format_buffer = SpMemAlloc(max_sec_per_sa*BytesPerSector);
    ASSERT(unaligned_format_buffer);
    format_buffer = ALIGN(unaligned_format_buffer,BytesPerSector);

    Status = FmtFillFormatBuffer(
                ActualSectorCount,
                BytesPerSector,
                pHardDisk->Geometry.SectorsPerTrack,
                pHardDisk->Geometry.TracksPerCylinder,
                hidden_sectors,
                format_buffer,
                max_sec_per_sa*BytesPerSector,
                &super_area_size,
                bad_sectors,
                num_bad_sectors,
                &SysId
                );

    if(bad_sectors) {
        SpMemFree(bad_sectors);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx from FmtFillFormatBuffer\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        SpMemFree(unaligned_format_buffer);
        return(Status);
    }

    //
    // Write the super area.
    //
    LargeZero.QuadPart = 0;
    Status = ZwWriteFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                format_buffer,
                super_area_size,
                &LargeZero,
                NULL
                );

    //
    // I/O should be synchronous.
    //
    ASSERT(Status != STATUS_PENDING);

    SpMemFree(unaligned_format_buffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx from ZwWriteFile\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        return(Status);
    }

    //
    // If we wrote the super area then the drive is now FAT!
    // If we don't change, say, a type of ntfs to fat, then code
    // that lays down the x86 boot code (i386\bootini.c) will
    // come along and write 16 sectors of NTFS boot code into
    // sector 0 of our nice FAT volume -- very bad!
    // Preserve the filesystem type of FilesystemNewlyCreated
    // since other code later in setup relies on this.
    //
    if(Region->Filesystem >= FilesystemFirstKnown) {
        Region->Filesystem = FilesystemFat;
    }

    //
    // Set the partition type.
    //
    PartitionInfo.PartitionType = SysId;

    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_SET_PARTITION_INFO,
                &PartitionInfo,
                sizeof(PartitionInfo),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set partition type (status = %lx)\n",Status));
    }

    //
    // Dismount the drive
    //
    Status = SpDismountVolume( Handle );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to dismount drive\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        return(Status);
    }

    //
    // Unlock the drive
    //
    Status = SpLockUnlockVolume( Handle, FALSE );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to unlock drive\n",Status));
    }

    ZwClose(Handle);
    return(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spdsputl.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for text setup display utilitiy functions.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPDSPUTL_DEFN_
#define _SPDSPUTL_DEFN_


#define HEADER_HEIGHT 3
#define STATUS_HEIGHT 1
#define CLIENT_HEIGHT (VideoVars.ScreenHeight - (HEADER_HEIGHT+STATUS_HEIGHT))
#define CLIENT_TOP    HEADER_HEIGHT


#define CLEAR_ENTIRE_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        0,                                          \
        0,                                          \
        0,                                          \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_CLIENT_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        HEADER_HEIGHT,                              \
        VideoVars.ScreenWidth,                      \
        VideoVars.ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT), \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_HEADER_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        0,                                          \
        VideoVars.ScreenWidth,                      \
        HEADER_HEIGHT,                              \
        DEFAULT_BACKGROUND                          \
        )



ULONG
SpDisplayText(
    IN PWCHAR  Message,
    IN ULONG   MsgLen,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y
    );


ULONG
vSpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    IN va_list arglist
    );


ULONG
SpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    ...
    );


VOID
SpStartScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   TopLine,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    ...
    );


VOID
SpContinueScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   SpacingLines,
    IN BOOLEAN CenterHorizontally,
    IN UCHAR   Attribute,
    ...
    );


VOID
SpBugCheck(
    IN ULONG BugCode,
    IN ULONG Param1,
    IN ULONG Param2,
    IN ULONG Param3
    );


VOID
SpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    ...
    );


#define SpDisplayScreen(MessageId,LeftMargin,TopLine)   \
                                                        \
    SpStartScreen(                                      \
        MessageId,                                      \
        LeftMargin,                                     \
        TopLine,                                        \
        FALSE,                                          \
        FALSE,                                          \
        DEFAULT_ATTRIBUTE                               \
        )


//
// As messages are built on on-screen, with SpStartScreen and
// SpContinueScreen, this value remembers where
// the next message in the screen should be placed.
//
extern ULONG NextMessageTopLine;


VOID
SpDisplayHeaderText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute
    );


VOID
SpDisplayStatusText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute,
    ...
    );

VOID
SpCmdConsEnableStatusText(
  IN BOOLEAN EnableStatusText
  );
    

VOID
SpDisplayStatusOptions(
    IN UCHAR Attribute,
    ...
    );

VOID
SpDisplayStatusActionLabel(
    IN ULONG ActionMessageId,   OPTIONAL
    IN ULONG FieldWidth
    );

VOID
SpDisplayStatusActionObject(
    IN PWSTR ObjectText
    );

VOID
SpDrawFrame(
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN ULONG   TopY,
    IN ULONG   Height,
    IN UCHAR   Attribute,
    IN BOOLEAN DoubleLines
    );

//
// There are places where the user has to press C for custom setup, etc.
// These keystrokes are referred to as the nmemonic keys, and they must be
// localizable.  To accomplish this, the enum below indexes the SP_MNEMONICS
// message.
//
typedef enum {
    MnemonicUnused = 0,
    MnemonicCustom,             // as in "C=Custom Setup"
    MnemonicCreatePartition,    // as in "C=Create Partition"
    MnemonicDeletePartition,    // as in "D=Delete Partition"
    MnemonicContinueSetup,      // as in "C=Continue Setup"
    MnemonicFormat,             // as in "F=Format"
    MnemonicConvert,            // as in "C=Convert"
    MnemonicRemoveFiles,        // as in "R=Remove Files"
    MnemonicNewPath,            // as in "N=Different Directory"
    MnemonicSkipDetection,      // as in "S=Skip Detection"
    MnemonicScsiAdapters,       // as in "S=Specify Additional SCSI Adapter"
    MnemonicDeletePartition2,   // as in "L=Delete"
    MnemonicOverwrite,          // as in "O=Overwrite"
    MnemonicRepair,             // as in "R=Repair"
    MnemonicRepairAll,          // as in "A=Repair All"
    MnemonicUpgrade,            // as in "U=Upgrade"
    MnemonicAutomatedSystemRecovery,   // as in "A=ASR"
    MnemonicInitializeDisk,     // as in "I=Initialize Disk"
    MnemonicLocate,             // as in "L=Locate"
    MnemonicFastRepair,         // as in "F=Fast Repair"
    MnemonicManualRepair,       // as in "M=Manual Repair"
    MnemonicConsole,            // as in "C=Console"
    MnemonicChangeDiskStyle,    // as in "S=Change Disk Style"
    MnemonicMakeSystemPartition,// as in "M=Make System Partition"
    MnemonicMax
} MNEMONIC_KEYS;

#define KEY_MNEMONIC    0x80000000

extern PWCHAR MnemonicValues;

ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2,  OPTIONAL
    IN PULONG MnemonicKeys OPTIONAL
    );

//
// Enum for values that can be retuned by a KEYRESS_CALLBACK routine.
//
typedef enum {
    ValidateAccept,
    ValidateReject,
    ValidateIgnore,
    ValidateTerminate,
    ValidateRepaint
} ValidationValue;

//
// Type for routine to be passed as ValidateKey parameter to SpGetInput().
//
typedef
ValidationValue
(*PKEYPRESS_CALLBACK) (
    IN ULONG Key
    );

BOOLEAN
SpGetInput(
    IN     PKEYPRESS_CALLBACK ValidateKey,
    IN     ULONG              X,
    IN     ULONG              Y,
    IN     ULONG              MaxLength,
    IN OUT PWCHAR             Buffer,
    IN     BOOLEAN            ValidateEscape
    );

#endif // ndef _SPDSPUTL_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfile.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfile.c

Abstract:

    File operations for text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

    Jim Schmidt (jimschm) 10-Apr-1997   Added file attribute routines

--*/


#include "spprecmp.h"
#pragma hdrstop


NTSTATUS
SpGetFileSize(
    IN  HANDLE hFile,
    OUT PULONG Size
    )

/*++

Routine Description:

    Determine the size of a file.  Only the low 32 bits of the size
    are considered.

Arguments:

    hFile - supplies open handle to file whose size is desired.

    Size - receives size of file.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    Status = ZwQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSize: status %lx from ZwQueryInformationFile\n",Status));
        return(Status);
    }

    *Size = StandardInfo.EndOfFile.LowPart;

    return(STATUS_SUCCESS);
}


NTSTATUS
SpMapEntireFile(
    IN  HANDLE   hFile,
    OUT PHANDLE  Section,
    OUT PVOID   *ViewBase,
    IN  BOOLEAN  WriteAccess
    )

/*++

Routine Description:

    Map an entire file for read or write access access.

Arguments:

    hFile - supplies handle of open file to be mapped.

    Section - receives handle for section object created to map file.

    ViewBase - receives address of the view of the file

    WriteAccess - if TRUE, map file for read and write access.
        If FALSE, map file for read access.

Return Value:

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
    SIZE_T   ViewSize = 0;

    SectionOffset.QuadPart = 0;

    Status = ZwCreateSection(
                Section,
                  STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ
                | (WriteAccess ? SECTION_MAP_WRITE : 0),
                NULL,
                NULL,       // entire file
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY,
                SEC_COMMIT,
                hFile
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Status %lx from ZwCreateSection\n",Status));
        return(Status);
    }

    *ViewBase = NULL;
    Status = ZwMapViewOfSection(
                *Section,
                NtCurrentProcess(),
                ViewBase,
                0,
                0,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0,
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY
                );

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpMapEntireFile: Status %lx from ZwMapViewOfSection\n",Status));

        s = ZwClose(*Section);

        if(!NT_SUCCESS(s)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpMapEntireFile: Warning: status %lx from ZwClose on section handle\n",s));
        }

        return(Status);
    }

    return(STATUS_SUCCESS);
}



BOOLEAN
SpUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    )
{
    NTSTATUS Status;
    BOOLEAN  rc = TRUE;

    Status = ZwUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: status %lx from ZwUnmapViewOfSection\n",Status));
        rc = FALSE;
    }

    Status = ZwClose(Section);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: status %lx from ZwClose on section handle\n",Status));
        rc = FALSE;
    }

    return(rc);
}



NTSTATUS
SpOpenAndMapFile(
    IN     PWSTR    FileName,  OPTIONAL  // only needed if no FileHandle
    IN OUT PHANDLE  FileHandle,
    OUT    PHANDLE  SectionHandle,
    OUT    PVOID   *ViewBase,
    OUT    PULONG   FileSize,
    IN     BOOLEAN  WriteAccess
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN MustClose = FALSE;

    //
    // If necessary, open the file.
    //
    if(!(*FileHandle)) {
        INIT_OBJA(&Obja,&UnicodeString,FileName);
        Status = ZwCreateFile(
                    FileHandle,
                    FILE_GENERIC_READ | (WriteAccess ? FILE_GENERIC_WRITE : 0),
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: Unable to open %ws (%lx)\n",FileName,Status));
            return(Status);
        } else {
            MustClose = TRUE;
        }
    }

    //
    // Get the size of the file.
    //
    Status = SpGetFileSize(*FileHandle,FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: unable to determine size of file %ws(%lx)\n",
                FileName ? FileName : L"(handle)", Status));
        if(MustClose) {
            ZwClose(*FileHandle);
        }
        return(Status);
    }

    //
    // Map the file.
    //
    Status = SpMapEntireFile(*FileHandle,SectionHandle,ViewBase,WriteAccess);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: unable to map %ws (%lx)\n",
                FileName ? FileName : L"(handle)", Status));
        if(MustClose) {
            ZwClose(*FileHandle);
        }
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpSetInformationFile(
    IN HANDLE                 Handle,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG                  Length,
    IN PVOID                  FileInformation
    )
{
    NTSTATUS Status;
    PFILE_OBJECT FileObject;
    OBJECT_HANDLE_INFORMATION HandleInfo;

    //
    // Reference the object.
    //
    Status = ObReferenceObjectByHandle(
                    Handle,
                    (ACCESS_MASK)DELETE,
                    *IoFileObjectType,
                    ExGetPreviousMode(),
                    &FileObject,
                    &HandleInfo
                    );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpSetInformationFile: ObReferenceObjectByHandle failed (%lx)\n",Status));
        return(Status);
    }

    //
    // Set the information.
    //
    Status = IoSetInformation(FileObject,FileInformationClass,Length,FileInformation);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: IoSetInformation returns %lx\n",Status));
    }

    //
    // Clean up and return.
    //
    ObDereferenceObject(FileObject);
    return(Status);
}


NTSTATUS
SpSetAttributes (
    IN      PWSTR SrcNTPath,
    IN      ULONG FileAttributes
    )

/*++

Routine Description:

  Applies FileAttributes to the specified file.

Arguments:

  SrcNTPath      - The NT path of the file needing attribute modification

  FileAttributes - The FILE_ATTRIBUTE_* flags to apply.

Return Value:

  NTSTATUS code.

--*/

{
    OBJECT_ATTRIBUTES Obja;                 // for ZwOpenFile
    IO_STATUS_BLOCK IoStatusBlock;          // for ZwOpenFile
    UNICODE_STRING UnicodeString;           // DontCare string
    NTSTATUS Status;                        // Return value
    HANDLE FileHandle;                      // Handle of file to be modified
    FILE_BASIC_INFORMATION BasicInfo;       // For attribs modification

    INIT_OBJA(&Obja, &UnicodeString, SrcNTPath);

    Status = ZwOpenFile(
                &FileHandle,
                (ACCESS_MASK)(DELETE|FILE_WRITE_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE|FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS (Status)) {
        Status = ZwOpenFile(
                    &FileHandle,
                    (ACCESS_MASK)(DELETE|FILE_WRITE_ATTRIBUTES),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE|FILE_OPEN_FOR_BACKUP_INTENT
                    );
    }

    if(NT_SUCCESS(Status)) {

        RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
        BasicInfo.FileAttributes = FileAttributes;

        Status = SpSetInformationFile(
                    FileHandle,
                    FileBasicInformation,
                    sizeof(BasicInfo),
                    &BasicInfo
                    );

        ZwClose(FileHandle);
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpSetAttributes failed for %ws, Status=%lx\n", SrcNTPath, Status));
    }

    return Status;
}


NTSTATUS
SpGetAttributes (
    IN      PWSTR SrcNTPath,
    OUT     PULONG FileAttributesPtr
    )

/*++

Routine Description:

  Obtains FileAttributes for the specified file.

Arguments:

  SrcNTPath         - The NT path of the file to obtain attributes

  FileAttributesPtr - A poitner to a DWORD that recieves FILE_ATTRIBUTE_*
                      flags

Return Value:

  NTSTATUS code.  FileAttributePtr is modified only with status is NO_ERROR.

--*/

{
    OBJECT_ATTRIBUTES Obja;                 // for ZwOpenFile
    IO_STATUS_BLOCK IoStatusBlock;          // for ZwOpenFile
    UNICODE_STRING UnicodeString;           // DontCare string
    NTSTATUS Status;                        // Return value
    HANDLE FileHandle;                      // Handle of file to be queried
    FILE_BASIC_INFORMATION BasicInfo;       // For attribs retrieval

    INIT_OBJA(&Obja, &UnicodeString, SrcNTPath);

    Status = ZwOpenFile(
                &FileHandle,
                (ACCESS_MASK)(FILE_TRAVERSE | FILE_READ_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_NON_DIRECTORY_FILE
                );

    if (!NT_SUCCESS (Status)) {
        Status = ZwOpenFile(
                    &FileHandle,
                    (ACCESS_MASK)(FILE_TRAVERSE | FILE_READ_ATTRIBUTES),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ,
                    FILE_DIRECTORY_FILE
                    );
    }

    if(NT_SUCCESS(Status)) {
        Status = ZwQueryInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    FileBasicInformation
                    );

        ZwClose(FileHandle);
        if (NT_SUCCESS(Status)) {
            *FileAttributesPtr = BasicInfo.FileAttributes;
        }
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetAttributes failed for %ws, Status=%lx\n", SrcNTPath, Status));
    }

    return Status;
}


NTSTATUS
SpDeleteFileEx(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    )
{
    PWSTR p;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_BASIC_INFORMATION       BasicInfo;

    //
    // Point to temporary buffer for pathname.
    //
    p = TemporaryBuffer;

    //
    // Build up the full name of the file to delete.
    //
    wcscpy(p,Name1);
    if(Name2) {
        SpConcatenatePaths(p,Name2);
    }
    if(Name3) {
        SpConcatenatePaths(p,Name3);
    }

    //
    // Prepare to open the file.
    //
    INIT_OBJA(&Obja,&UnicodeString,p);

    //
    // Attempt to open the file.
    //
    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(DELETE | FILE_WRITE_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                ShareFlags,
                OpenFlags
              );

    if(!NT_SUCCESS(Status)) {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to open %ws for delete (%lx)\n",p,Status));
        }
        return(Status);
    }

    //
    //  Change the file attribute to normal
    //

    RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
    BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = SpSetInformationFile(
                Handle,
                FileBasicInformation,
                sizeof(BasicInfo),
                &BasicInfo
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to change attribute of %ws, Status = (%lx)\n",p,Status));
        return(Status);
    }

    //
    // Set up for delete and call worker to do it.
    //
    #undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = SpSetInformationFile(
                Handle,
                FileDispositionInformation,
                sizeof(Disposition),
                &Disposition
                );

    //
    // Clean up and return.
    //
    ZwClose(Handle);
    return(Status);
}

NTSTATUS
SpDeleteFile(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3  OPTIONAL
    )
{

    return( SpDeleteFileEx( Name1,
                            Name2,
                            Name3,
                            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT ) );

}


BOOLEAN
SpFileExists(
    IN PCWSTR PathName,
    IN BOOLEAN Directory
    )

/*++

Routine Description:

    Determine if a file or directory exists

Arguments:

    PathName - PathName of file or directory to check

    Directory - Whether PathName refers to a directory or a file

Return Value:

    NT_SUCCESS(NTSTATUS) if file exists.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    INIT_OBJA(&Obja,&UnicodeString,PathName);

    Status = ZwCreateFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                Directory ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return(TRUE);
    } else {
        return(FALSE);
    }
}



NTSTATUS
SpRenameFile(
    IN PWSTR   OldName,
    IN PWSTR   NewName,
    IN BOOLEAN AllowDirectoryRename
    )
/*++

Routine Description:

    Rename a file or directory

Arguments:

    OldName - Old name of file

    NewName - New name of file

    AllowDirectoryRename - if TRUE, then this routine will rename a directory,
        otherwise directory renames are not allowed.

Return Value:

    NT_SUCCESS(NTSTATUS) if file successfully renamed

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    BYTE Buffer[ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_RENAME_INFORMATION)];
    PFILE_RENAME_INFORMATION pNameInfo;
    ULONG NameInfoLength, FileNameLength;


    //
    // Prepare to open the file.
    //

    INIT_OBJA(&Obja,&UnicodeString,OldName);

    //
    // Attempt to open the file as a file.
    //
    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(DELETE | SYNCHRONIZE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status) && AllowDirectoryRename) {
        //
        // Attempt to open the file as a directory.
        //
        Status = ZwOpenFile(
                    &Handle,
                    (ACCESS_MASK)(DELETE | SYNCHRONIZE),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                    );
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to open %ws for rename (%lx)\n",OldName,Status));
        return(Status);
    }

    //
    //  Change the file name
    //

    NameInfoLength = sizeof(Buffer);
    FileNameLength = (wcslen(NewName))*sizeof(WCHAR);

    memset(Buffer, 0, sizeof(Buffer));
    
    pNameInfo = (PFILE_RENAME_INFORMATION)Buffer;

    pNameInfo->ReplaceIfExists = FALSE;
    pNameInfo->RootDirectory   = NULL;
    pNameInfo->FileNameLength  = FileNameLength;
    wcscpy( pNameInfo->FileName, NewName );

    Status = SpSetInformationFile(
                Handle,
                FileRenameInformation,
                NameInfoLength,
                (PVOID)pNameInfo
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to change name of %ls to %ls. Status = (%lx)\n",OldName,NewName,Status));
    }

    //
    // Clean up and return.
    //

    ZwClose(Handle);
    return(Status);


}

USHORT
SpChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


PIMAGE_NT_HEADERS
SpChecksumMappedFile(
    IN  PVOID  BaseAddress,
    IN  ULONG  FileSize,
    OUT PULONG HeaderSum,
    OUT PULONG Checksum
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT            PartialSum;
    PUSHORT           AdjustSum;

    try {

        //
        // Compute the checksum of this file and zero the header sum.
        //
        PartialSum = SpChkSum(0,BaseAddress,(FileSize+1) >> 1);
        *HeaderSum = 0;

        //
        // See whether this is an image.
        //
        if(NtHeaders = RtlImageNtHeader(BaseAddress)) {

            //
            // The file is an image file -- subtract the two checksum words
            // in the optional header from the computed checksum before adding
            // the file length, and set the value of the header checksum.
            //
            *HeaderSum = NtHeaders->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
            PartialSum -= (PartialSum < AdjustSum[0]);
            PartialSum -= AdjustSum[0];
            PartialSum -= (PartialSum < AdjustSum[1]);
            PartialSum -= AdjustSum[1];
        }

        //
        // Compute the checksum.
        //
        *Checksum = (ULONG)PartialSum + FileSize;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NtHeaders = NULL;
    }

    return(NtHeaders);
}


NTSTATUS
SpOpenNameMayBeCompressed(
    IN  PWSTR    FullPath,
    IN  ULONG    OpenAccess,
    IN  ULONG    FileAttributes,
    IN  ULONG    ShareFlags,
    IN  ULONG    Disposition,
    IN  ULONG    OpenFlags,
    OUT PHANDLE  Handle,
    OUT PBOOLEAN OpenedCompressedName   OPTIONAL
    )
{
    NTSTATUS Status;
    PWSTR compname;
    PWSTR names[2];
    int compord,uncompord;
    static BOOLEAN PreviousWasCompressed = FALSE;
    BOOLEAN IsComp;
    int i;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Generate compressed name.
    //
    compname = SpGenerateCompressedName(FullPath);

    //
    // Figure out which name to try to use first.  If the last successful
    // call to this routine opened the file using the compressed name, then
    // try to open the compressed name first.  Otherwise try to open the
    // uncompressed name first.
    //
    if(PreviousWasCompressed) {
        compord = 0;
        uncompord = 1;
    } else {
        compord = 1;
        uncompord = 0;
    }

    names[uncompord] = FullPath;
    names[compord] = compname;

    for(i=0; i<2; i++) {

        INIT_OBJA(&Obja,&UnicodeString,names[i]);

        Status = ZwCreateFile(
                    Handle,
                    OpenAccess,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FileAttributes,
                    ShareFlags,
                    Disposition,
                    OpenFlags,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            IsComp = (BOOLEAN)(i == compord);

            PreviousWasCompressed = IsComp;
            if(OpenedCompressedName) {
                *OpenedCompressedName = IsComp;
            }

            break;
        }
    }

    SpMemFree(compname);
    return(Status);
}

NTSTATUS
SpGetFileSizeByName(
    IN  PWSTR DevicePath OPTIONAL,
    IN  PWSTR Directory  OPTIONAL,
    IN  PWSTR FileName,
    OUT PULONG Size
    )

/*++

Routine Description:

    Determine the size of a file.  Only the low 32 bits of the size
    are considered.

Arguments:

    DevicePath - Path to the device that contains the file.

    Directory - Name of the directory that contains the file.

    FileName - Name of the file.

    Size - receives size of file.

Return Value:

    NTSTATUs -

--*/

{
    PWSTR               CompleteFileName;
    HANDLE              FileHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeFileName;
    ULONG               FileNameLength;

    FileNameLength = wcslen( FileName ) + 1;
    if( DevicePath != NULL ) {
        FileNameLength += wcslen( DevicePath ) + 1;
    }
    if( Directory != NULL ) {
        FileNameLength += wcslen( Directory ) + 1;
    }

    CompleteFileName = SpMemAlloc( FileNameLength*sizeof( WCHAR ) );
    if( CompleteFileName == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to allocate memory on SpGetFileSizeByName \n" ));
        return( STATUS_NO_MEMORY );
    }

    *CompleteFileName = (WCHAR)'\0';
    if( DevicePath != NULL ) {
        SpConcatenatePaths( CompleteFileName, DevicePath );
    }
    if( Directory != NULL ) {
        SpConcatenatePaths( CompleteFileName, Directory );
    }
    SpConcatenatePaths( CompleteFileName, FileName );

    RtlInitUnicodeString( &UnicodeFileName,
                          CompleteFileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &FileHandle,
                         STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( !NT_SUCCESS( Status ) ) {
        SpMemFree( CompleteFileName );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwOpenFile() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return( Status );
        }

    Status = SpGetFileSize( FileHandle, Size );
    ZwClose( FileHandle );
    SpMemFree( CompleteFileName );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSize() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return( Status );
    }
    return( Status );
}


VOID
SpVerifyNoCompression(
    IN PWSTR FileName
    )

/*++

Routine Description:

    Determine if the file is compressed (via NTFS compression), and if so,
    uncompress it.

Arguments:

    FileName - Name of the file that must be uncompressed.

Return Value:

    none

--*/

{
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicFileInfo;

    INIT_OBJA(&Obja, &UnicodeString, FileName);
    Status = ZwCreateFile(
                &FileHandle,
                0,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        //
        // Ignore error.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to open file %ws (%lx)\n", FileName, Status));
        return;
    }

    Status = ZwQueryInformationFile(
                FileHandle,
                &IoStatusBlock,
                &BasicFileInfo,
                sizeof(BasicFileInfo),
                FileBasicInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to get basic file info for %ws (%lx)\n", FileName, Status));
        goto ComprVerifyDone;
    }

    if(BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        USHORT CompressionState = 0;

        Status = ZwFsControlFile(
                     FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_SET_COMPRESSION,
                     &CompressionState,
                     sizeof(CompressionState),
                     NULL,
                     0
                     );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to uncompress %ws (%lx)\n", FileName, Status));
        }
    }

ComprVerifyDone:
    ZwClose(FileHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfsrec.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfsrec.h

Abstract:

    Header file for filesystem recognition.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/


#ifndef _SPFSREC_
#define _SPFSREC_


//
// Do NOT rearrange this enum without changing
// the order of the filesystem names in the message file
// (starting at SP_TEXT_FS_NAME_BASE).
//
typedef enum {
    FilesystemUnknown       = 0,
    FilesystemNewlyCreated  = 1,
    FilesystemFat           = 2,
    FilesystemFirstKnown    = FilesystemFat,
    FilesystemNtfs          = 3,
    FilesystemFat32         = 4,
    FilesystemDoubleSpace   = 5,
    FilesystemMax
} FilesystemType;



FilesystemType
SpIdentifyFileSystem(
    IN PWSTR     DevicePath,
    IN ULONG     BytesPerSector,
    IN ULONG     PartitionOrdinal
    );

ULONG
NtfsMirrorBootSector (
    IN      HANDLE  Handle,
    IN      ULONG   BytesPerSector,
    IN OUT  PUCHAR  *Buffer
    );

VOID
WriteNtfsBootSector (
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  Buffer,
    IN ULONG  WhichOne
    );

//
// File system boot code.
//
extern UCHAR FatBootCode[512];
extern UCHAR Fat32BootCode[3*512];
extern UCHAR NtfsBootCode[16*512];
extern UCHAR PC98FatBootCode[512]; //NEC98
extern UCHAR PC98Fat32BootCode[3*512]; //NEC98
extern UCHAR PC98NtfsBootCode[8192]; //NEC98

#endif // ndef _SPFSREC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spfsrec.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfsrec.c

Abstract:

    Filesystem recognition/identification routines.

Author:

    Ted Miller (tedm) 16-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <bootfat.h>
#include <bootf32.h>
#include <bootntfs.h>
#include <boot98f.h> //NEC98
#include <boot98n.h> //NEC98
#include <boot98f2.h> //NEC98
#include <patchbc.h>

//
// Packed FAT boot sector.
//
typedef struct _BOOTSECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    UCHAR BytesPerSector[2];
    UCHAR SectorsPerCluster[1];
    UCHAR ReservedSectors[2];
    UCHAR Fats[1];
    UCHAR RootEntries[2];
    UCHAR Sectors[2];
    UCHAR Media[1];
    UCHAR SectorsPerFat[2];
    UCHAR SectorsPerTrack[2];
    UCHAR Heads[2];
    UCHAR HiddenSectors[4];
    UCHAR LargeSectors[4];
    UCHAR PhysicalDriveNumber[1];                   // offset = 0x024  36
    UCHAR Reserved[1];                              // offset = 0x025  37
    UCHAR Signature[1];                             // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
    UCHAR BootStrap[510-62];
    UCHAR AA55Signature[2];
} BOOTSECTOR, *PBOOTSECTOR;


//
// Packed NTFS boot sector.
//
typedef struct _NTFS_BOOTSECTOR {
    UCHAR         Jump[3];
    UCHAR         Oem[8];
    UCHAR         BytesPerSector[2];
    UCHAR         SectorsPerCluster[1];
    UCHAR         ReservedSectors[2];
    UCHAR         Fats[1];
    UCHAR         RootEntries[2];
    UCHAR         Sectors[2];
    UCHAR         Media[1];
    UCHAR         SectorsPerFat[2];
    UCHAR         SectorsPerTrack[2];
    UCHAR         Heads[2];
    UCHAR         HiddenSectors[4];
    UCHAR         LargeSectors[4];
    UCHAR         Unused[4];
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    CHAR          ClustersPerFileRecordSegment;
    UCHAR         Reserved0[3];
    CHAR          DefaultClustersPerIndexAllocationBuffer;
    UCHAR         Reserved1[3];
    LARGE_INTEGER SerialNumber;
    ULONG         Checksum;
    UCHAR         BootStrap[512-86];
    USHORT        AA55Signature;
} NTFS_BOOTSECTOR, *PNTFS_BOOTSECTOR;


//
// Various signatures
//
#define BOOTSECTOR_SIGNATURE    0xaa55


BOOLEAN
SpIsFat(
    IN  HANDLE   PartitionHandle,
    IN  ULONG    BytesPerSector,
    IN  PVOID    AlignedBuffer,
    OUT BOOLEAN *Fat32
    )

/*++

Routine Description:

    Determine whether a partition contians a FAT or FAT32 filesystem.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    Fat32 - if this routine returns TRUE then this receives a flag
        indicating whether the volume is fat32.

Return Value:

    TRUE if the drive appears to be FAT.

--*/

{
    PBOOTSECTOR BootSector;
    USHORT bps;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONG SecCnt;

    //
    // Get partition info. This is so we can check to make sure the
    // file system on the partition isn't actually larger than the
    // partition itself. This happens for example when people
    // abuse the win9x rawread/rawwrite oem tool.
    //
    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsFat: unable to get partition info (%lx)\n",Status));
        return(FALSE);
    }

    if((ULONGLONG)(PartitionInfo.PartitionLength.QuadPart / BytesPerSector) > 0xffffffffUi64) {
        //
        // This can't happen since the BPB can't describe it.
        //
        return(FALSE);
    }
    SecCnt = (ULONG)(PartitionInfo.PartitionLength.QuadPart / BytesPerSector);

    ASSERT(sizeof(BOOTSECTOR)==512);
    BootSector = AlignedBuffer;

    //
    // Read the boot sector (sector 0).
    //
    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                0,
                1,
                BytesPerSector,
                BootSector,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsFat: Error %lx reading sector 0\n",Status));
        return(FALSE);
    }

    //
    // Adjust large sector count if necessary.
    //
    if(U_USHORT(BootSector->Sectors)) {
        U_ULONG(BootSector->LargeSectors) = 0;

        if((ULONG)U_USHORT(BootSector->Sectors) > SecCnt) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Boot sector on a disk has inconsistent size information!!\n"));
            return(FALSE);
        }
    } else {
        if(U_ULONG(BootSector->LargeSectors) > SecCnt) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Boot sector on a disk has inconsistent size information!!\n"));
            return(FALSE);
        }
    }

    //
    // Check various fields for permissible values.
    // Note that this check does not venture into fields beyond the BPB,
    // so disks with sector size < 512 are allowed.
    //
    if((BootSector->Jump[0] != 0x49)        // Fujitsu FMR
    && (BootSector->Jump[0] != 0xe9)
    && (BootSector->Jump[0] != 0xeb)) {
        return(FALSE);
    }

    bps = U_USHORT(BootSector->BytesPerSector);
    if((bps !=  128) && (bps !=  256)
    && (bps !=  512) && (bps != 1024)
    && (bps !=  2048) && (bps != 4096)) {
       return(FALSE);
    }

    if((BootSector->SectorsPerCluster[0] !=  1)
    && (BootSector->SectorsPerCluster[0] !=  2)
    && (BootSector->SectorsPerCluster[0] !=  4)
    && (BootSector->SectorsPerCluster[0] !=  8)
    && (BootSector->SectorsPerCluster[0] != 16)
    && (BootSector->SectorsPerCluster[0] != 32)
    && (BootSector->SectorsPerCluster[0] != 64)
    && (BootSector->SectorsPerCluster[0] != 128)) {

        return(FALSE);
    }

    if(!U_USHORT(BootSector->ReservedSectors) || !BootSector->Fats[0]) {
        return(FALSE);
    }

    if(!U_USHORT(BootSector->Sectors) && !U_ULONG(BootSector->LargeSectors)) {
        return(FALSE);
    }

    if((BootSector->Media[0] != 0x00)       // FMR (formatted by OS/2)
    && (BootSector->Media[0] != 0x01)       // FMR (floppy, formatted by DOS)
    && (BootSector->Media[0] != 0xf0)
    && (BootSector->Media[0] != 0xf8)
    && (BootSector->Media[0] != 0xf9)
    && (BootSector->Media[0] != 0xfa)       // FMR
    && (BootSector->Media[0] != 0xfb)
    && (BootSector->Media[0] != 0xfc)
    && (BootSector->Media[0] != 0xfd)
    && (BootSector->Media[0] != 0xfe)
    && (BootSector->Media[0] != 0xff)) {
        return(FALSE);
    }

    //
    // Final distinction is between FAT and FAT32.
    // Root dir entry count is 0 on FAT32.
    //
    if(U_USHORT(BootSector->SectorsPerFat) && !U_USHORT(BootSector->RootEntries)) {
        return(FALSE);
    }
    *Fat32 = (BOOLEAN)(U_USHORT(BootSector->RootEntries) == 0);
    return(TRUE);
}


BOOLEAN
SpIsNtfs(
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  AlignedBuffer,
    IN ULONG  WhichOne
    )

/*++

Routine Description:

    Determine whether a partition contians an NTFS filesystem.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    WhichOne - supplies a value that allows the caller to try more than
        one sector. 0 = sector 0. 1 = sector n-1. 2 = sector n/2, where
        n = number of sectors in the partition.

Return Value:

    TRUE if the drive appears to be FAT.

--*/

{
    PNTFS_BOOTSECTOR BootSector;
    NTSTATUS Status;
    PULONG l;
    ULONG Checksum;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONGLONG SecCnt;

    //
    // Get partition information.
    //
    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsNtfs: unable to get partition info (%lx)\n",Status));
        return(FALSE);
    }

    SecCnt = (ULONGLONG)PartitionInfo.PartitionLength.QuadPart / BytesPerSector;

    ASSERT(sizeof(NTFS_BOOTSECTOR)==512);
    BootSector = AlignedBuffer;

    //
    // Read the boot sector (sector 0).
    //
    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                (ULONG)(WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0),
                1,
                BytesPerSector,
                BootSector,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsNtfs: Error %lx reading sector %u\n",Status,WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0));
        return(FALSE);
    }

    //
    // Caulculate the checksum.
    //
    for(Checksum=0,l=(PULONG)BootSector; l<(PULONG)&BootSector->Checksum; l++) {
        Checksum += *l;
    }

    //
    // Ensure that NTFS appears in the OEM field.
    //
    if(strncmp(BootSector->Oem,"NTFS    ",8)) {
        return(FALSE);
    }

    //
    // The number of bytes per sector must match the value
    // reported by the device, and must be less than or equal to
    // the page size.
    //
    if((U_USHORT(BootSector->BytesPerSector) != BytesPerSector)
    || (U_USHORT(BootSector->BytesPerSector) > PAGE_SIZE))
    {
        return(FALSE);
    }

    //
    // Other checks.
    // Note that these checks do not venture into fields beyond 128 bytes,
    // so disks with sector size < 512 are allowed.
    //
    if((BootSector->SectorsPerCluster[0] !=  1)
    && (BootSector->SectorsPerCluster[0] !=  2)
    && (BootSector->SectorsPerCluster[0] !=  4)
    && (BootSector->SectorsPerCluster[0] !=  8)
    && (BootSector->SectorsPerCluster[0] != 16)
    && (BootSector->SectorsPerCluster[0] != 32)
    && (BootSector->SectorsPerCluster[0] != 64)
    && (BootSector->SectorsPerCluster[0] != 128)) {

        return(FALSE);
    }

    if(U_USHORT(BootSector->ReservedSectors)
    || BootSector->Fats[0]
    || U_USHORT(BootSector->RootEntries)
    || U_USHORT(BootSector->Sectors)
    || U_USHORT(BootSector->SectorsPerFat)
    || U_ULONG(BootSector->LargeSectors)) {

        return(FALSE);
    }

    //
    // ClustersPerFileRecord can be less than zero if file records
    // are smaller than clusters.  This number is the negative of a shift count.
    // If clusters are smaller than file records then this number is
    // still the clusters per file records.
    //

    if(BootSector->ClustersPerFileRecordSegment <= -9) {
        if(BootSector->ClustersPerFileRecordSegment < -31) {
            return(FALSE);
        }

    } else if((BootSector->ClustersPerFileRecordSegment !=  1)
           && (BootSector->ClustersPerFileRecordSegment !=  2)
           && (BootSector->ClustersPerFileRecordSegment !=  4)
           && (BootSector->ClustersPerFileRecordSegment !=  8)
           && (BootSector->ClustersPerFileRecordSegment != 16)
           && (BootSector->ClustersPerFileRecordSegment != 32)
           && (BootSector->ClustersPerFileRecordSegment != 64)) {

        return(FALSE);
    }

    //
    // ClustersPerIndexAllocationBuffer can be less than zero if index buffers
    // are smaller than clusters.  This number is the negative of a shift count.
    // If clusters are smaller than index buffers then this number is
    // still the clusters per index buffers.
    //

    if(BootSector->DefaultClustersPerIndexAllocationBuffer <= -9) {
        if(BootSector->DefaultClustersPerIndexAllocationBuffer < -31) {
            return(FALSE);
        }

    } else if((BootSector->DefaultClustersPerIndexAllocationBuffer !=  1)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  2)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  4)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  8)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 16)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 32)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 64)) {

        return(FALSE);
    }

    if((ULONGLONG)BootSector->NumberSectors.QuadPart > SecCnt) {
        return(FALSE);
    }

    if((((ULONGLONG)BootSector->MftStartLcn.QuadPart * BootSector->SectorsPerCluster[0]) > SecCnt)
    || (((ULONGLONG)BootSector->Mft2StartLcn.QuadPart * BootSector->SectorsPerCluster[0]) > SecCnt)) {

        return(FALSE);
    }

    return(TRUE);
}


FilesystemType
SpIdentifyFileSystem(
    IN PWSTR     DevicePath,
    IN ULONG     BytesPerSector,
    IN ULONG     PartitionOrdinal
    )

/*++

Routine Description:

    Identify the filesystem present on a given partition.

Arguments:

    DevicePath - supplies the name in the nt namespace for
        the disk's device object.

    BytesPerSector - supplies value reported by IOCTL_GET_DISK_GEOMETRY.

    PartitionOrdinal - supplies the ordinal of the partition
        to be identified.

Return Value:

    Value from the FilesystemType enum identifying the filesystem.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;
    FilesystemType fs;
    PUCHAR UnalignedBuffer,AlignedBuffer;
    BOOLEAN Fat32;

    //
    // First open the partition.
    //
    Status = SpOpenPartition(DevicePath,PartitionOrdinal,&Handle,FALSE);

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpIdentifyFileSystem: unable to open %ws\\partition%u (%lx)\n",
            DevicePath,
            PartitionOrdinal
            ));

        return(FilesystemUnknown);
    }

    UnalignedBuffer = SpMemAlloc(2*BytesPerSector);
    AlignedBuffer = ALIGN(UnalignedBuffer,BytesPerSector);

    //
    // Check for each filesystem we know about.
    //
    if(SpIsFat(Handle,BytesPerSector,AlignedBuffer,&Fat32)) {
        fs = Fat32 ? FilesystemFat32 : FilesystemFat;
    } else {
        if(SpIsNtfs(Handle,BytesPerSector,AlignedBuffer,0)) {
            fs = FilesystemNtfs;
        } else {
            fs = FilesystemUnknown;
        }
    }

    SpMemFree(UnalignedBuffer);

    ZwClose(Handle);

    return(fs);
}

ULONG
NtfsMirrorBootSector (
    IN      HANDLE  Handle,
    IN      ULONG   BytesPerSector,
    IN OUT  PUCHAR  *Buffer
    )

/*++

Routine Description:

    Finds out where the mirror boot sector is.

Arguments:

    Handle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    Buffer - receives the address of the buffer we use to read the boot sector

Return Value:

    0 - mirror sector not found
    1 - mirror in sector n-1
    2 - mirror in sector n/2
    where n = number of sectors in the partition.

--*/

{
    NTSTATUS    Status;
    PUCHAR      UnalignedBuffer, AlignedBuffer;
    ULONG       Mirror;

    Mirror = 0;

    //
    // Set up our buffer
    //

    UnalignedBuffer = SpMemAlloc (2*BytesPerSector);
    ASSERT (UnalignedBuffer);
    AlignedBuffer = ALIGN (UnalignedBuffer, BytesPerSector);

    //
    // Look for the mirror boot sector
    //

    if (SpIsNtfs (Handle,BytesPerSector,AlignedBuffer,1)) {
        Mirror = 1;
    } else if (SpIsNtfs (Handle,BytesPerSector,AlignedBuffer,2)) {
        Mirror = 2;
    }

    //
    // Give the caller a copy of the buffer
    //

    if (Buffer) {
        *Buffer = SpMemAlloc (BytesPerSector);
        RtlMoveMemory (*Buffer, AlignedBuffer, BytesPerSector);
    }

    SpMemFree (UnalignedBuffer);
    return Mirror;
}


VOID
WriteNtfsBootSector (
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  Buffer,
    IN ULONG  WhichOne
    )

/*++

Routine Description:

    Writes a NTFS boot sector to sector 0 or one of the mirror locations.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    WhichOne - supplies a value that allows the caller to try more than
        one sector. 0 = sector 0. 1 = sector n-1. 2 = sector n/2, where
        n = number of sectors in the partition.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    PUCHAR      UnalignedBuffer, AlignedBuffer;
    ULONGLONG SecCnt;


    UnalignedBuffer = SpMemAlloc (2*BytesPerSector);
    ASSERT (UnalignedBuffer);
    AlignedBuffer = ALIGN (UnalignedBuffer, BytesPerSector);
    RtlMoveMemory (AlignedBuffer, Buffer, BytesPerSector);

    //
    // Get partition information.
    //

    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: WriteNtfsBootSector: unable to get partition info (%lx)\n",
            Status));
        return;
    }

    SecCnt = (ULONGLONG)PartitionInfo.PartitionLength.QuadPart / BytesPerSector;

    ASSERT(sizeof(NTFS_BOOTSECTOR)==512);

    //
    // Write the boot sector.
    //

    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                (ULONG)(WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0),
                1,
                BytesPerSector,
                AlignedBuffer,
                TRUE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: WriteNtfsBootSector: Error %lx reading sector 0\n",
            Status));
        return;
    }

    SpMemFree (UnalignedBuffer);
}


BOOLEAN
SpPatchBootMessages(
    VOID
    )
{
    LPWSTR UnicodeMsg;
    LPSTR FatNtldrMissing;
    LPSTR FatDiskError;
    LPSTR FatPressKey;
    LPSTR NtfsNtldrMissing;
    LPSTR NtfsNtldrCompressed;
    LPSTR NtfsDiskError;
    LPSTR NtfsPressKey;
    LPSTR MbrInvalidTable;
    LPSTR MbrIoError;
    LPSTR MbrMissingOs;
    ULONG l;
    extern unsigned char x86BootCode[512];

    //
    // we don't touch boot code on NEC98
    //
    if (IsNEC_98) { //NEC98
        return(TRUE);
    } //NEC98

    UnicodeMsg = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    //
    // Deal with FAT -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_NTLDR_MISSING);
    FatNtldrMissing = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(FatNtldrMissing,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_DISK_ERROR);
    FatDiskError = FatNtldrMissing + l;
    RtlUnicodeToOemN(FatDiskError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_PRESS_KEY);
    FatPressKey = FatDiskError + l;
    RtlUnicodeToOemN(FatPressKey,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoFatBootCode(FatBootCode,FALSE,FatNtldrMissing,FatDiskError,FatPressKey)) {
        return(FALSE);
    }

    if(!PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,FatNtldrMissing,FatDiskError,FatPressKey)) {
        return(FALSE);
    }

    //
    // Deal with NTFS -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_NTLDR_MISSING);
    NtfsNtldrMissing = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(NtfsNtldrMissing,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_NTLDR_COMPRESSED);
    NtfsNtldrCompressed = NtfsNtldrMissing + l;
    RtlUnicodeToOemN(NtfsNtldrCompressed,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_DISK_ERROR);
    NtfsDiskError = NtfsNtldrCompressed + l;
    RtlUnicodeToOemN(NtfsDiskError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_PRESS_KEY);
    NtfsPressKey = NtfsDiskError + l;
    RtlUnicodeToOemN(NtfsPressKey,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoNtfsBootCode(NtfsBootCode,NtfsNtldrMissing,NtfsNtldrCompressed,NtfsDiskError,NtfsPressKey)) {
        return(FALSE);
    }

    //
    // Deal with MBR -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_INVALID_TABLE);
    MbrInvalidTable = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(MbrInvalidTable,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_IO_ERROR);
    MbrIoError = MbrInvalidTable + l;
    RtlUnicodeToOemN(MbrIoError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_MISSING_OS);
    MbrMissingOs = MbrIoError + l;
    RtlUnicodeToOemN(MbrMissingOs,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoMasterBootCode(x86BootCode,MbrInvalidTable,MbrIoError,MbrMissingOs)) {
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sphelp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphelp.c

Abstract:

    Routines for displaying on-line help during text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


#define MAX_HELP_SCREENS 100

PWSTR HelpScreen[MAX_HELP_SCREENS+1];


VOID
SpHelp(
    IN ULONG    MessageId,      OPTIONAL
    IN PCWSTR   FileText,       OPTIONAL
    IN ULONG    Flags
    )
{
    UCHAR StatusAttribute, BackgroundAttribute, HeaderAttribute,
          ClientAttribute, ClientIntenseAttribute;
    PWSTR HelpText,p,q;
    ULONG ScreenCount;
    ULONG ValidKeys[8];
    ULONG CurrentScreen;
    ULONG y;
    BOOLEAN Intense;
    BOOLEAN Done;
    unsigned kc;

    //
    // Pick the video attributes we want
    //
    if(Flags & SPHELP_LICENSETEXT) {

        StatusAttribute = DEFAULT_STATUS_ATTRIBUTE;
        BackgroundAttribute = DEFAULT_BACKGROUND;
        HeaderAttribute = DEFAULT_ATTRIBUTE;
        ClientAttribute = DEFAULT_ATTRIBUTE;
        ClientIntenseAttribute = (ATT_FG_INTENSE  | ATT_BG_INTENSE);

    } else {

        StatusAttribute = (ATT_FG_WHITE | ATT_BG_BLUE);
        BackgroundAttribute = ATT_WHITE;
        HeaderAttribute = (ATT_FG_BLUE  | ATT_BG_WHITE);
        ClientAttribute = (ATT_FG_BLACK | ATT_BG_WHITE);
        ClientIntenseAttribute = (ATT_FG_BLUE  | ATT_BG_WHITE);
    }

    //
    // Retreive the help text.
    //
    if (FileText) {
        HelpText = (PWSTR)FileText;
    } else {
        HelpText = SpRetreiveMessageText(NULL,MessageId,NULL,0);
        if (!HelpText) { // no way to return an error code, so fail quietly
	    goto s0;
        }
    }

    //
    // Shop off extra blank lines in the text.
    //
    p = HelpText + wcslen(HelpText);
    while((p > HelpText) && SpIsSpace(*(p-1))) {
        p--;
    }
    if(q = wcschr(p,L'\n')) {
        *(++q) = 0;
    }

    //
    // Break up the help text into screens.
    // The maximum length of a help screen will be the client screen size
    // minus two lines for spacing.  A %P alone at the beginning of a line
    // forces a page break.
    //
    for(p=HelpText,ScreenCount=0; *p; ) {

        //
        // Mark the start of a new screen.
        //
        HelpScreen[ScreenCount++] = p;

        //
        // Count lines in the help text.
        //
        for(y=0; *p; ) {

            //
            // Determine whether this line is really a hard page break
            // or if we have exhausted the number of lines allowed on a screen.
            //
            if(((p[0] == L'%') && (p[1] == 'P')) || (++y == CLIENT_HEIGHT-2)) {
                break;
            }

            //
            // Find next line start.
            //
            if(q = wcschr(p,L'\r')) {
                p = q + 2;
            } else {
                p = wcschr(p,0);
            }
        }

        //
        // Find the end of the line that broke us out of the loop
        // and then the start of the next line (if any).
        //
        if(q = wcschr(p,L'\r')) {
            p = q + 2;
        } else {
            p = wcschr(p,0);
        }

        if(ScreenCount == MAX_HELP_SCREENS) {
            break;
        }
    }

    //
    // Sentinal value: point to the terminating nul byte.
    //
    HelpScreen[ScreenCount] = p;

    //
    // Display header text in blue on white.
    //
    SpvidClearScreenRegion(0,0,VideoVars.ScreenWidth,HEADER_HEIGHT,BackgroundAttribute);
    if(Flags & SPHELP_LICENSETEXT) {
        SpDisplayHeaderText(SP_HEAD_LICENSE,HeaderAttribute);
    } else {
        SpDisplayHeaderText(SP_HEAD_HELP,HeaderAttribute);
    }

    //
    // The first screen to display is screen 0.
    //
    CurrentScreen = 0;

    Done = FALSE;
    do {

        SpvidClearScreenRegion(
            0,
            HEADER_HEIGHT,
            VideoVars.ScreenWidth,
            VideoVars.ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT),
            BackgroundAttribute
            );

        //
        // Display the current screen.
        //
        for(y=HEADER_HEIGHT+1, p=HelpScreen[CurrentScreen]; *p && (p < HelpScreen[CurrentScreen+1]); y++) {

            Intense = FALSE;
            if(p[0] == L'%') {
                if(p[1] == L'I') {
                    Intense = TRUE;
                    p += 2;
                } else {
                    if(p[1] == L'P') {
                        p += 2;     // don't display %P
                    }
                }
            }

            q = wcschr(p,L'\r');
            if(q) {
                *q = 0;
            }

            SpvidDisplayString(
                p,
                (UCHAR)(Intense ? ClientIntenseAttribute : ClientAttribute),
                3,
                y
                );

            if(q) {
                *q = '\r';
                p = q + 2;
            } else {
                p = wcschr(p,0);
            }
        }

        //
        // Construct a list of valid keypresses from the user, depending
        // on whether this is the first, last, etc. screen.
        //
        // If there are previous screens, BACKSPACE=Read Last Help is an option.
        // If there are additional screens, ENTER=Continue Reading Help is an option.
        // ESC=Cancel Help is always an option for help text.
        //
        // For licensing text, we allow pageup/pagedown when appropriate,
        // and on the last page we allow accept/reject.
        //
        kc = 0;

        if(Flags & SPHELP_LICENSETEXT) {

            ValidKeys[kc++] = KEY_F8;
            ValidKeys[kc++] = ASCI_ESC;

            if(CurrentScreen) {
                ValidKeys[kc++] = KEY_PAGEUP;
            }
            if(CurrentScreen < ScreenCount-1) {
                ValidKeys[kc++] = KEY_PAGEDOWN;
            }

        } else {

            ValidKeys[kc++] = ASCI_ESC;

            if(CurrentScreen) {
                ValidKeys[kc++] = ASCI_BS;
                ValidKeys[kc++] = KEY_PAGEUP;
            }
            if(CurrentScreen < ScreenCount-1) {
                ValidKeys[kc++] = ASCI_CR;
                ValidKeys[kc++] = KEY_PAGEDOWN;
            }
        }

        ValidKeys[kc] = 0;

        if(CurrentScreen && (CurrentScreen < ScreenCount-1)) {
            //
            // There are screens before and after this one.
            //
            if(Flags & SPHELP_LICENSETEXT) {

                SpDisplayStatusOptions(
                    StatusAttribute,
                    SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                    SP_STAT_X_EQUALS_REJECT_LICENSE,
                    SP_STAT_PAGEDOWN_EQUALS_NEXT_LIC,
                    SP_STAT_PAGEUP_EQUALS_PREV_LIC,
                    0
                    );

            } else {

                SpDisplayStatusOptions(
                    StatusAttribute,
                    SP_STAT_ENTER_EQUALS_CONTINUE_HELP,
                    SP_STAT_BACKSP_EQUALS_PREV_HELP,
                    SP_STAT_ESC_EQUALS_CANCEL_HELP,
                    0
                    );
            }
        } else {
            if(CurrentScreen) {
                //
                // This is the last page but not the only page.
                //
                if(Flags & SPHELP_LICENSETEXT) {

                    SpDisplayStatusOptions(
                        StatusAttribute,
                        SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                        SP_STAT_X_EQUALS_REJECT_LICENSE,
                        SP_STAT_PAGEUP_EQUALS_PREV_LIC,
                        0
                        );

                } else {

                    SpDisplayStatusOptions(
                        StatusAttribute,
                        SP_STAT_BACKSP_EQUALS_PREV_HELP,
                        SP_STAT_ESC_EQUALS_CANCEL_HELP,
                        0
                        );
                }
            } else {
                if(CurrentScreen < ScreenCount-1) {
                    //
                    // This is the first page but additional pages exist.
                    //
                    if(Flags & SPHELP_LICENSETEXT) {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                            SP_STAT_X_EQUALS_REJECT_LICENSE,
                            SP_STAT_PAGEDOWN_EQUALS_NEXT_LIC,
                            0
                            );

                    } else {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_ENTER_EQUALS_CONTINUE_HELP,
                            SP_STAT_ESC_EQUALS_CANCEL_HELP,
                            0
                            );
                    }
                } else {
                    //
                    // This is the only page.
                    //
                    if(Flags & SPHELP_LICENSETEXT) {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                            SP_STAT_X_EQUALS_REJECT_LICENSE,
                            0
                            );

                    } else {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_ESC_EQUALS_CANCEL_HELP,
                            0
                            );
                    }
                }
            }
        }

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:

            if(Flags & SPHELP_LICENSETEXT) {
                SpDone(0,FALSE,TRUE);
            }

            // ELSE FALL THROUGH

        case KEY_F8:

            Done = TRUE;
            break;

        case KEY_PAGEUP:
        case ASCI_BS:

            ASSERT(CurrentScreen);
            CurrentScreen--;
            break;

        case KEY_PAGEDOWN:
        case ASCI_CR:

            ASSERT(CurrentScreen < ScreenCount-1);
            CurrentScreen++;
            break;
        }
    } while(!Done);

    //
    // Clean up.
    //
    if(!FileText) {
        SpMemFree(HelpText);
    }

s0:
    CLEAR_ENTIRE_SCREEN();
    
    SpDisplayHeaderText(
        SpGetHeaderTextId(),
        DEFAULT_ATTRIBUTE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spgauge.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spgauge.c

Abstract:

    Code implementing a gas gauge for file copies for text mode NT setup.

Author:

    Ted Miller (tedm) 14-April-1992

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


PWSTR PctFmtStr = L"%u%%   ";


VOID
pSpDrawVariableParts(
    IN PGAS_GAUGE Gauge
    );



PVOID
SpCreateAndDisplayGauge(
    IN ULONG  ItemCount,
    IN ULONG  GaugeWidth,       OPTIONAL
    IN ULONG  Y,
    IN PWCHAR Caption,
    IN PWCHAR ProgressFmtStr,   OPTIONAL
    IN ULONG  Flags,            OPTIONAL
    IN UCHAR  Attribute         OPTIONAL
    )
{
    PGAS_GAUGE Gauge;
    ULONG X;


    //
    // Allocate a gauge structure.
    //
    Gauge = SpMemAlloc(sizeof(GAS_GAUGE));
    if(!Gauge) {
        return(NULL);
    }

    Gauge->Buffer = SpMemAlloc(VideoVars.ScreenWidth*sizeof(WCHAR));
    if(!Gauge->Buffer) {
        SpMemFree(Gauge);
        return(NULL);
    }

    Gauge->Caption = SpMemAlloc((wcslen(Caption)+1)*sizeof(WCHAR));
    if(!Gauge->Caption) {
        SpMemFree(Gauge->Buffer);
        SpMemFree(Gauge);
        return(NULL);
    }
    wcscpy(Gauge->Caption,Caption);

    if (ProgressFmtStr) {
        Gauge->ProgressFmtStr = SpMemAlloc((wcslen(ProgressFmtStr)+1)*sizeof(WCHAR));
        if(!Gauge->ProgressFmtStr) {
            SpMemFree(Gauge->Buffer);
            SpMemFree(Gauge->Caption);
            SpMemFree(Gauge);
            return(NULL);
        }
        wcscpy(Gauge->ProgressFmtStr,ProgressFmtStr);
        Gauge->ProgressFmtWidth = SplangGetColumnCount(ProgressFmtStr);
    } else {
        Gauge->ProgressFmtStr = PctFmtStr;
        Gauge->ProgressFmtWidth = 3;
    }

    Gauge->Flags = Flags;

    if (Attribute) {
       Gauge->Attribute = Attribute;
    } else {
       Gauge->Attribute = GAUGE_ATTRIBUTE;
    }

    //
    // If the caller did not specify a width, calculate one.
    // Originally, a gauge was 66 chars wide on an 80 character vga screen.
    // To preserve that ratio, make the width 66/80ths of the screen.
    //
    if(!GaugeWidth) {

        GaugeWidth = VideoVars.ScreenWidth * 66 / 80;
        if(GaugeWidth & 1) {
            GaugeWidth++;        // make sure it's even.
        }
    }

    //
    // Center the gauge horizontally.
    //
    X = (VideoVars.ScreenWidth - GaugeWidth) / 2;

    Gauge->GaugeX = X;
    Gauge->GaugeY = Y;
    Gauge->GaugeW = GaugeWidth;

    //
    // Calculate the size of the thermometer box.
    // The box is always offset by 6 characters from the gauge itself.
    //

    Gauge->ThermX = X+6;
    Gauge->ThermY = Y+3;
    Gauge->ThermW = GaugeWidth-12;

    //
    // Save away additional info about the gauge.
    //

    Gauge->ItemCount = max (ItemCount, 1);  // ensure no divide-by-zero bug checks
    Gauge->ItemsElapsed = 0;
    Gauge->CurrentPercentage = 0;

    SpDrawGauge(Gauge);

    return(Gauge);
}


VOID
SpDestroyGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;

    if (Gauge == NULL)
        return;

    if (Gauge->ProgressFmtStr != PctFmtStr) {
       SpMemFree(Gauge->ProgressFmtStr);
    }
    SpMemFree(Gauge->Caption);
    SpMemFree(Gauge->Buffer);
    SpMemFree(Gauge);
}



VOID
SpDrawGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;

    //
    // Draw the outer box.
    //
    SpDrawFrame(
        Gauge->GaugeX,
        Gauge->GaugeW,
        Gauge->GaugeY,
        GAUGE_HEIGHT,
        DEFAULT_ATTRIBUTE,
        TRUE
        );

    //
    // Draw the thermometer box.
    //
    SpDrawFrame(
        Gauge->ThermX,
        Gauge->ThermW,
        Gauge->ThermY,
        3,
        DEFAULT_ATTRIBUTE,
        FALSE
        );

    //
    // Percent complete, etc.
    //
    pSpDrawVariableParts(Gauge);

    //
    // Caption text
    //
    SpvidDisplayString(Gauge->Caption,DEFAULT_ATTRIBUTE,Gauge->GaugeX+2,Gauge->GaugeY+1);
}



VOID
SpTickGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;
    ULONG NewPercentage;

    if(Gauge->ItemsElapsed < Gauge->ItemCount) {

        Gauge->ItemsElapsed++;

        NewPercentage = 100 * Gauge->ItemsElapsed / Gauge->ItemCount;

        if(NewPercentage != Gauge->CurrentPercentage) {

            Gauge->CurrentPercentage = NewPercentage;

            pSpDrawVariableParts(Gauge);
        }
    }
}


VOID
pSpDrawVariableParts(
    IN PGAS_GAUGE Gauge
    )
{
    ULONG Spaces;
    ULONG i;
    WCHAR Percent[128];

    //
    // Figure out how many spaces this is.
    //
    Spaces = Gauge->ItemsElapsed * (Gauge->ThermW-2) / Gauge->ItemCount;

    for(i=0; i<Spaces; i++) {
        Gauge->Buffer[i] = L' ';
    }
    Gauge->Buffer[Spaces] = 0;

    SpvidDisplayString(Gauge->Buffer,Gauge->Attribute,Gauge->ThermX+1,Gauge->ThermY+1);

    //
    // Now put the percentage text up.
    //
    switch (Gauge->Flags) {
        case GF_PERCENTAGE:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->CurrentPercentage );
            break;

        case GF_ITEMS_REMAINING:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->ItemCount - Gauge->ItemsElapsed );
            break;

        case GF_ITEMS_USED:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->ItemsElapsed );
            break;
    }

    SpvidDisplayString(
        Percent,
        DEFAULT_ATTRIBUTE,
        Gauge->GaugeX + ((Gauge->GaugeW-Gauge->ProgressFmtWidth)/2),
        Gauge->GaugeY+2
        );
}


VOID
SpFillGauge(
    IN PVOID GaugeHandle,
    IN ULONG Amount
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;
    ULONG NewPercentage;

    if(Amount <= Gauge->ItemCount) {

        Gauge->ItemsElapsed = Amount;

        NewPercentage = 100 * Gauge->ItemsElapsed / Gauge->ItemCount;

        if(NewPercentage != Gauge->CurrentPercentage) {

            Gauge->CurrentPercentage = NewPercentage;

            pSpDrawVariableParts(Gauge);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spkbd.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spkbd.c

Abstract:

    Text setup keyboard support routines.

Author:

    Ted Miller (tedm) 30-July-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <kbd.h>
#include <ntddkbd.h>

PKBDTABLES KeyboardTable;

HANDLE hKeyboard;

BOOLEAN KeyboardInitialized = FALSE;
BOOLEAN KbdLayoutInitialized = FALSE;

USHORT CurrentLEDs;

//
// Globals for async I/O calls
//
KEYBOARD_INDICATOR_PARAMETERS asyncKbdParams;
IO_STATUS_BLOCK asyncIoStatusBlock;


#define MAX_KEYBOARD_ITEMS 10



VOID
spkbdApcProcedure(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG            Reserved
    );

VOID
spkbdSetLEDs(
    VOID
    );

VOID
SpkbdInitialize(
    VOID
    );

VOID
SpkbdTerminate(
    VOID
    );
    
VOID
SpkbdLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    );
    
ULONG
SpkbdGetKeypress(
    VOID
    );

BOOLEAN
SpkbdIsKeyWaiting(
    VOID
    );

VOID
SpkbdDrain(
    VOID
    );


//
// Buffer for one character.
//
volatile ULONG KbdNextChar;


//
// The following are used in async calls to NtReadFile and so
// cannot be on the stack.
//
IO_STATUS_BLOCK     IoStatusKeyboard;
KEYBOARD_INPUT_DATA KeyboardInputData[MAX_KEYBOARD_ITEMS];
LARGE_INTEGER       DontCareLargeInteger;


//
// Current state of shift, control, alt keys.
//
USHORT  ModifierBits = 0;

#define START_KEYBOARD_READ()       \
                                    \
    ZwReadFile(                     \
        hKeyboard,                  \
        NULL,                       \
        spkbdApcProcedure,          \
        NULL,                       \
        &IoStatusKeyboard,          \
        KeyboardInputData,          \
        sizeof(KeyboardInputData),  \
        &DontCareLargeInteger,      \
        NULL                        \
        )



VOID
SpInputInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize all input support.  This includes

    - opening the serial port and checking for a terminal.
    - opening the keyboard device.

Arguments:

    None.

Return Value:

    None. Does not return if not successful.

--*/

{
    SpkbdInitialize();
    SpTermInitialize();
}

VOID
SpInputTerminate(
    VOID
    )

/*++

Routine Description:

    Terminate all input support.  This includes

    - closing the serial port.
    - closing the keyboard device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SpkbdTerminate();
    SpTermTerminate();
}

VOID
SpInputLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    )
{
    SpkbdLoadLayoutDll(SifHandle, Directory);
}

ULONG
SpInputGetKeypress(
    VOID
    )

/*++

Routine Description:

    Wait for a keypress and return it to the caller.
    The return value will be an ASCII value (ie, not a scan code).

Arguments:

    None.

Return Value:

    ASCII value.

--*/

{
    ULONG Tmp;

    //
    // If we are in upgrade graphics mode then
    // switch to textmode
    //
    SpvidSwitchToTextmode();

    while (TRUE) {
    
        if (SpTermIsKeyWaiting()) {
            Tmp = SpTermGetKeypress();
            if (Tmp != 0) {
                return Tmp;
            }
        }
        
        if (SpkbdIsKeyWaiting()) {
            return SpkbdGetKeypress();
        }
        
    }
    
}

BOOLEAN
SpInputIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Tell the caller if a keypress is waiting to be fetched by
    a call to SpInputGetKeypress().

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    return (SpTermIsKeyWaiting() || SpkbdIsKeyWaiting());
}

VOID
SpInputDrain(
    VOID
    )
{
    SpTermDrain();
    SpkbdDrain();
}











//
//
// Below here are all the functions for keyboard operations...
//
//

VOID
SpkbdInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize keyboard support.  This includes

    - opening the keyboard device.

Arguments:

    None.

Return Value:

    None. Does not return if not successful.

--*/

{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    UnicodeString;

    ASSERT(!KeyboardInitialized);
    if(KeyboardInitialized) {
        return;
    }

    //
    // Open the keyboard.
    //
    RtlInitUnicodeString(&UnicodeString,DD_KEYBOARD_DEVICE_NAME_U L"0");

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &hKeyboard,
                GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OPEN,
                0,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtOpenFile of " DD_KEYBOARD_DEVICE_NAME "0 returns %lx\n",Status));
        SpFatalKbdError(SP_SCRN_KBD_OPEN_FAILED);
    }

    //
    // Initialize LEDs.
    //

    //
    // No NEC98 has NumLock and NumLock LED.
    // Num keys must be act as Numlock alternated keys.
    //
    CurrentLEDs = (!IsNEC_98 ? 0 : KEYBOARD_NUM_LOCK_ON);
    spkbdSetLEDs();

    KeyboardInitialized = TRUE;

    //
    // Do not initialize keyboard input yet because we don't have a layout.
    //
}


VOID
SpkbdTerminate(
    VOID
    )

/*++

Routine Description:

    Terminate keyboard support.  This includes

    - closing the keyboard device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    ASSERT(KeyboardInitialized);

    if(KeyboardInitialized) {

        Status = ZwClose(hKeyboard);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to close " DD_KEYBOARD_DEVICE_NAME "0 (status = %lx)\n",Status));
        }

        KeyboardInitialized = FALSE;
    }
}


VOID
SpkbdLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    )
{
    PWSTR    p,LayoutDll;
    NTSTATUS Status;

    //
    // Determine layout name.
    //
    if(p = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,1)) {
        LayoutDll = p;
    } else {
        p = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0);
        if(!p) {
            SpFatalSifError(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0,0);
        }

        LayoutDll = SpGetSectionKeyIndex(SifHandle,SIF_KEYBOARDLAYOUTFILES,p,0);
        if(!LayoutDll) {
            SpFatalSifError(SifHandle,SIF_KEYBOARDLAYOUTFILES,p,0,0);
        }
    }

    SpDisplayStatusText(SP_STAT_LOADING_KBD_LAYOUT,DEFAULT_STATUS_ATTRIBUTE,LayoutDll);

    //
    // Bugcheck if we can't load the layout dll, because we won't be able
    // to put up a screen and ask the user to hit f3, etc.
    //
    Status = SpLoadKbdLayoutDll(Directory,LayoutDll,&KeyboardTable);
    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load layout dll %ws (%lx)\n",LayoutDll,Status));
        SpFatalKbdError(SP_SCRN_KBD_LAYOUT_FAILED, LayoutDll);
    }

    //
    // Erase status text line.
    //
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,0);

    //
    // Now that we've loaded the layout, we can start accepting keyboard input.
    //
    START_KEYBOARD_READ();

    KbdLayoutInitialized = TRUE;
}


ULONG
SpkbdGetKeypress(
    VOID
    )

/*++

Routine Description:

    Wait for a keypress and return it to the caller.
    The return value will be an ASCII value (ie, not a scan code).

Arguments:

    None.

Return Value:

    ASCII value.

--*/

{
    ULONG k;

    //
    // Shouldn't be calling this until we have loaded a keyboard layout.
    //
    ASSERT(KeyboardTable);

    //
    // Wait for the user to press a key.
    //
    while(!KbdNextChar) {
        ;
    }

    k = KbdNextChar;
    KbdNextChar = 0;

    return(k);
}


BOOLEAN
SpkbdIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Tell the caller if a keypress is waiting to be fetched by
    a call to SpkbdGetKeypress().

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    //
    // Shouldn't be calling this until we have loaded a keyboard layout.
    //
    ASSERT(KeyboardTable);

    return((BOOLEAN)(KbdNextChar != 0));
}


VOID
SpkbdDrain(
    VOID
    )

/*++

Routine Description:

    Drain the keyboard buffer, throwing away any keystrokes
    in the buffer waiting to be fetched.

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    ASSERT(KeyboardTable);

    KbdNextChar = 0;
}



ULONG
spkbdScanCodeToChar(
    IN UCHAR   Prefix,
    IN USHORT  ScanCode,
    IN BOOLEAN Break
    );


VOID
spkbdApcProcedure(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG            Reserved
    )

/*++

Routine Description:

    Async Procedure Call routine for keyboard reads.  The I/O
    system will call this routine when the keyboard class driver
    wants to return some data to us.

Arguments:

Return Value:

    None.

--*/

{
    UCHAR bPrefix;
    PKEYBOARD_INPUT_DATA pkei;
    ULONG k;

    UNREFERENCED_PARAMETER(ApcContext);
    UNREFERENCED_PARAMETER(Reserved);

    for(pkei = KeyboardInputData;
        (PUCHAR)pkei < (PUCHAR)KeyboardInputData + IoStatusBlock->Information;
        pkei++)
    {
        if(pkei->Flags & KEY_E0) {
            bPrefix = 0xE0;
        } else if (pkei->Flags & KEY_E1) {
            bPrefix = 0xE1;
        } else {
            bPrefix = 0;
        }

        k = spkbdScanCodeToChar(
                bPrefix,
                pkei->MakeCode,
                (BOOLEAN)((pkei->Flags & KEY_BREAK) != 0)
                );

        if(k) {
            KbdNextChar = k;
        }
    }

    //
    // Keyboard might have been terminated.
    //
    if(KeyboardInitialized) {
        START_KEYBOARD_READ();
    }
}


WCHAR SavedDeadChar = 0;
UCHAR AltNumpadAccum = 0;

struct {
    BYTE CursorKey;
    BYTE NumberKey;
    BYTE Value;
} NumpadCursorToNumber[] = { { VK_INSERT, VK_NUMPAD0,  0 },
                             { VK_END   , VK_NUMPAD1,  1 },
                             { VK_DOWN  , VK_NUMPAD2,  2 },
                             { VK_NEXT  , VK_NUMPAD3,  3 },
                             { VK_LEFT  , VK_NUMPAD4,  4 },
                             { VK_CLEAR , VK_NUMPAD5,  5 },
                             { VK_RIGHT , VK_NUMPAD6,  6 },
                             { VK_HOME  , VK_NUMPAD7,  7 },
                             { VK_UP    , VK_NUMPAD8,  8 },
                             { VK_PRIOR , VK_NUMPAD9,  9 },
                             { VK_DELETE, VK_DECIMAL, 10 }, // no value.
                             { 0        , 0         ,  0 }
                           };

ULONG
spkbdScanCodeToChar(
    IN UCHAR   Prefix,
    IN USHORT  ScanCode,
    IN BOOLEAN Break
    )
{
    USHORT VKey = 0;
    PVSC_VK VscVk;
    PVK_TO_WCHAR_TABLE pVKT;
    PVK_TO_WCHARS1 pVK;
    USHORT Modifier;
    USHORT ModBits,ModNum;
    WCHAR deadChar;

    ScanCode &= 0x7f;

    if(Prefix == 0) {

        if(ScanCode < KeyboardTable->bMaxVSCtoVK) {

            //
            // Index directly into non-prefix scan code table.
            //
            VKey = KeyboardTable->pusVSCtoVK[ScanCode];
            if(VKey == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown scan code 0x%x\n",ScanCode));
                return (0);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown scan code 0x%x\n",ScanCode));
            return(0);
        }
    } else {
        if(Prefix == 0xe0) {
            //
            // Ignore the SHIFT keystrokes generated by the hardware
            //
            if((ScanCode == SCANCODE_LSHIFT) || (ScanCode == SCANCODE_RSHIFT)) {
                return(0);
            }
            VscVk = KeyboardTable->pVSCtoVK_E0;
        } else if(Prefix == 0xe1) {
            VscVk = KeyboardTable->pVSCtoVK_E1;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown keyboard scan prefix 0x%x\n",Prefix));
            return(0);
        }

        while(VscVk->Vk) {
            if(VscVk->Vsc == ScanCode) {
                VKey = VscVk->Vk;
                break;
            }
            VscVk++;
        }
        if(VKey == 0) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown keyboard scan prefix/code 0x%x/0x%x\n",Prefix,ScanCode));
            return(0);
        }
    }


    //
    // VirtualKey --> modifier bits.  This translation is also
    // mapped out in the pCharModifiers field in the keyboard layout
    // table but that seems redundant.
    //
    Modifier = 0;
    switch(VKey & 0xff) {
    case VK_LSHIFT:
    case VK_RSHIFT:
        Modifier = KBDSHIFT;
        break;
    case VK_LCONTROL:
    case VK_RCONTROL:
        Modifier = KBDCTRL;
        break;
    case VK_RMENU:
        //
        // AltGr ==> control+alt modifier.
        //
        if(KeyboardTable->fLocaleFlags & KLLF_ALTGR) {
            Modifier = KBDCTRL;
        }
        // fall through
    case VK_LMENU:
        Modifier |= KBDALT;
        break;
    }

    if(Break) {
        //
        // Key is being released.
        // If it's not a modifer, ignore it.
        //
        if(!Modifier) {
            return(0);
        }
        //
        // Key being released is a modifier.
        //
        ModifierBits &= ~Modifier;

        //
        // If it's ALT going up and we have a numpad key being entered,
        // return it.
        //
        if((Modifier & KBDALT) && AltNumpadAccum) {

            WCHAR UnicodeChar;

            RtlOemToUnicodeN(
                &UnicodeChar,
                sizeof(UnicodeChar),
                NULL,
                &AltNumpadAccum,
                1
                );

            AltNumpadAccum = 0;

            return(UnicodeChar);
        }
        return(0);
    } else {
        if(Modifier) {
            //
            // Key is being pressed and is a modifier.
            //
            ModifierBits |= Modifier;

            //
            // If ALT is going down, reset alt+numpad value.
            //
            if(Modifier & KBDALT) {
                AltNumpadAccum = 0;
            }
            return(0);
        }
    }

    //
    // If we get here, we've got a non-modifier key being made (pressed).
    // If the previous key was a dead key, the user gets only
    // one try to get a valid second half.
    //
    deadChar = SavedDeadChar;
    SavedDeadChar = 0;


    //
    // Special processing if the key is a numeric keypad key.
    //
    if(VKey & KBDNUMPAD) {

        int i;

        for(i=0; NumpadCursorToNumber[i].CursorKey; i++) {
            if(NumpadCursorToNumber[i].CursorKey == (BYTE)VKey) {

                //
                // Key is a numeric keypad key.  If ALT (and only alt) is down,
                // then we have an alt+numpad code being entered.
                //
                if(((ModifierBits & ~KBDALT) == 0) && (NumpadCursorToNumber[i].Value < 10)) {

                    AltNumpadAccum = (AltNumpadAccum * 10) + NumpadCursorToNumber[i].Value;
                }

                //
                // If numlock is on, translate the key from cursor movement
                // to a number key.
                //
                if(CurrentLEDs & KEYBOARD_NUM_LOCK_ON) {
                    VKey = NumpadCursorToNumber[i].NumberKey;
                }
                break;
            }
        }
    }

    //
    // We need to filter out keystrokes that we know are not part of any
    // character set here.
    //
    if((!deadChar)) {
        switch(VKey & 0xff) {
        case VK_CAPITAL:
            if(CurrentLEDs & KEYBOARD_CAPS_LOCK_ON) {
                CurrentLEDs &= ~KEYBOARD_CAPS_LOCK_ON;
            } else {
                CurrentLEDs |= KEYBOARD_CAPS_LOCK_ON;
            }
            spkbdSetLEDs();
            return(0);
        case VK_NUMLOCK:
            if(CurrentLEDs & KEYBOARD_NUM_LOCK_ON) {
                CurrentLEDs &= ~KEYBOARD_NUM_LOCK_ON;
            } else {
                CurrentLEDs |= KEYBOARD_NUM_LOCK_ON;
            }
            spkbdSetLEDs();
            return(0);
        case VK_PRIOR:
            return(KEY_PAGEUP);
        case VK_NEXT:
            return(KEY_PAGEDOWN);
        case VK_UP:
            return(KEY_UP);
        case VK_DOWN:
            return(KEY_DOWN);
        case VK_LEFT:
            return(KEY_LEFT);
        case VK_RIGHT:
            return(KEY_RIGHT);
        case VK_HOME:
            return(KEY_HOME);
        case VK_END:
            return(KEY_END);
        case VK_INSERT:
            return(KEY_INSERT);
        case VK_DELETE:
            return(KEY_DELETE);
        case VK_F1:
            return(KEY_F1);
        case VK_F2:
            return(KEY_F2);
        case VK_F3:
            return(KEY_F3);
        case VK_F4:
            return(KEY_F4);
        case VK_F5:
            return(KEY_F5);
        case VK_F6:
            return(KEY_F6);
        case VK_F7:
            return(KEY_F7);
        case VK_F8:
            return(KEY_F8);
        case VK_F9:
            return(KEY_F9);
        case VK_F10:
            return(KEY_F10);
        case VK_F11:
            return(KEY_F11);
        case VK_F12:
            return(KEY_F12);
        }
    }

    //
    // We think the character is probably a 'real' character.
    // Scan through all the shift-state tables until a matching Virtual
    // Key is found.
    //
    for(pVKT = KeyboardTable->pVkToWcharTable; pVKT->pVkToWchars; pVKT++) {
        pVK = pVKT->pVkToWchars;
        while(pVK->VirtualKey) {
            if(pVK->VirtualKey == (BYTE)VKey) {
                goto VK_Found;
            }
            pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
        }
    }

    //
    // Key is not valid with requested modifiers.
    //
    return(0);

    VK_Found:

    ModBits = ModifierBits;

    //
    // If CapsLock affects this key and it is on: toggle SHIFT state
    // only if no other state is on.
    // (CapsLock doesn't affect SHIFT state if Ctrl or Alt are down).
    //
    if((pVK->Attributes & CAPLOK) && ((ModBits & ~KBDSHIFT) == 0)
    && (CurrentLEDs & KEYBOARD_CAPS_LOCK_ON))
    {
        ModBits ^= KBDSHIFT;
    }

    //
    // Get the modification number.
    //
    if(ModBits > KeyboardTable->pCharModifiers->wMaxModBits) {
        return(0);  // invalid keystroke
    }

    ModNum = KeyboardTable->pCharModifiers->ModNumber[ModBits];
    if(ModNum == SHFT_INVALID) {
        return(0);  // invalid keystroke
    }

    if(ModNum >= pVKT->nModifications) {

        //
        // Key is not valid with current modifiers.
        // Could still be a control char that we can convert directly.
        //
        if((ModBits == KBDCTRL) || (ModBits == (KBDCTRL | KBDSHIFT))) {
            if(((UCHAR)VKey >= 'A') && ((UCHAR)VKey <= 'Z')) {
                return((ULONG)VKey & 0x1f);
            }
        }
        return(0);  // invalid keystroke
    }

    if(pVK->wch[ModNum] == WCH_NONE) {
        return(0);
    }

    if((pVK->wch[ModNum] == WCH_DEAD)) {

        if(!deadChar) {
            //
            // Remember the current dead character, whose value follows
            // the current entry in the modifier mapping table.
            //
            SavedDeadChar = ((PVK_TO_WCHARS1)((PUCHAR)pVK + pVKT->cbSize))->wch[ModNum];
        }
        return(0);
    }

    //
    // The keyboard layout table contains some dead key mappings.
    // If previous key was a dead key, attempt to compose it with the
    // current character by scanning the keyboard layout table for a match.
    //
    if(deadChar) {

        ULONG    chr;
        PDEADKEY DeadKeyEntry;

        chr = MAKELONG(pVK->wch[ModNum],deadChar);

        if(DeadKeyEntry = KeyboardTable->pDeadKey) {

            while(DeadKeyEntry->dwBoth) {

                if(DeadKeyEntry->dwBoth == chr) {
                    //
                    // Got a match.  Return the composed character.
                    //
                    return((ULONG)DeadKeyEntry->wchComposed);
                }

                DeadKeyEntry++;
            }
        }

        //
        // If we get here, then the previous key was a dead char,
        // but the current key could not be composed with it.
        // So return nothing.  Note that the dead key has been forgotten.
        //
        return(0);
    }


    return((ULONG)pVK->wch[ModNum]);
}



VOID
spkbdSetLEDs(
    VOID
    )
{
    asyncKbdParams.UnitId = 0;
    asyncKbdParams.LedFlags = CurrentLEDs;

    ZwDeviceIoControlFile(
        hKeyboard,
        NULL,
        NULL,
        NULL,
        &asyncIoStatusBlock,
        IOCTL_KEYBOARD_SET_INDICATORS,
        &asyncKbdParams,
        sizeof(asyncKbdParams),
        NULL,
        0
    );
}

VOID
SpSelectAndLoadLayoutDll(
  IN PWSTR Directory,
  IN PVOID SifHandle,
  IN BOOLEAN ShowStatus
  )
/*++

Routine Description:

  Allows the user to select a keyboard layout DLL and loads it.
  

Arguments:

  Directory - The setup startup directory
  SifHandle - Handle to txtsetup.sif
  ShowStatus - Whether status should be displayed or not

Return Value:

  None

--*/  
{
  ULONG SelectedLayout;
  ULONG DefLayout = -1;
  PWSTR TempPtr = 0;
  PWSTR LayoutDll = 0;
  NTSTATUS  Status;

  //
  // Get the default layout (index)
  //
  TempPtr = SpGetSectionKeyIndex(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0);

  if(!TempPtr) {
    SpFatalSifError(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0, 0);
  }

  DefLayout = SpGetKeyIndex(SifHandle, SIF_KEYBOARDLAYOUTDESC, TempPtr);

  if(DefLayout == -1) {
    SpFatalSifError(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0, 0);
  }

  SelectedLayout = -1;  

  //
  // Let the user select the layout which he wants
  //    
  if (SpSelectSectionItem(SifHandle, SIF_KEYBOARDLAYOUTDESC, 
                     SP_SELECT_KBDLAYOUT, DefLayout, &SelectedLayout)) {
    //
    // Load the layout if its not already loaded
    //
    if (DefLayout != SelectedLayout) {
      //
      // get the key
      //
      TempPtr = SpGetKeyName(SifHandle, SIF_KEYBOARDLAYOUTDESC, SelectedLayout);

      if (TempPtr) {
        //
        // get the KDB layout dll name
        //
        LayoutDll = SpGetSectionKeyIndex(SifHandle, SIF_KEYBOARDLAYOUTFILES,
                          TempPtr, 0);

        if (LayoutDll) {
          if (ShowStatus) {
            SpDisplayStatusText(SP_STAT_LOADING_KBD_LAYOUT,
                DEFAULT_STATUS_ATTRIBUTE, LayoutDll);
          }                
              
          //
          // Load the new KDB layout dll
          //
          Status = SpLoadKbdLayoutDll(Directory, LayoutDll, &KeyboardTable);
        }          
        else
          Status = STATUS_INVALID_PARAMETER;

        if (!NT_SUCCESS(Status)) {
          CLEAR_ENTIRE_SCREEN();
          SpFatalKbdError(SP_SCRN_KBD_LAYOUT_FAILED, LayoutDll);          
        } else {
          if (ShowStatus) {
            //
            // Erase status text line.
            //
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 0);
          }

          //
          // Now that we've loaded the layout, 
          // we can start accepting keyboard input.
          //
          START_KEYBOARD_READ();
          KbdLayoutInitialized = TRUE;          
        }
      } else {
        CLEAR_ENTIRE_SCREEN();
        SpFatalSifError(SifHandle, SIF_KEYBOARDLAYOUTDESC, 0, 0, 0);
      }
    }
  }                                              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spgauge.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spgauge.h

Abstract:

    Public header file for gas gauge functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPGAUGE_DEFN_
#define _SPGAUGE_DEFN_


#define GF_PERCENTAGE           0
#define GF_ITEMS_REMAINING      1
#define GF_ITEMS_USED           2

PVOID
SpCreateAndDisplayGauge(
    IN ULONG  ItemCount,
    IN ULONG  GaugeWidth,       OPTIONAL
    IN ULONG  Y,
    IN PWCHAR Caption,
    IN PWCHAR ProgressFmtStr,   OPTIONAL
    IN ULONG  Flags,            OPTIONAL
    IN UCHAR  Attribute         OPTIONAL
    );

VOID
SpDestroyGauge(
    IN PVOID GaugeHandle
    );

VOID
SpDrawGauge(
    IN PVOID GaugeHandle
    );

VOID
SpTickGauge(
    IN PVOID GaugeHandle
    );

VOID
SpFillGauge(
    IN PVOID GaugeHandle,
    IN ULONG Amount
    );


//
// Character attribute for thermometer portion of the gas gauge.
// Because we're using spaces for the gauge, the foreground attribute
// is irrelevent.
//
// Need intense attribute or the thermometer comes out orange on some machines.
//
#define GAUGE_ATTRIBUTE (ATT_BG_YELLOW | ATT_BG_INTENSE )


#define GAUGE_HEIGHT 7

#endif // ndef _SPGAUGE_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spkbd.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spkbd.h

Abstract:

    Public header file for text setup input support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:
    + Added defines for ASCI_D
      (Michael Peterson, Seagate Software, 29 April, 1997)

--*/


#ifndef _SPINPUT_DEFN_
#define _SPINPUT_DEFN_



VOID
SpInputInitialize(
    VOID
    );

VOID
SpInputTerminate(
    VOID
    );

VOID
SpInputLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    );

ULONG
SpInputGetKeypress(
    VOID
    );

BOOLEAN
SpInputIsKeyWaiting(
    VOID
    );

VOID
SpInputDrain(
    VOID
    );

VOID
SpSelectAndLoadLayoutDll(
  IN PWSTR Directory,
  IN PVOID SifHandle,
  IN BOOLEAN ShowStatus
  );

#define ASCI_ETX    3   //  control-C
#define ASCI_BS     8
#define ASCI_NL     10
#define ASCI_C      67
#define ASCI_LOWER_C 99
#define ASCI_CR     13
#define ASCI_ESC    27

//
// Character codes are passed around as ULONGs within setup.
// The low word is a Unicode character value; the high word
// is used for various other keypresses.
//
#define KEY_PAGEUP          0x00010000
#define KEY_PAGEDOWN        0x00020000
#define KEY_UP              0x00030000
#define KEY_DOWN            0x00040000
#define KEY_LEFT            0x00050000
#define KEY_RIGHT           0x00060000
#define KEY_HOME            0x00070000
#define KEY_END             0x00080000
#define KEY_INSERT          0x00090000
#define KEY_DELETE          0x000a0000
#define KEY_F1              0x00110000
#define KEY_F2              0x00120000
#define KEY_F3              0x00130000
#define KEY_F4              0x00140000
#define KEY_F5              0x00150000
#define KEY_F6              0x00160000
#define KEY_F7              0x00170000
#define KEY_F8              0x00180000
#define KEY_F9              0x00190000
#define KEY_F10             0x001a0000
#define KEY_F11             0x001b0000
#define KEY_F12             0x001c0000

#define KEY_NON_CHARACTER   0xffff0000

#endif // ndef _SPINPUT_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sphw.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphw.h

Abstract:

    Header file for hardware detection and
    confirmation routines for text setup.

Author:

    Ted Miller (tedm) 1-October-1993

Revision History:

--*/


#ifndef _SPHW_DEFN_
#define _SPHW_DEFN_

VOID
SpConfirmScsiMiniports(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpConfirmHardware(
    IN PVOID SifHandle
    );

VOID
SpInitializePreinstallList(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        OemPreinstallSourcePath
    );


//
// In splddrv.c
//
VOID
SpLoadScsiClassDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

VOID
SpLoadCdRomDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

VOID
SpLoadDiskDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

BOOLEAN
SpInstallingMp(
    VOID
    );

BOOLEAN
SpSelectSectionItem(
    IN    PVOID   SifHandle,
    IN    PWSTR   SectionName,
    IN    ULONG   SelectScreenId,
    IN    ULONG   DefaultSelection OPTIONAL,
    OUT   PULONG  SelectedOption
    );

//
// enum to represent flopy disk drive types.
//
typedef enum {    
    FloppyTypeNone,
    FloppyType525Low,
    FloppyType525High,
    FloppyType35Low,
    FloppyType35High,
    FloppyType35High120MB
} FloppyDriveType;

FloppyDriveType
SpGetFloppyDriveType(
    IN ULONG FloppyOrdinal
    );

#define IS_525_DRIVE(x)  (((x)==FloppyType525Low) || ((x)==FloppyType525High))
#define IS_35_DRIVE(x)   (((x)==FloppyType35Low) || ((x)==FloppyType35High))


typedef struct _HARDWARE_COMPONENT_REGISTRY {

    struct _HARDWARE_COMPONENT_REGISTRY *Next;

    //
    // The name of the key.  The empty string means the key in the
    // services key itself.
    //

    PWSTR KeyName;

    //
    // The name of the value within the registry key
    //

    PWSTR ValueName;

    //
    // The data type for the value (ie, REG_DWORD, etc)
    //

    ULONG ValueType;

    //
    // The buffer containing the data to be placed into the value
    //

    PVOID Buffer;

    //
    // The size of the buffer in bytes
    //

    ULONG BufferSize;


} HARDWARE_COMPONENT_REGISTRY, *PHARDWARE_COMPONENT_REGISTRY;


//
// One of these will be created for each file to be copied for a
// third party device.
//
typedef struct _HARDWARE_COMPONENT_FILE {

    struct _HARDWARE_COMPONENT_FILE *Next;

    //
    // Filename of the file.
    //

    PWSTR Filename;

    //
    // type of the file (hal, port, class, etc).
    //

    HwFileType FileType;

    //
    // Part of name of the section in txtsetup.oem [Config.<ConfigName>]
    // that contains registry options.  If this is NULL, then no registry
    // information is associated with this file.
    //
    PWSTR ConfigName;

    //
    // Registry values for the node in the services list in the registry.
    //

    PHARDWARE_COMPONENT_REGISTRY RegistryValueList;

    //
    // These two fields are used when prompting for the diskette
    // containing the third-party-supplied driver's files.
    //

    PWSTR DiskDescription;
    PWSTR DiskTagFile;

    //
    // Directory where files are to be found on the disk.
    //
    PWSTR Directory;

    //
    // Arc name of the device from which the file was copied
    //
    PWSTR ArcDeviceName;

} HARDWARE_COMPONENT_FILE, *PHARDWARE_COMPONENT_FILE;



//
// structure for storing information about a driver we have located and
// will install.
//

typedef struct _HARDWARE_COMPONENT {

    struct _HARDWARE_COMPONENT *Next;

    //
    // String used as a key into the relevent section (like [Display],
    // [Mouse], etc).
    //

    PWSTR IdString;

    //
    // String that describes the hardware.
    //

    PWSTR Description;

    //
    // If this is TRUE, then there is an OEM option selected for this
    // hardware.
    //

    BOOLEAN ThirdPartyOptionSelected;

    //
    // Bits to be set if a third party option is selected, indicating
    // which type of files are specified in the oem inf file.
    //

    ULONG FileTypeBits;

    //
    // Files for a third party option.
    //

    PHARDWARE_COMPONENT_FILE Files;

    //
    // For some components this is the name of a device driver file.
    //
    PWSTR BaseDllName;

    //
    // If this is TRUE, then the driver for this device was migrated from an
    // existing NT system.
    //

    BOOLEAN MigratedDriver;

} HARDWARE_COMPONENT, *PHARDWARE_COMPONENT;


PHARDWARE_COMPONENT
SpSetupldrHwToHwDevice(
    IN PDETECTED_DEVICE SetupldrHw
    );

extern PHARDWARE_COMPONENT HardwareComponents[HwComponentMax];
extern PHARDWARE_COMPONENT ScsiHardware;
extern PHARDWARE_COMPONENT BootBusExtenders;
extern PHARDWARE_COMPONENT BusExtenders;
extern PHARDWARE_COMPONENT InputDevicesSupport;
extern PHARDWARE_COMPONENT PreinstallHardwareComponents[HwComponentMax];
extern PHARDWARE_COMPONENT PreinstallScsiHardware;
extern PHARDWARE_COMPONENT UnsupportedScsiHardwareToDisable;

#ifdef _ALPHA_

extern PWSTR OemPalFilename, OemPalDiskDescription;

#endif _ALPHA_

VOID
SpFreeHwComponent(
    IN OUT PHARDWARE_COMPONENT *HwComp,
    IN     BOOLEAN              FreeAllInList
    );


//
// These are the names of the components.  This is array is not localized
// because it is used only to index hardware-related sections in the
// setup information file.
//
extern PWSTR NonlocalizedComponentNames[HwComponentMax];

extern PWSTR ScsiSectionName;

extern ULONG LoadedScsiMiniportCount;


//
// structure for storing the PNP database.
//

typedef struct _SETUP_PNP_HARDWARE_ID {

    struct _SETUP_PNP_HARDWARE_ID *Next;

    //
    // String that represents the hardware id of a PNP device.
    //

    PWSTR Id;

    //
    // Driver for the device
    //

    PWSTR DriverName;

    //
    // Class GUID for this device, if any
    //

    PWSTR ClassGuid;


} SETUP_PNP_HARDWARE_ID, *PSETUP_PNP_HARDWARE_ID;


PSETUP_PNP_HARDWARE_ID
SpSetupldrPnpDatabaseToSetupPnpDatabase(
    IN PPNP_HARDWARE_ID HardwareIdDatabase
    );

//
// OEM Virtual Source Device abstraction
//
typedef struct _VIRTUAL_OEM_SOURCE_DEVICE {
    //
    // Next device
    //
    struct _VIRTUAL_OEM_SOURCE_DEVICE *Next;

    //
    // Device Id (for ARC name mapping)
    //
    ULONG   DeviceId;

    //
    // Arc device name
    //
    PWSTR   ArcDeviceName;

    //
    // Memory address where the device image is copied
    // by the loader
    //
    PVOID   ImageBase;

    //
    // Image size
    //
    ULONGLONG   ImageSize;
    
} VIRTUAL_OEM_SOURCE_DEVICE, *PVIRTUAL_OEM_SOURCE_DEVICE;

#define MS_RAMDISK_DRIVER_PARAM    L"Disk"

//
// Virtual OEM source devices (accessible through RAM driver)
//
extern PVIRTUAL_OEM_SOURCE_DEVICE VirtualOemSourceDevices;

NTSTATUS
SpInitVirtualOemDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT PVIRTUAL_OEM_SOURCE_DEVICE *SourceDevices
    );

#endif // ndef _SPHW_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\splddrv.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sploaddrv.c

Abstract:

    Routines to load sets of device drivers for use during text setup.

Author:

    Ted Miller (tedm) 13-November-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

//
// Define type of routine used by the device driver set loader.
// Before each driver is loaded, this routine is called with
// a flag indicating whether the machine is an MCA machine and
// the shortname of the driver about to be loaded.  If this routine
// returns FALSE, the driver is not loaded.  If it returns TRUE,
// the driver is loaded.
//
typedef
BOOLEAN
(*PDRIVER_VERIFY_LOAD_ROUTINE) (
    IN PVOID   SifHandle,
    IN BOOLEAN IsMcaMachine,
    IN PWSTR   DriverShortname
    );



BOOLEAN
pSpVerifyLoadDiskDrivers(
    IN PVOID   SifHandle,
    IN BOOLEAN IsMcaMachine,
    IN PWSTR   DriverShortname
    )
{
    UNREFERENCED_PARAMETER(SifHandle);

    //
    // Don't load fat if setupldr loaded floppy drivers.
    //
    if(!_wcsicmp(DriverShortname,L"Fat") && SetupParameters.LoadedFloppyDrivers) {
        return(FALSE);
    }

    //
    // On an MCA machine, don't load atdisk.
    // On a non-MCA machine, don't load abiosdsk.
    //
    if(( IsMcaMachine && !_wcsicmp(DriverShortname,L"atdisk"))
    || (!IsMcaMachine && !_wcsicmp(DriverShortname,L"abiosdsk")))
    {
        return(FALSE);
    }

    //
    // If we get this far, the driver should be loaded.
    //
    return(TRUE);
}


VOID
SpLoadDriverSet(
    IN PVOID                        SifHandle,
    IN PWSTR                        SifSectionName,
    IN PWSTR                        SourceDevicePath,
    IN PWSTR                        DirectoryOnSourceDevice,
    IN PDRIVER_VERIFY_LOAD_ROUTINE  VerifyLoad                  OPTIONAL
    )

/*++

Routine Description:

    Load a set of device drivers listed in a section in the setup
    information file.  The section is expected to be in the following form:

        [SectionName.Load]
        DriverShortname = DriverFilename
        DriverShortname = DriverFilename
        DriverShortname = DriverFilename
        etc.

        [SectionName]
        DriverShortname = Description
        DriverShortname = Description
        DriverShortname = Description
        etc.

    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

    Before loading each driver, a callback routine is called to verify
    that the driver should actually be loaded.  This allows the caller
    to gain a fine degree of control over which drivers are loaded.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSectionName - supplies name of section in setup information file
        listing drivers to be laoded.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        from which the drivers are to be loaded.

    VerifyLoad - if specified, supplies the address of a routine to be
        called before each driver is loaded.  The routine takes a flag
        indicating whether the machine is an MCA machine, and the driver
        shortname.  If the routine returns false, the driver is not loaded.
        If this parameter is not specified, all drivers in the section
        will be loaded.

Return Value:

    None.

--*/

{
    BOOLEAN IsMcaMachine;
    ULONG d,DriverLoadCount;
    PWSTR DiskDesignator,PreviousDiskDesignator;
    PWSTR DriverShortname,DriverFilename,DriverDescription;
    PWSTR LoadSectionName;
    NTSTATUS Status;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Form the .load section name.
    //
    LoadSectionName = SpMemAlloc((wcslen(SifSectionName)*sizeof(WCHAR))+sizeof(L".Load"));
    wcscpy(LoadSectionName,SifSectionName);
    wcscat(LoadSectionName,L".Load");

    IsMcaMachine = FALSE;

    //
    // Set up some initial state.
    //
    PreviousDiskDesignator = L"";

    //
    // Determine the number of drivers to be loaded.
    //
    DriverLoadCount = SpCountLinesInSection(SifHandle,LoadSectionName);
    for(d=0; d<DriverLoadCount; d++) {

        PWSTR p;

        //
        // Get the driver shortname.
        //
        DriverShortname = SpGetKeyName(SifHandle,LoadSectionName,d);
        if(!DriverShortname) {
            SpFatalSifError(SifHandle,LoadSectionName,NULL,d,(ULONG)(-1));
        }

        //
        // Determine whether we are really supposed to load this driver.
        //
        if((p = SpGetSectionLineIndex(SifHandle,LoadSectionName,d,2)) && !_wcsicmp(p,L"noload")) {
            continue;
        }

        if(VerifyLoad && !VerifyLoad(SifHandle,IsMcaMachine,DriverShortname)) {
            continue;
        }

        //
        // Get a human-readable description for this driver.
        //
        DriverDescription = SpGetSectionLineIndex(SifHandle,SifSectionName,d,0);
        if(!DriverDescription) {
            SpFatalSifError(SifHandle,SifSectionName,NULL,d,0);
        }

        //
        // Get the driver filename.
        //
        DriverFilename = SpGetSectionLineIndex(SifHandle,LoadSectionName,d,0);
        if(!DriverFilename) {
            SpFatalSifError(SifHandle,LoadSectionName,NULL,d,0);
        }

        //
        // Determine the disk on which this driver resides.
        //
        DiskDesignator = SpLookUpValueForFile(
                            SifHandle,
                            DriverFilename,
                            INDEX_WHICHBOOTMEDIA,
                            TRUE
                            );

        //
        // Prompt for the disk containing the driver.
        //
        retryload:
        if(_wcsicmp(DiskDesignator,PreviousDiskDesignator)) {

            SpPromptForSetupMedia(
                SifHandle,
                DiskDesignator,
                SourceDevicePath
                );

            PreviousDiskDesignator = DiskDesignator;

            CLEAR_CLIENT_SCREEN();
            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);
        }

        //
        // Attempt to load the driver.
        //
        Status = SpLoadDeviceDriver(
                    DriverDescription,
                    SourceDevicePath,
                    DirectoryOnSourceDevice,
                    DriverFilename
                    );

        if(Status == STATUS_NO_MEDIA_IN_DEVICE) {
            PreviousDiskDesignator = L"";
            goto retryload;
        }
    }

    SpMemFree(LoadSectionName);
}


VOID
SpLoadScsiClassDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load scsi class drivers if setupldr has not already loaded them
    and there are any miniport drivers loaded.

    The drivers to be loaded are listed in [ScsiClass].
    The section is expected to be in the following form:

        [ScsiClass]
        cdrom  = "SCSI CD-ROM"     ,scsicdrm.sys
        floppy = "SCSI Floppy Disk",scsiflop.sys
        disk   = "SCSI Disk"       ,scsidisk.sys

    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded scsi drivers, nothing to do.
    // If there are no miniport drivers loaded, nothing to do.
    //
    if(!SetupParameters.LoadedScsi && LoadedScsiMiniportCount) {

        SpLoadDriverSet(
            SifHandle,
            SIF_SCSICLASSDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            NULL
            );
    }
}


VOID
SpLoadDiskDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load (non-scsi) disk class drivers and disk filesystems
    if setupldr has not already loaded them.

    The drivers to be loaded are listed in [DiskDrivers] and [FileSystems].
    The section is expected to be in the following form:

        [DiskDrivers]
        atdisk   = "ESDI/IDE Hard DIsk",atdisk.sys
        abiosdsk = "Micro Channel Hard Disk",abiosdsk.sys

        [FileSystems]
        fat      = "FAT File System",fastfat.sys
        ntfs     = "Windows NT File System (NTFS)",ntfs.sys


    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

    On MCA machines, atdisk will not be loaded.
    On non-MCA machines, abiosdsk will not be loaded.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded disk drivers, nothing to do.
    //
    if(!SetupParameters.LoadedDiskDrivers) {

        SpLoadDriverSet(
            SifHandle,
            SIF_DISKDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            pSpVerifyLoadDiskDrivers
            );
    }
    //
    // If setupldr loaded file systems, nothing to do.
    //
    if(!SetupParameters.LoadedFileSystems) {

        SpLoadDriverSet(
            SifHandle,
            SIF_FILESYSTEMS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            pSpVerifyLoadDiskDrivers
            );
    }

}

VOID
SpLoadCdRomDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load the cd-rom filesystem if setupldr has not already loaded it.

    The drivers to be loaded are listed in [CdRomDrivers].
    The section is expected to be in the following form:

        [CdRomDrivers]
        cdfs = "CD-ROM File System",cdfs.sys


    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded cd-rom drivers, nothing to do.
    //
    if(!SetupParameters.LoadedCdRomDrivers) {

        SpLoadDriverSet(
            SifHandle,
            SIF_CDROMDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            NULL
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sphw.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphw.c

Abstract:

    Hardware detection and confirmation routines for text setup.

Author:

    Ted Miller (tedm) 1-October-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

extern BOOLEAN HandleLineContinueChars;

VOID
SpHardwareConfirmInteract(
    IN PVOID SifHandle
    );

VOID
SpConfirmScsiInteract(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

BOOLEAN
SpSelectHwItem(
    IN     PVOID               SifHandle,
    IN     PWSTR               NonlocalizedComponentName,
    IN     PWSTR               OemSectionName,            OPTIONAL
    IN     ULONG               SelectHwScreenId,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp
    );

VOID
SpScanHardwareDescription(
    IN PWSTR DesiredKeyName
    );

VOID
SpDetectComputer(
    IN PVOID SifHandle
    );

VOID
SpDetectVideo(
    IN PVOID SifHandle
    );

VOID
SpDetectKeyboard(
    IN PVOID SifHandle
    );

VOID
SpDetectMouse(
    IN PVOID SifHandle
    );

VOID
SpDetectLayout(
    IN PVOID SifHandle
    );

VOID
SpDetectScsi(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpDetermineComponent(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               HardwareDescriptionKeyName,
    IN  PWSTR               FallbackIdentifier,
    IN  PWSTR               ComponentName
    );

BOOLEAN
SpOemDiskette(
    IN     PVOID               SifHandle,
    IN     PWSTR               SectionName,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp,
    IN     ULONG               ErrorId
    );

BOOLEAN
SpOemInfSelection(
    IN  PVOID               TxtsetupOem,
    IN  PWSTR               NonlocalizedComponentName,
    IN  PWSTR               SelectedId,
    IN  PWSTR               ItemDescription,
    IN  ULONG               AllowedFileTypes,
    IN  ULONG               RequiredFileTypes,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  ULONG               ErrorId
    );

VOID
SpFreeLocatedIdStrings(
    VOID
    );

VOID
SpScanHardwareDescriptionWorker(
    IN HANDLE KeyHandle,
    IN PWSTR  KeyName,
    IN PWSTR  DesiredKeyName
    );

BOOLEAN
SpScanMapSection(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               ComponentName,
    IN  PWSTR               IdString
    );

VOID
SpInitHwComponent(
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               IdString,
    IN  PWSTR               Description,
    IN  BOOLEAN             ThirdPartyOption,
    IN  ULONG               FileTypeBits,
    IN  PWSTR               BaseDllName,
    IN  BOOLEAN             MigratedDriver
    );

VOID
SpInitHwComponentFile(
    OUT PHARDWARE_COMPONENT_FILE HwCompFile,
    IN  PWSTR                    Filename,
    IN  HwFileType               FileType,
    IN  PWSTR                    ConfigName,
    IN  PWSTR                    DiskDescription,
    IN  PWSTR                    DiskTagFile,
    IN  PWSTR                    Directory,
    IN  PWSTR                    ArcDeviceName
    );

VOID
SpInitHwComponentRegVal(
    OUT PHARDWARE_COMPONENT_REGISTRY HwCompReg,
    IN  PWSTR                        KeyName,
    IN  PWSTR                        ValueName,
    IN  ULONG                        ValueType,
    IN  PVOID                        Buffer,
    IN  ULONG                        BufferSize
    );

VOID
SpFreeHwComponentFile(
    IN OUT PHARDWARE_COMPONENT_FILE *HwCompFile
    );

VOID
SpFreeHwComponentReg(
    IN OUT PHARDWARE_COMPONENT_REGISTRY *HwCompReg
    );

PHARDWARE_COMPONENT_REGISTRY
SpInterpretOemRegistryData(
    IN PVOID          SifHandle,
    IN PWSTR          SectionName,
    IN ULONG          Line,
    IN ULONG          ValueType,
    IN PWSTR          KeyName,
    IN PWSTR          ValueName
    );

VOID
SpGetDriverValuesForLoad(
    IN  PVOID  SifHandle,
    IN  PWSTR  ComponentSectionName,
    IN  PWSTR  ComponentLoadSectionName,
    IN  PWSTR  Shortname,
    OUT PWSTR *Filename,
    OUT PWSTR *MediaDesignator,
    OUT PWSTR *Description OPTIONAL
    );


//
// These two globals track a table that gets built as the
// hardware description in the registry is scanned for a
// particular hardware component.  See SpScanHardwareDescription().
//
PWSTR *IdStringArray;
ULONG  IdStringCount;

//
// Array of ulongs that are the message ids for screens that
// prompt the user to select a type of a component from the
// list below.
//
ULONG SelectHwScreens[HwComponentMax] = { SP_SCRN_SELECT_COMPUTER,
                                          SP_SCRN_SELECT_DISPLAY,
                                          SP_SCRN_SELECT_KEYBOARD,
                                          SP_SCRN_SELECT_LAYOUT,
                                          SP_SCRN_SELECT_MOUSE
                                        };

//
// Array of ulongs that are the message ids for screens that
// prompt the user to select an option from an oem disk for
// a component from the list below.
//
ULONG SelectOemHwScreens[HwComponentMax] = { SP_SCRN_SELECT_OEM_COMPUTER,
                                             SP_SCRN_SELECT_OEM_DISPLAY,
                                             SP_SCRN_SELECT_OEM_KEYBOARD,
                                             SP_SCRN_SELECT_OEM_LAYOUT,
                                             SP_SCRN_SELECT_OEM_MOUSE
                                           };

ULONG UnknownHwScreens[HwComponentMax] = { SP_SCRN_UNKNOWN_COMPUTER,
                                           SP_SCRN_UNKNOWN_DISPLAY,
                                           SP_SCRN_UNKNOWN_KEYBOARD,
                                           SP_SCRN_UNKNOWN_LAYOUT,
                                           SP_SCRN_UNKNOWN_MOUSE
                                         };

//
// These are the names of the components.  This is array is not localized
// because it is used only to index hardware-related sections in the
// setup information file.
//
PWSTR NonlocalizedComponentNames[HwComponentMax] = { L"Computer",
                                                     L"Display",
                                                     L"Keyboard",
                                                     L"Keyboard Layout",
                                                     L"Mouse"
                                                   };

//
// The following is the name of the SCSI section in txtsetup.sif.
// On x86 machines, this is one of SCSI.ISA, SCSI.EISA, or SCSI.MCA.
// On other machines, this is just SCSI.
//
PWSTR ScsiSectionName;
PWSTR ScsiLoadSectionName;

PWSTR FileTypeNames[HwFileMax+1] = { L"Driver",
                                     L"Port",
                                     L"Class",
                                     L"Inf",
                                     L"Dll",
                                     L"Detect",
                                     L"Hal",
                                     L"Catalog",
                                     NULL
                                   };

PWSTR RegistryTypeNames[HwRegistryMax+1] = { L"REG_DWORD",
                                             L"REG_BINARY",
                                             L"REG_SZ",
                                             L"REG_EXPAND_SZ",
                                             L"REG_MULTI_SZ",
                                             NULL
                                           };

ULONG RegistryValueTypeMap[HwRegistryMax] = { REG_DWORD,
                                              REG_BINARY,
                                              REG_SZ,
                                              REG_EXPAND_SZ,
                                              REG_MULTI_SZ
                                              };

PHARDWARE_COMPONENT HardwareComponents[HwComponentMax] = { NULL,NULL,NULL,NULL,NULL };

PHARDWARE_COMPONENT ScsiHardware;

PHARDWARE_COMPONENT BootBusExtenders;

PHARDWARE_COMPONENT BusExtenders;

PHARDWARE_COMPONENT InputDevicesSupport;

PHARDWARE_COMPONENT PreinstallHardwareComponents[HwComponentMax] = { NULL,NULL,NULL,NULL,NULL };

PHARDWARE_COMPONENT PreinstallScsiHardware = NULL;

PHARDWARE_COMPONENT UnsupportedScsiHardwareToDisable = NULL;


PWSTR PreinstallSectionNames[HwComponentMax] = { WINNT_U_COMPUTERTYPE_W,
                                                 WINNT_OEMDISPLAYDRIVERS_W,
                                                 WINNT_OEMKEYBOARDDRIVERS_W,
                                                 WINNT_U_KEYBOARDLAYOUT_W,
                                                 WINNT_OEMPOINTERDRIVERS_W
                                               };

#define MAX_SCSI_MINIPORT_COUNT 5
ULONG LoadedScsiMiniportCount;


//
// This array lists the type of files allowed for each component type.
// For example, detect files are allowed for computer and driver files are
// allowed for all component types. Keep in sync with HwComponentType enum!
//

ULONG AllowedFileTypes[HwComponentMax] = {

    // Computer

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileDetect)
  | FILETYPE(HwFileHal)    | FILETYPE(HwFileCatalog),

    // Display

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileInf)
  | FILETYPE(HwFileDll)    | FILETYPE(HwFileCatalog),

    // Keyboard

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileCatalog),

    // Layout

    FILETYPE(HwFileDll)    | FILETYPE(HwFileInf),

    // Mouse

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileCatalog)

};

#define SCSI_ALLOWED_FILETYPES (FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileInf) | FILETYPE(HwFileCatalog))

//
// This array lists the type of files required for each component type.
// For example, a hal is required for computer.  Keep in sync with
// HwComponentType enum!
//

ULONG RequiredFileTypes[HwComponentMax] = {

    // Computer

    FILETYPE(HwFileHal),

    // Display

    FILETYPE(HwFileDriver) | FILETYPE(HwFileDll),

    // Keyboard

    FILETYPE(HwFileDriver),

    // Layout

    FILETYPE(HwFileDll),

    // Mouse

    FILETYPE(HwFileDriver)

};

#define SCSI_REQUIRED_FILETYPES FILETYPE(HwFileDriver)



#define MAP_SECTION_NAME_PREFIX     L"Map."
#define HARDWARE_MENU_SIZE          HwComponentMax

#define MICROSOFT_BUS_MOUSE_NAME    L"MICROSOFT BUS MOUSE"


FloppyDriveType
SpGetFloppyDriveType(
    IN ULONG FloppyOrdinal
    )

/*++

Routine Description:

    Inspect a floppy disk drive attempting to classify it as a
    5.25 or 3.5" drive, hi or low density.  For 5.25" disks,
    1.2MB drives are high density; smaller drives are low-density.
    For 3.5" drives, 1.44, 2.88, or 20.8MB is high density, smaller
    drives are low density.

    Any other drive types are unrecognized and result in
    FloppyTypeNone being returned.

Arguments:

    FloppyOrdinal - supplies ordinal number of floppy (0=A:, etc).

Return Value:

    Value from the FloppyDriveType enum indicating which type the drive is.
    FloppyTypeNone if we couldn't determine this information.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    WCHAR OpenPath[64];
    DISK_GEOMETRY DiskGeom[25];
    ULONG_PTR MediaTypeCount;
    static FloppyDriveType CachedTypes[2] = { -1,-1 };
    FloppyDriveType FloppyType;

    //
    // If we have already determined this for this drive,
    // return the cached info.
    //
    if((FloppyOrdinal < ELEMENT_COUNT(CachedTypes))
    && (CachedTypes[FloppyOrdinal] != -1))
    {
        return(CachedTypes[FloppyOrdinal]);
    }

    //
    // Assume the floppy doesn't exist or we can't tell what type it is.
    //
    FloppyType = FloppyTypeNone;

    swprintf(OpenPath,L"\\device\\floppy%u",FloppyOrdinal);

    INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);

    Status = ZwCreateFile(
                &Handle,
                SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,                           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_VALID_FLAGS,         // full sharing
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                           // no EAs
                0
                );

    if(NT_SUCCESS(Status)) {

        //
        // Get supported media types.
        //
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_MEDIA_TYPES,
                    NULL,
                    0,
                    DiskGeom,
                    sizeof(DiskGeom)
                    );

        if(NT_SUCCESS(Status)) {

            ASSERT((IoStatusBlock.Information % sizeof(DISK_GEOMETRY)) == 0);
            if(MediaTypeCount = IoStatusBlock.Information / sizeof(DISK_GEOMETRY)) {

                //
                // Highest capacity media type is last entry.
                //
                switch(DiskGeom[MediaTypeCount-1].MediaType) {

                case F5_1Pt23_1024: //NEC98
                    if (!IsNEC_98) {
                        break;
                    }
                    // trough down to set FloppyType525High on NEC98

                case F5_1Pt2_512:

                    FloppyType = FloppyType525High;
                    break;

                case F3_1Pt23_1024: //NEC98
                    if (!IsNEC_98) {
                        break;
                    }
                    // trough down to set FloppyType35High on NEC98

                case F3_1Pt44_512:
                case F3_2Pt88_512:
                case F3_20Pt8_512:

                    FloppyType = FloppyType35High;
                    break;

                case F3_720_512:

                    FloppyType = FloppyType35Low;
                    break;

                case F5_360_512:
                case F5_320_512:
                case F5_320_1024:
                case F5_180_512:
                case F5_160_512:

                    FloppyType = FloppyType525Low;
                    break;

                case F3_120M_512:
                    FloppyType = FloppyType35High120MB;
                    break;
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: no media types for %ws!\n",OpenPath));
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get media types for %ws (%lx)\n",OpenPath,Status));
        }

        ZwClose(Handle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %ws does not exist (%lx)\n",OpenPath,Status));
    }

    //
    // Save the value.
    //
    if(FloppyOrdinal < ELEMENT_COUNT(CachedTypes)) {
        CachedTypes[FloppyOrdinal] = FloppyType;
    }

    return(FloppyType);
}

VOID
SpConfirmScsiMiniports(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Start with scsi.
    //
    SpDetectScsi(SifHandle,SourceDevicePath,DirectoryOnSourceDevice);
    SpConfirmScsiInteract(SifHandle,SourceDevicePath,DirectoryOnSourceDevice);
}


VOID
SpConfirmHardware(
    IN PVOID SifHandle
    )
{
    ULONG i;
    BOOLEAN AllConfirmed,FirstPass,NeedConfirm;
    PWSTR p;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Determine the computer type.
    //
    SpDetectComputer(SifHandle);

    //
    // Determine the video type.
    //
    SpDetectVideo(SifHandle);

    //
    // Determine the keyboard type.
    //
    SpDetectKeyboard(SifHandle);

    //
    // Determine the mouse.
    //
    SpDetectMouse(SifHandle);

    //
    // Determine the keyboard layout.
    //
    SpDetectLayout(SifHandle);

    //
    // If we have upgrade, we don't need to know what display, keyboard,
    // layout, mouse we have.   We just need the computer type and that
    // is 100% accurate.  So we can skip the hardware confirmation dialog
    //

    if(NTUpgrade == UpgradeFull) {
        return;
    }

    //
    // Handle locale-specific keyboard stuff for Far East.
    //
    SplangSelectKeyboard(
        UnattendedOperation,
        UnattendedSifHandle,
        NTUpgrade,
        SifHandle,
        HardwareComponents
        );

    //
    // See whether this is an unattended setup.
    //
    NeedConfirm = FALSE;
    if(UnattendedOperation) {

        NeedConfirm = FALSE;

        if( !PreInstall ) {
            //
            //  If this is not an OEM pre-install, then check if we need
            //  to confirm the hardware
            //
            p = SpGetSectionKeyIndex(
                    UnattendedSifHandle,
                    SIF_UNATTENDED,
                    SIF_CONFIRMHW,
                    0
                    );

            if(p && !_wcsicmp(p,L"yes")) {
                NeedConfirm = TRUE;
            }
        } else {
            return;
        }
    }

    FirstPass = TRUE;
    do {

        //
        // See if we know what everything is.
        //
        AllConfirmed = TRUE;
        for(i=0; i<HwComponentMax; i++) {
            if(HardwareComponents[i]->Description == NULL) {
                AllConfirmed = FALSE;
                break;
            }
        }

        //
        // If we don't know what everything is, put up a warning.
        //
        if(FirstPass) {
            if(CustomSetup && NeedConfirm) {
                AllConfirmed = FALSE;
            }
            FirstPass = FALSE;
        } else if(!AllConfirmed) {

            SpDisplayScreen(UnknownHwScreens[i],4,HEADER_HEIGHT+2);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        }

        //
        // If this is a custom setup or we don't know what
        // a piece of hardware is, present the confirmation screen
        // to the user.
        //
        if(!AllConfirmed) {
            SpHardwareConfirmInteract(SifHandle);
        }

    } while(!AllConfirmed);
}



VOID
SpHardwareConfirmInteract(
    IN PVOID SifHandle
    )
{
    PWSTR szUnknown,szListMatches;
    PWSTR p;
    ULONG MenuLeftX,MenuTopY;
    ULONG LongestLength,len;
    PWSTR MenuItems[HARDWARE_MENU_SIZE];
    PVOID Menu;
    ULONG KeyPressed;
    ULONG_PTR Selection;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    BOOLEAN Done;
    ULONG i;
    WCHAR c;


    //
    // Fetch 'unknown' and 'the above list matches my computer' from the resources.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_UNKNOWN);
    szUnknown = SpDupStringW(TemporaryBuffer);
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_LIST_MATCHES);
    szListMatches = SpDupStringW(TemporaryBuffer);

    for(Done=FALSE; !Done; ) {

        //
        // Part 1 of the screen.
        //
        SpDisplayScreen(SP_SCRN_HW_CONFIRM_1,3,HEADER_HEIGHT+1);

        //
        // Remember top line of the menu.
        //
        MenuTopY = NextMessageTopLine + 2;

        //
        // Part 2 of the screen.
        //
        SpContinueScreen(SP_SCRN_HW_CONFIRM_2,3,2,FALSE,DEFAULT_ATTRIBUTE);

        //
        // To determine where the left margin of the menu is, we'll load
        // the second part of the screen and look for the first semicolon.
        //
        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_SCRN_HW_CONFIRM_2);
        p = wcschr(TemporaryBuffer,L':');
        ASSERT(p);
        if(p) {
            c = *p;
            *p = 0;
            MenuLeftX = SplangGetColumnCount(TemporaryBuffer) + 5;
            *p = c;
        } else {
            MenuLeftX = 23;
        }

        //
        // Build up menu items.
        //
        LongestLength = SplangGetColumnCount(szListMatches);
        for(i=0; i<HARDWARE_MENU_SIZE; i++) {

            MenuItems[i] = HardwareComponents[i]->Description
                         ? HardwareComponents[i]->Description
                         : szUnknown;
            if((len=SplangGetColumnCount(MenuItems[i])) > LongestLength) {
                LongestLength = len;
            }
        }

        Menu = SpMnCreate(MenuLeftX,MenuTopY,LongestLength,HARDWARE_MENU_SIZE+2);

        ASSERT(Menu);

        //
        // Silently fail, if we cannot create the menu
        //
        if (!Menu) {            
            Done = TRUE;

            continue;
        }

        //
        // Add all the items to the menu, plus one unselectable spacer and
        // the 'the list matches' item.
        //
        for(i=0; i<HARDWARE_MENU_SIZE; i++) {
            BOOLEAN ItemSelectable;

#if defined (_IA64_)
            ItemSelectable = TRUE; // in softsdv the mouse + keyboard are
                                   // unknown; we need to select them.
#else
            ItemSelectable = ( (i != HwComponentKeyboard) &&
                               (i != HwComponentMouse) );
#endif
            SpMnAddItem(Menu,
                        MenuItems[i],
                        MenuLeftX,
                        LongestLength,
                        ItemSelectable,
                        ItemSelectable ? i : 0);
        }
        SpMnAddItem(Menu,L"",MenuLeftX,LongestLength,FALSE,0);
        SpMnAddItem(Menu,szListMatches,MenuLeftX,LongestLength,TRUE,(ULONG_PTR)(-1));

        //
        // Display the status text.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Display the menu and await a selection.
        //
        SpMnDisplay(Menu,(ULONG_PTR)(-1),FALSE,ValidKeys,NULL,NULL,&KeyPressed,&Selection);

        SpMnDestroy(Menu);

        switch(KeyPressed) {
        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            //
            // Selection was made.
            //
            if(Selection == (ULONG_PTR)(-1)) {
                Done = TRUE;
            } else {

                ASSERT(Selection < HwComponentMax);

                //
                // Allow user to make alternate selection for this component.
                //
                SpSelectHwItem(
                    SifHandle,
                    NonlocalizedComponentNames[Selection],
                    NULL,               // use component name as section name
                    SelectHwScreens[Selection],
                    SelectOemHwScreens[Selection],
                    AllowedFileTypes[Selection],
                    RequiredFileTypes[Selection],
                    HardwareComponents[Selection]
                    );
            }
            break;
        default:
            // should never get here!
            ASSERT(0);
            break;
        }
    }

    SpMemFree(szUnknown);
    SpMemFree(szListMatches);
}


BOOLEAN
SpSelectHwItem(
    IN     PVOID               SifHandle,
    IN     PWSTR               NonlocalizedComponentName,
    IN     PWSTR               OemSectionName,            OPTIONAL
    IN     ULONG               SelectHwScreenId,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp
    )

/*++

Routine Description:

    Allow the user to make selection from a list of choices for a component.

    The list comes from a section in the setup information file named
    for the component.  For example, [Display].

    The descriptions in that section will be placed into a menu to make
    up the selections.  Also added to the menu will be a choice for 'other'
    which the user can choose if he has a third-party driver diskette.
    If a third-party option is the currently selected option, then that
    option will also be on the menu and will be the default.

    If the user selects 'other' then prompt for a driver diskette.

Arguments:

    SifHandle - supplies handle to open setup information file.

    NonlocalizedComponentName - supplies name of component to be used
        as the name of a section in the sif file for the component.

    OemSectionName - supplies name of a section that will contain the
        options for the component in txtsetup.oem.  This may be different
        than NonloclizedComponentName -- for example, the componentname
        string might be "SCSI.MCA" but the OemSectionName would be "SCSI."

    SelectHwScreenId - supplies message id of the screen prompting the user
        to select an option for this component.

    SelectOemHwScreenId - supplies message id of the screen prompting the
        user to select an option on an oem screen for this component
        (ie, the screen the user gets when he selects 'other' hw type
        and inserts an oem floppy).

    AllowedFileTypes - supplies a mask indicating which types of files are
        allowed for this component.  Used to validate the oem selection
        if the user chooses the 'other' hardware type and inserts an oem floppy.

    RequiredFileTypes - supplies a mask indicating which types of files are
        required for this component.  Used to validate the oem selection
        if the user chooses the 'other' hardware type and inserts an oem floppy.

    HwComp - hardware component structure to be filled in with information
        about the user's selection.

Return Value:

    TRUE if the selected hardware item has been changed by the user's action.
    FALSE otherwise.

--*/

{
    ULONG LineCount,Line;
    PVOID Menu;
    ULONG MenuTopY,MenuHeight,MenuWidth;
    PWSTR Description;
    ULONG_PTR Selection;
    PWSTR szOtherHardware;
    ULONG OtherOption;
    ULONG_PTR OriginalSelection = (ULONG_PTR)(-1);
    ULONG ValidKeys[4] = { KEY_F3,ASCI_CR,ASCI_ESC,0 };
    ULONG Keypress;
    BOOLEAN Done;
    BOOLEAN rc = FALSE;
    PWSTR Id,Descr;

    //
    // Fetch the 'other hardware' string from resources.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_OTHER_HARDWARE);
    szOtherHardware = SpDupStringW(TemporaryBuffer);

    for(Done=FALSE; !Done; ) {

        //
        // Display the selection prompt screen.
        //
        SpDisplayScreen(SelectHwScreenId,5,HEADER_HEIGHT+1);

        MenuTopY = NextMessageTopLine + 2;
        MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
        MenuWidth = VideoVars.ScreenWidth - 6;

        //
        // Create a menu.
        //
        Menu = SpMnCreate(3,MenuTopY,MenuWidth,MenuHeight);
        ASSERT(Menu);

        //
        // Assume unknown option.
        //
        Selection = (ULONG_PTR)(-1);

        //
        // Build a list of options containing the options in our box
        // and the currently selected oem option (if any).
        //
        LineCount = SpCountLinesInSection(SifHandle,NonlocalizedComponentName);
        for(Line=0; Line<LineCount; Line++) {

            //
            // Get the description from the current line and add it to the menu.
            //
            Description = SpGetSectionLineIndex(
                                SifHandle,
                                NonlocalizedComponentName,
                                Line,
                                INDEX_DESCRIPTION
                                );

            if(!Description) {
                SpFatalSifError(SifHandle,NonlocalizedComponentName,NULL,Line,INDEX_DESCRIPTION);
            }

            SpMnAddItem(Menu,Description,3,VideoVars.ScreenWidth-6,TRUE,Line);

            //
            // See if this is the currently selected item.
            //
            if(HwComp->Description && !wcscmp(HwComp->Description,Description)) {
                Selection = Line;
            }
        }

        //
        // If there is an oem option, add its description and make it the default.
        //
        if(HwComp->ThirdPartyOptionSelected) {
            SpMnAddItem(Menu,HwComp->Description,3,VideoVars.ScreenWidth-6,TRUE,Line);
            Selection = Line++;
        }

        //
        // Add 'other to the list and make it the defualt if the current type is
        // 'other' and there is no third-party option.
        // Note that we don't allow oem keyboard layouts any more.
        //
        if(HwComp == HardwareComponents[HwComponentLayout]) {
            if(Selection == (ULONG_PTR)(-1)) {
                Selection = 0;
            }
            OtherOption = (ULONG)(-1);
        } else {
            SpMnAddItem(Menu,szOtherHardware,3,VideoVars.ScreenWidth-6,TRUE,Line);
            if((Selection == (ULONG_PTR)(-1))
            || (!HwComp->ThirdPartyOptionSelected && !HwComp->IdString))
            {
                Selection = Line;
            }
            OtherOption = Line;
        }

        if(OriginalSelection == (ULONG_PTR)(-1)) {
            OriginalSelection = Selection;
        }

        //
        // Display the status text options.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        //
        // Display the menu.
        //
        SpMnDisplay(
            Menu,
            Selection,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            &Keypress,
            &Selection
            );

        //
        // Fetch the description text before we free the menu structure.
        //
        Descr = SpMnGetTextDup(Menu,Selection);

        SpMnDestroy(Menu);

        switch(Keypress) {

        case ASCI_CR:

            if(Selection == OtherOption) {

                //
                // User selected 'other' -- prompt for a diskette, etc.
                //
                rc = SpOemDiskette(
                        SifHandle,
                        OemSectionName ? OemSectionName : NonlocalizedComponentName,
                        SelectOemHwScreenId,
                        AllowedFileTypes,
                        RequiredFileTypes,
                        HwComp,
                        SP_SCRN_OEM_INF_ERROR
                        );

            } else if(Selection == OriginalSelection) {
                //
                // User chose same thinbg that was selected before.
                //
                rc = FALSE;
            } else {

                //
                // User chose a non-oem option.  Update structures accordingly
                // and forget any previously selected oem option.
                //
                Id = SpGetKeyName(SifHandle,NonlocalizedComponentName,(ULONG)Selection);
                if(!Id) {
                    SpFatalSifError(SifHandle,NonlocalizedComponentName,NULL,(ULONG)Selection,(ULONG)(-1));
                }

                ASSERT(Descr);

                SpFreeHwComponentFile(&HwComp->Files);

                SpInitHwComponent(HwComp,Id,Descr,FALSE,0,NULL,FALSE);
                rc = TRUE;
            }

            Done = TRUE;
            break;

        case ASCI_ESC:

            Done = TRUE;
            break;

        case KEY_F3:

            SpConfirmExit();
            break;

        default:

            // shouldn't ever get here!
            ASSERT(0);
            break;
        }

        SpMemFree(Descr);
    }

    SpMemFree(szOtherHardware);
    return(rc);
}


VOID
SpOemInfError(
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PWSTR Description
    )
{
    WCHAR SubError[512];

    //
    // Line numbers are 0-based.  Want to display to user as 1-based.
    //
    LineNumber++;

    //
    // Fetch/format the suberror.
    //
    SpFormatMessage(SubError,sizeof(SubError),SubErrorId,SectionName,LineNumber,Description);

    //
    // Display the error screen.
    //
    SpStartScreen(
        ErrorScreenId,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        SubError
        );

    if( !PreInstall ) {
        //
        // Display status options: enter to continue.
        //
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);

        //
        // Wait for the user to press enter.
        //
        SpInputDrain();
        while(SpInputGetKeypress() != ASCI_CR) ;
    } else {
        //
        // If this is an OEM pre-install then treat the error as a fatal one.
        // Display status options: F3 to exit.
        //
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        //
        // Wait for the user to press enter.
        //
        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


BOOLEAN
SpOemDiskette(
    IN     PVOID               SifHandle,
    IN     PWSTR               SectionName,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp,
    IN     ULONG               ErrorId
    )
{
    PWSTR szDiskName;
    BOOLEAN b;
    ULONG ErrorLine;
    NTSTATUS Status;
    PVOID TxtsetupOem;
    ULONG Count;
    ULONG Line;
    ULONG_PTR DefaultSelection,Selection;
    PWSTR DefSelId;
    PVOID Menu;
    ULONG MenuTopY,MenuHeight,MenuWidth;
    BOOLEAN rc;
    ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
    ULONG Key;
    PWSTR szDefaults = TXTSETUP_OEM_DEFAULTS_U;
    PWSTR szDevicePath = 0;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // Always want to prompt for the disk in A:.
    // First, make sure there is an A:!
    //
    if(SpGetFloppyDriveType(0) == FloppyTypeNone) {
        SpDisplayScreen(SP_SCRN_NO_FLOPPY_FOR_OEM_DISK,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpInputDrain();
        while(SpInputGetKeypress() != ASCI_CR) ;
        goto sod0;
    }

    //
    // Fetch the generic oem disk name.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_OEM_DISK_NAME);
    szDiskName = SpDupStringW(TemporaryBuffer);

    //
    // Prompt for the disk -- ignore what may be in the drive already,
    // and allow escape.
    //
    szDevicePath = SpDupStringW(L"\\device\\floppy0");

    if (szDevicePath) {
        b = SpPromptForDisk(
                szDiskName,
                szDevicePath,
                TXTSETUP_OEM_FILENAME_U,
                TRUE,
                TRUE,
                FALSE,
                NULL
                );
        SpMemFree(szDevicePath);
    } else {
        b = FALSE;
    }

    SpMemFree(szDiskName);

    //
    // If the user pressed escape at the disk prompt, bail out now.
    //
    if(!b) {
        goto sod0;
    }

    //
    // Load txtsetup.oem.
    //
    HandleLineContinueChars = FALSE;
    Status = SpLoadSetupTextFile(
                L"\\device\\floppy0\\" TXTSETUP_OEM_FILENAME_U,
                NULL,
                0,
                &TxtsetupOem,
                &ErrorLine,
                TRUE,
                FALSE
                );
    HandleLineContinueChars = TRUE;

    if(!NT_SUCCESS(Status)) {
        if(Status == STATUS_UNSUCCESSFUL) {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_A,NULL,ErrorLine,NULL);
        } else {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_0,NULL,0,NULL);
        }
        goto sod0;
    }

    //
    // Determine if this inf file is relevent to the device class the user
    // is selecting.  If there is a section called 'display' 'keyboard' etc
    // as appropriate for DeviceClass, then we're in business.
    //

    Count = SpCountLinesInSection(TxtsetupOem,SectionName);
    if(!Count) {
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_1,SectionName,0,NULL);
        goto sod1;
    }

    //
    // Get the id of the default choice.
    //

    DefaultSelection = 0;
    DefSelId = SpGetSectionKeyIndex(TxtsetupOem,szDefaults,SectionName,OINDEX_DEFAULT);
    if(DefSelId == NULL) {
        DefSelId = L"";
    }

    //
    // Display the prompt screen, calculate where the menu goes,
    // and create a menu.
    //
    SpDisplayScreen(SelectOemHwScreenId,5,HEADER_HEIGHT+1);

    MenuTopY = NextMessageTopLine + 2;
    MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
    MenuWidth = VideoVars.ScreenWidth - 6;

    Menu = SpMnCreate(3,MenuTopY,MenuWidth,MenuHeight);

    //
    // Build a menu from the choices in the oem inf file section.
    //
    for(Line=0; Line<Count; Line++) {

        PWSTR p,Descr;

        Descr = SpGetSectionLineIndex(TxtsetupOem,SectionName,Line,OINDEX_DESCRIPTION);
        if(Descr == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemDiskette: no description on line %u in [%ws]",Line,SectionName));
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,SectionName,Line,NULL);
            goto sod2;
        }

        SpMnAddItem(Menu,Descr,3,MenuWidth,TRUE,Line);

        // determine if this is the default selection.
        if(p = SpGetKeyName(TxtsetupOem,SectionName,Line)) {
            if(!_wcsicmp(p,DefSelId)) {
                DefaultSelection = Line;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemDiskette: no key on line %u of section %ws",Line,SectionName));
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,SectionName,Line,NULL);
            goto sod2;
        }
    }

    //
    // Display options in status bar: enter = select, escape = cancel.
    //
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_SELECT,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Display the menu and await a selection.
    //
    SpMnDisplay(Menu,DefaultSelection,TRUE,ValidKeys,NULL,NULL,&Key,&Selection);

    if(Key == ASCI_CR) {

        PWSTR Id = SpGetKeyName(TxtsetupOem,SectionName,(ULONG)Selection);
        PWSTR p;

        //
        // We already checked this once for non-null (above).
        //
        ASSERT(Id);

        rc = SpOemInfSelection(
                TxtsetupOem,
                SectionName,
                Id,
                p = SpMnGetTextDup(Menu,Selection),
                AllowedFileTypes,
                RequiredFileTypes,
                HwComp,
                ErrorId
                );

        SpMemFree(p);

    } else {

        ASSERT(Key == ASCI_ESC);

        // just fall through and return false.
    }

sod2:
    SpMnDestroy(Menu);

sod1:
    SpFreeTextFile(TxtsetupOem);

sod0:
    return(rc);
}


BOOLEAN
SpOemInfSelection(
    IN  PVOID               TxtsetupOem,
    IN  PWSTR               NonlocalizedComponentName,
    IN  PWSTR               SelectedId,
    IN  PWSTR               ItemDescription,
    IN  ULONG               AllowedFileTypes,
    IN  ULONG               RequiredFileTypes,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  ULONG               ErrorId
    )
{
    PWSTR FilesSectionName,ConfigSectionName;
    ULONG Line,Count,Line2,Count2;
    BOOLEAN rc = FALSE;
    PHARDWARE_COMPONENT_FILE FileList = NULL;
    PHARDWARE_COMPONENT_REGISTRY RegList = NULL;
    ULONG FileTypeBits = 0;
    PWSTR szDisks = TXTSETUP_OEM_DISKS_U;

    //
    // Iterate through the files section, remembering info about the
    // files to be copied in support of the selection.
    //

    FilesSectionName = SpMemAlloc(
                                ((wcslen(NonlocalizedComponentName)+wcslen(SelectedId)+1)*sizeof(WCHAR))
                              + sizeof(L"Files.")
                            );

    wcscpy(FilesSectionName,L"Files.");
    wcscat(FilesSectionName,NonlocalizedComponentName);
    wcscat(FilesSectionName,L".");
    wcscat(FilesSectionName,SelectedId);
    Count = SpCountLinesInSection(TxtsetupOem,FilesSectionName);
    if(Count == 0) {
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_3,FilesSectionName,0,NULL);
        goto sod0;
    }

    for(Line=0; Line<Count; Line++) {

        PWSTR Disk,Filename,Filetype,Tagfile,Description,Directory,ConfigName;
        HwFileType filetype;
        PHARDWARE_COMPONENT_FILE FileStruct;

        //
        // Get the disk specification, filename, and filetype from the line.
        //

        Disk = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_DISKSPEC);
        Filename = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_FILENAME);
        Filetype = SpGetKeyName(TxtsetupOem,FilesSectionName,Line);

        if(!Disk || !Filename || !Filetype) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpOemInfSelection: Disk=%ws, Filename=%ws, Filetype=%ws",
                Disk ? Disk : L"(null)",
                Filename ? Filename : L"(null)",
                Filetype ? Filetype : L"(null)"
                ));

            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        //
        // Parse the filetype.
        //
        filetype = SpFindStringInTable(FileTypeNames,Filetype);
        if(filetype == HwFileMax) {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_4,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        //
        // Fetch the name of the section containing configuration information.
        // Required if file is of type port, class, or driver.
        //
        if((filetype == HwFilePort) || (filetype == HwFileClass) || (filetype == HwFileDriver)) {
            ConfigName = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_CONFIGNAME);
            if(ConfigName == NULL) {
                SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_8,FilesSectionName,Line,NULL);
                SpFreeHwComponentFile(&FileList);
                goto sod0;
            }
        } else {
            ConfigName = NULL;
        }

        //
        // Using the disk specification, look up the tagfile, description,
        // and directory for the disk.
        //

        Tagfile     = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_TAGFILE);
        Description = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_DISKDESCR);
        Directory   = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_DIRECTORY);
        if((Directory == NULL) || !wcscmp(Directory,L"\\")) {
            Directory = L"";
        }

        if(!Tagfile || !Description) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpOemInfSelection: Tagfile=%ws, Description=%ws",
                Tagfile ? Tagfile : L"(null)",
                Description ? Description : L"(null)"
                ));

            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_5,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        FileStruct = SpMemAlloc(sizeof(HARDWARE_COMPONENT_FILE));
        RtlZeroMemory(FileStruct,sizeof(HARDWARE_COMPONENT_FILE));

        SpInitHwComponentFile(
            FileStruct,
            Filename,
            filetype,
            ConfigName,
            Description,
            Tagfile,
            Directory,
            NULL
            );

        FileStruct->Next = FileList;
        FileList = FileStruct;

        if((filetype == HwFilePort) || (filetype == HwFileDriver)) {
            SET_FILETYPE_PRESENT(FileTypeBits,HwFilePort);
            SET_FILETYPE_PRESENT(FileTypeBits,HwFileDriver);
        } else {
            SET_FILETYPE_PRESENT(FileTypeBits,filetype);
        }

        //
        // Now go look in the [Config.<ConfigName>] section for registry
        // information that is to be set for this driver file.
        //
        if(ConfigName) {
            ConfigSectionName = SpMemAlloc((wcslen(ConfigName)*sizeof(WCHAR)) + sizeof(L"Config."));
            wcscpy(ConfigSectionName,L"Config.");
            wcscat(ConfigSectionName,ConfigName);
            Count2 = SpCountLinesInSection(TxtsetupOem,ConfigSectionName);

            for(Line2=0; Line2<Count2; Line2++) {

                PWSTR KeyName,ValueName,ValueType;
                PHARDWARE_COMPONENT_REGISTRY Reg;
                HwRegistryType valuetype;

                //
                // Fetch KeyName, ValueName, and ValueType from the line.
                //

                KeyName   = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_KEYNAME);
                ValueName = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_VALUENAME);
                ValueType = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_VALUETYPE);

                if(!KeyName || !ValueName || !ValueType) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP: SpOemInfSelection: KeyName=%ws, ValueName=%ws, ValueType=%ws",
                        KeyName ? KeyName : L"(null)",
                        ValueName ? ValueName : L"(null)",
                        ValueType ? ValueType : L"(null)"
                        ));

                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentReg(&RegList);
                    SpFreeHwComponentFile(&FileList);
                    goto sod0;
                }

                //
                // Parse the value type and associated values.
                //
                valuetype = SpFindStringInTable(RegistryTypeNames,ValueType);
                if(valuetype == HwRegistryMax) {
                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_6,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentFile(&FileList);
                    SpFreeHwComponentReg(&RegList);
                    goto sod0;
                }

                valuetype = RegistryValueTypeMap[valuetype];

                Reg = SpInterpretOemRegistryData(
                            TxtsetupOem,
                            ConfigSectionName,
                            Line2,
                            valuetype,
                            KeyName,
                            ValueName
                            );

                if(Reg) {
                    Reg->Next = RegList;
                    RegList = Reg;
                } else {
                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_7,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentReg(&RegList);
                    SpFreeHwComponentFile(&FileList);
                    goto sod0;
                }
            }

            FileStruct->RegistryValueList = RegList;
            RegList = NULL;

            SpMemFree(ConfigSectionName);
        }
    }

    //
    // Check to see whether only files of the allowed types for this component
    // have been specified.
    //

    if((AllowedFileTypes | FileTypeBits) != AllowedFileTypes) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppOemInfSelection: allowed files: %lx, what we've got: %lx",AllowedFileTypes,FileTypeBits));
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_9,FilesSectionName,0,NULL);
        SpFreeHwComponentFile(&FileList);
        goto sod0;
    }

    //
    // Check to see whether files were specified for each required type.
    //

    if((RequiredFileTypes & FileTypeBits) != RequiredFileTypes) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppOemInfSelection: required files: %lx, what we've got: %lx",RequiredFileTypes,FileTypeBits));
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_9,FilesSectionName,0,NULL);
        SpFreeHwComponentFile(&FileList);
        goto sod0;
    }

    //
    // Everything is OK so we can place the information we have gathered
    // into the main structure for the device class.
    //

    SpFreeHwComponentFile(&HwComp->Files);
    SpInitHwComponent(HwComp,SelectedId,ItemDescription,TRUE,FileTypeBits,NULL,FALSE);
    HwComp->Files = FileList;
    rc = TRUE;

    //
    // Clean up and exit.
    //

sod0:
    SpMemFree(FilesSectionName);

    return(rc);
}


VOID
SpDetectComputer(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT pHw = HardwareComponents[HwComponentComputer];
    PWSTR Description;

    //
    // Setupldr *must* have given us this information.
    //
    ASSERT(pHw);
    ASSERT(pHw->Next == NULL);

    //
    // If the computer is a third-aprty type, the desscription
    // should already be there.
    //
    if(pHw->ThirdPartyOptionSelected) {

        ASSERT(pHw->Description);

    } else {

        //
        // Description might already be there if the user chose
        // a type we support, during setupldr phase.
        //
        if(pHw->Description) {
            SpMemFree(pHw->Description);
        }

        //
        // Look up the description.
        //
        Description = SpGetSectionKeyIndex(
                            SifHandle,
                            NonlocalizedComponentNames[HwComponentComputer],
                            pHw->IdString,
                            INDEX_DESCRIPTION
                            );

        if(!Description) {

            SpFatalSifError(
                SifHandle,
                NonlocalizedComponentNames[HwComponentComputer],
                pHw->IdString,
                0,
                INDEX_DESCRIPTION
                );
        }

        pHw->Description = SpDupStringW(Description);
    }


}


VOID
SpDetectVideo(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT VideoDevice;

    VideoDevice = HardwareComponents[HwComponentDisplay];

    //
    // Just use what setupldr detected but we'll have to go
    // fetch the description for non-oem video types.
    //
    if(!VideoDevice->ThirdPartyOptionSelected && !VideoDevice->Description) {

        VideoDevice->Description = SpGetSectionKeyIndex(
                                        SifHandle,
                                        NonlocalizedComponentNames[HwComponentDisplay],
                                        VideoDevice->IdString,
                                        INDEX_DESCRIPTION
                                        );

        if(VideoDevice->Description) {
            VideoDevice->Description = SpDupStringW(VideoDevice->Description);
        } else {
            SpFatalSifError(
                SifHandle,
                NonlocalizedComponentNames[HwComponentDisplay],
                VideoDevice->IdString,
                0,
                INDEX_DESCRIPTION
                );
        }
    }

    //
    // There should be only one video device.
    //
    ASSERT(VideoDevice->Next == NULL);
}


VOID
SpDetectKeyboard(
    IN PVOID SifHandle
    )
{
#if 0
    PHARDWARE_COMPONENT KeyboardDevice;

    KeyboardDevice = HardwareComponents[HwComponentKeyboard];

    //
    // If setupldr did any keyboard detection, ignore it
    // unless it's a third-party option.
    //
    if(KeyboardDevice && KeyboardDevice->ThirdPartyOptionSelected)  {

        //
        // There should be only one keyboard device.
        //
        ASSERT(KeyboardDevice->Next == NULL);

    } else {

        //
        // Free the keyboard device if there is one.
        //
        if(KeyboardDevice) {
            SpFreeHwComponent(&KeyboardDevice,TRUE);
        }

        KeyboardDevice = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(KeyboardDevice,sizeof(HARDWARE_COMPONENT));

        SpDetermineComponent(
            SifHandle,
            KeyboardDevice,
            L"KeyboardPeripheral",
            NULL,
            L"Keyboard"
            );

        HardwareComponents[HwComponentKeyboard] = KeyboardDevice;
    }
#endif

    PHARDWARE_COMPONENT KeyboardDevice, p;
    PWSTR   ComponentName;
    PWSTR   Key;
    PWSTR   Description;

#if 0
    for( KeyboardDevice = HardwareComponents[HwComponentKeyboard];
         KeyboardDevice != NULL;
         KeyboardDevice = KeyboardDevice->Next ) {

        //
        // Free the keyboard device if there is one.
        //
        if(KeyboardDevice) {
            SpFreeHwComponent(&KeyboardDevice,TRUE);
        }
    }
#endif

    KeyboardDevice = HardwareComponents[HwComponentKeyboard];
    //
    // Free the keyboard device if there is one.
    //
    if(KeyboardDevice) {
        SpFreeHwComponent(&KeyboardDevice,TRUE);
    }
    ComponentName = NonlocalizedComponentNames[HwComponentKeyboard];
    KeyboardDevice = NULL;
    p = NULL;
    
    if( UsbKeyboardDetected ) {

        Key = SpDupStringW( L"kbdhid" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"kbdhid";
        }            
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        
        KeyboardDevice = p;
     
    } 
    else if (StdKeyboardDetected) {

        Key = SpDupStringW( L"STANDARD" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"STANDARD";
        }            
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        KeyboardDevice = p;

    } else {

         p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));

         if (p) {
             RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));

             SpDetermineComponent(
                 SifHandle,
                 p,
                 L"KeyboardPeripheral",
                 NULL,
                 L"Keyboard"
                 );

            KeyboardDevice = p;
         }
     }

     ASSERT(KeyboardDevice);

     HardwareComponents[HwComponentKeyboard] = KeyboardDevice;
}

VOID
SpDetectLayout(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT KeyboardLayout;
    PWSTR IdString,Description;

    KeyboardLayout = HardwareComponents[HwComponentLayout];

    //
    // Setupldr never chooses a layout.
    //
    ASSERT(KeyboardLayout == NULL);

    KeyboardLayout = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(KeyboardLayout,sizeof(HARDWARE_COMPONENT));

    HardwareComponents[HwComponentLayout] = KeyboardLayout;

    //
    // Look up the default layout in the setup information file.
    //
    IdString = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0);
    if(!IdString) {
        SpFatalSifError(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0,0);
    }

    Description = SpGetSectionKeyIndex(
                        SifHandle,
                        NonlocalizedComponentNames[HwComponentLayout],
                        IdString,
                        INDEX_DESCRIPTION
                        );
    if(!Description) {
        SpFatalSifError(
            SifHandle,
            NonlocalizedComponentNames[HwComponentLayout],
            IdString,
            0,
            INDEX_DESCRIPTION
            );
    }

    //
    // Initialize the hardware component strucutre for the layout.
    //
    SpInitHwComponent(KeyboardLayout,IdString,Description,FALSE,0,NULL,FALSE);
}


VOID
SpDetectMouse(
    IN PVOID SifHandle
    )
{
#if 0
    PHARDWARE_COMPONENT MouseDevice;

    //
    // Setupldr does not do any mouse detection.
    //
    ASSERT(HardwareComponents[HwComponentMouse] == NULL);

    MouseDevice = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(MouseDevice,sizeof(HARDWARE_COMPONENT));

    SpDetermineComponent(
        SifHandle,
        MouseDevice,
        L"PointerPeripheral",
        L"NO MOUSE",
        L"Mouse"
        );

    HardwareComponents[HwComponentMouse] = MouseDevice;
#endif

    PHARDWARE_COMPONENT MouseDevice, p;
    PWSTR   ComponentName;
    PWSTR   Key;
    PWSTR   Description;

    ComponentName = NonlocalizedComponentNames[HwComponentMouse];
    MouseDevice = NULL;
    p = NULL;
    
    //
    // If a mouse was detected (through pnp), then add the mouse to the list
    //
    // none = "No Mouse or Other Pointing Device",files.none,""
    // mouhid = "USB Mouse",files.mouhid,mouhid
    // msser = "Microsoft Serial Mouse",files.sermouse,sermouse
    // ps2 = "Mouse Port Mouse",files.i8042,i8042prt
    // sermouse = "Serial Mouse",files.sermouse,sermouse
    //
    if( UsbMouseDetected ) {
        
        Key = SpDupStringW( L"mouhid" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"mouhid";
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }

        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        MouseDevice = p;
    
    } else if( SerMouseDetected ) {

        Key = SpDupStringW( L"msser" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"msser";                
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }

        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        p->Next = MouseDevice;
        MouseDevice = p;
    
    } 
#if defined (_IA64_)
    else if( PS2MouseDetected ) {
            
        Key = SpDupStringW( L"ps2" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"ps2";                
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        p->Next = MouseDevice;
        MouseDevice = p;
        
    } 
    else
#endif
    {
        //
        //  Now look for a mouse detected by NTDETECT.
        //
        
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));

        SpDetermineComponent(
            SifHandle,
            p,
            L"PointerPeripheral",
            L"NO MOUSE",
            L"Mouse"
            );
        if( MouseDevice == NULL ) {
            //
            // If we did not any mice through pnp, then add whatever we found through NTDETECT
            // (even "No Mouse"), to the mice list.
            //
            MouseDevice = p;
        } else {
            //
            //  Add the mouse detected through NTDETECT, if any
            //
            if( _wcsicmp( p->IdString, L"none" ) != 0 ) {
                p->Next = MouseDevice;
                MouseDevice = p;
            }
        }
    
    }

    ASSERT(MouseDevice);

    HardwareComponents[HwComponentMouse] = MouseDevice;
}



VOID
SpDetermineComponent(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               HardwareDescriptionKeyName,
    IN  PWSTR               FallbackIdentifier,
    IN  PWSTR               ComponentName
    )

/*++

Routine Description:

    Make an initial determination about the type of a hardware component
    (ie, perform a hardware 'detection').

    The detection is performed by scanning the hardware configuration tree
    for a key representing a particular hardware component, and attempting
    to match its identifier string with a set of known identifier strings
    (stored in the setup information file).

Arguments:

    SifHandle - supplies handle for main setup information file.

    HwComp - a hardware component structure that is filled in with information
        about the component we find.

    HardwareDescriptionKeyName - supplies the name of the key in the hardware
        description (ie, the firmware configuration tree).

    FallbackIdentifier - supplies the id string to use if we cannot detect
        the hardware type for the component.  For example, if we can't find
        a PointerPeripheral (mouse), this might be "NO MOUSE."

    ComponentName - supplies name of the component.  This name is not translated.

Return Value:

    TRUE if a match was found, FALSE otherwise.

--*/

{
    PWSTR IdString;

    //
    // Scan the firmware configuration tree.
    //
    SpScanHardwareDescription(HardwareDescriptionKeyName);

    if (IdStringCount && (0 == _wcsicmp(HardwareDescriptionKeyName, L"PointerPeripheral"))) {
        //
        // Skip the Microsoft Bus Mouse device
        //
        ULONG Index;        
        
        for (Index = 0; Index < IdStringCount; Index++) {
            if (IdStringArray[Index] && _wcsicmp(IdStringArray[Index], MICROSOFT_BUS_MOUSE_NAME)) {
                if (Index) {
                    PWSTR FirstId = IdStringArray[0];

                    IdStringArray[0] = IdStringArray[Index];
                    IdStringArray[Index] = FirstId;
                }                    

                break;
            }                
        }

        if (Index >= IdStringCount) {
            IdStringCount = 0;
        }
    }
    
    //
    // Pick off the first identifier found.  If no such node
    // was found, then use the fallback identifier.
    //    
    IdString = IdStringCount ? IdStringArray[0] : FallbackIdentifier;

    //
    // Now go scan the map section in the sif file to see whether we
    // recognize the hardware described by this particular id string.
    //
    SpScanMapSection(SifHandle,HwComp,ComponentName,IdString);

    SpFreeLocatedIdStrings();
}



BOOLEAN
SpScanMapSection(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               ComponentName,
    IN  PWSTR               IdString
    )

/*++

Routine Description:

    Scan a 'map' section in the main sif file.  A 'map' section is used to
    map values seen as id strings in the firmware configuration tree t0
    'shortnames' -- ie, key values that represent a particular component type.

    A map section has the form, for example,

    [Map.Display]
    g300 = *G300
    g364 = *G364
    vxl  = *VXL

    where the values on the RHS represent possible values for the DisplayController
    node in the hardware description.  The values on the LHS are the keys to be used
    throughout the rest of setup to represent the type of video present in the machine.

    If an entry starts with a * then it need only appear as a substring of the
    id string found in the firmware configuration tree; otherwise the entry and
    the id string must match exactly.

    There is then a section like

    [Display]
    g300 = "Integrated Video Controller (G300)",...
    g364 = "Integrated Video Controller (G364)",...
    vxl  = "Integrated Jaguar Video",...

    that gives additional information about the video type, like a description, etc.

    This routine scans the map section for a match of a given id string found in
    the firmware tree, looks up additional information about the component if a match
    is found, and fills in a hardware component structure.

Arguments:

    SifHandle - supplies handle for main setup information file.

    HwComp - a hardware component structure that is filled in with information
        about the component we find, if a match is found.

    ComponentName - supplies name of the component.  This name is not translated.

    IdString - supplies the id string located in a key in the
        firmware configuration tree.

Return Value:

    TRUE if a match was found, FALSE otherwise.

--*/

{
    PWSTR MapSectionName;
    ULONG LineCount;
    ULONG Line;
    BOOLEAN b;
    PWSTR Value;
    PWSTR Key,Description;


    if(IdString == NULL) {
        IdString = L"";
    }

    //
    // Form the name of the map section.
    //
    MapSectionName = SpMemAlloc((wcslen(ComponentName)*sizeof(WCHAR)) + sizeof(MAP_SECTION_NAME_PREFIX));
    wcscpy(MapSectionName,MAP_SECTION_NAME_PREFIX);
    wcscat(MapSectionName,ComponentName);
    LineCount = SpCountLinesInSection(SifHandle,MapSectionName);
    if(!LineCount) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: no lines in [%ws]\n",MapSectionName));
        SpMemFree(MapSectionName);
        return(FALSE);
    }

    //
    // We have a section like
    //
    // [Map.Display]
    // vga = "VGA"
    // xga = *XGA
    //
    // We look at each line in the section, seeing if the IdString found in the
    // firmware configuration tree matches the value on the right hand side.
    // If so, then we expect to find a line like, for example
    //
    // [Display]
    // xga = "IBM XGA or XGA2"
    //

    for(Line=0; Line<LineCount; Line++) {

        Value = SpGetSectionLineIndex(SifHandle,MapSectionName,Line,INDEX_MAP_FWID);

        if(!Value) {
            SpFatalSifError(SifHandle,MapSectionName,NULL,Line,INDEX_MAP_FWID);
            return FALSE;
        }

        if(*Value == L'*') {
            b = (BOOLEAN)(wcsstr(IdString,Value+1) != NULL);
        } else {
            b = (BOOLEAN)(wcscmp(IdString,Value) == 0);
        }

        if(b) {

            //
            // We've got a match.
            //

            if((Key = SpGetKeyName(SifHandle,MapSectionName,Line)) == NULL) {

                SpFatalSifError(SifHandle,MapSectionName,NULL,Line,(ULONG)(-1));
            }

            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
            if(!Description) {
                SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
            }

            SpInitHwComponent(HwComp,Key,Description,FALSE,0,NULL,FALSE);

            SpMemFree(MapSectionName);
            return(TRUE);
        }
    }

    SpMemFree(MapSectionName);
    return(FALSE);
}


VOID
SpScanHardwareDescription(
    IN PWSTR DesiredKeyName
    )

/*++

Routine Description:

    Scan the hardware tree looking for subkeys of a key whose name
    matches a given value.

    Keys in the hardware tree do not match nodes in the arc configuration
    tree exactly.  In the arc configuration tree, each node has 3 attributes:
    a class, a type, and a key (not the same as a registry key; an arc key
    is more like an instance number or ordinal).  In the TN tree, the instances
    are themselves made subkeys.  So something like scsi(0)disk(0)rdisk(0)
    in the arc space ends up looking like

        HKEY_LOCAL_MACHINE
            HARDWARE
                DESCRIPTION
                    System
                        ScsiAdapter
                            0
                                DiskController
                                    0
                                        DiskPeripheral
                                            0

    in the nt hardware description tree.

    This is why we need to look for subkeys on a desired node in the arc tree --
    we assume that the subkeys of, say, a PointerPeripheral key in the registry
    are named "0" "1" etc and contain the ARC configuration data and id string.

    Id strings in keys we locate are added to a global table, in the variables
    IdStringCount and IdStringArray.  The caller must free these resources by
    calling SpFreeLocatedIdStrings.

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKey;

    //
    // Initialize some globals that allow us to track identifier strings
    // of devices we have located.
    //
    IdStringCount = 0;
    IdStringArray = SpMemAlloc(0);

    //
    // Open the root of the hardware description tree.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"\\Registry\\Machine\\Hardware\\Description\\System");

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open hardware description (%lx)\n",Status));
        return;
    }

    //
    // Scan the tree.
    //
    SpScanHardwareDescriptionWorker(hKey,L"System",DesiredKeyName);

    ZwClose(hKey);
}


VOID
SpScanHardwareDescriptionWorker(
    IN HANDLE KeyHandle,
    IN PWSTR  KeyName,
    IN PWSTR  DesiredKeyName
    )

/*++

Routine Description:

    Recursive worker routine used to do a depth-first traveral of a registry
    tree rooted at a given key.

Arguments:

    KeyHandle - handle for a registry tree.

    KeyName - name of the key for which KeyHandle is an open handle.
        This is one component long -- ie, no path separator characters appear.

    DesiredKeyName - supplies the name of the key we are looking for.

Return Value:

--*/

{
    ULONG SubKeyIndex;
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    PKEY_VALUE_PARTIAL_INFORMATION ValInfo;
    HANDLE hSubkey;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PWSTR SubkeyName;

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    ValInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

    //
    // Enumerate all subkeys of the current key.
    //
    for( SubKeyIndex=0;

         NT_SUCCESS(
            ZwEnumerateKey(
                KeyHandle,
                SubKeyIndex,
                KeyBasicInformation,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                &ResultLength
                )
            );

         SubKeyIndex++ )
    {
        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);

        if (SubkeyName) {
            //
            // Open this subkey.
            //
            INIT_OBJA(&Obja,&UnicodeString,SubkeyName);
            Obja.RootDirectory = KeyHandle;

            Status = ZwOpenKey(&hSubkey,KEY_READ,&Obja);

            if(NT_SUCCESS(Status)) {
                //
                // See if the current key's name matches the type we're looking for.
                //
                if(!_wcsicmp(KeyName,DesiredKeyName)) {

                    RtlInitUnicodeString(&UnicodeString,L"Identifier");

                    //
                    // Get the identifier string,
                    //
                    Status = ZwQueryValueKey(
                                hSubkey,
                                &UnicodeString,
                                KeyValuePartialInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &ResultLength
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Zero-terminate the id string value just in case.
                        // The data is a wstring, so there shouldn't be
                        // any alignment problems.
                        //
                        *(PWCHAR)(ValInfo->Data + ValInfo->DataLength) = 0;

                        //
                        // Now we have the identifier string -- save it.
                        //
                        IdStringArray = SpMemRealloc(
                                            IdStringArray,
                                            (IdStringCount+1) * sizeof(PWSTR)
                                            );

                        IdStringArray[IdStringCount++] = SpDupStringW((PWSTR)ValInfo->Data);

                    } else {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP: Unable to get identifier string in %ws\\%ws (%lx)\n",
                            KeyName,
                            SubkeyName,
                            Status
                            ));
                    }
                } else {

                    //
                    // Enumerate this subkey's subkeys.
                    //
                    SpScanHardwareDescriptionWorker(hSubkey,SubkeyName,DesiredKeyName);
                }

                ZwClose(hSubkey);
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Warning: unable to open key %ws\\%ws (%lx)\n",
                    KeyName,SubkeyName,Status));
            }

            SpMemFree(SubkeyName);
        }            
    }
}


VOID
SpFreeLocatedIdStrings(
    VOID
    )
{
    ULONG i;

    ASSERT(IdStringArray);

    for(i=0; i<IdStringCount; i++) {
        SpMemFree(IdStringArray[i]);
    }
    SpMemFree(IdStringArray);
    IdStringArray = NULL;
    IdStringCount = 0;
}



PHARDWARE_COMPONENT
SpSetupldrHwToHwDevice(
    IN PDETECTED_DEVICE SetupldrHw
    )
{
    PHARDWARE_COMPONENT HwComp,HwCompPrev,HwCompFirst=NULL;
    PHARDWARE_COMPONENT_FILE HwCompFile,HwCompFilePrev;
    PHARDWARE_COMPONENT_REGISTRY HwCompReg,HwCompRegPrev;
    PDETECTED_DEVICE_FILE SetupldrFile;
    PDETECTED_DEVICE_REGISTRY SetupldrReg;
    PWSTR s1,s2,s3,s4,s5;
    PVOID Buffer;
    ULONG BufferSize;

    if (SetupldrHw==NULL) {
        return(NULL);
    }
    HwCompPrev = NULL;
    for( ; SetupldrHw; SetupldrHw=SetupldrHw->Next) {

        //
        // Fetch and convert the two strings from the detected device structure.
        //
        s1 = SpToUnicode(SetupldrHw->IdString);
#ifdef UNICODE_SETUPLDR
        // cast this to avoid having to drag in tchar.h, etc.
        s2 = (PWSTR)SetupldrHw->Description;
#else
        s2 = SetupldrHw->Description ? SpToUnicode(SetupldrHw->Description) : NULL;
#endif
        s3 = SpToUnicode(SetupldrHw->BaseDllName);

        //
        // Create a new hardware component structure.
        //
        HwComp = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(HwComp,sizeof(HARDWARE_COMPONENT));

        //
        // Initialize the component structure.
        //
        SpInitHwComponent(
            HwComp,
            s1,
            s2,
            SetupldrHw->ThirdPartyOptionSelected,
            SetupldrHw->FileTypeBits,
            s3,
            SetupldrHw->MigratedDriver
            );

        //
        // Link the component structure into the list.
        //
        if(HwCompPrev) {
            HwCompPrev->Next = HwComp;
        } else {
            HwCompFirst = HwComp;
        }
        HwCompPrev = HwComp;

        //
        // Free the unicode strings.
        //
        SpMemFree(s1);
#ifndef UNICODE_SETUPLDR
        if(s2) {
            SpMemFree(s2);
        }
#endif
        SpMemFree(s3);

        //
        // Create new entries for each of the hardware component's files.
        //
        HwCompFilePrev = NULL;

        for(SetupldrFile=SetupldrHw->Files; SetupldrFile; SetupldrFile=SetupldrFile->Next) {
            //
            // We can't convert the ARC device name to NT device name since may may not have
            // the ARC <-> NT name map fully initialized yet
            //
            PWSTR ArcDeviceName = SetupldrFile->ArcDeviceName ? 
                                    SpToUnicode(SetupldrFile->ArcDeviceName) : NULL;

            //
            // Fetch and convert the 5 strings from the detected device file structure.
            //
            s1 = SpToUnicode(SetupldrFile->Filename);
#ifdef UNICODE_SETUPLDR
            // cast this to avoid having to drag in tchar.h, etc.
            s2 = (PWSTR)SetupldrFile->DiskDescription;
#else
            s2 = SpToUnicode(SetupldrFile->DiskDescription);
#endif
            s3 = SpToUnicode(SetupldrFile->DiskTagfile);
            s4 = SpToUnicode(SetupldrFile->Directory);
            if (SetupldrFile->ConfigName != NULL) {
                s5 = SpToUnicode(SetupldrFile->ConfigName);
            } else {
                s5 = NULL;
            }

            //
            // Create a new hardware component file structure.
            //
            HwCompFile = SpMemAlloc(sizeof(HARDWARE_COMPONENT_FILE));

            //
            // Initialize the component file structure.
            //
            SpInitHwComponentFile(HwCompFile,
                    s1,
                    SetupldrFile->FileType,
                    s5,
                    s2,
                    s3,
                    s4,
                    ArcDeviceName          
                    );

            //
            // Link the component file structure into the list.
            //
            if(HwCompFilePrev) {
                HwCompFilePrev->Next = HwCompFile;
            } else {
                HwComp->Files = HwCompFile;
            }
            HwCompFilePrev = HwCompFile;

            //
            // Free the unicode strings.
            //
            SpMemFree(s1);
#ifndef UNICODE_SETUPLDR
            SpMemFree(s2);
#endif
            SpMemFree(s3);
            SpMemFree(s4);
            if (s5 != NULL) {
                SpMemFree(s5);
            }

            if (ArcDeviceName) {
                SpMemFree(ArcDeviceName);
            }

            //
            // Create new entries for each registry value structure for this file.
            //
            HwCompRegPrev = NULL;
            for( SetupldrReg=SetupldrFile->RegistryValueList;
                 SetupldrReg;
                 SetupldrReg=SetupldrReg->Next)
            {
                //
                // Make a duplicate of the buffer.
                // Special case REG_SZ and REG_MULTI_SZ values because
                // we need to convert then to unicode.
                //
                if(SetupldrReg->ValueType == REG_SZ) {

                    Buffer = SpToUnicode(SetupldrReg->Buffer);
                    BufferSize = (wcslen(Buffer) + 1) * sizeof(WCHAR);

                } else {

                    if(SetupldrReg->ValueType == REG_MULTI_SZ) {

                        PUCHAR p;
                        ULONG len;

                        //
                        // Determine the size of the buffer needed to hold the unicode
                        // equivalent of the multi_sz.  Assume all characters are
                        // single-byte and thus the size exactly doubles.
                        //
                        for(BufferSize=sizeof(WCHAR),p=SetupldrReg->Buffer; *p; ) {

                            len = strlen(p) + 1;
                            BufferSize += len * sizeof(WCHAR);
                            p += len;
                        }

                        Buffer = SpMemAlloc(BufferSize);

                        //
                        // Convert each string in the multi_sz to unicode
                        // and place in the resulting unicode multi_sz.
                        //
                        for(s1=Buffer,p=SetupldrReg->Buffer; *p; ) {

                            s2 = SpToUnicode(p);
                            wcscpy(s1,s2);
                            SpMemFree(s2);

                            p  += strlen(p)  + 1;
                            s1 += wcslen(s1) + 1;
                        }

                        //
                        // Final terminating nul in the multi_sz.
                        //
                        *s1++ = 0;

                        //
                        // Reallocate the buffer. If some of the characters
                        // were double-byte, the buffer will be smaller than
                        // the maximum size we allocated above.
                        //
                        BufferSize = (ULONG)((PUCHAR)s1 - (PUCHAR)Buffer);
                        Buffer = SpMemRealloc(Buffer,BufferSize);

                    } else {

                        BufferSize = SetupldrReg->BufferSize;
                        Buffer = SpMemAlloc(BufferSize);
                        ASSERT(Buffer);
                        RtlMoveMemory(Buffer,SetupldrReg->Buffer,BufferSize);
                    }
                }

                //
                // Fetch and convert the 2 strings from the detected device
                // registry value structure.
                //
                s1 = SpToUnicode(SetupldrReg->KeyName);
                s2 = SpToUnicode(SetupldrReg->ValueName);

                //
                // Create a new registry value structure.
                //
                HwCompReg = SpMemAlloc(sizeof(HARDWARE_COMPONENT_REGISTRY));

                //
                // Initialize the component registry value structure.
                //
                SpInitHwComponentRegVal(
                    HwCompReg,
                    s1,
                    s2,
                    SetupldrReg->ValueType,
                    Buffer,
                    BufferSize
                    );

                //
                // Link the component registry value structure into the list.
                //
                if(HwCompRegPrev) {
                    HwCompRegPrev->Next = HwCompReg;
                } else {
                    HwCompFile->RegistryValueList = HwCompReg;
                }
                HwCompRegPrev = HwCompReg;

                //
                // Free the unicode strings.
                //
                SpMemFree(s1);
                SpMemFree(s2);
            }
        }
    }
    return(HwCompFirst);
}


VOID
SpInitHwComponent(
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               IdString,
    IN  PWSTR               Description,
    IN  BOOLEAN             ThirdPartyOption,
    IN  ULONG               FileTypeBits,
    IN  PWSTR               BaseDllName,
    IN  BOOLEAN             MigratedDriver
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT structure.

    Before initializing the fields, ther IdString and Description
    strings are freed if they are present in the given hardware
    component structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the hardware component
    structure.

Arguments:

    IdString - supplies a nul-terminated unicode string for the
        IdString field of the structure.  May be NULL.

    Description - supplies a nul-terminated unicode string for the
        Description field pf the structure.  May be NULL.

    ThirdPartyOption - supplies value of the ThirdPartyOptionSelected
        field of the strcture.

    FileTypeBits - supplies value for the FileTypeBits field
        of the structure.

Return Value:

    None.

--*/

{
    if(HwComp->IdString) {
        SpMemFree(HwComp->IdString);
    }

    if(HwComp->Description) {
        SpMemFree(HwComp->Description);
    }

    if(HwComp->BaseDllName) {
        SpMemFree(HwComp->BaseDllName);
    }

    RtlZeroMemory(HwComp,sizeof(HARDWARE_COMPONENT));

    if(IdString) {
        HwComp->IdString = SpDupStringW(IdString);
    }

    if(Description) {
        HwComp->Description = SpDupStringW(Description);
    }

    if(BaseDllName) {
        HwComp->BaseDllName = SpDupStringW(BaseDllName);
    }

    HwComp->ThirdPartyOptionSelected = ThirdPartyOption;

    HwComp->FileTypeBits = FileTypeBits;

    HwComp->MigratedDriver = MigratedDriver;

}


VOID
SpFreeHwComponent(
    IN OUT PHARDWARE_COMPONENT *HwComp,
    IN     BOOLEAN              FreeAllInList
    )
{
    PHARDWARE_COMPONENT hwComp,Next;

    for(hwComp = *HwComp; hwComp; hwComp=(FreeAllInList ? Next : NULL)) {

        SpFreeHwComponentFile(&hwComp->Files);

        if(hwComp->IdString) {
            SpMemFree(hwComp->IdString);
        }

        if(hwComp->Description) {
            SpMemFree(hwComp->Description);
        }

        if(hwComp->BaseDllName) {
            SpMemFree(hwComp->BaseDllName);
        }

        Next = hwComp->Next;
        SpMemFree(hwComp);
    }

    *HwComp = NULL;
}


VOID
SpFreeHwComponentFile(
    IN OUT PHARDWARE_COMPONENT_FILE *HwCompFile
    )

/*++

Routine Description:

    Free a hardware component file list and all resources used by it,
    including any registry value structures associated with the file
    and resources used by such structgures.

Arguments:

    HwCompFile - supplies pointer to pointer to the first hardware
        component file structure in a linked list.

Return Value:

    None.  HwCompFile is filled in with NULL to prevent the caller
        from retaining a 'dangling' pointer to memory that has been freed.

--*/

{
    PHARDWARE_COMPONENT_FILE hwCompFile,NextFile;

    for(hwCompFile = *HwCompFile ; hwCompFile; hwCompFile=NextFile) {

        if(hwCompFile->Filename) {
            SpMemFree(hwCompFile->Filename);
        }

        if(hwCompFile->ConfigName) {
            SpMemFree(hwCompFile->ConfigName);
        }

        if(hwCompFile->DiskDescription) {
            SpMemFree(hwCompFile->DiskDescription);
        }

        if(hwCompFile->DiskTagFile) {
            SpMemFree(hwCompFile->DiskTagFile);
        }

        if(hwCompFile->Directory) {
            SpMemFree(hwCompFile->Directory);
        }

        //
        // Free registry values as well.
        //
        SpFreeHwComponentReg(&hwCompFile->RegistryValueList);

        NextFile = hwCompFile->Next;
        SpMemFree(hwCompFile);
    }

    *HwCompFile = NULL;
}


VOID
SpInitHwComponentFile(
    OUT PHARDWARE_COMPONENT_FILE HwCompFile,
    IN  PWSTR                    Filename,
    IN  HwFileType               FileType,
    IN  PWSTR                    ConfigName,
    IN  PWSTR                    DiskDescription,
    IN  PWSTR                    DiskTagFile,
    IN  PWSTR                    Directory,
    IN  PWSTR                    ArcDeviceName
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT_FILE structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the
    hardware component file structure.

Arguments:

    Filename - supplies a nul-terminated unicode string for the
        Filename field of the structure.  May be NULL.

    FileType - supplies value for the FileType field of the structure.

    ConfigName - supplies a nul-terminated unicode string for the
        ConfigName field of the structure.  May be NULL.

    DiskDescription - supplies a nul-terminated unicode string for the
        DiskDescription field of the structure.  May be NULL.

    DiskTagFile - supplies a nul-terminated unicode string for the
        DiskTagFile field of the structure.  May be NULL.

    Directory - supplies a nul-terminated unicode string for the
        Directory field of the structure.  May be NULL.

    ArcDeviceName - supplies the arc device name where the file
        resides.

Return Value:

    None.

--*/

{
    RtlZeroMemory(HwCompFile,sizeof(HARDWARE_COMPONENT_FILE));

    if(Filename) {
        HwCompFile->Filename = SpDupStringW(Filename);
    }

    HwCompFile->FileType = FileType;

    if(ConfigName) {
        HwCompFile->ConfigName = SpDupStringW(ConfigName);
    }

    if(DiskDescription) {
        HwCompFile->DiskDescription = SpDupStringW(DiskDescription);
    }

    if(DiskTagFile) {
        HwCompFile->DiskTagFile = SpDupStringW(DiskTagFile);
    }

    if(Directory) {
        HwCompFile->Directory = SpDupStringW(Directory);
    }

    if (ArcDeviceName) {
        HwCompFile->ArcDeviceName = SpDupStringW(ArcDeviceName);
    }
}


VOID
SpFreeHwComponentReg(
    IN OUT PHARDWARE_COMPONENT_REGISTRY *HwCompReg
    )

/*++

Routine Description:

    Free a hardware component registry value list and all resources
    used by it.

Arguments:

    HwCompReg - supplies pointer to pointer to the first hardware
        component registry value structure in a linked list.

Return Value:

    None.  HwCompReg is filled in with NULL to prevent the caller
        from retaining a 'dangling' pointer to memory that has been freed.

--*/

{
    PHARDWARE_COMPONENT_REGISTRY hwCompReg,NextReg;

    for(hwCompReg = *HwCompReg ; hwCompReg; hwCompReg=NextReg) {

        if(hwCompReg->KeyName) {
            SpMemFree(hwCompReg->KeyName);
        }

        if(hwCompReg->ValueName) {
            SpMemFree(hwCompReg->ValueName);
        }

        if(hwCompReg->Buffer) {
            SpMemFree(hwCompReg->Buffer);
        }

        NextReg = hwCompReg->Next;
        SpMemFree(hwCompReg);
    }

    *HwCompReg = NULL;
}


VOID
SpInitHwComponentRegVal(
    OUT PHARDWARE_COMPONENT_REGISTRY HwCompReg,
    IN  PWSTR                        KeyName,
    IN  PWSTR                        ValueName,
    IN  ULONG                        ValueType,
    IN  PVOID                        Buffer,
    IN  ULONG                        BufferSize
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT_REGISTRY structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the
    hardware component file structure.

Arguments:

    KeyName - supplies a nul-terminated unicode string for the
        KeyName field of the structure.  May be NULL.

    ValueName - supplies a nul-terminated unicode string for the
        ValueName field of the structure.  May be NULL.

    ValueType - supplies value for the ValueType field of the structure.

    Buffer - supplies value for the Buffer field of the structure.

    BufferSize - supplies value for the BufferSize field of the structure.

Return Value:

    None.

--*/

{
    RtlZeroMemory(HwCompReg,sizeof(HARDWARE_COMPONENT_REGISTRY));

    if(KeyName) {
        HwCompReg->KeyName = SpDupStringW(KeyName);
    }

    if(ValueName) {
        HwCompReg->ValueName = SpDupStringW(ValueName);
    }

    HwCompReg->ValueType  = ValueType;
    HwCompReg->Buffer     = Buffer;
    HwCompReg->BufferSize = BufferSize;
}



PHARDWARE_COMPONENT_REGISTRY
SpInterpretOemRegistryData(
    IN PVOID          SifHandle,
    IN PWSTR          SectionName,
    IN ULONG          Line,
    IN ULONG          ValueType,
    IN PWSTR          KeyName,
    IN PWSTR          ValueName
    )
{
    PHARDWARE_COMPONENT_REGISTRY Reg;
    PWSTR Value;
    unsigned i,len;
    ULONG Dword;
    ULONG BufferSize;
    PVOID Buffer = NULL;
    PWSTR BufferWstr;
    WCHAR str[3];

    //
    // Perform appropriate action based on the type
    //

    switch(ValueType) {

    case REG_DWORD:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Make sure it's really a hex number
        //

        len = wcslen(Value);
        if(len > 8) {
            goto x1;
        }
        for(i=0; i<len; i++) {
            if(!SpIsXDigit(Value[i])) {
                goto x1;
            }
        }

        //
        // convert it from unicode to a hex number
        //
        Dword = (ULONG)SpStringToLong(Value,NULL,16);

        //
        // Allocate a 4-byte buffer and store the dword in it
        //

        Buffer = SpMemAlloc(BufferSize = sizeof(ULONG));
        *(PULONG)Buffer = Dword;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Allocate a buffer of appropriate size for the string
        //

        Buffer = SpDupStringW(Value);
        BufferSize = (wcslen(Value)+1) * sizeof(WCHAR);

        break;

    case REG_BINARY:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Figure out how many byte values are specified
        //

        len = wcslen(Value);
        if(len & 1) {
            goto x1;            // odd # of characters
        }

        //
        // Allocate a buffer to hold the byte values
        //

        Buffer = SpMemAlloc(BufferSize = len / 2);

        //
        // For each digit pair, convert to a hex number and store in the
        // buffer
        //

        str[2] = 0;

        for(i=0; i<len; i+=2) {

            //
            // SpIsXDigit evaluates args more than once so break out assignments.
            //
            str[0] = SpToUpper(Value[i]);
            str[1] = SpToUpper(Value[i+1]);
            if(!SpIsXDigit(str[0]) || !SpIsXDigit(str[1])) {
                goto x1;
            }

            ((PUCHAR)Buffer)[i/2] = (UCHAR)SpStringToLong(str,NULL,16);
        }

        break;

    case REG_MULTI_SZ:

        //
        // Calculate size of the buffer needed to hold all specified strings
        //

        for(BufferSize=sizeof(WCHAR),i=0;
            Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            BufferSize += (wcslen(Value)+1) * sizeof(WCHAR);
        }

        //
        // Allocate a buffer of appropriate size
        //

        Buffer = SpMemAlloc(BufferSize);
        BufferWstr = Buffer;

        //
        // Store each string in the buffer, converting to wide char format
        // in the process
        //

        for(i=0;
            Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            wcscpy(BufferWstr,Value);
            BufferWstr += wcslen(Value) + 1;
        }

        //
        // Place final terminating widechar nul in the buffer
        //

        *BufferWstr = 0;

        break;

    default:
    x1:

        //
        // Error - bad type specified or maybe we detected bad data values
        // and jumped here
        //

        if(Buffer) {
            SpMemFree(Buffer);
        }
        return(NULL);
    }

    Reg = SpMemAlloc(sizeof(HARDWARE_COMPONENT_REGISTRY));

    SpInitHwComponentRegVal(Reg,KeyName,ValueName,ValueType,Buffer,BufferSize);

    return(Reg);
}



VOID
SpDetectScsi(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    BOOLEAN DetectScsi;
    BOOLEAN b;
    ULONG DriverLoadCount;
    ULONG d;
    NTSTATUS Status;
    PWSTR DriverDescription,DriverFilename;
    PWSTR DriverShortname,DiskDesignator;
    PHARDWARE_COMPONENT scsi,Prev;
    PWSTR PreviousDiskDesignator;

    //
    // Determine the name of the scsi section.
    // This is a remnant from the time when we had separate
    // lists for isa, eisa, and mca machines.
    //
    ScsiSectionName = SpDupStringW(L"SCSI");
    ScsiLoadSectionName = SpDupStringW(L"SCSI.Load");

    LoadedScsiMiniportCount = 0;

    //
    // If scsi drivers have already been loaded, assume setupldr
    // did the detection and skip the scsi confirmation screen.
    //
    if(SetupParameters.LoadedScsi) {

        DetectScsi = FALSE;

        //
        // Fill in descriptions, ignoring what setupldr may have put in
        // the device descriptor.
        //
        for(scsi=ScsiHardware; scsi; scsi=scsi->Next) {

            if(scsi->ThirdPartyOptionSelected) {
                ASSERT(scsi->Description);
                if(!scsi->Description) {

                }
            } else if(scsi->MigratedDriver) {
                if(scsi->Description) {
                    SpMemFree(scsi->Description);
                }

                SpFormatMessage( TemporaryBuffer,
                                 sizeof(TemporaryBuffer),
                                 SP_TEXT_MIGRATED_DRIVER,
                                 scsi->BaseDllName );
                scsi->Description = SpDupStringW( TemporaryBuffer );

            } else {
                if(scsi->Description) {
                    SpMemFree(scsi->Description);
                }

                scsi->Description = SpGetSectionKeyIndex(
                                        SifHandle,
                                        ScsiSectionName,
                                        scsi->IdString,
                                        INDEX_DESCRIPTION
                                        );

                if(!scsi->Description) {
                    SpFatalSifError(SifHandle,ScsiSectionName,scsi->IdString,0,INDEX_DESCRIPTION);
                }
            }
        }


    } else {

        //
        // Scsi drivers have not been loaded.
        // Assume we need to perform detection and confirmation here.
        //

        //
        // If this is a custom setup, ask the user if he wants to skip detection.
        // We do this because loading some miniports can whack the hardware such
        // that the machine hangs.
        //
        if(CustomSetup) {

            ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
            ULONG Mnemonics[2] = { MnemonicSkipDetection,0 };

            do {
                SpDisplayScreen(SP_SCRN_CONFIRM_SCSI_DETECT,3,HEADER_HEIGHT+1);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_F3_EQUALS_EXIT,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_S_EQUALS_SKIP_DETECTION,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

                case KEY_F3:

                    SpConfirmExit();
                    b = TRUE;
                    break;

                case ASCI_CR:

                    DetectScsi = TRUE;
                    b = FALSE;
                    break;

                default:

                    //
                    // Must be MnemonicSkipDetection.
                    //
                    DetectScsi = FALSE;
                    b = FALSE;
                    break;
                }
            } while(b);

        } else {

            //
            // Express Setup; always detect scsi.
            //
            DetectScsi = TRUE;
        }
    }

    //
    // If we are supposed to detect scsi, do that here.
    // We will 'detect' scsi by loading scsi miniport drivers.
    //
    if(DetectScsi) {

        ASSERT(ScsiHardware == NULL);

        CLEAR_CLIENT_SCREEN();

        //
        // Determine the number of drivers to be loaded.
        //
        PreviousDiskDesignator = L"";
        Prev = NULL;
        DriverLoadCount = SpCountLinesInSection(SifHandle,ScsiLoadSectionName);
        for(d=0; (d<DriverLoadCount) && (LoadedScsiMiniportCount < MAX_SCSI_MINIPORT_COUNT); d++) {

            PWSTR p;

            //
            // Determine whether we are really supposed to load this driver.
            //
            if((p = SpGetSectionLineIndex(SifHandle,ScsiLoadSectionName,d,2)) && !_wcsicmp(p,L"noload")) {
                continue;
            }

            //
            // Get the driver shortname.
            //
            DriverShortname = SpGetKeyName(SifHandle,ScsiLoadSectionName,d);
            if(!DriverShortname) {
                SpFatalSifError(SifHandle,ScsiLoadSectionName,NULL,d,(ULONG)(-1));
            }

            //
            // Get parameters used to load the driver.
            //
            SpGetDriverValuesForLoad(
                SifHandle,
                ScsiSectionName,
                ScsiLoadSectionName,
                DriverShortname,
                &DriverFilename,
                &DiskDesignator,
                &DriverDescription
                );

            //
            // Prompt for the disk containing the driver.
            //
            retryload:
            if(_wcsicmp(DiskDesignator,PreviousDiskDesignator)) {

                ULONG i;

                SpPromptForSetupMedia(
                    SifHandle,
                    DiskDesignator,
                    SourceDevicePath
                    );

                //
                // Redraw the found list.
                //
                CLEAR_CLIENT_SCREEN();
                for(i=0,scsi=ScsiHardware; scsi; scsi=scsi->Next,i++) {
                    SpDisplayFormattedMessage(
                        SP_TEXT_FOUND_ADAPTER,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE,
                        4,
                        HEADER_HEIGHT+4+i,
                        scsi->Description
                        );
                }

                PreviousDiskDesignator = DiskDesignator;
            }

            //
            // Attempt to load the driver.
            //
            Status = SpLoadDeviceDriver(
                        DriverDescription,
                        SourceDevicePath,
                        DirectoryOnSourceDevice,
                        DriverFilename
                        );

            //
            // If the driver loaded, remember it.
            //
            if(NT_SUCCESS(Status)) {

                SpDisplayFormattedMessage(
                    SP_TEXT_FOUND_ADAPTER,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    4,
                    HEADER_HEIGHT+4+LoadedScsiMiniportCount,
                    DriverDescription
                    );

                LoadedScsiMiniportCount++;

                scsi = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
                RtlZeroMemory(scsi,sizeof(HARDWARE_COMPONENT));

                SpInitHwComponent(scsi,DriverShortname,DriverDescription,FALSE,0,NULL,FALSE);

                //
                // Link the hardware description into the list.
                //
                if(Prev) {
                    Prev->Next = scsi;
                } else {
                    ScsiHardware = scsi;
                }
                Prev = scsi;
            } else {
                if(Status == STATUS_NO_MEDIA_IN_DEVICE) {
                    PreviousDiskDesignator = L"";
                    goto retryload;
                }
            }
        }

    } else {

        //
        // Count the number of loaded miniport drivers.
        //
        for(scsi=ScsiHardware; scsi; scsi=scsi->Next) {
            LoadedScsiMiniportCount++;
        }
    }
}


VOID
SpConfirmScsiInteract(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG Mnemonics[2] = { MnemonicScsiAdapters,0 };
    ULONG ListTopY;
    PHARDWARE_COMPONENT scsi;
    ULONG i;
    BOOLEAN ScsiConfirmed;
    BOOLEAN b;
    BOOLEAN AddDriver;
    NTSTATUS Status;

    #define SCSI_LIST_LEFT_X  7

    //
    // In unattended mode, we might skip this
    // depending on the unattended script.
    //
    if(UnattendedOperation) {

        if( !PreInstall ) {
            PWSTR p;

            p = SpGetSectionKeyIndex(
                    UnattendedSifHandle,
                    SIF_UNATTENDED,
                    SIF_CONFIRMHW,
                    0
                    );

            //
            // If not specified or specified and not "yes"
            // then return.
            //
            if(!p || _wcsicmp(p,L"yes")) {
                return;
            }
        } else {
            return;
        }
    } else if (LoadedScsiMiniportCount) {
        return;
    }

    ScsiConfirmed = FALSE;
    do {
        //
        // First part of the screen.
        //
        SpDisplayScreen(SP_SCRN_SCSI_LIST_1,3,HEADER_HEIGHT+1);

        //
        // Remember where the first part of the screen ends.
        //
        ListTopY = NextMessageTopLine + 2;

        //
        // Second part of the screen.
        //
        SpContinueScreen(
            SP_SCRN_SCSI_LIST_2,
            3,
            MAX_SCSI_MINIPORT_COUNT+6,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        //
        // Display each loaded miniport driver description.
        //
        if(ScsiHardware) {
            for(i=0,scsi=ScsiHardware; scsi; scsi=scsi->Next,i++) {

                if(i == MAX_SCSI_MINIPORT_COUNT) {

                    SpvidDisplayString(
                        L"...",
                        DEFAULT_ATTRIBUTE,
                        SCSI_LIST_LEFT_X,
                        ListTopY+i
                        );

                    break;
                }

                SpvidDisplayString(
                    scsi->Description,
                    DEFAULT_ATTRIBUTE,
                    SCSI_LIST_LEFT_X,
                    ListTopY+i
                    );
            }
        } else {

            SpDisplayFormattedMessage(
                SP_TEXT_ANGLED_NONE,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                SCSI_LIST_LEFT_X,
                ListTopY
                );
        }

        //
        // display status text options.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_S_EQUALS_SCSI_ADAPTER,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for the user to press a valid key.
        //
        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case ASCI_CR:

            ScsiConfirmed = TRUE;
            break;

        case KEY_F3:

            SpConfirmExit();
            break;

        default:

            //
            // Must be s=specify additional adapter.
            //

            AddDriver = FALSE;

            scsi = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
            RtlZeroMemory(scsi,sizeof(HARDWARE_COMPONENT));

            b = SpSelectHwItem(
                    SifHandle,
                    ScsiSectionName,
                    L"Scsi",
                    SP_SCRN_SELECT_SCSI,
                    SP_SCRN_SELECT_OEM_SCSI,
                    SCSI_ALLOWED_FILETYPES,
                    SCSI_REQUIRED_FILETYPES,
                    scsi
                    );

            if(b) {
                //
                // User made a selection. Determine whether that scsi adapter
                // is already on the list for instllation.
                //
                PHARDWARE_COMPONENT p;

                b = FALSE;
                for(p=ScsiHardware; p; p=p->Next) {

                    if((p->ThirdPartyOptionSelected == scsi->ThirdPartyOptionSelected)
                    && !_wcsicmp(p->IdString,scsi->IdString))
                    {
                        b = TRUE;
                        break;
                    }
                }

                if(b) {
                    //
                    // The driver is already loaded -- silently ignore the user's selection.
                    //
                    #if 0
                    //
                    // This driver is already loaded -- tell the user.
                    //
                    SpDisplayScreen(SP_SCRN_SCSI_ALREADY_LOADED,3,HEADER_HEIGHT+1);
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_CONTINUE,
                        0
                        );

                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;
                    #endif

                } else {

                    PWSTR DiskDevicePath;
                    PWSTR DirectoryOnDisk;
                    PWSTR DriverFilename;
                    PWSTR Media;

                    //
                    // The driver is not loaded.  Atempt to load it.
                    //
                    if(scsi->ThirdPartyOptionSelected) {

                        PHARDWARE_COMPONENT_FILE fil;

                        //
                        // Locate the first file of type driver or port.
                        //
                        for(fil=scsi->Files; fil; fil=fil->Next) {
                            if((fil->FileType == HwFileDriver) || (fil->FileType == HwFilePort)) {

                                DirectoryOnDisk = fil->Directory;
                                DriverFilename = fil->Filename;
                                break;
                            }
                        }

                        DiskDevicePath = L"\\device\\floppy0";

                    } else {

                        DiskDevicePath = SourceDevicePath;
                        DirectoryOnDisk = DirectoryOnSourceDevice;

                        SpGetDriverValuesForLoad(
                            SifHandle,
                            ScsiSectionName,
                            ScsiLoadSectionName,
                            scsi->IdString,
                            &DriverFilename,
                            &Media,
                            NULL
                            );

                        SpPromptForSetupMedia(
                            SifHandle,
                            Media,
                            DiskDevicePath
                            );
                    }

                    CLEAR_CLIENT_SCREEN();

                    Status = SpLoadDeviceDriver(
                                scsi->Description,
                                DiskDevicePath,
                                DirectoryOnDisk,
                                DriverFilename
                                );

                    //
                    // If the driver did not load, tell the user.
                    //
                    if(NT_SUCCESS(Status)) {
                        AddDriver = TRUE;
                    } else {
                        SpDisplayScreen(SP_SCRN_SCSI_DIDNT_LOAD,3,HEADER_HEIGHT+1);
                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        SpInputDrain();
                        while(SpInputGetKeypress() != ASCI_CR) ;
                    }
                }
            }

            if(AddDriver) {

                if(ScsiHardware) {

                    PHARDWARE_COMPONENT p = ScsiHardware;

                    while(p->Next) {
                        p = p->Next;
                    }
                    p->Next = scsi;

                } else {
                    ScsiHardware = scsi;
                }

                LoadedScsiMiniportCount++;

            } else {
                SpFreeHwComponent(&scsi,TRUE);
            }

            break;
        }
    } while(!ScsiConfirmed);
}


VOID
SpGetDriverValuesForLoad(
    IN  PVOID  SifHandle,
    IN  PWSTR  ComponentSectionName,
    IN  PWSTR  ComponentLoadSectionName,
    IN  PWSTR  Shortname,
    OUT PWSTR *Filename,
    OUT PWSTR *MediaDesignator,
    OUT PWSTR *Description OPTIONAL
    )
{
    PWSTR description,mediaDesignator,filename;

    //
    // Get the filename associated with this load option.
    //
    filename = SpGetSectionKeyIndex(SifHandle,ComponentLoadSectionName,Shortname,0);
    if(!filename) {
        SpFatalSifError(SifHandle,ComponentLoadSectionName,Shortname,0,0);
    }

    //
    // Look up the description in the component section.
    //
    description = SpGetSectionKeyIndex(
                        SifHandle,
                        ComponentSectionName,
                        Shortname,
                        INDEX_DESCRIPTION
                        );

    if(!description) {
        SpFatalSifError(SifHandle,ComponentSectionName,Shortname,0,INDEX_DESCRIPTION);
    }

    //
    // Look up the media designator.  If we are loading the driver for use
    // during setup, we want to get it from the setup boot media.
    //
    mediaDesignator = SpLookUpValueForFile(SifHandle,filename,INDEX_WHICHBOOTMEDIA,TRUE);

    //
    // Pass information back to caller.
    //
    *Filename = filename;
    *MediaDesignator = mediaDesignator;
    if(Description) {
        *Description = description;
    }
}


BOOLEAN
SpInstallingMp(
    VOID
    )
{
    PWSTR ComputerId;
    ULONG ComputerIdLen;

    ComputerId = HardwareComponents[HwComponentComputer]->IdString;
    ComputerIdLen = wcslen(ComputerId);

    //
    // If _up is specified use the up kernel.  Otherwise use the mp kernel.
    //
    if((ComputerIdLen >= 3) && !_wcsicmp(ComputerId+ComputerIdLen-3,L"_mp")) {

        return(TRUE);
    }

    return(FALSE);
}



PHARDWARE_COMPONENT
SpGetPreinstallComponentInfo(
    IN HANDLE       MasterSifHandle,
    IN BOOLEAN      OemComponent,
    IN PWSTR        ComponentName,
    IN PWSTR        Description,
    IN ULONG        AllowedFileTypes,
    IN ULONG        RequiredFileTypes
    )

/*++

Routine Description:

    Initialize a structure that contains the information about a
    component to be pre-installed.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    OemComponent - Flag that indicates if the component to be pre-installed
                   is an OEM or retail component.

    ComponentName - Name of the component whose information will be retrieved
                    (Computer, Display, Keyboard, Keyboard Layout and Mouse ).

    AllowedFileTypes -

    RequiredFileTypes -


Return Value:

    Returns a pointer to an initialized HARDWARE_COMPONENT structure.

--*/


{
    PHARDWARE_COMPONENT TempHwComponent;
    PWSTR               IdString;
    ULONG ValidKeys[2] = { KEY_F3,0 };


    TempHwComponent = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(TempHwComponent,sizeof(HARDWARE_COMPONENT));

    if( !OemComponent ) {
        //
        //  Pre-install a retail component
        //
        IdString = SpGetKeyNameByValue( MasterSifHandle,
                                        ComponentName,
                                        Description );
        if( IdString == NULL ) {
            //
            //  This is a fatal error
            //
            SpStartScreen( SP_SCRN_OEM_PREINSTALL_VALUE_NOT_FOUND,
                           3,
                           HEADER_HEIGHT+3,
                           FALSE,
                           FALSE,
                           DEFAULT_ATTRIBUTE,
                           Description,
                           ComponentName);

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpWaitValidKey(ValidKeys,NULL,NULL);

            SpDone(0,FALSE,TRUE);

            return NULL;    // for prefix
        }
        
        SpInitHwComponent(TempHwComponent,IdString,Description,FALSE,0,NULL,FALSE);

    } else {
        //
        //  Pre-install an OEM component
        //
        IdString = SpGetKeyNameByValue( PreinstallOemSifHandle,
                                        ComponentName,
                                        Description );
        if( IdString == NULL ) {
            //
            //  Put a fatal error message indicating that txtsetup.oem
            //  is needed but that it couldn't be loaded. Note that the
            //  that SpOemInfError() will not return.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,
                          SP_TEXT_OEM_INF_ERROR_B,
                          ComponentName,
                          0,
                          Description);

            // SpDone(0,FALSE,TRUE);
        }
        if( !SpOemInfSelection( PreinstallOemSifHandle,
                                ComponentName,
                                IdString,
                                Description,
                                AllowedFileTypes,
                                RequiredFileTypes,
                                TempHwComponent,
                                SP_SCRN_OEM_PREINSTALL_INF_ERROR ) ) {

            //
            //  This case shoud never occur, becase in case of error,
            //  SpOemInfSelection will not return.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemInfSelection() in pre-install mode failed \n" ));
            ASSERT(FALSE);
            // SpDone(0,FALSE,TRUE);
        }
    }
    return( TempHwComponent );
}


VOID
SpInitializePreinstallList(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        OemPreinstallSourcePath
    )

/*++

Routine Description:

    Initialize the structures that contains the information about the
    components to be pre-installed.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    OemDirectoryOnSourceDevice - Directory on the media where the OEM
                                 components are loacted.


Return Value:

    NONE.

--*/

{
    PWSTR       TxtsetupOemPath;
    PWSTR       p;
    PWSTR       OemTag = L"OEM";
    BOOLEAN     OemComponent;
    NTSTATUS    Status;
    PHARDWARE_COMPONENT TempHwComponent;
    PWSTR       IdString;
    PWSTR       Description;
    ULONG       ErrorLine;
    ULONG       i,j;
#ifdef _X86_
    PWSTR       r, s;
#endif

#ifdef _X86_

    //
    //  First, we need to check if the directory '\$' exists on the root.
    //  if it does, we need to move it to (\$win_nt$.~ls\$OEM$).
    //  This will happen only when winnt.exe (DOS) was used in the installation
    //  process.
    //  Winnt.exe copies the $OEM$ to the '\$', in order to avoid hitting the
    //  DOS limitiation for the length of a path (maximum of 64 characters).
    //
    wcscpy(TemporaryBuffer, SetupSourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_DEST_DIR_W );    
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            wcscpy(TemporaryBuffer, SetupSourceDevicePath);
            SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
            s = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );

            if( s != NULL ) {
                *s = (WCHAR)'\0';
            }

            s = SpDupStringW(TemporaryBuffer);

            if (s) {
                Status = SpMoveFileOrDirectory( r, s );
                
                SpMemFree( s );
            } else {
                Status = STATUS_NO_MEMORY;
            }                

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Unable to move directory %ws to %ws. Status = %lx \n", 
                    r, s, Status ));
            }
        }

        SpMemFree( r );
    }

#endif

    //
    //  Attempt to load txtsetup.oem
    //
    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, OemPreinstallSourcePath );
    SpConcatenatePaths( TemporaryBuffer, L"txtsetup.oem" );
    TxtsetupOemPath = SpDupStringW( TemporaryBuffer );

    CLEAR_CLIENT_SCREEN();

    HandleLineContinueChars = FALSE;
    Status = SpLoadSetupTextFile(
                TxtsetupOemPath,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &PreinstallOemSifHandle,
                &ErrorLine,
                TRUE,
                FALSE
                );
    HandleLineContinueChars = TRUE;

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read txtsetup.oem. Status = %lx \n", Status ));

        PreinstallOemSifHandle = NULL;

        if(Status == STATUS_UNSUCCESSFUL) {
            //
            //  Put an fatal error. On pre-install mode, the function will
            //  never come back.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,ErrorLine,NULL);
            return;
        } else {
            //
            //  Unable to load txtsetup.oem. Don't put an error message yet.
            //  Wait until we know that the file is needed.
            //
        }
    }

    for( j = 0; j < HwComponentMax; j++ ) {
        PreinstallHardwareComponents[j] = NULL;
        if( ( j == HwComponentComputer ) || ( j == HwComponentLayout ) ) {

            Description = SpGetSectionKeyIndex(UnattendedSifHandle,
                                               SIF_UNATTENDED,
                                               PreinstallSectionNames[j],
                                               0);

            if( Description != NULL ) {
                if( j != HwComponentLayout ) {
                    p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                             SIF_UNATTENDED,
                                             PreinstallSectionNames[j],
                                             1);

                    OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

                    if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
                        //
                        //  Put a fatal error message indicating that txtsetup.oem
                        //  is needed but that it couldn't be loaded. Note that the
                        //  SpOemInfError() will not return.
                        //
                        SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
                        // return;
                    }
                } else {
                    OemComponent = FALSE;
                }

                PreinstallHardwareComponents[j] =
                    SpGetPreinstallComponentInfo( MasterSifHandle,
                                                  OemComponent,
                                                  NonlocalizedComponentNames[j],
                                                  Description,
                                                  AllowedFileTypes[j],
                                                  RequiredFileTypes[j] );
            }
        } else {

            for( i = 0;
                 Description = SpGetKeyName( UnattendedSifHandle,
                                             PreinstallSectionNames[j],
                                             i );
                 i++ ) {

                p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                         PreinstallSectionNames[j],
                                         Description,
                                         0);

                OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

                if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
                    //
                    //  Put a fatal error message indicating that txtsetup.oem
                    //  is needed but that it couldn't be loaded. Note that the
                    //  SpOemInfError() will not return.
                    //
                    SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
                    // return;
                }

                TempHwComponent =
                    SpGetPreinstallComponentInfo( MasterSifHandle,
                                                  OemComponent,
                                                  NonlocalizedComponentNames[j],
                                                  Description,
                                                  AllowedFileTypes[j],
                                                  RequiredFileTypes[j] );

                TempHwComponent->Next = PreinstallHardwareComponents[j];
                PreinstallHardwareComponents[j] = TempHwComponent;
            }
        }
    }


    //
    //  Note that there is no need to get the information about the scsi
    //  drivers to pre-install, ScsiHardware already contains the correct
    //  information.
    //

// #if 0
    for( i = 0;
         Description = SpGetKeyName( UnattendedSifHandle,
                                     WINNT_OEMSCSIDRIVERS_W,
                                     i );
         i++ ) {

        p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                 WINNT_OEMSCSIDRIVERS_W,
                                 Description,
                                 0);

        OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

        if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
            //
            //  Put a fatal error message indicating that txtsetup.oem
            //  is needed but that it couldn't be loaded. Note that the
            //  SpOemInfError() will not return.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
            // return;
        }

        TempHwComponent =
            SpGetPreinstallComponentInfo( MasterSifHandle,
                                          OemComponent,
                                          L"SCSI",
                                          Description,
                                          SCSI_ALLOWED_FILETYPES,
                                          SCSI_REQUIRED_FILETYPES );

        TempHwComponent->Next = PreinstallScsiHardware;
        PreinstallScsiHardware = TempHwComponent;
    }


// #endif
}


PSETUP_PNP_HARDWARE_ID
SpSetupldrPnpDatabaseToSetupPnpDatabase(
    IN PPNP_HARDWARE_ID AnsiHardwareIdDatabase
    )

{
    PPNP_HARDWARE_ID        TempAnsiId;
    PSETUP_PNP_HARDWARE_ID  TempUnicodeId;
    PSETUP_PNP_HARDWARE_ID  UnicodeHardwareIdDatabase;
#if 0
    ULONG   Index;
#endif


    UnicodeHardwareIdDatabase = NULL;
    for( TempAnsiId = AnsiHardwareIdDatabase; TempAnsiId != NULL; TempAnsiId = TempAnsiId->Next ) {

        TempUnicodeId = SpMemAlloc( sizeof( SETUP_PNP_HARDWARE_ID ) );
        ASSERT(TempUnicodeId);
        RtlZeroMemory( TempUnicodeId, sizeof(SETUP_PNP_HARDWARE_ID ) );

        TempUnicodeId->Id = SpToUnicode( TempAnsiId->Id );
        ASSERT(TempUnicodeId->Id);
        TempUnicodeId->DriverName = SpToUnicode( TempAnsiId->DriverName );
        ASSERT(TempUnicodeId->DriverName);
        if( TempAnsiId->ClassGuid != NULL ) {
            TempUnicodeId->ClassGuid = SpToUnicode( TempAnsiId->ClassGuid );
        } else {
            TempUnicodeId->ClassGuid = NULL;
        }
        TempUnicodeId->Next = UnicodeHardwareIdDatabase;
        UnicodeHardwareIdDatabase = TempUnicodeId;

    }

#if 0
    for( TempUnicodeId = UnicodeHardwareIdDatabase, Index = 0;
         TempUnicodeId != NULL;
         TempUnicodeId = TempUnicodeId->Next, Index++ ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Index = %d, Id = %ls, DriverName = %ls, ClassGUID = %ls \n", Index, TempUnicodeId->Id, TempUnicodeId->DriverName, ((TempUnicodeId->ClassGuid)? TempUnicodeId->ClassGuid : none)));
    }
#endif
    return( UnicodeHardwareIdDatabase );
}

BOOLEAN
SpSelectSectionItem(
    IN    PVOID   SifHandle,
    IN    PWSTR   SectionName,
    IN    ULONG   SelectScreenId,
    IN    ULONG   DefaultSelection OPTIONAL,
    OUT   PULONG  SelectedOption
    )
/*++

Routine Description:

    Allow the user to make selection from a list of choices for a component.

    The list comes from a section in the setup information file named
    for the component.  For example, [Display].

    The descriptions in that section will be placed into a menu to make
    up the selections.
    
Arguments:

    SifHandle - supplies handle to open setup information file.

    SectionName - supplies name of section to be used.

    SelectHwScreenId - supplies message id of the screen prompting the user
        to select an option for this section.

    DefaultSelection - Item index, which should be highlighted as the default
        choice when the menu is shown
    
    SelectedOption - Returns the selected option        

Return Value:

    TRUE if a valid option is selected, otherwise FALSE

--*/
{
  BOOLEAN Result;
  ULONG LineCount,Line;
  PVOID Menu;
  ULONG MenuTopY,MenuHeight,MenuWidth;
  PWSTR Description;
  ULONG_PTR Selection;
  ULONG ValidKeys[4] = {ASCI_CR, ASCI_ESC, 0};
  ULONG Keypress;

  //
  // Display the selection prompt screen.
  //
  SpDisplayScreen(SelectScreenId, 5, HEADER_HEIGHT+1);

  MenuTopY = NextMessageTopLine + 2;
  MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
  MenuWidth = VideoVars.ScreenWidth - 6;

  //
  // Create a menu.
  //
  Menu = SpMnCreate(3, MenuTopY, MenuWidth, MenuHeight);
  Result = (Menu != NULL);
  
  //
  // Assume unknown option.
  //
  Selection = (ULONG_PTR)(-1);
  
  //
  // Build a list of options containing the options in our box
  //
  LineCount = SpCountLinesInSection(SifHandle, SectionName);

  for(Line=0; (Line < LineCount) && Result; Line++) {
      //
      // Get the description from the current line and add it to the menu.
      //
      Description = SpGetSectionLineIndex(
                          SifHandle,
                          SectionName,
                          Line,
                          INDEX_DESCRIPTION
                          );

      if(!Description) {
        Result = FALSE;

        break;              
      }

      SpMnAddItem(Menu, Description, 3, VideoVars.ScreenWidth-6, TRUE, Line);

      //
      // See if this is the currently selected item.
      //
      if((DefaultSelection != -1) && (DefaultSelection == Line)) {
        Selection = Line;
      }
  }

  if (Result) {    
    if(Selection == (ULONG_PTR)(-1)) {
      Selection = 0;
    }

    //
    // Display the status text options.
    //
    SpDisplayStatusOptions(
        (UCHAR)(ATT_FG_BLACK | ATT_BG_WHITE),
        SP_STAT_ENTER_EQUALS_SELECT,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Display the menu.
    //
    SpMnDisplay(Menu, Selection, TRUE, ValidKeys, NULL, NULL, 
          &Keypress, &Selection);

    //
    // Destroy the menu
    //
    SpMnDestroy(Menu);

    switch(Keypress) {
      case ASCI_CR:
          Result = TRUE;
          *SelectedOption = (ULONG)Selection;
          
          break;

      case ASCI_ESC:
          Result = FALSE;

          if (DefaultSelection != -1)
            *SelectedOption = (ULONG)Selection;
          
          break;

      default:
          Result = FALSE;
          break;
    }
  }

  return Result;
}


NTSTATUS
SpInitVirtualOemDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT PVIRTUAL_OEM_SOURCE_DEVICE *SourceDevices
    )
/*++

Routine Description:

    Iterates through the virtual OEM source devices which loader
    created and converts them into VIRTUAL_OEM_SOURCE_DEVICE list.
    Also creates the required registry entries for each device 
    under RAM disk's parameters key.
    
Arguments:

    SetupLoaderBlock  - Setup loader block constructed by setupldr.

    SourceDevice - Place holder for receiving the pointer to
        head of the linked list of VIRTUAL_OEM_SOURCE_DEVICEs.
        
Return Value:

    Appropriate NTSTATUS code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (SetupLoaderBlock && SourceDevices) {
        Status = STATUS_SUCCESS;

        //
        // Setupldr would have constructed its own version
        // of the virtual OEM source devices
        //
        if (SetupLoaderBlock->OemSourceDevices) {
            PVIRTUAL_OEM_SOURCE_DEVICE DeviceList = NULL;
            PDETECTED_OEM_SOURCE_DEVICE CurrDevice = SetupLoaderBlock->OemSourceDevices;
            ULONG DeviceCount = 0;
            
            //
            // Replicate the device list
            //
            while (CurrDevice) {
                PVIRTUAL_OEM_SOURCE_DEVICE NewDevice;

                NewDevice = SpMemAlloc(sizeof(VIRTUAL_OEM_SOURCE_DEVICE));

                if (!NewDevice) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory(NewDevice, sizeof(VIRTUAL_OEM_SOURCE_DEVICE));

                NewDevice->ArcDeviceName = SpToUnicode(CurrDevice->ArcDeviceName);

#ifdef _X86_                
                //
                // NOTE : Loader allocated "LoaderFirmwarePermanent" memory
                // so that memory manager while initializing doesn't
                // reclaim this memory. This also helps us to avoid 
                // double copy -- i.e. this is the only location
                // where we read the device contents into memory and 
                // this memory is valid through out the textmode setup so
                // just reuse the memory.
                //                                    
                NewDevice->ImageBase = CurrDevice->ImageBase;
#else
                //
                // NOTE : 05/13/2001 : LoaderFirmwarePermanent doesn't seem to work on non
                // x86 platforsm (particularly IA64). Till this issue is resolved
                // we have to allocate paged pool memory and replicate the disk
                // image in loader heap tracked by "CurrDevice->ImageBase".
                //
                NewDevice->ImageBase = SpMemAlloc((SIZE_T)(CurrDevice->ImageSize));

                if (NewDevice->ImageBase) {
                    memcpy(NewDevice->ImageBase, 
                        CurrDevice->ImageBase,
                        (SIZE_T)(CurrDevice->ImageSize));
                } else {                
                    Status = STATUS_NO_MEMORY;  // ran out of memory
                    
                    break;
                }                    
#endif
                NewDevice->ImageSize = CurrDevice->ImageSize;
                NewDevice->DeviceId = DeviceCount++;

                //
                // Insert the node at the head of the list
                //
                if (!DeviceList) {
                    DeviceList = NewDevice;
                } else {
                    NewDevice->Next = DeviceList;
                    DeviceList = NewDevice;
                }                    
                
                CurrDevice = CurrDevice->Next;
            }

            //
            // Sanity check
            //
            if (NT_SUCCESS(Status) && !DeviceList) {
                Status = STATUS_UNSUCCESSFUL;
            } 

            //
            // Setup the parameters for the RAM disk driver
            // to create appropriate device objects as
            // needed by us
            //
            if (NT_SUCCESS(Status) && DeviceList) {
                WCHAR   KeyName[MAX_PATH];
                UNICODE_STRING  RamDiskDriverName;
                OBJECT_ATTRIBUTES ObjectAttrs;
                HANDLE RamDiskDriverHandle = NULL;

                //
                // Create the service key
                //            
                swprintf(KeyName,
                    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%ws",
                    RAMDISK_DRIVER_NAME
                    );

                INIT_OBJA(&ObjectAttrs, &RamDiskDriverName, KeyName);
                
                Status = ZwCreateKey(&RamDiskDriverHandle,
                            KEY_ALL_ACCESS,
                            &ObjectAttrs,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            NULL);

                if (NT_SUCCESS(Status)) {
                    UNICODE_STRING  ParamName;
                    OBJECT_ATTRIBUTES ParamAttrs;
                    HANDLE ParamHandle = NULL;

                    //
                    // Create the parameters key
                    //
                    INIT_OBJA(&ParamAttrs, &ParamName, L"Parameters");
                    ParamAttrs.RootDirectory = RamDiskDriverHandle;

                    Status = ZwCreateKey(&ParamHandle,
                                KEY_ALL_ACCESS,
                                &ParamAttrs,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL);

                    if (NT_SUCCESS(Status)) {
                        WCHAR   ValueStr[MAX_PATH];
                        PVIRTUAL_OEM_SOURCE_DEVICE  CurrDevice = DeviceList;

                        //
                        // Create the regsitry values indicating the virtual
                        // devices for the Ram drive
                        //
                        while (CurrDevice) {
                            UNICODE_STRING  ValueName;
                            BYTE  Value[MAX_PATH * 2];
                            PBYTE ValuePtr = (PBYTE)Value;
                            ULONG ValueSize;
                            ULONGLONG ImageBase = (ULONGLONG)(ULONG_PTR)(CurrDevice->ImageBase);
                            ULONG ImageSize = (ULONG)(CurrDevice->ImageSize);
                            
                            swprintf(ValueStr, 
                                L"%ws%d", 
                                MS_RAMDISK_DRIVER_PARAM,
                                CurrDevice->DeviceId);                                            

                            memcpy(ValuePtr, &ImageBase, sizeof(ULONGLONG));
                            ValuePtr += sizeof(ULONGLONG);
                            memcpy(ValuePtr, &ImageSize, sizeof(ULONG));
                            ValuePtr += sizeof(ULONG);

                            ValueSize = (ULONG)(ULONG_PTR)(ValuePtr - Value);
                            
                            RtlInitUnicodeString(&ValueName, ValueStr);
                                                    
                            Status = ZwSetValueKey(ParamHandle,
                                        &ValueName,
                                        0,
                                        REG_BINARY,
                                        Value,
                                        ValueSize);

                            if (!NT_SUCCESS(Status)) {
                                break;
                            }

                            //
                            // process next device
                            //
                            CurrDevice = CurrDevice->Next;
                        }                

                        ZwClose(ParamHandle);
                    }

                    ZwClose(RamDiskDriverHandle);
                }
            }

            //
            // Initialize the return value only if we are successful
            //
            if (NT_SUCCESS(Status)) {
                *SourceDevices = DeviceList;                
            }
        } else {
            *SourceDevices = NULL;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmenu.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.h

Abstract:

    Public header file for text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#ifndef _SPMENU_
#define _SPMENU_


//
// Define type of routine that is called from within
// SpMnDisplay when the user moves the highlight via
// the up and down arrow keys.
//
typedef
VOID
(*PMENU_CALLBACK_ROUTINE) (
    IN ULONG_PTR UserDataOfHighlightedItem
    );


PVOID
SpMnCreate(
    IN ULONG LeftX,
    IN ULONG TopY,
    IN ULONG Width,
    IN ULONG Height
    );

VOID
SpMnDestroy(
    IN PVOID Menu
    );

BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  BOOLEAN                Framed,
    IN  PULONG                 ValidKeys,
    IN  PULONG                 Mnemonics,               OPTIONAL
    IN  PMENU_CALLBACK_ROUTINE NewHighlightCallback,    OPTIONAL
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    );

#endif // _SPMENU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmemory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.c

Abstract:

    Memory allocation routines for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

PVOID
SpMemAlloc(
    IN SIZE_T Size
    )
{
    return(SpMemAllocEx(Size,'pteS', PagedPool));
}

PVOID
SpMemAllocNonPagedPool(
    IN SIZE_T Size
    )
{
    return(SpMemAllocEx(Size,'pteS', NonPagedPool));
}

PVOID
SpMemAllocEx(
    IN SIZE_T Size,
    IN ULONG Tag,
    IN POOL_TYPE Type
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T p;

    //
    // Add space for storing the size of the block.
    //
#if defined(SETUP_TEST_USERMODE)
    p = RtlAllocateHeap(RtlProcessHeap(), 0, Size + (2 * sizeof(SIZE_T)));
#else
    p = ExAllocatePoolWithTag(Type, Size + (2 * sizeof(SIZE_T)), Tag);
#endif

    if(!p) {

        SpOutOfMemory();
    }

    //
    // Store the size of the block, and return the address
    // of the user portion of the block.
    //
    *p = Tag;
    *(p + 1) = Size;

    return(p + 2);
}



PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T NewBlock;
    SIZE_T  OldSize;
    ULONG   OldTag;

    //
    // Get the size of the block being reallocated.
    //
    OldTag = (ULONG)((PSIZE_T)Block)[-2];
    OldSize = ((PSIZE_T)Block)[-1];

    //
    // Allocate a new block of the new size.
    //
    NewBlock = SpMemAllocEx(NewSize, OldTag, PagedPool);
    ASSERT(NewBlock);

    //
    // Copy the old block to the new block.
    //
    if (NewSize < OldSize) {
        RtlCopyMemory(NewBlock, Block, NewSize);
    } else {
        RtlCopyMemory(NewBlock, Block, OldSize);
    }

    //
    // Free the old block.
    //
    SpMemFree(Block);

    //
    // Return the address of the new block.
    //
    return(NewBlock);
}


VOID
SpMemFree(
    IN PVOID Block
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
extern PWSTR CommonStrings[11];
unsigned long i;

    if (Block == NULL)
        return;

    for( i = 0; i < sizeof(CommonStrings)/sizeof(PWSTR); i++ ) {
        if( (PWSTR)Block == CommonStrings[i] ) {
            return;
        }
    }

    //
    // Free the block at its real address.
    //
#if defined(SETUP_TEST_USERMODE)
    RtlFreeHeap(RtlProcessHeap(), 0, (PULONG_PTR)Block - 2);
#else
    ExFreePool((PULONG_PTR)Block - 2);
#endif
}


VOID
SpOutOfMemory(
    VOID
    )
{
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Out of memory\n"));

#if !defined(SETUP_TEST_USERMODE)

    if(VideoInitialized) {
        if(KbdLayoutInitialized) {

            ULONG ValidKeys[2] = { KEY_F3,0 };

            //
            // We run a high risk of getting into an infinite loop
            // here because SpStartScreen will result in a call to
            // SpMemAlloc(), which will fail and call SpOutOfMemory
            // again.  In order to get around this, we'll jettison
            // some memory that we won't need anymore (since we're
            // about to die).  These should give us enough memory
            // to display the messages below.
            //
            SpFreeBootVars();
            SpFreeArcNames();

            while(1) {
                SpStartScreen(SP_SCRN_OUT_OF_MEMORY,5,0,FALSE,TRUE,DEFAULT_ATTRIBUTE);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
                    SpDone(0,FALSE,TRUE);
                }
            }
        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpStartScreen(SP_SCRN_OUT_OF_MEMORY_RAW,5,0,FALSE,TRUE,DEFAULT_ATTRIBUTE);

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_KBD_HARD_REBOOT, 0);

            while(TRUE);    // Loop forever
        }
    } else {
        SpDisplayRawMessage(SP_SCRN_OUT_OF_MEMORY_RAW, 2);
        while(TRUE);    // loop forever
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmenu.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.c

Abstract:

    Text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#define MENUITEM_NORMAL     0x00000000
#define MENUITEM_STATIC     0x00000001


typedef struct _MENU_ITEM {

    PWSTR Text;

    ULONG Flags;

    ULONG LeftX;

    ULONG_PTR UserData;

    ULONG OriginalLength;

} MENU_ITEM, *PMENU_ITEM;


typedef struct _MENU {

    PMENU_ITEM Items;
    ULONG      ItemCount;

    ULONG      TopY;
    ULONG      Height;

    ULONG      LeftX;
    ULONG      Width;

    ULONG      TopDisplayedIndex;

    BOOLEAN    MoreUp,MoreDown;

} MENU, *PMENU;



VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN DrawFrame,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    );


PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    )

/*++

Routine Description:

    Create a new menu by allocating space for a new menu structure
    and initializing its fields.

Arguments:

    LeftX - supplies the 0-based X coordinate of the leftmost column
        of the menu.

    TopY - supplies the 0-based Y coordinate of the topmost line
        of the menu.

    Width - supplies the maximum displayed width for lines in the menu.

    Height - supplies the maximum displayed height of the menu.
        The menu will scroll if it is too long to fit in the
        allotted space.

Return Value:

    Menu handle (expressed as a pvoid) of NULL if memory couldn't
    be allocated.

--*/

{
    PMENU p;

    if(p = SpMemAlloc(sizeof(MENU))) {

        RtlZeroMemory(p,sizeof(MENU));

        if(p->Items = SpMemAlloc(0)) {
            p->LeftX = LeftX;
            p->TopY = TopY;
            p->Width = Width;
            p->Height = Height;
        } else {
            SpMemFree(p);
            p = NULL;
        }
    }

    return(p);
}


VOID
SpMnDestroy(
    IN PVOID Menu
    )

/*++

Routine Description:

    Destroy a menu, releasing all memory associated with it.

Arguments:

    Menu - supplies handle to menu to destroy.

Return Value:

    None.

--*/

{
    PMENU pMenu = Menu;
    ULONG u;

    for(u=0; u<pMenu->ItemCount; u++) {
        if(pMenu->Items[u].Text) {
            SpMemFree(pMenu->Items[u].Text);
        }
    }

    SpMemFree(pMenu->Items);

    SpMemFree(pMenu);
}



BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    )

/*++

Routine Description:

    Add an item to a menu.

Arguments:

    Menu - supplies handle to menu to which the item is to be added.

    Text - supplies text that comprises the menu selection.  This routine
        will make a copy of the text.

    LeftX - supplies 0-based x coordinate of leftmost character of the text
        when it is displayed.

    Width - supplies width in characters of the field for this selection.
        If this is larger than the number of characters in the text, then
        the text is padded to the right with blanks when highlighted.

    Selectable - if FALSE, then this text is static -- ie, not selectable.

    UserData - supplies a ulong's worth of caller-specific data to be associated
        with this menu item.

Return Value:

    TRUE if the menu item was added successfully; FALSE if insufficient memory.

--*/

{
    PMENU pMenu = Menu;
    PMENU_ITEM p;
    ULONG TextLen;
    ULONG PaddedLen;
    PWSTR String;
    ULONG u;
    ULONG ColumnLen;
    ULONG FillLen;

    //
    // Build a string that is padded to the right with blanks to make
    // it the right width.
    //
    TextLen = wcslen(Text);
    PaddedLen = max(TextLen,Width);
    ColumnLen = SplangGetColumnCount(Text);
    FillLen = (PaddedLen <= ColumnLen) ? 0 : PaddedLen - ColumnLen;

    String = SpMemAlloc((PaddedLen+1)*sizeof(WCHAR));
    if(!String) {
        return(FALSE);
    }

    wcsncpy(String,Text,TextLen);
    for(u=0; u<FillLen; u++) {
        String[TextLen+u] = L' ';
    }
    String[TextLen+u] = 0;

    //
    // Make space for the item.
    //
    if((p = SpMemRealloc(pMenu->Items,(pMenu->ItemCount+1) * sizeof(MENU_ITEM))) == NULL) {
        SpMemFree(String);
        return(FALSE);
    }

    pMenu->Items = p;

    //
    // Calculate the address of the new menu item and
    // indicate that there is now an additional item in the menu.
    //
    p = &pMenu->Items[pMenu->ItemCount++];

    //
    // Set the fields of the menu.
    //
    p->LeftX = LeftX;
    p->UserData = UserData;

    p->Flags = Selectable ? MENUITEM_NORMAL : MENUITEM_STATIC;

    p->Text = String;

    p->OriginalLength = TextLen;

    return(TRUE);
}


PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            return(pMenu->Items[i].Text);
        }
    }

    return(NULL);
}

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;
    PWSTR p;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            //
            // Make a duplicate; leave off trailing pad spaces.
            //
            p = SpMemAlloc((pMenu->Items[i].OriginalLength+1)*sizeof(WCHAR));
            wcsncpy(p,pMenu->Items[i].Text,pMenu->Items[i].OriginalLength);
            p[pMenu->Items[i].OriginalLength] = 0;
            return(p);
        }
    }

    return(NULL);
}


VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  BOOLEAN                Framed,
    IN  PULONG                 ValidKeys,
    IN  PULONG                 Mnemonics,            OPTIONAL
    IN  PMENU_CALLBACK_ROUTINE NewHighlightCallback, OPTIONAL
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    )

/*++

Routine Description:

    Display a menu and accept keystrokes.

    When the user presses a menu keystroke (up/down arrow keys), this
    routine automatically updates the highlight and calls a callback function
    to inform the caller that a new item has the highlight.

    When the user presses a keystroke in a list provided by the caller,
    this routine returns, providing information about the key pressed and
    the item that was highlighted when the key was pressed.

Arguments:

    Menu - supplies handle to menu to be displayed.

    UserDataOfHighlightedItem - supplies user data of the menu item which
        is to receive the highlight initially.

    Framed - if TRUE, then draw a single-line bordera around the menu.

    ValidKeys - supplies a list of keystrokes that cause this routine to
        return to the caller.  The list must be terminated with a 0 entry.

    NewHighlightCallback - If specified, supplies a routine to be called
        when a new item has received the highlight.

    KeyPressed - receives the key press that caused this routine to exit.
        This will be a valid from the ValidKeys array.

    UserDataOfSelectedItem - receives the UserData of the item that had the
        highlight when the user pressed a key in ValidKeys.

Return Value:

    None.

--*/


{
    ULONG ValidMenuKeys[3] = { KEY_UP, KEY_DOWN, 0 };
    ULONG key;
    PMENU pMenu = Menu;
    ULONG SelectedIndex,OldIndex;
    BOOLEAN FoundNewItem;
    ULONG NewTopDisplayedIndex;
    BOOLEAN MustScroll;
    PWSTR MoreUpText,MoreDownText;


    //
    // Get the text for the text that indicate that there are more
    // selections.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_MORE_UP);
    MoreUpText = SpDupStringW(TemporaryBuffer);
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_MORE_DOWN);
    MoreDownText = SpDupStringW(TemporaryBuffer);

    //
    // Locate the seleccted item.
    //
    for(SelectedIndex=0; SelectedIndex<pMenu->ItemCount; SelectedIndex++) {
        if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)
        && (pMenu->Items[SelectedIndex].UserData == UserDataOfHighlightedItem))
        {
            break;
        }
    }
    ASSERT(SelectedIndex < pMenu->ItemCount);

    //
    // Make sure the selected item will be visible when we draw the menu.
    //
    pMenu->TopDisplayedIndex = 0;
    while(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
        pMenu->TopDisplayedIndex += pMenu->Height;
    }

    //
    // Draw the menu itself.
    //
    pSpMnDrawMenu(pMenu,SelectedIndex,Framed,Framed,MoreUpText,MoreDownText);

    while(1) {

        //
        // Wait for a valid keypress.
        //
        key = SpWaitValidKey(ValidKeys,ValidMenuKeys,Mnemonics);

        //
        // If the key is a menu keystroke, handle it here.
        //
        FoundNewItem = FALSE;
        MustScroll = FALSE;
        OldIndex = SelectedIndex;

        switch(key) {

        case KEY_UP:

            //
            // Locate the previous selectable item.
            //
            if(SelectedIndex) {

                for(SelectedIndex=SelectedIndex-1; (LONG)SelectedIndex>=0; SelectedIndex--) {
                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex < pMenu->TopDisplayedIndex) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = SelectedIndex;
                    }
                } else {
                    //
                    // If the first lines are static text, there might be no
                    // way to get them back on the screen -- the tests above
                    // fail in this case.  So if the user hits the up arrow
                    // when he's at the topmost selectable item but there are
                    // static items above him, we'll simply scroll the menu
                    // so that item #0 is at the top.
                    //
                    FoundNewItem = TRUE;
                    NewTopDisplayedIndex = 0;
                    MustScroll = TRUE;
                    SelectedIndex = OldIndex;
                }
            }
            break;

        case KEY_DOWN:

            //
            // Locate the next selectable item.
            //
            if(SelectedIndex < pMenu->ItemCount) {

                for(SelectedIndex=SelectedIndex+1; SelectedIndex < pMenu->ItemCount; SelectedIndex++) {

                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = pMenu->TopDisplayedIndex + SelectedIndex - OldIndex;
                    }
                }
            }
            break;

        default:

            //
            // User pressed a non-menu key.
            //
            *KeyPressed = key;
            *UserDataOfSelectedItem = pMenu->Items[SelectedIndex].UserData;

            SpMemFree(MoreUpText);
            SpMemFree(MoreDownText);
            return;
        }


        if(FoundNewItem) {

            //
            // Unhighlight the currently selected item.
            //
            SpvidDisplayString(
                pMenu->Items[OldIndex].Text,
                DEFAULT_ATTRIBUTE,
                pMenu->Items[OldIndex].LeftX,
                pMenu->TopY + OldIndex - pMenu->TopDisplayedIndex
                );


            //
            // Highlight the newly selected item.  This may involve
            // scrolling the menu.
            //
            if(MustScroll) {
                //
                // Redraw the menu so the newly highlighted line is in view.
                //
                pMenu->TopDisplayedIndex = NewTopDisplayedIndex;

                pSpMnDrawMenu(pMenu,SelectedIndex,FALSE,Framed,MoreUpText,MoreDownText);
            }

            //
            // Highlight the newly selected item.
            //
            SpvidDisplayString(
                pMenu->Items[SelectedIndex].Text,
                ATT_BG_WHITE | ATT_FG_BLUE,
                pMenu->Items[SelectedIndex].LeftX,
                pMenu->TopY + SelectedIndex - pMenu->TopDisplayedIndex
                );


            //
            // Inform the caller.
            //
            if(NewHighlightCallback) {
                NewHighlightCallback(pMenu->Items[SelectedIndex].UserData);
            }

        } else {
            SelectedIndex = OldIndex;
        }
    }
}


VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN DrawFrame,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    )
{
    ULONG item;
    BOOLEAN MoreUp,MoreDown,MoreStatusChanged;

    //
    // Blank out the on-screen menu display.
    //
    SpvidClearScreenRegion(
        pMenu->LeftX,
        pMenu->TopY,
        pMenu->Width,
        pMenu->Height,
        DEFAULT_BACKGROUND
    );


    MoreUp = (BOOLEAN)(pMenu->TopDisplayedIndex > 0);
    MoreDown = (BOOLEAN)(pMenu->TopDisplayedIndex + pMenu->Height < pMenu->ItemCount);

    //
    // We want to force the frame to be drawn if there is a change in whether
    // there are more selections above or below us.
    //
    MoreStatusChanged = (BOOLEAN)(    IndicateMore
                                   && (    (pMenu->MoreUp != MoreUp)
                                        || (pMenu->MoreDown != MoreDown)
                                      )
                                 );

    if(DrawFrame || MoreStatusChanged) {

        ASSERT(pMenu->LeftX);
        ASSERT(pMenu->TopY);

        SpDrawFrame(
            pMenu->LeftX-1,
            pMenu->Width+2,
            pMenu->TopY-1,
            pMenu->Height+2,
            DEFAULT_ATTRIBUTE,
            FALSE
            );
    }

    //
    // Draw each item that is currently on-screen.
    //
    ASSERT(pMenu->TopDisplayedIndex < pMenu->ItemCount);
    for(item = pMenu->TopDisplayedIndex;
        item < min(pMenu->TopDisplayedIndex+pMenu->Height,pMenu->ItemCount);
        item++)
    {
        SpvidDisplayString(
            pMenu->Items[item].Text,
            (UCHAR)((item == SelectedIndex) ? ATT_BG_WHITE | ATT_FG_BLUE : DEFAULT_ATTRIBUTE),
            pMenu->Items[item].LeftX,
            pMenu->TopY + item - pMenu->TopDisplayedIndex
            );
    }


    //
    // If there are more selections above or below us,
    // indicate so by placing a small bit of text on the frame.
    // Note that the arrow chars can sometimes be DBCS.
    //
    if(MoreStatusChanged) {

        if(MoreUp) {
            SpvidDisplayString(
                MoreUpText,
                DEFAULT_ATTRIBUTE,
                pMenu->LeftX + pMenu->Width - SplangGetColumnCount(MoreUpText) - 1,
                pMenu->TopY - 1
                );
        }

        if(MoreDown) {
            SpvidDisplayString(
                MoreDownText,
                DEFAULT_ATTRIBUTE,
                pMenu->LeftX + pMenu->Width - SplangGetColumnCount(MoreDownText) - 1,
                pMenu->TopY + pMenu->Height
                );
        }

        pMenu->MoreUp = MoreUp;
        pMenu->MoreDown = MoreDown;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmemory.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.h

Abstract:

    Public Header file for memory allocation routines
    for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPMEM_DEFN_
#define _SPMEM_DEFN_


PVOID
SpMemAlloc(
    IN SIZE_T Size
    );

PVOID
SpMemAllocEx(
    IN SIZE_T Size,
    IN ULONG Tag,
    IN POOL_TYPE Type
    );

PVOID
SpMemAllocNonPagedPool(
    IN SIZE_T Size
    );

PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    );

VOID
SpMemFree(
    IN PVOID Block
    );

VOID
SpOutOfMemory(
    VOID
    );

#endif // ndef _SPMEM_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmisc.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmisc.h

Abstract:

    Miscellaneous stuff for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/

#include <crypt.h>

#ifndef _SPSETUP_DEFN_
#define _SPSETUP_DEFN_


extern PWSTR SetupSourceDevicePath;
extern PWSTR DirectoryOnSetupSource;
extern PVOID SifHandle;
extern BOOLEAN Win9xRollback;

ULONG
SpStartSetup(
    VOID
    );

VOID
SpGetWinntParams(
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice
    );

extern WCHAR TemporaryBuffer[16384];


//
// TRUE if setup should run in the step-up upgrade mode.
// In this mode, setup is not allowed to do clean install,
// and is not allowed to upgrade workstation to server.
//
// We also track an evaluation time for the evaluation SKU.
//
extern BOOLEAN StepUpMode;
extern ULONG EvaluationTime;
extern ULONG RestrictCpu;
extern ULONG SuiteType;

__inline
BOOLEAN
SpIsProductSuite(
    DWORD SuiteToCheck
    )
{
    return (SuiteType & SuiteToCheck) ? TRUE : FALSE;
}


//
// Non-0 if gui setup is supposed to be restartable.
// This causes us to do special stuff with hives in spconfig.c.
//
extern BOOLEAN RestartableGuiSetup;

//
// TRUE if user chose Repair Winnt
//

extern BOOLEAN RepairWinnt;

//
// TRUE if user chose Custom Setup.
//
extern BOOLEAN CustomSetup;

//
// TRUE if floppyless boot
//
extern BOOLEAN IsFloppylessBoot;

//
// TRUE is textmode is to pick a partition
//
extern BOOLEAN AutoPartitionPicker;

//
// Preferred installation dir
//
extern PWSTR PreferredInstallDir;

//
// ARC pathname of the device from which we were started.
//
extern PWSTR ArcBootDevicePath;

//
// Gets set to TRUE if the user elects to convert or format to ntfs.
// And a flag indicating whether we are doing a dirty sleazy hack
// for oem preinstall.
//
extern BOOLEAN ConvertNtVolumeToNtfs;
extern BOOLEAN ExtendingOemPartition;

//
// TRUE if upgrading NT to NT
//
typedef enum _ENUMUPRADETYPE {
    DontUpgrade = 0,
    UpgradeFull,
    UpgradeInstallFresh
    } ENUMUPGRADETYPE;

extern ENUMUPGRADETYPE NTUpgrade;

extern ENUMUPGRADETYPE IsNTUpgrade;

extern ULONG OldMinorVersion,OldMajorVersion;

//
// TRUE if upgrading Workstation to Standard Server, or upgrading
// existing Standard Server
//
extern BOOLEAN StandardServerUpgrade;

typedef enum _ENUMNONNTUPRADETYPE {
    NoWinUpgrade = 0,
    UpgradeWin31,
    UpgradeWin95
    } ENUMNONNTUPRADETYPE;

//
// Non-zero if upgrading win31 or win95 to NT.
//
extern ENUMNONNTUPRADETYPE WinUpgradeType;

//
// Macros to simplify use of enum type
//

#define ANY_TYPE_OF_UPGRADE    (NTUpgrade || WinUpgradeType)
#define WIN9X_OR_NT_UPGRADE    (NTUpgrade == UpgradeFull || WinUpgradeType == UpgradeWin95)

//
// TRUE if this setup was started with winnt.exe.
// Also a flag indicating whether the local source was not created and we
// should get files from the CD instead.
//
extern BOOLEAN WinntSetup;
extern BOOLEAN WinntFromCd;

#ifdef _X86_
//
// TRUE if this setup was started with winnt95.exe.
//
extern BOOLEAN Winnt95Setup;
#endif

//
// TRUE if any of the accessibility options was selected
//
extern BOOLEAN AccessibleSetup;
//
// If this is an unattended setup, this value will be a TRUE
//
extern BOOLEAN UnattendedOperation;
//
// If there is an Unattended GUI section, this value will be TRUE
//
extern BOOLEAN UnattendedGuiOperation;
//
// This value is strictly a pointer to the WINNT.SIF file in the
// case that Unattended operation occurs in either the textmode
// or GUI Mode case. It has been kept to avoid changing large
// sections of code.
//
extern PVOID UnattendedSifHandle;
//
// This value is a non-null pointer to the WINNT.SIF file. It is
// initialized when the driver is started. Any parameter which is
// to be passed to GUI mode is added to the WINNT.SIF file by
// referencing this parameter.
//
extern PVOID WinntSifHandle;
extern BOOLEAN SkipMissingFiles;
extern BOOLEAN HideWinDir;


//
// this value is a non-null pointer to the drvindex.inf file.  It is
// initialized on startup.  The list of files that are present in our
// driver cab file are indexed in this inf, so we can quickly look if a
// file is present in the cab
//
extern PVOID DriverInfHandle;


//
// This structure will keep track of all the cabs
// that we'll be installing from.
//
typedef struct _CABDATA {
    struct _CABDATA     *Next;
    PWSTR               CabName;
    HANDLE              CabHandle;
    PWSTR               CabSectionName;
    PVOID               CabInfHandle;
} CABDATA;

extern CABDATA *CabData;

//
// handle to delta.inf, used for private testing
//
extern PVOID PrivateInfHandle;

#ifdef _X86_
//
// WINNT95 may turn this flag on, it is off by default for everything
// else.
//

extern BOOLEAN MigrateOption;
#endif


//
//  This is a handle to txtsetup.oem, used on pre-install mode.
//
extern PVOID PreinstallOemSifHandle;


//
// On unattended mode, indicates whether OEM files
// that have same name as Microsoft files released
// with the product should be overwritten.
//
extern BOOLEAN UnattendedOverwriteOem;

//
// On unattended mode, indicates that this is is
// an OEM pre-installation
//
extern BOOLEAN PreInstall;


//
//  On pre-install mode, points to the directory that contains the files
//  that need to be copied during textmode setup
//
extern PWSTR   PreinstallOemSourcePath;

//
//  Flags that indicate the type of mice detected in the machine.
//  Note that more than one type of mice may be present.
//
extern BOOLEAN UsbMouseDetected;
extern BOOLEAN PS2MouseDetected;
extern BOOLEAN SerMouseDetected;

//
//  Flags that indicate the type of keyboard detected in the machine.
//  Note that more than one type of keyborad may be present.
//
extern BOOLEAN UsbKeyboardDetected;
extern BOOLEAN StdKeyboardDetected;

//
// This flag identifies "dockable" machines (portables)
// so that we can disble dynamic volumes on them
//
extern BOOLEAN DockableMachine;

//
// Variable used during the repair process, that indicates that the
// system has no CD-ROM drive.
// This is a hack that we did for World Bank so that they can repair
// the hives even if they don't have a CD-ROM drive.
//
extern BOOLEAN RepairNoCDROMDrive;

//
//  RemoteBootSetup is true when Source and target paths are through the redirector
//  with possibly no system partition.
//
//  RemoteInstallSetup is true when we are doing a remote install.
//
//  RemoteSysPrepSetup is true when we are doing a remote install of a sys prep image.
//
//  RemoteSysPrepVolumeIsNtfs is true when the sysprep image we're copying down
//  represents an ntfs volume.
//

extern BOOLEAN RemoteBootSetup;
extern BOOLEAN RemoteInstallSetup;
extern BOOLEAN RemoteSysPrepSetup;
extern BOOLEAN RemoteSysPrepVolumeIsNtfs;

//
// setupldr may pass us the administrator password in a remote install
// if the user is prompted for the password.
//
extern PWSTR NetBootAdministratorPassword;



extern BOOLEAN NoLs;

//
// Source and target paths are through the redirector with possibly no
// system partition,
//

extern BOOLEAN RemoteBootSetup;

//
// Filename of local source directory.
//
extern PWSTR LocalSourceDirectory;

//
// Platform-specific extension, used when creating names of sections
// in sif/inf files.
//
extern PWSTR PlatformExtension;

//
// TRUE if this is advanced server we're setting up.
//
extern BOOLEAN AdvancedServer;

//
// Windows NT Version.
//
extern ULONG WinntMajorVer;
extern ULONG WinntMinorVer;

//
// Representation of the boot device path in the nt namespace.
//
extern PWSTR NtBootDevicePath;
extern PWSTR DirectoryOnBootDevice;

//
// Setup parameters passed to us by setupldr.
//
extern SETUP_LOADER_BLOCK_SCALARS SetupParameters;

//
// System information gathered by the user-mode part of text setup
// and passed to us in IOCTL_SETUP_START
//
extern SYSTEM_BASIC_INFORMATION SystemBasicInfo;

//
// Flags indicating whether or not keyboard and video have been initialized
//
extern BOOLEAN VideoInitialized, KeyboardInitialized, KbdLayoutInitialized;

//
// ARC disk/signature information structure.
// A list of these is created during phase0 initialization.
//
typedef struct _DISK_SIGNATURE_INFORMATION {
    struct _DISK_SIGNATURE_INFORMATION *Next;
    ULONG Signature;
    PWSTR ArcPath;
    ULONG CheckSum;
    BOOLEAN ValidPartitionTable;
    BOOLEAN xInt13;
} DISK_SIGNATURE_INFORMATION, *PDISK_SIGNATURE_INFORMATION;

extern PDISK_SIGNATURE_INFORMATION DiskSignatureInformation;

//
// Flag indicating whether or not pcmcia driver has been initialized
//

extern BOOLEAN PcmciaLoaded;

//
// Flag indicating whether or not atapi driver has been initialized
//

extern BOOLEAN AtapiLoaded;

//
//  Array with the PIDs of all NT greater than 4.x found in the machine (PID 2.0)
//  The values in this array will be saved under Setup\PID key in the registry,
//  and will be used during GUI setup
//
extern PWSTR*  Pid20Array;

//
//  Product Id read from setup.ini
//
extern PWSTR   PidString;

//
// Object types.
//
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *IoDeviceObjectType;


//
//  Gauge used to report progress of autochk and autofmt
//
extern PVOID   UserModeGauge;

//
//  This variable is used when displaying the progress bar
//  during autochk and autofmt. It indicates the disk that
//  is being autochecked or formatted.
//
extern ULONG   CurrentDiskIndex;

//
// Process structure for usetup.exe
//
extern PEPROCESS UsetupProcess;

//
// Setup fatal error codes.
//
// If you add anything here, you must also update ntos\nls\bugcodes.txt.
//
#define     SETUP_BUGCHECK_BAD_OEM_FONT         0
#define     SETUP_BUGCHECK_BOOTPATH             4
#define     SETUP_BUGCHECK_PARTITION            5
#define     SETUP_BUGCHECK_BOOTMSGS             6

//
// The following error codes are no longer used, because we have friendlier
// error messages for them.
//
// #define  SETUP_BUGCHECK_VIDEO                1
// #define  SETUP_BUGCHECK_MEMORY               2
// #define  SETUP_BUGCHECK_KEYBOARD             3


//
// Video-specific bugcheck subcodes.
//
#define     VIDEOBUG_OPEN           0
#define     VIDEOBUG_GETNUMMODES    1
#define     VIDEOBUG_GETMODES       2
#define     VIDEOBUG_BADMODE        3
#define     VIDEOBUG_SETMODE        4
#define     VIDEOBUG_MAP            5
#define     VIDEOBUG_SETFONT        6

//
// Partition sanity check bugcheck subcodes.
//
#define     PARTITIONBUG_A          0
#define     PARTITIONBUG_B          1

//
// Use the following enum to access line draw characters in
// the LineChars array.
//

typedef enum {
    LineCharDoubleUpperLeft = 0,
    LineCharDoubleUpperRight,
    LineCharDoubleLowerLeft,
    LineCharDoubleLowerRight,
    LineCharDoubleHorizontal,
    LineCharDoubleVertical,
    LineCharSingleUpperLeft,
    LineCharSingleUpperRight,
    LineCharSingleLowerLeft,
    LineCharSingleLowerRight,
    LineCharSingleHorizontal,
    LineCharSingleVertical,
    LineCharDoubleVerticalToSingleHorizontalRight,
    LineCharDoubleVerticalToSingleHorizontalLeft,
    LineCharMax
} LineCharIndex;

extern WCHAR LineChars[LineCharMax];


//
// Remember whether or not we write out an ntbootdd.sys
//
typedef struct _HARDWAREIDLIST {
    struct _HARDWAREIDLIST *Next;
    PWSTR HardwareID;
} HARDWAREIDLIST;

extern HARDWAREIDLIST *HardwareIDList;
extern BOOLEAN ForceBIOSBoot;

//
// Structure used to track a gauge.
//
typedef struct _GAS_GAUGE {

    //
    // upper left corner of outside of gauge.
    //
    ULONG GaugeX,GaugeY;

    //
    // Total width of gauge.
    //
    ULONG GaugeW;

    //
    // upper left corner of thermometer box.
    //
    ULONG ThermX,ThermY;

    //
    // Width of thermometer box.
    //
    ULONG ThermW;

    //
    // Total items reperesented by 100%
    //
    ULONG ItemCount;

    //
    // Items elapsed.
    //
    ULONG ItemsElapsed;

    //
    // Current percentage represented by ItemsElapsed.
    //
    ULONG CurrentPercentage;

    //
    // Caption text.
    //
    PWCHAR Caption;

    //
    // Absolute string
    //
    PWCHAR ProgressFmtStr;
    ULONG ProgressFmtWidth;

    //
    // Flags controlling what value to print
    //
    ULONG Flags;

    //
    // Color for the gauge bar
    //
    UCHAR Attribute;

    //
    // Buffer used for drawing.
    //
    PWCHAR Buffer;

} GAS_GAUGE, *PGAS_GAUGE;

//
// Indicates whether autochk or autofmt are running
//
extern BOOLEAN AutochkRunning;
extern BOOLEAN AutofrmtRunning;

//
// Various textmode setup progress events
//
typedef enum {
    CallbackEvent,
    InitializationEvent,
    PartitioningEvent,
    FileCopyEvent,
    BackupEvent,
    UninstallEvent,
    SavingSettingsEvent,
    SetupCompletedEvent
} TM_SETUP_MAJOR_EVENT;

typedef enum {
    CallbackInitialize,
    CallbackDeInitialize,
    InitializationStartEvent,
    InitializationEndEvent,
    PartitioningStartEvent,
    ScanDisksEvent,
    ScanDiskEvent,
    CreatePartitionEvent,
    DeletePartitionEvent,
    FormatPartitionEvent,
    ValidatePartitionEvent,
    PartitioningEventEnd,
    FileCopyStartEvent,
    OneFileCopyEvent,
    FileCopyEndEvent,
    SavingSettingsStartEvent,
    InitializeHiveEvent,
    SaveHiveEvent,
    HiveProcessingEndEvent,
    SavingSettingsEndEvent,
    ShutdownEvent,
    UninstallStartEvent,
    UninstallUpdateEvent,
    UninstallEndEvent,
    BackupStartEvent,
    BackupEndEvent,
    OneFileBackedUpEvent
} TM_SETUP_MINOR_EVENT;

typedef VOID (*TM_SETUP_PROGRESS_CALLBACK) (
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    );

typedef struct _TM_PROGRESS_SUBSCRIBER {
    TM_SETUP_PROGRESS_CALLBACK  Callback;
    PVOID                       Context;
} TM_PROGRESS_SUBSCRIBER, *PTM_PROGRESS_SUBSCRIBER;


NTSTATUS
RegisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK CallBack,
    IN PVOID Context
    );

NTSTATUS
DeregisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK CallBack,
    IN PVOID Context
    );

VOID
SendSetupProgressEvent(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID EventData
    );

//
// Enumerate the possible returns values from SpEnumFiles()
//
typedef enum {
    NormalReturn,   // if the whole process completes uninterrupted
    EnumFileError,  // if an error occurs while enumerating files
    CallbackReturn  // if the callback returns FALSE, causing termination
} ENUMFILESRESULT;

typedef BOOLEAN (*ENUMFILESPROC) (
    IN  PCWSTR,
    IN  PFILE_BOTH_DIR_INFORMATION,
    OUT PULONG,
    IN  PVOID
    );

ENUMFILESRESULT
SpEnumFiles(
    IN  PCWSTR        DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer
    );

ENUMFILESRESULT
SpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer       OPTIONAL
    );

ENUMFILESRESULT
SpEnumFilesRecursiveLimited (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    IN  ULONG         MaxDepth,
    IN  ULONG         CurrentDepth,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    );

ENUMFILESRESULT
SpEnumFilesRecursiveDel (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    );

#define SecToNano(_sec) (LONGLONG)((_sec) * 1000 * 1000 * 10)

//
// This macro filters in-page exceptions, which occur if there is
// an I/O error while the memory manager is paging in parts of a
// memory-mapped file.  Access to such data should be guarded with SEH!
//
#define IN_PAGE_ERROR                                   \
                                                        \
    ((GetExceptionCode() == STATUS_IN_PAGE_ERROR)       \
     ? EXCEPTION_EXECUTE_HANDLER                        \
     : EXCEPTION_CONTINUE_SEARCH)


//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// Macro to align a buffer.
//
#define ALIGN(p,val)                                        \
                                                            \
    (PVOID)((((ULONG_PTR)(p) + (val) - 1)) & (~((ULONG_PTR)((val) - 1))))


//
// Macro to determine the number of elements in a statically
// initialized array.
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof(x[0]))

//
// Marcos to pull potentially unaligned values from memory.
//
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))
#define U_ULONGLONG(p) (*(ULONGLONG  UNALIGNED *)(p))



typedef struct _SP_MIG_DRIVER_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR BaseDllName;
} SP_MIG_DRIVER_ENTRY, *PSP_MIG_DRIVER_ENTRY;

extern LIST_ENTRY MigratedDriversList;

BOOL
SpRememberMigratedDrivers (
    OUT     PLIST_ENTRY List,
    IN      PDETECTED_DEVICE SetupldrList
    );


//
// Setup media types. Setup can be started from one media
// (ie, floppy) and copy files from another (ie, cd-rom).
//
typedef enum {
    SetupBootMedia,
    SetupSourceMedia
} SetupMediaType;


//
// Upgrade-specific routines.
//
VOID
SpPrepareFontsForUpgrade(
    IN PCWSTR SystemDirectory
    );

//
// User-mode services.
//
NTSTATUS
SpExecuteImage(
    IN  PWSTR  ImagePath,
    OUT PULONG ReturnStatus,    OPTIONAL
    IN  ULONG  ArgumentCount,
    ...                         // argv[0] is generated automatically
    );

NTSTATUS
SpLoadUnloadKey(
    IN HANDLE  TargetKeyRootDirectory,  OPTIONAL
    IN HANDLE  SourceFileRootDirectory, OPTIONAL
    IN PWSTR   TargetKeyName,
    IN PWSTR   SourceFileName           OPTIONAL
    );

NTSTATUS
SpDeleteKey(
    IN HANDLE  KeyRootDirectory, OPTIONAL
    IN PWSTR   Key
    );

NTSTATUS
SpQueryDirectoryObject(
    IN     HANDLE  DirectoryHandle,
    IN     BOOLEAN RestartScan,
    IN OUT PULONG  Context
    );

NTSTATUS
SpFlushVirtualMemory(
    IN PVOID BaseAddress,
    IN ULONG RangeLength
    );

VOID
SpShutdownSystem(
    VOID
    );

NTSTATUS
SpLoadKbdLayoutDll(
    IN  PWSTR  Directory,
    IN  PWSTR  DllName,
    OUT PVOID *TableAddress
    );

NTSTATUS
SpVerifyFileAccess(
    IN  PWSTR       FileName,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
SpSetDefaultFileSecurity(
    IN PWSTR    FileName
    );

NTSTATUS
SpCreatePageFile(
    IN PWSTR FileName,
    IN ULONG MinSize,
    IN ULONG MaxSize
    );

NTSTATUS
SpGetFullPathName(
    IN OUT PWSTR FileName
    );

NTSTATUS
SpDecryptPassword(
    PENCRYPTED_NT_OWF_PASSWORD PasswordData,
    ULONG PasswordDataLength,
    ULONG Rid,
    PNT_OWF_PASSWORD NtOwfPassword
    );

//
// Registry Hives.  We pass around the keys to the hives
// in an array.  Use the following enum values to access
// the hive members
//
typedef enum {
    SetupHiveSystem,
    SetupHiveSoftware,
    SetupHiveDefault,
    SetupHiveUserdiff,
    SetupHiveMax
} SetupHive;

//
// Function to set up registry.
//
VOID
SpInitializeRegistry(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        SpecialDevicePath   OPTIONAL,
    IN PDISK_REGION SystemPartitionRegion
    );

NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    );


//
// Function to examine a target registry
//

typedef enum {
    UpgradeNotInProgress = 0,
    UpgradeInProgress,
    UpgradeMaxValue
    } UPG_PROGRESS_TYPE;


NTSTATUS
SpDetermineProduct(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    OUT PNT_PRODUCT_TYPE  ProductType,
    OUT ULONG             *MajorVersion,
    OUT ULONG             *MinorVersion,
    OUT ULONG             *BuildNumber,          OPTIONAL
    OUT ULONG             *ProductSuiteMask,
    OUT UPG_PROGRESS_TYPE *UpgradeProgressValue,
    OUT PWSTR             *UniqueIdFromReg,      OPTIONAL
    OUT PWSTR             *Pid,                  OPTIONAL
    OUT PBOOLEAN          pIsEvalVariation       OPTIONAL,
    OUT PLCID             LangId,
    OUT ULONG             *ServicePack            OPTIONAL
    );

NTSTATUS
SpSetUpgradeStatus(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    IN  UPG_PROGRESS_TYPE UpgradeProgressValue
    );


//
// Utility functions.
//
BOOLEAN
SpGetTargetPath(
    IN  PVOID        SifHandle,
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR       *TargetPath
    );

VOID
SpDeleteExistingTargetDir(
    IN  PDISK_REGION     Region,
    IN  PWSTR            NtDir,
    IN  BOOLEAN          GaugeNeeded,
    IN  DWORD            MsgId
    );

VOID
SpDone(
    IN ULONG   MsgId,
    IN BOOLEAN Successful,
    IN BOOLEAN Wait
    );

VOID
SpFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber
    );

VOID
SpNonFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber,
    IN PWSTR FileName
    );

VOID
SpFatalKbdError(
    IN ULONG MessageId,
    ...
    );

VOID
SpFatalError(
    IN ULONG MessageId,
    ...
    );

PWSTR
SpMakePlatformSpecificSectionName(
    IN PWSTR SectionName
    );

VOID
SpConfirmExit(
    VOID
    );

PWSTR
SpDupStringW(
    IN PCWSTR String
    );

PSTR
SpDupString(
    IN PCSTR String
    );

#define \
SpDupStringA SpDupString

PWSTR
SpToUnicode(
    IN PUCHAR OemString
    );

PUCHAR
SpToOem(
    IN PWSTR UnicodeString
    );

VOID
SpGetSourceMediaInfo(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortName,
    OUT PWSTR *Description,     OPTIONAL
    OUT PWSTR *Tagfile,         OPTIONAL
    OUT PWSTR *Directory        OPTIONAL
    );

VOID
SpConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2
    );

VOID
SpFetchDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    );

VOID
SpFetchTempDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG LocalSourceKBRequired,   OPTIONAL
    OUT PULONG BootKBRequired           OPTIONAL
    );

VOID
SpFetchUpgradeDiskSpaceReq(
    IN  PVOID  SifHandle,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    );

PWCHAR
SpRetreiveMessageText(
    IN     PVOID  ImageBase,            OPTIONAL
    IN     ULONG  MessageId,
    IN OUT PWCHAR MessageText,          OPTIONAL
    IN     ULONG  MessageTextBufferSize OPTIONAL
    );

NTSTATUS
SpRtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );

VOID
SpOpenDriverCab(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    OUT PWSTR       *Directory        OPTIONAL
    );

//
// Disk region name translations
//

typedef enum _ENUMARCPATHTYPE {
                PrimaryArcPath = 0,
                SecondaryArcPath
                } ENUMARCPATHTYPE;

VOID
SpNtNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                NtPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType
    );

BOOLEAN
SpNtNameFromDosPath (
    IN      PCWSTR DosPath,
    OUT     PWSTR NtPath,
    IN      UINT NtPathSizeInBytes,
    IN      PartitionOrdinalType OrdinalType
    );

VOID
SpArcNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                ArcPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType,
    IN  ENUMARCPATHTYPE      ArcPathType
    );

PDISK_REGION
SpRegionFromArcOrDosName(
    IN PWSTR                Name,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    );

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtName,
    IN PartitionOrdinalType OrdinalType
    );

PDISK_REGION
SpRegionFromDosName(
    IN PCWSTR DosName
    );

PDISK_REGION
SpRegionFromArcName(
    IN PWSTR                ArcName,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    );

//
// Help routine.
//
#define SPHELP_HELPTEXT         0x00000000
#define SPHELP_LICENSETEXT      0x00000001

VOID
SpHelp(
    IN ULONG    MessageId,      OPTIONAL
    IN PCWSTR   FileText,       OPTIONAL
    IN ULONG    Flags
    );

//
//
//

BOOLEAN
SpPromptForDisk(
    IN      PWSTR    DiskDescription,
    IN OUT  PWSTR    DiskDevicePath,
    IN      PWSTR    DiskTagFile,
    IN      BOOLEAN  IgnoreDiskInDrive,
    IN      BOOLEAN  AllowEscape,
    IN      BOOLEAN  WarnMultiplePrompts,
    OUT     PBOOLEAN pRedrawFlag
    );

BOOLEAN
SpPromptForSetupMedia(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortname,
    IN  PWSTR  DiskDevicePath
    );

ULONG
SpFindStringInTable(
    IN PWSTR *StringTable,
    IN PWSTR  StringToFind
    );

PWSTR
SpGenerateCompressedName(
    IN PWSTR Filename
    );

BOOLEAN
SpNonCriticalError(
    IN PVOID SifHandle,
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

BOOLEAN
SpNonCriticalErrorWithContinue(
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

VOID
SpNonCriticalErrorNoRetry(
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

VOID
SpPrepareForPrinterUpgrade(
    IN PVOID        SifHandle,
    IN PDISK_REGION NtRegion,
    IN PWSTR        Sysroot
    );

NTSTATUS
SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName, OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    );

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    );

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    );

BOOLEAN
SpIsRegionBeyondCylinder1024(
    IN PDISK_REGION Region
    );

PWSTR
SpDetermineSystemPartitionDirectory(
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        OriginalSystemPartitionDirectory OPTIONAL
    );

VOID
SpFindSizeOfFilesInOsWinnt(
    IN PVOID        MasterSifHandle,
    IN PDISK_REGION SystemPartition,
    IN PULONG       TotalSize
    );

VOID
SpRunAutochkOnNtAndSystemPartitions(
    IN HANDLE       MasterSifHandle,
    IN PDISK_REGION WinntPartitionRegion,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        TargetPath
    );

NTSTATUS
SpRunAutoFormat(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        RegionDescription,
    IN PDISK_REGION PartitionRegion,
    IN ULONG        FilesystemType,
    IN BOOLEAN      QuickFormat,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


#ifdef _X86_
BOOL
SpUseBIOSToBoot(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PVOID        SifHandle
    );
#endif

//
// Utilities used for partitioning/formatting
//

USHORT
ComputeSecPerCluster(
    IN  ULONG   NumSectors,
    IN  BOOLEAN SmallFat
    );

NTSTATUS
SpLockUnlockVolume(
    IN HANDLE   Handle,
    IN BOOLEAN  LockVolume
    );

NTSTATUS
SpDismountVolume(
    IN HANDLE   Handle
    );

//
// Miscellaneous other stuff
//
BOOLEAN
SpReadSKUStuff(
    VOID
    );

VOID
SpSetDirtyShutdownFlag(
    IN  PDISK_REGION    TargetRegion,
    IN  PWSTR           SystemRoot
    );

BOOLEAN
SpPatchBootMessages(
    VOID
    );

ULONG
SpGetHeaderTextId(
    VOID
    );


NTSTATUS
SpGetVersionFromStr(
    IN  PWSTR   VersionStr,
    OUT PDWORD  Version,        // major * 100 + minor
    OUT PDWORD  BuildNumber
    );

NTSTATUS
SpQueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    );

void
SpDisableCrashRecoveryForGuiMode(
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    );

//
// mountmanger mount point iteration routine(s)
//
typedef BOOLEAN (* SPMOUNTMGR_ITERATION_CALLBACK)(
                    IN PVOID Context,
                    IN PMOUNTMGR_MOUNT_POINTS MountPoints,
                    IN PMOUNTMGR_MOUNT_POINT MountPoint);


NTSTATUS
SpIterateMountMgrMountPoints(
    IN PVOID Context,
    IN SPMOUNTMGR_ITERATION_CALLBACK Callback
    );


//
// Registry iteration abstractions
//
typedef struct _SPREGISTERYKEY_ITERATION_CALLBACK_DATA {
    KEY_INFORMATION_CLASS   InformationType;
    PVOID                   Information;
    HANDLE                  ParentKeyHandle;
} SP_REGISTRYKEY_ITERATION_CALLBACK_DATA, *PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA;

//
// registry iteration call back
// 
typedef BOOLEAN (* SP_REGISTRYKEY_ITERATION_CALLBACK)(
                    IN PVOID Context,
                    IN PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA Data,
                    OUT NTSTATUS *StatusCode
                    );                    

NTSTATUS
SpIterateRegistryKeyForKeys(
    IN HANDLE RootKeyHandle,
    IN PWSTR  KeyToIterate,
    IN SP_REGISTRYKEY_ITERATION_CALLBACK Callback,
    IN PVOID  Context
    );
    

#define MAX_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
#define MAX_COPY_SIZE(a) (MAX_ARRAY_SIZE(a) - 1)
#define MAX_APPEND_SIZE_W(a) (MAX_COPY_SIZE(a) - wcslen(a))
#define MAX_APPEND_SIZE MAX_APPEND_SIZE_W


#ifdef PRERELEASE
extern INT g_TestHook;
# define TESTHOOK(n)        if(g_TestHook==(n))SpBugCheck(SETUP_BUGCHECK_BOOTMSGS,0,0,0)
#else
# define TESTHOOK(n)
#endif


//
// On x86, we want to clear the previous OS entry in boot.ini if
// we reformat C:
//
#ifdef _X86_
extern UCHAR    OldSystemLine[MAX_PATH];
extern BOOLEAN  DiscardOldSystemLine;
#endif

#endif // ndef _SPSETUP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmsg.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmsg.h

Abstract:

    Public header file for text message functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#ifndef _SPMSG_DEFN_
#define _SPMSG_DEFN_


VOID
vSpFormatMessage(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  ULONG    MessageId,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    );

VOID
SpFormatMessage(
    OUT PVOID LargeBuffer,
    IN  ULONG BufferSize,
    IN  ULONG MessageId,
    ...
    );

VOID
vSpFormatMessageText(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  PWSTR    MessageText,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    );

VOID
SpFormatMessageText(
    OUT PVOID   LargeBuffer,
    IN  ULONG   BufferSize,
    IN  PWSTR   MessageText,
    ...
    );


extern PVOID ResourceImageBase;

#endif // ndef _SPMSG_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spmsg.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdsputl.c

Abstract:

    Text setup high-level display utility routines.

Author:

    Ted Miller (tedm) 30-July-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// This will be filled in at init time with the base address of the image
// containing the message resources.
// This implementation assumes that we are always executing in the context
// of that image!
//

PVOID ResourceImageBase;


NTSTATUS
SpRtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ 100 ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    WCHAR c;
    PWSTR s, s1;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                                }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                    }
                                }

                            *s1++ = *s++;
                            }
                        else {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }

                    s++;
                    *s1 = UNICODE_NULL;
                    }
                else {
                    wcscpy( PrintFormatString, L"%s" );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    }

                if (!IgnoreInserts && ARGUMENT_PRESENT( Arguments )) {

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hc" );
                            }
                        else
                        if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hs" );
                            }
                        else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                            }
                        else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                            }
                        }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                            rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            rgInserts[ MaxInsert++ ] = va_arg(*Arguments, ULONG_PTR);
                            }
                        }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                                }
                            else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                }
                            }
                        }

                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             PrintFormatString,
                                             s1,
                                             PrintParameter1,
                                             PrintParameter2
                                           );
                    }
                else
                if (!wcscmp( PrintFormatString, L"%s" )) {
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             L"%%%u",
                                             CurInsert+1
                                           );
                    }
                else {
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             L"%%%u!%s!",
                                             CurInsert+1,
                                             &PrintFormatString[ 1 ]
                                           );
                    }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDst += cchWritten;
                }
            else
            if (*s == L'0') {
                break;
                }
            else
            if (!*s) {
                return( STATUS_INVALID_PARAMETER );
                }
            else
            if (*s == L'!') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'!';
                s++;
                }
            else
            if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                    }
                else {
                    Column += 8;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
                }
            else
            if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
                }
            else
            if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (IgnoreInserts) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }

                    *lpDst++ = L'%';
                    }

                *lpDst++ = *s++;
                }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                Column += (ULONG)(lpDst - lpDstBeg);
                }
            }
        else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if (c == L'\r' && *s == L'\n') {
                    s++;
                    }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                    }
                else {
                    c = L'\n';
                    }
                }


            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                    }

                *lpDst++ = c;
                Column += 1;
                }
            }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (size_t)((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)((lpDst - Buffer) * sizeof( WCHAR ));
        }
    return( STATUS_SUCCESS );
}


PWCHAR
SpRetreiveMessageText(
    IN     PVOID  ImageBase,            OPTIONAL
    IN     ULONG  MessageId,
    IN OUT PWCHAR MessageText,          OPTIONAL
    IN     ULONG  MessageTextBufferSize OPTIONAL
    )
{
    ULONG LenBytes;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    BOOLEAN IsUnicode;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    Status = RtlFindMessage(
                ImageBase ? ImageBase : ResourceImageBase,
                (ULONG)(ULONG_PTR)RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Can't find message 0x%lx\n",MessageId));
        return(NULL);
    }

    IsUnicode = (BOOLEAN)((MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) != 0);

    //
    // Get the size in bytes of a buffer large enough to hold the
    // message and its terminating nul wchar.  If the message is
    // unicode, then this value is equal to the size of the message.
    // If the message is not unicode, then we have to calculate this value.
    //
    if(IsUnicode) {

        LenBytes = (wcslen((PWSTR)MessageEntry->Text) + 1) * sizeof(WCHAR);

    } else {

        //
        // RtlAnsiStringToUnicodeSize includes an implied wide-nul terminator
        // in the count it returns.
        //

        AnsiString.Buffer = MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen(MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length;

        LenBytes = RtlAnsiStringToUnicodeSize(&AnsiString);
    }

    //
    // If the caller gave a buffer, check its size.
    // Otherwise, allocate a buffer.
    //
    if(MessageText) {
        if(MessageTextBufferSize < LenBytes) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRetreiveMessageText: buffer is too small (%u bytes, need %u)\n",MessageTextBufferSize,LenBytes));
            return(NULL);
        }
    } else {
        MessageText = SpMemAlloc(LenBytes);
        if(MessageText == NULL) {
            return(NULL);
        }
    }

    if(IsUnicode) {

        //
        // Message is already unicode; just copy it into the buffer.
        //
        wcscpy(MessageText,(PWSTR)MessageEntry->Text);

    } else {

        //
        // Message is not unicode; convert in into the buffer.
        //
        UnicodeString.Buffer = MessageText;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)LenBytes;

        RtlAnsiStringToUnicodeString(
            &UnicodeString,
            &AnsiString,
            FALSE
            );
    }

    return(MessageText);
}



VOID
vSpFormatMessageText(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  PWSTR    MessageText,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    )
{
    NTSTATUS Status;

    Status = SpRtlFormatMessage(
                 MessageText,
                 0,                         // don't bother with maximum width
                 FALSE,                     // don't ignore inserts
                 FALSE,                     // args are unicode
                 FALSE,                     // args are not an array
                 arglist,
                 LargeBuffer,
                 BufferSize,
                 ReturnLength
                 );

    ASSERT(NT_SUCCESS(Status));
}



VOID
SpFormatMessageText(
    OUT PVOID   LargeBuffer,
    IN  ULONG   BufferSize,
    IN  PWSTR   MessageText,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageText);

    vSpFormatMessageText(LargeBuffer,BufferSize,MessageText,NULL,&arglist);

    va_end(arglist);
}



VOID
vSpFormatMessage(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  ULONG    MessageId,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    )
{
    PWCHAR MessageText;

    //
    // Get the message text.
    //
    MessageText = SpRetreiveMessageText(NULL,MessageId,NULL,0);
    ASSERT(MessageText);
    if(MessageText == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: vSpFormatMessage: SpRetreiveMessageText %u returned NULL\n",MessageId));
        return;
    }

    vSpFormatMessageText(LargeBuffer,BufferSize,MessageText,ReturnLength,arglist);

    SpMemFree(MessageText);
}



VOID
SpFormatMessage(
    OUT PVOID LargeBuffer,
    IN  ULONG BufferSize,
    IN  ULONG MessageId,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageId);

    vSpFormatMessage(LargeBuffer,BufferSize,MessageId,NULL,&arglist);

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spnetupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spnetupg.c

Abstract:

    Configuration routines for the disabling the nework services

Author:

    Terry Kwan (terryk) 23-Nov-1993, provided code
    Sunil Pai  (sunilp) 23-Nov-1993, merged and modified code
    Michael Miller (MikeMi) 26-Jun-1997, updated to new model

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

// TEXT MODE FLAGS
// Note: TMF_DISABLE and TMF_REMOTE_BOOT_CRITICAL are retired.
// The only TextModeFlag with meaning now is TMF_DISABLE_FOR_DELETION.
// This flag is set during winnt32.exe to prepare networking services for
// deletion during GUI mode setup.  The start type is not saved and restored
// any longer because GUI mode setup does not allow arbitrary services to
// be auto-started.
//
#define TMF_DISABLE_FOR_DELETION    0x00000004

// TEXT MODE START DISABLE VALUE
#define STARTVALUE_DISABLE 4

NTSTATUS
SpDisableNetwork(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet )
{
    NTSTATUS Status = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING StringRegStartValueName;
    PWSTR pszServiceName;

    PUCHAR RegBuffer;
    const ULONG  cbRegBuffer = sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH+1;
    DWORD  cbSize;
    HKEY hkeyServices;
    HKEY hkeyService;
    INT i;

    DWORD dwStart;
    DWORD dwNewStart = STARTVALUE_DISABLE;
    DWORD dwFlags;

    RtlInitUnicodeString(&StringRegStartValueName, L"Start");

    RegBuffer = SpMemAlloc(cbRegBuffer);
    pszServiceName = SpMemAlloc(MAX_PATH+1);

    // open services key
    //
    INIT_OBJA( &Obja, &UnicodeString, L"Services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwOpenKey(&hkeyServices, KEY_ALL_ACCESS, &Obja);

    if (NT_SUCCESS(Status))
    {
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpDisableNetwork: Disabling network services...\n"));
        // enumerate all services
        //
        for ( i = 0;
              STATUS_SUCCESS == ZwEnumerateKey(hkeyServices,
                        i,
                        KeyBasicInformation,
                        RegBuffer,
                        cbRegBuffer,
                        &cbSize);
              i++)
        {
            ((PKEY_BASIC_INFORMATION)RegBuffer)->Name[((PKEY_BASIC_INFORMATION)RegBuffer)->NameLength/sizeof(WCHAR)] = L'\0';
            wcscpy(pszServiceName, ((PKEY_BASIC_INFORMATION)RegBuffer)->Name);

            // open the service key
            //
            INIT_OBJA(&Obja, &UnicodeString, pszServiceName);
            Obja.RootDirectory = hkeyServices;

            Status = ZwOpenKey(&hkeyService, KEY_ALL_ACCESS, &Obja);

            if (NT_SUCCESS(Status))
            {
                //  read the TextModeFlags
                //
                RtlInitUnicodeString(&UnicodeString, L"TextModeFlags");

                Status = ZwQueryValueKey(hkeyService,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        RegBuffer,
                        cbRegBuffer,
                        &cbSize);

                if (NT_SUCCESS(Status))
                {
                    // Should the service be disabled?
                    //
                    dwFlags = *((DWORD*)(&(((PKEY_VALUE_PARTIAL_INFORMATION)RegBuffer)->Data)));

                    if (dwFlags & TMF_DISABLE_FOR_DELETION)
                    {
                        Status = ZwSetValueKey(
                                    hkeyService,
                                    &StringRegStartValueName,
                                    0,
                                    REG_DWORD,
                                    &dwNewStart,
                                    sizeof(DWORD));
                    }
                }

                Status = STATUS_SUCCESS;

                ZwClose(hkeyService);
            }

            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        ZwClose(hkeyServices);
    }

    SpMemFree(pszServiceName);
    SpMemFree(RegBuffer);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spnetupg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spnetupg.h

Abstract:

    Configuration routines for the disabling the nework services

Author:

    Terry Kwan (terryk) 23-Nov-1993, provided code
    Sunil Pai  (sunilp) 23-Nov-1993, merged and modified code

Revision History:

--*/

#ifndef _SPNETUPG_H_
#define _SPNETUPG_H_

//
// Public functions
//

NTSTATUS SpDisableNetwork(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    );


//
// Private data structures and routines
//

typedef struct _NODE *PNODE;
typedef struct _NODE {
    PWSTR pszService;
    PNODE Next;
} NODE, *PNODE;


NTSTATUS
SppNetAddItem(
    PNODE *head,
    PWSTR psz
    );

NTSTATUS
SppNetAddList(
    PNODE *head,
    PWSTR psz
    );

VOID
SppNetClearList(
    PNODE *head
    );

NTSTATUS
SppNetAddToDisabledList(
    PWSTR pszService,
    HANDLE hKeySoftware
    );

NTSTATUS
SppNetGetAllNetServices(
    PVOID  SifHandle,
    PNODE *head,
    HANDLE hKeySoftware,
    HANDLE hKeyCCSet
    );

NTSTATUS
SppNetDisableServices(
    PNODE ServiceList,
    HANDLE hKeySoftware,
    HANDLE hKeyCCSet
    );

#endif // for _SPNETUPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spnttree.h ===
#ifndef _SPNTTREE_
#define _SPNTTREE_

BOOLEAN
SpNFilesExist(
    IN OUT PWSTR   PathName,
    IN     PWSTR  *Files,
    IN     ULONG   FileCount,
    IN     BOOLEAN Directories
    );

BOOLEAN
SpIsNtOnPartition(
    IN PDISK_REGION Region
    );

BOOLEAN
SpIsNtInDirectory(
    IN PDISK_REGION Region,
    IN PWSTR        Directory
    );

BOOLEAN
SpAllowRemoveNt(
    IN  PDISK_REGION    Region,
    IN  PWSTR           DriveSpec,      OPTIONAL
    IN  BOOLEAN         RescanForNTs,
    IN  ULONG           ScreenMsgId,
    OUT PULONG          SpaceFreed
    );

BOOLEAN
IsSetupLogFormatNew(
    IN  PVOID   Inf
    );

#endif // ndef _SPNTTREE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spntfix.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spntfix.c

Abstract:

    This module contains code to repair winnt installations.

Author:

    Shie-Lin Tzong (shielint) 27-Jan-1994

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


//
//  Path to the ntuser.dat hive
//
#define DEFAULT_USER_PATH   L"Users\\Default User"


//
// Global variables control which repair options should be performed.
// Initialized to ALL options.  We explicitly use 1 and 0 for true and false.
//

#ifdef _X86_
ULONG RepairItems[RepairItemMax] = { 0, 0, 0};  // BCL - Seagate - removed one.
#else
ULONG RepairItems[RepairItemMax] = { 0, 0};     // BCL
#endif

PVOID RepairGauge = NULL;

//
// global variables for delayed driver CAB opening during
// repair
//
extern PWSTR    gszDrvInfDeviceName;
extern PWSTR    gszDrvInfDirName;
extern HANDLE   ghSif;


#define ATTR_RHS (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

//**************************************************************
// S E L E C T I N G    N T   T O   REPAIR    S T U F F
//**************************************************************

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define LIST_BOX_WIDTH  50
#define LIST_BOX_HEIGHT RepairItemMax+1
#define HIVE_LIST_BOX_WIDTH  45
#define HIVE_LIST_BOX_HEIGHT RepairHiveMax+1
#define MENU_INDENT     4

VOID
SppGetRepairPathInformation(
    IN  PVOID LogFileHandle,
    OUT PWSTR *SystemPartition,
    OUT PWSTR *SystemPartitionDirectory,
    OUT PWSTR *WinntPartition,
    OUT PWSTR *WinntPartitionDirectory
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    repairable. Presents the information to the user.


Arguments:

    SifHandle  - Handle the txtsetup.sif

    SystemPartition - Supplies a variable to receive the name of System
                      partition.

    SystemPartitionDirectory - Supplies a variable to receive the name of
                      the osloader directory on the system partition.

    WinntPartition - Supplies a variable to receive the name of  winnt
                     partition.

    WinntPartitionDirectory - Supplies a variable to receive the winnt
                     directory.

Return Value:

    None.

--*/
{
    PWSTR KeyName = NULL;

    *SystemPartition = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,
                                             0);
    if (*SystemPartition == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE;
        goto ReportError;
    }
    *SystemPartitionDirectory = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY,
                                             0);
    if (*SystemPartitionDirectory == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY;
        goto ReportError;
    }

    *WinntPartition = SpGetSectionKeyIndex ( LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,
                                             0);

    if (*WinntPartition == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_TARGET_DEVICE;
        goto ReportError;
    }
    *WinntPartitionDirectory = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY,
                                             0);

    if (*WinntPartitionDirectory == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY;
        goto ReportError;
    }
ReportError:

    if (KeyName) {

        //
        // Unable to find path information.  This indicates the setup.log
        // is bad.  Inform user and exit.
        //

        SpFatalSifError(LogFileHandle,SIF_NEW_REPAIR_PATHS,KeyName,0,0);
    }
}

BOOLEAN
SpFindNtToRepair(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory,
    OUT PBOOLEAN     RepairableBootSetsFound
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    repairable. Presents the information to the user.


Arguments:

    SifHandle:    Handle the txtsetup.sif

    TargetRegion: Variable to receive the partition of the Windows NT to install
                  NULL if not chosen.

    TargetPath:   Variable to receive the target path of Windows NT.  NULL if
                  not decided.

    SystemPartitionRegion:
                  Variable to receive the system partition of the Windows NT

    SystemPartitionDirectory:
                  Variable to receive the osloader directory of the system
                  partition.

    RepairableBootSetsFound:
                  Indicates whether a repairable boot set was found. This
                  information can be used by the caller when the function
                  returns FALSE, so that the caller can determine if no
                  repairable disk was found, or if the user didn't select
                  any of the repairable systems found.

Return Value:

    A boolean value to indicate if selection has been made.

--*/
{
    NT_PRODUCT_TYPE ProductType;
    BOOLEAN  GoRepair = FALSE;
    NTSTATUS NtStatus;

    ULONG j, RepairBootSets = 0, MajorVersion, MinorVersion, BuildNumber, ProductSuiteMask;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY ChosenBootEntry;
    LCID LangId;

    UPG_PROGRESS_TYPE UpgradeProgressValue;

    //
    // Find all upgradeable boot entries. These are entries that are unique in
    // the boot entry list and are present on disk.
    //

    SpDetermineUniqueAndPresentBootEntries();

    for ( BootEntry = SpBootEntries; BootEntry != NULL ; BootEntry = BootEntry->Next ) {

        if (!BootEntry->Processable) {
            continue;
        }

        //
        // Reinitialize
        //

        BootEntry->Processable = FALSE;
        LangId = -1;

        //
        // try loading the registry and getting the following information
        // out of it:
        //
        // 1) Product type: WINNT | LANMANNT
        // 2) Major and Minor Version Number
        //
        // Based on the information, we will update the RepairableList.
        //

        NtStatus = SpDetermineProduct(
                     BootEntry->OsPartitionDiskRegion,
                     BootEntry->OsDirectory,
                     &ProductType,
                     &MajorVersion,
                     &MinorVersion,
                     &BuildNumber,
                     &ProductSuiteMask,
                     &UpgradeProgressValue,
                     NULL,
                     NULL,                   // Pid is not needed
                     NULL,                    // ignore eval variation flag
                     &LangId,                // Language Id
                     NULL                   // service pack not needed?
                     );

        if(NT_SUCCESS(NtStatus)) {

            //
            // make sure we only try to repair a build that matches the CD we have inserted
            //
            BootEntry->Processable = SpDoBuildsMatch(
                                        SifHandle,
                                        BuildNumber,
                                        ProductType,
                                        ProductSuiteMask,
                                        AdvancedServer,
                                        SuiteType,
                                        LangId
                                        );
            if( BootEntry->Processable ) {
                RepairBootSets++;
                ChosenBootEntry = BootEntry;
            }
        }
    }

    //
    // Find out how many valid boot sets there are which we can repair
    //

    *RepairableBootSetsFound = (RepairBootSets != 0);

    if ( RepairBootSets == 1 ) {

        //
        // If it is a fresh attempt at upgrade ask the user if he
        // wants to upgrade or not
        //

        GoRepair = SppSelectNTSingleRepair(
                          ChosenBootEntry->OsPartitionDiskRegion,
                          ChosenBootEntry->OsDirectory,
                          ChosenBootEntry->FriendlyName
                          );

    } else if (RepairBootSets > 1) {

        //
        // Find out if the user wants to upgrade one of the Windows
        // NT found
        //

        GoRepair = SppSelectNTMultiRepair(
                          &ChosenBootEntry
                          );
    }

    //
    // Depending on upgrade selection made do the setup needed before
    // we do the upgrade
    //

    if (GoRepair) {

        PWSTR    p1,p2,p3;
        ULONG    u;

        //
        // Return the region we are goint to repair
        //

        *TargetRegion          = ChosenBootEntry->OsPartitionDiskRegion;
        *TargetPath            = SpDupStringW(ChosenBootEntry->OsDirectory);
        *SystemPartitionRegion = ChosenBootEntry->LoaderPartitionDiskRegion;

        //
        // Process the osloader variable to extract the system partition path.
        // The var vould be of the form ...partition(1)\os\nt\... or
        // ...partition(1)os\nt\...
        // So we search forward for the first \ and then backwards for
        // the closest ) to find the start of the directory.  We then
        // search backwards in the resulting string for the last \ to find
        // the end of the directory.
        //
        p1 = ChosenBootEntry->LoaderFile;
        p2 = wcsrchr(p1, L'\\');
        if (p2 == NULL) {
            p2 = p1;
        }
        u = (ULONG)(p2 - p1);

        if(u == 0) {
            *SystemPartitionDirectory = SpDupStringW(L"");
        } else {
            p2 = p3 = SpMemAlloc((u+2)*sizeof(WCHAR));
            ASSERT(p3);
            if(*p1 != L'\\') {
                *p3++ = L'\\';
            }
            wcsncpy(p3, p1, u);
            p3[u] = 0;
            *SystemPartitionDirectory = p2;
        }
    }

    //
    // Do cleanup
    //

    CLEAR_CLIENT_SCREEN();
    return (GoRepair);
}

BOOLEAN
SppSelectNTSingleRepair(
    IN PDISK_REGION Region,
    IN PWSTR        OsLoadFileName,
    IN PWSTR        LoadIdentifier
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows NT installation.
    The user has the option to repair this or cancel.

Arguments:

    Region         - Region descriptor for the NT found

    OsLoadFileName - Directory for the NT found

    LoadIdentifier - Multi boot load identifier used for this NT.

Return Value:



--*/

{
    ULONG ValidKeys[] = { KEY_F3,ASCI_CR, ASCI_ESC, 0 };
    ULONG c;
    PWSTR TmpString = NULL;

    ASSERT(Region->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    if( Region->DriveLetter ) {
        swprintf( TemporaryBuffer,
                  L"%wc:%ws",
                  Region->DriveLetter,
                  OsLoadFileName );
        TmpString = SpDupStringW( TemporaryBuffer );
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WINNT_REPAIR,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            (Region->DriveLetter)? TmpString : OsLoadFileName,
            LoadIdentifier
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_REPAIR,
            0
            );

        if( TmpString != NULL ) {
            SpMemFree( TmpString );
        }

        switch(c=SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            return(TRUE);
        default:
            //
            // must have entered ESC
            //

            return(FALSE);
        }
    }
}

BOOLEAN
SppSelectNTMultiRepair(
    OUT PSP_BOOT_ENTRY *BootEntryChosen
    )
{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG Keypress;
    PSP_BOOT_ENTRY BootEntry,FirstRepairSet;

    while(1) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //
        SpDisplayScreen(SP_SCRN_WINNT_REPAIR_LIST,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        //

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    MENU_WIDTH,
                    VideoVars.ScreenHeight-MenuTopY-2-STATUS_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of partitions and free spaces.
        //

        FirstRepairSet = NULL;
        for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next ) {
            if( BootEntry->Processable ) {
                if( BootEntry->OsPartitionDiskRegion->DriveLetter ) {
                    swprintf(
                        TemporaryBuffer,
                        L"%wc:%ws %ws",
                        BootEntry->OsPartitionDiskRegion->DriveLetter,
                        BootEntry->OsDirectory,
                        BootEntry->FriendlyName
                        );
                } else {
                    swprintf(
                        TemporaryBuffer,
                        L"%ws %ws",
                        BootEntry->OsDirectory,
                        BootEntry->FriendlyName
                        );
                }


                SpMnAddItem(Menu,
                            TemporaryBuffer,
                            MENU_LEFT_X+MENU_INDENT,
                            MENU_WIDTH-(2*MENU_INDENT),
                            TRUE,
                            (ULONG_PTR)BootEntry
                            );
                if(FirstRepairSet == NULL) {
                   FirstRepairSet = BootEntry;
                }
            }
        }

        //
        // Initialize the status line.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_REPAIR,
            0
            );

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            (ULONG_PTR)FirstRepairSet,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            &Keypress,
            (PULONG_PTR)BootEntryChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_CR:
            SpMnDestroy(Menu);
            return( TRUE );

        default:
            SpMnDestroy(Menu);
            return(FALSE);
        }
        SpMnDestroy(Menu);
    }

}

VOID
SppRepairScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    UNREFERENCED_PARAMETER(FullTargetname);
    UNREFERENCED_PARAMETER(FullSourcename);

    //
    // Repaint the entire screen if necessary.
    //

    if(RepaintEntireScreen) {
        if( SpDrEnabled() ) {
            SpStartScreen( SP_SCRN_ASR_IS_EXAMINING,  0, 6, TRUE, FALSE, DEFAULT_ATTRIBUTE );
        }
        else {
            SpStartScreen( SP_SCRN_SETUP_IS_EXAMINING,0, 6, TRUE, FALSE, DEFAULT_ATTRIBUTE );
        }

        if(RepairGauge) {
            SpDrawGauge(RepairGauge);
        }
    }
}


BOOLEAN
SpErDiskScreen(
    BOOLEAN *HasErDisk
    )

/*++

Routine Description:

    Ask user if user has emergency repair disk.

Arguments:

    *HasErDisk - Indicates whether diskette will be used.

Return Value:

    TRUE - User chose disk or diskless.

    FALSE - User wants to return to previous screen.

--*/

{
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG MnemonicKeys[] = { MnemonicLocate, 0 };
    BOOLEAN Choosing;
    ULONG c;

    for (Choosing = TRUE; Choosing; ) {

        SpDisplayScreen(SP_SCRN_REPAIR_ASK_REPAIR_DISK,3,4);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_L_EQUALS_LOCATE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for keypress.  Valid keys:
        //
        // L = Do not use ER diskette, locate on hard disk
        // F3 = exit
        // ENTER = Use ER diskette
        // ESC = cancel, return to previous screen
        //

        SpInputDrain();

        switch(c=SpWaitValidKey(ValidKeys,NULL,MnemonicKeys)) {

        case ASCI_CR:

            //
            // User wants express setup.
            //

            *HasErDisk = TRUE;
            Choosing = FALSE;
            break;

        case (MnemonicLocate | KEY_MNEMONIC):

            //
            // User wants repair without diskette.
            //

            *HasErDisk = FALSE;
            Choosing = FALSE;
            break;

        case KEY_F3:

            //
            // User wants to exit.
            //

            SpConfirmExit();
            break;

        default:

            //
            // must be ESC
            //

            *HasErDisk = FALSE;
            Choosing = FALSE;
            return( FALSE );
        }
    }

    return( TRUE );
}

BOOLEAN
SppRepairReportError(
    IN BOOLEAN AllowEsc,
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PBOOLEAN DoNotPromptAgain
    )

/*++

Routine Description:

    Inform a user that repair has encountered some kind of error.
    The user has the option to continue or exit.

Arguments:

    AllowEsc -  Supplies a BOOLEAN to indicate if ESC is allowed.

    ErrorScreenId - The SCREEN error message number.

    SubErrorId - the sub error number

    SectionName - the name of the section which error occured.

    LineNumber - the error line number within the specified section.

Return Value:

    FALSE if ESC was pressed.

--*/

{
    ULONG ValidKeys0[] = { KEY_F3, ASCI_CR, 0 };
    ULONG ValidKeys1[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG MnemonicKeys[] = { MnemonicRepairAll, 0 };
    PULONG ValidKeys;
    PULONG  Mnemonics;
    ULONG c;
    PWSTR SubError;
    BOOLEAN rc;

    SubError = SpMemAlloc(512);

    //
    // Line numbers are 0-based.  Want to display to user as 1-based.
    //

    LineNumber++;

    //
    // Fetch/format the suberror.
    //

    SpFormatMessage(SubError, 512, SubErrorId, SectionName, LineNumber);

    //
    // Display the error screen.
    //

    SpStartScreen(
        ErrorScreenId,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        SubError
        );

    SpMemFree(SubError);

    //
    // Display status options: enter to continue.
    //

    if (AllowEsc) {
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_A_EQUALS_REPAIR_ALL,
                               SP_STAT_ESC_EQUALS_SKIP_FILE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0);
        ValidKeys = ValidKeys1;
        Mnemonics = MnemonicKeys;
        if( DoNotPromptAgain != NULL ) {
            *DoNotPromptAgain = FALSE;
        }
    } else {
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0);
        ValidKeys = ValidKeys0;
        Mnemonics = NULL;
    }

    //
    // Wait for the user to press enter.
    //

    switch(c=SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

    case KEY_F3:
        SpConfirmExit();
        break;
    case ASCI_CR:
        rc = TRUE;
        break;
    case ASCI_ESC:
        rc = FALSE;
        break;
    default:
        //
        // must be repair all mnemonic
        //
        ASSERT(c == (MnemonicRepairAll | KEY_MNEMONIC));
        if( DoNotPromptAgain != NULL ) {
            *DoNotPromptAgain = TRUE;
        }
        rc = TRUE;
        break;

    }
    CLEAR_CLIENT_SCREEN();
    return(rc);
}

BOOLEAN
SpLoadRepairLogFile(
    IN  PWCHAR  Filename,
    OUT PVOID  *Handle
    )

/*++

Routine Description:

    Load repair text file (setup.log) into memory.

Arguments:

    Filename - Supplies full filename (in NT namespace) of the file to
               be loaded.

    Handle - receives handle to loaded file, which can be
        used in subsequent calls to other text file services.

Return Value:

    BOOLEAN value to indicate if the setup.log is processed.

--*/

{
    NTSTATUS Status;
    PWSTR Version;
    ULONG ErrorSubId;
    ULONG ErrorLine;

    //
    // Load setup.log
    //

    Status = SpLoadSetupTextFile(
                Filename,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                Handle,
                &ErrorLine,
                TRUE,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        if(Status == STATUS_UNSUCCESSFUL) {

            //
            // Syntax error in setup.log file
            //

            ErrorSubId = SP_TEXT_REPAIR_INF_ERROR_1;
        } else {

            //
            // Unable to load setup.log file
            //

            ErrorLine = 0;
            ErrorSubId = SP_TEXT_REPAIR_INF_ERROR_0;
        }

        SppRepairReportError(FALSE,
                             SP_SCRN_REPAIR_INF_ERROR,
                             ErrorSubId,
                             NULL,
                             ErrorLine,
                             NULL );

        *Handle = NULL;
        return (FALSE);
    }

    //
    // Check if this setup.log file is for Winnt 3.5
    //

    Version = SpGetSectionKeyIndex(*Handle,
                                   SIF_NEW_REPAIR_SIGNATURE,
                                   SIF_NEW_REPAIR_VERSION_KEY,
                                   0);      // should be moved to spsif.c
    if(Version == NULL) {
        SppRepairReportError(FALSE,
                             SP_SCRN_REPAIR_INF_ERROR,
                             SP_TEXT_REPAIR_INF_ERROR_2,
                             NULL,
                             0,
                             NULL);
    } else {
        if(!_wcsicmp(Version,SIF_NEW_REPAIR_NT_VERSION)) {
            return(TRUE);
        } else {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR,
                                 SP_TEXT_REPAIR_INF_ERROR_5,
                                 NULL,
                                 0,
                                 NULL);
        }
    }

    //
    // Control comes here only when error occurs ...
    //

    SpFreeTextFile(*Handle);
    *Handle = NULL;
    return(FALSE);
}

VOID
SpRepairDiskette(
    OUT PVOID        *SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    )
/*++

Routine Description:

    This routine checks if there is a floppy drive.  If no, it returns
    silently.  Otherwise, it prompts user for Emergency Repair Disk.

Arguments:

    SifHandle - Supplies a variable to receive the setup.log file handle.

    TargetRegion - Supplies a variable to receive the pointer to the target
                installation region.

    TargetPath - Supplies a variable to receive the nt name of target path.

    SystemPartitionRegion - Supplies a variable to receive the pointer of the
                            system partition region.

    SystemPartitionDirectory - Supplies a variable to receive the osloader
                            directory name on the system partition.

Return Value:

    None.

--*/
{
    PWSTR szDiskName;
    BOOLEAN b, rc = FALSE;
    PWSTR FullLogFilename, p, FloppyDevicePath = L"\\device\\floppy0";
    PWSTR SystemPartition, WinntPartition;

    //
    // Assume failure.
    //

    *SifHandle = NULL;

    //
    // Always want to prompt for the disk in A:.
    // First, check if there is an A:.  If no floppy drive,
    // simply skip the request for ER diskette.
    //

    if(SpGetFloppyDriveType(0) == FloppyTypeNone) {
        return;
    }

    //
    // Fetch the generic repair disk name.
    //

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_REPAIR_DISK_NAME);
    szDiskName = SpDupStringW(TemporaryBuffer);
    p = TemporaryBuffer;
    *p = 0;
    SpConcatenatePaths(p, FloppyDevicePath);
    SpConcatenatePaths(p, SETUP_LOG_FILENAME);
    FullLogFilename = SpDupStringW(p);

    while (rc == FALSE) {

        //
        // Prompt for the disk -- ignore what may be in the drive already,
        // and allow escape.
        //

        b = SpPromptForDisk(
                szDiskName,
                FloppyDevicePath,
                SETUP_LOG_FILENAME,
                TRUE,             // Always prompt for at least once
                TRUE,             // Allow user to cancel
                FALSE,            // No multiple prompts
                NULL              // don't care about redraw flag
                );


        //
        // If the user pressed escape at the disk prompt, bail out now.
        //

        if(!b) {
            rc = TRUE;            // User canceled. Skip repair floppy
        } else {
            rc = SpLoadRepairLogFile(FullLogFilename, SifHandle);
            if (rc) {

                //
                // Now we need to figure out the partition, path information
                // to update boot.ini.
                //

                SppGetRepairPathInformation(*SifHandle,
                                            &SystemPartition,
                                            SystemPartitionDirectory,
                                            &WinntPartition,
                                            TargetPath
                                            );

                *SystemPartitionRegion = SpRegionFromNtName(
                                            SystemPartition,
                                            PartitionOrdinalCurrent);
                if (*SystemPartitionRegion == NULL) {
                    SpFatalSifError(*SifHandle,
                                    SIF_NEW_REPAIR_PATHS,
                                    SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,0,0);
                }
                *TargetRegion = SpRegionFromNtName(WinntPartition, PartitionOrdinalCurrent);
                if (*TargetRegion == NULL) {
                    SpFatalSifError(*SifHandle,
                                    SIF_NEW_REPAIR_PATHS,
                                    SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,0,0);
                }
            }
        }
    }
    SpMemFree(szDiskName);
    SpMemFree(FullLogFilename);

    return;
}

VOID
SppRepairWinntFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR WinntPartition,
    IN PWSTR WinntPartitionDirectory
    )

/*++

Routine Description:

    This routine goes through the system partition files and winnt files
    listed in the setup.log file and checks their validity.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

Return Value:

    None.

--*/
{
    PWSTR SystemPartitionFiles = L"system partition files";
    PWSTR WinntFiles = L"WinNt files";
    ULONG TotalFileCount;
    BOOLEAN RepairWithoutConfirming;

    //
    // Create file repair gauge
    //

    TotalFileCount =  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_SYSPARTFILES);
    TotalFileCount +=  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_WINNTFILES);
    TotalFileCount +=  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR);

    CLEAR_CLIENT_SCREEN();
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_EXAMINING);
    RepairGauge = SpCreateAndDisplayGauge(TotalFileCount,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
    ASSERT(RepairGauge);

    //
    // delay opening of driver inf and cab file till required
    //
    ghSif = MasterSifHandle;
    gszDrvInfDeviceName = SourceDevicePath;
    gszDrvInfDirName = DirectoryOnSourceDevice;


    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);
    SppRepairScreenRepaint(NULL, NULL, TRUE);


    //
    // first recreate all of the directories we copy into
    //
    if (SystemPartition != NULL) {
        SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
    }

    //
    // Create the nt tree.
    //
    SpCreateDirectoryStructureFromSif(MasterSifHandle,
                                      SIF_NTDIRECTORIES,
                                      WinntPartition,
                                      WinntPartitionDirectory);

    //
    // Verify and repair the files in [Files.InRepairDirectory].  If textmode
    // setup is executing a disaster recovery, do not prompt the user for the
    // files to repair.  Just go ahead and repair 'em.
    //

    RepairWithoutConfirming = SpDrEnabled() && SpDrIsRepairFast();

    SppVerifyAndRepairVdmFiles(LogFileHandle,
                               WinntPartition,
                               NULL,
                               &RepairWithoutConfirming);

    //
    // Verify and repair the files in [FIles.SystemPartition]
    //

    SppVerifyAndRepairFiles(LogFileHandle,
                            MasterSifHandle,
                            SIF_NEW_REPAIR_SYSPARTFILES,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            SystemPartition,
                            SystemPartitionDirectory,
                            TRUE,
                            &RepairWithoutConfirming);


    //
    // Verify and repair the files in [Files.WinNt]
    //

    SppVerifyAndRepairFiles(LogFileHandle,
                            MasterSifHandle,
                            SIF_NEW_REPAIR_WINNTFILES,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            WinntPartition,
                            NULL,
                            FALSE,
                            &RepairWithoutConfirming);

    SpDestroyGauge(RepairGauge);
    RepairGauge = NULL;
}


VOID
SppVerifyAndRepairFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SectionName,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN BOOLEAN SystemPartitionFiles,
    IN OUT PBOOLEAN RepairWithoutConfirming
    )

/*++

Routine Description:

    This routine goes through the files listed in the specified section of
    setup.log file and checks their validity.  If a file's checksum does
    not match the checksum listed in the setup.log file, we will prompt
    the user and recopy the file from original installation sources.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SectionName - Section in setup.log to be examined

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    SystemPartitionFile - supplies a boolean value to indicate if the target
                          file is on system partition

    RepairWithoutConfirming - Pointer to a flag that indicates whether or not
                              setup should repair a damaged file without
                              asking the user to confirm.


Return Value:

    None.

--*/
{
    PWSTR FullTargetName, ChecksumString;
    PWSTR TargetDirectory, TargetFileName;
    PWSTR SourceFileName;
    ULONG Checksum, FileChecksum, PrefixLength, Length, Count, i;
    BOOLEAN IsNtImage, IsValid, RepairFile, SysPartNTFS = FALSE;
    BOOLEAN RedrawGauge = TRUE, ForceNoComp;
    FILE_TO_COPY FileToCopy;
    PWSTR OemDiskDescription, OemDiskTag, OemSourceDirectory;
    PWSTR DevicePath, Directory, q;
    PWSTR MediaShortName, PreviousMediaName = L"";
    PWSTR MediaDir;
    NTSTATUS    Status;

    //
    // Allocate a SMALL buffer for local use and init FileToCopy struct
    //

    TargetDirectory = NULL;
    FullTargetName = SpMemAlloc(1024);
    *FullTargetName = 0;
    FileToCopy.Next = NULL;
    FileToCopy.AbsoluteTargetDirectory = TRUE;

    FileToCopy.TargetDevicePath = TargetDevicePath;
    SpConcatenatePaths(FullTargetName,TargetDevicePath);

    if(SystemPartitionFiles) {

        PDISK_REGION    SystemPartitionRegion;

        //
        // We must find out whether the system partition is NTFS, because
        // if it is, then we might want to make sure it's not compressed.
        //
        if(SystemPartitionRegion = SpRegionFromNtName(TargetDevicePath,
                                                       PartitionOrdinalCurrent)) {
            SysPartNTFS = (SystemPartitionRegion->Filesystem == FilesystemNtfs);
        }

        //
        // For system partition files, we need to concatenate target
        // directory to FullTargetName.  Because the target filename
        // of system partition files do not have target directory.
        //

        FileToCopy.TargetDirectory = DirectoryOnTargetDevice;
        SpConcatenatePaths(FullTargetName,FileToCopy.TargetDirectory);
    }

    PrefixLength = wcslen(FullTargetName);

    Count = SpCountLinesInSection(LogFileHandle,SectionName);
    for (i = 0; i < Count; i++) {
        if (RedrawGauge) {
            SppRepairScreenRepaint(NULL, NULL, TRUE);
            RedrawGauge = FALSE;
        }
        SpTickGauge(RepairGauge);

        //
        // Initialize the 'ForceNoComp' flag to FALSE, thus allowing the
        // file to use NTFS compression.
        //
        ForceNoComp = FALSE;

        //
        // Initialize target fullname to be DevicePath+Directory for
        // system partition file or DevicePath for Winnt files
        //

        FullTargetName[PrefixLength] = (WCHAR)NULL;

        //
        // If we allocate space for TargetDirectory we must free it.
        //

        if (TargetDirectory) {
            SpMemFree(TargetDirectory);
            TargetDirectory = NULL;
        }
        TargetFileName = SpGetKeyName(LogFileHandle,SectionName,i);
        if(!TargetFileName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        //
        // If the target file name contains \system32\config\, it is
        // hive related file.  We simply ignore it.
        //

        q = SpDupStringW(TargetFileName);
        SpStringToUpper(q);
        if (wcsstr(q,L"\\SYSTEM32\\CONFIG\\")) {
            SpMemFree(q);
            continue;
        }
        SpMemFree(q);

        SpConcatenatePaths(FullTargetName,TargetFileName);
        SpDisplayStatusText(SP_STAT_EXAMINING_WINNT,
                            DEFAULT_STATUS_ATTRIBUTE,
                            TargetFileName);

        ChecksumString = SpGetSectionLineIndex(LogFileHandle,SectionName,i,1);
        if(!ChecksumString) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        Checksum = (ULONG)SpStringToLong(ChecksumString, NULL, 16);

        //
        // Validate the security set on the file.
        // Note that we do not check the files in the system partition
        // on non-x86 systems since it is always FAT
        //
#ifndef _X86_
        if(!SystemPartitionFiles) {
#endif
            Status = SpVerifyFileAccess( FullTargetName,
                                         STANDARD_RIGHTS_READ |
                                         FILE_READ_ATTRIBUTES |
                                         FILE_WRITE_ATTRIBUTES |
                                         DELETE |
                                         WRITE_DAC |
                                         SYNCHRONIZE );


            if( !NT_SUCCESS( Status ) &&
                ((Status == STATUS_ACCESS_DENIED)||(Status == STATUS_PRIVILEGE_NOT_HELD)) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Security of %ls, must be fixed. Status = %x\n", FullTargetName, Status ));
                Status = SpSetDefaultFileSecurity( FullTargetName );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: unable to change security of %ls. Status = %x\n", FullTargetName, Status ));

                }
            }

#ifndef _X86_   // end of block started by "if(!SystemPartitionFiles) {" above
        }
#endif

        //
        // If this is a system partition file and the system partition is NTFS,
        // then check to see whether this file can use NTFS compression, and
        // if not, force it to be uncompressed.
        //
        if((SysPartNTFS) &&
           IsFileFlagSet(MasterSifHandle,TargetFileName,FILEFLG_FORCENOCOMP))
        {
            ForceNoComp = TRUE;
            SpVerifyNoCompression(FullTargetName);
        }

        SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&FileChecksum,&IsValid);

        //
        // If the image is invalid or the file on the target is not the
        // original file copied by setup, we will recopy it.
        //

        if (!IsValid || FileChecksum != Checksum) {

            //
            // Ask user if he wants to repair the file
            //
            if(*RepairWithoutConfirming) {
                RepairFile = TRUE;
            } else {
                RepairFile = SppRepairReportError(
                                TRUE,
                                SP_SCRN_REPAIR_FILE_MISMATCH,
                                SP_TEXT_REPAIR_INF_ERROR_4,
                                TargetFileName,
                                i,
                                RepairWithoutConfirming);
                RedrawGauge = TRUE;
            }

            if (!RepairFile) {
                continue;
            }
            SpDisplayStatusText(SP_STAT_REPAIR_WINNT,
                                DEFAULT_STATUS_ATTRIBUTE,
                                TargetFileName);

            if (SystemPartitionFiles) {
                FileToCopy.TargetFilename = TargetFileName;
            } else {

                //
                // For Winnt files, the TargetName contains path and filename.
                // We need to seperate them.
                //

                TargetDirectory = SpDupStringW(TargetFileName);
                Length = wcslen(TargetDirectory);
                while (Length) {
                    if (TargetDirectory[Length] == L'\\') {
                        TargetDirectory[Length] = 0;
                        TargetFileName = &TargetDirectory[Length + 1];
                        break;
                    } else {
                        Length--;
                    }
                }
                if (Length == 0) {
                    SppRepairReportError(FALSE,
                                         SP_SCRN_REPAIR_INF_ERROR_0,
                                         SP_TEXT_REPAIR_INF_ERROR_1,
                                         SectionName,
                                         i,
                                         NULL);
                    RedrawGauge = TRUE;
                    continue;
                }
                FileToCopy.TargetFilename = TargetFileName;
                FileToCopy.TargetDirectory = TargetDirectory;
            }
            SourceFileName = SpGetSectionLineIndex(LogFileHandle,SectionName,i,0);
            if (!SourceFileName) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }


            FileToCopy.SourceFilename = NULL;
            q = SpDupStringW(SourceFileName);
            SpStringToUpper(q);
            if (wcsstr(q,L"DRIVER.CAB")) {
                SpMemFree(q);
                q = SpDupStringW(TargetFileName);
                SpStringToUpper(q);
                if (!wcsstr(q,L"DRIVER.CAB")) {
                    FileToCopy.SourceFilename = TargetFileName;
                }
            }
            SpMemFree(q);

            FileToCopy.SourceFilename = FileToCopy.SourceFilename
                                        ? FileToCopy.SourceFilename
                                        : SourceFileName;
            FileToCopy.Flags = COPY_ALWAYS | COPY_NOVERSIONCHECK | (ForceNoComp ? COPY_FORCENOCOMP : 0);


            //
            // The file may come from OEM diskette. We need to check if the
            // sources device is listed in log file.  If not, it must be
            // from MS setup sources.
            //

            OemSourceDirectory = SpGetSectionLineIndex(LogFileHandle,SectionName,i,2);
            OemDiskTag = NULL;
            if (OemSourceDirectory) {
                OemDiskDescription = SpGetSectionLineIndex(LogFileHandle,SectionName,i,3);
                if (OemDiskDescription) {
                    OemDiskTag = SpGetSectionLineIndex(LogFileHandle,SectionName,i,4);
                    if((OemDiskTag != NULL) &&
                       (wcslen(OemDiskTag) == 0)){
                        OemDiskTag = SourceFileName;
                    }
                }
            }

            if (OemDiskTag) {
                BOOLEAN rs;
                PWSTR   szDevicePath = SpDupStringW(L"\\device\\floppy0");

                //
                // Prompt for the disk, based on the setup media type.
                //

                rs = SpPromptForDisk(
                           OemDiskDescription,
                           szDevicePath,
                           OemDiskTag,
                           FALSE,          // don't ignore disk in drive
                           TRUE,           // allow escape
                           TRUE,           // warn about multiple prompts for same disk
                           NULL            // don't care redraw flag
                           );

                SpMemFree(szDevicePath);
                RedrawGauge = TRUE;

                if (rs == FALSE) {
                    continue;
                }

                DevicePath = L"\\device\\floppy0";
                Directory = OemSourceDirectory;
                MediaDir = NULL;
            } else {
                PWSTR   szDescription = 0, szTagFileName = 0;
                BOOLEAN bDiskFound = FALSE;

                //
                // Search SourceFileName against txtsetup.sif to figure out its
                // media name.
                //
                MediaShortName = SpLookUpValueForFile(
                                    MasterSifHandle,
                                    SourceFileName,
                                    INDEX_WHICHMEDIA,
                                    FALSE
                                    );

                if(MediaShortName) {
                    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDir);
                } else {
                    SpNonFatalSifError(
                        MasterSifHandle,
                        SIF_FILESONSETUPMEDIA,
                        SourceFileName,
                        0,
                        INDEX_WHICHMEDIA,
                        SourceFileName
                        );
                    //
                    // If we returned from SpNonFatalSifError, then the user wants to
                    // skip the file.
                    //
                    RedrawGauge = TRUE;
                    continue;
                }

                //
                // Prompt user to insert the source media, if changed.
                //
                SpGetSourceMediaInfo(MasterSifHandle, MediaShortName,
                                        &szDescription, &szTagFileName, NULL);

                //
                // Prompt for the disk, based on the setup media type.
                //
                bDiskFound = SpPromptForDisk(
                                szDescription,
                                SourceDevicePath,
                                szTagFileName,
                                FALSE,          // don't ignore disk in drive
                                TRUE,           // don't allow escape
                                TRUE,           // warn about multiple prompts for same disk
                                NULL            // don't care redraw flag
                                );

                RedrawGauge = TRUE;

                //
                // user might have wanted to skip the file
                //
                if (!bDiskFound)
                    continue;

                DevicePath = SourceDevicePath;
                Directory = DirectoryOnSourceDevice;
            }

            //
            // Copy the file.
            //
            // If the file is listed for lock smashing then we need to smash it
            // if installing UP on x86 (we don't bother with the latter
            // qualifications here).
            //

            SpCopyFileWithRetry(
                &FileToCopy,
                DevicePath,
                Directory,
                MediaDir,
                NULL,                          // TargetRoot -> NULL
                SystemPartitionFiles ? ATTR_RHS : 0,
                SppRepairScreenRepaint,
                NULL,                          // Do not want checksum
                NULL,                          // Do not want to know if file was skipped
                IsFileFlagSet(
                    MasterSifHandle,
                    FileToCopy.TargetFilename,
                    FILEFLG_SMASHLOCKS) ? COPY_SMASHLOCKS : 0
                );
        }
    }

    SpMemFree(FullTargetName);
    if (RedrawGauge) {
        SppRepairScreenRepaint(NULL, NULL, TRUE);
    }
}


BOOLEAN
SpDisplayRepairMenu(
    VOID
    )
/*++

Routine Description:

    This routine presents a list of repairable items to user and
    let user choose the items to be fixed among the list.

Arguments:

    None.

Return Value:

    None. Some global repare variables are set or cleared.

--*/

{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG Keypress, MessageIds[RepairItemMax];
    ULONG i;
    ULONG_PTR OptionChosen, InitialHighlight;
    PWSTR MenuItem;
    ULONG ListBoxWidth, curLBEntryWidth;

    //
    // Initialize repair options to repair ALL.
    // Initialize repair menu item message id.
    //

    for (i = 0; i < RepairItemMax; i++) {
        RepairItems[i] = 1;
        if (i == 0) {
            MessageIds[i] = SP_REPAIR_MENU_ITEM_1;
        } else {
            MessageIds[i] = MessageIds[i - 1] + 1;
        }
    }

    while(1) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //

        SpDisplayScreen(SP_SCRN_REPAIR_MENU,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        // First, find the longest string, so we can size the listbox accordingly
        //
        ListBoxWidth = LIST_BOX_WIDTH;   // It will be at least this wide
        for (i = 0; i <= RepairItemMax; i++ ) {
            if (i == RepairItemMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
            }
            if((curLBEntryWidth = SplangGetColumnCount(TemporaryBuffer)+(2*MENU_INDENT)) > ListBoxWidth) {
                ListBoxWidth = min(curLBEntryWidth, MENU_WIDTH);
            }
        }

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    ListBoxWidth,
                    LIST_BOX_HEIGHT
                    );

        if( !Menu )
            return FALSE;

        ASSERT(Menu);

        for (i = 0; i <= RepairItemMax; i++ ) {
            if (i == RepairItemMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);

                (TemporaryBuffer)[1] = RepairItems[i] ? L'X' : L' ';
            }
            SpMnAddItem(Menu,
                        TemporaryBuffer,
                        MENU_LEFT_X+MENU_INDENT,
                        ListBoxWidth-(2*MENU_INDENT),
                        TRUE,
                        i
                        );
        }
        InitialHighlight = RepairItemMax;

        //
        // Initialize the status line.
        //

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_CHANGE,
            0
            );

DisplayMenu:

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            InitialHighlight,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            &Keypress,
            &OptionChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {


            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_CR:
                if (OptionChosen == RepairItemMax) {
                    SpMnDestroy(Menu);
                    return( TRUE );
                } else {
                    MenuItem = SpMnGetText(Menu, OptionChosen);
                    if( !MenuItem )
                        goto DisplayMenu;
                    RepairItems[OptionChosen] ^= 1;
                    if (RepairItems[OptionChosen]) {
                        MenuItem[1] = L'X';
                    } else {
                        MenuItem[1] = L' ';
                    }
                    InitialHighlight = OptionChosen;
                    goto DisplayMenu;
                }
                break;

            default:
                SpMnDestroy(Menu);
                return(FALSE);
        }
        SpMnDestroy(Menu);
    }
}

NTSTATUS
SppRepairFile(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetPath,
    IN PWSTR TargetFilename,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR SourceFilename,
    IN BOOLEAN SystemPartitionFile
    )

/*++

Routine Description:

    This routine repairs ONE file and the source of the file MUST be on
    emergency repair diskette or on the repair directory of the winnt
    being repaired.

Arguments:

    MasterSifHandle - Hanle of the txtsetup.sif

    TargetPath - Supplies the target file path

    TargetFilename - supplies the name of the target file

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

    SourceFilename - supplies the name of the source file

    SystemPartitionFile - supplies a boolean value to indicate if the target
                          file is on system partition

Return Value:

    NTSTATUS of the file copy.

--*/
{
    PWSTR szDiskName;
    PWSTR FullSourceFilename, FullTargetFilename;
    NTSTATUS Status;

    if (RepairFromErDisk) {

        //
        // Fetch the generic repair disk name.
        //

        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),
                        SP_TEXT_REPAIR_DISK_NAME);
        szDiskName = SpDupStringW(TemporaryBuffer);

        //
        // Prompt for the disk -- do not ignore what may be in the drive
        // already, and dont allow escape.
        //

        SpPromptForDisk(
                szDiskName,
                SourceDevicePath,
                SETUP_LOG_FILENAME,
                FALSE,              // if disk is in already dont prompt
                FALSE,              // Do not allow user to cancel
                TRUE,               // warn for multiple prompts
                NULL                // don't care about redraw flag
                );


        SpMemFree(szDiskName);
    }

    //
    // Form the name of the source and target fullname.
    //

    wcscpy(TemporaryBuffer, TargetPath);
    SpConcatenatePaths(TemporaryBuffer, TargetFilename);
    FullTargetFilename = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths(TemporaryBuffer, DirectoryOnSourceDevice);
    SpConcatenatePaths(TemporaryBuffer, SourceFilename);
    FullSourceFilename = SpDupStringW(TemporaryBuffer);

    //
    // Copy the file.
    //
    // If the file is listed for lock smashing then we need to smash it
    // if installing UP on x86 (we don't bother with the latter
    // qualifications here).
    //

    Status = SpCopyFileUsingNames(
               FullSourceFilename,
               FullTargetFilename,
               SystemPartitionFile ? ATTR_RHS : 0,
               IsFileFlagSet(MasterSifHandle,TargetFilename,FILEFLG_SMASHLOCKS) ? COPY_SMASHLOCKS : 0
               );

    SpMemFree(FullSourceFilename);
    SpMemFree(FullTargetFilename);
    return(Status);
}

VOID
SppRepairStartMenuGroupsAndItems(
    IN PWSTR        WinntPartition,
    IN PWSTR        WinntDirectory
    )

/*++

Routine Description:

    This routine loads the software hive, and set a value on Winlogon key
    to indicate to Winlogon that it should recreate the Start Menu groups
    and items for the Default User.

Arguments:

    WinntPartition - supplies the NT name of the Winnt partition.

    WinntDirectory - Supplies the name of the Winnt directory.


Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    PWSTR             p,q;
    PWSTR             LOCAL_MACHINE_KEY_NAME = L"\\registry\\machine";
    ULONG             Repair = 1;
    PWSTR             WINLOGON_KEY_NAME = L"Microsoft\\Windows NT\\CurrentVersion\\Winlogon";
    PWSTR             REPAIR_VALUE_NAME = L"Repair";
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    HANDLE            SoftwareKey;

    //
    // Put up a screen telling the user what we are doing.
    //

//    SpStartScreen(SP_SCRN_REPAIR_CHECK_HIVES,
//                  0,
//                  8,
//                  TRUE,
//                  FALSE,
//                  DEFAULT_ATTRIBUTE
//                  );
//
//    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Load the software hive
    //

    //
    // Form the name of the hive file.
    // This is WinntPartition + WinntDirectory + system32\config + the hive name.
    //
    p = NULL;
    q = NULL;
    wcscpy(TemporaryBuffer,WinntPartition);
    SpConcatenatePaths(TemporaryBuffer,WinntDirectory);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config\\software");
    p = SpDupStringW( TemporaryBuffer );

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(TemporaryBuffer,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(TemporaryBuffer,L"x");
    wcscat(TemporaryBuffer,L"software");
    q = SpDupStringW( TemporaryBuffer );

    if( (p == NULL) || (q == NULL) ) {
        goto fix_strtmenu_cleanup_1;
    }

    //
    // Attempt to load the hive.
    //

    Status = SpLoadUnloadKey(NULL,NULL,q,p);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",p,q,Status));
        goto fix_strtmenu_cleanup_1;
    }

    INIT_OBJA(&Obja,&UnicodeString,q);
    Status = ZwOpenKey(&SoftwareKey,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",q,Status));
        goto fix_strtmenu_cleanup_2;
    }

    Status = SpOpenSetValueAndClose(
                SoftwareKey,
                WINLOGON_KEY_NAME,
                REPAIR_VALUE_NAME,
                REG_DWORD,
                &Repair,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws on key %ws. Status = %lx\n",REPAIR_VALUE_NAME,REPAIR_VALUE_NAME,Status));
        goto fix_strtmenu_cleanup_3;
    }
    Status = ZwFlushKey(SoftwareKey );

fix_strtmenu_cleanup_3:

    Status = ZwClose( SoftwareKey );

fix_strtmenu_cleanup_2:

    Status = SpLoadUnloadKey(NULL,NULL,q,NULL);

fix_strtmenu_cleanup_1:
    if( p != NULL ) {
        SpMemFree( p );
    }
    if( q != NULL ) {
        SpMemFree( q );
    }
}

VOID
SppInspectHives(
    IN PWSTR        PartitionPath,
    IN PWSTR        SystemRoot,
    OUT PULONG      HiveLoaded,
    IN PWSTR        *HiveNames
    )

/*++

Routine Description:

    This routine inspects setup hives by loading and unloading them and
    returns the loadable information in HiveLoaded[].

Arguments:

    PartitionPath - supplies the NT name of the Winnt partition.

    SystemRoot - Supplies the name of the Winnt System root.

    HiveLoaded - Supplies a pointer to a ULONG array to receive the
                 loadable information for each hive inspected.

    HIveNames - Supplies a pointer to a PWSTR array to receive the
                name of hives to inspect.

Return Value:

    None.  HiveLoaded array initialized.

--*/
{
    NTSTATUS Status;
    PWSTR pwstrTemp1,pwstrTemp2;
    int h;
    PWSTR   LOCAL_MACHINE_KEY_NAME = L"\\registry\\machine";

    //
    // Put up a screen telling the user what we are doing.
    //

    SpStartScreen(SP_SCRN_REPAIR_CHECK_HIVES,
                  0,
                  8,
                  TRUE,
                  FALSE,
                  DEFAULT_ATTRIBUTE
                  );

    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Load each template hive we care about from the target tree.
    //

    for (h = 0; h < RepairHiveMax; h++) {

        pwstrTemp1 = TemporaryBuffer;
        pwstrTemp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

        if( h != RepairHiveUser ) {
            //
            // Form the name of the hive file.
            // This is partitionpath + sysroot + system32\config + the hive name.
            //

            wcscpy(pwstrTemp1,PartitionPath);
            SpConcatenatePaths(pwstrTemp1,SystemRoot);
            SpConcatenatePaths(pwstrTemp1,L"system32\\config");
            SpConcatenatePaths(pwstrTemp1,HiveNames[h]);

        } else {
            wcscpy(pwstrTemp1,PartitionPath);
            SpConcatenatePaths(pwstrTemp1,DEFAULT_USER_PATH);
            SpConcatenatePaths(pwstrTemp1,HiveNames[h]);
        }

        //
        // First we must verify that the hive file exists.  We have to do
        // this because loading a hive will create one if it didn't already
        // exist!
        //
        if(!SpFileExists(pwstrTemp1, FALSE)) {
            HiveLoaded[h] = 0;
            continue;
        }

        //
        // Form the path of the key into which we will
        // load the hive.  We'll use the convention that
        // a hive will be loaded into \registry\machine\x<hivename>.
        //

        wcscpy(pwstrTemp2,LOCAL_MACHINE_KEY_NAME);
        SpConcatenatePaths(pwstrTemp2,L"x");
        wcscat(pwstrTemp2,HiveNames[h]);

        //
        // Attempt to load the hive.
        //

        HiveLoaded[h] = 0;
        Status = SpLoadUnloadKey(NULL,NULL,pwstrTemp2,pwstrTemp1);

        if (NT_SUCCESS(Status) || Status == STATUS_NO_MEMORY) {

            //
            // If the reason the hive did not load is because of not
            // enough memory.  We assume the hive is OK.
            //

            HiveLoaded[h] = 1;

            //
            // Unload the hive.
            //

            SpLoadUnloadKey(NULL,NULL,pwstrTemp2,NULL);
        }
    }

    //
    // Sam and security hives must be updated together.  If any one of
    // them failed to load, we must update both.
    //

    if ((HiveLoaded[RepairHiveSecurity] == 0) ||
        (HiveLoaded[RepairHiveSam] == 0)) {
        HiveLoaded[RepairHiveSam] = 0;
        HiveLoaded[RepairHiveSecurity] = 0;
    }
}

VOID
SppRepairHives(
    PVOID MasterSifHandle,
    PWSTR WinntPartition,
    PWSTR WinntPartitionDirectory,
    PWSTR SourceDevicePath,
    PWSTR DirectoryOnSourceDevice
    )
/*++

Routine Description:

    This routine inspects hives and let user choose the hives which he
    wants to repair.

Arguments:

    MasterSifHandle - The handle of textsetup.sif

    WinntPartition - The nt name of Winnt partition

    WinntPartitionDirectory - The directory name of winnt installation

    SourceDevicePath - The NT name of source device which contains hives

    DirectoryOnSourceDevice - The directory name of source device

Return Value:

    None.

--*/

{
    //
    //  Do not change the order of the files in 'HiveNames' array.
    //  If you do that, you also need to change the order of the
    //  enum 'RepairHive' in spntfix.h
    //
    PWSTR HiveNames[RepairHiveMax] = { L"system",L"software",L"default",L"ntuser.dat",L"security",L"sam"};
    ULONG HiveLoaded[RepairHiveMax];
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, 0 };
    ULONG ValidKeys1[] = { KEY_F3, ASCI_CR, 0 };
    ULONG i;
    ULONG_PTR InitialHighlight, OptionChosen;
    PWSTR MenuItem, TargetPath, p;
    ULONG Keypress, MessageIds[RepairHiveMax];
    BOOLEAN Selectable;
    NTSTATUS Status;
    ULONG ListBoxWidth, curLBEntryWidth;
    BOOLEAN DetermineHivesToRepair;

    //
    // Inspect hives by loading hives to determine which hives need to be
    // fixed.
    //

    SppInspectHives(WinntPartition,
                    WinntPartitionDirectory,
                    HiveLoaded,
                    HiveNames);

    // BCL - Seagate: If doing ASR, don't do the menu.
    if ( SpDrEnabled() ) {
        goto UpdateTheHives;
    }

    //
    // Initialize hive menu item message id.
    //

    for (i = 0; i < RepairHiveMax; i++) {
        if (i == 0) {
            MessageIds[i] = SP_REPAIR_HIVE_ITEM_1;
        } else {
            MessageIds[i] = MessageIds[i - 1] + 1;
        }
    }


    DetermineHivesToRepair = TRUE;
    while(DetermineHivesToRepair) {
        //
        // Display the text that goes above the menu on the partitioning screen.
        //

        SpDisplayScreen(SP_SCRN_REPAIR_HIVE_MENU,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        // First, find the longest string, so we can size the listbox accordingly
        //
        ListBoxWidth = HIVE_LIST_BOX_WIDTH;   // It will be at least this wide
        for (i = 0; i <= RepairHiveMax; i++ ) {
            if (i == RepairHiveMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
            }
            if((curLBEntryWidth = SplangGetColumnCount(TemporaryBuffer)+(2*MENU_INDENT)) > ListBoxWidth) {
                ListBoxWidth = min(curLBEntryWidth, MENU_WIDTH);
            }
        }

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    ListBoxWidth,
                    HIVE_LIST_BOX_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of hives
        //

        for (i = 0; i <= RepairHiveMax; i++ ) {
            if (i == RepairHiveSam) {
                Selectable = FALSE;
            } else {
                Selectable = TRUE;
            }
            if (i == RepairHiveMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
                p = TemporaryBuffer;
                if (HiveLoaded[i] || ( i == RepairHiveSam )) {
                    p[1] = L' ';
                } else {
                    p[1] = L'X';
                }
            }
            SpMnAddItem(Menu,
                        TemporaryBuffer,
                        MENU_LEFT_X+MENU_INDENT,
                        ListBoxWidth-(2*MENU_INDENT),
                        Selectable,
                        i
                        );
        }
        InitialHighlight = RepairHiveMax;

        //
        // Initialize the status line.
        //

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CHANGE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

DisplayMenu:

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            InitialHighlight,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            &Keypress,
            &OptionChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {


            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_CR:
                if (OptionChosen == RepairHiveMax) {
                    SpMnDestroy(Menu);
                    DetermineHivesToRepair = FALSE;
                } else {
                    HiveLoaded[OptionChosen] ^= 1;
                    MenuItem = SpMnGetText(Menu, OptionChosen);
                    if ((HiveLoaded[OptionChosen] != 0) ||
                        (OptionChosen == RepairHiveSam)){
                        MenuItem[1] = L' ';
                    } else {
                        MenuItem[1] = L'X';
                    }

                    //
                    // Security and sam must go together.
                    //

                    HiveLoaded[RepairHiveSam] = HiveLoaded[RepairHiveSecurity];
                    InitialHighlight = OptionChosen;
                    goto DisplayMenu;
                }
                break;
        }
    }

UpdateTheHives:

    //
    // At this point user has decided which hives to repair.
    // We will copy the hives from repair disk to
    // Winnt\system32\config directory.
    //

    for (i = 0; i < RepairHiveMax; i++ ) {

        // BCL - Seagate: Don't do ntuser.dat. As of 4/17/98, there is no
        // copy of this file to copy from.
        if ( SpDrEnabled() && i == RepairHiveUser ) {
            continue;
        }

        if (HiveLoaded[i] == 0) {

            //
            // Form Target path
            //

            if( i != RepairHiveUser ) {
                wcscpy(TemporaryBuffer, WinntPartition);
                SpConcatenatePaths(TemporaryBuffer, WinntPartitionDirectory);
                SpConcatenatePaths(TemporaryBuffer, L"\\SYSTEM32\\CONFIG");
                TargetPath = SpDupStringW(TemporaryBuffer);
            } else {
                wcscpy(TemporaryBuffer, WinntPartition);
                SpConcatenatePaths(TemporaryBuffer, WinntPartitionDirectory);
                SpConcatenatePaths(TemporaryBuffer, DEFAULT_USER_PATH);
                TargetPath = SpDupStringW(TemporaryBuffer);
            }

            Status = SppRepairFile(MasterSifHandle,
                                   TargetPath,
                                   HiveNames[i],
                                   SourceDevicePath,
                                   DirectoryOnSourceDevice,
                                   HiveNames[i],
                                   FALSE
                                   );
            if (!NT_SUCCESS(Status)) {

                //
                // Tell user we couldn't do it.  Options are to continue or exit.
                //

                SpStartScreen(
                    SP_SCRN_REPAIR_HIVE_FAIL,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys1,NULL,NULL)) {
                    case ASCI_CR:
                         return;
                         break;

                    case KEY_F3:
                         SpConfirmExit();
                         break;
                }
            }
            SpMemFree(TargetPath);
        }
    }
}

VOID
SpRepairWinnt(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    This is a the top level repair rutine.  It calls worker routines
    for each repair options that user selected.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SourceDevicePath - The NT name for the repair source device.

    DirectoryOnSourceDevice -  The directory name on the repair source
                               device which contains the source files.

Return Value:

    None.

--*/
{

    PWSTR SystemPartition, SystemPartitionDirectory;
    PWSTR WinntPartition, WinntPartitionDirectory;
    PWSTR HiveRepairSourceDevice, DirectoryOnHiveRepairSource;

    //
    // Initialize the diamond decompression engine.
    //
    SpdInitialize();

    //
    // Determine SystemPartition, SystemPartitionDirectory.
    // WinntParition and WinntPartitionDirectory of the WINNT
    // installation to be repaired.
    //

    SppGetRepairPathInformation(LogFileHandle,
                                &SystemPartition,
                                &SystemPartitionDirectory,
                                &WinntPartition,
                                &WinntPartitionDirectory
                                );

    //
    //  If repair involves disk access, then run autochk on Nt and system
    //  partitions.
    //
    if( RepairItems[RepairFiles]
#ifdef _X86_
        ||
        RepairItems[RepairNvram]
#endif
      ) {
        PDISK_REGION    SystemPartitionRegion;
        PDISK_REGION    WinntPartitionRegion;

        WinntPartitionRegion = SpRegionFromNtName( WinntPartition,
                                                    PartitionOrdinalCurrent);

        SystemPartitionRegion = SpRegionFromNtName( SystemPartition,
                                                     PartitionOrdinalCurrent);

        if( !RepairNoCDROMDrive ) {
            //
            //  If we know that the system doesn't have a CD-ROM drive,
            //  then don't even attempt to run autochk.
            //
            SpRunAutochkOnNtAndSystemPartitions( MasterSifHandle,
                                                 WinntPartitionRegion,
                                                 SystemPartitionRegion,
                                                 SourceDevicePath,
                                                 DirectoryOnSourceDevice,
                                                 NULL
                                                 );
        }
    }

    //
    // Verify and repair security of the directories that form the NT tree
    // This needs to be done before repairing the hives because the
    // system32\config directory might not be there anymore!
    //
    SppVerifyAndRepairNtTreeAccess(MasterSifHandle,
                                   WinntPartition,
                                   WinntPartitionDirectory,
                                   SystemPartition,
                                   SystemPartitionDirectory
                                   );

#if 0
// BCL - Seagate - the RepairHives member has been removed from the
// struct

    if (RepairItems[RepairHives]) {

        //
        // User has selected to repair hives.  If user has provided the
        // ER disk, we will copy the hive from ER disk to repair damaged
        // hives.  Otherwise we copy the hive from the directory where
        // setup.log was loaded.
        //

        if (RepairFromErDisk) {
            HiveRepairSourceDevice = L"\\device\\floppy0";
            DirectoryOnHiveRepairSource = L"";
        } else {
            HiveRepairSourceDevice = WinntPartition;
            wcscpy(TemporaryBuffer, WinntPartitionDirectory);
            SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
            DirectoryOnHiveRepairSource = SpDupStringW(TemporaryBuffer);
        }
        SppRepairHives(MasterSifHandle,
                       WinntPartition,
                       WinntPartitionDirectory,
                       HiveRepairSourceDevice,
                       DirectoryOnHiveRepairSource
                       );
        if (!RepairFromErDisk) {
            SpMemFree(DirectoryOnHiveRepairSource);
        }
    }
    if (RepairItems[RepairFiles]) {
        SppRepairWinntFiles(LogFileHandle,
                            MasterSifHandle,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            SystemPartition,
                            SystemPartitionDirectory,
                            WinntPartition,
                            WinntPartitionDirectory
                            );
    }
#endif

    //
    // The code to repair nvram variables and boot sector is
    // incorporated into SpStartSetup.
    //

    //
    //  Load the software hive, and and set the repair flag under Winlogon,
    //  so that winlogon can recreate the start menu groups and items for
    //  the default user.
    //
    SppRepairStartMenuGroupsAndItems( WinntPartition,
                                      WinntPartitionDirectory );

    //
    // Terminate diamond.
    //
    SpdTerminate();

}


VOID
SppVerifyAndRepairNtTreeAccess(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory
    )

/*++

Routine Description:

    This routine examines whether or not the directories that form the
    NT tree are accessible, and set the appropriate security descriptor
    in each directory, when necessary.

Arguments:

    MasterSifHandle - Hanle of the txtsetup.sif

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    SystemPartition - supplies the nt name of the target device (non-x86 platforms)

    SystemPartitionDirectory - the name of the winnt directory on target
                               device (non-x86 platforms)

Return Value:

    None.

--*/
{
    ULONG       Count, i;
    PWSTR       SectionName = L"WinntDirectories";
    PWSTR       DirectoryName;
    PWSTR       TargetPath;
    PWSTR       WinNtDirectory;
    NTSTATUS    Status;

    SpDisplayStatusText(SP_STAT_SETUP_IS_EXAMINING_DIRS, DEFAULT_STATUS_ATTRIBUTE);
    if(SpIsArc()){
    //
    // Make sure that on ARC platforms, the system partition directory
    // exists (re-create it if it doesn't exist)
    //
    SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
    }

    WinNtDirectory = ( PWSTR )SpMemAlloc( ( wcslen( TargetDevicePath ) + 1 +
                                          wcslen( DirectoryOnTargetDevice ) + 1 +
                                          1 )*sizeof( WCHAR ) );
    TargetPath = ( PWSTR )SpMemAlloc( 1024 );
    if( ( WinNtDirectory == NULL ) ||
        ( TargetPath == NULL ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory for WinNtDirectory \n"));
        if( WinNtDirectory != NULL ) {
            SpMemFree( WinNtDirectory );
        }
        if( TargetPath != NULL ) {
            SpMemFree( TargetPath );
        }
        return;
    }
    wcscpy( WinNtDirectory, TargetDevicePath );
    SpConcatenatePaths( WinNtDirectory, DirectoryOnTargetDevice );

    Count = SpCountLinesInSection(MasterSifHandle, SectionName);
    //
    //  Note that in the loop below, the maximum value for 'i' is 'Count'
    //  instead of 'Count-1'. This is because we need to create the directory
    //  'Profiles\\Default User' which cannot be listed in txtsetup.sif.
    //  This is due to pre-install requirements, and DOS limitation regarding
    //  long file names.
    //
    for (i = 0; i <= Count; i++) {
        if( i != Count ) {
            DirectoryName = SpGetSectionLineIndex(MasterSifHandle,SectionName,i,0);
        } else {
            //
            //  Due to pre-installation requirements, and DOS limitation
            //  regarding long file names, the "Default User" directory
            //  is not specified on txtsetup.sif, as the other directories.
            //  This directory is treated as a special case in the
            //  repair process.
            //
            DirectoryName = DEFAULT_USER_PATH;
        }
        if(!DirectoryName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            continue;
        }
        wcscpy( TargetPath, WinNtDirectory );
        //
        //  Make sure that TargetPath doesn't contain '\' as the last character
        //
        if(!((DirectoryName[0] == L'\\') && (DirectoryName[1] == 0))) {
            SpConcatenatePaths( TargetPath, DirectoryName );
        }

        Status = SpVerifyFileAccess( TargetPath,
                                     STANDARD_RIGHTS_READ |
                                     FILE_READ_ATTRIBUTES |
                                     FILE_LIST_DIRECTORY |
                                     FILE_ADD_FILE |
                                     FILE_ADD_SUBDIRECTORY |
                                     FILE_TRAVERSE |
                                     WRITE_DAC |
                                     SYNCHRONIZE );

        //
        //  If unable to access the directory, try to determine why.
        //  If it is because of access denied, change the directory security.
        //  If it is because the directory doesn't exist, then create it.
        //
        if( !NT_SUCCESS( Status ) ) {
            if ((Status == STATUS_ACCESS_DENIED)||(Status == STATUS_PRIVILEGE_NOT_HELD) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Security of %ls, must be fixed. Status = %x\n", TargetPath, Status ));
                Status = SpSetDefaultFileSecurity( TargetPath );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: unable to change security of %ls. Status = %x\n", TargetPath, Status ));
                }
            } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                if(((DirectoryName[0] == L'\\') && (DirectoryName[1] == 0))) {
                    //
                    //  Create the target directory
                    //
                    SpCreateDirectory( TargetDevicePath,
                                       NULL,
                                       DirectoryOnTargetDevice,
                                       0,
                                       0);
                } else {
                    SpCreateDirectory( TargetDevicePath,
                                       DirectoryOnTargetDevice,
                                       DirectoryName,
                                       0,
                                       0);
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to access directory %ls. Status = %x\n", TargetPath, Status ));
            }
        }
    }

    if( WinNtDirectory != NULL ) {
        SpMemFree( WinNtDirectory );
    }
    if( TargetPath != NULL ) {
        SpMemFree( TargetPath );
    }
    return;
}

VOID
SppVerifyAndRepairVdmFiles(
    IN PVOID LogFileHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PBOOLEAN RepairWithoutConfirming
    )

/*++

Routine Description:

    This routine repairs the Vdm configuration files listed on
    'Files.InRepairDirectory' of setup.log. Currently, such files are:
    autoexec.nt and config.nt. It is assumed that files in this section
    will be copied from the emergency repair disk, or from the repair
    directory.

Arguments:

    LogFileHandle - Handle of the setup.log

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    RepairWithoutConfirming - Pointer to a flag that indicates whether or not
                              setup should repair files without confirming
                              with the user.

Return Value:

    None.

--*/
{
    PWSTR FullTargetName, ChecksumString;
    PWSTR TargetDirectory, TargetFileName;
    PWSTR SourceFileName;
    ULONG Checksum, FileChecksum, PrefixLength, Length, Count, i;
    BOOLEAN IsNtImage, IsValid, RepairFile;
    BOOLEAN RedrawGauge = TRUE;
    FILE_TO_COPY FileToCopy;
    PWSTR DevicePath, Directory;
    PWSTR SectionName = SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR;

    //
    // Allocate a SMALL buffer for local use and init FileToCopy struct
    //

    TargetDirectory = NULL;
    FullTargetName = SpMemAlloc(1024);
    *FullTargetName = 0;
    FileToCopy.Next = NULL;
    FileToCopy.Flags = COPY_ALWAYS;
    FileToCopy.AbsoluteTargetDirectory = TRUE;

    FileToCopy.TargetDevicePath = TargetDevicePath;
    SpConcatenatePaths(FullTargetName,TargetDevicePath);

    PrefixLength = wcslen(FullTargetName);

    Count = SpCountLinesInSection(LogFileHandle,SectionName);
    for (i = 0; i < Count; i++) {
        if (RedrawGauge) {
            SppRepairScreenRepaint(NULL, NULL, TRUE);
            RedrawGauge = FALSE;
        }
        SpTickGauge(RepairGauge);

        //
        // Initialize target fullname to be DevicePath+Directory for
        // system partition file or DevicePath for Winnt files
        //

        FullTargetName[PrefixLength] = (WCHAR)NULL;

        //
        // If we allocate space for TargetDirectory we must free it.
        //

        if (TargetDirectory) {
            SpMemFree(TargetDirectory);
            TargetDirectory = NULL;
        }
        TargetFileName = SpGetKeyName(LogFileHandle,SectionName,i);
        if(!TargetFileName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        SpConcatenatePaths(FullTargetName,TargetFileName);
        SpDisplayStatusText(SP_STAT_EXAMINING_WINNT,
                            DEFAULT_STATUS_ATTRIBUTE,
                            TargetFileName);

        ChecksumString = SpGetSectionLineIndex(LogFileHandle,SectionName,i,1);
        if(!ChecksumString) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        Checksum = (ULONG)SpStringToLong(ChecksumString, NULL, 16);

        SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&FileChecksum,&IsValid);

        //
        // If the image is invalid or the file on the target is not the
        // original file copied by setup, we will recopy it.
        //

        if (!IsValid || FileChecksum != Checksum) {

            //
            // Ask user if he wants to repair the file
            //

            RepairFile = ( *RepairWithoutConfirming )?
                         TRUE :
                         SppRepairReportError(
                                          TRUE,
                                          SP_SCRN_REPAIR_FILE_MISMATCH,
                                          SP_TEXT_REPAIR_INF_ERROR_4,
                                          TargetFileName,
                                          i,
                                          RepairWithoutConfirming);

            RedrawGauge = TRUE;
            if (!RepairFile) {
                continue;
            }
            SpDisplayStatusText(SP_STAT_REPAIR_WINNT,
                                DEFAULT_STATUS_ATTRIBUTE,
                                TargetFileName);


            //
            // TargetName contains path and filename.
            // We need to seperate them.
            //

            TargetDirectory = SpDupStringW(TargetFileName);
            Length = wcslen(TargetDirectory);
            while (Length) {
                if (TargetDirectory[Length] == L'\\') {
                    TargetDirectory[Length] = 0;
                    TargetFileName = &TargetDirectory[Length + 1];
                    break;
                } else {
                    Length--;
                }
            }
            if (Length == 0) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }
            FileToCopy.TargetFilename = TargetFileName;
            FileToCopy.TargetDirectory = TargetDirectory;

            SourceFileName = SpGetSectionLineIndex(LogFileHandle,SectionName,i,0);
            if (!SourceFileName) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }
            FileToCopy.SourceFilename = SourceFileName;

            //
            // Find out whether the source file should come from the
            // Emergency Repair Disk  or the Repair directory
            //

            if (RepairFromErDisk) {
                BOOLEAN rs;
                PWSTR   szDiskName;
                PWSTR   szDevicePath = SpDupStringW(L"\\device\\floppy0");

                //
                // Fetch the generic repair disk name.
                //

                SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),
                                SP_TEXT_REPAIR_DISK_NAME);
                szDiskName = SpDupStringW(TemporaryBuffer);

                //
                // Prompt for the disk, based on the setup media type.
                //

                rs = SpPromptForDisk(
                          szDiskName,
                          szDevicePath,
                          SETUP_LOG_FILENAME,
                          FALSE,              // if disk is in already dont prompt
                          FALSE,              // allow escape
                          TRUE,               // warn for multiple prompts
                          NULL                // don't care about redraw flag
                          );

                SpMemFree(szDiskName);
                SpMemFree(szDevicePath);

                RedrawGauge = TRUE;
                if (rs == FALSE) {
                    continue;
                }
                DevicePath = L"\\device\\floppy0";
                wcscpy( TemporaryBuffer, L"\\" );
                Directory = SpDupStringW(TemporaryBuffer);                 // OemSourceDirectory;
            } else {

                RedrawGauge = TRUE;
                DevicePath = TargetDevicePath;
                wcscpy( TemporaryBuffer, DirectoryOnTargetDevice );
                SpConcatenatePaths( TemporaryBuffer, SETUP_REPAIR_DIRECTORY );
                Directory = SpDupStringW(TemporaryBuffer);
            }

            //
            // Copy the file.
            //

            SpCopyFileWithRetry(
                &FileToCopy,
                DevicePath,
                Directory,
                NULL,
                NULL,                          // TargetRoot -> NULL
                0,                      // SystemPartitionFiles ? ATTR_RHS : 0,
                SppRepairScreenRepaint,
                NULL,                          // Do not want checksum
                NULL,                          // Do not want to know if file was skipped
                0
                );

            SpMemFree( Directory );
        }
    }

    SpMemFree(FullTargetName);
    if (RedrawGauge) {
        SppRepairScreenRepaint(NULL, NULL, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spntfix.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spntfix.h

Abstract:

    initializing and maintaining list of nts to repair

Author:

    Shie-Lin Tzong (shielint) 6-Feb-1994

Revision History:

--*/

#ifndef _SPNTFIX_H_
#define _SPNTFIX_H_

//
// Repair items -
//   defines the items which setup can repair
//   Note, the ordering must be the same as SP_REPAIR_MENU_ITEM_x defined in msg.mc.

typedef enum {
//    RepairHives,   // BCL - Seagate: hives will not be in the menu.
    RepairNvram,
    RepairFiles,
#ifdef _X86_
    RepairBootSect,
#endif
    RepairItemMax
} RepairItem;

//
// The hives that repair cares about.  We pass around the keys to the hives
// in an array.  Use the following enum values to access
// the hive members
// Note, the ordering of the hives must be the same as SP_REPAIE_HIVE_ITEM_x
// defined in msg.mc.
//

typedef enum {
    RepairHiveSystem,
    RepairHiveSoftware,
    RepairHiveDefault,
    RepairHiveUser,
    RepairHiveSecurity,
    RepairHiveSam,
    RepairHiveMax
} RepairHive;

//
// Public functions
//

BOOLEAN
SpDisplayRepairMenu(
    VOID
    );

BOOLEAN
SpFindNtToRepair(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory,
    OUT PBOOLEAN     RepairableBootSetsFound
    );

VOID
SpRepairWinnt(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpRepairDiskette(
    OUT PVOID        *SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    );

BOOLEAN
SpLoadRepairLogFile(
    IN  PWCHAR  Filename,
    OUT PVOID  *Handle
    );

BOOLEAN
SpErDiskScreen (
    BOOLEAN *HasErDisk
    );

//
// Private functions
//

BOOLEAN
SppSelectNTSingleRepair(
    IN PDISK_REGION Region,
    IN PWSTR        OsLoadFileName,
    IN PWSTR        LoadIdentifier
    );

BOOLEAN
SppSelectNTMultiRepair(
    OUT PSP_BOOT_ENTRY *BootSetChosen
    );

BOOLEAN
SppRepairReportError(
    IN BOOLEAN AllowEsc,
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PBOOLEAN DoNotPromptAgain
    );

VOID
SppVerifyAndRepairFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SectionName,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN BOOLEAN SystemPartitionFiles,
    IN OUT PBOOLEAN RepairWithoutConfirming
    );

VOID
SppVerifyAndRepairNtTreeAccess(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory
    );

VOID
SppVerifyAndRepairVdmFiles(
    IN PVOID LogFileHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN OUT PBOOLEAN RepairWithoutConfirming
    );

VOID
SppGetRepairPathInformation(
    IN  PVOID LogFileHandle,
    OUT PWSTR *SystemPartition,
    OUT PWSTR *SystemPartitionDirectory,
    OUT PWSTR *WinntPartition,
    OUT PWSTR *WinntPartitionDirectory
    );
   

//
// External functions
//

extern
VOID
SpCopyFilesScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    );

//
// External data references
//

extern PVOID RepairGauge;
extern ULONG RepairItems[RepairItemMax];
extern BOOLEAN RepairFromErDisk;
extern PVOID Gbl_HandleToSetupLog;
extern PWSTR Gbl_SystemPartitionName;
extern PWSTR Gbl_SystemPartitionDirectory;
extern PWSTR Gbl_BootPartitionName;
extern PWSTR Gbl_BootPartitionDirectory;

#endif // for _SPNTFIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spntupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spntupg.c

Abstract:

    initializing and maintaining list of nts to upgrade

Author:

    Sunil Pai (sunilp) 10-Nov-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


//
// Major/minor version numbers of the system we're upgrading *from*
// if upgrading.
//
ULONG OldMajorVersion,OldMinorVersion;

//**************************************************************
// S E L E C T I N G    N T   T O   U P G R A D E     S T U F F
//**************************************************************

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

    VOID
pSpStepUpValidate(
    VOID //IN BOOLEAN Server
    );

BOOLEAN
SpGetStepUpMode(
    IN PWSTR PidExtraData,
    BOOLEAN  *StepUpMode
    );
 
BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    );
VOID
SpGetUpgDriveLetter(
    IN WCHAR  DriveLetter,
    IN PWCHAR Buffer,
    IN ULONG  BufferSize,
    IN BOOL   AddColon
    );

VOID
SpCantFindBuildToUpgrade(
    VOID
    );

#ifdef _X86_
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );
#endif

VOID
SpGetFileVersion(
    IN  PVOID      ImageBase,
    OUT PULONGLONG Version
    );

ENUMUPGRADETYPE
SpFindNtToUpgrade(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    upgradeable. Presents the information to the user and selects if he
    wishes to upgrade an installed NT / install a fresh NT into the same
    directory / select a different location for Windows NT.

    If the chosen target is too full user is offered to exit setup to create
    space/ choose new target.

Arguments:

    SifHandle:    Handle the txtsetup.sif

    TargetRegion: Variable to receive the partition of the Windows NT to install
                  NULL if not chosen.  Caller should not free.

    TargetPath:   Variable to receive the target path of Windows NT.  NULL if
                  not decided.  Caller can free.

    SystemPartitionRegion:
                  Variable to receive the system partition of the Windows NT
                  NULL if not chosen.  Caller should not free.


Return Value:

    UpgradeFull:         If user chooses to upgrade an NT

    UpgradeInstallFresh: If user chooses to install fresh into an existing NT
                         tree.

    DontUpgrade:         If user chooses to cancel upgrade and choose a fresh
                         tree for installation


--*/
{
    ENUMUPGRADETYPE UpgradeType;
    UPG_PROGRESS_TYPE UpgradeProgressValue;
    NTSTATUS NtStatus;
    ULONG i,j;
    ULONG UpgradeBootSets;
    ULONG PidIndex;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY ChosenBootEntry;
    PSP_BOOT_ENTRY MatchedSet = NULL;
    ULONG UpgradeOnlyBootSets;
    PVOID p;
    PWSTR Pid;
    ULONG TotalSizeOfFilesOnOsWinnt = 0;
    PWSTR UniqueIdFromSif;
    PWSTR UniqueIdFromReg;
    BOOLEAN Compliant;
    BOOLEAN WindowsUpgrade;
    BOOLEAN ComplianceChecked;
    PWSTR EulaComplete;
    DWORD Version = 0, BuildNumber = 0;

    DetermineSourceVersionInfo(&Version, &BuildNumber);

    //
    // If we know we're upgrading NT (chosen during winnt32) then fetch the
    // unique id from the parameters file. This will be used later to
    // find the system to be upgraded.
    //
    UniqueIdFromSif = NULL;
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
    if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
        UniqueIdFromSif = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,SIF_UNIQUEID,0);
        if(!UniqueIdFromSif) {
            SpFatalSifError(WinntSifHandle,SIF_DATA,SIF_UNIQUEID,0,0);
        }
    }

    //
    // Go through all boot sets, looking for upgradeable ones.
    //
    SpDetermineUniqueAndPresentBootEntries();

    UpgradeBootSets = 0;
    UpgradeOnlyBootSets = 0;
    PidIndex = 0;
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        //
        // The set's upgradeable flag might already be 0, such as it if was
        // a duplicate entry in boot.ini/nv-ram.
        // After we've checked for this reset the upgradeable flag for this
        // boot set to FALSE in preparation for validating upgreadeability below.
        //
        if (!BootEntry->Processable) {
            continue;
        }

        BootEntry->Processable = FALSE;
        Pid = NULL;
        BootEntry->LangId = -1;

        //
        // Determine various things about the build identified by the
        // current boot set (product type -- srv, wks, etc; version and
        // build numbers, upgrade progress value, unique id winnt32 put
        // in there if any, etc).
        //
        // Based on the information, we will update the UpgradeableList and
        // initialize FailedUpgradeList.
        //
        NtStatus = SpDetermineProduct(
                     BootEntry->OsPartitionDiskRegion,
                     BootEntry->OsDirectory,
                     &BootEntry->ProductType,
                     &BootEntry->MajorVersion,
                     &BootEntry->MinorVersion,
                     &BootEntry->BuildNumber,
                     &BootEntry->ProductSuiteMask,
                     &UpgradeProgressValue,
                     &UniqueIdFromReg,
                     &Pid,
                     NULL,       // ignore eval variation flag
                     &BootEntry->LangId,
                     &BootEntry->ServicePack
                     );

        if(!NT_SUCCESS(NtStatus)) {
            continue;
        }

        //
        // Determine if this installation matches the one we're supposed
        // to upgrade (the one the user ran winnt32 on).  If this is
        // a winnt32 based installation, there is no need to do a
        // compliance test as this was already completed during winnt32.
        //
        if(UniqueIdFromReg) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade: BootEntry = %p, RegId = %S, UniqueId = %S\n", BootEntry, UniqueIdFromReg, UniqueIdFromSif));

            if(UniqueIdFromSif && (MatchedSet == NULL)
            && !wcscmp(UniqueIdFromSif,UniqueIdFromReg)) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade:   found a match!\n"));
                MatchedSet = BootEntry;
                BootEntry->Processable = TRUE;
            }

            SpMemFree(UniqueIdFromReg);
            UniqueIdFromReg = NULL;
        }

        if (BootEntry->Processable == FALSE) {
            //
            // this is set to TRUE if this is the build we ran winnt32 upgrade
            // from -- in all other cases we need to do a compliance test
            // to determine if this is a valid build to upgrade
            //
            Compliant = pSpIsCompliant( Version,
                                        BuildNumber,
                                        BootEntry->OsPartitionDiskRegion,
                                        BootEntry->OsDirectory,
                                        &BootEntry->UpgradeOnlyCompliance );
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade says UpgradeableList[%p] compliance test is %s, upgrade only : %s\n",
                     BootEntry,
                     Compliant ? "TRUE" : "FALSE" ,
                     BootEntry->UpgradeOnlyCompliance ? "TRUE" : "FALSE"
                   ));

            BootEntry->Processable = Compliant;
            if (BootEntry->UpgradeOnlyCompliance) {

                UpgradeOnlyBootSets++;

            }
        }

        if(BootEntry->Processable) {

            UpgradeBootSets++;

            //
            // Save the Pid only if it is Pid20
            //
            if(wcslen(Pid) == 20) {
                BootEntry->Pid20Array = Pid;
            } else {
                SpMemFree(Pid);
            }
        } else {
            SpMemFree(Pid);
        }

        BootEntry->FailedUpgrade = (UpgradeProgressValue == UpgradeInProgress);


    }

    //
    // Winnt32 displays the EULA which signifies that compliance checking has been
    // completed
    //
    EulaComplete = SpGetSectionKeyIndex(WinntSifHandle, SIF_DATA,WINNT_D_EULADONE_W, 0);

    if(EulaComplete && SpStringToLong(EulaComplete, NULL, 10)) {
        ComplianceChecked = TRUE;
    } else {
        ComplianceChecked = FALSE;
    }

    //
    // don't try to validate if we are upgrading a Win3.X or Win9X installation
    //
#ifdef _X86_
    WindowsUpgrade = SpIsWindowsUpgrade(WinntSifHandle);
#else
    WindowsUpgrade = FALSE;
#endif // _X86_

    //
    // In step-up mode, we need to ensure that the user has a qualifiying product.
    //
    //
    // If we couldn't find it on the machine, go perform additional validation
    // steps.
    //
    if(StepUpMode && !UpgradeBootSets && !WindowsUpgrade && !ComplianceChecked) {
        pSpStepUpValidate();
    }

    //
    // If we are supposed to be upgrading NT then make sure we found
    // the system we're supposed to upgrade.
    //
    if(UniqueIdFromSif) {
        if(MatchedSet == NULL) {
            SpCantFindBuildToUpgrade();
        }

        ChosenBootEntry = MatchedSet;
        UpgradeType = UpgradeFull;

        OldMajorVersion = ChosenBootEntry->MajorVersion;
        OldMinorVersion = ChosenBootEntry->MinorVersion;

#ifndef _X86_
        //
        // On non-x86 platforms, especially alpha machines that in general
        // have small system partitions (~3 MB), we compute the size
        // of the files on \os\winnt (ie osloader.exe and hal.dll),
        // and consider this size as available disk space. We can do this
        // since these files will be overwritten by the new ones.
        // This fixes the problem that we see on Alpha, when the system
        // partition is too full.
        //
        SpFindSizeOfFilesInOsWinnt(
            SifHandle,
            ChosenBootEntry->LoaderPartitionDiskRegion,
            &TotalSizeOfFilesOnOsWinnt
            );

        //
        // Transform the size into KB
        //
        TotalSizeOfFilesOnOsWinnt /= 1024;
#endif

        //
        // If a previous upgrade attempt on this build failed
        // (say the power went out in the middle) then we will try to
        // upgrade it again. We can't offer to install a fresh build
        // because we're not sure we can reliably complete it
        // (for example winnt32.exe might copy down only a subset of files
        // across the net when it knows the user ios upgrading and so
        // initial install could fail because of missing files, etc).
        //
        // If the disk is too full then the user is hosed. Tell him and exit.
        //
        if(ChosenBootEntry->FailedUpgrade) {

            SppResumingFailedUpgrade(
                ChosenBootEntry->OsPartitionDiskRegion,
                ChosenBootEntry->OsDirectory,
                ChosenBootEntry->FriendlyName,
                FALSE
                );
        }
    } else {
        //
        // Not upgrading. However for PSS we allow the user to upgrade a build
        // "in place" as a sort of emergency repair thing. The build has to be
        // the same build number as the one we're installing.
        //
        UpgradeType = DontUpgrade;
        //
        // Also, if the user is upgrading Windows 95 or we're in unattended mode
        // then we don't ask the user anything.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
        if(!UnattendedOperation && (!p || _wcsicmp(p,WINNT_A_YES_W))) {

            //
            // Eliminate from the upgradeable list those builds which
            // don't match.
            //
            j = 0;
            for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                if(BootEntry->Processable) {

                    if (!SpDoBuildsMatch(
                                    SifHandle,
                                    BootEntry->BuildNumber,
                                    BootEntry->ProductType,
                                    BootEntry->ProductSuiteMask,
                                    AdvancedServer,
                                    SuiteType,
                                    BootEntry->LangId)) {
                        BootEntry->Processable = FALSE;
                        j++;
                    }
                }
            }
            UpgradeBootSets -= j;

            if(UpgradeBootSets) {
                //
                // Find out if the user wants to "upgrade" one of these.
                //
                UpgradeType = SppSelectNTToRepairByUpgrade(
                                  &ChosenBootEntry
                                  );

#ifndef _X86_
                SpFindSizeOfFilesInOsWinnt(
                    SifHandle,
                    ChosenBootEntry->LoaderPartitionDiskRegion,
                    &TotalSizeOfFilesOnOsWinnt
                    );

                TotalSizeOfFilesOnOsWinnt /= 1024;
#endif

                if(UpgradeType == UpgradeFull) {
                    //
                    // Check for resume case and inform user.
                    //
                    if(ChosenBootEntry->FailedUpgrade) {
                        //
                        // If user cancelled then lets try to do a
                        // clean install
                        //
                        if (!SppResumingFailedUpgrade(
                                    ChosenBootEntry->OsPartitionDiskRegion,
                                    ChosenBootEntry->OsDirectory,
                                    ChosenBootEntry->FriendlyName,
                                    TRUE
                                    )) {
                            UpgradeType = DontUpgrade;
                        }                            
                    } else {
                        //
                        // Everything is OK.
                        //
                        OldMajorVersion = ChosenBootEntry->MajorVersion;
                        OldMinorVersion = ChosenBootEntry->MinorVersion;
                    }
                }
            }
        }
    }

    //
    // Depending on upgrade selection made do the setup needed before
    // we do the upgrade
    //
    if(UpgradeType == UpgradeFull) {

        PWSTR p1,p2,p3;

        //
        // Set the upgrade status to upgrading in the current system hive
        //
        SpSetUpgradeStatus(
             ChosenBootEntry->OsPartitionDiskRegion,
             ChosenBootEntry->OsDirectory,
             UpgradeInProgress
             );

        //
        // Return the region we are installing onto
        //
        *TargetRegion          = ChosenBootEntry->OsPartitionDiskRegion;
        *TargetPath            = SpDupStringW(ChosenBootEntry->OsDirectory);
        *SystemPartitionRegion = ChosenBootEntry->LoaderPartitionDiskRegion;
        StandardServerUpgrade = ( AdvancedServer &&
                                  ( ChosenBootEntry->ProductType == NtProductWinNt ) ||
                                  ( ChosenBootEntry->ProductType == NtProductServer )
                                );

        //
        // Process the osloader variable to extract the system partition path.
        // The var could be of the form ...partition(1)\os\nt\... or
        // ...partition(1)os\nt\...
        // So we search forward for the first \ and then backwards for
        // the closest ) to find the start of the directory.  We then
        // search backwards in the resulting string for the last \ to find
        // the end of the directory.
        //
        p1 = ChosenBootEntry->LoaderFile;
        p2 = wcsrchr(p1, L'\\');
        if (p2 == NULL) {
            p2 = p1;
        }
        i = (ULONG)(p2 - p1);

        if(i == 0) {
            *SystemPartitionDirectory = SpDupStringW(L"");
        } else {
            p2 = p3 = SpMemAlloc((i+2)*sizeof(WCHAR));
            ASSERT(p3);
            if(*p1 != L'\\') {
                *p3++ = L'\\';
            }
            wcsncpy(p3, p1, i);
            p3[i] = 0;
            *SystemPartitionDirectory = p2;
        }
    }

    //
    // Clean up and return,
    //

    CLEAR_CLIENT_SCREEN();
    return(UpgradeType);
}

BOOLEAN
pSpGetCdInstallType(
    IN  PWSTR PathToCd,
    OUT PULONG CdInstallType,
    OUT PULONG CdInstallVersion
    )
{
    #define BuildMatch(_filename_,_type_,_ver_) \
        FileName = _filename_; \
        b = SpNFilesExist(PathToCd,&FileName,1,FALSE); \
        if (b) { \
            *CdInstallType    = _type_; \
            *CdInstallVersion = _ver_; \
        } \
            //return(TRUE); \


    BOOLEAN     b;
    //
    // Directories that are present on all known NT CD-ROM's.
    //

    //
    // ISSUE:2000/27/07:vijayj: this code seems really busted.  In looking at a handful of cd's, none
    // of the nt cd's seem to conform to these rules listed
    // also looks like there might be "per architecture" tag files as well.
    //

    //Check for both dirs to exist? Definitely nt4 has these. Some pre RTM w2k cds have them
    PWSTR ListAllPreNT5[] = { L"alpha", L"i386" }; 

    //wk2 RTM , whistler and nt4 have thse two dirs. They differ by tag file.
    PWSTR ListAllNT5[] = { L"i386", L"support" };

    PWSTR ListAllNec98[] = { L"pc98",L"support" }; //NEC98
    PWSTR ListAllEntNT4[] = { L"alpha", L"i386", L"SP3" };


    //
    // Directories which must be present if a CD is a 3.51 or a 4.0 CD-ROM,
    // workstation or server. Note that the ppc directory distinguishes
    // 3.51 from 3.5.
    //
    PWSTR List351_40[] = { L"mips", L"ppc" };

    //
    // directories which must be present if a CD is a win95 or win98 cd-rom.
    //
    PWSTR ListWin95[] = { L"win95", L"drivers" }; 
    PWSTR ListWin98[] = { L"win98", L"drivers" };
    PWSTR ListWinME[] = { L"win9x", L"drivers" };

    PWSTR FileName;


    //
    // check for NT4 enterprise
    //
    b = SpNFilesExist(
            PathToCd,
            ListAllEntNT4,
            sizeof(ListAllEntNT4)/sizeof(ListAllEntNT4[0]),
            TRUE
            );

    if (b) {
        BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTSE, 400);
        if (b) {
            return(TRUE);
        }
    }

    //
    // check for various subsets of NT < NT5
    //
    b = SpNFilesExist(
            PathToCd,
            (!IsNEC_98) ? ListAllPreNT5 : ListAllNec98, //NEC98
            (!IsNEC_98) ? sizeof(ListAllPreNT5)/sizeof(ListAllPreNT5[0]) : sizeof(ListAllNec98)/sizeof(ListAllNec98[0]), //NEC98
            TRUE
            );

    if(b) {
        //
        // hydra (terminal server) is a special case (since it does not
        // have mips and ppc directory).
        //
        BuildMatch(L"cdrom_ts.40", COMPLIANCE_INSTALLTYPE_NTS, 400);

        if (b) {
            return TRUE;
        }

        //
        // OK, it could be an NT CD of some kind, but it could be
        // 3.1, 3.5, 3.51, 4.0. It could also be
        // server or workstation. Narrow down to 3.51/4.0.
        //
        b = SpNFilesExist(PathToCd,List351_40,
                sizeof(List351_40)/sizeof(List351_40[0]),TRUE);

        if(b) {
            //
            // If we get here, we know it can only be either 3.51 or 4.0.
            // Look for 3.51.
            //
            BuildMatch(L"cdrom.s", COMPLIANCE_INSTALLTYPE_NTS, 351);
            if (b) {
                return(TRUE);
            }
            BuildMatch(L"cdrom.w", COMPLIANCE_INSTALLTYPE_NTW, 351);
            if (b) {
                return(TRUE);
            }
            //
            // Look for 4.0.
            //
            BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTS, 400);
            if (b) {
                return(TRUE);
            }
            BuildMatch(L"cdrom_w.40", COMPLIANCE_INSTALLTYPE_NTW, 400);
            if (b) {
                return(TRUE);
            }

        } else {
            // 
            // Find out if its one of the NT 4.0 service pack CDs
            //
            BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTS, 400);
            if (b) {
                return(TRUE);
            }
            
            BuildMatch(L"cdrom_w.40", COMPLIANCE_INSTALLTYPE_NTW, 400);
            if (b) {
                return(TRUE);
            }
            //
            // Not 3.51 or 4.0. Check for 5.0 beta 1 and beta2
            //
            //How is this possible to be 5.0 unless alpha dir exists on cd.
            //
            // Post beta 1 the tag files changed to support per architecture tags
            // but beta 2 still has alpha directories
            //
            // We could possibly just check to see if cdrom_w.50 isn't
            // there, but the NT3.1 CD would then pass so we need to
            // check explicitly for the 5.0 beta CDs.
            //
            BuildMatch(L"cdrom_s.5b1", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b1", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_s.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_s.5b3", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b3", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }

            BuildMatch(L"cdrom_is.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_iw.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_ie.5b2", COMPLIANCE_INSTALLTYPE_NTSE, 500);
            if (b) {
                return(FALSE); //eval
            }
            //Do we need to check for eval nt5.1 here? No since alpha dir doesnt exist on the cds.
            //
            // if we made it this far, it must be nt 3.1/3.5
            //
            // we just mark the version as 3.5 since we don't allow upgradescd o
            // from either type of install.
            //
            *CdInstallType = COMPLIANCE_INSTALLTYPE_NTW;
            *CdInstallVersion = 350;
            return(TRUE);
        }
    }

    //
    // look for various nt5 beta cds.
    // // Could also be nt5.1 since cd also contains same dir.
    //
    // note that we don't check 5.0 retail since that would allow the retail CD to
    // validate itself, which defeats the purpose entirely.
    //
    // Post NT5 beta 1 the tag files changed to support per architecture tags so we have
    // a massive ifdef below
    //
    //
    b = SpNFilesExist(
            PathToCd,
            ListAllNT5,
            sizeof(ListAllNT5)/sizeof(ListAllNT5[0]),
            TRUE
            );

    if (b) {
        //
        // we might have some flavour of NT5 beta cd, but we're not sure which one
        //
        BuildMatch(L"cdrom_s.5b1", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_w.5b1", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_is.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_iw.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_ie.5b2", COMPLIANCE_INSTALLTYPE_NTSE, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_is.5b3", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_iw.5b3", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_ie.5b3", COMPLIANCE_INSTALLTYPE_NTSE, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_nt.51", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //pre beta1 whistler
        }
        BuildMatch(L"wen51.b1", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //beta 1 whistler
        }
        BuildMatch(L"win51.b2", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //beta 1 whistler
        }
        BuildMatch(L"win51.rc1", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //rc1 whistler
        }
    }

    //
    // check for win95
    //
    b = SpNFilesExist(PathToCd, ListWin95, sizeof(ListWin95)/sizeof(ListWin95[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 950;

      return TRUE;
    }      

    //
    // check for win98
    //
    b = SpNFilesExist(PathToCd, ListWin98, sizeof(ListWin98)/sizeof(ListWin98[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 1998;

      return TRUE;
    }
    
    //
    // check for winME
    //
    b = SpNFilesExist(PathToCd, ListWinME, sizeof(ListWinME)/sizeof(ListWinME[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 3000;

      return TRUE;
    }
    //At this point we have rejected w2k beta cds. However we need to reject wk2 eval cds.
    //We should accept w2k stepup media so the next check is only for 5.1
    //Need to accept nt5.1 eval cds.!!Ask rajj to verify.
    // Need to reject nt5.1 step-up cds.
    // Need to reject nt5.1 rtm cds? Looks like we accept RTM FPP?
    //
    // could be NT 5.1 CD-ROM (make sure its not eval media)
    //
    if (!b) { //check is not needed.
        NTSTATUS    Status;
        CCMEDIA        MediaObj;
        WCHAR        InfDir[MAX_PATH];

        wcscpy(InfDir, PathToCd);
        SpConcatenatePaths(InfDir, (IsNEC_98 ? ListAllNec98[0] : ListAllNT5[0]));

        Status = SpGetMediaDetails(InfDir, &MediaObj);

        if (NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Type=%lx, Variation=%lx, Version=%lx, Build=%lx, SetupMedia=%s\n",
                MediaObj.SourceType, MediaObj.SourceVariation, MediaObj.Version,
                MediaObj.BuildNumber,
                (MediaObj.StepUpMedia ? L"True" : L"False")));

            if( (MediaObj.Version == 500) && 
                (MediaObj.SourceVariation != COMPLIANCE_INSTALLVAR_EVAL) &&
                (MediaObj.BuildNumber == 2195)) {
                    *CdInstallType = MediaObj.SourceType;
                    *CdInstallVersion = MediaObj.Version;
                    return TRUE;
            }
            // At this point we should be current media 5.1
            if( MediaObj.Version == 501 ) {
                if( MediaObj.SourceVariation != COMPLIANCE_INSTALLVAR_EVAL) {
                    if( MediaObj.StepUpMedia == FALSE) {
                        *CdInstallType = MediaObj.SourceType;
                        *CdInstallVersion = MediaObj.Version;
                        return TRUE;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but STEPUP media"
                                " cannot be used for validation\n", Status));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but Eval media\n",
                                Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but unrecognized version\n",
                            Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails failed with %lx error code\n",
                        Status));
        }
    }


    //
    // not any system CD that we know about
    //
    return(FALSE);
}


VOID
pSpStepUpValidate(
    VOID
    )
{
    ULONG CdCount;
    ULONG i;
    BOOLEAN b;
    ULONG Prompt,SecondaryPrompt;
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    LARGE_INTEGER DelayTime;
    PWSTR FileName;
    ULONG SourceSkuId;
    ULONG DontCare;
    ULONG CdInstallType;
    ULONG CdInstallVersion;

    //
    // Directories that are present on all known NT CD-ROM's.
    //
    PWSTR ListAll[] = { L"alpha", L"i386" };
    PWSTR ListAllNec98[] = { L"pc98",L"support" }; //NEC98

    //
    // Directories which must be present if a CD is a 3.51 or a 4.0 CD-ROM,
    // workstation or server. Note that the ppc directory distinguishes
    // 3.51 from 3.5.
    //
    PWSTR List351_40[] = { L"mips", L"ppc" };

    PWSTR ListWin95[] = { L"win95", L"autorun" };
    PWSTR ListWin98[] = { L"win98", L"autorun" };

    SourceSkuId = DetermineSourceProduct(&DontCare,NULL);

    Prompt = SP_SCRN_STEP_UP_NO_QUALIFY;

    switch (SourceSkuId) {
        case COMPLIANCE_SKU_NTW32U:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_WKS;
            break;
        case COMPLIANCE_SKU_NTSU:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_SRV;
            break;
        case COMPLIANCE_SKU_NTSEU:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_ENT;
            break;
        default:
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "setup: Unexpected SKU %x, defaulting to workstation\n", SourceSkuId));
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_WKS;
            break;
    }

#if 0
    //
    // ntw upgrade is a special case because you have either win95 or an old NTW to
    // upgrade from
    //
    // might have to prompt for floppies
    //
    if (SourceSkuId == COMPLIANCE_SKU_NTWU) {



    }
        //
        // See if there is a CD-ROM drive. If not we can't continue.
        //
    else
#endif
        if(CdCount = IoGetConfigurationInformation()->CdRomCount) {

        do {
            //
            // Tell the user what's going on. This screen also contains
            // a prompt to insert a qualifying CD-ROM.
            //
            while(1) {

                SpStartScreen(Prompt,3,HEADER_HEIGHT+1,FALSE,FALSE,DEFAULT_ATTRIBUTE);


                SpContinueScreen(
                    SecondaryPrompt,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpContinueScreen(SP_SCRN_STEP_UP_INSTRUCTIONS,3,1,FALSE,DEFAULT_ATTRIBUTE);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
                    SpConfirmExit();
                } else {
                    break;
                }
            }

            CLEAR_CLIENT_SCREEN();
            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

            //
            // Wait 5 sec for the CD to become ready
            //
            DelayTime.HighPart = -1;
            DelayTime.LowPart = (ULONG)(-50000000);
            KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);

            //
            // Check for relevent files/dirs on each CD-ROM drive.
            //
            for(i=0; i<CdCount; i++) {

                swprintf(TemporaryBuffer,L"\\Device\\Cdrom%u",i);

                if (pSpGetCdInstallType(TemporaryBuffer, &CdInstallType, &CdInstallVersion) ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "cd type : %x cd version : %d\n", CdInstallType, CdInstallVersion ));

                    switch (SourceSkuId) {
                        case COMPLIANCE_SKU_NTWPU:
                        case COMPLIANCE_SKU_NTW32U:
                            if ( (CdInstallType == COMPLIANCE_INSTALLTYPE_WIN9X) ||
                                 ( ((CdInstallType == COMPLIANCE_INSTALLTYPE_NTW) ||
                                     (CdInstallType == COMPLIANCE_INSTALLTYPE_NTWP)) &&
                                    (CdInstallVersion > 350)) ) {
                                  return;
                            }
                            break;
                        case COMPLIANCE_SKU_NTSU:
                            if ( (CdInstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                                 (CdInstallVersion > 350) ) {
                                 return;
                            }
                            break;
                        case COMPLIANCE_SKU_NTSEU:
                            if (CdInstallType == COMPLIANCE_INSTALLTYPE_NTSE) {
                                return;
                            }
                            break;

                        default:
                            return;
                    }

                }

            }

            //
            // If we get here then the CD the user inserted is bogus
            // or the user didn't insert a CD. Reprompt. The while loop
            // condition makes this essentially an infinite loop.
            //
        } while(Prompt = SP_SCRN_STEP_UP_BAD_CD);
    }

    SpStartScreen(
        SP_SCRN_STEP_UP_FATAL,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3);
    SpDone(0,FALSE,FALSE);
}


BOOLEAN
SppResumingFailedUpgrade(
    IN PDISK_REGION Region,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN BOOLEAN     AllowCancel
    )

/*++

Routine Description:

    Simple routine to inform the user that setup noticed that the build
    chosen for upgrade had been upgraded before, but the upgrade attempt
    failed. The user can continue or exit. If he continues the build will be
    upgraded (again).

Arguments:

    Region - supplies region containing the build being upgraded

    OsLoadFileName - supplies ARC OSLOADFILENAME var for the build (ie, sysroot)

    LoadIdentifier - supplies ARC LOADIDENTIFIER for the build (ie, human-
        readable description).

    AllowCancel - Indicates whether user can cancel out of this or not        

Return Value:

    TRUE, if the user wants to continue and attempt to upgrade again else
    FALSE.

--*/

{
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, 0, 0 };
    ULONG c;
    DRIVELTR_STRING UpgDriveLetter;
    ULONG MsgId;
    ULONG EscStatusId;
    BOOLEAN AllowUpgrade = TRUE;

    ASSERT(Region->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    SpGetUpgDriveLetter(Region->DriveLetter,
            UpgDriveLetter,
            sizeof(UpgDriveLetter),
            FALSE);

    if (AllowCancel) {
        ValidKeys[2] = ASCI_ESC;            
        MsgId = SP_SCRN_WINNT_FAILED_UPGRADE_ESC;
        EscStatusId = SP_STAT_ESC_EQUALS_CLEAN_INSTALL;
    } else {    
        MsgId = SP_SCRN_WINNT_FAILED_UPGRADE;
        EscStatusId = 0;
    }
    
    do {
        SpStartScreen(
            MsgId,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            UpgDriveLetter,
            OsLoadFileName,
            LoadIdentifier
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_UPGRADE,
            EscStatusId,
            0
            );

        c = SpWaitValidKey(ValidKeys, NULL, NULL);
        
        switch (c) {
            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_ESC:
                AllowUpgrade = FALSE;
                break;

            default:
                break;
        }
    } while (c == KEY_F3);

    return AllowUpgrade;
}

#define MAX_INT_STRING   30

VOID
SppUpgradeDiskFull(
    IN PDISK_REGION OsRegion,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN PDISK_REGION SysPartRegion,
    IN ULONG        MinOsFree,
    IN ULONG        MinSysFree,
    IN BOOLEAN      Fatal
    )

/*++

Routine Description:

    Inform the user that the nt tree chosen for upgrade can't be upgraded
    because the partition is too full.

Arguments:

    OsRegion - supplies region containing the nt tree.

    OsLoadFileName - supplies ARC OSLOADFILENAME var for the build (ie, sysroot)

    LoadIdentifier - supplies ARC LOADIDENTIFIER for the build (ie, human-
        readable description).

    SysPartRegion - supplies the region that is the ARC system partition
        for the build being upgraded

    MinOsFree - supplies the size in KB of the minimum amount of free space
        we require before attempting upgrade

    MinSysFree - supplies the size in KB of the minimum amount of free space
        we require on the system partition before attempting upgrade.

    Fatal - if TRUE then the only option is exit. If FALSE then this routine
        can return to its caller.

Return Value:

    None. MAY NOT RETURN, depending on Fatal.

--*/

{
    ULONG ValidKeys[] = { KEY_F3,0,0 };
    PWCHAR Drive1, Drive2;
    DRIVELTR_STRING OsRgnDrive, OsRgnDriveFull, SysRgnDriveFull;
    WCHAR Drive1Free[MAX_INT_STRING], Drive1FreeNeeded[MAX_INT_STRING];
    WCHAR Drive2Free[MAX_INT_STRING], Drive2FreeNeeded[MAX_INT_STRING];
    BOOLEAN FirstDefined = FALSE, SecondDefined = FALSE;

    ASSERT(OsRegion->PartitionedSpace);
    ASSERT(SysPartRegion->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    SpGetUpgDriveLetter(OsRegion->DriveLetter,OsRgnDrive,sizeof(OsRgnDrive),FALSE);
    if((OsRegion == SysPartRegion) || (OsRegion->FreeSpaceKB < MinOsFree)) {
        //
        // Then we'll be needing the full (colon added) version of
        // the drive letter
        //
        SpGetUpgDriveLetter(OsRegion->DriveLetter,OsRgnDriveFull,sizeof(OsRgnDrive),TRUE);
    }

    if(OsRegion == SysPartRegion) {
        Drive1 = OsRgnDriveFull;
        swprintf(Drive1Free,L"%d",OsRegion->FreeSpaceKB);
        swprintf(Drive1FreeNeeded,L"%d",MinOsFree);
        FirstDefined = TRUE;
    } else {
        if(SysPartRegion->FreeSpaceKB < MinSysFree) {
            SpGetUpgDriveLetter(SysPartRegion->DriveLetter,SysRgnDriveFull,sizeof(SysRgnDriveFull),TRUE);
            Drive1 = SysRgnDriveFull;
            swprintf(Drive1Free,L"%d",SysPartRegion->FreeSpaceKB);
            swprintf(Drive1FreeNeeded,L"%d",MinSysFree);
            FirstDefined = TRUE;
        }
        if(OsRegion->FreeSpaceKB < MinOsFree) {

            if(!FirstDefined) {
                Drive1 = OsRgnDriveFull;
                swprintf(Drive1Free,L"%d",OsRegion->FreeSpaceKB);
                swprintf(Drive1FreeNeeded,L"%d",MinOsFree);
                FirstDefined = TRUE;
            } else {
                Drive2 = OsRgnDriveFull;
                swprintf(Drive2Free,L"%d",OsRegion->FreeSpaceKB);
                swprintf(Drive2FreeNeeded,L"%d",MinOsFree);
                SecondDefined = TRUE;
            }
        }
    }

    if(!Fatal) {
        ValidKeys[1] = ASCI_CR;
    }

    while(1) {
        SpStartScreen(
            Fatal ? SP_SCRN_WINNT_DRIVE_FULL_FATAL : SP_SCRN_WINNT_DRIVE_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            OsRgnDrive,
            OsLoadFileName,
            LoadIdentifier,
            FirstDefined  ? Drive1           : L"",
            FirstDefined  ? Drive1FreeNeeded : L"",
            FirstDefined  ? Drive1Free       : L"",
            SecondDefined ? Drive2           : L"",
            SecondDefined ? Drive2FreeNeeded : L"",
            SecondDefined ? Drive2Free       : L""
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            Fatal ? 0 : SP_STAT_ENTER_EQUALS_CONTINUE,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
            if(Fatal) {
                SpDone(0,FALSE,TRUE);
            } else {
                SpConfirmExit();
            }
        } else {
            //
            // User hit CR in non-fatal case
            //
            return;
        }
    }
}


ENUMUPGRADETYPE
SppSelectNTToRepairByUpgrade(
    OUT PSP_BOOT_ENTRY *BootEntryChosen
    )
{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3,ASCI_ESC,0 };
    ULONG Mnemonics[] = {MnemonicRepair,0 };
    ULONG Keypress;
    PSP_BOOT_ENTRY BootEntry,FirstUpgradeSet;
    BOOL bDone;
    ENUMUPGRADETYPE ret;

    //
    // Build up array of drive letters for all menu options
    //
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable) {
            SpGetUpgDriveLetter(
                BootEntry->OsPartitionDiskRegion->DriveLetter,
                BootEntry->DriveLetterString,
                sizeof(DRIVELTR_STRING),
                FALSE
                );
        }
    }

    bDone = FALSE;
    while(!bDone) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //
        SpDisplayScreen(SP_SCRN_WINNT_REPAIR_BY_UPGRADE,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //
        MenuTopY = NextMessageTopLine+2;

        //
        // Create a menu.
        //
        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    MENU_WIDTH,
                    VideoVars.ScreenHeight-MenuTopY-2-STATUS_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of partitions and free spaces.
        //
        FirstUpgradeSet = NULL;
        for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
            if(BootEntry->Processable) {

                swprintf(
                    TemporaryBuffer,
                    L"%ws:%ws %ws",
                    BootEntry->DriveLetterString,
                    BootEntry->OsDirectory,
                    BootEntry->FriendlyName
                    );

                SpMnAddItem(
                    Menu,
                    TemporaryBuffer,
                    MENU_LEFT_X+MENU_INDENT,
                    MENU_WIDTH-(2*MENU_INDENT),
                    TRUE,
                    (ULONG_PTR)BootEntry
                    );
                if(FirstUpgradeSet == NULL) {
                   FirstUpgradeSet = BootEntry;
                }
            }
        }

        //
        // Initialize the status line.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_R_EQUALS_REPAIR,
            SP_STAT_ESC_EQUALS_NO_REPAIR,
            0
            );

        //
        // Display the menu
        //
        SpMnDisplay(
            Menu,
            (ULONG_PTR)FirstUpgradeSet,
            TRUE,
            ValidKeys,
            Mnemonics,
            NULL,
            &Keypress,
            (PULONG_PTR)BootEntryChosen
            );

        //
        // Now act on the user's selection.
        //
        switch(Keypress) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            ret = DontUpgrade;
            bDone = TRUE;
            break;

        default:
            //
            // Must be r=repair
            //
            ret = UpgradeFull;
            bDone = TRUE;
            break;
        }
        SpMnDestroy(Menu);
    }
    return(ret);
}


VOID
SpGetUpgDriveLetter(
    IN WCHAR  DriveLetter,
    IN PWCHAR Buffer,
    IN ULONG  BufferSize,
    IN BOOL   AddColon
    )
/*++

Routine Description:

    This returns a unicode string containing the drive letter specified by
    DriveLetter (if nonzero).  If DriveLetter is 0, then we assume that we
    are looking at a mirrored partition, and retrieve a localized string of
    the form '(Mirror)'.  If 'AddColon' is TRUE, then drive letters get a
    colon appended (eg, "C:").


Arguments:

    DriveLetter: Unicode drive letter, or 0 to denote a mirrored partition.

    Buffer:      Buffer to receive the unicode string

    BufferSize:  Size of the buffer.

    AddColon:    Boolean specifying whether colon should be added (has no
                 effect if DriveLetter is 0).


Returns:

    Buffer contains the formatted Unicode string.

--*/
{
    if(DriveLetter) {
        if(BufferSize >= 2) {
            *(Buffer++) = DriveLetter;
            if(AddColon && BufferSize >= 3) {
                *(Buffer++) = L':';
            }
        }
        *Buffer = 0;
    } else {
        SpFormatMessage(Buffer, BufferSize, SP_UPG_MIRROR_DRIVELETTER);
    }
}


BOOLEAN
SppWarnUpgradeWorkstationToServer(
    IN ULONG    MsgId
    )

/*++

Routine Description:

    Inform a user that that the installation that he/she selected to upgrade
    is an NT Workstation, and that after the upgrade it will become a
    Standard Server.
    The user has the option to upgrade this or specify that he wants to
    install Windows NT fresh.

Arguments:

    MsgId - Screen to be displayed to the user.

Return Value:

    BOOLEAN - Returns TRUE if the user wants to continue the upgrade, or
              FALSE if the user wants to select another system to upgrade or
              install fress.

--*/

{
    ULONG ValidKeys[] = { ASCI_CR, ASCI_ESC, 0 };
    ULONG c;

    while(1) {

        SpStartScreen(
            MsgId,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        switch(c=SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            return( FALSE );

        case ASCI_CR:
            return(TRUE);
        default:
            break;
        }
    }
}


VOID
SpCantFindBuildToUpgrade(
    VOID
    )

/*++

Routine Description:

    Inform the user that we were unable to locate the build from which
    he initiated unattended installation via winnt32.

    This is a fatal condition.

Arguments:

    None.

Return Value:

    Does not return.

--*/

{
    ULONG ValidKeys[2] = { KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();

    SpDisplayScreen(SP_SCRN_CANT_FIND_UPGRADE,3,HEADER_HEIGHT+1);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,FALSE);
}


void
SpUpgradeToNT50FileSystems(
    PVOID SifHandle,
    PDISK_REGION SystemPartitionRegion,
    PDISK_REGION NTPartitionRegion,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    )

/*++

Routine Description:

    Perform any necessary upgrades of the file systems
    for the NT40 to NT50 upgrade case.

Arguments:

    SystemPartitionRegion   - Pointer to the structure that describes the
                              system partition.

    NTPartitionRegion       - Pointer to the structure that describes the
                              NT partition.

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Local source directory.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PDISK_REGION Region;
    PUCHAR Win9xPath;
    ULONG i,j,k;
    PSP_BOOT_ENTRY BootEntry;
    PWSTR NtPath;
    BOOLEAN DoConvert = TRUE;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID ImageBase;
    HANDLE SectionHandle;
    ULONGLONG SourceVersion;
    HANDLE SourceHandle;
    UNICODE_STRING UnicodeString;
    BOOLEAN IssueWarning = FALSE;
    WCHAR SourceFile[MAX_PATH];
    PWSTR MediaShortName;
    PWSTR MediaDirectory;
    UCHAR SysId;


#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot installation, do not try to convert -- the
    // NT partition in this case is on the remote boot server.
    //

    if (RemoteBootSetup && !RemoteInstallSetup) {
        ConvertNtVolumeToNtfs = FALSE;
        return;
    }
#endif // defined(REMOTE_BOOT)

    SpDetermineUniqueAndPresentBootEntries();

    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        if (!BootEntry->Processable) {
            continue;
        }

        BootEntry->Processable = FALSE;

        wcscpy( TemporaryBuffer, BootEntry->OsPartitionNtName );
        SpConcatenatePaths( TemporaryBuffer, BootEntry->OsDirectory );
        SpConcatenatePaths( TemporaryBuffer, L"\\system32\\ntoskrnl.exe" );

        INIT_OBJA( &Obja, &UnicodeString, TemporaryBuffer );

        Status = ZwCreateFile(
            &SourceHandle,
            FILE_GENERIC_READ,
            &Obja,
            &IoStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
        if (NT_SUCCESS(Status)) {
            Status = SpMapEntireFile( SourceHandle, &SectionHandle, &ImageBase, FALSE );
            if (NT_SUCCESS(Status)) {
                SpGetFileVersion( ImageBase, &BootEntry->KernelVersion );
                BootEntry->Processable = TRUE;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP: SpUpgradeToNT50FileSystems: Kernel %p: NT%d.%d(Build %d) %d\n",
                    BootEntry,
                    (USHORT)(BootEntry->KernelVersion>>48),
                    (USHORT)(BootEntry->KernelVersion>>32),
                    (USHORT)(BootEntry->KernelVersion>>16),
                    (USHORT)(BootEntry->KernelVersion)));
                SpUnmapFile( SectionHandle, ImageBase );
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() could not map kernel image [%ws], %lx\n", TemporaryBuffer, Status ));
            }
            ZwClose(SourceHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() corrupt boot config [%ws], %lx\n", TemporaryBuffer, Status ));
        }
    }

    //
    // count the number of "real" entries
    //

    k = 0;
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable) {
            k += 1;
        }
    }

    //
    // check to see if a warning is necessary.
    //
    // If we're doing an upgrade, and there's only 1
    // boot set, then we don't need a warning.  However,
    // if we're doing a clean install and there's at least
    // 1 boot set, then warn (given the existing OS is
    // old enough).
    //

    if( ( ((NTUpgrade == UpgradeFull) && (k > 1)) ||
          ((NTUpgrade == DontUpgrade) && (k > 0)) ) &&
        ( !UnattendedOperation ) && (!SpDrEnabled())) {
        for(BootEntry = SpBootEntries; BootEntry != NULL && IssueWarning == FALSE; BootEntry = BootEntry->Next) {
            if (!BootEntry->Processable || (BootEntry->KernelVersion == 0)) {
                //
                // bogus boot entry
                //
            } else if ((BootEntry->KernelVersion >> 48) < 4) {
                IssueWarning = TRUE;
            } else if ((BootEntry->KernelVersion >> 48) == 4 && (BootEntry->KernelVersion & 0xffff) <= 4) {
                IssueWarning = TRUE;
            }
        }
    }

    // If there's any existing NT4.0 with servicepack less than 5 then warn.
    if( k > 0) {
        for(BootEntry = SpBootEntries; BootEntry != NULL && IssueWarning == FALSE; BootEntry = BootEntry->Next) {
            if (!BootEntry->Processable || (BootEntry->KernelVersion == 0)) {
                //
                // bogus boot entry
                //
            } else if (BootEntry->MajorVersion == 4 && BootEntry->MinorVersion == 0 && BootEntry->BuildNumber == 1381 && BootEntry->ServicePack < 500) {
                IssueWarning = TRUE;
            }
        }
    }

    if (IssueWarning) {

        ULONG WarnKeys[] = { KEY_F3, 0 };
        ULONG MnemonicKeys[] = { MnemonicContinueSetup, 0 };

        while (IssueWarning) {
            SpDisplayScreen(SP_SCRN_FSWARN,3,CLIENT_TOP+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpInputDrain();

            switch(SpWaitValidKey(WarnKeys,NULL,MnemonicKeys)) {
                case KEY_F3:
                    SpConfirmExit();
                    return;

                default:
                    IssueWarning = FALSE;
                    break;
            }
        }
    }

#if 0
    //
    // now lets upgrade any nt40+sp3 ntfs file systems
    //

    MediaShortName = SpLookUpValueForFile(
        SifHandle,
        L"ntfs40.sys",
        INDEX_WHICHMEDIA,
        TRUE
        );

    SpGetSourceMediaInfo( SifHandle, MediaShortName, NULL, NULL, &MediaDirectory );

    wcscpy( SourceFile, SetupSourceDevicePath );
    SpConcatenatePaths( SourceFile, DirectoryOnSetupSource );
    SpConcatenatePaths( SourceFile, MediaDirectory );
    SpConcatenatePaths( SourceFile, L"ntfs40.sys" );

    //
    // Initialize the diamond decompression engine.
    // This needs to be done, because SpCopyFileUsingNames() uses
    // the decompression engine.
    //
    SpdInitialize();

    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable &&
            ((BootEntry->KernelVersion >> 48) == 4) &&
            ((BootEntry->KernelVersion & 0xffff) == 4)) {

            wcscpy( TemporaryBuffer, BootEntry->OsPartitionNtName );
            SpConcatenatePaths( TemporaryBuffer, BootEntry->OsDirectory );
            SpConcatenatePaths( TemporaryBuffer, L"\\system32\\drivers\\ntfs.sys" );

            Status = SpCopyFileUsingNames(
                SourceFile,
                TemporaryBuffer,
                0,
                COPY_NOVERSIONCHECK
                );
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() could not copy nt40 ntfs.sys driver, %lx\n", Status ));
            }

            SpMemFree(NtPath);
        }
    }

    // Terminate diamond
    SpdTerminate();
#endif

    return;
}

BOOLEAN
SpDoBuildsMatch(
    IN PVOID SifHandle,
    ULONG TestBuildNum,
    NT_PRODUCT_TYPE TestBuildType,
    ULONG TestBuildSuiteMask,
    BOOLEAN CurrentProductIsServer,
    ULONG CurrentSuiteMask,
    IN LCID LangId
    )
/*++

Routine Description:

    Checks if the current build the user is installing matches the build we're
    checking against.

    We check:

    1. do the build numbers match?
    2. do the build types match? (nt server and nt professional don't match)
    3. do the product suites match? (nt advanced server vs. data center)

Arguments:

    SifHandle - Handle to txtsetup.sif to find the source language
    TestBuildNum - The build number of the build we're checking against
    TestBuildType - The type of build we're checking against
    TestBuildSuiteMask - Type of product suite as mask we're checking against
    CurrentProductIsServer - If TRUE, the current build is NT Server
    CurrentSuiteMask - Type of suite mask
    LangId - System Language Id of the installation to check. If -1, Lang Id
             check is ignored.

Return Value:

    BOOLEAN - Returns TRUE if the builds match.

--*/
{
    #define PRODUCTSUITES_TO_MATCH ((  VER_SUITE_SMALLBUSINESS               \
                                     | VER_SUITE_ENTERPRISE                  \
                                     | VER_SUITE_BACKOFFICE                  \
                                     | VER_SUITE_COMMUNICATIONS              \
                                     | VER_SUITE_SMALLBUSINESS_RESTRICTED    \
                                     | VER_SUITE_EMBEDDEDNT                  \
                                     | VER_SUITE_DATACENTER                  \
                                     | VER_SUITE_PERSONAL))


    BOOLEAN retval;
    LANGID DefLangId = -1;
    DWORD Version = 0, BuildNumber = 0;

    if (!DetermineSourceVersionInfo(&Version, &BuildNumber)) {
      retval = FALSE;
      goto exit;
    }

    if(TestBuildNum != BuildNumber) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has build mismatch, %d != %d\n", 
          TestBuildNum, BuildNumber));
        retval = FALSE;
        goto exit;
    }

    //
    // build number test passed.  now check for server vs. professional
    //
    if (((TestBuildType == NtProductWinNt) && CurrentProductIsServer) ||
        ((TestBuildType == NtProductServer) && !CurrentProductIsServer)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has server/professional mismatch\n" ));
        retval = FALSE;
        goto exit;
    }

    //
    // now check product suites.
    // note that we don't check for all product suites, only
    // suites that have their own SKU
    //

    if ((CurrentSuiteMask & PRODUCTSUITES_TO_MATCH) != (TestBuildSuiteMask & PRODUCTSUITES_TO_MATCH)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has suite mismatch (dest = %x) (source = %x\n", 
          TestBuildSuiteMask,CurrentSuiteMask ));
        retval = FALSE;
        goto exit;
    }

    //
    // language IDs should also match (if requested)
    //
    if (LangId != -1) {
      PWSTR LangIdStr = SpGetSectionKeyIndex(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0);
      PWSTR EndChar;

      if (LangIdStr)
        DefLangId = (LANGID)SpStringToLong(LangIdStr, &EndChar, 16);

      //
      // note : currently we are only interested in primary language IDs
      //
      retval = (PRIMARYLANGID(DefLangId) == PRIMARYLANGID(LangId)) ? TRUE : FALSE;
      goto exit;
    }

    retval = TRUE;

exit:
    return(retval);
}

NTSTATUS
SpGetMediaDetails(
    IN    PWSTR        CdInfDirPath,
    OUT    PCCMEDIA    MediaObj
    )
/*++

Routine Description:

    Gets the details of the current CD in CCMEDIA structure

Arguments:

    CdInfDirPath - The path to the inf directories on CD-ROM drive
    MediaObj     - The pointer to the media object in which the details
                    are returned

Return Value:

    Returns STATUS_SUCCESS if success otherwise appropriate status error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    WCHAR        DosNetPath[MAX_PATH];
    WCHAR        SetuppIniPath[MAX_PATH];
    PVOID        SetuppIniHandle = 0;
    PVOID        DosNetHandle = 0;
    ULONG        ErrorLine = 0;
    WCHAR        Pid[32] = {0};
    WCHAR        PidData[256] = {0};
    PWSTR        TempPtr;
    BOOLEAN     UpgradeMode = FALSE;
    DWORD       Type = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    DWORD       Variation = COMPLIANCE_INSTALLVAR_UNKNOWN;
    DWORD Version = 0, BuildNumber = 0;

    if (CdInfDirPath && MediaObj) {
        BOOLEAN VersionDetected = FALSE;
        
        wcscpy(DosNetPath, CdInfDirPath);
        wcscpy(SetuppIniPath, CdInfDirPath);

        SpConcatenatePaths(DosNetPath, L"dosnet.inf");
        SpConcatenatePaths(SetuppIniPath, L"setupp.ini");

        //
        // load setupp.ini file and parse it
        //
        Status = SpLoadSetupTextFile(
                    SetuppIniPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &SetuppIniHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );

        if(NT_SUCCESS(Status)) {
            Status = STATUS_FILE_INVALID;

            //
            // get the PID
            //
            TempPtr = SpGetSectionKeyIndex(SetuppIniHandle, L"Pid", L"Pid", 0);

            if (TempPtr) {
                wcscpy(Pid, TempPtr);

                //
                // get PID ExtraData
                //
                TempPtr = SpGetSectionKeyIndex(SetuppIniHandle, L"Pid", L"ExtraData", 0);

                if (TempPtr) {
                    wcscpy(PidData, TempPtr);

                    //
                    // Get stepup mode & install variation based on PID
                    //
                    if (SpGetStepUpMode(PidData, &UpgradeMode) &&
                            pSpGetCurrentInstallVariation(Pid, &Variation)) {
                        Status = STATUS_SUCCESS;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could "
                                 "not find StepUp mode or variation of install CD\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could not get "
                             "PidExtraData from Setupp.ini\n"));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could not get Pid from Setupp.ini\n"));
            }
        } else {
            //
            //  Silently fail if unable to read setupp.ini
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Unable to read setupp.ini. "
                     "Status = %lx \n", Status));
        }

        if (SetuppIniHandle)
            SpFreeTextFile(SetuppIniHandle);

        if (NT_SUCCESS(Status)) {
            //
            // load and parse dosnet.inf
            //
            Status = SpLoadSetupTextFile(
                        DosNetPath,
                        NULL,                  // No image already in memory
                        0,                     // Image size is empty
                        &DosNetHandle,
                        &ErrorLine,
                        TRUE,
                        FALSE
                        );

            if (NT_SUCCESS(Status)) {
                Status = STATUS_FILE_INVALID;

                //
                // get ProductType from Miscellaneous section
                //
                TempPtr = SpGetSectionKeyIndex(DosNetHandle, L"Miscellaneous",
                            L"ProductType", 0);

                if (TempPtr) {
                    UNICODE_STRING    UnicodeStr;
                    ULONG            Value = -1;

                    RtlInitUnicodeString(&UnicodeStr, TempPtr);
                    Status = RtlUnicodeStringToInteger(&UnicodeStr, 10, &Value);

                    switch (Value) {
                        case 0:
                            Type = COMPLIANCE_INSTALLTYPE_NTW;
                            break;

                        case 1:
                            Type  = COMPLIANCE_INSTALLTYPE_NTS;
                            break;

                        case 2:
                            Type  = COMPLIANCE_INSTALLTYPE_NTSE;
                            break;

                        case 3:
                            Type  = COMPLIANCE_INSTALLTYPE_NTSDTC;
                            break;

                        case 4:
                            Type = COMPLIANCE_INSTALLTYPE_NTWP;
                            break;

                        default:
                            break;
                    }

                    //
                    // Get the version also off from driverver in dosnet.inf
                    //
                    TempPtr = SpGetSectionKeyIndex(DosNetHandle, L"Version",
                                    L"DriverVer", 1);

                    if (TempPtr) {
                        if (NT_SUCCESS(SpGetVersionFromStr(TempPtr, 
                                                   &Version, &BuildNumber))) {
                            VersionDetected = TRUE;
                        }                            

                        Status = STATUS_SUCCESS;
                    } 
                    
                    if (Type != COMPLIANCE_INSTALLTYPE_UNKNOWN) {
                        Status = STATUS_SUCCESS;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: Could not get product type"
                                 " from dosnet.inf\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: "
                             "Could not get ProductType from dosnet.inf\n"));
                }
            } else {
                //
                //  Silently fail if unable to read dosnet.inf
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: Unable to read dosnet.inf. "
                         "Status = %lx \n", Status ));
            }
        }

        if (DosNetHandle)
            SpFreeTextFile(DosNetHandle);


        //
        // Fall back to old way of finding version, if we failed
        // to get one from dosnet.inf
        //
        if (NT_SUCCESS(Status) && !VersionDetected) {
          if (!DetermineSourceVersionInfo(&Version, &BuildNumber))
            Status = STATUS_FILE_INVALID;
        }


        //
        // fill in the media details
        //
        if (NT_SUCCESS(Status) &&
                ! CCMediaInitialize(MediaObj, Type, Variation, UpgradeMode, Version, BuildNumber)) {
            Status = STATUS_FILE_INVALID;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spnttree.c ===
#include "spprecmp.h"
#pragma hdrstop

/*++
Revision History
        Michael Peterson (Seagate Software)
        + Modified SpIsNtInDirectory() so that it always returns FALSE if DR is
          in effect.
--*/
PWSTR *NtDirectoryList;
ULONG  NtDirectoryCount;


BOOLEAN
SpNFilesExist(
    IN OUT PWSTR   PathName,
    IN     PWSTR  *Files,
    IN     ULONG   FileCount,
    IN     BOOLEAN Directories
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    ULONG i;
    PWSTR FilenamePart;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // No reason to call this routine to check for 0 files.
    //
    ASSERT(FileCount);

    //
    // Stick a backslash on the end of the path part if necessary.
    //
    SpConcatenatePaths(PathName,L"");
    FilenamePart = PathName + wcslen(PathName);

    //
    // Check each file.  If any one of then doesn't exist,
    // then return FALSE.
    //
    for(i=0; i<FileCount; i++) {

        //
        // Restore PathName and concatenate the new filename
        //
        *FilenamePart = L'\0';
        SpConcatenatePaths(PathName, Files[i]);


        INIT_OBJA(&Obja,&UnicodeString,PathName);

        Status = ZwCreateFile(
                    &Handle,
                    FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_OPEN_REPARSE_POINT | (Directories ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE),
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {
            ZwClose(Handle);
        } else {
            *FilenamePart = 0;
            return(FALSE);
        }
    }

    //
    // All exist.  Return TRUE.
    //
    *FilenamePart = 0;
    return(TRUE);
}


BOOLEAN
SpIsNtInDirectory(
    IN PDISK_REGION Region,
    IN PWSTR        Directory
    )

/*++

Routine Description:

    Determine whether Windows NT is present on a partition in one of a
    set of given directories.  This determination is based on the presence
    of certain windows nt system files and directories.

Arguments:

    Region - supplies the region descriptor for the partition to check.

    Directory - supplies the path to check for a windows nt installation.

Return Value:

    TRUE if we think we've found Windows NT in the given directory on
    the given partition.

--*/

{
    PWSTR NTDirectories[3] = { L"system32", L"system32\\drivers", L"system32\\config" };
    PWSTR NTFiles[2] = { L"system32\\ntoskrnl.exe", L"system32\\ntdll.dll" };
    PWSTR PaeNTFiles[2] = { L"system32\\ntkrnlpa.exe", L"system32\\ntdll.dll" };
    PWSTR OpenPath;
    BOOLEAN rc;

    if( SpDrEnabled() && ! RepairWinnt )
    {
        return( FALSE );
    }

    OpenPath = SpMemAlloc(1024);

    //
    // Place the fixed part of the name into the buffer.
    //
    SpNtNameFromRegion(
        Region,
        OpenPath,
        1024,
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(OpenPath,Directory);

    if(SpNFilesExist(OpenPath, NTDirectories, ELEMENT_COUNT(NTDirectories), TRUE) && 
            (SpNFilesExist(OpenPath, NTFiles, ELEMENT_COUNT(NTFiles), FALSE) ||
             SpNFilesExist(OpenPath, PaeNTFiles, ELEMENT_COUNT(PaeNTFiles), FALSE))) {
        rc = TRUE;
    } else {
        rc = FALSE;
    }

    SpMemFree(OpenPath);
    return(rc);
}




ULONG
SpRemoveInstallation(
    IN PDISK_REGION Region,
    IN PWSTR        PartitionPath,
    IN PWSTR        Directory
    )
{
    HANDLE Handle;
    NTSTATUS Status;
    PWSTR FileName;
    ULONG Space = 0;
    ULONG ClusterSize;
    ULONG bps;
    PVOID Gauge;
    PWSTR Filename;
    ULONG FileCount;
    ULONG FileSize;
    ULONG i;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG ErrLine;
    PVOID Inf;
    BOOLEAN OldFormatSetupLogFile;
    PWSTR   SectionName;
    HANDLE  TempHandle;
    ULONG   RootDirLength;
    PUCHAR UBuffer;
    PUCHAR Buffer;


    FileName = SpMemAlloc(1024);

    //
    // Fetch the number of bytes in a sector.
    //
    bps = HardDisks[Region->DiskNumber].Geometry.BytesPerSector;

    //
    // Get cluster size from the BPB.
    //
    ASSERT(Region->Filesystem >= FilesystemFirstKnown);

    Status = SpOpenPartition(
                HardDisks[Region->DiskNumber].DevicePath,
                SpPtGetOrdinal(Region,PartitionOrdinalCurrent),
                &Handle,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        goto xx0;
    }

    UBuffer = SpMemAlloc(2*bps);
    Buffer = ALIGN(UBuffer,bps);
    Status = SpReadWriteDiskSectors(
                Handle,
                0,
                1,
                bps,
                Buffer,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        ZwClose(Handle);
        SpMemFree(UBuffer);
        goto xx0;
    }

    //
    // Make sure this sector appears to hold a valid boot sector
    // for a hard disk.
    //
    // "55AA" was not presented by DOS 5.0 for NEC98,
    // so must not to check "55aa" in BPB,
    //
    if(((!IsNEC_98) &&
        ((Buffer[510] == 0x55) && (Buffer[511] == 0xaa) && (Buffer[21] == 0xf8))) ||
       ((IsNEC_98) && (Buffer[21] == 0xf8))) { //NEC98

        //
        // bps * spc.
        //
        ClusterSize = (ULONG)U_USHORT(Buffer+11) * (ULONG)Buffer[13];

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: sector 0 on %ws is invalid\n",PartitionPath));
        Status = STATUS_UNSUCCESSFUL;
    }

    ZwClose(Handle);
    SpMemFree(UBuffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: can't get cluster size on %ws\n",PartitionPath));
        goto xx0;
    }

    //
    //  Find out if the repair directory exists, if it does exist load
    //  setup.log from the repair directory. Otherwise, load setup.log
    //  from the WinNt directory
    //
    wcscpy(FileName,PartitionPath);
    SpConcatenatePaths(FileName,Directory);
    RootDirLength = wcslen(FileName);

    SpConcatenatePaths(FileName,SETUP_REPAIR_DIRECTORY);
    INIT_OBJA( &Obja, &UnicodeString, FileName );
    Status = ZwOpenFile( &TempHandle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                       );

    if( !NT_SUCCESS( Status ) ) {
        FileName[ RootDirLength ] = L'\0';
    } else {
        ZwClose( TempHandle );
    }

    SpConcatenatePaths(FileName,SETUP_LOG_FILENAME);

    //
    // Load setup.log from the given path.
    //
    Status = SpLoadSetupTextFile(FileName,NULL,0,&Inf,&ErrLine,TRUE,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: can't load inf file %ws (%lx)\n",FileName,Status));

        while(1) {
            ULONG ks[2] = { ASCI_CR, 0 };

            SpStartScreen(
                SP_SCRN_CANT_LOAD_SETUP_LOG,
                3,
                HEADER_HEIGHT+2,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                FileName + wcslen(PartitionPath)    // skip \device\harddiskx\partitiony
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            switch(SpWaitValidKey(ks,NULL,NULL)) {
            case ASCI_CR:
                goto xx0;
            }
        }
    }

    //
    // Go through all files in the [Repair.WinntFiles] section
    //

    SpStartScreen(
        SP_SCRN_WAIT_REMOVING_NT_FILES,
        0,
        8,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    //
    //  Determine whether setup.log has the new or old style
    //
    if( OldFormatSetupLogFile = !IsSetupLogFormatNew( Inf ) ) {
        SectionName = SIF_REPAIRWINNTFILES;
    } else {
        SectionName = SIF_NEW_REPAIR_WINNTFILES;
    }

    FileCount = SpCountLinesInSection(Inf,SectionName);

    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_REMOVING_FILES
        );

    Gauge = SpCreateAndDisplayGauge(
                FileCount,
                0,
                VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                TemporaryBuffer,
                NULL,
                GF_PERCENTAGE,
                0
                );

    //
    // Clear the status area.
    //
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,0);

    //
    // Set the status text in the lower right portion of the screen
    // to "Removing:" in preparation for displaying filenames as
    // files are deleted.  The 12 is for an 8.3 name.
    //
    SpDisplayStatusActionLabel(SP_STAT_REMOVING,12);

    for(i=0; i<FileCount; i++) {

        if( OldFormatSetupLogFile ) {
            Filename = SpGetSectionLineIndex(Inf,SectionName,i,1);
        } else {
            Filename = SpGetKeyName(Inf,SectionName,i);
        }
        if(Filename) {

            PWCHAR p = wcsrchr(Filename,L'\\');

            if(p) {
                p++;
            } else {
                p = Filename;
            }

#ifdef _X86_
            {
                //
                // Don't remove files in the system directory.
                // We might have installed into the windows directory
                // so removing files in the system directory would
                // wipe out the user's fonts (which are shared between
                // 3.1 and nt).
                //
                PWSTR dup = SpDupStringW(Filename);
                SpStringToLower(dup);
                if(wcsstr(dup,L"\\system\\")) {
                    SpMemFree(dup);
                    SpTickGauge(Gauge);
                    continue;
                }
                SpMemFree(dup);
            }
#endif

            SpDisplayStatusActionObject(p);

            //
            // Form the full pathname of the file being deleted.
            //
            wcscpy(FileName,PartitionPath);
            SpConcatenatePaths(FileName,Filename);

            //
            // Open the file.
            //
            INIT_OBJA(&Obja,&UnicodeString,FileName);

            Status = ZwCreateFile(
                        &Handle,
                        FILE_READ_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN,  // open if exists
                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: unable to open %ws (%lx)\n",FileName,Status));
            } else {

                //
                // Get the file size.
                //
                Status = SpGetFileSize(Handle,&FileSize);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: unable to get %ws file size (%lx)\n",FileName,Status));
                    FileSize = 0;
                } else {

                    //
                    // Add the size of this file to the running total.
                    //
                    if(FileSize % ClusterSize) {

                        FileSize += ClusterSize - (FileSize % ClusterSize);
                    }

                    Space += FileSize;
                }

                ZwClose(Handle);

                //
                // Delete the file
                //
                Status = SpDeleteFile(FileName,NULL,NULL);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ws (%lx)\n",FileName,Status));
                    Space -= FileSize;
                }
            }
        }

        SpTickGauge(Gauge);
    }

    SpFreeTextFile(Inf);

    SpDestroyGauge(Gauge);

    SpDisplayStatusActionLabel(0,0);

    xx0:

    SpMemFree(FileName);
    return(Space);
}



BOOLEAN
SpIsNtOnPartition(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    Determine whether there is any Windows NT installed on
    a given partition.

Arguments:

    PartitionPath - supplies NT path to partition on which we
        should look for NT installations.

Return Value:

    TRUE if any NT installations were found.
    FALSE if not.

--*/

{
    ULONG i;

    SpGetNtDirectoryList(&NtDirectoryList,&NtDirectoryCount);

    for(i=0; i<NtDirectoryCount; i++) {
        if(SpIsNtInDirectory(Region,NtDirectoryList[i])) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOLEAN
SpAllowRemoveNt(
    IN  PDISK_REGION    Region,
    IN  PWSTR           DriveSpec,      OPTIONAL
    IN  BOOLEAN         RescanForNTs,
    IN  ULONG           ScreenMsgId,
    OUT PULONG          SpaceFreed
    )

/*++

Routine Description:


Arguments:

    ScreenMsgId - supplies the message id of the text that will be
        printed above the menu of located nt directories,
        to supply instructions, etc.

    SpaceFreed - receives amount of disk space created by removing a
        Windows NT tree, if this function returns TRUE.

Return Value:

    TRUE if any files were actually removed.
    FALSE otherwise.

    If an error occured, the user will have already been told about it.

--*/

{
    ULONG i;
    ULONG NtCount;
    PULONG MenuOrdinals;
    PWSTR *MenuItems;
    PWSTR *MenuTemp;
    BOOLEAN rc,b;
    BOOLEAN Add;
    ULONG MenuWidth,MenuLeftX;
    PVOID Menu;
    PWSTR PartitionPath;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    PartitionPath = SpMemAlloc(512);

    //
    // Form the nt pathname for this partition.
    //
    SpNtNameFromRegion(
        Region,
        PartitionPath,
        512,
        PartitionOrdinalCurrent
        );

    //
    // Assume nothing deleted.
    //
    rc = FALSE;

    //
    // Go look for Windows NT installations.
    //
    if(RescanForNTs) {
        SpGetNtDirectoryList(&NtDirectoryList,&NtDirectoryCount);
    }

    if(!NtDirectoryCount) {
        goto xx0;
    }

    //
    // Determine whether any of the NT trees we found are
    // on the given partition, and build an association between
    // NT trees and their ordinal positions in the menu we will
    // present to the user, and the menu itself.
    //
    NtCount = 0;
    MenuOrdinals = SpMemAlloc((NtDirectoryCount+1)*sizeof(ULONG));
    MenuItems = SpMemAlloc((NtDirectoryCount+1)*sizeof(PWSTR));

    //
    // Eliminate potential duplicate entries in the menu
    // to be presented to the user.
    //
    MenuTemp = SpMemAlloc(NtDirectoryCount*sizeof(PWSTR));
    for(i=0; i<NtDirectoryCount; i++) {

        WCHAR FullName[128];
        ULONG j;

        _snwprintf(
            FullName,
            (sizeof(FullName)/sizeof(WCHAR))-1,
            L"%s%s",
            DriveSpec ? DriveSpec : L"",
            NtDirectoryList[i]
            );

        FullName[(sizeof(FullName)/sizeof(WCHAR))-1] = 0;

        //
        // If the name is not already in the list, then add it.
        //
        for(Add=TRUE,j=0; Add && (j<i); j++) {
            if(MenuTemp[j] && !_wcsicmp(FullName,MenuTemp[j])) {
                Add = FALSE;
            }
        }

        MenuTemp[i] = Add ? SpDupStringW(FullName) : NULL;
    }

    //
    // Construct the menu to be presented to the user by looking in the
    // list of directories constructed above.
    //
    for(i=0; i<NtDirectoryCount; i++) {

        if(MenuTemp[i] && SpIsNtInDirectory(Region,NtDirectoryList[i])) {

            MenuOrdinals[NtCount] = i;
            MenuItems[NtCount] = SpDupStringW(MenuTemp[i]);
            NtCount++;
        }
    }

    for(i=0; i<NtDirectoryCount; i++) {
        if(MenuTemp[i]) {
            SpMemFree(MenuTemp[i]);
        }
    }
    SpMemFree(MenuTemp);

    //
    // If we found any nt directories on this partition,
    // make a menu to present to the user.  Otherwise we
    // are done here.
    //
    if(!NtCount) {
        goto xx1;
    }

    MenuOrdinals = SpMemRealloc(MenuOrdinals,(NtCount+1) * sizeof(ULONG));
    MenuItems = SpMemRealloc(MenuItems,(NtCount+1) * sizeof(PWSTR));

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_REMOVE_NO_FILES);
    MenuItems[NtCount] = SpDupStringW(TemporaryBuffer);

    //
    // Determine the width of the widest item.
    //
    MenuWidth = 0;
    for(i=0; i<=NtCount; i++) {
        if(SplangGetColumnCount(MenuItems[i]) > MenuWidth) {
            MenuWidth = SplangGetColumnCount(MenuItems[i]);
        }
    }
    //
    // Use 80-column screen here because that's how the screen text
    // above the menu will be formatted.
    //
    MenuLeftX = 40 - (MenuWidth/2);

    //
    // Create menu and populate it.
    //
    SpDisplayScreen(ScreenMsgId,3,HEADER_HEIGHT+1);

    Menu = SpMnCreate(
                MenuLeftX,
                NextMessageTopLine+(SplangQueryMinimizeExtraSpacing() ? 1 : 2),
                MenuWidth,
                VideoVars.ScreenHeight-STATUS_HEIGHT-NextMessageTopLine-(SplangQueryMinimizeExtraSpacing() ? 2 : 3)
                );

    for(i=0; i<=NtCount; i++) {
        SpMnAddItem(Menu,MenuItems[i],MenuLeftX,MenuWidth,TRUE,i);
    }

    //
    // Present the menu of installations available for removal
    // on this partition and await a choice.
    //

    b = TRUE;
    do {

        ULONG Keys[4] = { ASCI_CR,KEY_F3,ASCI_ESC,0 };
        ULONG Mnemonics[2] = { MnemonicRemoveFiles,0 };
        ULONG key;
        ULONG_PTR Choice;

        SpDisplayScreen(ScreenMsgId,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        nextkey:

        SpMnDisplay(Menu,NtCount,FALSE,Keys,NULL,NULL,&key,&Choice);

        if(key == KEY_F3) {
            SpConfirmExit();
        } else if(key == ASCI_ESC) {
            break;
        } else if(key == ASCI_CR) {

            if(Choice == NtCount) {
                b = FALSE;
            } else {

                BOOLEAN keys;
                ULONG ValidKeys2[3] = { KEY_F3,ASCI_ESC,0 };

                //
                // User wants to actually remove an installation.
                // Confirm and then do that here.
                //

                redraw2:

                SpStartScreen(
                    SP_SCRN_REMOVE_EXISTING_NT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    MenuItems[Choice]
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_R_EQUALS_REMOVE_FILES,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                keys = TRUE;
                while(keys) {
                    switch(SpWaitValidKey(ValidKeys2,NULL,Mnemonics)) {
                    case KEY_F3:
                        SpConfirmExit();
                        goto redraw2;
                    case ASCI_ESC:
                        keys = FALSE;
                        break;
                    default:

                        //
                        // Must be r=remove files.
                        //
                        *SpaceFreed = SpRemoveInstallation(
                                        Region,
                                        PartitionPath,
                                        NtDirectoryList[MenuOrdinals[Choice]]
                                        );

                        rc = TRUE;

                        SpStartScreen(
                            SP_SCRN_DONE_REMOVING_EXISTING_NT,
                            4,
                            HEADER_HEIGHT+3,
                            FALSE,
                            FALSE,
                            DEFAULT_ATTRIBUTE,
                            *SpaceFreed
                            );

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        while(SpInputGetKeypress() != ASCI_CR) ;
                        keys = FALSE;
                        b = FALSE;
                        break;
                    }
                }
            }

        } else {
            goto nextkey;
        }
    } while(b);

    SpMnDestroy(Menu);

    xx1:

    for(i=0; i<=NtCount; i++) {
        SpMemFree(MenuItems[i]);
    }

    SpMemFree(MenuItems);
    SpMemFree(MenuOrdinals);

    xx0:

    SpMemFree(PartitionPath);
    return(rc);
}


#if 0

typedef
VOID
(*PINSTALLATION_CALLBACK_ROUTINE)(
    IN PWSTR                       DirectoryPath,
    IN PFILE_DIRECTORY_INFORMATION FoundFileInfo
    );

//
// Stuff to reduce stack usage.
//
PINSTALLATION_CALLBACK_ROUTINE FileIterationCallback;
POBJECT_ATTRIBUTES FileIterationObja;
PIO_STATUS_BLOCK FileIterationIoStatusBlock;
PUNICODE_STRING FileIterationUnicodeString;

VOID
SpIterateInstallationFilesWorker(
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2
    )
{
    PVOID InfoBuffer;
    PWSTR FullPath;
    NTSTATUS Status;
    HANDLE hFile;
    BOOLEAN restart;
    #define DIRINFO(x) ((PFILE_DIRECTORY_INFORMATION)InfoBuffer)

    InfoBuffer = SpMemAlloc(1024);

    //
    // Form the full path name of the current directory.
    //
    FullPath = SpMemAlloc( ( wcslen(FilenamePart1)
                           + (FilenamePart2 ? wcslen(FilenamePart2) : 0),
                           + 2) * sizeof(WCHAR)
                           );

    wcscpy(FullPath,FilenamePart1);
    if(FilenamePart2) {
        SpConcatenatePaths(FullPath,FilenamePart2);
    }

    //
    // Open the directory for list access.
    //
    INIT_OBJA(FileIterationObja,FileIterationUnicodeString,FullPath);

    Status = ZwOpenFile(
                &hFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                FileIterationObja,
                FileIterationIoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(NT_SUCCESS(Status)) {

        restart = TRUE;

        do {

            Status = ZwQueryDirectoryFile(
                        hFile,
                        NULL,
                        NULL,
                        NULL,
                        FileIterationIoStatusBlock,
                        InfoBuffer,
                        1024 - sizeof(WCHAR),   // leave room for nul
                        FileDirectoryInformation,
                        TRUE,                   // return single entry
                        NULL,                   // no file name (match all files)
                        restart
                        );

            restart = FALSE;

            if(NT_SUCCESS(Status)) {

                //
                // nul-terminate the filename just in case
                //
                DIRINFO->FileName[DIRINFO->FileNameLength/sizeof(WCHAR)] = 0;

                if(DIRINFO->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                    if(DIRINFO->FileName[0] != L'.') {

                        SpIterateInstallationFiles(
                            FullPath,
                            DIRINFO->FileName
                            );

                        FileIterationCallback(FullPath,InfoBuffer);
                    }
                } else {
                    FileIterationCallback(FullPath,InfoBuffer);
                }
            }

        } while(NT_SUCCESS(Status));

        ZwClose(hFile);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open directory %ws for list access (%lx)\n",FullPath,Status));
    }

    SpMemFree(FullPath);
    SpMemFree(InfoBuffer);
}


VOID
SpIterateInstallationFiles(
    IN PWSTR                          FilenamePart1,
    IN PWSTR                          FilenamePart2,
    IN PINSTALLATION_CALLBACK_ROUTINE CallbackFunction
    )
{
    //
    // Set up stack-saving globals
    //
    FileIterationIoStatusBlock = SpMemAlloc(sizeof(IO_STATUS_BLOCK);
    FileIterationUnicodeString = SpMemAlloc(sizeof(UNICODE_STRING));
    FileIterationObja          = SpMemAlloc(sizeof(OBJECT_ATTRIBUTES);

    FileIterationCallback = CallbackFunction;

    //
    // Do the iteration.
    //
    SpIterateInstallationFilesWorker(FileNamePart1,FilenamePart2);

    //
    // Clean up.
    //
    SpMemFree(FileIterationObja);
    SpMemFree(FileIterationUnicodeString);
    SpMemFree(FileIterationIoStatusBlock);
}
#endif


BOOLEAN
IsSetupLogFormatNew(
    IN  PVOID   Inf
    )

/*++

Routine Description:

    Informs the caller whether or not the information on setup.log
    is in the new format.

Arguments:

    Inf -

Return Value:

    TRUE if the information is in the new format.
    FALSE otherwise.

--*/

{
    return( SpGetSectionKeyExists ( Inf,
                                    SIF_NEW_REPAIR_SIGNATURE,
                                    SIF_NEW_REPAIR_VERSION_KEY )
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppart2.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppart2.c

Abstract:

    Second file for disk preparation UI;
    supplies routines to handle a user's selection
    of the partition onto which he wants to install NT.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop



#ifdef _X86_
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );
#endif

ULONG
SpFormattingOptions(
    IN BOOLEAN  AllowFatFormat,
    IN BOOLEAN  AllowNtfsFormat,
    IN BOOLEAN  AllowConvertNtfs,
    IN BOOLEAN  AllowDoNothing,
    IN BOOLEAN  AllowEscape
    );


BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    );

typedef enum {
    FormatOptionCancel = 0,
    FormatOptionFat,
    FormatOptionNtfs,
    FormatOptionFatQuick,
    FormatOptionNtfsQuick,
    FormatOptionConvertToNtfs,
    FormatOptionDoNothing
} FormatOptions;

extern PSETUP_COMMUNICATION CommunicationParams;

//#ifdef TEST
#ifdef _X86_
BOOLEAN
SpIsExistsOs(
    IN PDISK_REGION CColonRegion
    );

extern NTSTATUS
pSpBootCodeIo(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN     PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    );

extern VOID
SpDetermineOsTypeFromBootSector(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    );

extern BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    );
#endif
//#endif //TEST


BOOLEAN
SpPtDeterminePartitionGood(
    IN PDISK_REGION Region,
    IN ULONGLONG    RequiredKB,
    IN BOOLEAN      DisallowOtherInstalls
    )
{
    UCHAR SystemId;
    BOOLEAN NewlyCreated;
    ULONG PreconfirmFormatId;
    ULONG ValidKeys1[2] = { ASCI_CR ,0 };
    ULONG ValidKeys2[2] = { ASCI_ESC,0 };
    ULONG Mnemonics1[2] = { MnemonicContinueSetup, 0 };
    ULONG Mnemonics2[2] = { 0,0 };
    ULONGLONG RegionSizeKB;
    ULONG r;
#ifdef _X86_
    PDISK_REGION systemPartitionRegion;
#endif
    ULONG selection;
    NTSTATUS Status;
    ULONG Count;
    PWSTR p;
    PWSTR RegionDescr;
    LARGE_INTEGER temp;


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
        "SETUP: SpPtDeterminePartitionGood(): Starting partition verification\n" ));

    //
    // Make sure we can see the disk from the firmware/bios.
    // If we can get an arc name for the disk, assume it's ok.
    // Otherwise, it ain't.
    //
    p = SpNtToArc( HardDisks[Region->DiskNumber].DevicePath,PrimaryArcPath );
    
    if (p == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Failed to create an arc name for this partition\n" ));
            
        return FALSE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
        "SETUP: SpPtDeterminePartitionGood(): partition=[%ws]\n", p ));

    //
    // Make sure the partition is formatted.
    //
    if( Region->PartitionedSpace ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition is formated.\n"));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition hasn't been formated.\n"));
            
        return FALSE;
    }

    //
    // I think he's formatted, but he better be of a format that I can read.
    // Make sure.
    //
    if( (Region->Filesystem == FilesystemFat)        ||
        (Region->Filesystem == FilesystemFirstKnown) ||
        (Region->Filesystem == FilesystemNtfs)       ||
        (Region->Filesystem == FilesystemFat32) ) {

        //
        // Life is grand.  Let's tell the user and keep going.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition "
            "is formated with a known filesystem (%d).\n", Region->Filesystem ));
    } else {
        //
        // Darn!  We don't know how to read this filesystem.  Bail.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition is "
            "formated with an unknown (or invalid for holding an installation) "
            "filesystem (%d).\n", Region->Filesystem ));
            
        return FALSE;
    }

#ifdef _X86_
    //
    // On x86 we don't allow disks that have LUN greater than 0
    //
    SpStringToLower( p );
    
    if( wcsstr( p, L"scsi(" ) &&
        wcsstr( p, L")rdisk(" ) ) {
        if( wcsstr( p, L")rdisk(0)" ) == NULL ) {
            SpMemFree(p);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Disks with "
                "a LUN greater than zero are not allowed\n" ));
                
            return FALSE;
        }
    }
#endif

    SpMemFree(p);

    //
    // Disallow installation to PCMCIA disks.
    //
    if(HardDisks[Region->DiskNumber].PCCard) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install to PCMCIA disk\n" ));
            
        return FALSE;
    }

    //
    // don't choose a removeable drive
    //

#if 0
    //
    // Allow installs to removable media...
    //
    if(HardDisks[Region->DiskNumber].Characteristics & FILE_REMOVABLE_MEDIA) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install to a removable disk\n" ));
            
        return FALSE;
    }
#endif

    //
    // Disallow installs to removable media or AT formatted drive, on NEC98.
    //
    if(IsNEC_98 &&	
       ((HardDisks[Region->DiskNumber].Characteristics & FILE_REMOVABLE_MEDIA) ||
	    (HardDisks[Region->DiskNumber].FormatType == DISK_FORMAT_TYPE_PCAT))) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install "
            "to a removable disk or  AT formatted disk\n" ));
            
        return  FALSE;
    }

    //
    // Calculate the size of the region in KB.
    //
    temp.QuadPart = UInt32x32To64(
                        Region->SectorCount,
                        HardDisks[Region->DiskNumber].Geometry.BytesPerSector
                        );

    RegionSizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&r).LowPart;

    //
    // If the region is not large enough, bail
    //
    if (RegionSizeKB < RequiredKB) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Partition does not "
            "have enough free space: required=%ld, available=%ld\n", 
            RequiredKB, 
            RegionSizeKB ));
            
        return FALSE;
    }

    if (!Region->PartitionedSpace) {
        //
        // can't use a partition with just free space
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Partition does not "
            "have any partitioned space\n" ));
            
        return FALSE;
    }

/*
#ifdef NEW_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
        SystemId = PARTITION_FAT32;
    } else {
        SystemId = SPPT_GET_PARTITION_TYPE(Region);
    }        

#endif

#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
        SystemId = PARTITION_FAT32;
    } else {                
        SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;
    }        
    
#endif

#ifdef OLD_PARTITION_ENGINE
    //
    // If the region is a partition but not a native
    // type, then tell the user that he must explicitly delete it
    // and recreate it first.
    //
    SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;

#endif    
*/
    SystemId = SpPtGetPartitionType(Region);

    if (SystemId == PARTITION_ENTRY_UNUSED || IsContainerPartition(SystemId)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Invalid partition type(1)\n" ));
        return FALSE;
    }

    if( (PartitionNameIds[SystemId] != (UCHAR)(-1)) && 
        (!Region->DynamicVolume || !Region->DynamicVolumeSuitableForOS)) {
        
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Invalid partition type(2)\n" ));
            
        return FALSE;
    }

    //
    // The region is a partition that we recognize.
    // See whether it has enough free space on it.
    //
    if(Region->AdjustedFreeSpaceKB == (ULONG)(-1)) {

        //
        // If the partition was newly created during setup
        // then it is acceptable (because the check to see
        // if it is large enough was done above).
        //

        if(Region->Filesystem != FilesystemNewlyCreated) {
            //
            // Otherwise, we don't know how much space is
            // on the drive so reformat will be necessary.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Format is necessary\n" ));
                
            return FALSE;
        }
    } else {
        if(Region->AdjustedFreeSpaceKB < RequiredKB) {
            //
            // If we get here, then the partition is large enough,
            // but there is definitely not enough free space on it.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Partition does not have "
                "enough free space: required=%ld, available=%ld\n", 
                RequiredKB, Region->AdjustedFreeSpaceKB ));
                
            return FALSE;
        }
    }

#ifdef _X86_
    if(!SpIsArc())
    {
        //
        // On an x86 machine, make sure that we have a valid primary partition
        // on drive 0 (C:), for booting.
        //
        if (!IsNEC_98) { // this is a standard PC/AT type machine
            if((systemPartitionRegion = SpPtValidSystemPartition()) == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtDeterminePartitionGood(): Not a valid primary partition\n" ));
                    
                return FALSE;
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(systemPartitionRegion);
        } else {
            //
            // Check existing system on target partition,
            // If it exists, don't choose it as target partition.
            //
            if (SpIsExistsOs(Region)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): OS already exists\n" ));
                return(FALSE);
            }

            //
            // All of partition is bootable on NEC98,
            // so we don't need to check system partition on C:.
            //
            systemPartitionRegion = Region;
        } //NEC98
    }
#endif

    if (DisallowOtherInstalls) {

        PUCHAR Win9xPath;

#ifdef _X86_
        if (SpIsWin9xMsdosSys( Region, &Win9xPath )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Cannot use a partition with WIN9x installed on it\n" ));
            return FALSE;
        }
#endif

        if (SpIsNtOnPartition(Region)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Cannot use a partition with NT installed on it\n" ));
            return FALSE;
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Parition is GOOD :)\n" ));

    return TRUE;
}

#ifdef _X86_
BOOLEAN
SpIsExistsOs(
    IN OUT PDISK_REGION CColonRegion
    )
{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode;
    NTSTATUS Status;
    PUCHAR ExistingBootCodeOs;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    BOOLEAN IsNtBootcode,OtherOsInstalled;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG   BytesPerSector;
    ULONG   ActualSectorCount, hidden_sectors, super_area_size;
    BOOLEAN IsExist = TRUE;

    ULONG   MirrorSector;
    PWSTR   *FilesToLookFor;
    ULONG   FileCount;
    PWSTR NtFiles[1] = { L"NTLDR" };
    PWSTR ChicagoFiles[1] = { L"IO.SYS" };

    ExistingBootCode = NULL;
    BytesPerSector = HardDisks[CColonRegion->DiskNumber].Geometry.BytesPerSector;

    switch(CColonRegion->Filesystem) {

    case FilesystemNewlyCreated:

        //
        // If the filesystem is newly-created, then there is
        // nothing to do, because there can be no previous
        // operating system.
        //
        IsExist = TRUE;
        return( IsExist );

    case FilesystemNtfs:

        NewBootCode = PC98NtfsBootCode;
        BootCodeSize = sizeof(PC98NtfsBootCode);
        ASSERT(BootCodeSize == 8192);
        break;

    case FilesystemFat:

        NewBootCode = PC98FatBootCode;
        BootCodeSize = sizeof(PC98FatBootCode);
        ASSERT(BootCodeSize == 512);
        break;

    case FilesystemFat32:

        //
        // Special hackage required for Fat32 because its NT boot code
        // is discontiguous.
        //
        ASSERT(sizeof(Fat32BootCode) == 1536);
        NewBootCode = PC98Fat32BootCode;
        BootCodeSize = 512;
        break;

    default:

        ASSERT(0);
        IsExist = TRUE;
        return( IsExist );
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion(CColonRegion,TemporaryBuffer,sizeof(TemporaryBuffer),PartitionOrdinalCurrent);
    CColonPath = SpDupStringW(TemporaryBuffer);
    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile(
        &PartitionHandle,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open the partition!\n"));
        ASSERT(0);
        IsExist = TRUE;
        return( IsExist );
    }


    //
    // Just use the existing boot code.
    //

    Status = pSpBootCodeIo(
                    CColonPath,
                    NULL,
                    BootCodeSize,
                    &ExistingBootCode,
                    FILE_OPEN,
                    FALSE,
                    0,
                    BytesPerSector
                    );

    if(CColonRegion->Filesystem == FilesystemNtfs) {
        MirrorSector = NtfsMirrorBootSector(PartitionHandle,BytesPerSector,NULL);
    }

    switch(CColonRegion->Filesystem) {

    case FilesystemFat:

        if(NT_SUCCESS(Status)) {

            //
            // Determine the type of operating system the existing boot sector(s) are for
            // and whether that os is actually installed.
            //

            SpDetermineOsTypeFromBootSector(
                CColonPath,
                ExistingBootCode,
                &ExistingBootCodeOs,
                &IsNtBootcode,
                &OtherOsInstalled,
                CColonRegion->DriveLetter
                );

            if (OtherOsInstalled == TRUE) {
                IsExist = TRUE;

            } else if (IsNtBootcode == TRUE) {
                wcscpy(TemporaryBuffer,CColonPath);
                FilesToLookFor = NtFiles;
                FileCount = ELEMENT_COUNT(NtFiles);

                if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
                    IsExist = TRUE;
                } else {
                    IsExist = FALSE;
                }

            } else {
                IsExist = FALSE;
            }

        } else {
            IsExist = TRUE;
        }
        break;

    case FilesystemFat32:

        wcscpy(TemporaryBuffer,CColonPath);
        FilesToLookFor = NtFiles;
        FileCount = ELEMENT_COUNT(NtFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
            IsExist = TRUE;
        }

        FilesToLookFor = ChicagoFiles;
        FileCount = ELEMENT_COUNT(ChicagoFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {

            wcscpy(TemporaryBuffer, CColonPath);
            SpConcatenatePaths(TemporaryBuffer, L"IO.SYS");

            if(SpHasMZHeader(TemporaryBuffer)) {
                IsExist = TRUE;
            } else {
                IsExist = FALSE;
            }
        } else {
            IsExist = FALSE;
        }
        break;

    case FilesystemNtfs:

        wcscpy(TemporaryBuffer,CColonPath);
        FilesToLookFor = NtFiles;
        FileCount = ELEMENT_COUNT(NtFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
            IsExist = TRUE;
        } else {
            IsExist = FALSE;
        }
        break;

    default:

        ASSERT(0);
        IsExist = TRUE;
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);
    return( IsExist );
}
#endif   // _X86_

BOOLEAN
SpPtDoPartitionSelection(
    IN OUT PDISK_REGION *Region,
    IN     PWSTR         RegionDescription,
    IN     PVOID         SifHandle,
    IN     BOOLEAN       Unattended,
    IN     PWSTR         SetupSourceDevicePath,
    IN     PWSTR         DirectoryOnSetupSource,
    IN     BOOLEAN       RemoteBootRepartition,
    OUT    PBOOLEAN      Win9xInstallationPresent    
    )
{
    ULONG RequiredKB;
    ULONG TempKB;
    UCHAR SystemId;
    BOOLEAN NewlyCreated;
    ULONG PreconfirmFormatId;
    ULONG ValidKeys1[2] = { ASCI_CR ,0 };
    ULONG ValidKeys2[2] = { ASCI_ESC,0 };
    ULONG Mnemonics1[2] = { MnemonicContinueSetup, 0 };
    ULONG Mnemonics2[2] = { 0,0 };
    ULONG RegionSizeKB;
    ULONG r;
#ifdef _X86_
    PDISK_REGION systemPartitionRegion;
#endif
    BOOLEAN AllowNtfsOptions;
    BOOLEAN AllowFatOptions;
    ULONG selection;
    NTSTATUS Status;
    ULONG   Count;
    PWSTR p;
    PWSTR RegionDescr;
    PDISK_REGION region = *Region;
    LARGE_INTEGER temp;
    BOOLEAN AllowFormatting;
    BOOLEAN QuickFormat = FALSE, OtherOSOnPartition;
    PSTR Win9xPath = NULL;
    PWCHAR Win9xPathW = NULL;

    if (Win9xInstallationPresent) {
        *Win9xInstallationPresent = FALSE;
    }                        

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup on a diskless machine, skip partition
    // selection (note that we check the RemoteBootSetup global flag, not
    // the passed-in RemoteBootRepartition flag).
    //
    if (RemoteBootSetup && (HardDiskCount == 0)) {
        return TRUE;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Assume that if we need to format the drive, that
    // the user needs to confirm.
    //
    PreconfirmFormatId = 0;
    NewlyCreated = FALSE;
    AllowNtfsOptions = TRUE;
    AllowFatOptions = TRUE;

    //
    // Disallow installation to PCMCIA disks.
    //
    if(HardDisks[region->DiskNumber].PCCard) {
        SpDisplayScreen(SP_SCRN_CANT_INSTALL_ON_PCMCIA,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    //
    // Disallow installation to non-platform disk
    // on clean installs
    //
    // X86  - Installs only to MBR disks
    // IA64 - Installs only to GPT disks
    //
    if (SPPT_GET_DISK_TYPE(region->DiskNumber) != SPPT_DEFAULT_DISK_STYLE) {
        SpDisplayScreen(SP_SCRN_INVALID_INSTALLPART, 3, HEADER_HEIGHT+1);        
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        
        SpWaitValidKey(ValidKeys1,NULL,NULL);
    
        return FALSE;
    }

    //
    // Make sure we can see the disk from the firmware/bios.
    // If we can get an arc name for the disk, assume it's ok.
    // Otherwise, it ain't.
    //
    if(p = SpNtToArc(HardDisks[region->DiskNumber].DevicePath,PrimaryArcPath)) {
#ifdef _X86_
        //
        // On x86 we don't allow disks that have LUN greater than 0
        //
        SpStringToLower( p );
        if( wcsstr( p, L"scsi(" ) &&
            wcsstr( p, L")rdisk(" ) ) {
            if( wcsstr( p, L")rdisk(0)" ) == NULL ) {
                //
                // Tell the user that we can't install to that disk.
                //
                SpDisplayScreen(SP_SCRN_DISK_NOT_INSTALLABLE_LUN_NOT_SUPPORTED,
                                3,
                                HEADER_HEIGHT+1);
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                SpWaitValidKey(ValidKeys1,NULL,NULL);
                SpMemFree(p);
                return(FALSE);
            }
        }
#endif
        SpMemFree(p);
    } else {
        //
        // Tell the user that we can't install to that disk.
        //
        SpDisplayScreen(SP_SCRN_DISK_NOT_INSTALLABLE,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    //
    // Disallow installation of Personal onto dynamic disks 
    // since dynamic disks feature is not available on Personal
    //
    if (SpIsProductSuite(VER_SUITE_PERSONAL) && 
        SpPtnIsDynamicDisk(region->DiskNumber)) {    

        SpDisplayScreen(SP_NO_DYNAMIC_DISK_INSTALL, 
            3, 
            HEADER_HEIGHT + 1);
            
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            0);
            
        SpWaitValidKey(ValidKeys1, NULL, NULL);        

        return FALSE;
    }

    //
    // Fetch the amount of free space required on the windows nt drive.
    //
    SpFetchDiskSpaceRequirements( SifHandle,
                                  region->BytesPerCluster,
                                  &RequiredKB,
                                  NULL);

    //
    // For remote install, we have not yet copied ~LS, so add that space
    // in also.
    //
    if (RemoteInstallSetup) {
        SpFetchTempDiskSpaceRequirements( SifHandle,
                                          region->BytesPerCluster,
                                          &TempKB,
                                          NULL);
        RequiredKB += TempKB;
    }

    //
    // Calculate the size of the region in KB.
    //
    temp.QuadPart = UInt32x32To64(
                        region->SectorCount,
                        HardDisks[region->DiskNumber].Geometry.BytesPerSector
                        );

    RegionSizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&r).LowPart;

    //
    // If the region is not large enough, tell the user.
    //
    if(RegionSizeKB < RequiredKB) {

        SpStartScreen(
            SP_SCRN_REGION_TOO_SMALL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            (RequiredKB / 1024) + 1
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    if(region->PartitionedSpace) {     

/*
#ifdef NEW_PARTITION_ENGINE

        if (SPPT_IS_GPT_DISK(region->DiskNumber)) {
            SystemId = PARTITION_FAT32;
        } else {
            SystemId = SPPT_GET_PARTITION_TYPE(region);
        }       

#endif

#ifdef GPT_PARTITION_ENGINE

        if (SPPT_IS_GPT_DISK(region->DiskNumber)) {
            SystemId = PARTITION_FAT32;
        } else {
            SystemId = region->MbrInfo->OnDiskMbr.PartitionTable[region->TablePosition].SystemId;
        }

#endif              

#ifdef OLD_PARTITION_ENGINE
        //
        // If the region is a partition but not a native
        // type, then tell the user that he must explicitly delete it
        // and recreate it first.
        //
        SystemId = region->MbrInfo->OnDiskMbr.PartitionTable[region->TablePosition].SystemId;
#endif        
*/
        SystemId = SpPtGetPartitionType(region);        

        ASSERT(SystemId != PARTITION_ENTRY_UNUSED);
        ASSERT(!IsContainerPartition(SystemId));

        if((PartitionNameIds[SystemId] != (UCHAR)(-1))
           && (!region->DynamicVolume || !region->DynamicVolumeSuitableForOS)
          ){

            SpStartScreen(
                SP_SCRN_FOREIGN_PARTITION,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
            SpWaitValidKey(ValidKeys1,NULL,NULL);
            return(FALSE);
        }


        if (!RemoteBootRepartition) {

            //
            // The region is a partition that we recognize.
            // See whether it has enough free space on it.
            //
            if(region->AdjustedFreeSpaceKB == (ULONG)(-1)) {

                //
                // If the partition was newly created during setup
                // then it acceptable (because the check to see
                // if it is large enough was done above).
                //

                if(region->Filesystem != FilesystemNewlyCreated) {

                    //
                    // Otherwise, we don't know how much space is
                    // on the drive so reformat will be necessary.
                    //
                    PreconfirmFormatId = SP_SCRN_UNKNOWN_FREESPACE;
                }
            } else {
                if(region->AdjustedFreeSpaceKB < RequiredKB) {

                    //
                    // If we get here, then the partition is large enough,
                    // but there is definitely not enough free space on it.
                    //

                    CLEAR_CLIENT_SCREEN();
                    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

                    //
                    // We check here to see if this partition is the partition we
                    // booted from (in floppyless case on x86).
                    //
                    // Also make sure we aren't trying to format the drive w/
                    // local source.
                    //
                    // If so, then the
                    // user can't format, and we give a generic 'disk too full'
                    // error.
                    //
                    if( ( region->IsLocalSource )
#ifdef _X86_
                        || ( (IsFloppylessBoot) &&
                             (region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL))) )
#endif
                      ) {
                        SpStartScreen(
                            SP_SCRN_INSUFFICIENT_FREESPACE_NO_FMT,
                            3,
                            HEADER_HEIGHT+1,
                            FALSE,
                            FALSE,
                            DEFAULT_ATTRIBUTE,
                            (RequiredKB / 1024) + 1
                            );

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        SpWaitValidKey(ValidKeys1,NULL,NULL);
                        return FALSE;
                    }
                    //
                    // To use the selected partition, we will have to reformat.
                    // Inform the user of that, and let him decide to bail
                    // right here if this is not acceptable.
                    //
                    PreconfirmFormatId = SP_SCRN_INSUFFICIENT_FREESPACE;
                }
            }

            if(PreconfirmFormatId) {

                //
                // Do a 'preconfirmation' that the user really wants
                // to reformat this drive.  We'll confirm again later
                // before actually reformatting anything.
                //

                SpStartScreen(
                    PreconfirmFormatId,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    (RequiredKB / 1024) + 1
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_C_EQUALS_CONTINUE_SETUP,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    0
                    );

                if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics1) == ASCI_ESC) {

                    //
                    // User decided to select a different partition.
                    //
                    return(FALSE);
                } // otherwise user decided to use the partition anyway.
            }
        }

    } else {

        //
        // The region is a free space. Attempt to create a partition
        // in the space.  The create routine will tell us whether this
        // was successful.  If it was not successful, then the create routine
        // will have already informed the user of why.
        //
        PDISK_REGION p;

        if(!SpPtDoCreate(region,&p,TRUE,0,0,TRUE)) {
            return(FALSE);
        }

        //
        // If we just created an extended partition and a logical drive,
        // we'll need to switch regions -- Region points to the extended partition
        // region, but we want to point to the logical drive region.
        //
        ASSERT(p);
        region = p;
        *Region = p;

        NewlyCreated = TRUE;
    }

    if(NewlyCreated) {
        SpPtRegionDescription(
            &PartitionedDisks[region->DiskNumber],
            region,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        RegionDescr = SpDupStringW(TemporaryBuffer);
    } else {
        RegionDescr = SpDupStringW(RegionDescription);
    }
    
    OtherOSOnPartition = FALSE;
    
    if( SpIsNtOnPartition( region ) )
        OtherOSOnPartition = TRUE;

#ifdef _X86_
    if(!SpIsArc())
    {
        //
        // On an x86 machine, make sure that we have a valid primary partition
        // on drive 0 (C:), for booting.
        //
        if (!IsNEC_98) { //NEC98
            if((systemPartitionRegion = SpPtValidSystemPartition()) == NULL) {

                SpStartScreen(
                    SP_SCRN_NO_VALID_C_COLON,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    HardDisks[SpDetermineDisk0()].Description
                    );

                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                SpWaitValidKey(ValidKeys1,NULL,NULL);

                SpMemFree(RegionDescr);
                return(FALSE);
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(systemPartitionRegion);

            //
            // Warn user about win9x installations on same partition
            //

            if( !OtherOSOnPartition && SpIsWin9xMsdosSys( systemPartitionRegion, &Win9xPath )){
                Win9xPathW = SpToUnicode(Win9xPath);

                if(SpIsWin4Dir(region, Win9xPathW)) {
                    OtherOSOnPartition = TRUE;

                    if (Win9xInstallationPresent) {
                        *Win9xInstallationPresent = TRUE;
                    }                        
                }
                
                SpMemFree(Win9xPathW);
            }
            
            if(Win9xPath) {
                SpMemFree(Win9xPath);
            }   
        } else {
            //
            // All of partition is bootable on NEC98,
            // so we don't need to check system partition on C:.
            //
            systemPartitionRegion = *Region;
        } //NEC98
    }
#endif

    //
    //  Display common warning for other OS on partition
    //
    if( OtherOSOnPartition && !Unattended ){

        SpDisplayScreen(SP_SCRN_OTHEROS_ON_PARTITION,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_C_EQUALS_CONTINUE_SETUP,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics1) == ASCI_ESC) {
            return(FALSE);
        }

        //
        // Remove the boot sets which are already present for
        // this partition in boot.ini, if any. This aids in
        // disabling the other OSes installed on the same
        // partition
        //
        //
        // NOTE : We want to really think about enforcing
        // single installs on a partition, so for the time
        // being disable it
        //
        // SpPtDeleteBootSetsForRegion(region);        
    }

    //
    // At this point, everything is fine, so commit any
    // partition changes the user may have made.
    // This won't return if an error occurs while updating the disk.
    //
    SpPtDoCommitChanges();

    //
    // Attempt to grow the partition the system will be on
    // if necessary.
    //
    if(PreInstall
    && Unattended
    && (p = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,SIF_EXTENDOEMPART,0))
    && (Count = SpStringToLong(p,NULL,10))) {

        //
        // 1 means size it maximally, any other non-0 number means
        // extend by that many MB
        //
        ExtendingOemPartition = SpPtExtend(region,(Count == 1) ? 0 : Count);
    }

#ifdef _X86_
    if(!SpIsArc())
    {
    //
    // On an x86 machine, see whether we need to format C: and if so,
    // go ahead and do it.  If the system is going on C:, then don't
    // bother with this here because it will be covered in the options
    // for the target NT partition.
    //
    if(systemPartitionRegion != region) {

        PWSTR   SysPartRegionDescr;
        BOOLEAN bValidCColon;

        SpPtRegionDescription(
            &PartitionedDisks[systemPartitionRegion->DiskNumber],
            systemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        SysPartRegionDescr = SpDupStringW(TemporaryBuffer);
        bValidCColon = SpPtValidateCColonFormat(SifHandle,
                                                SysPartRegionDescr,
                                                systemPartitionRegion,
                                                FALSE,
                                                SetupSourceDevicePath,
                                                DirectoryOnSetupSource);
        SpMemFree(SysPartRegionDescr);

        if(!bValidCColon) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }
    }
    }else
#endif
    {
    //
    // If we are going to install on the system partition,
    // issue a special warning because it can't be converted to ntfs.
    //
    if((region->IsSystemPartition == 2) && !Unattended) {

        ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };

        SpDisplayScreen(SP_SCRN_INSTALL_ON_SYSPART,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }

        AllowNtfsOptions = FALSE;
    }
    }

    if( SpPtSectorCountToMB( &(HardDisks[region->DiskNumber]),
                             region->SectorCount ) > 32*1024 ) {
        //
        //  If the partition size is greater than 32 GB, then we don't allow Fat formatting,
        //  because Fat32 does not support partitions that are that big.
        //
        AllowFatOptions = FALSE;
    }

    //
    // Present formatting/conversion options to the user.
    //

    //
    // If the partition was newly created, the only option is
    // to format the partition.  Ditto if the partition is
    // a 'bad' partition -- damaged, can't tell free space, etc.
    //
    if(NewlyCreated
    || (region->Filesystem < FilesystemFirstKnown)
    || (region->FreeSpaceKB == (ULONG)(-1))
    || (region->AdjustedFreeSpaceKB < RequiredKB)
    || RemoteBootRepartition)
    {
        if (RemoteBootRepartition) {

            //
            // For remote boot we always quick format as NTFS without
            // prompting the user.
            //

            selection = FormatOptionNtfs;
            QuickFormat = TRUE;

        } else {

            if(NewlyCreated) {

                SpStartScreen(
                    SP_SCRN_FORMAT_NEW_PART,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    HardDisks[region->DiskNumber].Description
                    );

            } else if(region->Filesystem == FilesystemNewlyCreated) {

                SpDisplayScreen(SP_SCRN_FORMAT_NEW_PART2,3,HEADER_HEIGHT+1);

            } else {

                SpStartScreen(
                    SP_SCRN_FORMAT_BAD_PART,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description
                    );
            }

            selection = SpFormattingOptions(
                            AllowFatOptions,
                            AllowNtfsOptions,
                            FALSE,
                            FALSE,
                            TRUE
                            );

        }

        switch(selection) {
        case FormatOptionCancel:
            SpMemFree(RegionDescr);
            return(FALSE);

        default:
            //
            // Format the partition right here and now.
            //
            if ((selection == FormatOptionFatQuick) || (selection == FormatOptionNtfsQuick))
                QuickFormat = TRUE;
                
            Status = SpDoFormat(
                        RegionDescr,
                        region,
                        ((selection == FormatOptionNtfs) || (selection == FormatOptionNtfsQuick)) ? 
                            FilesystemNtfs : FilesystemFat,
                        FALSE,
                        TRUE,
                        QuickFormat,
                        SifHandle,
                        0,          // default cluster size
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource
                        );

            SpMemFree(RegionDescr);
            return(NT_SUCCESS(Status));
        }
    }

    //
    // The partition is acceptable as-is.
    // Options are to reformat to fat or ntfs, or to leave as-is.
    // If it's FAT, converting to ntfs is an option
    // unless we're installing onto an ARC system partition.
    //
    SpStartScreen(
        SP_SCRN_FS_OPTIONS,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RegionDescr,
        HardDisks[region->DiskNumber].Description
        );

    //
    // If this is a winnt installation, don't want to let the user
    // reformat the local source partition!
    //
    // Also, don't let them reformat if this is the partition we booted
    // off of (in x86 floppyless boot case).
    //
    AllowFormatting = !region->IsLocalSource;
#ifdef _X86_
    if(AllowFormatting) {
        AllowFormatting = !(IsFloppylessBoot &&
               (region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL))));
    }
#endif
    selection = SpFormattingOptions(
        (BOOLEAN)(AllowFormatting ? AllowFatOptions : FALSE),
        (BOOLEAN)(AllowFormatting ? AllowNtfsOptions : FALSE),
        (BOOLEAN)(AllowNtfsOptions && (BOOLEAN)(region->Filesystem != FilesystemNtfs)),
        TRUE,
        TRUE
        );

    switch(selection) {

    case FormatOptionDoNothing:
        SpMemFree(RegionDescr);
        return(TRUE);

    case FormatOptionFat:
    case FormatOptionFatQuick:
    case FormatOptionNtfs:
    case FormatOptionNtfsQuick:
        //
        // Confirm the format.
        //
        if( ( region->Filesystem != FilesystemFat ) ||
            ( ( region->Filesystem == FilesystemFat ) &&
              ( ( Count = SpGetNumberOfCompressedDrives( region ) ) == 0 ) )
            ) {

            SpStartScreen(
                SP_SCRN_CONFIRM_FORMAT,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescr,
                HardDisks[region->DiskNumber].Description
                );

        } else {
            SpStartScreen(
                SP_SCRN_CONFIRM_FORMAT_COMPRESSED,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescr,
                HardDisks[region->DiskNumber].Description,
                Count
                );

        }
        
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F_EQUALS_FORMAT,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        Mnemonics2[0] = MnemonicFormat;

        if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics2) == ASCI_ESC) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }

        if  ((selection == FormatOptionNtfsQuick) || (selection == FormatOptionFatQuick))
            QuickFormat = TRUE;
            
        //
        // Format the partition right here and now.
        //
        Status = SpDoFormat(
                    RegionDescr,
                    region,
                    ((selection == FormatOptionNtfs) || (selection == FormatOptionNtfsQuick)) ?
                        FilesystemNtfs : FilesystemFat,
                    FALSE,
                    TRUE,
                    QuickFormat,
                    SifHandle,
                    0,          // default cluster size
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource
                    );

        SpMemFree(RegionDescr);
        return(NT_SUCCESS(Status));

    case FormatOptionCancel:
        SpMemFree(RegionDescr);
        return(FALSE);

    case FormatOptionConvertToNtfs:

        if(!UnattendedOperation) {
            //
            // Confirm that the user really wants to do this.
            //
            if( ( Count = SpGetNumberOfCompressedDrives( region ) ) == 0 ) {

                SpStartScreen(
                    SP_SCRN_CONFIRM_CONVERT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description
                    );

            } else {

                SpStartScreen(
                    SP_SCRN_CONFIRM_CONVERT_COMPRESSED,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description,
                    Count
                    );

            }
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONVERT,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            Mnemonics2[0] = MnemonicConvert;

            if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics2) == ASCI_ESC) {
                SpMemFree(RegionDescr);
                return(FALSE);
            }
        }

        //
        // Remember that we need to convert the NT drive to NTFS.
        //
        ConvertNtVolumeToNtfs = TRUE;
        SpMemFree(RegionDescr);
        return(TRUE);
    }

    //
    // Should never get here.
    //
    SpMemFree(RegionDescr);
    ASSERT(FALSE);
    return(FALSE);
}


ULONG
SpFormattingOptions(
    IN BOOLEAN  AllowFatFormat,
    IN BOOLEAN  AllowNtfsFormat,
    IN BOOLEAN  AllowConvertNtfs,
    IN BOOLEAN  AllowDoNothing,
    IN BOOLEAN  AllowEscape
    )

/*++

Routine Description:

    Present a menu of formatting options and allow the user to choose
    among them.  The text describing the menu must already be present
    on-screen.

    The user may also press escape to indicate that he wants to select
    a different partition.

Arguments:

    AllowFatFormat - TRUE if the option to format the partition to
        FAT should be presented in the menu.

    AllowNtfsFormat - TRUE if the option to format the partition to
        NTFS should be presented in the menu.

    AllowConvertNtfs - TRUE if the option to convert the partition to
        NTFS should be presented in the menu.

    AllowDoNothing - TRUE if the option to leave the partition as-is
        should be presented in the menu.

Return Value:

    Value from the FormatOptions enum indicating the outcome of the
    user's interaction with the menu, which will be FormatOptionCancel
    if the user pressed escape.

--*/

{
    ULONG FatFormatOption = (ULONG)(-1);
    ULONG NtfsFormatOption = (ULONG)(-1);
    ULONG FatQFormatOption = (ULONG)(-1);
    ULONG NtfsQFormatOption = (ULONG)(-1);
    ULONG ConvertNtfsOption = (ULONG)(-1);
    ULONG DoNothingOption = (ULONG)(-1);
    ULONG OptionCount = 0;
    PVOID Menu;
    WCHAR FatQFormatText[128];
    WCHAR NtfsQFormatText[128];
    WCHAR FatFormatText[128];
    WCHAR NtfsFormatText[128];
    WCHAR ConvertNtfsText[128];
    WCHAR DoNothingText[128];
    WCHAR QuickText[128];
    ULONG MaxLength;
    ULONG Key;
    ULONG_PTR Selection;
    BOOLEAN Chosen;
    ULONG ValidKeys[4] = { ASCI_CR, KEY_F3, 0, 0 };

    if (AllowEscape) {
        ValidKeys[2] = ASCI_ESC;
    }        

    //
    // If the only thing we're allowed to do is nothing, just return.
    //
    if(!AllowFatFormat
    && !AllowNtfsFormat
    && !AllowConvertNtfs
    && AllowDoNothing) {

        return(FormatOptionDoNothing);
    }

    //
    // The FileSystem entry might be in the unattend section if we're
    // in unattend mode.  if we aren't in unattend mode, it may be in
    // the data section.
    //
    // If we fail to find it in either place, then if we're unattended
    // we return DoNothing.  If we're attended, fall through to the attended
    // case.
    //
    if( ( UnattendedSifHandle && (Menu = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Filesystem",0)) ) ||
        ( WinntSifHandle && (Menu = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"Filesystem",0)) ) ) {

        if(!_wcsicmp(Menu,L"FormatFat") && AllowFatFormat) {
            return(FormatOptionFat);
        }
        if(!_wcsicmp(Menu,L"FormatNtfs") && AllowNtfsFormat) {
            return(FormatOptionNtfs);
        }
        if(!_wcsicmp(Menu,L"ConvertNtfs") && AllowConvertNtfs) {
            return(FormatOptionConvertToNtfs);
        }
        if( (!_wcsicmp(Menu,L"ConvertNtfs")) &&
            (!AllowConvertNtfs)              &&
            (AllowDoNothing) ) {
            return(FormatOptionDoNothing);
        }
        if(!_wcsicmp(Menu,L"LeaveAlone") && AllowDoNothing) {
            return(FormatOptionDoNothing);
        }
    } else {
        if(UnattendedOperation && AllowDoNothing) {
            return(FormatOptionDoNothing);
        }
    }


    ASSERT(AllowFatFormat || AllowNtfsFormat || AllowConvertNtfs || AllowDoNothing);

    SpFormatMessage(FatFormatText  ,sizeof(FatFormatText),SP_TEXT_FAT_FORMAT);
    SpFormatMessage(NtfsFormatText ,sizeof(FatFormatText),SP_TEXT_NTFS_FORMAT);
    SpFormatMessage(ConvertNtfsText,sizeof(FatFormatText),SP_TEXT_NTFS_CONVERT);
    SpFormatMessage(DoNothingText  ,sizeof(FatFormatText),SP_TEXT_DO_NOTHING);    
    SpFormatMessage(QuickText, sizeof(QuickText), SP_TEXT_FORMAT_QUICK);

    wcscpy(FatQFormatText, FatFormatText);
    wcscat(FatQFormatText, QuickText);

    wcscpy(NtfsQFormatText, NtfsFormatText);
    wcscat(NtfsQFormatText, QuickText);

    //
    // Determine maximum length of the option strings.
    //
    MaxLength = wcslen(FatFormatText);
    MaxLength = max(wcslen(NtfsFormatText), MaxLength);
    MaxLength = max(wcslen(ConvertNtfsText), MaxLength);
    MaxLength = max(wcslen(DoNothingText), MaxLength);
    MaxLength = max(wcslen(FatQFormatText), MaxLength);
    MaxLength = max(wcslen(NtfsQFormatText), MaxLength);

    Menu = SpMnCreate(5,    
                NextMessageTopLine + 1,
                VideoVars.ScreenWidth - 5, 
                6);

    //
    // If we cannot create menu then cancel the formatting
    // request itself
    //
    if (!Menu) {
        return FormatOptionCancel;
    }

#ifdef NEW_PARTITION_ENGINE
    if(AllowNtfsFormat) {
        NtfsQFormatOption = OptionCount++;

        SpMnAddItem(Menu, 
            NtfsQFormatText,
            5,
            MaxLength,
            TRUE,
            NtfsQFormatOption);
    }

    if(AllowFatFormat) {
        FatQFormatOption = OptionCount++;

        SpMnAddItem(Menu,
            FatQFormatText,
            5,
            MaxLength,
            TRUE,
            FatQFormatOption);
    }
#endif    

    if(AllowNtfsFormat) {
        NtfsFormatOption = OptionCount++;

        SpMnAddItem(Menu,
            NtfsFormatText,
            5,
            MaxLength,
            TRUE,
            NtfsFormatOption);
    }

    if(AllowFatFormat) {
        FatFormatOption = OptionCount++;
        
        SpMnAddItem(Menu,
            FatFormatText,
            5,
            MaxLength,
            TRUE,
            FatFormatOption);
    }

    if(AllowConvertNtfs) {
        ConvertNtfsOption = OptionCount++;

        SpMnAddItem(Menu,
            ConvertNtfsText,
            5,
            MaxLength,
            TRUE,
            ConvertNtfsOption);
    }
    
    if(AllowDoNothing) {
        DoNothingOption = OptionCount++;

        SpMnAddItem(Menu,
            DoNothingText,
            5,
            MaxLength,
            TRUE,
            DoNothingOption);
    }

    //
    // Determine the default.
    // If do nothing if an option, then it is the default.
    // Otherwise, if fat format is allowed, it is the default.
    // Otherwise, the first item in the menu is the default.
    //
    if(AllowDoNothing) {
        Selection = DoNothingOption;
    } else {
        if(AllowNtfsFormat) {
            Selection = NtfsFormatOption;
        } else {
            Selection = 0;
        }
    }

    //
    // Display the menu.
    //
    Chosen = FALSE;

    do {

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            AllowEscape ? SP_STAT_ESC_EQUALS_CANCEL : 0,
            0
            );

        SpMnDisplay(Menu,Selection,FALSE,ValidKeys,NULL,NULL,&Key,&Selection);

        switch(Key) {

        case ASCI_CR:
            Chosen = TRUE;
            break;

        case ASCI_ESC:
            if (AllowEscape) {
                SpMnDestroy(Menu);
                return(FormatOptionCancel);
            }                
        }

    } while(!Chosen);

    SpMnDestroy(Menu);

    //
    // Convert chosen option to a meaningful value.
    //
    if(Selection == FatQFormatOption) {
        return(FormatOptionFatQuick);
    }

    if(Selection == NtfsQFormatOption) {
        return(FormatOptionNtfsQuick);
    }
    

    if(Selection == FatFormatOption) {
        return(FormatOptionFat);
    }

    if(Selection == NtfsFormatOption) {
        return(FormatOptionNtfs);
    }

    if(Selection == ConvertNtfsOption) {
        return(FormatOptionConvertToNtfs);
    }
    
    if(Selection == DoNothingOption) {
        return(FormatOptionDoNothing);
    }
    
    ASSERT(FALSE);
    return(FormatOptionCancel);
}

VOID
SpPtDoCommitChanges(
    VOID
    )
{
    NTSTATUS Status;
    ULONG i;
    BOOLEAN Changes;
    BOOLEAN AnyChanges = FALSE;

    CLEAR_CLIENT_SCREEN();

    //
    //  Update dblspace.ini, if necessary
    //
    SpUpdateDoubleSpaceIni();

    //
    // Iterate through the disks.
    //
    for(i=0; i<HardDiskCount; i++) {

        //
        // Tell the user what we're doing.
        // This is useful because if it hangs, there will be an
        // on-screen record of which disk we were updating.
        //
        SpDisplayStatusText(
            SP_STAT_UPDATING_DISK,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[i].Description
            );

        //
        // Commit any changes on this disk.
        //
        Status = SpPtCommitChanges(i,&Changes);

        //
        // If there were no changes, then we better have success.
        //
        ASSERT(NT_SUCCESS(Status) || Changes);
        if(Changes) {
            AnyChanges = TRUE;
        }

        //
        // Fatal error if we can't update the disks with
        // the new partitioning info.
        //
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDoCommitChanges: status %lx updating disk %u\n",Status,i));
            FatalPartitionUpdateError(HardDisks[i].Description);
        }
    }
}


VOID
FatalPartitionUpdateError(
    IN PWSTR DiskDescription
    )
{
    ULONG ValidKeys[2] = { KEY_F3,0 };

    while(1) {

        SpStartScreen(
            SP_SCRN_FATAL_FDISK_WRITE_ERROR,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            DiskDescription
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
            break;
        }
    }

    SpDone(0,FALSE,TRUE);
}


NTSTATUS
SpDoFormat(
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN ULONG        FilesystemType,
    IN BOOLEAN      IsFailureFatal,
    IN BOOLEAN      CheckFatSize,
    IN BOOLEAN      QuickFormat,
    IN PVOID        SifHandle,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    )
{
    NTSTATUS Status;
    ULONGLONG RegionSizeMB;
    ULONG ValidKeys2[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    LONG Key;

    ASSERT( (FilesystemType == FilesystemFat)  ||
            (FilesystemType == FilesystemNtfs) ||
            (FilesystemType == FilesystemFat32));

    //
    // Under normal conditions, setup switches to Fat32 if the partition is big
    // enough (2GB as the cutoff). Before plowing ahead, though, we warn
    // the user that the drive will not be compatible with MS-DOS/Win95, etc.
    //

    if(FilesystemType == FilesystemFat) {
        RegionSizeMB = SpPtSectorCountToMB(
                            &(HardDisks[Region->DiskNumber]),
                            Region->SectorCount
                            );

        if(RegionSizeMB > 2048) {
            if(CheckFatSize) {
                do {
                    SpStartScreen(
                        SP_SCRN_OSPART_LARGE,
                        3,
                        HEADER_HEIGHT+1,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE
                        );

                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_CONTINUE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

                    switch(Key = SpWaitValidKey(ValidKeys2,NULL,NULL)) {
                    case KEY_F3:
                        SpConfirmExit();
                        break;
                    case ASCI_ESC:
                        return(STATUS_UNSUCCESSFUL);
                    }
                } while(Key != ASCI_CR);
            }
            FilesystemType = FilesystemFat32;
        }
    }

    AutofrmtRunning = TRUE;
    
    Status = SpRunAutoFormat(
                SifHandle,
                RegionDescr,
                Region,
                FilesystemType,
                QuickFormat,
                ClusterSize,
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );

    AutofrmtRunning = FALSE;                

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to format (%lx)\n",Status));

        if(IsFailureFatal) {
            //
            // Then we can't continue (this means that the system partition
            // couldn't be formatted).
            //

            WCHAR   DriveLetterString[2];

            DriveLetterString[0] = Region->DriveLetter;
            DriveLetterString[1] = L'\0';
            SpStringToUpper(DriveLetterString);
            SpStartScreen(SP_SCRN_SYSPART_FORMAT_ERROR,
                          3,
                          HEADER_HEIGHT+1,
                          FALSE,
                          FALSE,
                          DEFAULT_ATTRIBUTE,
                          DriveLetterString
                          );
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);

        } else {
            //
            // Put up an error screen.
            //
            SpDisplayScreen(SP_SCRN_FORMAT_ERROR,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;

            return(Status);
        }
    } else {
        //
        //      Partition was successfuly formatted.
        //      Save the file system type on the region description.
        //
        Region->Filesystem = FilesystemType;
        SpFormatMessage( Region->TypeName,
                         sizeof(Region->TypeName),
                         SP_TEXT_FS_NAME_BASE + Region->Filesystem );
        //
        //  Reset the volume label
        //
        Region->VolumeLabel[0] = L'\0';

        // Clean up boot.ini entries that referred to this partition

        SpRemoveInstallationFromBootList(
            NULL,
            Region,
            NULL,
            NULL,
            NULL,
            PrimaryArcPath,
            NULL
            );

#ifdef _X86_
        // call again to delete the secondary Arc name
        SpRemoveInstallationFromBootList(
            NULL,
            Region,
            NULL,
            NULL,
            NULL,
            SecondaryArcPath,
            NULL
            );
#endif
    }

    return(STATUS_SUCCESS);
}

//
// dummy entry points for the cmd console
//

VOID
SpDetermineOsTypeFromBootSectorC(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    )
{
#ifdef _X86_
    SpDetermineOsTypeFromBootSector(
        CColonPath,
        BootSector,
        OsDescription,
        IsNtBootcode,
        IsOtherOsInstalled,
        DriveLetter
        );
#else
    *OsDescription = NULL;
    *IsNtBootcode = FALSE;
    *IsOtherOsInstalled = FALSE;
    return;
#endif
}

NTSTATUS
pSpBootCodeIoC(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN OUT PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    )
{
#ifdef _X86_
    return pSpBootCodeIo(
        FilePath,
        AdditionalFilePath,
        BytesToRead,
        Buffer,
        OpenDisposition,
        Write,
        Offset,
        BytesPerSector
        );
#else
    return STATUS_NOT_IMPLEMENTED;
#endif
}


#ifdef OLD_PARTITION_ENGINE

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    Make a partition active and make sure all other primary partitions
    are inactive.  The partition must be on disk 0.

    If a region is found active that is not the region we want to be active,
    tell the user that his other operating system will be disabled.

    NOTE: Any changes made here are not committed automatically!

Arguments:

    Region - supplies disk region descriptor for the partition to activate.
        This region must be on disk 0.

Return Value:

    None.

--*/

{
    ULONG i;
    static BOOLEAN WarnedOtherOs = FALSE;

    ASSERT(Region->DiskNumber == SpDetermineDisk0());
    if(Region->DiskNumber != SpDetermineDisk0()) {
        return;
    }

    //
    // Make sure the system partition is active and all others are inactive.
    // If we find Boot Manager, present a warning that we are going to disable it.
    // If we find some other operating system is active, present a generic warning.
    //
    for(i=0; i<PTABLE_DIMENSION; i++) {

        PON_DISK_PTE pte = &PartitionedDisks[Region->DiskNumber].MbrInfo.OnDiskMbr.PartitionTable[i];

        if(pte->ActiveFlag) {

            //
            // If this is not the region we want to be the system partition,
            // then investigate its type.
            //
            if(i != Region->TablePosition) {

                //
                // If this is boot manager, give a specific warning.
                // Otherwise, give a general warning.
                //
                if(!WarnedOtherOs && !UnattendedOperation) {

                    SpDisplayScreen(
                        (pte->SystemId == 10) ? SP_SCRN_BOOT_MANAGER : SP_SCRN_OTHER_OS_ACTIVE,
                        3,
                        HEADER_HEIGHT+1
                        );

                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);

                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;

                    WarnedOtherOs = TRUE;
                }
            }
        }
    }

    ASSERT(Region->PartitionedSpace);
    ASSERT(Region->TablePosition < PTABLE_DIMENSION);
    SpPtMarkActive(Region->TablePosition);
}

#endif


BOOLEAN
SpPtValidateCColonFormat(
    IN PVOID        SifHandle,
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN BOOLEAN      CheckOnly,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    )

/*++

Routine Description:

    Inspect C: to make sure it is formatted with a filesystem we
    recognize, and has enough free space on it for the boot files.

    If any of these tests fail, tell the user that we will have to
    reformat C: to continue, and give the option of returning to the
    partitioning screen or continuing anyway.

    If the user opts to continue, then format the partition to FAT
    before returning.

Arguments:

    SifHandle - supplies handle to txtsetup.sif.  This is used to fetch the
        value indicating how much space is required on C:.

    Region - supplies disk region descriptor for C:.

Return Value:

    TRUE if, upon returning from this routine, C: is acceptable.
    FALSE if not, which could mean that the user asked us not
    to format his C:, or that the format failed.

--*/

{
    ULONG MinFreeKB;
    ULONG ValidKeys[3] = { ASCI_ESC, KEY_F3, 0 };
    ULONG ValidKeys3[2] = { KEY_F3, 0 };
    ULONG ValidKeys4[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    ULONG Mnemonics[2] = { MnemonicFormat,0 };
    ULONG Key;
    BOOLEAN Confirm;
    BOOLEAN Fat32;
    NTSTATUS Status;
    ULONGLONG RegionSizeMB;
    WCHAR DriveLetterString[2];
    BOOLEAN QuickFormat = TRUE;
    ULONG FileSystem = FilesystemFat;
    BOOLEAN AllowFat = FALSE;

    //
    // Initialize the drive letter string, to be used in the various error messages
    //
    DriveLetterString[0] = Region->DriveLetter;
    DriveLetterString[1] = L'\0';
    SpStringToUpper(DriveLetterString);

    //
    // Get the minimum free space required for C:.
    //
    SpFetchDiskSpaceRequirements( SifHandle,
                                  Region->BytesPerCluster,
                                  NULL,
                                  &MinFreeKB );

  d1:
    //
    // If the user newly created the C: drive, no confirmation is
    // necessary.
    //
    if(Region->Filesystem == FilesystemNewlyCreated) {
        //
        // Shouldn't be newly created if we're checking
        // to see whether we should do an upgrade, because we
        // haven't gotten to the partitioning screen yet.
        //
        ASSERT(!CheckOnly);
        Confirm = FALSE;

    //
    // If we don't know the filesystem on C: or we can't determine the
    // free space, then we need to format the drive, and will confirm first.
    //
    } else if((Region->Filesystem == FilesystemUnknown) || (Region->FreeSpaceKB == (ULONG)(-1))) {
        if(CheckOnly) {
            return(FALSE);
        }
        SpStartScreen(SP_SCRN_C_UNKNOWN,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString
                      );
        Confirm = TRUE;

    //
    // If C: is too full, then we need to format over it.
    // Confirm first.
    //
    } else if(Region->FreeSpaceKB < MinFreeKB) {

        if(CheckOnly) {
            return(FALSE);
        }

        //
        // If this is a floppyless boot, then the user (probably) cannot
        // format, and has no choice but to exit Setup and free some space.
        //
        if( IsFloppylessBoot &&
           (Region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL)))) {
            SpStartScreen(
                SP_SCRN_C_FULL_NO_FMT,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                MinFreeKB,
                DriveLetterString
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpWaitValidKey(ValidKeys3,NULL,NULL);
            SpDone(0,FALSE,TRUE);
        }

        Confirm = TRUE;
        SpStartScreen(
            SP_SCRN_C_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            MinFreeKB,
            DriveLetterString
            );

    //
    // If all of the above tests fail, then the partition is acceptable as-is.
    //
    } else {
        return(TRUE);
    }

    //
    // If we are supposed to confirm, then do that here, forcing the
    // user to press F if he really wants to format or esc to bail.
    //
    if(Confirm) {

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F_EQUALS_FORMAT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case KEY_F3:

            SpConfirmExit();
            goto d1;

        case ASCI_ESC:

            //
            // User bailed.
            //
            return(FALSE);

        default:
            //
            // Must be F.
            //
            break;
        }
    }

    //
    // Whistler formats only 32GB Fat32 partitions
    //
    AllowFat = (SPPT_REGION_FREESPACE_GB(Region) <= 32);        

    //
    // Prompt the user for the formatting options
    //
    if (!UnattendedOperation) {
        ULONG Selection;

        SpDisplayScreen(SP_SCRN_FORMAT_NEW_PART3, 3, HEADER_HEIGHT+1);        

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            0);
            
        Selection = SpFormattingOptions(
                        AllowFat,
                        TRUE,
                        FALSE,
                        FALSE,
                        TRUE);
                        
        if ((Selection != FormatOptionFatQuick) &&
            (Selection != FormatOptionNtfsQuick)) {
            QuickFormat = FALSE;
        }

        if ((Selection == FormatOptionNtfs) ||
            (Selection == FormatOptionNtfsQuick)) {
            FileSystem = FilesystemNtfs;            
        }

        if (Selection == FormatOptionCancel) {
            return FALSE;   // user bailed out
        }
    } 

    if (!AllowFat && ((FileSystem == FilesystemFat) ||
            (FileSystem == FilesystemFat32))) {
        FileSystem = FilesystemNtfs;            
    }            

    if (FileSystem == FilesystemFat) {
        //
        // If the partition is larger than 2048MB then we want to make it
        // Fat32. Ask the user first.
        //
        Fat32 = FALSE;
        RegionSizeMB = SpPtSectorCountToMB(
                            &(HardDisks[Region->DiskNumber]),
                            Region->SectorCount
                            );

        if(RegionSizeMB > 2048) {

            do {
                SpStartScreen(
                    SP_SCRN_C_LARGE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    DriveLetterString
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                switch(Key = SpWaitValidKey(ValidKeys4,NULL,NULL)) {
                case KEY_F3:
                    SpConfirmExit();
                    break;
                case ASCI_ESC:
                    return(FALSE);
                }
            } while(Key != ASCI_CR);

            Fat32 = TRUE;
        }

        FileSystem = Fat32 ? FilesystemFat32 : FilesystemFat;
    }        

    if(!Confirm) {
        //
        // Just put up an information screen so the user doesn't
        // go bonkers when we just start formatting his newly created C:.
        //
        SpStartScreen(SP_SCRN_ABOUT_TO_FORMAT_C,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString
                      );
                      
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpInputDrain();
        
        while(SpInputGetKeypress() != ASCI_CR) ;
    }
    

    //
    // Do the format.
    //
    Status = SpDoFormat(
                RegionDescr,
                Region,
                FileSystem,
                TRUE,
                FALSE,
                QuickFormat,
                SifHandle,
                0,          // default cluster size
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );
                
    if(NT_SUCCESS(Status)) {
        //
        // At this point we must initialize the available free space on the partition. Otherwise,
        // SpPtValidateCColonFormat() will not recognized this partition, if it is called again.
        // This can happen if the user decides not format the partition (newly created or unformatted),
        // that he initially selected as the target partition.
        //
        SpPtDetermineRegionSpace(Region);
    }

    return(NT_SUCCESS(Status));
}

//#ifdef _X86_


#ifndef NEW_PARTITION_ENGINE

PDISK_REGION
SpPtValidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.
    If there is a partition that meets these criteria that is marked active,
    then it is the system partition, regardless of whether there are other
    partitions that also meet the criteria.

Arguments:

    None.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition (C:)
    for an x86 machine.
    NULL if no such partition currently exists.

--*/

{
    PON_DISK_PTE pte;
    PDISK_REGION pRegion,pActiveRegion,pFirstRegion;
    ULONG DiskNumber;
    
    pActiveRegion = NULL;
    pFirstRegion = NULL;

    DiskNumber = SpDetermineDisk0();

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( DiskNumber == (ULONG)-1 ) {
        return NULL;
    }
#endif // defined(REMOTE_BOOT)

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(DiskNumber)) {
        return SpPtnValidSystemPartition();
    }        
#endif        
        
    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    for(pRegion=PartitionedDisks[DiskNumber].PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

        if(pRegion->PartitionedSpace) {
            UCHAR   TmpSysId;

            ASSERT(pRegion->TablePosition < PTABLE_DIMENSION);

            pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];
            ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);

            //
            // Skip if not recognized.
            // In the repair case, we recognize FT partitions
            //
            TmpSysId = pte->SystemId;
            if( !IsContainerPartition(TmpSysId)
                && ( (PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) ||
                     (pRegion->DynamicVolume && pRegion->DynamicVolumeSuitableForOS) ||
                     ((RepairWinnt || WinntSetup || SpDrEnabled() ) && pRegion->FtPartition )
                   )
              )
            {
                //
                // Remember it if it's active.
                //
                if((pte->ActiveFlag) && !pActiveRegion) {
                    pActiveRegion = pRegion;
                }

                //
                // Remember it if it's the first one we've seen.
                //
                if(!pFirstRegion) {
                    pFirstRegion = pRegion;
                }
            }
        }
    }

    //
    // If there is an active, recognized region, use it as the
    // system partition.  Otherwise, use the first primary
    // we encountered as the system partition.  If there is
    // no recognized primary, then there is no valid system partition.
    //
    return(pActiveRegion ? pActiveRegion : pFirstRegion);
}

#endif // ! NEW_PARTITION_ENGINE


ULONG
SpDetermineDisk0(
    VOID
    )

/*++

Routine Description:

    Determine the real disk 0, which may not be the same as \device\harddisk0.
    Consider the case where we have 2 scsi adapters and
    the NT drivers load in an order such that the one with the BIOS
    gets loaded *second* -- meaning that the system partition is actually
    on disk 1, not disk 0.

Arguments:

    None.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

--*/


{
    ULONG   DiskNumber = (ULONG)-1;
    ULONG   CurrentDisk = 0;
    WCHAR   ArcDiskName[MAX_PATH];

    //
    // Find the first harddisk (non-removable) media that the 
    // BIOS enumerated to be used for system partition
    //
    while (CurrentDisk < HardDiskCount) {
        swprintf(ArcDiskName, L"multi(0)disk(0)rdisk(%d)", CurrentDisk);       
        DiskNumber = SpArcDevicePathToDiskNumber(ArcDiskName);        

        if (DiskNumber != (ULONG)-1) {
            if (!SPPT_IS_REMOVABLE_DISK(DiskNumber)) {
                break;
            } else {
                DiskNumber = (ULONG)-1;
            }                
        }
        
        CurrentDisk++;            
    }
    
#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( RemoteBootSetup && (DiskNumber == (ULONG)-1) && (HardDiskCount == 0) ) {
        return DiskNumber;
    }
#endif // defined(REMOTE_BOOT)

    return  (DiskNumber == (ULONG)-1) ? 0 : DiskNumber;
}


#ifdef OLD_PARTITION_ENGINE

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
/*++

Routine Description:

    Determine whether the active partition is suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.

Arguments:

    None.

Return Value:

    TRUE - We found a suitable partition

    FALSE - We didn't find a suitable partition

--*/

{
    PON_DISK_PTE pte;
    PDISK_REGION pRegion;
    ULONG DiskNumber;

    //
    // Any partitions on NEC98 are primary and active. So don't need to check on NEC98.
    //
    if( IsNEC_98 ) {
	return TRUE;
    }

    DiskNumber = SpDetermineDisk0();

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    for(pRegion=PartitionedDisks[DiskNumber].PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

        pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];

        if( (pRegion->PartitionedSpace) &&
            (pte->ActiveFlag) ) {
            //
            // We've hit the active partition.  Check its format.
            //
            if( (pRegion->Filesystem == FilesystemNtfs) ||
                (pRegion->Filesystem == FilesystemFat)  ||
                (pRegion->Filesystem == FilesystemFat32) ) {
                //
                // We recognize him.
                //
                return TRUE;
            }
        }
    }

    //
    // If we get here, we didn't find any active partitions
    // we recognize.
    //
    return FALSE;
}


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an ARC machine.

    A partition is suitable if it is marked as a system partition in nvram,
    has the required free space and is formatted with the FAT filesystem.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition.
    Does not return if no such partition exists.

--*/

{
    ULONG RequiredSpaceKB = 0;
    ULONG disk,pass;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;

    //
    // Go through all the regions.  The first one that has enough free space
    // and is of the required filesystem becomes *the* system partition.
    //
    for(disk=0; disk<HardDiskCount; disk++) {

        pDisk = &PartitionedDisks[disk];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {

                if(pRegion->IsSystemPartition
                && (pRegion->FreeSpaceKB != (ULONG)(-1))
                && (pRegion->Filesystem == FilesystemFat))
                {
                    ULONG TotalSizeOfFilesOnOsWinnt;

                    //
                    //  On non-x86 platformrs, specially alpha machines that in general
                    //  have small system partitions (~3 MB), we should compute the size
                    //  of the files on \os\winnt (currently, osloader.exe and hall.dll),
                    //  and consider this size as available disk space. We can do this
                    //  since these files will be overwritten by the new ones.
                    //  This fixes the problem that we see on Alpha, when the system
                    //  partition is too full.
                    //

                    SpFindSizeOfFilesInOsWinnt( SifHandle,
                                                pRegion,
                                                &TotalSizeOfFilesOnOsWinnt );
                    //
                    // Transform the size into KB
                    //
                    TotalSizeOfFilesOnOsWinnt /= 1024;

                    //
                    // Determine the amount of free space required on a system partition.
                    //
                    SpFetchDiskSpaceRequirements( SifHandle,
                                                  pRegion->BytesPerCluster,
                                                  NULL,
                                                  &RequiredSpaceKB );

                    if ((pRegion->FreeSpaceKB + TotalSizeOfFilesOnOsWinnt) >= RequiredSpaceKB) {
                       return(pRegion);
                    }
                }
            }
        }
    }

    //
    // Make sure we don't look bad.
    //
    if( RequiredSpaceKB == 0 ) {
        SpFetchDiskSpaceRequirements( SifHandle,
                                      (32 * 1024),
                                      NULL,
                                      &RequiredSpaceKB );
    }

    //
    // No valid system partition.
    //
    SpStartScreen(
        SP_SCRN_NO_SYSPARTS,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RequiredSpaceKB
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3) ;

    SpDone(0,FALSE,TRUE);

    //
    // Should never get here, but it keeps the compiler happy
    //

    return NULL;

}

#endif // OLD_PARTITION_ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppart3.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sppart3.c

Abstract:

    Partitioning module for disks in textmode setup.

    Contains functions that initialize the in memory data structures,
    representing the extents on the disk.    

Author:

    Matt Holle (matth) 1-December-1999

Revision History:

    Vijay Jayaseelan (vijayj) 2-April-2000
        -   Clean up
        -   Added lookup and prompting for system partition on 
            ARC systems
        -   Added on disk ordinals for MBR disks            

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>
#include <diskguid.h>
#include <oemtypes.h>
#include "sppart3.h"

#define         MAX_NTPATH_LENGTH   (2048)
#define         SUGGESTED_SYSTEMPARTIION_SIZE_MB (100)
#define         SUGGESTED_INSTALL_PARTITION_SIZE_MB (4*1024)

extern BOOLEAN ConsoleRunning;
extern BOOLEAN ForceConsole;

//
// Debugging Macros
//

//#define PERF_STATS  1
//#define TESTING_SYSTEM_PARTITION 1


NTSTATUS
SpPtnInitializeDiskDrive(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Initializes the in memory disk region structures for
    the given disk number.

Arguments:

    DiskId  :   Disk ID

Return Value:

    STATUS_SUCCESS if successful otherwise appropriate
    error code

--*/    
{
    NTSTATUS    Status;


#ifdef PERF_STATS
    LARGE_INTEGER   StartTime, EndTime;
    ULONGLONG       Diff;

    KeQuerySystemTime(&StartTime);
#endif

    //
    // Send the event
    //
    SendSetupProgressEvent(PartitioningEvent, ScanDiskEvent, &DiskId);
    
    //
    // It would have been better to just have a pointer to a list
    // of PDISK_REGIONs off of HARD_DISK, but for some reason, someone
    // long ago decided to also maintain a list of PARTITIONED_DISK, which
    // *does* contain a list of PDISK_REGIONs.  I'm not sure of the use
    // of maintaining both HARD_DISKs and PARTITIONED_DISKs, but that's
    // the way the data structures are set, so we'll use those.
    //
    // But it doesn't end there.  Rather than assuming that HardDisk[i]
    // is describing the same disk as PartitionedDisks[i], we'll
    // keep a pointer out of PartitionedDisks[i] that points to the
    // corresponding HardDisk entry.  Oh well...
    //
    PartitionedDisks[DiskId].HardDisk = &HardDisks[DiskId];

    //
    // Initialize structures that are based on the partition tables.
    //
    Status = SpPtnInitializeDiskAreas(DiskId);

    //
    // Now we need to fill in additional Region structures
    // to represent empty space on the disk.  For example, assume
    // we have 2 partitions on the disk, but there's empty space
    // in between:
    // partition1: 0 - 200 sectors
    // <empty space>
    // partition2: 500 - 1000 sectors
    //
    // I need to create another Region structure to represent
    // this empty space (ensuring that it's marked as unpartitioned.
    // This will allow me to present a nice UI to the user when it's
    // time to ask for input.
    //

    //
    // Sort the Partitions based on their location on the disk.
    //
    if( NT_SUCCESS(Status) ) {
        Status = SpPtnSortDiskAreas(DiskId);
        
        //
        // Create place holders for all empty spaces on the disk.
        //
        if( NT_SUCCESS(Status) ) {    
            Status = SpPtnFillDiskFreeSpaceAreas(DiskId);

            if (NT_SUCCESS(Status)) {
                //
                // Mark logical drive's and its container, if any.
                //
                Status = SpPtnMarkLogicalDrives(DiskId);
            }
        }
    }

#ifdef PERF_STATS
    KeQuerySystemTime(&EndTime);
    
    Diff = EndTime.QuadPart - StartTime.QuadPart;
    Diff /= 1000000;

    KdPrint(("SETUP:SpPtInitializeDiskDrive(%d) took %I64d Secs\n",
            DiskId,
            Diff));    
#endif

    SpPtDumpDiskDriveInformation(TRUE);
    
    return Status;
}

NTSTATUS
SpPtnInitializeDiskDrives(
    VOID
    )
/*++

Routine Description:

    Initializes all the disk drive's in memory data structure
    representing the disk regions (extents)

Arguments:

    None

Return Value:

    STATUS_SUCCESS if successful other wise appropriate error
    code.

--*/    
{
    ULONG       disk;
    NTSTATUS    Status = STATUS_SUCCESS;
    NTSTATUS    ErrStatus = STATUS_SUCCESS;      

    //
    // If there are no hard disks, bail now.
    //
    if(!HardDiskCount) {

#if defined(REMOTE_BOOT)
        //
        // If this is a diskless remote boot setup, it's OK for there to be
        // no hard disks. Otherwise, this is a fatal error.
        //
        if (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
        {
            SpDisplayScreen(SP_SCRN_NO_HARD_DRIVES,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();

            while(SpInputGetKeypress() != KEY_F3);

            SpDone(0,FALSE,TRUE);
        }
        
        return STATUS_SUCCESS;
    }

    CLEAR_CLIENT_SCREEN();

    //
    // Initialize all the RAW disks to platform specific
    // default disk styles
    // 
    for(disk=0, Status = STATUS_SUCCESS; 
        (disk < HardDiskCount); 
        disk++) {        

        if (SPPT_IS_RAW_DISK(disk) && SPPT_IS_BLANK_DISK(disk)) {
            PHARD_DISK HardDisk = SPPT_GET_HARDDISK(disk);
            PARTITION_STYLE Style = SPPT_DEFAULT_PARTITION_STYLE;

            //
            // Removable Media are always MBR (so don't bother)
            //
            if (HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {
                continue;
            }                            
            
            Status = SpPtnInitializeDiskStyle(disk, 
                        Style,
                        NULL);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                    "SETUP:SpPtnInitializeDiskStyle(%d) failed with"
                    " %lx \n",
                    disk,
                    Status));
            }
        }                        
    }        


    //
    // Allocate an array for the partitioned disk descriptors.
    //
    PartitionedDisks = SpMemAlloc(HardDiskCount * sizeof(PARTITIONED_DISK));

    if(!PartitionedDisks) {
        return(STATUS_NO_MEMORY);
    }

    RtlZeroMemory( PartitionedDisks, HardDiskCount * sizeof(PARTITIONED_DISK) );

    //
    // Unlock the floppy if we booted off the ls-120 media
    //
    SpPtnUnlockDevice(L"\\device\\floppy0");

    //
    // Collect information about each partition.
    //
    for(disk=0, Status = ErrStatus = STATUS_SUCCESS; 
        (disk < HardDiskCount); 
        disk++) {
        
        //
        // Initialize the region structure for the given
        // disk
        //
        Status = SpPtnInitializeDiskDrive(disk);           

        //
        // TBD - In remote boot case the disk needs to have
        // a valid signature. I am assuming that setupldr
        // would have stamped the signature when booting off
        // the harddisk
        // 

        //
        // Save of the last error
        //
        if (!NT_SUCCESS(Status))
            ErrStatus = Status;
    }

#if defined(_IA64_)
    //
    // Go and figure out the ESP partitions and
    // initialize the MSR partitions on valid GPT
    // disks
    //
    if (SpIsArc() && !SpDrEnabled()) {    
        if (!ValidArcSystemPartition) {
            //
            // Create a system partition
            //
            Status = SpPtnCreateESP(TRUE);                    
        }            

        //
        // Initialize the GPT disks, to have MSR
        // partition
        //
        Status = SpPtnInitializeGPTDisks();
    }
#endif    

    return  ErrStatus;
}



NTSTATUS
SpPtnInitializeDiskAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Examine the disk for partitioning information and fill in our
    partition descriptors.

    We'll ask the volume manager for a list of partitions and fill
    in our descriptors from the information he provided us.


Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect for determining their types.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDRIVE_LAYOUT_INFORMATION_EX   DriveLayoutEx;
    WCHAR           DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    HANDLE          Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    PDISK_REGION    pDiskRegion = NULL;
    PFILE_FS_ATTRIBUTE_INFORMATION  pFSInfo = NULL;
    PFILE_FS_SIZE_INFORMATION       pSizeInfo = NULL;
    PFILE_FS_VOLUME_INFORMATION     pLabelInfo = NULL;
    PWCHAR          MyTempBuffer = NULL;
    ULONG           DriveLayoutSize,
                    i,
                    r;
    PWSTR           LocalSourceFiles[1] = { LocalSourceDirectory };
    PHARD_DISK          Disk = NULL;
    PPARTITIONED_DISK   PartDisk = NULL;
    ULONGLONG           *NewPartitions = NULL;
    ULONG               NewPartitionCount;
    
    Disk = SPPT_GET_HARDDISK(DiskNumber);
    PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    
    //
    // Give the user some indication of what we're doing.
    //
    SpDisplayStatusText( SP_STAT_EXAMINING_DISK_N,
                         DEFAULT_STATUS_ATTRIBUTE,
                         Disk->Description);

    //
    // If we are updating the local source region disk then
    // make sure we invalidate LocalSourceRegion
    //
    if (LocalSourceRegion && (LocalSourceRegion->DiskNumber == DiskNumber)) {
        LocalSourceRegion = NULL;
    }

    //
    // Save off the new partitions created 
    //
    NewPartitionCount = SpPtnCountPartitionsByFSType(DiskNumber, 
                            FilesystemNewlyCreated);                            

    if (NewPartitionCount) {
        PDISK_REGION    NewRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ULONG           Index;
        
        NewPartitions = (PULONGLONG) SpMemAlloc(sizeof(ULONGLONG) * NewPartitionCount);

        if (!NewPartitions) {
            return STATUS_NO_MEMORY;
        }
        
        RtlZeroMemory(NewPartitions, sizeof(ULONGLONG) * NewPartitionCount);

        Index = 0;
        
        while (NewRegion && (Index < NewPartitionCount)) {
            if (SPPT_IS_REGION_PARTITIONED(NewRegion) && 
                !SPPT_IS_REGION_MARKED_DELETE(NewRegion) &&
                (NewRegion->Filesystem == FilesystemNewlyCreated)) {
                
                NewPartitions[Index] = NewRegion->StartSector;
                Index++;
            }
            
            NewRegion = NewRegion->Next;
        }
    }
    
    //
    // Free the old regions we allocated, if there are any
    //
    SpPtnFreeDiskRegions(DiskNumber);
    
    //
    // ============================
    //
    // Open a handle to this hard disk
    //
    // ============================
    //

    //
    // Create a device path (NT style!) that will describe this disk.  This
    // will be of the form: \Device\Harddisk0
    //
    swprintf( DevicePath,
              L"\\Device\\Harddisk%u",
              DiskNumber );

    //
    // Open partition 0 on this disk..
    //
    Status = SpOpenPartition0( DevicePath,
                               &Handle,
                               FALSE );

    if(!NT_SUCCESS(Status)) {

        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: unable to open partition0 on device %ws (%lx)\n",
                    DevicePath,
                    Status ));

        if (NewPartitions) {
            SpMemFree(NewPartitions);
        }

        return( Status );
    }
    
    //
    // ============================
    //
    // Load the drive layout information.
    //
    // ============================
    //

    //
    // Get the disk's layout information.  We aren't
    // sure how big of a buffer we need, so brute-force it.
    //
    DriveLayoutSize = 0;
    DriveLayoutEx = NULL;
    Status = STATUS_BUFFER_TOO_SMALL;

    while ((Status == STATUS_BUFFER_TOO_SMALL) || 
           (Status == STATUS_BUFFER_OVERFLOW)) {

        if (DriveLayoutEx)
            SpMemFree(DriveLayoutEx);

        DriveLayoutSize += 1024;
        DriveLayoutEx = SpMemAlloc( DriveLayoutSize );
        
        if(!DriveLayoutEx) {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

            if (NewPartitions) {
                SpMemFree(NewPartitions);
            }
            
            return  (STATUS_NO_MEMORY);
        }

        RtlZeroMemory( DriveLayoutEx, DriveLayoutSize );

        //
        // Attempt to get the disk's partition information.
        //
        Status = ZwDeviceIoControlFile( Handle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                        NULL,
                                        0,
                                        DriveLayoutEx,
                                        DriveLayoutSize );
    }                                        

    if(!NT_SUCCESS(Status)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
              "SETUP: SpPtInitializeDiskAreas: unable to query IOCTL_DISK_GET_DRIVE_LAYOUT_EX on device %ws (%lx)\n",
              DevicePath,
              Status ));

        if (NewPartitions) {
            SpMemFree(NewPartitions);
        }

        if (DriveLayoutEx)
            SpMemFree(DriveLayoutEx);

        if (Handle != INVALID_HANDLE_VALUE)
            ZwClose(Handle);

        return ( Status );
    }

    //
    // What kind of disk is this?
    //
    switch (DriveLayoutEx->PartitionStyle) {
        case PARTITION_STYLE_GPT:
            Disk->FormatType = DISK_FORMAT_TYPE_GPT;

            break;
            
        case PARTITION_STYLE_MBR:
            Disk->FormatType = DISK_FORMAT_TYPE_PCAT;
            Disk->Signature = DriveLayoutEx->Mbr.Signature;

#if defined(_IA64_)            
            //
            // Make sure that this is not a raw disk
            // which is being faked as MBR disk
            //
            if (SpPtnIsRawDiskDriveLayout(DriveLayoutEx)) {
                Disk->FormatType = DISK_FORMAT_TYPE_RAW;
                SPPT_SET_DISK_BLANK(DiskNumber, TRUE);
            }
#endif

            break;
            
        case PARTITION_STYLE_RAW:
            Disk->FormatType = DISK_FORMAT_TYPE_RAW;
            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);

            break;

        default:
            Disk->FormatType = DISK_FORMAT_TYPE_UNKNOWN;

            break;            
    }

    SpAppendDiskTag(Disk);

    SpPtDumpDriveLayoutInformation(DevicePath, DriveLayoutEx);
    
    //
    // Don't need this guy anymore.
    //
    ZwClose( Handle );
    
    //
    // might need this while committing
    //
    Disk->DriveLayout = *DriveLayoutEx;

    Status = STATUS_SUCCESS;
    
    //
    // ============================
    //
    // Initialize partiton descriptors.
    //
    // ============================
    //    
    if(DriveLayoutEx->PartitionCount) {
        BOOLEAN SysPartFound = FALSE;
        ULONG   PartitionedSpaceCount = 1;
        
        //
        // Initialize an area entry for each partition
        // on the disk.
        //
        for( i = 0, pDiskRegion = NULL; i < DriveLayoutEx->PartitionCount; i++ ) {
            ULONG Count = 0;
            ULONG TypeNameId = SP_TEXT_UNKNOWN;
            LARGE_INTEGER DelayTime;
            BOOLEAN AssignDriveLetter = TRUE;

            PPARTITION_INFORMATION_EX PartInfo = DriveLayoutEx->PartitionEntry + i;
            
            //
            // IOCTL_DISK_GET_DRIVE_LAYOUT_EX may return us a list of entries that
            // are not used, so ignore these partitions.
            //
            if (// if its partition 0, which indicates whole disk
                (SPPT_IS_GPT_DISK(DiskNumber) && (PartInfo->PartitionNumber == 0)) ||
                (PartInfo->PartitionLength.QuadPart == 0) ||
                // if MBR entry not used or length is zero
                ((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR) &&
                 (PartInfo->Mbr.PartitionType == PARTITION_ENTRY_UNUSED) &&
                 (PartInfo->PartitionLength.QuadPart == 0)) ||
                // if unknown/unused GPT partition
                ((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) &&
                 (!memcmp(&PartInfo->Gpt.PartitionType, 
                            &PARTITION_ENTRY_UNUSED_GUID, sizeof(GUID))))){
                continue;                                  
            }

            //
            // Allocate space for the next region.
            //
            if(pDiskRegion) {
                pDiskRegion->Next = SpMemAlloc( sizeof(DISK_REGION) );                
                pDiskRegion = pDiskRegion->Next;
            } else {
                //
                // First region allocation for harddisk so initialize 
                // the region list head for the hardisk
                //                
                ASSERT(PartDisk->PrimaryDiskRegions == NULL);
                
                pDiskRegion = SpMemAlloc(sizeof(DISK_REGION));
                PartDisk->PrimaryDiskRegions = pDiskRegion;
                SPPT_SET_DISK_BLANK(DiskNumber, FALSE);
            }

            if(!pDiskRegion) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                                    
                Status = STATUS_NO_MEMORY;

                break;
            }
            
            RtlZeroMemory(pDiskRegion, sizeof(DISK_REGION));
            
            //
            // Start filling out our Region descriptor...
            //

            //
            // DiskNumber
            //
            pDiskRegion->DiskNumber = DiskNumber;

            //
            // Partition information
            //
            pDiskRegion->PartInfo = *PartInfo;

            //
            // StartSector
            //
            pDiskRegion->StartSector = PartInfo->StartingOffset.QuadPart /
                                        Disk->Geometry.BytesPerSector;

            //
            // SectorCount
            //
            pDiskRegion->SectorCount = PartInfo->PartitionLength.QuadPart /
                                        Disk->Geometry.BytesPerSector;


            //
            // PartitionNumber
            //
            pDiskRegion->PartitionNumber = PartInfo->PartitionNumber;
            
            if (SPPT_IS_MBR_DISK(DiskNumber) && (PartInfo->PartitionNumber == 0)) {
                if (IsContainerPartition(PartInfo->Mbr.PartitionType)) {
                    SPPT_SET_REGION_EPT(pDiskRegion, EPTContainerPartition);
                }

                //
                // nothing after this is really needed for container partition
                //
                continue;                  
            } else {
                //
                // PartitionedSpace
                //
                SPPT_SET_REGION_PARTITIONED(pDiskRegion, TRUE);
            }

            if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                pDiskRegion->TablePosition = PartitionedSpaceCount++;
            }                

            //
            // Partition Number should be valid
            //
            ASSERT(pDiskRegion->PartitionNumber);
            
            //
            // IsSystemPartition (is it active)
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // On IA64 systems don't use active MBR partitions as system 
                // partitions
                //
                if (!SpIsArc()) {
                    //
                    // He's an MBR disk, so we can rely on the BootIndicator field.
                    //
                    pDiskRegion->IsSystemPartition = PartInfo->Mbr.BootIndicator;
                } 

                //
                // Don't assign drive letters to OEM partitions
                //
                if (IsOEMPartition(SPPT_GET_PARTITION_TYPE(pDiskRegion))) {
                    AssignDriveLetter = FALSE;
                }
            } else {
                //
                // He's not MBR, look at his PartitionType (which is a GUID).
                //
                pDiskRegion->IsSystemPartition = FALSE;
                
                if( !memcmp(&PartInfo->Gpt.PartitionType, 
                        &PARTITION_SYSTEM_GUID, sizeof(GUID)) ) {
                    pDiskRegion->IsSystemPartition = TRUE;
                    AssignDriveLetter = FALSE;
                }
            }

            if (SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion)) {
                SysPartFound = TRUE;
            }
                    
            
            //
            // FtPartition
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // He's an MBR disk, so we can rely on the PartitionType field.
                //
                pDiskRegion->FtPartition = IsFTPartition(PartInfo->Mbr.PartitionType);
            } else {
                //
                // He's not MBR.  Assume he's GPT and look at his PartitionType (which is a GUID).
                //
                pDiskRegion->FtPartition = FALSE;
            }

            //
            // DynamicVolume
            // DynamicVolumeSuitableForOS
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // He's an MBR disk, so we can rely on the PartitionType field.
                //
                pDiskRegion->DynamicVolume = (PartInfo->Mbr.PartitionType == PARTITION_LDM);
            } else {
                //
                // He's not MBR.  Assume he's GPT and look at his PartitionType (which is a GUID).
                //
                pDiskRegion->DynamicVolume = FALSE;
                
                if( !memcmp(&PartInfo->Gpt.PartitionType, 
                            &PARTITION_LDM_DATA_GUID, sizeof(GUID)) ) {
                    //
                    // The GUIDs match.
                    pDiskRegion->DynamicVolume = TRUE;
                }
            }

            if (pDiskRegion->DynamicVolume) {
                TypeNameId = SP_TEXT_PARTITION_NAME_DYNVOL;
            }

            //
            // if MSFT reserved partition (we need to keep track of it but
            // not process it)
            //
            if((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) &&                
                (IsEqualGUID(&(PartInfo->Gpt.PartitionType), &PARTITION_MSFT_RESERVED_GUID) ||
                 IsEqualGUID(&(PartInfo->Gpt.PartitionType), &PARTITION_LDM_METADATA_GUID))) {

                pDiskRegion->IsReserved = TRUE; 
                AssignDriveLetter = FALSE;

                //
                // Get the type name from the resources.
                //
                SpFormatMessage(pDiskRegion->TypeName,
                            sizeof(pDiskRegion->TypeName),
                            SP_TEXT_PARTNAME_RESERVED);
                
                continue;
            }               

            //
            // Assume we can't install on this dynamic volume.
            //
            pDiskRegion->DynamicVolumeSuitableForOS = FALSE;
            
            //
            // For the following entries, we need an Open handle to this partition.
            //            

            //
            // If the partition just got created, we may have to wait for
            // a few seconds before its actually available 
            //
            // Note : We wait for 20 secs at the max for each partition
            //
            for (Count = 0; (Count < 10); Count++) {
                //
                // Open the handle to the required partition
                //
                Status = SpOpenPartition( DevicePath,                
                                          PartInfo->PartitionNumber,
                                          &Handle,
                                          FALSE );

                if((Status == STATUS_NO_SUCH_DEVICE) ||
                   (Status == STATUS_OBJECT_NAME_NOT_FOUND)) {                    
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                "SETUP: SpPtInitializeDiskAreas: unable to open partition%d on device %ws (%lx)\n",
                                PartInfo->PartitionNumber,
                                DevicePath,
                                Status ));


                    DelayTime.HighPart = -1;                // relative time
                    DelayTime.LowPart = (ULONG)(-20000000);  // 2 secs in 100ns interval                     
                    
                    KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
                } else {
                    break;
                }
            }                

            //
            // Need the partition handle to continue
            //
            if (!NT_SUCCESS(Status)) {
                //
                // ignore the error while trying to open dynamic disks
                //
                if (SPPT_IS_REGION_DYNAMIC_VOLUME(pDiskRegion)) {
                    Status = STATUS_SUCCESS;
                }

                //
                // Get the type name from the resources.
                //
                SpFormatMessage(pDiskRegion->TypeName,
                            sizeof(pDiskRegion->TypeName),
                            TypeNameId);
                            
                continue;
            }                

            //
            // Check, if installtion can be done on the dynamic volume
            //
            if( pDiskRegion->DynamicVolume ) {
                //
                // Call disk manager to tell me if it's okay to
                // install on this dynamic volume.  If I get back
                // anything but STATUS_SUCCESS, then assume we
                // can't install here.
                //
                Status = ZwDeviceIoControlFile( 
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_VOLUME_IS_PARTITION,
                            NULL,
                            0,
                            NULL,
                            0 );

                if( NT_SUCCESS(Status) ){
                    pDiskRegion->DynamicVolumeSuitableForOS = TRUE;
                }
            }
            
            //
            // Filesystem
            //
            pFSInfo = SpMemAlloc( sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2) );

            if( !pFSInfo ) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                ZwClose( Handle );

                Status = STATUS_NO_MEMORY;
                break;
            }

            RtlZeroMemory( pFSInfo, sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2) );

            Status = ZwQueryVolumeInformationFile( 
                        Handle, 
                        &IoStatusBlock,
                        pFSInfo,
                        sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2),
                        FileFsAttributeInformation );
                                                                                                   
            if (!NT_SUCCESS(Status)) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: Failed to retrieve partition attribute information (%lx)\n", 
                    Status ));
            } else {                
                if (!wcscmp(pFSInfo->FileSystemName, L"NTFS")) {
                    pDiskRegion->Filesystem = FilesystemNtfs;
                    TypeNameId = SP_TEXT_FS_NAME_3;
                } else if (!wcscmp(pFSInfo->FileSystemName, L"FAT")) {
                    pDiskRegion->Filesystem = FilesystemFat;
                    TypeNameId = SP_TEXT_FS_NAME_2;
                } else if (!wcscmp(pFSInfo->FileSystemName, L"FAT32")) {
                    pDiskRegion->Filesystem = FilesystemFat32;
                    TypeNameId = SP_TEXT_FS_NAME_4;
                } else if (TypeNameId == SP_TEXT_UNKNOWN){
                    ULONG   Index;

                    pDiskRegion->Filesystem = FilesystemUnknown;

                    //
                    // Make sure it was not already created new partition
                    //
                    for (Index = 0; Index < NewPartitionCount; Index++) {
                        if (pDiskRegion->StartSector == NewPartitions[Index]) {
                            pDiskRegion->Filesystem = FilesystemNewlyCreated;
                            TypeNameId = SP_TEXT_FS_NAME_1;

                            break;
                        }                       
                    }                                                    
                }
            }

            //
            // if we cannot determine the partition type, then try
            // to use the known name from partition id.
            //
            if ((TypeNameId == SP_TEXT_UNKNOWN) && SPPT_IS_MBR_DISK(DiskNumber)) {                
                ULONG PartitionType = SPPT_GET_PARTITION_TYPE(pDiskRegion);

                if (PartitionType < 256) {   
                    UCHAR NameId = PartitionNameIds[SPPT_GET_PARTITION_TYPE(pDiskRegion)];

                    if (NameId != 0xFF) {
                        TypeNameId = SP_TEXT_PARTITION_NAME_BASE + NameId;
                    }                                                
                }                        
            }                
                                                            

            //
            // Get the type name from the resources.
            //
            SpFormatMessage(pDiskRegion->TypeName,
                        sizeof(pDiskRegion->TypeName),
                        TypeNameId);

            SpMemFree( pFSInfo );

            //
            // FreeSpaceKB and BytesPerCluster (only if we know what FS it is)
            //
            if ((pDiskRegion->Filesystem != FilesystemUnknown) &&
                 (pDiskRegion->Filesystem != FilesystemNewlyCreated)) {
                //
                // Delete \pagefile.sys if it's there.  This makes disk free space
                // calculations a little easier.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );
                                    
                SpConcatenatePaths( MyTempBuffer, L"" );
                SpDeleteFile( MyTempBuffer, L"pagefile.sys", NULL );

                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;

                pSizeInfo = SpMemAlloc( sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                if( !pSizeInfo ) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                    ZwClose( Handle );

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory( pSizeInfo, sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                Status = ZwQueryVolumeInformationFile( 
                            Handle, 
                            &IoStatusBlock,
                            pSizeInfo,
                            sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2),
                            FileFsSizeInformation );

                //
                // Waiting for another 2 secs for the volume to appear 
                //
                if (Status == STATUS_NO_SUCH_DEVICE) {
                    //
                    // Wait for 2 seconds
                    //
                    DelayTime.HighPart = -1;                // relative time
                    DelayTime.LowPart = (ULONG)(-20000000);  // 2 secs in 100ns interval                                     
                    KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
                    
                    RtlZeroMemory( pSizeInfo, sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                    Status = ZwQueryVolumeInformationFile( 
                                Handle, 
                                &IoStatusBlock,
                                pSizeInfo,
                                sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2),
                                FileFsSizeInformation );
                }
                            
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: Failed to retrieve disk(%d)partition(%d) sizing information (%lx)\n", 
                        DiskNumber,
                        pDiskRegion->PartitionNumber,                        
                        Status ));
                } else {
                    LARGE_INTEGER FreeBytes;

                    FreeBytes = RtlExtendedIntegerMultiply( 
                                    pSizeInfo->AvailableAllocationUnits,
                                    pSizeInfo->SectorsPerAllocationUnit * pSizeInfo->BytesPerSector );

                    pDiskRegion->FreeSpaceKB = RtlExtendedLargeIntegerDivide( FreeBytes,
                                                                              1024, &r ).LowPart;
                    if(r >= 512) {
                        pDiskRegion->FreeSpaceKB++;
                    }

                    //
                    // Sigh...  Legacy stuff.  SpPtDeterminePartitionGood() will want this
                    // field so that he knows what the free-space+space_from_local_source is.
                    //
                    pDiskRegion->AdjustedFreeSpaceKB = pDiskRegion->FreeSpaceKB;

                    pDiskRegion->BytesPerCluster = 
                        pSizeInfo->SectorsPerAllocationUnit * pSizeInfo->BytesPerSector;
                }

                SpMemFree( pSizeInfo );

                //
                // VolumeLabel
                //
                pLabelInfo = SpMemAlloc( sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2) );

                if( !pFSInfo ) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                        
                    ZwClose( Handle );

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory( pLabelInfo, sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2) );

                Status = ZwQueryVolumeInformationFile(
                            Handle, 
                            &IoStatusBlock,
                            pLabelInfo,
                            sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2),
                            FileFsVolumeInformation );

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: Failed to retrieve volume information (%lx)\n", Status));
                } else {
                    ULONG SaveCharCount;
                    
                    //
                    // We'll only save away the first <n> characters of
                    // the volume label.
                    //
                    SaveCharCount = min( pLabelInfo->VolumeLabelLength + sizeof(WCHAR),
                                         sizeof(pDiskRegion->VolumeLabel) ) / sizeof(WCHAR);

                    if(SaveCharCount) {
                        SaveCharCount--;  // allow for terminating NUL.
                    }

                    wcsncpy( pDiskRegion->VolumeLabel,
                             pLabelInfo->VolumeLabel,
                             SaveCharCount );
                             
                    pDiskRegion->VolumeLabel[SaveCharCount] = 0;

                }

                SpMemFree( pLabelInfo );
            } else {
                //
                // Free space is what ever the partition size is
                //
                pDiskRegion->FreeSpaceKB = (pDiskRegion->SectorCount * 
                                            Disk->Geometry.BytesPerSector) / 1024;

                pDiskRegion->AdjustedFreeSpaceKB = pDiskRegion->FreeSpaceKB;                                            
            }

            //
            // Assign the drive letter if required
            //
            if (AssignDriveLetter) {
                //
                // Retrieve nt pathname for this region.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

                    Status = STATUS_NO_MEMORY;
                    break;
                }
        
                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );

                //
                // Assign the drive letter 
                //
                pDiskRegion->DriveLetter = SpGetDriveLetter( MyTempBuffer, NULL );

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtInitializeDiskAreas: Partition = %ls, DriveLetter = %wc: \n", 
                    MyTempBuffer, pDiskRegion->DriveLetter));

                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;
            }                
            
            //
            // See if this guy has the local source.
            //
            //
            MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

            if( !MyTempBuffer ) {
                //
                // No memory...
                //
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                Status = STATUS_NO_MEMORY;
                break;
            }

            SpNtNameFromRegion( pDiskRegion,
                                MyTempBuffer,
                                MAX_NTPATH_LENGTH,
                                PrimaryArcPath );
                                
            SpConcatenatePaths( MyTempBuffer, L"" );

            //
            // Don't need this guy anymore.
            //
            ZwClose( Handle );


            if( WinntSetup && !WinntFromCd && !LocalSourceRegion &&
                    SpNFilesExist(MyTempBuffer, LocalSourceFiles, ELEMENT_COUNT(LocalSourceFiles), TRUE) ) {

                LocalSourceRegion = pDiskRegion;
                pDiskRegion->IsLocalSource = TRUE;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: %ws is the local source partition.\n", MyTempBuffer));
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: %ws is not the local source partition.\n", MyTempBuffer));
            }

            SpMemFree( MyTempBuffer );
            MyTempBuffer = NULL;
            Status = STATUS_SUCCESS;
        }

        //
        // Go ahead and locate the system partitions on this disk
        //
        if (SpIsArc()) {
            if (!SysPartFound) {
                SpPtnLocateDiskSystemPartitions(DiskNumber);
            } else {
                ValidArcSystemPartition = TRUE;
            }
        }
    }

    //
    // Update the boot entries to reflect the 
    // new region pointers
    //
    SpUpdateRegionForBootEntries();

    if (NewPartitions) {
        SpMemFree(NewPartitions);
    }    

    SpMemFree( DriveLayoutEx );

    return Status;
}


NTSTATUS
SpPtnSortDiskAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Examine the partitions defined on this disk and sort them
    according to their location on the disk.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDISK_REGION    pTempDiskRegion = NULL;
    PDISK_REGION    pCurrentDiskRegion = NULL;
    PDISK_REGION    pPreviousDiskRegion = NULL;

    //
    // Get a pointer to the list of regions.
    //
    pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

    if( !pCurrentDiskRegion ) {
        //
        // Odd.  Either something is very wrong, or
        // this disk simply has no partitions, which is
        // certainly possible.  Assume the best.
        //
        return  STATUS_SUCCESS;
    }

    //
    // We got something.  Go sort the list.  There
    // can't be very many partitions, so just bubble-sort.
    //
    while( pCurrentDiskRegion->Next ) {
        //
        // There's another partition ahead of
        // us.  See if we need to switch places.
        //
        if( pCurrentDiskRegion->StartSector > pCurrentDiskRegion->Next->StartSector ) {
            //
            // Yes, we need to swap these 2 entries.
            // Fixup the pointers.
            //
            if( pPreviousDiskRegion ) {
                //
                // 1. Set the previous disk region to point to
                //    the region after us.
                //
                pPreviousDiskRegion->Next = pCurrentDiskRegion->Next;
            } else {
                //
                // We're at the very beginning of the linked
                // list.
                //

                //
                // 1. Set the disk's region pointer to point to
                //    the region after us.
                //
                PartitionedDisks[DiskNumber].PrimaryDiskRegions = pCurrentDiskRegion->Next;
            }

            //
            // 2. Set our our next region's Next pointer to
            //    come back to us.
            //
            pTempDiskRegion = pCurrentDiskRegion->Next->Next;
            pCurrentDiskRegion->Next->Next = pCurrentDiskRegion;

            //
            // 3. Set our own pointer to a couple of regions ahead.
            //
            pCurrentDiskRegion->Next = pTempDiskRegion;

            //
            // Now reset so we start the sort over again.
            //
            pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;
            pPreviousDiskRegion = NULL;
        } else {
            //
            // No need to swap these two regions in our list.  Increment
            // our pointers and continue.
            //
            pPreviousDiskRegion = pCurrentDiskRegion;
            pCurrentDiskRegion = pCurrentDiskRegion->Next;
        }
    }

    return  Status;
}


NTSTATUS
SpPtnInitRegionFromDisk(
    IN ULONG DiskNumber,
    OUT PDISK_REGION Region
    )
/*++

Routine Description:

    Given the disk id, creates a disk region representing
    the whole disk

Arguments:

    DiskNumber  :   Disk Id

    Region      :   Region which gets initialized on return

Return Value:

    STATUS_SUCCESS if successful, otherwise STATUS_INVALID_PARAMETER

--*/    
{   
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    
    if (Region) {
        PHARD_DISK Disk = SPPT_GET_HARDDISK(DiskNumber);

        RtlZeroMemory(Region, sizeof(DISK_REGION));

        //
        // Note : Most of the fields below don't need to be initialized
        // because of the memset above, but its done for sake of
        // clarity
        //
        Region->DiskNumber = DiskNumber;
        Region->StartSector = Disk->Geometry.SectorsPerTrack;
        Region->SectorCount = Disk->DiskSizeSectors - Region->StartSector;
        SPPT_SET_REGION_PARTITIONED(Region, FALSE);
        Region->PartitionNumber = 0;
        Region->MbrInfo = NULL;
        Region->TablePosition = 0;
        Region->IsSystemPartition = FALSE;
        Region->IsLocalSource = FALSE;
        Region->Filesystem = FilesystemUnknown;
        Region->FreeSpaceKB = Disk->DiskSizeMB * 1024;
        Region->BytesPerCluster = -1;
        Region->AdjustedFreeSpaceKB = Region->FreeSpaceKB;
        Region->DriveLetter = 0;
        Region->FtPartition = FALSE;
        Region->DynamicVolume = FALSE;
        Region->DynamicVolumeSuitableForOS = FALSE;

        Status = STATUS_SUCCESS;
    }        

    return Status;
}    


NTSTATUS
SpPtnFillDiskFreeSpaceAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    This function will go peruse all partitions on the disk.  If there are
    any free regions on the disk, we'll create a region entry and
    mark it as unformatted.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDISK_REGION    pTempDiskRegion;
    PDISK_REGION    pCurrentDiskRegion = NULL;
    ULONGLONG       NextStart;
    ULONGLONG       NextSize;
    PDISK_REGION    FirstContainer = NULL;

    //
    // Get a pointer to the list of regions.
    //
    pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

    if( !pCurrentDiskRegion ) {
        //
        // Odd.  Either something is very wrong, or
        // this disk simply has no partitions, which is
        // certainly possible.  Assume the best and
        // create one region entry that encompasses all
        // space on the disk, but is unpartitioned.
        //        
        pCurrentDiskRegion = SpMemAlloc(sizeof(DISK_REGION));

        if (pCurrentDiskRegion) {
            Status = SpPtnInitRegionFromDisk(DiskNumber, pCurrentDiskRegion);
        } else {
            Status = STATUS_NO_MEMORY;
        }            

        if (NT_SUCCESS(Status)) {
            ASSERT(!PartitionedDisks[DiskNumber].PrimaryDiskRegions);
            
            PartitionedDisks[DiskNumber].PrimaryDiskRegions =
                    pCurrentDiskRegion;

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);
        }                    
        
        return Status;
    }

    //
    // The regions are already sorted according to their relative
    // position on the disk, so before we go through them, let's
    // see if there's any empty space on the disk occurring *before*
    // the first partition.
    //
    if( pCurrentDiskRegion->StartSector > SPPT_DISK_TRACK_SIZE(DiskNumber) ) {
        //
        // Yep.  Make a region descriptor for this guy (if he is more than
        // one cylinder in size)
        //
        NextStart = SPPT_DISK_TRACK_SIZE(DiskNumber);
        NextSize = pCurrentDiskRegion->StartSector - NextStart;

        //
        // The first partition can start at first track offset. So this need not always
        // be of minimum cylinder size
        //
        if (NextSize >= (SPPT_DISK_CYLINDER_SIZE(DiskNumber) - SPPT_DISK_TRACK_SIZE(DiskNumber))) {        
            pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

            if(!pTempDiskRegion) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                        
                return  STATUS_NO_MEMORY;
            }

            RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );

            pTempDiskRegion->DiskNumber = DiskNumber;
            pTempDiskRegion->StartSector = NextStart;
            pTempDiskRegion->SectorCount = NextSize;

            //
            // Put this region before the current region
            //
            pTempDiskRegion->Next = pCurrentDiskRegion;
            PartitionedDisks[DiskNumber].PrimaryDiskRegions = pTempDiskRegion;
        }            
    }

    //
    // Now go through the regions, inserting regions to account for any
    // empty space between the partitions.
    //
    while( pCurrentDiskRegion ) {
        if( !pCurrentDiskRegion->Next ) {            

            NextStart = 0;
            
            //
            // if this is container partition then all the space in this
            // container is free space
            //
            if (SPPT_IS_MBR_DISK(DiskNumber) && 
                IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion))) {
                PDISK_REGION ExtFree = NULL;

                ASSERT(FirstContainer == NULL);

                //
                // We add one here because we should be able to differentiate the starting
                // free region inside the extended partition from the extended partition
                // itself.
                //
                NextStart = pCurrentDiskRegion->StartSector + 1;
                NextSize = pCurrentDiskRegion->SectorCount;

                if (NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {                
                    PDISK_REGION ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                    if (!ExtFree) {
                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                            "SETUP: SpPtFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                            
                        return  STATUS_NO_MEMORY;
                    }

                    RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                    ExtFree->DiskNumber = DiskNumber;
                    ExtFree->StartSector = NextStart;
                    ExtFree->SectorCount = NextSize;

                    pCurrentDiskRegion->Next = ExtFree;

                    //
                    // make the new region current region !!!
                    //
                    pCurrentDiskRegion = ExtFree;   

                    NextStart = NextStart + NextSize - 1;
                } else {
                    //
                    // Make sure that the free space after the extended 
                    // partition is accounted for
                    //
                    NextStart = 0;  
                }                    
            } 
            
            //                
            // There's nothing behind of us.  See if there's any
            // empty space back there that's unaccounted for.
            // 
            if (!NextStart) {
                NextStart = pCurrentDiskRegion->StartSector + 
                            pCurrentDiskRegion->SectorCount;
            }                            

            if (PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors > NextStart) {
                NextSize = PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors -
                                NextStart;
            } else {
                NextSize = 0;
            }

            //
            // For ASR, allow partition size on GPT disks to be >= 1 sector.  
            // In all other cases, partition size must be >= 1 cylinder.
            //
            if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                ) {
                //
                // Yes there is.  We need to make a region behind us that's
                // marked as unpartitioned.
                //                
                if (FirstContainer) {
                    //
                    // there could be free space at the end of the 
                    // extended partition. Mark is separately from
                    // the free space after the extended partition
                    //
                    ULONGLONG ExtEnd = FirstContainer->StartSector + 
                                        FirstContainer->SectorCount;
                    ULONGLONG ExtFreeStart = NextStart;
                    ULONGLONG ExtFreeSize = (ExtEnd > ExtFreeStart) ?
                                            ExtEnd - ExtFreeStart : 0;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                            "SETUP:SpPtnFillDiskFreeSpaces():EFS:%I64d,EFSize:%I64d,EE:%I64d\n",
                            ExtFreeStart,
                            ExtFreeSize,
                            ExtEnd));

                    if (ExtFreeSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {
                        PDISK_REGION ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                        if (!ExtFree) {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                                
                            return  STATUS_NO_MEMORY;
                        }

                        RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                        ExtFree->DiskNumber = DiskNumber;
                        ExtFree->StartSector = ExtFreeStart;
                        ExtFree->SectorCount = ExtFreeSize;

                        pCurrentDiskRegion->Next = ExtFree;
                        pCurrentDiskRegion = ExtFree;

                        NextStart = ExtEnd;
                        NextSize = 0;

                        if (PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors > NextStart) {
                            NextSize = PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors -
                                        NextStart;
                        }                                                                                                            
                    } else {
                        //
                        // Get rid of any free space at the end which is lesser than a 
                        // cylinder partition inside the exteneded partition before
                        // we try to see if there is adequate space at the end of extended
                        // partition
                        //
                        NextStart += ExtFreeSize;
                        NextSize -= ExtFreeSize;
                    }
                }

                //
                // For ASR, allow partition size on GPT disks to be >= 1 sector.  
                // In all other cases, partition size must be >= 1 cylinder.
                //
                if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                    (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                    ) {
                    pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

                    if(!pTempDiskRegion) {
                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                            "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                            
                        return(STATUS_NO_MEMORY);
                    }

                    RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );


                    pTempDiskRegion->DiskNumber = DiskNumber;
                    pTempDiskRegion->StartSector = NextStart;
                    pTempDiskRegion->SectorCount = NextSize;
                    pCurrentDiskRegion->Next = pTempDiskRegion;
                }                    
            }

            //
            // We just processed the last region.  If there was any free space
            // behind that partition, we just accounted for it, in which case
            // we're done with this disk.  If there wasn't any free space behind
            // that partition, then we're also done.
            //
            return( Status );
        } else {
            //
            // There's another partition ahead of us.
            // See if there's free space between them.
            //
            NextStart = pCurrentDiskRegion->StartSector + 
                        pCurrentDiskRegion->SectorCount;

            if (pCurrentDiskRegion->Next->StartSector > NextStart) {
                NextSize = pCurrentDiskRegion->Next->StartSector - NextStart;                        

                //
                // Check to see if its a container partition
                //
                if (!FirstContainer && SPPT_IS_MBR_DISK(DiskNumber) && 
                    IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion))) {
                    
                    FirstContainer = pCurrentDiskRegion; 
                    NextStart = pCurrentDiskRegion->StartSector + 1;
                    NextSize = pCurrentDiskRegion->Next->StartSector - NextStart;
                }

                if (FirstContainer) {
                    ULONGLONG   ExtEnd = FirstContainer->StartSector +  
                                         FirstContainer->SectorCount;
                    ULONGLONG   FreeEnd = pCurrentDiskRegion->Next->StartSector;
                    
                    //
                    // Split the free region into extended free and normal free region
                    // if needed
                    //
                    if (!SPPT_IS_REGION_CONTAINED(FirstContainer, pCurrentDiskRegion->Next) && 
                        (ExtEnd < FreeEnd)) {
                        
                        PDISK_REGION ExtFree = NULL;

                        NextSize = ExtEnd - NextStart;

                        if (NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {
                            ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                            if (!ExtFree) {
                                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                    "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                                    
                                return  STATUS_NO_MEMORY;
                            }

                            RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                            ExtFree->DiskNumber = DiskNumber;
                            ExtFree->StartSector = NextStart;
                            ExtFree->SectorCount = NextSize;

                            //
                            // insert the region after the current one
                            //
                            ExtFree->Next = pCurrentDiskRegion->Next;
                            pCurrentDiskRegion->Next = ExtFree;

                            //
                            // make the new region current
                            //
                            pCurrentDiskRegion = ExtFree;
                        }

                        //
                        // Fix the next free region start
                        //
                        NextStart += NextSize;

                        if (FreeEnd > NextStart) {
                            NextSize = FreeEnd - NextStart;
                        } else {
                            NextSize = 0;
                        }
                    }                    
                }                
            } else {
                //
                // skip container partitions (expect for starting free space
                // inside the container partition)
                //  
                NextSize = 0;
                
                if (SPPT_IS_MBR_DISK(DiskNumber) && 
                    IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion)) && 
                    (pCurrentDiskRegion->Next->StartSector > pCurrentDiskRegion->StartSector)) {

                    if (!FirstContainer) {
                        FirstContainer = pCurrentDiskRegion;
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                            "SETUP:SpPtnFillDiskFreeSpaces():%p is the first container\n", 
                            FirstContainer));
                    }                        
                    
                    //
                    // We add one here because we should be able to differentiate the starting
                    // free region inside the extended partition from the extended partition
                    // itself.
                    //
                    NextStart = pCurrentDiskRegion->StartSector + 1;            
                    NextSize = pCurrentDiskRegion->Next->StartSector - NextStart + 1;
                }
            }                

            //
            // For ASR, allow partition size on GPT disks to be >= 1 sector.  
            // In all other cases, partition size must be >= 1 cylinder.
            //
            if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                ) {
                //
                // Yes, there's free space and we need to insert
                // a region here to represent it.  Allocate a region
                // and initialize it as unpartitioned space.
                //
                pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

                if(!pTempDiskRegion) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                    
                    return(STATUS_NO_MEMORY);
                }

                RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );


                pTempDiskRegion->DiskNumber = DiskNumber;
                pTempDiskRegion->StartSector = NextStart;
                pTempDiskRegion->SectorCount = NextSize;
                
                pTempDiskRegion->Next = pCurrentDiskRegion->Next;
                pCurrentDiskRegion->Next = pTempDiskRegion;
                pCurrentDiskRegion = pTempDiskRegion;
            }
        }
        pCurrentDiskRegion = pCurrentDiskRegion->Next;
    }

    return  Status;
}


#ifdef NOT_USED_CURRENTLY

VOID
SpDeleteDiskDriveLetters(
    VOID
    )
/*++

Routine Description:

    This routine will delete all drive letters assigned to disks and CD-ROM drives. The deletion will
    occur only if setup was started booting from the CD or boot floppies (in which case drive letter
    migration does not take place), and only if the non-removable dissks have no partitioned spaces.
    This ensures that on a clean install from the CD or boot floppies, the drive letters assigned to
    partitions on removable disks and CD-ROM drives will always be greater than the drive letters assigned
    to partitions on non-removable disks (unless the partitions on the removable disks were created before
    the ones in the removable disks, during textmode setup).


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG           DiskNumber;
    PDISK_REGION    pDiskRegion;
    PWCHAR          MyTempBuffer = NULL;
    unsigned        pass;
    BOOLEAN         PartitionedSpaceFound = FALSE;

    if( WinntSetup ) {
        //
        // If setup started from winnt32.exe then do not delete the drive letters since we want to preserve them
        //
        return;
    }

    //
    //  Setup started booting from a CD.
    //
    //  Find out if the disks contain at least one partition that is not a container.
    //  Note that we do not take into consideration partitions that are on removable media.
    //  This is to avoid the situation in which a newly created partition on a non-removable disk ends up with
    //  a drive letter that is greater than the one assigned to an existing partition on a removable disk.
    //
    for(DiskNumber = 0; !PartitionedSpaceFound && (DiskNumber<HardDiskCount); DiskNumber++) {

        if( PartitionedDisks[DiskNumber].HardDisk->Geometry.MediaType != RemovableMedia) {
            //
            // This disk isn't removable.  Let's look at all the areas and see
            // if there's anything that's partitioned.
            //
            pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

            while( pDiskRegion ) {
                if(SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                    PartitionedSpaceFound = TRUE;
                }

                //
                // Now get the next region on this disk.
                //
                pDiskRegion = pDiskRegion->Next;
            }
        }
    }

    if( !PartitionedSpaceFound ) {
        //
        // There are no partitions on this machine.  Delete all drive letters
        // so that the drive letters for each CD-ROM drive also get deleted.
        //
        // We'll do this by sending an IOCTL to the MountManager and ask him
        // to whack all his knowledge of drive letters.
        //
        NTSTATUS                Status;
        OBJECT_ATTRIBUTES       Obja;
        IO_STATUS_BLOCK         IoStatusBlock;
        UNICODE_STRING          UnicodeString;
        HANDLE                  Handle;

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile( &Handle,
                             (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_NON_DIRECTORY_FILE );

        if( NT_SUCCESS( Status ) ) {

            MOUNTMGR_MOUNT_POINT    MountMgrMountPoint;

            MountMgrMountPoint.SymbolicLinkNameOffset = 0;
            MountMgrMountPoint.SymbolicLinkNameLength = 0;
            MountMgrMountPoint.UniqueIdOffset = 0;
            MountMgrMountPoint.UniqueIdLength = 0;
            MountMgrMountPoint.DeviceNameOffset = 0;
            MountMgrMountPoint.DeviceNameLength = 0;

            Status = ZwDeviceIoControlFile( Handle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_MOUNTMGR_DELETE_POINTS,
                                            &MountMgrMountPoint,
                                            sizeof( MOUNTMGR_MOUNT_POINT ),
                                            TemporaryBuffer,
                                            sizeof( TemporaryBuffer ) );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Unable to delete drive letters. "
                    "ZwDeviceIoControl( IOCTL_MOUNTMGR_DELETE_POINTS ) failed."
                    "Status = %lx \n", Status));
            } else {
                //
                // If the drive letters got deleted then reset the drive letters assigned to all partitions.
                // Note that we only really care about resetting the drive letters on the partitions on the
                // removable disks, since, if we got that far, there won't be any partition on the non-removable
                // disks
                //
                for(DiskNumber = 0; DiskNumber<HardDiskCount; DiskNumber++) {

                    //
                    // This disk isn't removable.  Let's look at all the areas and see
                    // if there's anything that's partitioned.
                    //
                    pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

                    while( pDiskRegion ) {

                        pDiskRegion->DriveLetter = 0;

                        //
                        // Now get the next region on this disk.
                        //
                        pDiskRegion = pDiskRegion->Next;
                    }
                }
            }

            ZwClose( Handle );
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to delete drive letters. "
                "ZwOpenFile( %ls ) failed. Status = %lx \n", 
                MOUNTMGR_DEVICE_NAME, 
                Status));
        }
    }
}


NTSTATUS
SpAssignDiskDriveLetters(
    VOID
    )
/*++

Routine Description:



Arguments:


Return Value:


--*/    
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           DiskNumber;
    PDISK_REGION      pDiskRegion;
    PWCHAR          MyTempBuffer = NULL;
    unsigned        pass;

    //
    // Before initializing the drive letters, delete them if necessary.
    // This is to get rid of the letters assigned to CD-ROM drives and removables, when the disks have no
    // partitioned space.
    //
    SpDeleteDiskDriveLetters();

    //
    // Initialize all drive letters to nothing.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for( DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++ ) {
    
        pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

        while( pDiskRegion ) {
        
            pDiskRegion->DriveLetter = 0;
            
            if(SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                //
                // Retrieve nt pathname for this region.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtAssignDriveLetters: SpMemAlloc failed!\n" ));
                        
                    return(STATUS_NO_MEMORY);
                }
                    
                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );

                //
                // Assign the drive letter.
                //
                pDiskRegion->DriveLetter = SpGetDriveLetter( MyTempBuffer, NULL );

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtAssignDriveLetters: Partition = %ls, DriveLetter = %wc: \n", 
                    MyTempBuffer, pDiskRegion->DriveLetter));


                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;
            }

            //
            // Now get the next region on this disk.
            //
            pDiskRegion = pDiskRegion->Next;
        }
    }

    return( Status );
}

#endif  // NOT_USED_CURRENTLY



//
// ============================================================================
// ============================================================================
//
// The following code provides support for disk/partition selection.
//
// ============================================================================
// ============================================================================
//
#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

extern ULONG PartitionMnemonics[];


VOID
SpPtnAutoCreatePartitions(
    IN  PVOID         SifHandle,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource
    )
/*++

Routine Description:

    If there are no partitions on any disks, create some.


Arguments:

    SifHandle               :  Handle to txtsetup.sif

    SetupSourceDevicePath   :  Device from which setup was launced

    DirectoryOnSetupSource  :  Directory from where the kernel was loaded on
                               Setup device

Return Value:

    None.

--*/
{
    PDISK_REGION    p = NULL;
    PDISK_REGION    Region = NULL;
    ULONG           Index;
    BOOLEAN         Found = FALSE;
    WCHAR           RegionStr[128] = {0};
    NTSTATUS        FormatStatus;
    ULONG           MyPartitionSizeMB = 0;
    NTSTATUS        Status;



    KdPrintEx(( DPFLTR_SETUP_ID,
                DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtnAutoCreatePartitions - Checking for any existing partitions.\n" ));


    Found = FALSE;

    for(Index = 0; (Index < HardDiskCount) && (!Found); Index++) {

        Region = SPPT_GET_PRIMARY_DISK_REGION( Index );

        while( (Region) && (!Found) ) {

            if( Region->PartitionedSpace && 
                !SPPT_IS_REGION_RESERVED_PARTITION(Region)) {

                //
                // He's got something on the disk.
                //
                Found = TRUE;
            }

            Region = Region->Next;
        }
    }

    if( !Found ) {

        //
        // The disks are all empty.  We need to go
        // create some partitions for the installation.
        //

        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - No existing partitions were found.\n" ));



        if (SpIsArc()) {
            //
            // If we're on an ARC machine, go create a system
            // partition first.
            //
            
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtnAutoCreatePartitions - About to "
                "auto-generate a system partition.\n" ));

#if defined(_IA64_)

            Status = SpPtnCreateESP(FALSE);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - Could not "
                    "autocreate ESP : %lx\n",
                    Status));

                return;
            }
            
#endif            
        }

        //
        // Now create a partition to install the operating system.
        //
        // To do this, we're going to take the following steps:
        // 1. go find some free space on a disk that's big enough.
        // 2. create a partitions that's half of this guy's free space, (make the
        //    partition at least 4Gig).
        //

        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtnAutoCreatePartitions - About to "
            "auto-generate an installation partition.\n" ));

        Found = FALSE;
        for(Index = 0; (Index < HardDiskCount) && (!Found); Index++) {

            Region = SPPT_GET_PRIMARY_DISK_REGION( Index );

            while( (Region) && (!Found) ) {

                if( (!Region->PartitionedSpace) &&
                    (SPPT_REGION_FREESPACE_KB(Region)/1024 >= (SUGGESTED_INSTALL_PARTITION_SIZE_MB)) ) {

                    KdPrintEx(( DPFLTR_SETUP_ID,
                                DPFLTR_INFO_LEVEL,  
                                "SETUP: SpPtnAutoCreatePartitions - I found an area big enough for an installation.\n" ));

                    MyPartitionSizeMB = max( (ULONG)(SPPT_REGION_FREESPACE_KB(Region)/(2*1024)), SUGGESTED_INSTALL_PARTITION_SIZE_MB );

                    if( SpPtnDoCreate( Region,
                                       &p,
                                       TRUE,
                                       MyPartitionSizeMB,
                                       NULL,
                                       FALSE ) ) {

                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I just created an installation partition.\n" ));

                        //
                        // Got it.
                        //
                        Found = TRUE;
                        Region = p;

                        //
                        // Now format it.
                        //
                        swprintf( RegionStr,
                                  L"\\Harddisk%u\\Partition%u",
                                  Region->DiskNumber,
                                  Region->PartitionNumber );

                        //
                        // Format the system region with NTFS file system
                        //
                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I'm about to go format the installation partition.\n" ));

                        FormatStatus = SpDoFormat( RegionStr,
                                                   Region,
                                                   FilesystemNtfs,
                                                   TRUE,
                                                   TRUE,
                                                   FALSE,
                                                   SifHandle,
                                                   0,          // default cluster size
                                                   SetupSourceDevicePath,
                                                   DirectoryOnSetupSource );



                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - Format of an installation partition is complete.\n" ));


                    } else {
                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I failed to create an installation partition.\n" ));
                    }
                }

                Region = Region->Next;
            }
        }

    } else {

        // let 'em know
        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - Existing partitions were found.\n" ));
    }

}



NTSTATUS
SpPtnPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION  *InstallArea,
    OUT PDISK_REGION  *SystemPartitionArea,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
/*++

Routine Description:

    Shows the use the disk menu (with partitions) and locates
    the system and boot partition

Arguments:

    SifHandle               :  Handle to txtsetup.sif

    InstallArea             :  Place holder for boot partition

    SystemPartitionArea     :  Place holder for system partition

    SetupSourceDevicePath   :  Device from which setup was launced

    DirectoryOnSetupSource  :  Directory from where the kernel was loaded on
                               Setup device

    RemoteBootRePartition   :  Whether to repartition the disk for remote boot

Return Value:

    Appropriate status code

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    WCHAR           Buffer[256] = {0};
    ULONG           DiskNumber;
    PVOID           Menu;
    ULONG           MenuTopY;
    ULONG           ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG           ValidKeysCmdCons[2] = { ASCI_ESC, 0 };
    ULONG           Keypress;
    PDISK_REGION    pDiskRegion;
    PDISK_REGION    FirstDiskRegion,DefaultDiskRegion;
    BOOLEAN         unattended = UnattendedOperation;
    BOOLEAN         OldUnattendedOperation;
    BOOLEAN         createdMenu;
    ULONG           LastUsedDisk = -1;
    BOOLEAN         Win9xPartition = FALSE;

    //
    // Do some special partitioning if there's nothing
    // on the disk and the user has asked us to do an express
    // installation.
    //
    if( (!CustomSetup) && (UnattendedOperation) && (HardDiskCount != 0)
#if defined(REMOTE_BOOT)
        && (!RemoteBootSetup) && (!RemoteInstallSetup)
#endif

     ) {

        //
        // See if we need to auto-generate some partitions for the
        // installation.
        //
        SpPtnAutoCreatePartitions( SifHandle,
                                   SetupSourceDevicePath,
                                   DirectoryOnSetupSource );

    }

    if (SpIsArc()) {
        //
        // Select a system partition from among those defined in NV-RAM.
        //
        *SystemPartitionArea = SpPtnValidSystemPartitionArc(SifHandle,
                                    SetupSourceDevicePath,
                                    DirectoryOnSetupSource, 
                                    FALSE);

        if (*SystemPartitionArea) {                                    
            (*SystemPartitionArea)->IsSystemPartition = TRUE;
        }            
    }

    //
    // If the user selected any accessibility option and wanted to choose partition, show the partition screen
    //
    if(AccessibleSetup && !AutoPartitionPicker) {
        unattended = FALSE;
    }

    //
    // Save the current unattended mode and put the temp one
    //
    OldUnattendedOperation = UnattendedOperation;
    UnattendedOperation = unattended;

    while(1) {

        createdMenu = FALSE;
        Keypress = 0;

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup && HardDiskCount == 0) {

            //
            // If there are no hard disks, allow diskless install
            //

            pDiskRegion = NULL;

            //
            // Run through the rest of the code as if the user had just
            // hit enter to select this partition.
            //

            Keypress = ASCI_CR;

        } else
#endif // defined(REMOTE_BOOT)

        if (unattended && RemoteBootRepartition) {
            ULONG   DiskNumber;
            ULONG   DiskSpaceRequiredKB = 2 * 1024 * 1024;  // 2 GB

            //
            // What's the space we required for installation
            //
            SpFetchDiskSpaceRequirements(SifHandle,
                        4 * 1024,
                        &DiskSpaceRequiredKB,
                        NULL);

            //
            // Prepare the disk for remote boot installation. This involves
            // converting disk 0 into as big a partition as possible.
            //

            if (*SystemPartitionArea != NULL) {
                DiskNumber = (*SystemPartitionArea)->DiskNumber;
            } else {
#ifdef _X86_
                DiskNumber = SpDetermineDisk0();
#elif _IA64_
                DiskNumber = SpDetermineDisk0();
#else
                DiskNumber = 0;
#endif
            }

#ifdef _IA64_

            Status = SpPtnRepartitionGPTDisk(DiskNumber,
                            DiskSpaceRequiredKB,
                            &pDiskRegion);

#else                            

            Status = SpPtPartitionDiskForRemoteBoot(DiskNumber, 
                            &pDiskRegion);

#endif                            


            if (NT_SUCCESS(Status)) {

                SpPtRegionDescription(
                    &PartitionedDisks[pDiskRegion->DiskNumber],
                    pDiskRegion,
                    Buffer,
                    sizeof(Buffer)
                    );

                //
                // Run through the rest of the code as if the user had just
                // hit enter to select this partition.
                //
                Keypress = ASCI_CR;
            }
        }

        if (Keypress == 0) {

            //
            // Display the text that goes above the menu on the partitioning screen.
            //
            SpDisplayScreen(ConsoleRunning ? SP_SCRN_PARTITION_CMDCONS:SP_SCRN_PARTITION,
                    3,CLIENT_TOP+1);

            //
            // Calculate menu placement.  Leave one blank line
            // and one line for a frame.
            //
            MenuTopY = NextMessageTopLine + 2;

            //
            // Create a menu.
            //
            Menu = SpMnCreate(
                        MENU_LEFT_X,
                        MenuTopY,
                        MENU_WIDTH,
                        (VideoVars.ScreenHeight - MenuTopY -
                            (SplangQueryMinimizeExtraSpacing() ? 1 : 2) - STATUS_HEIGHT)
                        );

            if(!Menu) {
                UnattendedOperation = OldUnattendedOperation;
                return(STATUS_NO_MEMORY);
            }

            createdMenu = TRUE;

            //
            // Build up a menu of partitions and free spaces.
            //
            FirstDiskRegion = NULL;
            
            for(DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++) {
                if( !SpPtnGenerateDiskMenu(Menu, DiskNumber, &FirstDiskRegion) ) {
                    SpMnDestroy(Menu);

                    UnattendedOperation = OldUnattendedOperation;
                    return(STATUS_NO_MEMORY);
                }
            }

            ASSERT(FirstDiskRegion);

            //
            // If this is unattended operation, try to use the local source
            // region if there is one. If this fails, the user will have to
            // intervene manually.
            //
            if(!AutoPartitionPicker && unattended && LocalSourceRegion && CustomSetup &&
               (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS)) {
               
                pDiskRegion = LocalSourceRegion;

                Keypress = ASCI_CR;
                
            } else {            
                pDiskRegion = NULL;

                //
                // Unless we've been told not to, go look at each partition on each
                // disk and see if we can find anything suitable for an OS installation.
                //
                if( AutoPartitionPicker && !ConsoleRunning 
#if defined(REMOTE_BOOT)
                    && (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
                    ) {
                    
                    PDISK_REGION      pCurrentDiskRegion = NULL;
                    ULONG           RequiredKB = 0;
                    ULONG           SectorNo;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: -------------------------------------------------------------\n" ));
                        
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: Looking for an install partition\n\n" ));

                    for( DiskNumber=0; DiskNumber < HardDiskCount; DiskNumber++ ) {
                    
                        pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

                        while( pCurrentDiskRegion ) {
                            //
                            // Fetch the amount of free space required on the windows nt drive.
                            //
                            SpFetchDiskSpaceRequirements( SifHandle,
                                                          pCurrentDiskRegion->BytesPerCluster,
                                                          &RequiredKB,
                                                          NULL );

                            if( SpPtDeterminePartitionGood(pCurrentDiskRegion, RequiredKB, TRUE) ) {
                                //
                                // Got it.  Remember the partition and pretend the user
                                // hit the <enter> key.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                                    "SETUP: Selected install partition = "
                                    "(DiskNumber:%d),(DriveLetter:%wc:),(%ws)\n",
                                    DiskNumber,pCurrentDiskRegion->DriveLetter,
                                    pCurrentDiskRegion->VolumeLabel));
                                    
                                pDiskRegion = pCurrentDiskRegion;
                                Keypress = ASCI_CR;
                                
                                break;
                            }

                            pCurrentDiskRegion = pCurrentDiskRegion->Next;
                        }
                    }
                    
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: -------------------------------------------------------------\n" ));
                }


                if( !pDiskRegion ) {
                    //
                    // We didn't find any suitable partitions, which means we'll be putting up a
                    // menu very quickly.  Initialize the partition to highlight in the
                    // menu.
                    //
                    if (LastUsedDisk == -1) {
                        DefaultDiskRegion = FirstDiskRegion;
                    } else {
                        //
                        // Select the first region on the disk which the user last
                        // operated on
                        //
                        PDISK_REGION ValidRegion = SPPT_GET_PRIMARY_DISK_REGION(LastUsedDisk);

                        while (ValidRegion && SPPT_IS_REGION_CONTAINER_PARTITION(ValidRegion)) {
                            ValidRegion = ValidRegion->Next;
                        }                 

                        if (!ValidRegion)
                            ValidRegion = FirstDiskRegion;

                        DefaultDiskRegion = ValidRegion;
                    }                                                                                    

                    //
                    // Call the menu callback to initialize the status line.
                    //
                    SpPtMenuCallback( (ULONG_PTR)DefaultDiskRegion );                    

                    SpMnDisplay( Menu,
                                 (ULONG_PTR)DefaultDiskRegion,
                                 TRUE,
                                 ConsoleRunning ? ValidKeysCmdCons : ValidKeys,
                                 PartitionMnemonics,
                                 SpPtMenuCallback,
                                 &Keypress,
                                 (PULONG_PTR)(&pDiskRegion) );
                }
            }
        }            

        LastUsedDisk = pDiskRegion ? pDiskRegion->DiskNumber : -1;

        //
        // Now act on the user's selection.
        //
        if(Keypress & KEY_MNEMONIC) {
            Keypress &= ~KEY_MNEMONIC;
        }



        //
        // Disallow certain operations on partitions that contain local source
        // or are the system partition (in the x86 floppiless case).
        //
        switch(Keypress) {
            case MnemonicCreatePartition:
            case MnemonicMakeSystemPartition:
            case MnemonicDeletePartition:
            case MnemonicChangeDiskStyle:
            if( (pDiskRegion->IsLocalSource) ||
                ((Keypress == MnemonicDeletePartition) && 
                 (SpPtnIsDeleteAllowedForRegion(pDiskRegion) == FALSE))
#ifdef _X86_
                || (IsFloppylessBoot &&
                    pDiskRegion == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL)))
#endif
              ) {

                //
                // Inform the user that we can't do this operation on this
                // partition.
                //
                ULONG MyValidKeys[] = { ASCI_CR };
                SpDisplayScreen(SP_SCRN_CONFIRM_INABILITY,3,HEADER_HEIGHT+1);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0
                    );

                SpInputDrain();
                SpWaitValidKey(MyValidKeys,NULL,NULL);

                //
                // Now change the keypress so we'll fall through the next switch.
                //
                Keypress = MnemonicUnused;
            }
        }



        switch(Keypress) {

        case MnemonicCreatePartition:            
            SpPtnDoCreate(pDiskRegion, NULL, FALSE, 0, 0, TRUE);
            
            break;

        case MnemonicMakeSystemPartition: {
            //
            // Make sure we don't have any other system partition
            //
            if (SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion)) {
                ValidArcSystemPartition = TRUE;
            }
            
            if (!ValidArcSystemPartition && pDiskRegion->PartitionedSpace && SpIsArc() && 
                (pDiskRegion->Filesystem != FilesystemNtfs)) {            

                if (NT_SUCCESS(SpPtnMakeRegionArcSysPart(pDiskRegion))) {
                    PDISK_REGION SysPartRegion;
                        
                    //
                    // Ok format the partition if required
                    //
                    SysPartRegion = SpPtnValidSystemPartitionArc(SifHandle,
                                                SetupSourceDevicePath,
                                                DirectoryOnSetupSource,                                                
                                                FALSE);                   
                    if (SysPartRegion) {
                        ULONG SysPartDiskNumber = SysPartRegion->DiskNumber;                            
                        BOOLEAN Changes = FALSE;
                        
                        if ((NT_SUCCESS(SpPtnCommitChanges(SysPartDiskNumber,
                                                &Changes))) &&
                            (NT_SUCCESS(SpPtnInitializeDiskDrive(SysPartDiskNumber)))) {
                            //
                            // create MSR partition if needed
                            //
                            SpPtnInitializeGPTDisk(SysPartDiskNumber);
                        }                                                
                    }
                } else {
                    ValidArcSystemPartition = FALSE;
                }                    
            }

            break;
        }            

        case MnemonicDeletePartition:   {
            BOOLEAN SysPartDeleted = FALSE;
            BOOLEAN DeletionResult;
        
            SysPartDeleted = SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion);            
        
            DeletionResult = SpPtnDoDelete(pDiskRegion, 
                                SpMnGetText(Menu,(ULONG_PTR)pDiskRegion),
                                TRUE);

            if (DeletionResult && SysPartDeleted && SpIsArc()) {
                //
                // Find out if there are any other
                // valid system partitions
                //
                SpPtnValidSystemPartitionArc(SifHandle,
                                SetupSourceDevicePath,
                                DirectoryOnSetupSource,
                                FALSE);
            }
                                     
            break;
        }            

        case MnemonicChangeDiskStyle: {
            //
            // Before changing style make sure, its allowed
            // on this platform for the selected disk
            //
            if (SpPtnIsDiskStyleChangeAllowed(pDiskRegion->DiskNumber)) {
                PARTITION_STYLE Style = SPPT_DEFAULT_PARTITION_STYLE;
            
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                        SP_STAT_PLEASE_WAIT,
                        0);
                                    
                //
                // flip the style
                //
                if (!SPPT_IS_RAW_DISK(pDiskRegion->DiskNumber)) {
                    Style = SPPT_IS_GPT_DISK(pDiskRegion->DiskNumber) ?
                                PARTITION_STYLE_MBR : PARTITION_STYLE_GPT;
                }                            
                                
                Status = SpPtnInitializeDiskStyle(pDiskRegion->DiskNumber,
                                    Style, NULL);


                if (NT_SUCCESS(Status)) {
                    Status = SpPtnInitializeDiskDrive(pDiskRegion->DiskNumber);

#if defined(_IA64_)
                    //
                    // Go and figure out the ESP partitions and
                    // initialize the MSR partitions on valid GPT
                    // disks, if none present
                    //
                    if (Style == PARTITION_STYLE_GPT) {    
                        ULONG DiskNumber = pDiskRegion->DiskNumber;
                        
                        if (SpIsArc() && !ValidArcSystemPartition && !SpDrEnabled()) {                            
                            
                            //
                            // Create a system partition
                            //
                            Status = SpPtnCreateESP(TRUE);                    
                        }

                        //
                        // Initialize the GPT disks, to have MSR
                        // partition
                        //
                        Status = SpPtnInitializeGPTDisk(DiskNumber);                        
                    }                        
#endif                                        
                }
            }
            
            break;
        }            

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            if( ConsoleRunning ) {
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                        SP_STAT_PLEASE_WAIT,
                        0);
            
                SpPtDoCommitChanges();
            }
            if (createdMenu) {
                SpMnDestroy(Menu);
            }
            UnattendedOperation = OldUnattendedOperation;
            return(STATUS_SUCCESS);

        case ASCI_CR:

            Win9xPartition = FALSE;

            if( SpPtDoPartitionSelection( &pDiskRegion,
                                          ((Buffer[0]) ? Buffer : SpMnGetText(Menu,(ULONG_PTR)pDiskRegion)),
                                          SifHandle,
                                          unattended,
                                          SetupSourceDevicePath,
                                          DirectoryOnSetupSource,
                                          RemoteBootRepartition,
                                          &Win9xPartition) ) {

                *InstallArea = pDiskRegion;
#if defined(REMOTE_BOOT)
                //
                // Set the install region differently if this is a remote
                // boot -- in that case, the install region is always remote.
                //
                if (RemoteBootSetup && !RemoteInstallSetup) {
                    *InstallArea = RemoteBootTargetRegion;
                }
#endif // defined(REMOTE_BOOT)

                //
                // We need to figure out where the system partition is.
                //
                if (!SpIsArc()) {
                    *SystemPartitionArea = SpPtnValidSystemPartition();
                } else {                    
                    //
                    // Select a system partition from among those defined in NV-RAM.
                    // We have to do this again because the user may have deleted the
                    // system partition previously detected.
                    //
                    *SystemPartitionArea = SpPtnValidSystemPartitionArc(SifHandle,
                                                            SetupSourceDevicePath,
                                                            DirectoryOnSetupSource,
                                                            FALSE);

                    if (!(*SystemPartitionArea)) {                    
                        SpPtnPromptForSysPart(SifHandle);

                        break;  // user pressed escape to mark the system partition                            
                    }

                    //
                    // Disallow installation onto ESP / MSR
                    //
                    if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(*InstallArea) ||
                        SPPT_IS_REGION_MSFT_RESERVED(*InstallArea)) {
                        ULONG ValidKeys[] = { ASCI_CR, 0 };

                        SpDisplayScreen(SP_ESP_INSTALL_PARTITION_SAME, 3, HEADER_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0);

                        //
                        // Wait for user input
                        //
                        SpInputDrain();
                        
                        SpWaitValidKey(ValidKeys, NULL, NULL);

                        break;
                    }

                    //
                    // Disallow non GPT ESPs
                    //
                    if (SpIsArc() && !SPPT_IS_GPT_DISK((*SystemPartitionArea)->DiskNumber)) {
                        ULONG ValidKeys[] = { ASCI_CR, 0 };

                        SpDisplayScreen(SP_NON_GPT_SYSTEM_PARTITION, 3, HEADER_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0);

                        //
                        // Wait for user input
                        //
                        SpInputDrain();
                        
                        SpWaitValidKey(ValidKeys, NULL, NULL);

                        break;
                    }
                    
                }

                //
                // We're done here.
                //
                if (createdMenu) {
                    SpMnDestroy(Menu);
                }                

#if defined(REMOTE_BOOT)
                ASSERT(*SystemPartitionArea ||
                       (RemoteBootSetup && !RemoteInstallSetup && (HardDiskCount == 0)));
#else
                ASSERT(*SystemPartitionArea);
                ASSERT((*SystemPartitionArea)->Filesystem >= FilesystemFat);
#endif // defined(REMOTE_BOOT)


#ifdef _X86_
                //
                // If we are installing on to the same partition as Win9x then
                // remove the boot entry for the old operating system
                //
                if (Win9xPartition) {
                    DiscardOldSystemLine = TRUE;
                }
#endif                

                UnattendedOperation = OldUnattendedOperation;
                return(STATUS_SUCCESS);

            } else {
                //
                // Something happened when we tried to select the
                // partition.  Make sure that autopartition-picker
                // doesn't invoke next time through our while loop.
                //
                AutoPartitionPicker = FALSE;
            }
            break;
        }

        if (createdMenu) {
            SpMnDestroy(Menu);
        }
        unattended = FALSE;
    }
}


BOOLEAN
SpPtnGenerateDiskMenu(
    IN  PVOID           Menu,
    IN  ULONG           DiskNumber,
    OUT PDISK_REGION    *FirstDiskRegion
    )
/*++

Routine Description:

    Examine the disk for partitioning information and fill in our
    menu.


Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect for determining their types.

Return Value:

    TRUE    Everything went okay.
    FALSE   Something horrible happened.

--*/
{
    WCHAR           Buffer[128];
    ULONG           MessageId;
    PDISK_REGION    Region = NULL;
    WCHAR           DriveLetter[3];
    WCHAR           PartitionName[128];
    ULONGLONG       FreeSpaceMB;
    ULONGLONG       AreaSizeMB;
    ULONGLONG       AreaSizeBytes;
    ULONGLONG       OneMB = 1024 * 1024;
    PHARD_DISK      Disk = SPPT_GET_HARDDISK(DiskNumber);
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);

    //
    // Get a pointer to the list of regions.
    //
    Region = PartDisk->PrimaryDiskRegions;

    //
    // Add the disk name/description.
    //
    if(!SpMnAddItem(Menu, Disk->Description, MENU_LEFT_X, MENU_WIDTH, FALSE, 0)) {
        return(FALSE);
    }

    //
    // Only add a line between the disk name and partitions if we have space on
    // the screen. Not fatal if the space can't be added.
    //
    if(!SplangQueryMinimizeExtraSpacing()) {
        SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0);
    }

    //
    // If the disk is off-line, add a message indicating such.
    //    
    if((Disk->Status == DiskOffLine) || !Region) {
        MessageId = SP_TEXT_DISK_OFF_LINE;

        if( Disk->Characteristics & FILE_REMOVABLE_MEDIA ) {
            //
            // This is removable media, then just tell the user there's
            // no media in the drive.
            //
            MessageId = SP_TEXT_HARD_DISK_NO_MEDIA;
        }

        SpFormatMessage( Buffer,
                         sizeof(Buffer),
                         MessageId );

        return SpMnAddItem(Menu,
                            Buffer,
                            MENU_LEFT_X + MENU_INDENT,
                            MENU_WIDTH - (2 * MENU_INDENT),
                            FALSE,
                            0);
    }

    //
    // Now iterate through the areas on the disk and insert that info into the
    // menu.
    //
    while( Region ) {
        if (!SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {            
            //
            // remember the very first area that we examine.
            //
            if(*FirstDiskRegion == NULL) {
                *FirstDiskRegion = Region;
            }

            //
            // Figure out how big this disk area is and how much
            // free space we've got.
            //
            if (Region->AdjustedFreeSpaceKB != -1) {
                FreeSpaceMB = Region->AdjustedFreeSpaceKB / 1024;
            } else {
                FreeSpaceMB = 0;
            }
            
            AreaSizeBytes = Region->SectorCount * Disk->Geometry.BytesPerSector;
            AreaSizeMB    = AreaSizeBytes / OneMB;

            if ((AreaSizeBytes % OneMB) > (OneMB / 2))
                AreaSizeMB++;

            /*
            SpPtDumpDiskRegion(Region);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: Menu Item Details Free:%I64d,%I64d,%I64d\n",
                FreeSpaceMB, AreaSizeBytes, AreaSizeMB));
            */                
            
            //
            // See if this guy's partitioned.
            //
            if(SPPT_IS_REGION_PARTITIONED(Region)){                
                //
                // Pickup the driveletter
                //
                if( Region->DriveLetter ) {
                    DriveLetter[0] = Region->DriveLetter;
                } else {
                    DriveLetter[0] = L'-';
                }

                DriveLetter[1] = L':';
                DriveLetter[2] = 0;

                //
                // Format the partition name
                //
                PartitionName[0] = 0;
                
                SpPtnGetPartitionName(Region,
                    PartitionName,
                    sizeof(PartitionName)/sizeof(PartitionName[0]));

                SpFormatMessage( Buffer,
                                 sizeof( Buffer ),
                                 SP_TEXT_REGION_DESCR_1,
                                 DriveLetter,
                                 SplangPadString(-35, PartitionName),
                                 (ULONG)AreaSizeMB,
                                 (ULONG)FreeSpaceMB );                             
            } else {
                //
                // It's an unformatted area.  Use a different message.
                //
                SpFormatMessage( Buffer,
                                 sizeof( Buffer ),
                                 SP_TEXT_REGION_DESCR_3,
                                 (ULONG)AreaSizeMB );
            }

            //
            // Add the formatted information into the menu.
            //
            if(!SpMnAddItem(Menu, Buffer, MENU_LEFT_X + MENU_INDENT,
                    MENU_WIDTH - (2 * MENU_INDENT), TRUE, (ULONG_PTR)Region)) {
                return(FALSE);
            }
        }            

        Region = Region->Next;
    }


    return (SplangQueryMinimizeExtraSpacing() ? 
                TRUE : SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0));
}


PDISK_REGION
SpPtnValidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.
    If there is a partition that meets these criteria that is marked active,
    then it is the system partition, regardless of whether there are other
    partitions that also meet the criteria.

Arguments:

    None.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition (C:)
    for an x86 machine.
    NULL if no such partition currently exists.

--*/

{
    PDISK_REGION ActiveRegion , FirstRegion, CurrRegion;
    PHARD_DISK  Disk = NULL;
    ULONG DiskNumber;

    DiskNumber = SpDetermineDisk0();

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( DiskNumber == (ULONG)-1 ) {
        return NULL;
    }
#endif // defined(REMOTE_BOOT)

    if (!PartitionedDisks) {
        return NULL;
    }        

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //       
    CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    FirstRegion = NULL;
    ActiveRegion = NULL;

    while (CurrRegion) {
        if (SPPT_IS_REGION_PRIMARY_PARTITION(CurrRegion)) {
            UCHAR PartitionType = SPPT_GET_PARTITION_TYPE(CurrRegion);
            
            if(!IsContainerPartition(PartitionType) && 
                ((IsRecognizedPartition(PartitionType)) ||
                (CurrRegion->DynamicVolume && CurrRegion->DynamicVolumeSuitableForOS) ||
                ((RepairWinnt || WinntSetup || SpDrEnabled() ) && CurrRegion->FtPartition))) {

                if (!FirstRegion)
                    FirstRegion = CurrRegion;
                    
                if (!ActiveRegion && SPPT_IS_REGION_ACTIVE_PARTITION(CurrRegion)) {
                    ActiveRegion = CurrRegion;

                    break;
                }                    
            }
        }            
        
        CurrRegion = CurrRegion->Next;
    }

#ifdef TESTING_SYSTEM_PARTITION
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "%p Active, %p First\n", 
        ActiveRegion, 
        FirstRegion));
    
    if (ActiveRegion)
        FirstRegion = ActiveRegion;
        
    ActiveRegion = NULL;
#endif

    /*
    //
    // Don't do commit here as the multiple caller's are trying
    // to reuse the old region from the existing linked list
    // of regions for the disk after this
    //
    if (!ActiveRegion && FirstRegion) {
        BOOLEAN     Changes = FALSE;
        ULONGLONG   StartSector = FirstRegion->StartSector;

        SpPtnMakeRegionActive(FirstRegion);
        SPPT_MARK_REGION_AS_SYSTEMPARTITION(FirstRegion, TRUE);

        if (NT_SUCCESS(SpPtnCommitChanges(DiskNumber, &Changes)) && Changes) {
            SPPT_MARK_REGION_AS_ACTIVE(FirstRegion, TRUE);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP:SpPtnValidSystempartition():succeeded in marking\n"));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP:SpPtnValidSystempartition():Could not mark the first "
                "partition on primary disk as active\n"));
        }
    }
    */

    //
    // If there is an active, recognized region, use it as the
    // system partition.  Otherwise, use the first primary
    // we encountered as the system partition.  If there is
    // no recognized primary, then there is no valid system partition.
    //
    return  (ActiveRegion ? ActiveRegion : FirstRegion);
}

#if 0

ULONG
SpDetermineDisk0(
    VOID
    )

/*++

Routine Description:

    Determine the real disk 0, which may not be the same as \device\harddisk0.
    Consider the case where we have 2 scsi adapters and
    the NT drivers load in an order such that the one with the BIOS
    gets loaded *second* -- meaning that the system partition is actually
    on disk 1, not disk 0.

Arguments:

    None.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

--*/


{
    ULONG DiskNumber = SpArcDevicePathToDiskNumber(L"multi(0)disk(0)rdisk(0)");

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( RemoteBootSetup && (DiskNumber == (ULONG)-1) && (HardDiskCount == 0) ) {
        return DiskNumber;
    }
#endif // defined(REMOTE_BOOT)

    return((DiskNumber == (ULONG)(-1)) ? 0 : DiskNumber);
}

#endif

BOOL
SpPtnIsSystemPartitionRecognizable(
    VOID
    )
/*++

Routine Description:

    Determine whether the active partition is suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.

Arguments:

    None.

Return Value:

    TRUE - We found a suitable partition

    FALSE - We didn't find a suitable partition

--*/
{
    ULONG           DiskNumber;
    PDISK_REGION    Region = NULL;

    //
    // Any partitions on NEC98 are primary and active. So don't need to check on NEC98.
    //
    if( IsNEC_98 ) {
    	return TRUE;
    }

    DiskNumber = SpDetermineDisk0();

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if (SPPT_IS_GPT_DISK(DiskNumber)) {        
        //
        // On GPT we just need a valid formatted partition
        //
        while (Region) {    
            if (SPPT_IS_REGION_PARTITIONED(Region) &&
                SPPT_IS_RECOGNIZED_FILESYSTEM(Region->Filesystem)) {

                break;
            }                

            Region = Region->Next;
        }
    } else {
        //
        // On MBR we need a valid active formatted partition
        //
        while (Region) {    
            if (SPPT_IS_REGION_ACTIVE_PARTITION(Region) &&
                SPPT_IS_RECOGNIZED_FILESYSTEM(Region->Filesystem)) {

                break;
            }                

            Region = Region->Next;
        }
    }                
    
    return (Region) ? TRUE : FALSE;
}


BOOLEAN
SpPtnValidSystemPartitionArcRegion(
    IN PVOID SifHandle,
    IN PDISK_REGION Region
    )
{
    BOOLEAN Valid = FALSE;
    
    if (SPPT_IS_REGION_SYSTEMPARTITION(Region) &&
        (Region->FreeSpaceKB != -1) &&
        (Region->Filesystem == FilesystemFat)) {

        ULONG TotalSizeOfFilesOnOsWinnt = 0;
        ULONG RequiredSpaceKB = 0;  

        //
        //  On non-x86 platformrs, specially alpha machines that in general
        //  have small system partitions (~3 MB), we should compute the size
        //  of the files on \os\winnt (currently, osloader.exe and hall.dll),
        //  and consider this size as available disk space. We can do this
        //  since these files will be overwritten by the new ones.
        //  This fixes the problem that we see on Alpha, when the system
        //  partition is too full.
        //

        SpFindSizeOfFilesInOsWinnt( SifHandle,
                                    Region,
                                    &TotalSizeOfFilesOnOsWinnt );
        //
        // Transform the size into KB
        //
        TotalSizeOfFilesOnOsWinnt /= 1024;

        //
        // Determine the amount of free space required on a system partition.
        //
        SpFetchDiskSpaceRequirements( SifHandle,
                                      Region->BytesPerCluster,
                                      NULL,
                                      &RequiredSpaceKB );

        if ((Region->FreeSpaceKB + TotalSizeOfFilesOnOsWinnt) >= RequiredSpaceKB) {
            Valid = TRUE;
        }
    }

    return Valid;
}

PDISK_REGION
SpPtnValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN BOOLEAN SysPartNeeded
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an ARC machine.

    A partition is suitable if it is marked as a system partition in nvram,
    has the required free space and is formatted with the FAT filesystem.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition.
    Does not return if no such partition exists.

--*/

{
    ULONG               RequiredSpaceKB = 0;
    PDISK_REGION        Region = NULL;
    PPARTITIONED_DISK   PartDisk;
    ULONG               Index;

    //
    // Go through all the regions.  The one that's maked system partition
    // or is valid system partition is used for further validation.
    //
    for(Index = 0; (Index < HardDiskCount) && (!Region); Index++) {
        PartDisk = SPPT_GET_PARTITIONED_DISK(Index);
        Region = SPPT_GET_PRIMARY_DISK_REGION(Index);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                break;  // found the required region                 
            }
            
            Region = Region->Next;
        }
    }

    //
    // If the region is there and not formatted format it as FAT
    // file system
    //
    if (Region && (Region->Filesystem < FilesystemFat)) {
        WCHAR       DriveLetterString[4] = {0};

        DriveLetterString[0] = Region->DriveLetter;
        
        if (!UnattendedOperation) {
            ULONG   ValidKeys[] = { KEY_F3, 0 };
            ULONG   Mnemonics[] = { MnemonicFormat, 0 };
            ULONG   KeyPressed;
            ULONG   EscKey = SysPartNeeded ? KEY_F3 : ASCI_ESC;

            ValidKeys[0] = SysPartNeeded ? KEY_F3 : ASCI_ESC;

            SpStartScreen(SysPartNeeded ? 
                            SP_SCRN_C_UNKNOWN_1 : SP_SCRN_C_UNKNOWN,
                          3,
                          HEADER_HEIGHT+1,
                          FALSE,
                          FALSE,
                          DEFAULT_ATTRIBUTE,
                          DriveLetterString
                          );       

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                    SP_STAT_F_EQUALS_FORMAT,
                    SysPartNeeded ? 
                        SP_STAT_F3_EQUALS_EXIT : SP_STAT_ESC_EQUALS_CANCEL,
                    0);

            SpInputDrain();
                          
            KeyPressed = SpWaitValidKey(ValidKeys, NULL, Mnemonics);

            if (KeyPressed == EscKey) {
                Region = NULL;
            }                
        }

        if (Region) {
            WCHAR       RegionStr[128];
            NTSTATUS    FormatStatus;

            swprintf( RegionStr,
                      L"\\Harddisk%u\\Partition%u",
                      Region->DiskNumber,
                      Region->PartitionNumber );

            //
            // Format the system region with Fat file system
            //
            FormatStatus = SpDoFormat(RegionStr,
                                Region,
                                FilesystemFat,
                                TRUE,
                                TRUE,
                                FALSE,
                                SifHandle,
                                0,          // default cluster size
                                SetupSourceDevicePath,
                                DirectoryOnSetupSource);

            if (!NT_SUCCESS(FormatStatus)) {
                SpStartScreen(SP_SCRN_SYSPART_FORMAT_ERROR,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString
                              );
                              
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);
                        
                SpInputDrain();
                
                while(SpInputGetKeypress() != KEY_F3) ;
                
                SpDone(0, FALSE, TRUE);
            }

            //
            // Since we have formatted system partition, make sure
            // it has adequate space to hold the startup files
            //
            if(!SpPtnValidSystemPartitionArcRegion(SifHandle, Region))
                Region = NULL;  
        }                
    }              
    
    if (!Region && SysPartNeeded) {
        //
        // Make sure we don't look bad.
        //
        if( RequiredSpaceKB == 0 ) {
            SpFetchDiskSpaceRequirements( SifHandle,
                                          (32 * 1024),
                                          NULL,
                                          &RequiredSpaceKB );
        }

        //
        // No valid system partition.
        //
        SpStartScreen(
            SP_SCRN_NO_SYSPARTS,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RequiredSpaceKB
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_F3_EQUALS_EXIT,
                            0);

        SpInputDrain();

        //
        // wait for F3
        //
        while (SpInputGetKeypress() != KEY_F3) ;

        SpDone(0, FALSE, TRUE);
    }        

    ValidArcSystemPartition = (Region != NULL);

    return Region;
}    


NTSTATUS
SpPtnMarkLogicalDrives(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Walks through the region linked list and marks the container
    partition and the logical drives. Also marks the free
    space inside container partition as contained space

Arguments:

    DiskId  : Disk to process

Return Value:

    STATUS_SUCCESS if successful, otherwise approprite error code

--*/    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);
        PDISK_REGION    FirstContainer = NULL;
        PDISK_REGION    PrevContainer = NULL;

        while (Region) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                if (!FirstContainer) {
                    FirstContainer = Region;
                    Region->Container = NULL;
                } else {
                    Region->Container = FirstContainer;
                }

                PrevContainer = Region;
            } else {
                if (PrevContainer) {
                    if (SPPT_IS_REGION_CONTAINED(PrevContainer, Region)) {
                        Region->Container = PrevContainer;

                        if (SPPT_IS_REGION_PARTITIONED(Region))
                            SPPT_SET_REGION_EPT(Region, EPTLogicalDrive);
                    } else {
                        if (SPPT_IS_REGION_CONTAINED(FirstContainer, Region))
                            Region->Container = FirstContainer;
                    }
                }
            }

            Region = Region->Next;
        }
    }    

    return Status;
}

ULONG
SpPtnGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
/*++

Routine Description:

    Gets the Ordinal for the specified region of the specified
    type.
    
Arguments:

    Region      -   Region whose ordinal has to be found
    OrdinalType -   Type of ordinal for the region

Return Value:

    -1 if invalid request, otherwise appropriate ordinal number
    for the region.

--*/        
{
    ULONG   Ordinal = -1;
    
    if (Region && Region->PartitionNumber && SPPT_IS_REGION_PARTITIONED(Region)) {
        switch (OrdinalType) {
            case PartitionOrdinalOnDisk:
                if (SPPT_IS_MBR_DISK(Region->DiskNumber) && 
                    !SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                    Ordinal = Region->TablePosition;
                } else if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
                    Ordinal = Region->TablePosition;
                }


                //
                // Ordinal zero is not valid
                //
                if (Ordinal == 0) {
                    Ordinal = -1;
                }

                break;

            default:
                Ordinal = Region->PartitionNumber;
                
                break;
        }                
    }        


    if( Ordinal == -1 ) {
        //
        // This is really bad.  We're about to
        // fall over.  Atleast try...
        //
        ASSERT(FALSE);
        Ordinal = 1;        

        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtnGetOrdinal: We didn't get an ordinal!  Force it.\n" ));
    }

    return Ordinal;        
}

VOID
SpPtnGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )
/*++

Routine Description:

    Gets the hidden sector and sector count for the formatted
    partitions (volumes)
    
Arguments:

    Region      -   The region for which the sector layout information
                    is needed
    HiddenSectors   -   Place holder to return the # of hidden sectors
                        for the region
    VolumeSectorCount-  Place holder to return the # of valid sectors                        
                        for the volume

Return Value:

    None

--*/        
{
    ULONGLONG   Hidden = 0;
    
    if (Region) {
        if (ARGUMENT_PRESENT(HiddenSectors)) {
            if (Region->PartInfo.PartitionStyle == PARTITION_STYLE_MBR)
                Hidden = Region->PartInfo.Mbr.HiddenSectors;
            else
                Hidden = 0;

            *HiddenSectors = Hidden;                
        }

        if (ARGUMENT_PRESENT(VolumeSectorCount)) {
            *VolumeSectorCount = Region->SectorCount - Hidden;
        }                        
    }
}

NTSTATUS
SpPtnUnlockDevice(
    IN PWSTR    DeviceName
    )
/*++

Routine Description:

    Attempts to unlock the media for the given device
    name (NT device pathname)
    
Arguments:

    DeviceName  :   The device for which the media needs to be
                    unlocked                    

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error
    code

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (DeviceName) {
        IO_STATUS_BLOCK     IoStatusBlock;
        OBJECT_ATTRIBUTES   ObjectAttributes;
        UNICODE_STRING      UnicodeString;
        HANDLE              Handle;
        PREVENT_MEDIA_REMOVAL   PMRemoval;

        INIT_OBJA(&ObjectAttributes, 
                    &UnicodeString, 
                    DeviceName);

        //
        // Open the device
        //
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_WRITE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,                           // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_VALID_FLAGS,         // full sharing
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                           // no EAs
                    0
                    );

        if( NT_SUCCESS(Status) ) {
            //
            // Allow media removal
            //
            PMRemoval.PreventMediaRemoval = FALSE;
            
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_STORAGE_MEDIA_REMOVAL,
                        &PMRemoval,
                        sizeof(PMRemoval),
                        NULL,
                        0
                        );

            ZwClose(Handle);

            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Setup: SpPtnUnlockDevice(%ws) - "
                    "Failed to tell the floppy to release its media.\n",
                    DeviceName));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                "Setup: SpPtnUnlockDevice(%ws) - Failed to open the device.\n",
                DeviceName));
        }        
    }

    return Status;
}

VOID
SpPtnAssignOrdinals(
    IN  ULONG   DiskNumber
    )
/*++

Routine Description:

    Assigns the on disk ordinal for the partitions for
    the requested disk. This on disk ordinal is used in
    the boot.ini (or NVRAM) ARC names to identify the
    boot and system partition devices.    
    
Arguments:

    DiskNumber  :   Disk Index for the disk which needs to
                    be assigned on disk ordinal for its
                    partitions

Return Value:

    None.

--*/        
{
    if ((DiskNumber < HardDiskCount)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ULONG           OnDiskOrdinal = 1;

        if (SPPT_IS_MBR_DISK(DiskNumber)) {
            //
            // assign the ordinals to the primary partitions first
            //
            while (Region) {
                if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;              
                }

                Region = Region->Next;
            }    

            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

            //
            // assign the ordinals to the logical drives next
            //
            while (Region) {
                if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;
                }

                Region = Region->Next;
            }        
        } else {
            //
            // assign ordinals to the valid partition entries
            //
            while (Region) {
                if (SPPT_IS_REGION_PARTITIONED(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;
                }

                Region = Region->Next;
            }
        }
    }
}

VOID
SpPtnLocateSystemPartitions(
    VOID
    )
/*++

Routine Description:

    Locates and marks the system partition, by looking into all the
    partitioned space on all the disks.

    For non ARC machines, locates and marks the system partition
    only on the primary disk 
    
Arguments:

    None

Return Value:

    None

--*/        
{
    ULONG DiskNumber;

    if (SpIsArc()) {
        for (DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++) {
            SpPtnLocateDiskSystemPartitions(DiskNumber);
        }
    } else {
        DiskNumber = SpDetermineDisk0();

        if (DiskNumber != -1)
            SpPtnLocateDiskSystemPartitions(DiskNumber);
    }
}   


VOID
SpPtnLocateDiskSystemPartitions(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Locates and marks the system partition for the requested
    disk (if none exists)

    For non ARC machine, only operates on primary disk
    
Arguments:

    DiskNumber  :   Disk index, for which system partition
                    needs to be located and marked.

Return Value:

    None.    

--*/        
{
    PDISK_REGION Region = NULL;
    
    if(!SpIsArc()) {
        //
        // Note: On X86 we currently don't allow system partitions to reside
        // on GPT disks
        //            
        if (SPPT_IS_MBR_DISK(DiskNumber) && (DiskNumber == SpDetermineDisk0())) {
            //
            // On x86 machines, we will mark any primary partitions on drive 0
            // as system partition, since such a partition is potentially bootable.
            //
            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber); 

            while (Region && !SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                Region = Region->Next;
            }                

            if (!Region) {
                Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber); 

                while (Region) {
                    if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                        SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                        SPPT_SET_REGION_DIRTY(Region, TRUE);

                        break;
                    }
                    
                    Region = Region->Next;
                }
            }                
        }
    } else {
        PSP_BOOT_ENTRY BootEntry;

        //
        // Don't look for system partitions on MBR disks
        // on IA64
        //
        if (!SPPT_IS_GPT_DISK(DiskNumber)) {
            return;
        }

        //
        // On ARC machines, system partitions are specifically enumerated
        // in the NVRAM boot environment.
        //

        Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

        while (Region) {
            //
            // Skip if not a partition or extended partition.
            //
            if(SPPT_IS_REGION_PARTITIONED(Region)) {
                //
                // Get the nt pathname for this region.
                //
                SpNtNameFromRegion(
                    Region,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalOriginal
                    );

                //
                // Determine if it is a system partition.
                //
                for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                    if(!IS_BOOT_ENTRY_DELETED(BootEntry) &&
                       IS_BOOT_ENTRY_WINDOWS(BootEntry) &&                    
                       (BootEntry->LoaderPartitionNtName != 0) &&
                       !_wcsicmp(BootEntry->LoaderPartitionNtName,TemporaryBuffer)) {
                        if (!SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                            SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                            SPPT_SET_REGION_DIRTY(Region, TRUE);
                            ValidArcSystemPartition = TRUE;
                        }
                        
                        break;
                    }
                }
            }

            Region = Region->Next;
        }            
    }


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "SETUP:SpPtnLocateDiskSystemPartitions(%d):%p\n",
        DiskNumber,
        Region));

    if (Region) 
        SpPtDumpDiskRegion(Region);
}    

BOOLEAN
SpPtnIsDiskStyleChangeAllowed(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Finds out whether disk style change is allowed for the
    given disk.

    On AXP machines disk style change is not allowed. On
    X-86 machines currently disk style change is disabled for
    primary disks. 
    
Arguments:

    DiskNumber  :   Disk, whose style needs to be changed.

Return Value:

    TRUE if disk style change is allowed, otherwise FALSE

--*/            
{
    BOOLEAN Result = FALSE;

    if (DiskNumber < HardDiskCount) {
#if defined(_X86_)

        //
        // On non ARC x86 machines, the disk should be a clean
        // non-removable secondary disk
        //
        // Don't allow MBR to GPT disk conversion on X86
        //
        Result = (!SPPT_IS_REMOVABLE_DISK(DiskNumber) && 
                    SPPT_IS_BLANK_DISK(DiskNumber) && 
                    !SpIsArc() && SPPT_IS_GPT_DISK(DiskNumber));
                    
#elif defined (_IA64_)

        //
        // Don't allow conversion from GPT to MBR on IA-64
        //

        Result = !SPPT_IS_REMOVABLE_DISK(DiskNumber) &&
                    SPPT_IS_BLANK_DISK(DiskNumber) && 
                    SPPT_IS_MBR_DISK(DiskNumber);
        
#endif        
    }


    return Result;
}


VOID
SpPtnPromptForSysPart(
    IN PVOID SifHandle
    )
/*++

Routine Description:

    Prompts the user about the absence of system partition
    while installating to another valid non-system partition.
    Allows the user to quit setup or continue (generally go
    back to the partitioning engine)
    
Arguments:

    SifHandle   :   Handle to txtsetup.sif (to do space calculation)

Return Value:

    None

--*/        
{    
    ULONG RequiredSpaceKB = 0;
    ULONG KeyPressed = 0;
    
    SpFetchDiskSpaceRequirements( SifHandle,
                                  (32 * 1024),
                                  NULL,
                                  &RequiredSpaceKB );

    //
    // No valid system partition.
    //
    SpStartScreen(
        SP_SCRN_MARK_SYSPART,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RequiredSpaceKB
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);

    SpInputDrain();

    //
    // wait for F3 or ESC key
    //
    while ((KeyPressed != KEY_F3) && (KeyPressed != ASCI_ESC)) {
        KeyPressed = SpInputGetKeypress();
    }        

    if (KeyPressed == KEY_F3) {
        SpDone(0, FALSE, TRUE);
    }         
}

BOOLEAN
SpPtnIsDeleteAllowedForRegion(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Given a region this function tries to find out if the region
    can be deleted.
    
Arguments:

    Region :   Pointer to region which is to be checked for 
               deletion

Return Value:

    TRUE if the given region can be deleted otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (Region && SPPT_IS_REGION_PARTITIONED(Region)) {
        PDISK_REGION BootRegion = SpRegionFromNtName(NtBootDevicePath, 
                                    PartitionOrdinalCurrent);
        ULONG   DiskNumber = Region->DiskNumber;                                    

        if (SPPT_IS_REGION_DYNAMIC_VOLUME(Region)) {
            //
            // Don't delete the dynamic volume if its on
            // the same disk as local source or system partition
            //
            if (!(LocalSourceRegion && 
                 (LocalSourceRegion->DiskNumber == DiskNumber)) && 
                !(BootRegion && 
                 (BootRegion->DiskNumber == DiskNumber))) {                
                Result = TRUE;                 
            }                             
        } else {
            Result = ((BootRegion != Region) && (LocalSourceRegion != Region));
        }
    }

    return Result;
}


BOOLEAN
SpPtnIsRawDiskDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )
/*++

Routine Description:

    Given a drive layout tests whether the given drive layout
    could be for a raw disk

    NOTE : If all the partition entries are empty entries or
    if there are no partition entries then we assume the disk 
    to be RAW disk.
    
Arguments:

    DriveLayout : Drive layout information that needs to
    be tested

Return Value:

    TRUE if the given disk is RAW otherwise FALSE

--*/
{
    BOOLEAN Result = TRUE;

    if (DriveLayout && DriveLayout->PartitionCount && 
        (DriveLayout->PartitionStyle != PARTITION_STYLE_RAW)) {
        ULONG   Index;

        for (Index=0; Index < DriveLayout->PartitionCount; Index++) {
            PPARTITION_INFORMATION_EX   PartInfo = DriveLayout->PartitionEntry + Index;

            //
            // Partition is invalid partition if 
            //  - starting offset is 0 and
            //  - length is 0 and
            //  - partition number is 0
            //
            if ((PartInfo->StartingOffset.QuadPart) ||
                (PartInfo->PartitionLength.QuadPart) ||
                (PartInfo->PartitionNumber)) {
                Result = FALSE;

                break;  // found an valid partition entry
            }                        
        }
    }                

    return Result;
}

BOOLEAN
SpPtnIsDynamicDisk(
    IN  ULONG   DiskIndex
    )
/*++

Routine Description:

    Determines whether the given disk is dynamic i.e. it has
    atleast a single dynamic volume
        
Arguments:

    DiskIndex   -   Zero based index of the disk to test

Return Value:

    TRUE, if the disk has a dynamic volume otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if ((DiskIndex < HardDiskCount) &&
        !SPPT_IS_REMOVABLE_DISK(DiskIndex)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskIndex);

        while (Region && !SPPT_IS_REGION_DYNAMIC_VOLUME(Region)) {
            Region = Region->Next;
        }

        if (Region) {
            Result = TRUE;
        }
    }

    return Result;
}


//
// Callback context structure for finding the Guid volume name
// for the specified NT partition name
//
typedef struct _NT_TO_GUID_VOLUME_NAME {
    WCHAR   NtName[MAX_PATH];
    WCHAR   GuidVolumeName[MAX_PATH];
} NT_TO_GUID_VOLUME_NAME, *PNT_TO_GUID_VOLUME_NAME;


static
BOOLEAN
SppPtnCompareGuidNameForPartition(
    IN PVOID Context,
    IN PMOUNTMGR_MOUNT_POINTS MountPoints,        
    IN PMOUNTMGR_MOUNT_POINT MountPoint
    )
/*++

Routine Description:

    Callback routine for searching the appropriate GUID
    volume name for the specified NT partition.
        
Arguments:

    Context  : PNT_TO_GUID_VOLUME_NAME pointer disguised as PVOID

    MountPoints : The MountPoints which were received from mountmgr.
                  NOTE : The only reason this is here is because
                  somebody created MOUNT_POINT structure abstraction
                  contained inside MOUNT_POINTS which has some fields
                  (like SymbolicNameOffset) which are relative to
                  the MOUNT_POINTS.

    MountPoint : The current mountpoint (as part of MountPoints)                          

Return Value:

    TRUE if we found a match and want to terminate the iteration else
    FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (Context && MountPoint && MountPoint->SymbolicLinkNameLength) {
        WCHAR   CanonicalName[MAX_PATH];
        PWSTR   GuidName = NULL;
        UNICODE_STRING  String;
        PNT_TO_GUID_VOLUME_NAME Map = (PNT_TO_GUID_VOLUME_NAME)Context;

        GuidName = SpMemAlloc(MountPoint->SymbolicLinkNameLength + 2);

        if (GuidName) {
            //
            // Copy over the symbolic name and null terminate it
            // 
            RtlCopyMemory(GuidName, 
                ((PCHAR)MountPoints) + MountPoint->SymbolicLinkNameOffset,
                MountPoint->SymbolicLinkNameLength);

            GuidName[MountPoint->SymbolicLinkNameLength/sizeof(WCHAR)] = UNICODE_NULL;
            
            RtlInitUnicodeString(&String, GuidName); 

            //
            // We are only bothered about volume names & 
            // resolve the actual object name
            //
            if (MOUNTMGR_IS_VOLUME_NAME(&String) &&
                NT_SUCCESS(SpQueryCanonicalName(GuidName, 
                                -1, 
                                CanonicalName, 
                                sizeof(CanonicalName)))) {

                //
                // Do the names compare correctly
                //
                Result = (_wcsicmp(CanonicalName, Map->NtName) == 0);

                if (Result) {
                    //
                    // Copy the name to the result
                    //
                    RtlZeroMemory(Map->GuidVolumeName, 
                        sizeof(Map->GuidVolumeName));
                        
                    wcsncpy(Map->GuidVolumeName, 
                        GuidName, 
                        sizeof(Map->GuidVolumeName)/sizeof(WCHAR) - 1);
                        
                    Map->GuidVolumeName[sizeof(Map->GuidVolumeName)/sizeof(WCHAR) - 1] = UNICODE_NULL;
                }
            }                            

            SpMemFree(GuidName);
        }            
    }

    return Result;
}


NTSTATUS
SpPtnGetGuidNameForPartition(
    IN PWSTR NtPartitionName,
    IN OUT PWSTR VolumeName
    )
/*++

Routine Description:

    Gets the GUID volume name (in \\??\Volume{a-b-c-d} format) for
    the given NT partition name (in \Device\harddiskX\PartitionY format).
        
Arguments:

    NtPartitionName : NT partition name

    VolumeName  : Place holder buffer for receiving the GUID volume name.
                  Should be atlease MAX_PATH in length.

Return Value:

    Approriate NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (NtPartitionName && VolumeName) {
        NT_TO_GUID_VOLUME_NAME  Context = {0};

        //
        // Resolve the NT name to actual object name
        //
        Status = SpQueryCanonicalName(NtPartitionName, 
                            -1,
                            Context.NtName,
                            sizeof(Context.NtName));
                            
        if (NT_SUCCESS(Status)) {                            
            //
            // Iterate through mountpoints and try to
            // get the GUID volume name for the NT name
            //
            Status = SpIterateMountMgrMountPoints(&Context,
                        SppPtnCompareGuidNameForPartition);

            if (NT_SUCCESS(Status)) {
                if (Context.GuidVolumeName[0]) {
                    //
                    // Copy over the result
                    //
                    wcscpy(VolumeName, Context.GuidVolumeName);
                } else {
                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }                
            }
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppart3.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spppart3.h

Abstract:

    Private header file for partitioning engine and UI.

Author:

    Matt Holle (matth) 1-December-1999

Revision History:

    Minor clean up  -   Vijay Jayaseelan (vijayj)

--*/


#ifndef _SPPART3_H_
#define _SPPART3_H_

//
// MACROS
//

//
// Data structures.
//

//
// Function prototypes.
//
extern VOID
SpPtMenuCallback(
    IN ULONG_PTR UserData
    );

NTSTATUS
SpPtnInitializeDiskDrive(
    IN ULONG DiskId
    );

extern NTSTATUS
SpPtnInitializeDiskDrives(
    VOID
    );

extern NTSTATUS
SpPtnInitializeDiskAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnSortDiskAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnFillDiskFreeSpaceAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION  *InstallRegion,
    OUT PDISK_REGION  *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    );

extern BOOLEAN
SpPtnGenerateDiskMenu(
    IN  PVOID           Menu,
    IN  ULONG           DiskNumber,
    OUT PDISK_REGION    *FirstDiskRegion
    );


PDISK_REGION
SpPtnValidSystemPartition(
    VOID
    );

PDISK_REGION
SpPtnValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN BOOLEAN SysPartNeeded
    );    

BOOLEAN
SpPtnValidSystemPartitionArcRegion(
    IN PVOID SifHandle,
    IN PDISK_REGION Region
    );    
    

NTSTATUS
SpPtnInitRegionFromDisk(
    IN ULONG DiskNumber,
    OUT PDISK_REGION Region
    );
    
NTSTATUS
SpPtnInitializeDiskStyle(
    IN ULONG DiskId,
    IN PARTITION_STYLE Style,
    IN PCREATE_DISK DiskInfo OPTIONAL
    );

VOID
SpPtnFreeDiskRegions(
    IN ULONG DiskId
    );

NTSTATUS    
SpPtnMarkLogicalDrives(
    IN ULONG DiskId
    );


BOOLEAN
SpPtnDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    );

BOOLEAN
SpPtnDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    );

ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    );    

ULONG
SpPtnGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    );

VOID
SpPtnGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    );

BOOLEAN
SpPtnCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  BOOLEAN       AlignToCylinder,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

BOOLEAN
SpPtnDelete(
    IN ULONG        DiskNumber,
    IN ULONGLONG    StartSector
    );    

BOOL
SpPtnIsSystemPartitionRecognizable(
    VOID
    );

VOID
SpPtnMakeRegionActive(
    IN PDISK_REGION    Region
    );

NTSTATUS
SpPtnCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    );

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    );    

BOOLEAN
SpPtMakeDiskRaw(
    IN ULONG DiskNumber
    );    

NTSTATUS
SpPtnUnlockDevice(
    IN PWSTR    DeviceName
    );

VOID
SpPtnAssignOrdinals(
    IN  ULONG   DiskNumber
    );   

VOID
SpPtnDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    );    

VOID
SpPtnLocateDiskSystemPartitions(
    IN ULONG DiskNumber
    );    

VOID
SpPtnLocateSystemPartitions(
    VOID
    );    

BOOLEAN
SpPtnIsDiskStyleChangeAllowed(
    IN ULONG DiskNumber
    );

VOID
SpPtnPromptForSysPart(
    IN PVOID SifHandle
    );
    
NTSTATUS
SpPtnMakeRegionArcSysPart(
    IN PDISK_REGION Region
    );

ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    );
    
ULONG
SpPtnCountPartitionsByFSType(
    IN ULONG DiskId,
    IN FilesystemType   FsType
    );

BOOLEAN
SpPtnIsDeleteAllowedForRegion(
    IN PDISK_REGION Region
    );    
    
PWSTR
SpPtnGetPartitionName(
    IN PDISK_REGION Region,
    IN OUT PWSTR NameBuffer,
    IN ULONG NameBufferSize
    );

NTSTATUS
SpPtnGetGuidNameForPartition(
    IN PWSTR NtPartitionName,
    IN OUT PWSTR VolumeName
    );

NTSTATUS
SpPtnCreateESP(
    IN BOOLEAN PromptUser
    );

NTSTATUS
SpPtnInitializeGPTDisk(
    IN ULONG DiskNumber
    );    

NTSTATUS
SpPtnInitializeGPTDisks(
    VOID    
    ); 

NTSTATUS
SpPtnRepartitionGPTDisk(
    IN  ULONG           DiskId,
    IN  ULONG           MinimumFreeSpaceKB,
    OUT PDISK_REGION    *RegionToInstall
    );    

BOOLEAN
SpPtnIsDynamicDisk(
    IN  ULONG   DiskIndex
    );

    
#endif // _SPPART3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppartit.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartit.h

Abstract:

    Public header file for partitioning module in text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#ifndef _SPPARTIT_
#define _SPPARTIT_

//
// Number of entries in a partition table.
//
#define NUM_PARTITION_TABLE_ENTRIES_NEC98 16
//#if (NUM_PARTITION_TABLE_ENTRIES < NUM_PARTITION_TABLE_ENTRIES_NEC98)
#if defined(NEC_98) //NEC98
#define PTABLE_DIMENSION NUM_PARTITION_TABLE_ENTRIES_NEC98
# else //NEC98
#define PTABLE_DIMENSION NUM_PARTITION_TABLE_ENTRIES
# endif //NEC98


//
// The following table contains offsets from SP_TEXT_PARTITION_NAME_BASE
// to get the message id of the name of each type of partition.
//
extern UCHAR PartitionNameIds[256];

//
// Original ordinal is the ordinal the partition had when we started.
// OnDisk ordinal is the ordinal the partition will have when the system
//    is rebooted.
// Current ordinal is the ordinal the partition has now, if we want to
//    address it.  This may be different then OnDisk ordinal because of
//    how dynamic repartitioning is implemented.
//
typedef enum {
    PartitionOrdinalOriginal,
    PartitionOrdinalOnDisk,
    PartitionOrdinalCurrent
} PartitionOrdinalType;

//
// Define structure for an on-disk partition table entry.
//
typedef struct _REAL_DISK_PTE_NEC98 {

    UCHAR ActiveFlag;
    UCHAR SystemId;
    UCHAR Reserved[2];

    UCHAR IPLSector;
    UCHAR IPLHead;
    UCHAR IPLCylinderLow;
    UCHAR IPLCylinderHigh;

    UCHAR StartSector;
    UCHAR StartHead;
    UCHAR StartCylinderLow;
    UCHAR StartCylinderHigh;

    UCHAR EndSector;
    UCHAR EndHead;
    UCHAR EndCylinderLow;
    UCHAR EndCylinderHigh;

    UCHAR SystemName[16];
} REAL_DISK_PTE_NEC98, *PREAL_DISK_PTE_NEC98;

typedef struct _REAL_DISK_PTE {

    UCHAR ActiveFlag;

    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;

    UCHAR SystemId;

    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;

    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];

} REAL_DISK_PTE, *PREAL_DISK_PTE;


typedef struct _ON_DISK_PTE {

    UCHAR ActiveFlag;

    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;

    UCHAR SystemId;

    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;

    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];

#if defined(NEC_98) //NEC98
    //
    // add following entry for NEC98
    //
    UCHAR StartCylinderLow;  // add NEC98 original value
    UCHAR StartCylinderHigh; // not convert int13 format
    UCHAR EndCylinderLow;    // add NEC98 original value
    UCHAR EndCylinderHigh;   // not convert int13 format
    UCHAR IPLSector;         // add NEC98 original value
    UCHAR IPLHead;           //
    UCHAR IPLCylinderLow;    //
    UCHAR IPLCylinderHigh;   //
    UCHAR IPLSectors[4];     // for PC-PTOS
    UCHAR Reserved[2];       //
    UCHAR SystemName[16];    //
    UCHAR OldSystemId;       // reverse conversion for Sleep partition
    UCHAR RealDiskPosition;  // for Dynamic Partitioning on NEC98
#endif //NEC98
} ON_DISK_PTE, *PON_DISK_PTE;


//
// Define structure for an REAL on-disk master boot record.
//
typedef struct _REAL_DISK_MBR_NEC98 {

    UCHAR       JumpCode[4];

    UCHAR       IPLSignature[4];

    UCHAR       BootCode[502];

    UCHAR       AA55Signature[2];

    //REAL_DISK_PTE_NEC98 PartitionTable[NUM_PARTITION_TABLE_ENTRIES_NEC98];
    REAL_DISK_PTE_NEC98 PartitionTable[16];

} REAL_DISK_MBR_NEC98, *PREAL_DISK_MBR_NEC98;


//
// Define structure for an REAL on-disk master boot record.
//
typedef struct _REAL_DISK_MBR {

    UCHAR       BootCode[440];

    UCHAR       NTFTSignature[4];

    UCHAR       Filler[2];

    REAL_DISK_PTE PartitionTable[NUM_PARTITION_TABLE_ENTRIES];

    UCHAR       AA55Signature[2];

} REAL_DISK_MBR, *PREAL_DISK_MBR;


//
// Define structure for an DUMMY on-disk master boot record.
//
typedef struct _ON_DISK_MBR {

    UCHAR       BootCode[440];

    UCHAR       NTFTSignature[4];

    UCHAR       Filler[2];

    ON_DISK_PTE PartitionTable[PTABLE_DIMENSION];

    UCHAR       AA55Signature[2];

} ON_DISK_MBR, *PON_DISK_MBR;


typedef struct _MBR_INFO {

    struct _MBR_INFO *Next;

    ON_DISK_MBR OnDiskMbr;

    BOOLEAN     Dirty[PTABLE_DIMENSION];
    BOOLEAN     ZapBootSector[PTABLE_DIMENSION];

    USHORT      OriginalOrdinals[PTABLE_DIMENSION];
    USHORT      OnDiskOrdinals[PTABLE_DIMENSION];
    USHORT      CurrentOrdinals[PTABLE_DIMENSION];

    //
    // Fields that can be used locally for any purpose.
    //
    PVOID       UserData[PTABLE_DIMENSION];

    ULONGLONG   OnDiskSector;

} MBR_INFO, *PMBR_INFO;

typedef enum {
    EPTNone = 0,
    EPTContainerPartition,
    EPTLogicalDrive
} EXTENDED_PARTITION_TYPE;    


//
// Define structure that is used to track partitions and
// free (unpartitioned) spaces.
//
typedef struct _DISK_REGION {

    struct _DISK_REGION *Next;

    ULONG           DiskNumber;

    ULONGLONG       StartSector;
    ULONGLONG       SectorCount;

    BOOLEAN         PartitionedSpace;

    ULONG           PartitionNumber;

    //
    // The following fields are used only if PartitionedSpace is TRUE.
    //
    PMBR_INFO       MbrInfo;
    ULONG           TablePosition;

    BOOLEAN         IsSystemPartition;
    BOOLEAN         IsLocalSource;

    FilesystemType  Filesystem;
    WCHAR           TypeName[128];      // XENIX, FAT, NTFS, etc.
    ULONGLONG       FreeSpaceKB;        // -1 if can't determine.
    ULONG           BytesPerCluster;    // Number of bytes per cluster
                                        // (-1 if can't determine).
    ULONGLONG       AdjustedFreeSpaceKB; // -1 if can't determine.
                                        // if the region contains the Local Source
                                        // then this field should contain
                                        // FreeSpaceKB + LocalSourceSize
    WCHAR           VolumeLabel[20];    // First few chars of volume label
    WCHAR           DriveLetter;        // Always uppercase; 0 if none.

    BOOLEAN         FtPartition;
    BOOLEAN         DynamicVolume;
    BOOLEAN         DynamicVolumeSuitableForOS;

    EXTENDED_PARTITION_TYPE ExtendedType;
    struct _DISK_REGION     *Container;

    BOOLEAN                     Dirty;
    BOOLEAN                     Delete;
    PARTITION_INFORMATION_EX    PartInfo;
    BOOLEAN                     PartInfoDirty;
    BOOLEAN                     IsReserved;

    //
    //  The following fields are used to identify double space drives
    //  They are valid only if the file system type is FilesystemFat
    //  or FilesystemDoubleSpace
    //
    //  If the file system type is FilesystemFat and NextCompressed is not NULL,
    //  then the structure describes the host drive for compressed drives.
    //  In this case, the following fields are valid:
    //
    //      NextCompressed .... Points to a linked list of compressed drives
    //      HostDrive.......... Contains the drive letter for the drive represented
    //                          by this structure. Note that HostDrive will be
    //                          not necessarily be equal to DriveLetter
    //
    //  If the file system type is FilesystemDoubleSpace, then the structure
    //  describes a compressed drive.
    //  In this case the following fields are valid:
    //
    //      NextCompressed ..... Points to the next compressed drive in the
    //                           linked list
    //      PreviousCompressed.. Points to the previous compressed drive in
    //                           the linked list
    //      HostRegion ......... Points to the structure that describes the
    //                           host drive for the compressed drive represented
    //                           by this structure
    //      MountDrive ......... Drive letter of the drive described by this
    //                           structure (should be the same as HostRegion->HostDrive)
    //      HostDrive .......... Drive where the CVF file that represents the
    //                           this compressed drive is located.
    //      SeqNumber .......... Sequence number of the CVF file that representd
    //                           this compressed drive.
    //
    struct _DISK_REGION *NextCompressed;
    struct _DISK_REGION *PreviousCompressed;
    struct _DISK_REGION *HostRegion;
    WCHAR               MountDrive;
    WCHAR               HostDrive;
    USHORT              SeqNumber;

} DISK_REGION, *PDISK_REGION;


//
// There will be one of these structures per disk.
//
typedef struct _PARTITIONED_DISK {

    PHARD_DISK HardDisk;

    //
    //
    //
    BOOLEAN    MbrWasValid;

    //
    // We can just store the MBR here since there is only one of them.
    //
    MBR_INFO   MbrInfo;

    //
    // EBRs are stored in a linked list since there are an arbitrary number
    // of them. The one contained within this structure is a dummy and is
    // always zeroed out.
    //
    MBR_INFO  FirstEbrInfo;

    //
    // Lists of regions (partitions and free spaces)
    // on the disk and within the extended partition.
    //
    PDISK_REGION PrimaryDiskRegions;
    PDISK_REGION ExtendedDiskRegions;

} PARTITIONED_DISK, *PPARTITIONED_DISK;


extern PPARTITIONED_DISK PartitionedDisks;

//
// Disk region containing the local source directory
// in the winnt.exe setup case.
//
// If WinntSetup is TRUE, then this should be non-null.
// If it is not non-null, then we couldn't locate the local source.
//
extern PDISK_REGION LocalSourceRegion;


//
// GPT partition type strings
//
#define PARTITION_MSFT_RESERVED_STR L"Microsoft reserved partition"
#define PARTITION_LDM_METADATA_STR  L"LDM metadata partition"
#define PARTITION_LDM_DATA_STR      L"LDM data partition"
#define PARTITION_BASIC_DATA_STR    L"Basic data partition"
#define PARTITION_SYSTEM_STR        L"EFI system partition"


#if defined(REMOTE_BOOT)
//
// For remote boot, we create a fake disk region for the net(0) device.
//
extern PDISK_REGION RemoteBootTargetRegion;
#endif // defined(REMOTE_BOOT)


NTSTATUS
SpPtInitialize(
    VOID
    );

BOOLEAN
SpPtDelete(
    IN ULONG DiskNumber,
    IN ULONGLONG StartSector
    );

BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

BOOLEAN
SpPtExtend(
    IN PDISK_REGION Region,
    IN ULONGLONG    SizeMB      OPTIONAL
    );

VOID
SpPtQueryMinMaxCreationSizeMB(
    IN  ULONG   DiskNumber,
    IN  ULONGLONG StartSector,
    IN  BOOLEAN ForExtended,
    IN  BOOLEAN InExtended,
    OUT PULONGLONG  MinSize,
    OUT PULONGLONG  MaxSize,
    OUT PBOOLEAN ReservedRegion
    );

VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    );

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    );

PDISK_REGION
SpPtAllocateDiskRegionStructure(
    IN ULONG    DiskNumber,
    IN ULONGLONG StartSector,
    IN ULONGLONG SectorCount,
    IN BOOLEAN   PartitionedSpace,
    IN PMBR_INFO MbrInfo,
    IN ULONG     TablePosition
    );

ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    );

ULONGLONG
SpPtSectorCountToMB(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  SectorCount
    );

typedef BOOL
(*PSPENUMERATEDISKREGIONS)(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

void
SpEnumerateDiskRegions(
    IN PSPENUMERATEDISKREGIONS EnumRoutine,
    IN ULONG_PTR Context
    );

BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    );

PDISK_REGION
SpPtLookupRegionByStart(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           ExtendedPartition,
    IN ULONGLONG         StartSector
    );    

ULONG
SpPtAlignStart(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  StartSector,
    IN BOOLEAN    ForExtended
    );

VOID
SpPtInitializeCHSFields(
    IN  PHARD_DISK   HardDisk,
    IN  ULONGLONG    AbsoluteStartSector,
    IN  ULONGLONG    AbsoluteSectorCount,
    OUT PON_DISK_PTE pte
    );

VOID
SpPtAssignOrdinals(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           InitCurrentOrdinals,
    IN BOOLEAN           InitOnDiskOrdinals,
    IN BOOLEAN           InitOriginalOrdinals
    );    


ULONG
SpGetMaxNtDirLen(VOID);

VOID
SpPtLocateSystemPartitions(VOID);

VOID
SpPtCountPrimaryPartitions(
    IN  PPARTITIONED_DISK   pDisk,
    OUT PULONG              TotalPrimaryPartitionCount,
    OUT PULONG              RecognizedPrimaryPartitionCount,
    OUT PBOOLEAN            ExtendedExists);

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtDeviceName,
    IN PartitionOrdinalType Type);

VOID
SppRepairWinntFiles(
    IN PVOID    LogFileHandle,
    IN PVOID    MasterSifHandle,
    IN PWSTR    SourceDevicePath,
    IN PWSTR    DirectoryOnSourceDevice,
    IN PWSTR    SystemPartition,
    IN PWSTR    SystemPartitionDirectory,
    IN PWSTR    WinntPartition,
    IN PWSTR    WinntPartitionDirectory);

VOID
SppRepairStartMenuGroupsAndItems(
    IN PWSTR    WinntPartition,
    IN PWSTR    WinntDirectory);

VOID
SppRepairHives(
    PVOID   MasterSifHandle,
    PWSTR   WinntPartition,
    PWSTR   WinntPartitionDirectory,
    PWSTR   SourceDevicePath,
    PWSTR   DirectoryOnSourceDevice);

NTSTATUS
SpDoFormat(
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN ULONG        FilesystemType,
    IN BOOLEAN      IsFailureFatal,
    IN BOOLEAN      CheckFatSize,
    IN BOOLEAN      QuickFormat,
    IN PVOID        SifHandle,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    );

NTSTATUS
SpPtPartitionDiskForRemoteBoot(
    IN ULONG DiskNumber,
    OUT PDISK_REGION *RemainingRegion
    );

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION region
    );    

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    );    

WCHAR
SpGetDriveLetter(
    IN  PWSTR   DeviceName,
    OUT  PMOUNTMGR_MOUNT_POINT * MountPoint OPTIONAL
    );

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    );
    
VOID
SpPtDeleteDriveLetters(
    VOID
    );    

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    );

VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    );

VOID
SpCreateNewGuid(
    IN GUID *Guid
    );

UCHAR
SpPtGetPartitionType(
    IN PDISK_REGION Region
    );    

BOOLEAN
SpPtnIsRawDiskDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    );

BOOLEAN
SpPtnIsRegionSpecialMBRPartition(
    IN PDISK_REGION Region
    );
    

extern ULONG    RandomSeed;
extern BOOLEAN  ValidArcSystemPartition;


//
// Only on IA64 by default the RAW disk is marked as GPT disk
//
#if defined(_IA64_)
#define SPPT_DEFAULT_PARTITION_STYLE  PARTITION_STYLE_GPT
#define SPPT_DEFAULT_DISK_STYLE DISK_FORMAT_TYPE_GPT
#else
#define SPPT_DEFAULT_PARTITION_STYLE  PARTITION_STYLE_MBR    
#define SPPT_DEFAULT_DISK_STYLE DISK_FORMAT_TYPE_PCAT
#endif

#define SPPT_MINIMUM_ESP_SIZE_MB    100
#define SPPT_MAXIMUM_ESP_SIZE_MB    1000

//
//
// Various Disk, Partition, Region related Macros
//
// NB. These are used, because it makes code more readable and
// in future these macros can represent potential interface for 
// accessing the opaque in memory partition structure
//
//
#define SPPT_GET_NEW_DISK_SIGNATURE() RtlRandom(&RandomSeed)

#define SPPT_DISK_CYLINDER_COUNT(_DiskId) (HardDisks[(_DiskId)].CylinderCount)
#define SPPT_DISK_TRACKS_PER_CYLINDER(_DiskId) (HardDisks[(_DiskId)].Geometry.TracksPerCylinder)

#define SPPT_DISK_CYLINDER_SIZE(_DiskId)  (HardDisks[(_DiskId)].SectorsPerCylinder)
#define SPPT_DISK_TRACK_SIZE(_DiskId)  (HardDisks[(_DiskId)].Geometry.SectorsPerTrack)
#define SPPT_DISK_SECTOR_SIZE(_DiskId)  (HardDisks[(_DiskId)].Geometry.BytesPerSector)
#define SPPT_DISK_IS_REMOVABLE(_DiskId) (HardDisks[(_DiskId)].Characteristics & FILE_REMOVABLE_MEDIA)

#define SPPT_REGION_SECTOR_SIZE(_Region) (SPPT_DISK_SECTOR_SIZE((_Region)->DiskNumber))

#define SPPT_DISK_SIZE(_DiskId)                     \
            (SPPT_DISK_SECTOR_SIZE((_DiskId)) *     \
             HardDisks[(_DiskId)].DiskSizeSectors)

#define SPPT_DISK_SIZE_KB(_DiskId)  (SPPT_DISK_SIZE((_DiskId)) / 1024)
#define SPPT_DISK_SIZE_MB(_DiskId)  (SPPT_DISK_SIZE_KB((_DiskId)) / 1024)
#define SPPT_DISK_SIZE_GB(_DiskId)  (SPPT_DISK_SIZE_MB((_DiskId)) / 1024)
             

#define SPPT_REGION_FREESPACE(_Region) \
            ((_Region)->SectorCount * SPPT_REGION_SECTOR_SIZE((_Region)))            
            
#define SPPT_REGION_FREESPACE_KB(_Region) (SPPT_REGION_FREESPACE((_Region)) / 1024)
#define SPPT_REGION_FREESPACE_MB(_Region) (SPPT_REGION_FREESPACE_KB((_Region)) / 1024)
#define SPPT_REGION_FREESPACE_GB(_Region) (SPPT_REGION_FREESPACE_MB((_Region)) / 1024)

#define SPPT_IS_REGION_PARTITIONED(_Region) \
            ((_Region)->PartitionedSpace)

#define SPPT_IS_REGION_FREESPACE(_Region)               \
            (((_Region)->PartitionedSpace == FALSE) &&  \
             ((_Region)->ExtendedType == EPTNone))
            
#define SPPT_SET_REGION_PARTITIONED(_Region, _Type) \
            ((_Region)->PartitionedSpace = (_Type))
            
#define SPPT_IS_REGION_DIRTY(_Region) ((_Region)->Dirty)
#define SPPT_SET_REGION_DIRTY(_Region, _Type) ((_Region)->Dirty = (_Type))

#define SPPT_GET_PARTITION_TYPE(_Region) ((_Region)->PartInfo.Mbr.PartitionType)
#define SPPT_SET_PARTITION_TYPE(_Region, _Type) \
            ((_Region)->PartInfo.Mbr.PartitionType = (_Type))

#define SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(_TypeId)   \
            (IsRecognizedPartition((_TypeId)) && !IsFTPartition((_TypeId)))


#define SPPT_IS_REGION_SYSTEMPARTITION(_Region) \
            (SPPT_IS_REGION_PARTITIONED(_Region) && ((_Region)->IsSystemPartition))

#define SPPT_GET_PRIMARY_DISK_REGION(_HardDisk) \
            (PartitionedDisks[(_HardDisk)].PrimaryDiskRegions)

#define SPPT_GET_EXTENDED_DISK_REGION(_HardDisk)    \
            (PartitionedDisks[(_HardDisk)].ExtendedDiskRegions)            

#define SPPT_GET_HARDDISK(_DiskNumber) (HardDisks + (_DiskNumber))

#define SPPT_GET_PARTITIONED_DISK(_DiskNumber) (PartitionedDisks + (_DiskNumber))

#define SPPT_IS_RAW_DISK(_DiskNumber)   \
            (HardDisks[(_DiskNumber)].FormatType == DISK_FORMAT_TYPE_RAW)

#define SPPT_IS_GPT_DISK(_DiskNumber)   \
            (HardDisks[(_DiskNumber)].FormatType == DISK_FORMAT_TYPE_GPT)

#define SPPT_GET_DISK_TYPE(_DiskNumber) (HardDisks[(_DiskNumber)].FormatType)

#define SPPT_IS_MBR_DISK(_DiskNumber)   \
            (!SPPT_IS_GPT_DISK(_DiskNumber))

#define SPPT_IS_REMOVABLE_DISK(_DiskNumber) \
            (SPPT_GET_HARDDISK(_DiskNumber)->Geometry.MediaType == RemovableMedia)

#define SPPT_IS_REGION_EFI_SYSTEM_PARTITION(_Region)                        \
            (SPPT_IS_GPT_DISK((_Region)->DiskNumber) &&                     \
                (RtlEqualMemory(&((_Region)->PartInfo.Gpt.PartitionType),   \
                                    &PARTITION_SYSTEM_GUID,                 \
                                    sizeof(GUID))))

#define SPPT_IS_EFI_SYSTEM_PARTITION(_PartInfo)                         \
            (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) &&    \
                (RtlEqualMemory(&((_PartInfo)->Gpt.PartitionType),      \
                                    &PARTITION_SYSTEM_GUID,             \
                                    sizeof(GUID))))


#define SPPT_IS_REGION_RESERVED_PARTITION(_Region)      \
            (SPPT_IS_REGION_PARTITIONED(_Region) && ((_Region)->IsReserved))
            
                                                                        
#define SPPT_IS_REGION_MSFT_RESERVED(_Region)                               \
            (SPPT_IS_GPT_DISK((_Region)->DiskNumber) &&                     \
                (RtlEqualMemory(&((_Region)->PartInfo.Gpt.PartitionType),   \
                                    &PARTITION_MSFT_RESERVED_GUID,          \
                                    sizeof(GUID))))

#define SPPT_IS_PARTITION_MSFT_RESERVED(_PartInfo)                      \
            (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) &&    \
                (RtlEqualMemory(&((_PartInfo)->Gpt.PartitionType),      \
                                    &PARTITION_MSFT_RESERVED_GUID,      \
                                    sizeof(GUID))))

#define SPPT_PARTITION_NEEDS_NUMBER(_PartInfo)                              \
            ((((_PartInfo)->PartitionNumber == 0) &&                        \
              ((_PartInfo)->PartitionLength.QuadPart != 0)) &&              \
             (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) ?        \
                (SPPT_IS_PARTITION_MSFT_RESERVED((_PartInfo))) :            \
                ((IsContainerPartition((_PartInfo)->Mbr.PartitionType) == FALSE))))
                                    
#define SPPT_IS_BLANK_DISK(_DiskId) (SPPT_GET_HARDDISK((_DiskId))->NewDisk)
#define SPPT_SET_DISK_BLANK(_DiskId, _Blank) \
            (SPPT_GET_HARDDISK((_DiskId))->NewDisk = (_Blank))

#define SPPT_IS_REGION_LOGICAL_DRIVE(_Region)           \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) && \
             ((_Region)->ExtendedType == EPTLogicalDrive))

#define SPPT_IS_REGION_CONTAINER_PARTITION(_Region)                 \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) &&             \
             ((_Region)->ExtendedType == EPTContainerPartition) &&  \
              IsContainerPartition((_Region)->PartInfo.Mbr.PartitionType))

#define SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(_Region)       \
            (SPPT_IS_REGION_CONTAINER_PARTITION((_Region)) &&   \
             ((_Region)->Container == NULL))

#define SPPT_IS_REGION_INSIDE_CONTAINER(_Region) ((_Region)->Container != NULL)             

#define SPPT_IS_REGION_INSIDE_FIRST_CONTAINER(_Region)          \
            (((_Region)->Container != NULL) && ((_Region)->Container->Container == NULL))

#define SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(_Region)                         \
            ((_Region)->Container &&                                            \
             SPPT_IS_REGION_FIRST_CONTAINER_PARTITION((_Region)->Container) &&  \
             ((_Region)->Container->Next == (_Region)))
             
#define SPPT_IS_REGION_PRIMARY_PARTITION(_Region)       \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) && \
             SPPT_IS_REGION_PARTITIONED((_Region)) &&   \
             ((_Region)->ExtendedType == EPTNone))

#define SPPT_SET_REGION_EPT(_Region, _Type) \
            ((_Region)->ExtendedType = (_Type))

#define SPPT_IS_REGION_ACTIVE_PARTITION(_Region)                  \
            (SPPT_IS_REGION_PRIMARY_PARTITION((_Region)) &&     \
             ((_Region)->PartInfo.Mbr.BootIndicator))

#define SPPT_GET_REGION_LASTSECTOR(_Region) \
            ((_Region)->StartSector + (_Region)->SectorCount)

#define SPPT_IS_REGION_DYNAMIC_VOLUME(_Region)  \
            ((_Region)->DynamicVolume)

#define SPPT_IS_REGION_LDM_METADATA(_Region) \
            (PARTITION_STYLE_GPT == (_Region)->PartInfo.PartitionStyle && \
            IsEqualGUID(&PARTITION_LDM_METADATA_GUID, &(_Region)->PartInfo.Gpt.PartitionType))

#define SPPT_IS_REGION_CONTAINED(_Container, _Contained)                    \
            (((_Container)->StartSector <= (_Contained)->StartSector) &&    \
             ((_Container)->SectorCount >= (_Contained)->SectorCount) &&    \
             (SPPT_GET_REGION_LASTSECTOR((_Container)) >                    \
                (_Contained)->StartSector))

#define SPPT_IS_REGION_MARKED_DELETE(_Region) ((_Region)->Delete)
#define SPPT_SET_REGION_DELETED(_Region, _Type) ((_Region)->Delete = (_Type))

#define SPPT_IS_VALID_SYSPART_FILESYSTEM(_FileSys)  \
            (((_FileSys) == FilesystemFat) ||       \
             ((_FileSys) == FilesystemFat32))             

#define SPPT_IS_RECOGNIZED_FILESYSTEM(_FileSys) \
            (((_FileSys) == FilesystemFat) ||   \
             ((_FileSys) == FilesystemFat32) || \
             ((_FileSys) == FilesystemNtfs))

#define SPPT_IS_REGION_FORMATTED(_Region)                           \
            (SPPT_IS_REGION_PARTITIONED(_Region) &&                 \
             SPPT_IS_RECOGNIZED_FILESYSTEM((_Region)->Filesystem))

#define SPPT_IS_NT_UPGRADE()    (IsNTUpgrade == UpgradeFull)

#define SPPT_MARK_REGION_AS_SYSTEMPARTITION(_Region, _Value)   \
            (_Region)->IsSystemPartition = (_Value)             

#define SPPT_MARK_REGION_AS_ACTIVE(_Region, _Value)             \
            (_Region)->PartInfo.Mbr.BootIndicator = (_Value)

__inline
ULONGLONG
SpPtnGetDiskMSRSizeMB(
    IN ULONG DiskId
    )
{
    return (SPPT_DISK_SIZE_GB(DiskId) >= 16) ? 128 : 32;
}

__inline
BOOLEAN
SpPtnIsValidMSRRegion(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_REGION_FREESPACE(Region) &&
            (SpPtnGetDiskMSRSizeMB(Region->DiskNumber) 
                <= SPPT_REGION_FREESPACE_MB(Region)));
}

__inline
ULONGLONG
SpPtnGetDiskESPSizeMB(
    IN  ULONG DiskId
    )
{
    return (max(SPPT_MINIMUM_ESP_SIZE_MB,
                min(SPPT_MAXIMUM_ESP_SIZE_MB,
                    SPPT_DISK_SIZE_MB(DiskId) / 100)));
}

__inline
BOOLEAN
SpPtnIsValidESPRegionSize(
    IN PDISK_REGION Region
    )
{
    BOOLEAN Result = FALSE;

    if (Region) {
        ULONGLONG EspSizeMB = SpPtnGetDiskESPSizeMB(Region->DiskNumber);
        ULONGLONG EspSizeSectors = (EspSizeMB * 1024 * 1024) / SPPT_DISK_SECTOR_SIZE(Region->DiskNumber);

        //
        // Align down required ESP size if possible
        //
        if (EspSizeSectors > SPPT_DISK_CYLINDER_SIZE(Region->DiskNumber)) {
            EspSizeSectors -= (EspSizeSectors % SPPT_DISK_CYLINDER_SIZE(Region->DiskNumber));            
        }
        //
        // Take into account that the partition may start on the second track of the disk
        //
        if(EspSizeSectors > SPPT_DISK_TRACK_SIZE(Region->DiskNumber)) {
            EspSizeSectors -= SPPT_DISK_TRACK_SIZE(Region->DiskNumber);
        }

        Result = (EspSizeSectors <= Region->SectorCount);
    }                

    return Result;
}

__inline
BOOLEAN 
SpPtnIsValidESPRegion(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_GPT_DISK(Region->DiskNumber) && 
            SPPT_IS_REGION_FREESPACE(Region) &&
            (Region == SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber)) &&
            SpPtnIsValidESPRegionSize(Region));
}

__inline
BOOLEAN 
SpPtnIsValidESPPartition(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_GPT_DISK(Region->DiskNumber) && 
            SPPT_IS_REGION_PARTITIONED(Region) &&
            
            (Region == SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber)) &&
            SpPtnIsValidESPRegionSize(Region));
}

__inline
VOID
SpPtnSetRegionPartitionInfo(
    IN PDISK_REGION Region,
    IN PPARTITION_INFORMATION_EX PartInfo
    )
{
    if (Region && PartInfo) {
        if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
            Region->PartInfo.Mbr.PartitionType = PartInfo->Mbr.PartitionType;
            Region->PartInfo.Mbr.BootIndicator = PartInfo->Mbr.BootIndicator;
            Region->PartInfoDirty = TRUE;
        } else if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
            Region->PartInfo.Gpt = PartInfo->Gpt;           
            Region->PartInfoDirty = TRUE;
        }
    }
}

__inline
PWSTR
SpPtnGetPartitionNameFromGUID(
    IN  GUID     *Guid,
    OUT PWSTR    NameBuffer
    )
{
    PWSTR   Name = NULL;
    
    if (Guid && NameBuffer) {
        PWSTR   PartitionName = NULL;
        
        if (IsEqualGUID(Guid, &PARTITION_MSFT_RESERVED_GUID)) {
            PartitionName = PARTITION_MSFT_RESERVED_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_LDM_METADATA_GUID)) {
            PartitionName = PARTITION_LDM_METADATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_LDM_DATA_GUID)) {
            PartitionName = PARTITION_LDM_DATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_BASIC_DATA_GUID)) {
            PartitionName = PARTITION_BASIC_DATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_SYSTEM_GUID)) {
            PartitionName = PARTITION_SYSTEM_STR;
        }

        if (PartitionName) {
            PARTITION_INFORMATION_GPT   GptPart;
            
            Name = NameBuffer;
            wcsncpy(NameBuffer, PartitionName, sizeof(GptPart.Name)/sizeof(WCHAR));
        } else {
            *NameBuffer = UNICODE_NULL;
        }            
    }                

    return Name;
}

#endif // ndef _SPPARTIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppartit.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartit.c

Abstract:

    Partitioning module in text setup.

Author:

    Ted Miller (tedm) 7-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <bootmbr.h>

//
// For NEC98 boot memu code.
//
#include <x86mboot.h> //NEC98

extern BOOLEAN DriveAssignFromA; //NEC98
extern BOOLEAN ConsoleRunning;
extern BOOLEAN ForceConsole;
extern BOOLEAN ValidArcSystemPartition;

extern PSETUP_COMMUNICATION  CommunicationParams;

PPARTITIONED_DISK PartitionedDisks;

//
// Disk region containing the local source directory
// in the winnt.exe setup case.
//
// If WinntSetup is TRUE and WinntFromCd is FALSE, then this
// should be non-null. If it is not non-null, then we couldn't locate
// the local source.
//
//
PDISK_REGION LocalSourceRegion;

#if defined(REMOTE_BOOT)
//
// For remote boot, we create a fake disk region for the net(0) device.
//
PDISK_REGION RemoteBootTargetRegion = NULL;
#endif // defined(REMOTE_BOOT)


//
//  RemoteBootSetup is true when Source and target paths are through the redirector
//  with possibly no system partition.
//
//  RemoteInstallSetup is true when we are doing a remote install.
//
//  RemoteSysPrepSetup is true when we are doing a remote install of a sys prep image.
//
//  RemoteSysPrepVolumeIsNtfs is true when the sysprep image we're copying down
//  represents an ntfs volume.
//

BOOLEAN RemoteBootSetup = FALSE;
BOOLEAN RemoteInstallSetup = FALSE;
BOOLEAN RemoteSysPrepSetup = FALSE;
BOOLEAN RemoteSysPrepVolumeIsNtfs = FALSE;

VOID
SpPtReadPartitionTables(
    IN PPARTITIONED_DISK pDisk
    );

VOID
SpPtInitializePartitionStructures(
    IN ULONG DiskNumber
    );

VOID
SpPtDeterminePartitionTypes(
    IN ULONG DiskNumber
    );

VOID
SpPtDetermineVolumeFreeSpace(
    IN ULONG DiskNumber
    );

VOID
SpPtLocateSystemPartitions(
    VOID
    );

VOID
SpPtDeleteDriveLetters(
    VOID
    );

ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    );        

//begin NEC98
NTSTATUS
SpInitializeHardDisk_Nec98(
    PDISK_REGION
    );

VOID
SpReassignOnDiskOrdinals(
    IN PPARTITIONED_DISK pDisk
    );

VOID
ConvertPartitionTable(
    IN PPARTITIONED_DISK pDisk,
    IN PUCHAR            Buffer,
    IN ULONG             bps
    );
//end NEC98

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    );

VOID
SpPtAssignDriveLetters(
    VOID
    );

//begin NEC98
VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    );

VOID
SpPtUnAssignDriveLetters(
    VOID
    );

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    );

VOID
SpTranslatePteInfo(
    IN PON_DISK_PTE   pPte,
    IN PREAL_DISK_PTE pRealPte,
    IN BOOLEAN        Write // into real PTE
    );

VOID
SpTranslateMbrInfo(
    IN PON_DISK_MBR   pMbr,
    IN PREAL_DISK_MBR pRealMbr,
    IN ULONG          bps,
    IN BOOLEAN        Write // into real MBR
    );

VOID
SpDetermineFormatTypeNec98(
    IN PPARTITIONED_DISK pDisk,
    IN PREAL_DISK_MBR_NEC98 pRealMbrNec98
    );
//end NEC98

PDISK_PARTITION
SpGetPartitionDescriptionFromRegistry(
    IN PVOID            Buffer,
    IN ULONG            DiskSignature,
    IN PLARGE_INTEGER   StartingOffset,
    IN PLARGE_INTEGER   Length
    );

VOID
SpPtFindLocalSourceRegionOnDynamicVolumes(
    VOID
    );

NTSTATUS
SpPtCheckDynamicVolumeForOSInstallation(
    IN PDISK_REGION Region
    );


#ifndef NEW_PARTITION_ENGINE

NTSTATUS
SpPtInitialize(
    VOID
    )
{
    ULONG             disk;
    PHARD_DISK        harddisk;
    PPARTITIONED_DISK partdisk;
    ULONG             Disk0Ordinal = 0;

    ASSERT(HardDisksDetermined);

    //
    // If there are no hard disks, bail now.
    //
    if(!HardDiskCount) {

#if defined(REMOTE_BOOT)
        //
        // If this is a diskless remote boot setup, it's OK for there to be
        // no hard disks. Otherwise, this is a fatal error.
        //
        if (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
        {
            SpDisplayScreen(SP_SCRN_NO_HARD_DRIVES,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);
        }
        return STATUS_SUCCESS;
    }

    CLEAR_CLIENT_SCREEN();

#ifdef _X86_
    Disk0Ordinal = SpDetermineDisk0();


    //
    // If the user booted off of a high-density floppy (e.g. an ls-120), then
    // it's possible that we've locked the device in its bay.  For this
    // reason, we're going to tell the drive to unlock floppy0.
    //
    {
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        HANDLE Handle;
        WCHAR OpenPath[64];
        PREVENT_MEDIA_REMOVAL   PMRemoval;

        wcscpy(OpenPath,L"\\device\\floppy0");
        INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);

        //
        // Open him.
        //
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_WRITE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,                           // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_VALID_FLAGS,         // full sharing
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                           // no EAs
                    0
                    );

        if( NT_SUCCESS(Status) ) {

            //
            // Tell him to let go.
            //
            PMRemoval.PreventMediaRemoval = FALSE;
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_STORAGE_MEDIA_REMOVAL,
                        &PMRemoval,
                        sizeof(PMRemoval),
                        NULL,
                        0
                        );

            ZwClose(Handle);

            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: SpPtInitialize - Failed to tell the floppy to release its media.\n"));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: SpPtInitialize - Failed to open the floppy.\n"));
        }

    }

#endif

    //
    // Allocate an array for the partitioned disk descriptors.
    //
    PartitionedDisks = SpMemAlloc(HardDiskCount * sizeof(PARTITIONED_DISK));
    if(!PartitionedDisks) {
        return(STATUS_NO_MEMORY);
    }

    RtlZeroMemory(PartitionedDisks,HardDiskCount * sizeof(PARTITIONED_DISK));


    //
    // For each hard disk attached to the system, read its partition table.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
#ifdef GPT_PARTITION_ENGINE
        if (SPPT_IS_GPT_DISK(disk)) {
           SpPtnInitializeDiskDrive(disk);
           continue;
        }           
#endif

        harddisk = &HardDisks[disk];

        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            harddisk->Description
            );

        partdisk = &PartitionedDisks[disk];

        partdisk->HardDisk = harddisk;

        //
        // Read the partition tables.
        //
        SpPtReadPartitionTables(partdisk);

        //
        // Initialize structures that are based on the partition tables.
        //
        SpPtInitializePartitionStructures(disk);

        //
        // Determine the type name for each partition on this disk.
        //
        SpPtDeterminePartitionTypes(disk);
    }

    //
    // Assign drive letters to the various partitions
    //
    SpPtAssignDriveLetters();

    //
    // DoubleSpace initialization.
    //

    //
    //  Load dblspace.ini file
    //
    if( SpLoadDblspaceIni() ) {
        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[Disk0Ordinal].Description
            );

        //
        //  Build lists of compressed drives and add them to the DISK_REGION
        //  structures
        //
        SpInitializeCompressedDrives();
    }

    for(disk=0; disk<HardDiskCount; disk++) {

        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[disk].Description
            );

        //
        // Determine the amount of free space on recognized volumes.
        //
        SpPtDetermineVolumeFreeSpace(disk);
    }

    if(WinntSetup && !WinntFromCd && !LocalSourceRegion) {
        //
        // If we got that far and we still don't know where the local source files are,
        // then serch for them in the dynamic volumes that are not listed on the MBR or EBR.
        //
        SpPtFindLocalSourceRegionOnDynamicVolumes();
    }

#ifdef _X86_
    //
    // If the mbr on disk 0 was not valid, inform the user that
    // continuing will mean the loss of whatever was on the disk.
    //
    // We won't actually write it out here.  We know that in order to
    // continue, the user will HAVE to create a C: partition on this drive
    // so we'll end up writing the master boot code when that change is comitted.
    //
    // Bootable partition on NEC98 is not only C: so don't check it.
    //
    // If doing a remote install or remote sysprep setup, don't check it.
    //
    if((!IsNEC_98) && //NEC98
       (!ForceConsole) &&
       (!(RemoteInstallSetup || RemoteSysPrepSetup)) &&
       (!PartitionedDisks[Disk0Ordinal].MbrWasValid)) {

        ULONG ValidKeys[2] = { KEY_F3, 0 };
        ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

        while(1) {

            SpDisplayScreen(SP_SCRN_INVALID_MBR_0,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
            case KEY_F3:
                SpConfirmExit();
                break;
            default:
                //
                // must be c=continue
                //
                goto x1;
            }
        }
    }

  x1:
#endif

    //
    // Figure out which partitions are system partitions.
    //
    SpPtLocateSystemPartitions();

    return(STATUS_SUCCESS);
}


VOID
SpPtDeterminePartitionTypes(
    IN  ULONG     DiskNumber
    )

/*++

Routine Description:

    Determine the partition types of each partition currently on a disk.

    The partition type is determined by the system id byte in the partition
    table entry.  If the partition type is one we recognize as a Windows NT
    compatible filesystem (types 1,4,6,7) then we dig a little deeper and
    actually determine the filesystem on the volume and use the result as
    the type name.

    Unused spaces are not given type names.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
        we want to inspect for determining their types.

Return Value:

    None.

--*/

{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    ULONG NameId;
    UCHAR SysId;
    FilesystemType FsType;
    unsigned pass;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    pDisk = &PartitionedDisks[DiskNumber];

    for(pass=0; pass<2; pass++) {

        pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
        for( ; pRegion; pRegion=pRegion->Next) {

            pRegion->TypeName[0] = 0;
            pRegion->Filesystem = FilesystemUnknown;

            //
            // If this is a free space, skip it.
            //
            if(!pRegion->PartitionedSpace) {
                continue;
            }

            //
            // Fetch the system id.
            //
//            SysId = pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId;
            SysId = SpPtGetPartitionType(pRegion);

            //
            // If this is the extended partition, skip it.
            //
            if(IsContainerPartition(SysId)) {
                continue;
            }

            //
            //  Initialize the FT related information
            //
            if( IsRecognizedPartition(SysId) &&
                (((SysId & VALID_NTFT) == VALID_NTFT) ||
                ((SysId & PARTITION_NTFT) == PARTITION_NTFT))
              ) {

                pRegion->FtPartition = TRUE;

            }

            //
            //  Initialize the dynamic volume relatated information
            //
            if( (SysId == PARTITION_LDM)
              ) {

                pRegion->DynamicVolume = TRUE;
                //
                //  Find out if the dynamic volume is suitable for OS installation
                //
                SpPtCheckDynamicVolumeForOSInstallation(pRegion);
            }

            //
            // If this is a 'recognized' partition type, then determine
            // the filesystem on it.  Otherwise use a precanned name.
            // Note that we also determine the file system type if this is an
            // FT partition of type 'mirror', that is not the mirror shadow.
            // We don't care about the shadow since we cannot determine
            // its file system anyway (we can't access sector 0 of the shadow).
            //
            if((PartitionNameIds[SysId] == (UCHAR)(-1)) ||
               ( pRegion->FtPartition ) ||
               ( pRegion->DynamicVolume )
              ) {

                FsType = SpIdentifyFileSystem(
                            HardDisks[DiskNumber].DevicePath,
                            HardDisks[DiskNumber].Geometry.BytesPerSector,
                            SpPtGetOrdinal(pRegion,PartitionOrdinalOnDisk)
                            );

                NameId = SP_TEXT_FS_NAME_BASE + FsType;

                pRegion->Filesystem = FsType;

            } else {

                NameId = SP_TEXT_PARTITION_NAME_BASE + (ULONG)PartitionNameIds[SysId];
            }

            //
            // Get the final type name from the resources.
            //
            SpFormatMessage(
                pRegion->TypeName,
                sizeof(pRegion->TypeName),
                NameId
                );
        }
    }
}

#endif // ! NEW_PARTITION_ENGINE


VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    )
{
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    ULONG r;
    NTSTATUS Status;
    WCHAR Buffer[512];
    struct LABEL_BUFFER {
        FILE_FS_VOLUME_INFORMATION VolumeInfo;
        WCHAR Label[256];
        } LabelBuffer;
    PFILE_FS_VOLUME_INFORMATION LabelInfo;
#ifdef _X86_
    static BOOLEAN LookForUndelete = TRUE;
    PWSTR UndeleteFiles[1] = { L"SENTRY" };
#endif
    PWSTR LocalSourceFiles[1] = { LocalSourceDirectory };
    ULONG ExtraSpace;

    //
    // Assume unknown.
    //
    pRegion->FreeSpaceKB = SPPT_REGION_FREESPACE_KB(pRegion);
    pRegion->AdjustedFreeSpaceKB = pRegion->FreeSpaceKB;
    pRegion->BytesPerCluster = (ULONG)(-1);

    //
    // If region is free space of an unknown type, skip it.
    //
    if(pRegion->Filesystem >= FilesystemFirstKnown) {

        //
        // Form the name of the root directory.
        //
        SpNtNameFromRegion(pRegion,Buffer,sizeof(Buffer),PartitionOrdinalCurrent);
        SpConcatenatePaths(Buffer,L"");

        //
        // Delete \pagefile.sys if it's there.  This makes disk free space
        // calculations a little easier.
        //
        SpDeleteFile(Buffer,L"pagefile.sys",NULL);

#ifdef _X86_
        //
        // Check to see if Undelete (dos 6) delete sentry or delete tracking
        // methods are in use.  If so, give a warning because the free space
        // value we will display for this drive will be off.
        //
        if(LookForUndelete
        && (pRegion->Filesystem == FilesystemFat)
        && SpNFilesExist(Buffer,UndeleteFiles,ELEMENT_COUNT(UndeleteFiles),TRUE)) {

           SpDisplayScreen(SP_SCRN_FOUND_UNDELETE,3,HEADER_HEIGHT+1);
           SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
           SpInputDrain();
           while(SpInputGetKeypress() != ASCI_CR) ;
           LookForUndelete = FALSE;
        }
#endif

        //
        // If this is a winnt setup, then look for the local source
        // on this drive if we haven't found it already.
        //
        if(WinntSetup && !WinntFromCd && !LocalSourceRegion
        && SpNFilesExist(Buffer,LocalSourceFiles,ELEMENT_COUNT(LocalSourceFiles),TRUE)) {

            PWSTR SifName;
            PVOID SifHandle;
            ULONG ErrorLine;
            NTSTATUS Status;
            PWSTR p;

            LocalSourceRegion = pRegion;
            pRegion->IsLocalSource = TRUE;

            ExtraSpace = 0;

            //
            // Open the small ini file that text setup put there to tell us
            // how much space is taken up by the local source.
            //
            wcscpy(TemporaryBuffer,Buffer);
            SpConcatenatePaths(TemporaryBuffer,LocalSourceDirectory);
            SpConcatenatePaths(TemporaryBuffer,L"size.sif");

            SifName = SpDupStringW(TemporaryBuffer);

            Status = SpLoadSetupTextFile(SifName,NULL,0,&SifHandle,&ErrorLine,TRUE,FALSE);
            if(NT_SUCCESS(Status)) {
                p = SpGetSectionKeyIndex(SifHandle,L"Data",L"Size",0);
                if(p) {
                    ExtraSpace = (ULONG)SpStringToLong(p,NULL,10);
                }
                SpFreeTextFile(SifHandle);
            }

            SpMemFree(SifName);

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws is the local source (occupying %lx bytes)\n",Buffer,ExtraSpace));
        }

        //
        // Open the root directory on the partition's filesystem.
        //
        INIT_OBJA(&Obja,&UnicodeString,Buffer);
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_READ,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",Buffer,Status));
            //pRegion->Filesystem = FilesystemUnknown;
            return;
        }

        //
        // Fetch volume size info.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo),
                    FileFsSizeInformation
                    );

        if(NT_SUCCESS(Status)) {

            LARGE_INTEGER FreeBytes;
            LARGE_INTEGER AdjustedFreeBytes;

            //
            // Calculate the amount of free space on the drive.
            // Use the Rtl multiply routine because there is a compiler
            // problem/chip errata on MIPS with 64-bit arithmetic
            // (tedm 2/28/96).
            //
            FreeBytes = RtlExtendedIntegerMultiply(
                            SizeInfo.AvailableAllocationUnits,
                            SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                            );

            AdjustedFreeBytes = FreeBytes;
            if(pRegion->IsLocalSource) {
                //
                // Only about 1/4 of the total space is moved during textmode.
                // Remember too that gui-mode copies the files, so only 25%
                // of this space is reusable during setup...
                //
                AdjustedFreeBytes.QuadPart += (ExtraSpace >> 2);
            }

            //
            // convert this to a number of KB.
            //
            pRegion->FreeSpaceKB = RtlExtendedLargeIntegerDivide(FreeBytes,1024,&r).LowPart;
            if(r >= 512) {
                pRegion->FreeSpaceKB++;
            }
            pRegion->AdjustedFreeSpaceKB = RtlExtendedLargeIntegerDivide(AdjustedFreeBytes,1024,&r).LowPart;
            if(r >= 512) {
                pRegion->AdjustedFreeSpaceKB++;
            }

            pRegion->BytesPerCluster = SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector;

            if( pRegion->Filesystem == FilesystemDoubleSpace ) {
                //
                //  If this the regison is a double space drive, then initialize
                //  sector count correctly, so that the drive size can be calculated
                //  correctly later on.
                //
                pRegion->SectorCount = (ULONG)(   SizeInfo.TotalAllocationUnits.QuadPart
                                                * SizeInfo.SectorsPerAllocationUnit
                                              );
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwQueryVolumeInformationFile for freespace failed (%lx)\n",Status));
        }

        //
        // Fetch volume label info.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &LabelBuffer,
                    sizeof(LabelBuffer),
                    FileFsVolumeInformation
                    );

        if(NT_SUCCESS(Status)) {

            ULONG SaveCharCount;

            LabelInfo = &LabelBuffer.VolumeInfo;

            //
            // We'll only save away the first <n> characters of
            // the volume label.
            //
            SaveCharCount = min(
                                LabelInfo->VolumeLabelLength + sizeof(WCHAR),
                                sizeof(pRegion->VolumeLabel)
                                )
                          / sizeof(WCHAR);

            if(SaveCharCount) {
                SaveCharCount--;  // allow for terminating NUL.
            }

            wcsncpy(pRegion->VolumeLabel,LabelInfo->VolumeLabel,SaveCharCount);
            pRegion->VolumeLabel[SaveCharCount] = 0;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwQueryVolumeInformationFile for label failed (%lx)\n",Status));
        }

        ZwClose(Handle);
    }
}


VOID
SpPtDetermineVolumeFreeSpace(
    IN ULONG DiskNumber
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    unsigned pass;
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    PDISK_REGION CompressedDrive;
#endif // FULL_DOUBLE_SPACE_SUPPORT

    pDisk = &PartitionedDisks[DiskNumber];

    for(pass=0; pass<2; pass++) {

        pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
        for( ; pRegion; pRegion=pRegion->Next) {

            SpPtDetermineRegionSpace( pRegion );
#ifdef FULL_DOUBLE_SPACE_SUPPORT
            if( ( pRegion->Filesystem == FilesystemFat ) &&
                ( pRegion->NextCompressed != NULL ) ) {
                //
                // If the region is a FAT partition that contains compressed
                // volumes, then determine the available space on each
                // compressed volume
                //
                for( CompressedDrive = pRegion->NextCompressed;
                     CompressedDrive;
                     CompressedDrive = CompressedDrive->NextCompressed ) {
                    SpPtDetermineRegionSpace( CompressedDrive );
                }
            }
#endif // FULL_DOUBLE_SPACE_SUPPORT
        }
    }
}

#ifdef OLD_PARTITION_ENGINE

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    if(!SpIsArc()) {
        //
        // NEC98 must not write boot.ini on C:
        //
        if (!IsNEC_98) { //NEC98
            PDISK_REGION pRegion;
            ULONG Disk0Ordinal = SpDetermineDisk0();

            //
            // Note: On X86 we currently don't allow system partitions to reside
            // on GPT disks
            //            
            if (SPPT_IS_MBR_DISK(Disk0Ordinal)) {
                //
                // On x86 machines, we will mark any primary partitions on drive 0
                // as system partition, since such a partition is potentially bootable.
                //
                for(pRegion=PartitionedDisks[Disk0Ordinal].PrimaryDiskRegions; 
                    pRegion; 
                    pRegion=pRegion->Next) {
                    //
                    // Skip if free space or extended partition.
                    //
                    if(pRegion->PartitionedSpace && 
                        !IsContainerPartition(SpPtGetPartitionType(pRegion)) &&
                        (pRegion->ExtendedType == 0)) {
                        //
                        // It's a primary partition -- declare it a system partition.
                        //
                        pRegion->IsSystemPartition = TRUE;
                    }
                }
            }
        }            
    } else {
        PDISK_REGION        pRegion;
        PPARTITIONED_DISK   pDisk;
        unsigned pass;
        ULONG disk;
        PSP_BOOT_ENTRY BootEntry;

        //
        // On ARC machines, system partitions are specifically enumerated
        // in the NVRAM boot environment.
        //

        for(disk=0; disk<HardDiskCount; disk++) {

            if (SPPT_IS_GPT_DISK(disk)) {
#ifndef OLD_PARTITION_ENGINE            
                SpPtnLocateDiskSystemPartitions(disk);
#endif                
            } else {                
                pDisk = &PartitionedDisks[disk];

                for(pass=0; pass<2; pass++) {
                    pRegion = pass ? 
                        pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
                    
                    for( ; pRegion; pRegion=pRegion->Next) {
                        UCHAR SystemId = SpPtGetPartitionType(pRegion);
                        
                        //
                        // Skip if not a partition or extended partition.
                        //
                        if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                            //
                            // Get the nt pathname for this region.
                            //
                            SpNtNameFromRegion(
                                pRegion,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                PartitionOrdinalOriginal
                                );

                            //
                            // Determine if it is a system partition.
                            //
                            for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                                if((BootEntry->LoaderPartitionNtName != NULL) &&
                                   !_wcsicmp(BootEntry->LoaderPartitionNtName,TemporaryBuffer)) {
                                    pRegion->IsSystemPartition = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                }
            }                
        }
    }
}

#endif


VOID
SpPtReadPartitionTables(
    IN PPARTITIONED_DISK pDisk
    )

/*++

Routine Description:

    Read partition tables from a given disk.

Arguments:

    pDisk - supplies pointer to disk descriptor to be filled in.

Return Value:

    None.

--*/

{
    NTSTATUS        Status;
    HANDLE          Handle;
    PUCHAR          Buffer;
    PUCHAR          UnalignedBuffer;
    PON_DISK_MBR    pBr;
    BOOLEAN         InMbr;
    ULONG           ExtendedStart;
    ULONG           NextSector;
    PMBR_INFO       pEbr,pLastEbr;
    BOOLEAN         FoundLink;
    ULONG           i,x;
    BOOLEAN         Ignore;
    ULONG           bps;
    ULONG           SectorsInBootrec;

    //
    // If this disk is off-line, nothing to do.
    //
    if(pDisk->HardDisk->Status != DiskOnLine) {
        return;
    }

    //
    // Open partition 0 of this disk.
    //
    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,FALSE);

    if(!NT_SUCCESS(Status)) {
        pDisk->HardDisk->Status = DiskOffLine;
        return;
    }

    bps = pDisk->HardDisk->Geometry.BytesPerSector;
    if (!IsNEC_98) { //NEC98
        SectorsInBootrec = (512/bps) ? (512/bps) : 1;
    } else {
        // we read two sectors because 0 sector include BootCode , 1 sector include
        // PatitionTables. (In AT Machine,0 sector include BootCode and PartitionTable.)
        SectorsInBootrec = 2;
    } //NEC98

    //
    // Allocate and align a buffer for sector i/o.
    //
    // MBR size is not 512 on NEC98.
    //
    if (!IsNEC_98) {
        ASSERT(sizeof(ON_DISK_MBR)==512);
    }
    UnalignedBuffer = SpMemAlloc(2 * SectorsInBootrec * bps);
    Buffer = ALIGN(UnalignedBuffer,bps);

    //
    // Read the MBR (sector 0).
    //
    NextSector = 0;
#ifdef _X86_
    readmbr:
#endif
    Status = SpReadWriteDiskSectors(Handle,NextSector,SectorsInBootrec,bps,Buffer,FALSE);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read mbr for disk %ws (%lx)\n",pDisk->HardDisk->DevicePath,Status));

        pDisk->HardDisk->Status = DiskOffLine;
        ZwClose(Handle);
        SpMemFree(UnalignedBuffer);
        return;
    }

    //
    // Move the data we just read into the partitioned disk descriptor.
    //
    if (!IsNEC_98) { //NEC98
        RtlMoveMemory(&pDisk->MbrInfo.OnDiskMbr,Buffer,sizeof(ON_DISK_MBR));

    } else {

        SpDetermineFormatTypeNec98(pDisk,(PREAL_DISK_MBR_NEC98)Buffer);

        if(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT) {
            //
            // Move the data we just read into the partitioned disk descriptor.
            //
            SpTranslateMbrInfo(&pDisk->MbrInfo.OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);

        } else {
            //
            // Translate patririon table information from NEC98 format to PC/AT format.
            //
            ConvertPartitionTable(pDisk,Buffer,bps);

            //
            // Read NTFT Signature at 16th sector to check if hard disk is valid.
            //
            RtlZeroMemory(Buffer,bps);
            SpReadWriteDiskSectors(Handle,16,1,bps,Buffer,FALSE);

            //
            // check "AA55" at the end of 16th sector.
            //
            if(((PUSHORT)Buffer)[bps/2 - 1] == BOOT_RECORD_SIGNATURE){
                U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = (((PULONG)Buffer)[0]);

            } else {
                U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = 0x00000000;
            }

        }
    } //NEC98

    //
    // If this MBR is not valid, initialize it.  Otherwise, fetch all logical drives
    // (EBR) info as well.
    //
    if(U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) == MBR_SIGNATURE) {

#ifdef _X86_
        //
        // No NEC98 supports EZ Drive.
        //
        if (!IsNEC_98) { //NEC98
            //
            // EZDrive support: if the first entry in the partition table is
            // type 0x55, then the actual partition table is on sector 1.
            //
            // Only for x86 because on non-x86, the firmware can't see EZDrive
            // partitions, so we don't want to install on them!
            //
            if(!NextSector && (pDisk->MbrInfo.OnDiskMbr.PartitionTable[0].SystemId == 0x55)) {
                NextSector = 1;
                pDisk->HardDisk->Int13Hooker = HookerEZDrive;
                goto readmbr;
            }
            //
            // Also check for on-track.
            //
            if(!NextSector && (pDisk->MbrInfo.OnDiskMbr.PartitionTable[0].SystemId == 0x54)) {
                pDisk->HardDisk->Int13Hooker = HookerOnTrackDiskManager;
            }
        } //NEC98
#endif

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup &&
            (U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) == 0)) {

            //
            // Uh, oh, we've got a case where the signature on the disk is 0, which is
            // bad for remote boot because we use 0 as flag for a diskless machine.  Let's
            // write a new signature on the disk.
            //
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = SpComputeSerialNumber();

            RtlMoveMemory(Buffer, &pDisk->MbrInfo.OnDiskMbr, sizeof(ON_DISK_MBR));

            Status = SpReadWriteDiskSectors(Handle,NextSector,SectorsInBootrec,bps,Buffer,TRUE);

            //
            // Ignore the status - if it failed, then it failed. The only thing that will
            // happen is that the user will get a warning that they need to reformat later.
            //
        }
#endif // defined(REMOTE_BOOT)

        pDisk->MbrWasValid = TRUE;

        pBr = &pDisk->MbrInfo.OnDiskMbr;
        InMbr = TRUE;
        ExtendedStart = 0;
        pLastEbr = NULL;

        do {

            //
            // Look at all the entries in the current boot record to see if there
            // is a link entry.
            //
            FoundLink = FALSE;

            for(i=0; i<PTABLE_DIMENSION; i++) {

                if(IsContainerPartition(pBr->PartitionTable[i].SystemId)) {

                    FoundLink = TRUE;
                    NextSector = ExtendedStart + U_ULONG(pBr->PartitionTable[i].RelativeSectors);

                    if(NextSector == 0) {
                        //
                        // Then we've got ourselves one seriously messed up boot record.  We'll
                        // just return, and present this mess as free space.
                        //
                        // NOTE: maybe we should warn the user that we are going to ignore
                        // partitions past this point because the structures are damaged.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Bad partition table for %ws\n",pDisk->HardDisk->DevicePath));
                        ZwClose(Handle);
                        SpMemFree(UnalignedBuffer);
                        return;
                    }

                    pEbr = SpMemAlloc(sizeof(MBR_INFO));
                    ASSERT(pEbr);
                    RtlZeroMemory(pEbr,sizeof(MBR_INFO));

                    //
                    // Sector number on the disk where this boot sector is.
                    //
                    pEbr->OnDiskSector = NextSector;

                    if(InMbr) {
                        ExtendedStart = NextSector;
                        InMbr = FALSE;
                    }

                    //
                    // Read the next boot sector and break out of the loop through
                    // the current partition table.
                    //

                    Status = SpReadWriteDiskSectors(
                                Handle,
                                NextSector,
                                SectorsInBootrec,
                                bps,
                                Buffer,
                                FALSE
                                );

                    if(!IsNEC_98) {
                        RtlMoveMemory(&pEbr->OnDiskMbr,Buffer,sizeof(ON_DISK_MBR));

                    } else {
                        if(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT) {
                            SpTranslateMbrInfo(&pEbr->OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);
                        } else {
                            ConvertPartitionTable(pDisk,Buffer,bps);
                        }
                    }

                    if(!NT_SUCCESS(Status)
                    || (U_USHORT(pEbr->OnDiskMbr.AA55Signature) != MBR_SIGNATURE))
                    {
                        //
                        // NOTE: maybe we should warn the user that we are going to ignore
                        // partitions part this point because we could not read the disk
                        // or the structures are damaged.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read ebr on %ws at sector %lx (%lx)\n",pDisk->HardDisk->DevicePath,NextSector,Status));
                        ZwClose(Handle);
                        if(pLastEbr) {
                            SpMemFree(pEbr);
                        }
                        SpMemFree(UnalignedBuffer);
                        return;
                    }

                    pBr = &pEbr->OnDiskMbr;

                    //
                    // We just read the next boot sector.  If all that boot sector contains
                    // is a link entry, the only thing we need the boot sector for is to find
                    // the next boot sector. This happens when there is free space at the start
                    // of the extended partition.
                    //
                    Ignore = TRUE;
                    for(x=0; x<PTABLE_DIMENSION; x++) {
                        if((pBr->PartitionTable[x].SystemId != PARTITION_ENTRY_UNUSED)
                        && !IsContainerPartition(pBr->PartitionTable[x].SystemId)) {

                            Ignore = FALSE;
                            break;
                        }
                    }

                    //
                    // Link the Ebr into the logical volume list if we're not ignoring it.
                    //
                    if(!Ignore) {
                        if(pLastEbr) {
                            pLastEbr->Next = pEbr;
                        } else {
                            ASSERT(pDisk->FirstEbrInfo.Next == NULL);
                            pDisk->FirstEbrInfo.Next = pEbr;
                        }
                        pLastEbr = pEbr;
                    }

                    break;
                }
            }

        } while(FoundLink);

    } else {

        pDisk->MbrWasValid = FALSE;

        if(!IsNEC_98) {
            RtlZeroMemory(&pDisk->MbrInfo,sizeof(MBR_INFO));

        } else {
            RtlZeroMemory(Buffer,bps*SectorsInBootrec);
            SpTranslateMbrInfo(&pDisk->MbrInfo.OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);
        }

        U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = MBR_SIGNATURE;

        U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = SpComputeSerialNumber();
    }

#if 0
    if (IsNEC_98) { //NEC98
        //
        // Read NTFT Signature at 16th sector to check if hard disk is valid.
        // (I wish to replace below codes by HAL function later.)
        //
        RtlZeroMemory(Buffer,bps);
        SpReadWriteDiskSectors(Handle,
                               16,
                               1,
                               bps,
                               Buffer,
                               FALSE);
        if(((PUSHORT)Buffer)[bps/2 - 1] == BOOT_RECORD_SIGNATURE){
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = (((PULONG)Buffer)[0]);
        } else {
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = 0x00000000;
        }

    } //NEC98
#endif //0

    //
    // Close partition0.
    //
    ZwClose(Handle);

    SpMemFree(UnalignedBuffer);

    return;
}


PDISK_REGION
SpPtAllocateDiskRegionStructure(
    IN ULONG     DiskNumber,
    IN ULONGLONG StartSector,
    IN ULONGLONG SectorCount,
    IN BOOLEAN   PartitionedSpace,
    IN PMBR_INFO MbrInfo,
    IN ULONG     TablePosition
    )

/*++

Routine Description:

    Allcoate and initialize a structure of type DISK_REGION.

Arguments:

    Values to be filled into the fields of the newly allocated
    disk region structure.

Return Value:

    Pointer to new disk region structure.

--*/

{
    PDISK_REGION p;

    p = SpMemAlloc(sizeof(DISK_REGION));
    ASSERT(p);

    if(p) {

        RtlZeroMemory(p,sizeof(DISK_REGION));

        p->DiskNumber       = DiskNumber;
        p->StartSector      = StartSector;
        p->SectorCount      = SectorCount;
        p->PartitionedSpace = PartitionedSpace;
        p->MbrInfo          = MbrInfo;
        p->TablePosition    = TablePosition;
        p->FtPartition      = FALSE;
        p->DynamicVolume    = FALSE;
        p->DynamicVolumeSuitableForOS    = FALSE;
    }

    return(p);
}


VOID
SpPtInsertDiskRegionStructure(
    IN     PDISK_REGION  Region,
    IN OUT PDISK_REGION *ListHead
    )
{
    PDISK_REGION RegionCur,RegionPrev;

    //
    // Insert the region entry into the relevent list of region entries.
    // Note that these lists are kept sorted by start sector.
    //
    if(RegionCur = *ListHead) {

        if(Region->StartSector < RegionCur->StartSector) {

            //
            // Stick at head of list.
            //
            Region->Next = RegionCur;
            *ListHead = Region;

        } else {

            while(1) {

                RegionPrev = RegionCur;
                RegionCur = RegionCur->Next;

                if(RegionCur) {

                    if(RegionCur->StartSector > Region->StartSector) {

                        Region->Next = RegionCur;
                        RegionPrev->Next = Region;
                        break;
                    }

                } else {
                    //
                    // Stick at end of list.
                    //
                    RegionPrev->Next = Region;
                    break;
                }
            }

        }
    } else {
        *ListHead = Region;
    }
}



VOID
SpPtAssignOrdinals(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           InitCurrentOrdinals,
    IN BOOLEAN           InitOnDiskOrdinals,
    IN BOOLEAN           InitOriginalOrdinals
    )
{
    PMBR_INFO pBrInfo;
    ULONG i;
    USHORT ordinal;

    ordinal = 0;

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if((pte->SystemId != PARTITION_ENTRY_UNUSED)
            && !IsContainerPartition(pte->SystemId)) {

                ordinal++;

                if(InitCurrentOrdinals) {
                    pBrInfo->CurrentOrdinals[i]  = ordinal;
                }

                if(InitOnDiskOrdinals) {
                    pBrInfo->OnDiskOrdinals[i] = ordinal;
                }

                if(InitOriginalOrdinals) {
                    pBrInfo->OriginalOrdinals[i] = ordinal;
                }

            } else {

                if(InitCurrentOrdinals) {
                    pBrInfo->CurrentOrdinals[i] = 0;
                }

                if(InitOnDiskOrdinals) {
                    pBrInfo->OnDiskOrdinals[i] = 0;
                }

                if(InitOriginalOrdinals) {
                    pBrInfo->OriginalOrdinals[i] = 0;
                }
            }
        }
    }
}


VOID
SpPtInitializePartitionStructures(
    IN ULONG DiskNumber
    )

/*++

Routine Description:

    Perform additional initialization on the partition structures,
    beyond what has been performed in SpPtReadPartitionTables.

    Specifically, determine partition ordinals, offsets, and sizes.

Arguments:

    DiskNumber - disk ordinal of disk descriptor to be filled in.

Return Value:

    None.

--*/

{
    ULONG  i,pass;
    PMBR_INFO pBrInfo;
    BOOLEAN InMbr;
    ULONGLONG ExtendedStart = 0;
    ULONGLONG ExtendedEnd,ExtendedSize;
    ULONGLONG offset,size;
    ULONG bps;
    PDISK_REGION pRegion,pRegionCur,pRegionPrev;
    PPARTITIONED_DISK pDisk = &PartitionedDisks[DiskNumber];


    //
    // If this disk is off-line, nothing to do.
    //
    if(pDisk->HardDisk->Status != DiskOnLine) {
        return;
    }

    InMbr = TRUE;
    bps = pDisk->HardDisk->Geometry.BytesPerSector;

    //
    // Link the EBR chain to the MBR.
    //
    if(!IsNEC_98 || (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) {
        pDisk->MbrInfo.Next = &pDisk->FirstEbrInfo;
    } else {
        //
        // There are no extended partition on NEC98.
        //
        pDisk->MbrInfo.Next = NULL;;
    } //NEC98

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if(pte->SystemId != PARTITION_ENTRY_UNUSED) {

                if(IsContainerPartition(pte->SystemId)) {

                    //
                    // If we're in the MBR, ExtendedStart will be 0.
                    //
                    offset = ExtendedStart + U_ULONG(pte->RelativeSectors);

                    size   =  U_ULONG(pte->SectorCount);

                    //
                    // Track the start of the extended partition.
                    //

                    if(InMbr) {
                        ExtendedStart = U_ULONG(pte->RelativeSectors);
                        ExtendedEnd   = ExtendedStart + U_ULONG(pte->SectorCount);
                        ExtendedSize  = ExtendedEnd - ExtendedStart;
                    }

                } else {

                    //
                    // In the MBR, the relative sectors field is the sector offset
                    // to the partition.  In EBRs, the relative sectors field is the
                    // number of sectors between the start of the boot sector and
                    // the start of the filesystem data area.  We will consider such
                    // partitions to start with their boot sectors.
                    //
                    offset = InMbr ? U_ULONG(pte->RelativeSectors) : pBrInfo->OnDiskSector;

                    size   = U_ULONG(pte->SectorCount)
                           + (InMbr ? 0 : U_ULONG(pte->RelativeSectors));
                }

                if(InMbr || !IsContainerPartition(pte->SystemId)) {

                    //
                    // Create a region entry for this used space.
                    //
                    pRegion = SpPtAllocateDiskRegionStructure(
                                    DiskNumber,
                                    offset,
                                    size,
                                    TRUE,
                                    pBrInfo,
                                    i
                                    );

                    ASSERT(pRegion);

                    //
                    // Insert the region entry into the relevent list of region entries.
                    // Note that these lists are kept sorted by start sector.
                    //
                    SpPtInsertDiskRegionStructure(
                        pRegion,
                        InMbr ? &pDisk->PrimaryDiskRegions : &pDisk->ExtendedDiskRegions
                        );

                }
            }
        }

        if(InMbr) {
            InMbr = FALSE;
        }
    }


    //
    // Initialize partition ordinals.
    //
    SpPtAssignOrdinals(pDisk,TRUE,TRUE,TRUE);


    //
    // Now go through the regions for this disk and insert free space descriptors
    // where necessary.
    //
    // Pass 0 for the MBR; pass 1 for logical drives.
    //
    for(pass=0; pass<(ULONG)(ExtendedStart ? 2 : 1); pass++) {

        if(pRegionPrev = (pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions)) {

            ULONGLONG EndSector,FreeSpaceSize;

            ASSERT(pRegionPrev->PartitionedSpace);

            //
            // Handle any space occurring *before* the first partition.
            //
            if(pRegionPrev->StartSector != (pass ? ExtendedStart : 0)) {

                ASSERT(pRegionPrev->StartSector > (pass ? ExtendedStart : 0));

                pRegion = SpPtAllocateDiskRegionStructure(
                                DiskNumber,
                                pass ? ExtendedStart : 0,
                                pRegionPrev->StartSector - (pass ? ExtendedStart : 0),
                                FALSE,
                                NULL,
                                0
                                );

                ASSERT(pRegion);

                pRegion->Next = pRegionPrev;
                if(pass) {
                    // extended
                    pDisk->ExtendedDiskRegions = pRegion;
                } else {
                    // mbr
                    pDisk->PrimaryDiskRegions = pRegion;
                }
            }

            pRegionCur = pRegionPrev->Next;

            while(pRegionCur) {

                //
                // If the start of this partition plus its size is less than the
                // start of the next partition, then we need a new region.
                //
                EndSector     = pRegionPrev->StartSector + pRegionPrev->SectorCount;
                FreeSpaceSize = pRegionCur->StartSector - EndSector;

                if((LONG)FreeSpaceSize > 0) {

                    pRegion = SpPtAllocateDiskRegionStructure(
                                    DiskNumber,
                                    EndSector,
                                    FreeSpaceSize,
                                    FALSE,
                                    NULL,
                                    0
                                    );

                    ASSERT(pRegion);

                    pRegionPrev->Next = pRegion;
                    pRegion->Next = pRegionCur;
                }

                pRegionPrev = pRegionCur;
                pRegionCur = pRegionCur->Next;
            }

            //
            // Space at end of disk/extended partition.
            //
            EndSector     = pRegionPrev->StartSector + pRegionPrev->SectorCount;
            FreeSpaceSize = (pass ? ExtendedEnd : pDisk->HardDisk->DiskSizeSectors) - EndSector;

            if((LONG)FreeSpaceSize > 0) {

                pRegionPrev->Next = SpPtAllocateDiskRegionStructure(
                                        DiskNumber,
                                        EndSector,
                                        FreeSpaceSize,
                                        FALSE,
                                        NULL,
                                        0
                                        );

                ASSERT(pRegionPrev->Next);
            }

        } else {
            //
            // Show whole disk/extended partition as free.
            //
            if(pass) {
                //
                // Extended partition.
                //
                ASSERT(ExtendedStart);

                pDisk->ExtendedDiskRegions = SpPtAllocateDiskRegionStructure(
                                                DiskNumber,
                                                ExtendedStart,
                                                ExtendedSize,
                                                FALSE,
                                                NULL,
                                                0
                                                );

                ASSERT(pDisk->ExtendedDiskRegions);

            } else {
                //
                // MBR.
                //
                pDisk->PrimaryDiskRegions = SpPtAllocateDiskRegionStructure(
                                                DiskNumber,
                                                0,
                                                pDisk->HardDisk->DiskSizeSectors,
                                                FALSE,
                                                NULL,
                                                0
                                                );

                ASSERT(pDisk->PrimaryDiskRegions);
            }
        }
    }
}


VOID
SpPtCountPrimaryPartitions(
    IN  PPARTITIONED_DISK pDisk,
    OUT PULONG            TotalPrimaryPartitionCount,
    OUT PULONG            RecognizedPrimaryPartitionCount,
    OUT PBOOLEAN          ExtendedExists
    )
{
    ULONG TotalCount;
    ULONG RecognizedCount;
    ULONG u;
    UCHAR SysId;

    TotalCount = 0;
    RecognizedCount = 0;
    *ExtendedExists = FALSE;

    for(u=0; u<PTABLE_DIMENSION; u++) {

        SysId = pDisk->MbrInfo.OnDiskMbr.PartitionTable[u].SystemId;

        if(SysId != PARTITION_ENTRY_UNUSED) {

            TotalCount++;

            if(IsRecognizedPartition(SysId)
            && !(SysId & VALID_NTFT) && !(SysId & PARTITION_NTFT)) {
                RecognizedCount++;
            }

            if(IsContainerPartition(SysId)) {
                *ExtendedExists = TRUE;
            }
        }
    }

    *TotalPrimaryPartitionCount      = TotalCount;
    *RecognizedPrimaryPartitionCount = RecognizedCount;
}


PDISK_REGION
SpPtLookupRegionByStart(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           ExtendedPartition,
    IN ULONGLONG         StartSector
    )

/*++

Routine Description:

    Locate a disk region, based on its starting sector.
    The starting sector must match the starting sector of an existing
    region EXACTLY for it to be considered a match.

Arguments:

    pDisk - supplies disk on which to look for the region.

    ExtendedPartition - if TRUE, then look in the extended partition to find
        a match.  Otherwise look in the main list.

    StartSector - supplies the sector number of the first sector of the region.

Return Value:

    NULL is region could not be found; otherwise a pointer to the matching
    disk region structure.

--*/

{
    PDISK_REGION Region = NULL;

#ifdef NEW_PARTITION_ENGINE

    ExtendedPartition = FALSE;
    
#else    

#ifdef GPT_PARTITION_ENGINE

    if (pDisk->HardDisk->DiskFormatType == DISK_FORMAT_TYPE_GPT))
        ExtendedPartition = FALSE;
        
#endif  // GPT_PARTITION_ENGINE

#endif  // NEW_PARTITION_ENGINE

    Region = (ExtendedPartition) ? 
                pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;

    while (Region && (StartSector != Region->StartSector)) {
         Region = Region->Next;
    }

    return Region;
}


ULONG
SpPtAlignStart(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  StartSector,
    IN BOOLEAN    ForExtended
    )

/*++

Routine Description:

    Snap a start sector to a cylinder boundary if it is not already
    on a cylinder boundary.  Any alignment that is necessary
    is performed towards the end of the disk.

    If the start sector is on cylinder 0, then alignment is to track 1
    for primary partitions, or to track 0 on cylinder 1 for extended partitions.

Arguments:

    pHardDisk - supplies disk descriptor for disk that the start sector is on.

    StartSector - supplies the sector number of the first sector of the region.

    ForExtended - if TRUE, then align the start sector as appropriate for creating
        an extended partition.  Otherwise align for a pimary partition or logical drive.

Return Value:

    New (aligned) start sector.  May or may not be different than StartSector.

--*/

{
    PDISK_GEOMETRY pGeometry;
    ULONGLONG r;
    ULONGLONG C,H,S;

    pGeometry = &pHardDisk->Geometry;

    //
    // Convert the start sector into cylinder, head, sector address.
    //
    C = StartSector / pHardDisk->SectorsPerCylinder;
    r = StartSector % pHardDisk->SectorsPerCylinder;
    H = r           / pGeometry->SectorsPerTrack;
    S = r           % pGeometry->SectorsPerTrack;

    //
    // Align as necessary.
    //
    if(C) {

        if(H || S) {

            H = S = 0;
            C++;
        }
    } else {

        //
        // Start cylinder is 0.  If the caller wants to create an
        // extended partition, bump the start cylinder up to 1.
        //
        if(ForExtended) {
            C = 1;
            H = S = 0;
        } else {

            if (!IsNEC_98 || (pHardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) { //NEC98
                //
                // Start cylinder is 0 and the caller does not want to
                // create an extended partition.  In this case, we want
                // to start the partition on cylinder 0, track 1.  If the
                // start is beyond this already, start on cylinder 1.
                //
                if((H == 0) || ((H == 1) && !S)) {
                    H = 1;
                    S = 0;
                } else {
                    H = S = 0;
                    C = 1;
                }
            } else {
                //
                // if Start cylinder is 0, force start Cylinder 1.
                //
                C = 1;
                H = S = 0;
            } //NEC98
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "SETUP:SpPtAlignStart():C:%I64d,H:%I64d,S:%I64d\n",
        C, H, S));
                            

    //
    // Now calculate and return the new start sector.
    //
    return (ULONG)((C * pHardDisk->SectorsPerCylinder) + (H * pGeometry->SectorsPerTrack) + S);
}


VOID
SpPtQueryMinMaxCreationSizeMB(
    IN  ULONG   DiskNumber,
    IN  ULONGLONG StartSector,
    IN  BOOLEAN ForExtended,
    IN  BOOLEAN InExtended,
    OUT PULONGLONG  MinSize,
    OUT PULONGLONG  MaxSize,
    OUT PBOOLEAN ReservedRegion
    )

/*++

Routine Description:

    Given the starting sector of an unpartitioned space on a disk,
    determine the minimum and maximum size in megabytes of the partition that can
    be created in the space, taking all alignment and rounding
    requirements into account.

Arguments:

    DiskNumber - ordinal of disk on which partition will be created.

    StartSector - starting sector of an unpartitioned space on the disk.

    ForExtended - if TRUE, then the caller wants to know how large an
        extended partition in that space could be.  This may be smaller
        than the general case, because an extended partition cannot start
        on cylinder 0.

    InExtended - if TRUE, then we want to create a logical drive.  Otherwise
        we want to create a primary (including extended) partition.
        If TRUE, ForExtended must be FALSE.

    MinSize - receives minimum size in megabytes for a partition in the space.

    MaxSize - receives maximum size in megabytes for a partition in the space.

    ReservedRegion - Receives a flag that indicates if the region is entirely
                     in the last cylinder. Because the last cylinder should be
                     reserved for dynamic volumes, this routine will return 0
                     as MaxSize, if the region is in such a cylinder

Return Value:

    None.

--*/

{
    PPARTITIONED_DISK pDisk;
    ULONGLONG AlignedStartSector;
    ULONGLONG AlignedEndSector;
    ULONGLONG SectorCount;
    PDISK_REGION pRegion;
    ULONGLONG MB, ByteSize;
    ULONGLONG Remainder;
    ULONGLONG LeftOverSectors;

    *MinSize = 0;
    *MaxSize = 0;
    *ReservedRegion = FALSE;

    ASSERT(DiskNumber < HardDiskCount);

    if(InExtended) {
        ASSERT(!ForExtended);
    }

    pDisk = &PartitionedDisks[DiskNumber];

    //
    // Look up this region.
    //
    pRegion = SpPtLookupRegionByStart(pDisk, InExtended, StartSector);
    ASSERT(pRegion);
    if(!pRegion) {
        return;
    }

    ASSERT(!pRegion->PartitionedSpace);
    if(pRegion->PartitionedSpace) {
        return;
    }

    //
    // If this is the first free space inside the extended partition
    // we need to decrement the StartSector so that while creating
    // first logical inside the extended we don't create the 
    // logical at one cylinder offset
    //
    if (SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(pRegion) && StartSector) {        
        StartSector--;
    }

    //
    // Align the start to a proper boundary.
    //
    AlignedStartSector = SpPtAlignStart(pDisk->HardDisk,StartSector,ForExtended);

    //
    // Determine the maximum aligned end sector.
    //
    AlignedEndSector = StartSector + pRegion->SectorCount;

    if(LeftOverSectors = AlignedEndSector % pDisk->HardDisk->SectorsPerCylinder) {
        AlignedEndSector -= LeftOverSectors;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is because we should not allow the user to create a partition that contains the last cylinder.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if(!DockableMachine && !SpDrEnabled() && SPPT_IS_MBR_DISK(DiskNumber) && (!pRegion->Next) &&
       (AlignedEndSector >= (pDisk->HardDisk->CylinderCount - 1) * pDisk->HardDisk->SectorsPerCylinder)) {
        
        AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;

        if(AlignedEndSector == AlignedStartSector) {
            //
            // If after alignment, the partition size is zero, then the user was attempting to
            // create a partition in the last cylinder of the disk. Since this cylinder is
            // reserved for LDM (dynamic volume), just return 0 as maximum partition size, and
            // also indicate to the caller that the region is reserved.
            //
            *ReservedRegion = TRUE;
            *MinSize = 0;
            *MaxSize = 0;
            return;
        }
    }

    //
    // Calculate the number of sectors in the properly aligned space.
    //
    SectorCount = AlignedEndSector - AlignedStartSector;

    //
    // Convert sectors to MB.
    //
    ByteSize = SectorCount * pDisk->HardDisk->Geometry.BytesPerSector;
    MB = ByteSize / (1024 * 1024);
    Remainder = ByteSize % (1024 * 1024);

    //
    // If the remainder was greater than or equal to a half meg,
    // bump up the number of megabytes.
    //
    *MaxSize = (MB + ((Remainder >= (512 * 1024)) ? 1 : 0));

    //
    // The mimimum size is one cylinder except that if a cylinder
    // is smaller than 1 meg, the min size is 1 meg.
    //
    ByteSize = pDisk->HardDisk->SectorsPerCylinder *
                pDisk->HardDisk->Geometry.BytesPerSector;

    *MinSize = ByteSize / (1024 * 1024);
    Remainder = ByteSize % (1024 * 1024);

    if((*MinSize == 0) || (Remainder >= (512 * 1024))) {
        (*MinSize)++;
    }
}


ULONGLONG
SpPtSectorCountToMB(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  SectorCount
    )
{
    ULONGLONG ByteCount;
    ULONGLONG MB,r;

    //
    // Calculate the number of bytes that this number of
    // sectors represents.
    //
    ByteCount = (pHardDisk->Geometry.BytesPerSector * SectorCount);

    //
    // Calculate the number of megabytes this represents.
    //
    r = ByteCount % (1024 * 1204);
    MB = ByteCount / (1024 * 1024);

    //
    // Round up if necessary.
    //
    if(r >= (512*1024)) {
        MB++;
    }

    return (MB);
}


VOID
SpPtInitializeCHSFields(
    IN  PHARD_DISK   HardDisk,
    IN  ULONGLONG    AbsoluteStartSector,
    IN  ULONGLONG    AbsoluteSectorCount,
    OUT PON_DISK_PTE pte
    )
{
    ULONGLONG sC,sH,sS,r;
    ULONGLONG eC,eH,eS;
    ULONGLONG LastSector;


    sC = AbsoluteStartSector / HardDisk->SectorsPerCylinder;
    r  = AbsoluteStartSector % HardDisk->SectorsPerCylinder;
    sH = r                   / HardDisk->Geometry.SectorsPerTrack;
    sS = r                   % HardDisk->Geometry.SectorsPerTrack;

    LastSector = AbsoluteStartSector + AbsoluteSectorCount - 1;

    eC = LastSector / HardDisk->SectorsPerCylinder;
    r  = LastSector % HardDisk->SectorsPerCylinder;
    eH = r          / HardDisk->Geometry.SectorsPerTrack;
    eS = r          % HardDisk->Geometry.SectorsPerTrack;

    //
    // If this partition extends past the 1024th cylinder,
    // place reasonable values in the CHS fields.
    //
#if defined(NEC_98) //NEC98
    if (!IsNEC_98 || (HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) { //NEC98
#endif //NEC98
        if(eC >= 1024) {

            sC = 1023;
            sH = HardDisk->Geometry.TracksPerCylinder - 1;
            sS = HardDisk->Geometry.SectorsPerTrack - 1;

            eC = sC;
            eH = sH;
            eS = sS;
        }

        //
        // Pack the CHS values into int13 format.
        //
        pte->StartCylinder =  (UCHAR)sC;
        pte->StartHead     =  (UCHAR)sH;
        pte->StartSector   =  (UCHAR)((sS & 0x3f) | ((sC >> 2) & 0xc0)) + 1;

        pte->EndCylinder   =  (UCHAR)eC;
        pte->EndHead       =  (UCHAR)eH;
        pte->EndSector     =  (UCHAR)((eS & 0x3f) | ((eC >> 2) & 0xc0)) + 1;
#if defined(NEC_98) //NEC98
    } else {
        //
        // No NEC98 have "1024th cylinder limit".
        //
        pte->StartCylinderLow  = (UCHAR)sC;
        pte->StartCylinderHigh = (UCHAR)(sC >> 4);
        pte->StartHead         = (UCHAR)sH;
        pte->StartSector       = (UCHAR)sS;

        pte->EndCylinderLow    = (UCHAR)eC;
        pte->EndCylinderHigh   = (UCHAR)(eC >> 4);
        pte->EndHead           = (UCHAR)eH;
        pte->EndSector         = (UCHAR)eS;
    } //NEC98
#endif //NEC98

}


#ifndef NEW_PARTITION_ENGINE

BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Create a partition in a given free space.
Arguments:

    DiskNumber - supplies the number of the disk on which we are
        creating the partition.

    StartSector - supplies the start sector of the free space in which
        the parititon is to be created.  This must exactly match the
        start sector of the free space, and can be in either the primary
        space list or the list of spaces in the extended partition.

    SizeMB - supplies the size in megabytes of the partition.

    InExtended - if TRUE, then the free space is within the extended partition,
        and thus we are creating a logical drive.  If FALSE, then the free
        space is an ordinary unpartitioned space, and we are creating a
        primary partition.

    SysId - supplies the system id to give the partition.  This may not
        be 5/f (PARTITION_EXTENDED) if InExtended is TRUE or is an extended
        partition already exists.  No other checks are performed on this value.

    ActualDiskRegion - if supplied, receives a pointer to the disk region in which
        the partition was created.

Return Value:

    TRUE if the partition was created successfully.
    FALSE otherwise.

--*/

{
    PPARTITIONED_DISK pDisk;
    ULONGLONG SectorCount;
    ULONGLONG AlignedStartSector;
    ULONGLONG AlignedEndSector;
    PDISK_REGION pRegion,pRegionPrev,pRegionNew,*pRegionHead;
    ULONGLONG LeftOverSectors;
    PMBR_INFO pBrInfo;
    ULONG slot,i,spt;
    PON_DISK_PTE pte;
    ULONGLONG ExtendedStart;
    UCHAR  SysId;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(DiskNumber)) {
        return SpPtnCreate(DiskNumber,
                            StartSector,
                            0,  // SizeInSectors: Not used except in ASR
                            SizeMB,
                            InExtended,
                            TRUE,
                            PartInfo,
                            ActualDiskRegion);
    }                            
#endif                        

    SysId = PartInfo->Mbr.PartitionType;

    //
    // Look up the disk region that describes this free space.
    //
    pDisk = &PartitionedDisks[DiskNumber];
    pRegion = SpPtLookupRegionByStart(pDisk,InExtended,StartSector);
    ASSERT(pRegion);
    if(!pRegion) {
        return(FALSE);
    }

    if(ActualDiskRegion) {
        *ActualDiskRegion = pRegion;
    }

    ASSERT(!pRegion->PartitionedSpace);
    if(pRegion->PartitionedSpace) {
        return(FALSE);
    }

    if(InExtended) {
        ASSERT(!IsContainerPartition(SysId));

        //
        // Locate the start sector of the extended partition.
        //
        for(i=0; i<PTABLE_DIMENSION; i++) {
            if(IsContainerPartition(pDisk->MbrInfo.OnDiskMbr.PartitionTable[i].SystemId)) {
                ExtendedStart = U_ULONG(pDisk->MbrInfo.OnDiskMbr.PartitionTable[i].RelativeSectors);
                break;
            }
        }
        ASSERT(ExtendedStart);
        if(!ExtendedStart) {
            return(FALSE);
        }
    }


    //
    // Determine the number of sectors in the size passed in.
    // Note: the calculation is performed such that intermediate results
    // won't overflow a ULONG.
    //
    SectorCount = SizeMB * ((1024*1024)/pDisk->HardDisk->Geometry.BytesPerSector);

    //
    // Align the start sector.
    //
    AlignedStartSector = SpPtAlignStart(
                            pDisk->HardDisk,
                            StartSector,
                            (BOOLEAN)IsContainerPartition(SysId)
                            );

    //
    // Determine the end sector based on the size passed in.
    //
    AlignedEndSector = AlignedStartSector + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    if(LeftOverSectors = AlignedEndSector % pDisk->HardDisk->SectorsPerCylinder) {
        AlignedEndSector -= LeftOverSectors;
        if(LeftOverSectors > pDisk->HardDisk->SectorsPerCylinder/2) {
            AlignedEndSector += pDisk->HardDisk->SectorsPerCylinder;
        }
    }

    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while(AlignedEndSector > pRegion->StartSector + pRegion->SectorCount) {
        AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() &&
        (AlignedEndSector > (pDisk->HardDisk->CylinderCount - 1) * pDisk->HardDisk->SectorsPerCylinder)
      ) {
            AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: End of partition was aligned down 1 cylinder \n"));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     AlignedStartSector = %lx \n", AlignedStartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     AlignedEndSector   = %lx \n", AlignedEndSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     SectorsPerCylinder = %lx \n", pDisk->HardDisk->SectorsPerCylinder));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     CylinderCount = %lx \n", pDisk->HardDisk->CylinderCount));
    }


    ASSERT((LONG)AlignedEndSector > 0);
    if((LONG)AlignedEndSector < 0) {
        return(FALSE);
    }

    //
    // If we are creating a logical drive, create a new mbr structure
    // for it.
    //

    if(InExtended) {

        //
        // Create a boot record for this new logical drive; use slot #0
        // for the partition entry (and slot #1 for the extended record,
        // if necessary).
        //
        pBrInfo = SpMemAlloc(sizeof(MBR_INFO));
        ASSERT(pBrInfo);
        RtlZeroMemory(pBrInfo,sizeof(MBR_INFO));
        slot = 0;

    } else {

        //
        // Look for a free slot in the MBR's partition table.
        //
        pBrInfo = &pDisk->MbrInfo;
        for(slot=0; slot<PTABLE_DIMENSION; slot++) {

            if(pBrInfo->OnDiskMbr.PartitionTable[slot].SystemId == PARTITION_ENTRY_UNUSED) {
                break;
            }

        }

        if(slot == PTABLE_DIMENSION) {
            ASSERT(0);
            return(FALSE);
        }
    }


    //
    // Initialize the partition table entry.
    //
    spt = pDisk->HardDisk->Geometry.SectorsPerTrack;

    pte = &pBrInfo->OnDiskMbr.PartitionTable[slot];

    pte->ActiveFlag = 0;
    pte->SystemId   = SysId;

    U_ULONG(pte->RelativeSectors) = (ULONG)(InExtended ? spt : AlignedStartSector);

    U_ULONG(pte->SectorCount) = (ULONG)(AlignedEndSector - AlignedStartSector - (InExtended ? spt : 0));

    SpPtInitializeCHSFields(
        pDisk->HardDisk,
        AlignedStartSector + (InExtended ? spt : 0),
        AlignedEndSector - AlignedStartSector - (InExtended ? spt : 0),
        pte
        );

    //
    // If we're in the extended partition we mark all entries in the
    // boot record as dirty. Sometimes there is a turd boot record on
    // the disk already, and by setting all entries to dirty we get
    // the crud cleaned out if necessary. The only entries that should be
    // in an EBR are the type 6 or whatever and a type 5 if there are
    // additional logical drives in the extended partition.
    //
    if(InExtended) {
        for(i=0; i<PTABLE_DIMENSION; i++) {
            pBrInfo->Dirty[i] = TRUE;
        }
    } else {
        pBrInfo->Dirty[slot] = TRUE;
    }

    //
    // Don't zap the first sector of the extended partition,
    // as this wipes out the first logical drive, and precludes
    // access to all logical drives!
    //
    if(!IsContainerPartition(SysId)) {
        pBrInfo->ZapBootSector[slot] = TRUE;
    }

    //
    // Find the previous region (ie, the one that points to this one).
    // This region (if it exists) will be partitioned space (otherwise
    // it would have been part of the region we are trying to create
    // a partition in!)
    //
    pRegionHead = InExtended ? &pDisk->ExtendedDiskRegions : &pDisk->PrimaryDiskRegions;

    if(*pRegionHead == pRegion) {
        pRegionPrev = NULL;
    } else {
        for(pRegionPrev = *pRegionHead; pRegionPrev; pRegionPrev = pRegionPrev->Next) {
            if(pRegionPrev->Next == pRegion) {
                ASSERT(pRegionPrev->PartitionedSpace);
                break;
            }
        }
    }

    if(InExtended) {

        PMBR_INFO PrevEbr;

        //
        // The new logical drive goes immediately after the
        // previous logical drive (if any). Remember that if there is
        // a previous region, it will be partitioned space (otherwise
        // it would be a part of the region we are trying to create
        // a partition in).
        //
        PrevEbr = pRegionPrev ? pRegionPrev->MbrInfo : NULL;
        if(PrevEbr) {
            pBrInfo->Next = PrevEbr->Next;
            PrevEbr->Next = pBrInfo;
        } else {
            //
            // No previous EBR or region. This means we are creating
            // a logical drive at the beginning of the extended partition
            // so set the First Ebr pointer to point to the new Ebr.
            // Note that this does not mean that the extended partition
            // is empty; the Next pointer in the new Ebr structure is
            // set later.
            //
            pDisk->FirstEbrInfo.Next = pBrInfo;
            if(pRegion->Next) {
                //
                // If there is a region following the one we're creating
                // the partition in, it must be partitioned space, or else
                // it would be part of the region we're creating the partition in.
                //
                ASSERT(pRegion->Next->PartitionedSpace);
                ASSERT(pRegion->Next->MbrInfo);
                pBrInfo->Next = pRegion->Next->MbrInfo;
            } else {
                //
                // No more partitioned space in the extended partition;
                // the logical drive we are creating is the only one.
                //
                pBrInfo->Next = NULL;
            }
        }

        pBrInfo->OnDiskSector = AlignedStartSector;

        //
        // Create a link entry in the previous logical drive (if any).
        //
        if(PrevEbr) {

            //
            // If there is a link entry in there already, blow it away.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {
                if(IsContainerPartition(PrevEbr->OnDiskMbr.PartitionTable[i].SystemId)) {
                    RtlZeroMemory(&PrevEbr->OnDiskMbr.PartitionTable[i],sizeof(ON_DISK_PTE));
                    PrevEbr->Dirty[i] = TRUE;
                    break;
                }
            }

            //
            // Find a free slot for the link entry.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                pte = &PrevEbr->OnDiskMbr.PartitionTable[i];

                if(pte->SystemId == PARTITION_ENTRY_UNUSED) {

                    pte->SystemId = PARTITION_EXTENDED;
                    pte->ActiveFlag = 0;

                    U_ULONG(pte->RelativeSectors) = (ULONG)(AlignedStartSector - ExtendedStart);

                    U_ULONG(pte->SectorCount) = (ULONG)(AlignedEndSector - AlignedStartSector);

                    SpPtInitializeCHSFields(
                        pDisk->HardDisk,
                        AlignedStartSector,
                        U_ULONG(pte->SectorCount),
                        pte
                        );

                    PrevEbr->Dirty[i] = TRUE;

                    break;
                }
            }
        }

        //
        // Create a link entry in this new logical drive if necessary.
        //
        if(pBrInfo->Next) {

            //
            // Find the next entry's logical drive.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                if((pBrInfo->Next->OnDiskMbr.PartitionTable[i].SystemId != PARTITION_ENTRY_UNUSED)
                && !IsContainerPartition(pBrInfo->Next->OnDiskMbr.PartitionTable[i].SystemId))
                {
                    pte = &pBrInfo->OnDiskMbr.PartitionTable[1];

                    pte->SystemId = PARTITION_EXTENDED;
                    pte->ActiveFlag = 0;

                    U_ULONG(pte->RelativeSectors) = (ULONG)(pBrInfo->Next->OnDiskSector - ExtendedStart);

                    U_ULONG(pte->SectorCount) = U_ULONG(pBrInfo->Next->OnDiskMbr.PartitionTable[i].RelativeSectors)
                                              + U_ULONG(pBrInfo->Next->OnDiskMbr.PartitionTable[i].SectorCount);

                    SpPtInitializeCHSFields(
                        pDisk->HardDisk,
                        pBrInfo->Next->OnDiskSector,
                        U_ULONG(pte->SectorCount),
                        pte
                        );

                    break;
                }
            }
        }
    }

    //
    // If we just created a new extended partition, we need to
    // create a blank region descriptor for it in the extended region list.
    //
    if(!InExtended && IsContainerPartition(SysId)) {

        ASSERT(pDisk->ExtendedDiskRegions == NULL);

        pDisk->ExtendedDiskRegions = SpPtAllocateDiskRegionStructure(
                                        DiskNumber,
                                        AlignedStartSector,
                                        AlignedEndSector - AlignedStartSector,
                                        FALSE,
                                        NULL,
                                        0
                                        );

        ASSERT(pDisk->ExtendedDiskRegions);
    }

    //
    // Create a new disk region for the new free space at the
    // beginning and end of the free space, if any.
    //
    if(AlignedStartSector - pRegion->StartSector) {

        pRegionNew = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        pRegion->StartSector,
                        AlignedStartSector - pRegion->StartSector,
                        FALSE,
                        NULL,
                        0
                        );

        ASSERT(pRegionNew);

        if(pRegionPrev) {
            pRegionPrev->Next = pRegionNew;
        } else {
            *pRegionHead = pRegionNew;
        }
        pRegionNew->Next = pRegion;
    }

    if(pRegion->StartSector + pRegion->SectorCount - AlignedEndSector) {

        pRegionNew = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        AlignedEndSector,
                        pRegion->StartSector + pRegion->SectorCount - AlignedEndSector,
                        FALSE,
                        NULL,
                        0
                        );

        pRegionNew->Next = pRegion->Next;
        pRegion->Next = pRegionNew;
    }

    //
    // Adjust the current disk region.
    //
    pRegion->StartSector      = AlignedStartSector;
    pRegion->SectorCount      = AlignedEndSector - AlignedStartSector;
    pRegion->PartitionedSpace = TRUE;
    pRegion->TablePosition    = slot;
    pRegion->MbrInfo          = pBrInfo;

    pRegion->VolumeLabel[0] = 0;
    pRegion->Filesystem = FilesystemNewlyCreated;
    pRegion->FreeSpaceKB = (ULONG)(-1);
    pRegion->AdjustedFreeSpaceKB = (ULONG)(-1);
    SpFormatMessage(
        pRegion->TypeName,
        sizeof(pRegion->TypeName),
        SP_TEXT_FS_NAME_BASE + pRegion->Filesystem
        );

    SpPtCommitChanges(DiskNumber,(PUCHAR)&i);

    //
    // Adjust partition ordinals on this disk.
    //
    SpPtAssignOrdinals(pDisk,FALSE,FALSE,FALSE);

    //
    // Get the nt pathname for this region.
    //
    if (!IsContainerPartition(SysId)) {
        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        //
        //  Assign a drive letter for this region
        //
        if (!SpDrEnabled()) {
            pRegion->DriveLetter = SpGetDriveLetter( TemporaryBuffer, NULL );
            if (pRegion->DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpGetDriveLetter failed on %ls\n", TemporaryBuffer));
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (InExtended)? L"Extended" : L"Primary", pRegion->DriveLetter));
            }
        }
    }

    return(TRUE);
}


BOOLEAN
SpPtDelete(
    IN ULONG   DiskNumber,
    IN ULONGLONG  StartSector
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion,pRegionPrev,*pRegionHead,pRegionNext;
    BOOLEAN InExtended;
    PON_DISK_PTE pte;
    PMBR_INFO pEbrPrev,pEbr;
    ULONG i,j;
    PHARD_DISK pHardDisk;
    ULONG PartitionOrdinal;
    NTSTATUS Status;
    HANDLE Handle;


#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(DiskNumber))
        return SpPtnDelete(DiskNumber, StartSector);
        
#endif

    //
    // First try to look up this region in the extended partition.
    // If we can find it, assume it's a logical drive.
    //
    pDisk = &PartitionedDisks[DiskNumber];
    pRegion = SpPtLookupRegionByStart(pDisk,TRUE,StartSector);
    if(pRegion && pRegion->PartitionedSpace) {
        InExtended = TRUE;
    } else {
        InExtended = FALSE;
        pRegion = SpPtLookupRegionByStart(pDisk,FALSE,StartSector);
    }

    ASSERT(pRegion);
    if(!pRegion) {
        return(FALSE);
    }

    ASSERT(pRegion->PartitionedSpace);
    if(!pRegion->PartitionedSpace) {
        return(FALSE);
    }

    //
    // At this point, we dismount the volume (if it's not newly created),
    // so we don't run into problems later on when we go to format
    //
    if(pRegion->Filesystem > FilesystemNewlyCreated) {

        pHardDisk = &HardDisks[pRegion->DiskNumber];
        PartitionOrdinal = SpPtGetOrdinal(pRegion, PartitionOrdinalOnDisk);

        //
        // Open the partition for read/write access.
        // This shouldn't lock the volume so we need to lock it below.
        //
        Status = SpOpenPartition(
                    pHardDisk->DevicePath,
                    PartitionOrdinal,
                    &Handle,
                    TRUE
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpPtDelete: unable to open %ws partition %u (%lx)\n",
                pHardDisk->DevicePath,
                PartitionOrdinal,
                Status
                ));
            goto AfterDismount;
        }

        //
        //  Lock the drive.
        //
        Status = SpLockUnlockVolume(Handle, TRUE);

        //
        //  We shouldn't have any file opened that would cause this volume
        //  to already be locked, so if we get failure (ie, STATUS_ACCESS_DENIED)
        //  something is really wrong.  This typically indicates something is
        //  wrong with the hard disk that won't allow us to access it.
        //
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to lock drive\n", Status));
            ZwClose(Handle);
            goto AfterDismount;
        }

        //
        // Dismount the drive
        //
        Status = SpDismountVolume(Handle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to dismount drive\n", Status));
            SpLockUnlockVolume(Handle, FALSE);
            ZwClose(Handle);
            goto AfterDismount;
        }

        //
        // Unlock the drive
        //
        Status = SpLockUnlockVolume(Handle, FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to unlock drive\n", Status));
        }

        ZwClose(Handle);
    }

AfterDismount:
    //
    // Find the previous region (ie, the one that points to this one).
    //
    pRegionHead = InExtended ? &pDisk->ExtendedDiskRegions : &pDisk->PrimaryDiskRegions;

    if(*pRegionHead == pRegion) {
        pRegionPrev = NULL;
    } else {
        for(pRegionPrev = *pRegionHead; pRegionPrev; pRegionPrev = pRegionPrev->Next) {
            if(pRegionPrev->Next == pRegion) {
                break;
            }
        }
    }

    //
    // Additional processing for logical drives.
    //
    if(InExtended) {

        //
        // Locate the previous and next logical drives (if any).
        //
        pEbr = pRegion->MbrInfo;

        for(pEbrPrev=pDisk->FirstEbrInfo.Next; pEbrPrev; pEbrPrev=pEbrPrev->Next) {
            if(pEbrPrev->Next == pEbr) {
                break;
            }
        }

        //
        // If there is a previous logical drive, blow aways its link
        // entry, because it points to the logical drive we're deleting.
        //
        if(pEbrPrev) {

            for(i=0; i<PTABLE_DIMENSION; i++) {

                pte = &pEbrPrev->OnDiskMbr.PartitionTable[i];

                if(IsContainerPartition(pte->SystemId)) {

                    RtlZeroMemory(pte,sizeof(ON_DISK_PTE));
                    pEbrPrev->Dirty[i] = TRUE;
                    break;
                }
            }
        }

        //
        // If there is a next logical drive and a previous logical drive,
        // set a new link entry in previous logical drive to point to
        // the next logical drive.
        //
        if(pEbrPrev && pEbr->Next) {

            //
            // Locate the link entry in the logical drive being deleted.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                if(IsContainerPartition(pEbr->OnDiskMbr.PartitionTable[i].SystemId)) {

                    //
                    // Locate an empty slot in the previous logical drive's boot record
                    // and copy the link entry
                    //
                    for(j=0; j<PTABLE_DIMENSION; j++) {
                        if(pEbrPrev->OnDiskMbr.PartitionTable[j].SystemId == PARTITION_ENTRY_UNUSED) {

                            //
                            // Copy the link entry and mark the new link entry dirty
                            // so it gets updated on-disk. We do this even though on the
                            // typical disk it will have been marked dirty above. This one here
                            // handles the case of a wierd situation where the type 6/7/whatever
                            // is in slot 0 and the link entry was in slot 2 or 3. In that case,
                            // the RtlZeroMemory code above will have cleaned out a slot that is
                            // different than the one we're using here for the new link entry.
                            //
                            RtlMoveMemory(
                                &pEbrPrev->OnDiskMbr.PartitionTable[j],
                                &pEbr->OnDiskMbr.PartitionTable[i],
                                sizeof(ON_DISK_PTE)
                                );

                            pEbrPrev->Dirty[j] = TRUE;

                            break;
                        }
                    }
                    break;
                }
            }
        }

        //
        // Remove the EBR for this logical drive.
        //
        if(pEbrPrev) {
            pEbrPrev->Next = pEbr->Next;
        } else {
            ASSERT(pDisk->FirstEbrInfo.Next == pEbr);
            pDisk->FirstEbrInfo.Next = pEbr->Next;
        }

        SpMemFree(pEbr);

    } else {

        ASSERT(pRegion->MbrInfo == &pDisk->MbrInfo);

        pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];

        ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);

        //
        // Mark the entry dirty in the MBR.
        //
        pDisk->MbrInfo.Dirty[pRegion->TablePosition] = TRUE;

        //
        // If this is the extended partition, verify that it is empty.
        //
        if(IsContainerPartition(pte->SystemId)) {
            ASSERT(pDisk->ExtendedDiskRegions);
            ASSERT(pDisk->ExtendedDiskRegions->PartitionedSpace == FALSE);
            ASSERT(pDisk->ExtendedDiskRegions->Next == NULL);
            ASSERT(pDisk->FirstEbrInfo.Next == NULL);

            if(pDisk->ExtendedDiskRegions->Next || pDisk->FirstEbrInfo.Next) {
                return(FALSE);
            }

            //
            // Free the single disk region that covers the entire extended partition.
            //
            SpMemFree(pDisk->ExtendedDiskRegions);
            pDisk->ExtendedDiskRegions = NULL;
        }

        //
        // Adjust the PTE for this partition by zeroing it out.
        //
        RtlZeroMemory(pte,sizeof(ON_DISK_PTE));
    }


    //
    // Adjust fields in the region to describe this space as free.
    //
    pRegion->MbrInfo->ZapBootSector[pRegion->TablePosition] = FALSE;
    pRegion->PartitionedSpace = FALSE;
    pRegion->MbrInfo = NULL;
    pRegion->TablePosition = 0;
    pRegion->DriveLetter = L'\0';

    //
    // If previous region is free space, coalesce it and the region
    // we just made free.
    //
    if(pRegionPrev && !pRegionPrev->PartitionedSpace) {

        PDISK_REGION p;

        ASSERT(pRegionPrev->StartSector + pRegionPrev->SectorCount == pRegion->StartSector);

        pRegion->SectorCount = pRegion->StartSector + pRegion->SectorCount - pRegionPrev->StartSector;
        pRegion->StartSector = pRegionPrev->StartSector;

        //
        // Delete the previous region.
        //
        if(pRegionPrev == *pRegionHead) {
            //
            // The previous region was the first region.
            //
            *pRegionHead = pRegion;
        } else {

            for(p = *pRegionHead; p; p=p->Next) {
                if(p->Next == pRegionPrev) {
                    ASSERT(p->PartitionedSpace);
                    p->Next = pRegion;
                    break;
                }
            }
        }

        SpMemFree(pRegionPrev);
    }

    //
    // If the next region is free space, coalesce it and the region
    // we just made free.
    //
    if((pRegionNext = pRegion->Next) && !pRegionNext->PartitionedSpace) {

        ASSERT(pRegion->StartSector + pRegion->SectorCount == pRegionNext->StartSector);

        pRegion->SectorCount = pRegionNext->StartSector + pRegionNext->SectorCount - pRegion->StartSector;

        //
        // Delete the next region.
        //
        pRegion->Next = pRegionNext->Next;
        SpMemFree(pRegionNext);
    }

    SpPtCommitChanges(DiskNumber,(PUCHAR)&i);

    //
    // Adjust the partition ordinals on this disk.
    //
    SpPtAssignOrdinals(pDisk,FALSE,FALSE,FALSE);

    //
    //  No need to reassign drive letters
    //

    return(TRUE);
}

#endif  // !NEW_PARTITION_ENGINE


BOOLEAN
SpPtExtend(
    IN PDISK_REGION Region,
    IN ULONGLONG    SizeMB      OPTIONAL
    )

/*++

Routine Description:

    Extends a partition by claiming any free space immedately following it
    on the disk. The end boundary of the existing partition is adjusted
    so that the partition encompasses the free space.

    The partition may not be the extended partition and it may not be
    a logical drive within the extended partition.

    Note that no filesystem structures are manipulated or examined by
    this routine. Essentially it deals only with the partition table entry.

Arguments:

    Region - supplies the region descriptor for the partition to be
        extended. That partition must not be the extended partition and
        it cannot be a logical drive either.

    SizeMB - if specified, indicates the size in MB by which the partition
        will grow. If not specified, the partition grows to encompass all
        the free space in the adjacent free space.

Return Value:

    Boolean value indicating whether anything actually changed.

--*/

{
    PDISK_REGION NextRegion;
    PPARTITIONED_DISK pDisk;
    PMBR_INFO pBrInfo;
    PON_DISK_PTE pte;
    ULONG BytesPerSector;
    ULONGLONG NewEndSector;
    ULONGLONG SectorCount;
    PVOID UnalignedBuffer;
    PON_DISK_MBR AlignedBuffer;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // We aren't going to support this anymore on NT5.  It's too messy.
    //
    return FALSE;

/*
    pDisk = &PartitionedDisks[Region->DiskNumber];
    BytesPerSector = pDisk->HardDisk->Geometry.BytesPerSector;

    ASSERT(Region->PartitionedSpace);
    if(!Region->PartitionedSpace) {
        return(FALSE);
    }

    pBrInfo = Region->MbrInfo;
    pte = &pBrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];

    //
    // Make sure it's not the extended partition and is not
    // in the extended partition.
    //
    if(pBrInfo->OnDiskSector || IsContainerPartition(pte->SystemId)) {
        return(FALSE);
    }

    //
    // If there's no next region then there's nothing to do.
    // If there is a next region make sure it's empty.
    //
    NextRegion = Region->Next;
    if(!NextRegion) {
        return(FALSE);
    }
    if(NextRegion->PartitionedSpace) {
        return(FALSE);
    }

    //
    // Convert the passed in size to a sector count.
    //
    if(SizeMB) {
        SectorCount = SizeMB * ((1024*1024)/BytesPerSector);
        if(SectorCount > NextRegion->SectorCount) {
            SectorCount = NextRegion->SectorCount;
        }
    } else {
        SectorCount = NextRegion->SectorCount;
    }

    //
    // Claim the part of the free region we need and align the ending sector
    // to a cylinder boundary.
    //
    NewEndSector = NextRegion->StartSector + SectorCount;
    NewEndSector -= NewEndSector % pDisk->HardDisk->SectorsPerCylinder;

    //
    // Fix up the size and end CHS fields in the partition table entry
    // for the partition.
    //
    U_ULONG(pte->SectorCount) = NewEndSector - Region->StartSector;

    SpPtInitializeCHSFields(
        pDisk->HardDisk,
        Region->StartSector,
        NewEndSector - Region->StartSector,
        pte
        );

    //pBrInfo->Dirty[Region->TablePosition] = TRUE;

    //
    // If there is space left over at the end of the free region
    // we just stuck onto the end of the existing partition,
    // adjust the free region's descriptor. Else get rid of it.
    //
    if(NextRegion->StartSector + NextRegion->SectorCount == NewEndSector) {

        Region->Next = NextRegion->Next;
        SpMemFree(NextRegion);

    } else {

        NextRegion->SectorCount = NextRegion->StartSector + NextRegion->SectorCount - NewEndSector;
        NextRegion->StartSector = NewEndSector;
    }

    //
    // Now we have to something tricky. We don't want to inform the disk driver
    // about what we just did because he will delete the device object for
    // the partition, which causes problems the next time we hit the disk, say to
    // page in part of usetup.exe to get a message. We whack the partition table
    // entry directly, knowing that a) we've been called after SpPtCommitChanges
    // and b) no one cares about the new size until after we've rebooted.
    //
    UnalignedBuffer = SpMemAlloc(2*BytesPerSector);
    AlignedBuffer = ALIGN(UnalignedBuffer,BytesPerSector);

    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,TRUE);
    if(NT_SUCCESS(Status)) {

        Status = SpReadWriteDiskSectors(Handle,0,1,BytesPerSector,AlignedBuffer,FALSE);
        if(NT_SUCCESS(Status)) {

            if(!IsNEC_98) {
                RtlMoveMemory(
                    &AlignedBuffer->PartitionTable[Region->TablePosition],
                    &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition],
                    sizeof(ON_DISK_PTE)
                    );

            } else {
                PREAL_DISK_MBR pRealBuffer = (PREAL_DISK_MBR)AlignedBuffer;

                ASSERT(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT);
                SpTranslatePteInfo(
                    &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition],
                    &pRealBuffer->PartitionTable[Region->TablePosition],
                    TRUE
                    );
            }


            Status = SpReadWriteDiskSectors(Handle,0,1,BytesPerSector,AlignedBuffer,TRUE);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't write sector 0, status %lx",Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't read sector 0, status %lx",Status));
        }

        ZwClose(Handle);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't open disk, status %lx",Status));
    }

    SpMemFree(UnalignedBuffer);

    if(!NT_SUCCESS(Status)) {
        FatalPartitionUpdateError(pDisk->HardDisk->Description);
    }

    return(TRUE);
*/    
}


VOID
SpPtMarkActive(
    IN ULONG TablePosition
    )

/*++

Routine Description:

    Mark a partition on drive 0 active, and deactivate all others.

Arguments:

    TablePosition - supplies offset within partition table (0-3)
        of the partition entry to be activated.

Return Value:

    None.

--*/

{
    ULONG i;
    PON_DISK_PTE pte;
    ULONG Disk0Ordinal;

    ASSERT(TablePosition < PTABLE_DIMENSION);

    Disk0Ordinal = SpDetermineDisk0();

    //
    // Deactivate all others.
    //
    for(i=0; i<PTABLE_DIMENSION; i++) {

        pte = &PartitionedDisks[Disk0Ordinal].MbrInfo.OnDiskMbr.PartitionTable[i];

        if((pte->SystemId != PARTITION_ENTRY_UNUSED)
        && pte->ActiveFlag
        && (i != TablePosition))
        {
            pte->ActiveFlag = 0;
            PartitionedDisks[0].MbrInfo.Dirty[i] = TRUE;
        }
    }

    //
    // Activate the one we want to activate.
    //
    pte = &PartitionedDisks[Disk0Ordinal].MbrInfo.OnDiskMbr.PartitionTable[TablePosition];
    ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);
    ASSERT(!IsContainerPartition(pte->SystemId));

// @mtp - Original    ASSERT(( PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) || (pte->SystemId == PARTITION_LDM));

    ASSERT((PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) || (pte->SystemId == PARTITION_LDM) ||
            ( SpDrEnabled() &&
              IsRecognizedPartition(pte->SystemId) &&
              ( ((pte->SystemId & VALID_NTFT) == VALID_NTFT ) ||
                ((pte->SystemId & PARTITION_NTFT) == PARTITION_NTFT)
              )
            )
          );


    if(!pte->ActiveFlag) {
        pte->ActiveFlag = 0x80;
        PartitionedDisks[Disk0Ordinal].MbrInfo.Dirty[TablePosition] = TRUE;
    }
}

#ifndef NEW_PARTITION_ENGINE

NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
{
    PPARTITIONED_DISK pDisk;
    ULONG DiskLayoutSize;
    PDISK_REGION pRegion;
    PMBR_INFO pBrInfo;
    ULONG BootRecordCount;
    BOOLEAN NeedDummyEbr;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    PPARTITION_INFORMATION PartitionInfo;
    ULONG PartitionEntry;
    ULONG bps;
    PON_DISK_PTE pte;
    ULONGLONG ExtendedStart;
    ULONGLONG Offset;
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG i;
    ULONGLONG ZapSector;
    PUCHAR Buffer,UBuffer;
    ULONG NewSig;

    ULONGLONG RewriteSector[PTABLE_DIMENSION]; //NEC98
    ULONG cnt,RewriteCnt=0; //NEC98

#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(DiskNumber))
        return SpPtnCommitChanges(DiskNumber, AnyChanges);

#endif
        

    ASSERT(DiskNumber < HardDiskCount);
    pDisk = &PartitionedDisks[DiskNumber];
    *AnyChanges = FALSE;
    bps = pDisk->HardDisk->Geometry.BytesPerSector;
    ExtendedStart = 0;

    //
    // Determine the number of boot records that will used on this disk.
    // There is one for the MBR, and one for each logical drive.
    //
    BootRecordCount = 1;
    for(pRegion=pDisk->ExtendedDiskRegions; pRegion; pRegion=pRegion->Next) {

        if(pRegion->PartitionedSpace) {
            BootRecordCount++;
        }
    }

    if (IsNEC_98) { //NEC98
        ZapSector = 0;

#if defined(NEC_98) //NEC98
        //
        // Set RealDiskPosition. This value will be valid after changing partition.
        //
        for(i=0,pRegion=pDisk->PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {
            if(pRegion->PartitionedSpace) {
                pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].RealDiskPosition = (UCHAR)i;
                i++;
            }
        }
#endif //NEC98
    } //NEC98

    //
    // Determine whether a dummy boot record is rquired at the start
    // of the extended partition.  This is the case when there is free
    // space at its start.
    //
    if(pDisk->ExtendedDiskRegions
    && !pDisk->ExtendedDiskRegions->PartitionedSpace
    && pDisk->ExtendedDiskRegions->Next)
    {
        NeedDummyEbr = TRUE;
        BootRecordCount++;
        *AnyChanges = TRUE;
    } else {
        NeedDummyEbr = FALSE;
    }

    //
    // Allocate a disk layout structure whose size is based on the
    // number of boot records.  This assumes that the structure contains
    // one partition information structure in its definition.
    //
    DiskLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION)
                   + (BootRecordCount * PTABLE_DIMENSION * sizeof(PARTITION_INFORMATION))
                   - sizeof(PARTITION_INFORMATION);

    DriveLayout = SpMemAlloc(DiskLayoutSize);
    ASSERT(DriveLayout);
    RtlZeroMemory(DriveLayout,DiskLayoutSize);

    //
    // Set up some of the fields of the drive layout structure.
    //
    DriveLayout->PartitionCount =
        (!IsNEC_98) ? (BootRecordCount * sizeof(PTABLE_DIMENSION))
                    : (BootRecordCount * PTABLE_DIMENSION); //NEC98

    //
    // Go through each boot record and initialize the matching
    // partition information structure in the drive layout structure.
    //
    for(PartitionEntry=0,pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {
            pBrInfo->UserData[i] = NULL;
        }

        //
        // If we are going to need a dummy logical drive,
        // leave space for it here.
        //
        if(pBrInfo == &pDisk->FirstEbrInfo) {
            if(NeedDummyEbr) {
                PartitionEntry += PTABLE_DIMENSION;
            }
            continue;
        }

        ASSERT(PartitionEntry < BootRecordCount*PTABLE_DIMENSION);

        for(i=0; i<PTABLE_DIMENSION; i++) {

            //
            // Point to partition information structure within
            // drive layout structure.
            //
            PartitionInfo = &DriveLayout->PartitionEntry[PartitionEntry+i];

            //
            // Transfer this partition table entry
            // into the drive layout structure, field by field.
            //
            pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            //
            // If this is the extended partition, remember where it starts.
            //
            if((pBrInfo == &pDisk->MbrInfo)
            && IsContainerPartition(pte->SystemId)
            && !ExtendedStart)
            {
                ExtendedStart = U_ULONG(pte->RelativeSectors);
            }

            if(pte->SystemId != PARTITION_ENTRY_UNUSED) {

                if(!IsContainerPartition(pte->SystemId)) {
                    pBrInfo->UserData[i] = PartitionInfo;
                }

                //
                // Calculate starting offset.  If we are within
                // the extended parttion and this is a type 5 entry,
                // then the relative sector field counts the number of sectors
                // between the main extended partition's first sector and
                // the logical drive described by this entry.
                // Otherwise, the relative sectors field describes the number
                // of sectors between the boot record and the actual start
                // of the partition.
                //

                if((pBrInfo != &pDisk->MbrInfo) && IsContainerPartition(pte->SystemId)) {
                    ASSERT(ExtendedStart);
                    Offset = ExtendedStart + U_ULONG(pte->RelativeSectors);
                } else {
                    Offset = pBrInfo->OnDiskSector + U_ULONG(pte->RelativeSectors);
                }

                PartitionInfo->StartingOffset.QuadPart = UInt32x32To64(Offset,bps);

                //
                // Calculate size.
                //
                PartitionInfo->PartitionLength.QuadPart = UInt32x32To64(U_ULONG(pte->SectorCount),bps);

                //
                // Store start offset of newly created partition to clear sector later.
                //
                if(IsNEC_98 && pBrInfo->Dirty[i]) {
                    RewriteSector[RewriteCnt++] = Offset;
                }
            }

            //
            // Other fields.
            //
            PartitionInfo->PartitionType = pte->SystemId;
            PartitionInfo->BootIndicator = pte->ActiveFlag;
            PartitionInfo->RewritePartition = pBrInfo->Dirty[i];

            if(pBrInfo->Dirty[i]) {
                *AnyChanges = TRUE;
            }

            pBrInfo->Dirty[i] = FALSE;
        }

        PartitionEntry += PTABLE_DIMENSION;
    }

    //
    // If there are no changes, just return success now.
    //
    if(!(*AnyChanges)) {
        SpMemFree(DriveLayout);
        return(STATUS_SUCCESS);
    }

    //
    // If there is free space at the start of the extended partition,
    // then we need to generate a dummy boot record.
    //
    if(NeedDummyEbr) {

        pRegion = pDisk->ExtendedDiskRegions->Next;

        ASSERT(pRegion->PartitionedSpace);
        ASSERT(pRegion->StartSector == pRegion->MbrInfo->OnDiskSector);
        ASSERT(ExtendedStart == pDisk->ExtendedDiskRegions->StartSector);

        PartitionInfo = &DriveLayout->PartitionEntry[PTABLE_DIMENSION];

        PartitionInfo->StartingOffset.QuadPart = UInt32x32To64(pRegion->StartSector,bps);

        PartitionInfo->PartitionLength.QuadPart = UInt32x32To64(pRegion->SectorCount,bps);

        PartitionInfo->PartitionType = PARTITION_EXTENDED;
        PartitionInfo->RewritePartition = TRUE;
        //
        // Rewrite all other entries to ensure that if there was logica drive (first in the chain)
        // that was deleted, it will really go away. There won't be any effect if we overwrite a
        // logical drive that didn't exist
        //
        for( i = 1; i < PTABLE_DIMENSION; i ++ ) {
            PartitionInfo = &DriveLayout->PartitionEntry[PTABLE_DIMENSION + i];
            PartitionInfo->RewritePartition = TRUE;
        }
    }


    //
    // We now have everything set up. Open partition 0 on the disk.
    //
    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,TRUE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes, unable to open disk %u (%lx)\n",DiskNumber,Status));
        SpMemFree(DriveLayout);
        return(Status);
    }

    //
    // Make sure the mbr is valid before writing the changes.
    // Note that we slam in new boot code whenever any changes have been made.
    // We do this to guaranteee proper support for xint13 booting, etc.
    //

  if (!IsNEC_98) { //NEC98
    //
    // If MBR of target hard disk is invalid, initialize it when select target partition.
    // so don't rewrite MBR now.
    //
    Status = SpMasterBootCode(DiskNumber,Handle,&NewSig);
    if(NT_SUCCESS(Status)) {
        //
        // If a new NTFT signature was generated, propagate it.
        //
        if(NewSig) {
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = NewSig;
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes on disk %u, SpMasterBootCode returns %lx\n",DiskNumber,Status));
        ZwClose(Handle);
        SpMemFree(DriveLayout);
        return(Status);
    }
  } //NEC98

    DriveLayout->Signature = U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature);

#if 0
    //
    //  We dump after the call to the IOCTL because it can change some of the data in the structure,
    //  such as PartitionNumber
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dumping DriveLayout before calling IOCTL_DISK_SET_DRIVE_LAYOUT: \n"));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionCount = %lx\n", DriveLayout->PartitionCount));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->Signature = %lx \n\n", DriveLayout->Signature));
    for(i = 0; i < DriveLayout->PartitionCount; i++) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].StartingOffset = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].StartingOffset.u.HighPart, DriveLayout->PartitionEntry[i].StartingOffset.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionLength = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].PartitionLength.u.HighPart, DriveLayout->PartitionEntry[i].PartitionLength.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].HiddenSectors = 0x%08lx\n", i, DriveLayout->PartitionEntry[i].HiddenSectors));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionNumber = %d\n", i, DriveLayout->PartitionEntry[i].PartitionNumber));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionType = 0x%02x\n", i, DriveLayout->PartitionEntry[i].PartitionType));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].BootIndicator = %ls\n", i, DriveLayout->PartitionEntry[i].BootIndicator? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RecognizedPartition = %ls\n", i, DriveLayout->PartitionEntry[i].RecognizedPartition? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RewritePartition = %ls\n\n", i, DriveLayout->PartitionEntry[i].RewritePartition? L"TRUE" : L"FALSE"));
    }
#endif
    //
    // Write the changes.
    //
    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_SET_DRIVE_LAYOUT,
                DriveLayout,
                DiskLayoutSize,
                DriveLayout,
                DiskLayoutSize
                );

    // Deferred freeing memory till later on because we still need info in this structure (lonnym)
    // SpMemFree(DriveLayout);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes on disk %u, ioctl returns %lx\n",DiskNumber,Status));
        SpMemFree(DriveLayout);
        ZwClose(Handle);
        return(Status);
    }

#if 0
    //
    //  We dump after the call to the IOCTL because it can change some of the data in the structure,
    //  such as PartitionNumber
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Dumping DriveLayout after IOCTL_DISK_SET_DRIVE_LAYOUT was called: \n"));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionCount = %lx\n", DriveLayout->PartitionCount));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->Signature = %lx \n\n", DriveLayout->Signature));
    for(i = 0; i < DriveLayout->PartitionCount; i++) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].StartingOffset = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].StartingOffset.u.HighPart, DriveLayout->PartitionEntry[i].StartingOffset.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionLength = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].PartitionLength.u.HighPart, DriveLayout->PartitionEntry[i].PartitionLength.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].HiddenSectors = 0x%08lx\n", i, DriveLayout->PartitionEntry[i].HiddenSectors));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionNumber = %d\n", i, DriveLayout->PartitionEntry[i].PartitionNumber));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionType = 0x%02x\n", i, DriveLayout->PartitionEntry[i].PartitionType));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].BootIndicator = %ls\n", i, DriveLayout->PartitionEntry[i].BootIndicator? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RecognizedPartition = %ls\n", i, DriveLayout->PartitionEntry[i].RecognizedPartition? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RewritePartition = %ls\n\n", i, DriveLayout->PartitionEntry[i].RewritePartition? L"TRUE" : L"FALSE"));
    }
#endif

    //
    // Allocate a buffer for zapping.
    //
    UBuffer = SpMemAlloc(2*bps);
    ASSERT(UBuffer);
    Buffer = ALIGN(UBuffer,bps);
    RtlZeroMemory(Buffer,bps);

    if (IsNEC_98) { //NEC98
        //
        // Clear 1st sector of target partition.
        //
        for(cnt = 0; cnt < RewriteCnt; cnt++){
            Status = SpReadWriteDiskSectors(Handle,
                                            RewriteSector[cnt],
                                            1,
                                            bps,
                                            Buffer,
                                            TRUE);

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: clear sector %lx on disk %u returned %lx\n",ZapSector,DiskNumber,Status));
                SpMemFree(DriveLayout);
                SpMemFree(UBuffer);
                ZwClose(Handle);
                return(Status);
            }
        }
    } //NEC98

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            //
            // Update current partition ordinals.
            //
            if (IsNEC_98) {
                pte = &pBrInfo->OnDiskMbr.PartitionTable[i];
            }

            if ((!IsNEC_98) ? (pBrInfo->UserData[i]) :
                              (PVOID)(pte->SystemId != PARTITION_ENTRY_UNUSED)) { //NEC98

#if defined(NEC_98) //NEC98
                PartitionInfo = (!IsNEC_98) ? (PPARTITION_INFORMATION)pBrInfo->UserData[i] :
                                              &DriveLayout->PartitionEntry[pte->RealDiskPosition]; //NEC98
#else
                PartitionInfo = (PPARTITION_INFORMATION)pBrInfo->UserData[i];
#endif

                //
                // The partition ordinal better be non-0!
                //
                if(PartitionInfo->PartitionNumber) {

                    //
                    // Update current partition ordinal.
                    //
                    pBrInfo->CurrentOrdinals[i] = (USHORT)PartitionInfo->PartitionNumber;

                } else {
                    SpBugCheck(
                        SETUP_BUGCHECK_PARTITION,
                        PARTITIONBUG_A,
                        DiskNumber,
                        pBrInfo->CurrentOrdinals[i]
                        );
                }
            }

          if (!IsNEC_98) { //NEC98
            //
            // If there were any newly created partitions in this boot record,
            // zap their filesystem boot sectors.
            //
            if(pBrInfo->ZapBootSector[i]) {
                //
                // We shouldn't be zapping any partitions that don't exist.
                //
                ASSERT(pBrInfo->OnDiskMbr.PartitionTable[i].SystemId != PARTITION_ENTRY_UNUSED);

                //
                // This calculation is correct for partitions and logical drives.
                //
                ZapSector = pBrInfo->OnDiskSector
                          + U_ULONG(pBrInfo->OnDiskMbr.PartitionTable[i].RelativeSectors);

                //
                // The consequences for messing up here are so huge that a special check
                // is warranted to make sure we're not clobbering the MBR.
                //
                ASSERT(ZapSector);
                if(ZapSector) {
                    Status = SpReadWriteDiskSectors(
                                Handle,
                                ZapSector,
                                1,
                                bps,
                                Buffer,
                                TRUE
                                );
                } else {
                    Status = STATUS_SUCCESS;
                }

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: zapping sector %lx on disk %u returned %lx\n",ZapSector,DiskNumber,Status));
                    SpMemFree(DriveLayout);
                    SpMemFree(UBuffer);
                    ZwClose(Handle);
                    return(Status);
                }

                pBrInfo->ZapBootSector[i] = FALSE;
            }
          } //NEC98
        }
    }

    SpMemFree(UBuffer);
    ZwClose(Handle);

    //
    // Reassign on-disk ordinals (but not original ones).
    //
    SpPtAssignOrdinals(pDisk,FALSE,TRUE,FALSE);
    if (IsNEC_98) { //NEC98
        //
        // If newly created partition's position is before existing partition,
        // OnDiskOrdinals is not equal number of volume infomation position on NEC98
        //
        SpReassignOnDiskOrdinals(pDisk);
    } //NEC98

    SpMemFree(DriveLayout);

    return(STATUS_SUCCESS);
}

#endif // ! NEW_PARTITION_ENGINE

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    )

/*++

Routine Description:

    Write new master boot code onto a drive.

    If the mbr has a valid signature, the existing partition table
    and NTFT signature are preserved. Otherwise the partition table
    is zeroed out and a new ntft signature is generated.

Arguments:

    DiskNumber - supplies 0-based system ordinal for the disk.

    Partition0Handle - supplies an open handle for partition 0 on
        the disk. The handle must have read and write access.

    NewNTFTSignature - receives a value indicating the new NTFT signature,
        if one was generated and written to the disk. If 0 is received,
        then a new ntft signature was not generated and written.

Return Value:

    NT Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    ULONG BytesPerSector;
    PUCHAR Buffer;
    ULONG SectorCount;
    PON_DISK_MBR Mbr;

    BytesPerSector = HardDisks[DiskNumber].Geometry.BytesPerSector;

    SectorCount = max(1,sizeof(ON_DISK_MBR)/BytesPerSector);

    *NewNTFTSignature = 0;

    //
    // Allocate and align a buffer.
    //
    Buffer = SpMemAlloc(2 * SectorCount * BytesPerSector);
    Mbr = ALIGN(Buffer,BytesPerSector);

    //
    // Read mbr
    //
    Status = SpReadWriteDiskSectors(
                Partition0Handle,
                (HardDisks[DiskNumber].Int13Hooker == HookerEZDrive) ? 1 : 0,
                SectorCount,
                BytesPerSector,
                Mbr,
                FALSE
                );

    if(NT_SUCCESS(Status)) {
        if(U_USHORT(Mbr->AA55Signature) == MBR_SIGNATURE) {
            //
            // Valid. Slam in new boot code if there's no int13 hooker.
            //
            if(HardDisks[DiskNumber].Int13Hooker == NoHooker) {

                ASSERT(&((PON_DISK_MBR)0)->BootCode == 0);
                RtlMoveMemory(Mbr,x86BootCode,sizeof(Mbr->BootCode));

                Status = SpReadWriteDiskSectors(
                            Partition0Handle,
                            0,
                            SectorCount,
                            BytesPerSector,
                            Mbr,
                            TRUE
                            );
            }
        } else {
            //
            // Invalid. Construct a boot sector.
            //
            ASSERT(X86BOOTCODE_SIZE == sizeof(ON_DISK_MBR));

            RtlMoveMemory(Mbr,x86BootCode,X86BOOTCODE_SIZE);

            *NewNTFTSignature = SpComputeSerialNumber();
            U_ULONG(Mbr->NTFTSignature) = *NewNTFTSignature;

            U_USHORT(Mbr->AA55Signature) = MBR_SIGNATURE;

            //
            // Write the sector(s).
            //
            Status = SpReadWriteDiskSectors(
                        Partition0Handle,
                        (HardDisks[DiskNumber].Int13Hooker == HookerEZDrive) ? 1 : 0,
                        SectorCount,
                        BytesPerSector,
                        Mbr,
                        TRUE
                        );

            if (NT_SUCCESS(Status)) {
                PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);

                Disk->Signature = Disk->DriveLayout.Mbr.Signature = *NewNTFTSignature;
            }                
        }
    }

    SpMemFree(Buffer);

    return(Status);
}


#ifndef NEW_PARTITION_ENGINE

VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )

/*++

Routine Description:

    Given a region describing a partition or logical drive, return information
    about its layout on disk appropriate for the BPB when the volume is
    formatted.

Arguments:

    Region - supplies a pointer to the disk region descriptor for the
        partition or logical drive in question.

    HiidenSectors - receives the value that should be placed in the
        hidden sectors field of the BPB when the volume is formatted.

    HiidenSectors - receives the value that should be placed in the
        sector count field of the BPB when the volume is formatted.

Return Value:

    None.

--*/

{
    PON_DISK_PTE pte;

#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
        SpPtnGetSectorLayoutInformation(Region, 
                                        HiddenSectors, 
                                        VolumeSectorCount);

        return;
    }        

#endif                                            

    ASSERT(Region->PartitionedSpace);

    pte = &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];

    *HiddenSectors = U_ULONG(pte->RelativeSectors);

    *VolumeSectorCount = U_ULONG(pte->SectorCount);
}

ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
{
    ULONG ord;


#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber))
        return SpPtnGetOrdinal(Region, OrdinalType);        
        
#endif


    if(Region->PartitionedSpace && (!Region->DynamicVolume || Region->MbrInfo) ) {
        //
        //  This is either a basic volume, or a dynamic volume that is listed on the MBR/EBR
        //
        switch(OrdinalType) {

        case PartitionOrdinalOriginal:

            ord = Region->MbrInfo->OriginalOrdinals[Region->TablePosition];
            break;

        case PartitionOrdinalOnDisk:

            ord = Region->MbrInfo->OnDiskOrdinals[Region->TablePosition];
            break;

        case PartitionOrdinalCurrent:

            ord = Region->MbrInfo->CurrentOrdinals[Region->TablePosition];
            break;
        }
    } else {
        //
        //  Dynamic volume that is not listed on MBR or EBR
        //
        ord = Region->TablePosition;
    }
    return(ord);
}

#endif // NEW_PARTITION_ENGINE

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    )
{
    WCHAR DriveLetter[3];
    ULONGLONG RegionSizeMB;
    ULONGLONG FreeSpace;
    ULONG MessageId;
    WCHAR TypeName[((sizeof(pRegion->TypeName)+sizeof(pRegion->VolumeLabel))/sizeof(WCHAR))+4];
    BOOLEAN NewDescription = FALSE;

    //
    // Get the size of the region.
    //
    RegionSizeMB = SpPtSectorCountToMB(pDisk->HardDisk, pRegion->SectorCount);

    //
    // Don't show spaces smaller than 1 MB.
    //
    if(!RegionSizeMB) {
        return(FALSE);
    }

    //
    // Get the drive letter field, type of region, and amount of free space,
    // if this is a used region.
    //
    if(pRegion->PartitionedSpace) {

        if(pRegion->DriveLetter) {
            if( pRegion->Filesystem != FilesystemFat ) {
                DriveLetter[0] = pRegion->DriveLetter;
            } else {
                if( pRegion->NextCompressed == NULL ) {
                    DriveLetter[0] = pRegion->DriveLetter;
                } else {
                    DriveLetter[0] = pRegion->HostDrive;
                }
            }
            DriveLetter[1] = L':';
        } else {
            if( pRegion->Filesystem != FilesystemDoubleSpace ) {
                DriveLetter[0] = L'-';
                DriveLetter[1] = L'-';
            } else {
                DriveLetter[0] = pRegion->MountDrive;
                DriveLetter[1] = L':';
            }
        }
        DriveLetter[2] = 0;

#ifdef NEW_PARTITION_ENGINE

        NewDescription = TRUE;
        
#endif        

#ifdef GPT_PARTITION_ENGINE

        if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
            NewDescription = TRUE;
        } else {
            NewDescription = FALSE;
        }

#endif

        //
        // Format the partition name
        //
        TypeName[0] = 0;        

        if (SPPT_IS_REGION_PARTITIONED(pRegion)) {
            SpPtnGetPartitionName(pRegion,
                TypeName,
                sizeof(TypeName) / sizeof(TypeName[0]));
        } else {
            swprintf( TypeName,
                      L"\\Harddisk%u\\Partition%u",
                      pRegion->DiskNumber,
                      pRegion->PartitionNumber );            
        }                      
 
        //
        // Format the text based on whether we know the amount of free space.
        //
        if(pRegion->FreeSpaceKB == (ULONG)(-1)) {

            SpFormatMessage(
                Buffer,
                BufferSize,
                SP_TEXT_REGION_DESCR_2,
                DriveLetter,
                SplangPadString(-35,TypeName),
                (ULONG)RegionSizeMB
                );

        } else {
            ULONGLONG   AuxFreeSpaceKB;

            AuxFreeSpaceKB = (pRegion->IsLocalSource)? pRegion->AdjustedFreeSpaceKB :
                                                       pRegion->FreeSpaceKB;

            //
            // If there is less than 1 meg of free space,
            // then use KB as the units for free space.
            // Otherwise, use MB.
            //
            if(AuxFreeSpaceKB < 1024) {
                MessageId = SP_TEXT_REGION_DESCR_1a;
                FreeSpace = AuxFreeSpaceKB;
            } else {
                MessageId = SP_TEXT_REGION_DESCR_1;
                FreeSpace = AuxFreeSpaceKB / 1024;

                //
                // Make sure we don't look bad...
                //
                if( FreeSpace > RegionSizeMB ) {
                    FreeSpace = RegionSizeMB;
                }
            }

            SpFormatMessage(
                Buffer,
                BufferSize,
                MessageId,
                DriveLetter,
                SplangPadString(-35,TypeName),
                (ULONG)RegionSizeMB,
                (ULONG)FreeSpace
                );
        }

    } else {

        //
        // Not a used region, use a separate format string.
        //
        SpFormatMessage(Buffer,
                BufferSize,
                SP_TEXT_REGION_DESCR_3, 
                (ULONG)RegionSizeMB);
    }

    return(TRUE);
}



BOOLEAN
SpPtIterateRegionList(
    IN  PVOID             Menu,
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    IN  BOOLEAN           InMbr,
    OUT PDISK_REGION     *FirstRegion
    )
{
    WCHAR Buffer[256];
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    PDISK_REGION    Pointer;
#endif // FULL_DOUBLE_SPACE_SUPPORT

    Buffer[0] = UNICODE_NULL;

    for( ;pRegion; pRegion=pRegion->Next) {

        PMBR_INFO pBrInfo = pRegion->MbrInfo;

        //
        // If this is the extended partition,
        // iterate its contents now.
        //
        if(pRegion->PartitionedSpace
        && IsContainerPartition(pBrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId))
        {
            //
            // This better be in the MBR!
            //
            ASSERT(InMbr);

            if(!SpPtIterateRegionList(Menu,pDisk,pDisk->ExtendedDiskRegions,FALSE,FirstRegion)) {
                return(FALSE);
            }
        } else {

            //
            // Format a description of this region and add it to the menu.
            //
            if(SpPtRegionDescription(pDisk,pRegion,Buffer,sizeof(Buffer))) {

                if(*FirstRegion == NULL) {
                    *FirstRegion = pRegion;
                }

                if(!SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),TRUE,(ULONG_PTR)pRegion)) {
                    return(FALSE);
                }
#ifdef FULL_DOUBLE_SPACE_SUPPORT
                if( ( pRegion->Filesystem == FilesystemFat ) &&
                    ( ( Pointer = pRegion->NextCompressed ) != NULL ) ) {
                    for( ; Pointer;
                         Pointer = Pointer->NextCompressed ) {
                        if(SpPtRegionDescription(pDisk,Pointer,Buffer,sizeof(Buffer))) {
                            if(!SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),TRUE,(ULONG)Pointer)) {
                                return(FALSE);
                            }
                         }
                    }
                }
#endif // FULL_DOUBLE_SPACE_SUPPORT
            }
        }
    }

    return(TRUE);
}


BOOLEAN
SpPtGenerateMenu(
    IN  PVOID              Menu,
    IN  PPARTITIONED_DISK  pDisk,
    OUT PDISK_REGION      *FirstRegion
    )
{
    WCHAR Buffer[256];

    //
    // Add the disk name/description.
    //
    if(!SpMnAddItem(Menu,pDisk->HardDisk->Description,MENU_LEFT_X,MENU_WIDTH,FALSE,0)) {
        return(FALSE);
    }

    //
    // Only add a line between the disk anme and partitions if we have space on
    // the screen. Not fatal if the space can't be added.
    //
    if(!SplangQueryMinimizeExtraSpacing()) {
        SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0);
    }

    //
    // If the disk is off-line, add a message indicating such.
    //
    // Also disallow installation or create/delete partition into
    // removable meida on NEC98. Because NT cannot boot from it.
    //
    if(pDisk->HardDisk->Status == DiskOffLine) {

        SpFormatMessage(
            Buffer,
            sizeof(Buffer),
            (pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)
              ? (!IsNEC_98 ? SP_TEXT_HARD_DISK_NO_MEDIA : SP_TEXT_DISK_OFF_LINE)
              : SP_TEXT_DISK_OFF_LINE
            );

        return(SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),FALSE,0));
    }
#if 0
    else if(IsNEC_98 && (pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

        SpFormatMessage(Buffer,sizeof(Buffer),SP_TEXT_DISK_OFF_LINE);

        return(SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),FALSE,0));
    }
#endif //0

    if(!SpPtIterateRegionList(Menu,pDisk,pDisk->PrimaryDiskRegions,TRUE,FirstRegion)) {
        return(FALSE);
    }

    return(SplangQueryMinimizeExtraSpacing() ? TRUE : SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0));
}


//
// We will change item #0 in the array below as appropriate for
// the currently highlighted region.
//
ULONG PartitionMnemonics[4] = {0};

VOID
SpPtMenuCallback(
    IN ULONG_PTR UserData
    )
{
    PDISK_REGION pRegion = (PDISK_REGION)UserData;

    //
    // Don't allow deletion of the partition if the 'partition' is really
    // a DoubleSpace drive.
    //

    if(pRegion->Filesystem == FilesystemDoubleSpace) {

        PartitionMnemonics[0] = 0;

        if (ConsoleRunning) {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );
        } else {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_INSTALL,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );
        }

    } else {
        PHARD_DISK  Disk = SPPT_GET_HARDDISK(pRegion->DiskNumber);
        BOOLEAN     FlipStyle = FALSE;
        BOOLEAN     MakeSysPart = FALSE;
        FilesystemType  FsType = pRegion->Filesystem;

#ifndef OLD_PARTITION_ENGINE

        FlipStyle = SpPtnIsDiskStyleChangeAllowed(pRegion->DiskNumber);

#endif        

        PartitionMnemonics[0] = pRegion->PartitionedSpace ? 
                                    MnemonicDeletePartition : MnemonicCreatePartition;


        PartitionMnemonics[1] = FlipStyle ? MnemonicChangeDiskStyle : 0;                                       

#ifdef NEW_PARTITION_ENGINE

        if (SPPT_IS_REGION_SYSTEMPARTITION(pRegion)) {
            ValidArcSystemPartition = TRUE;
        }
        
        if (!ValidArcSystemPartition && !FlipStyle && SpIsArc() && 
            (FsType != FilesystemNtfs) && SpPtnIsValidESPPartition(pRegion)) {
            //
            // Need to allow conversion to system partition
            //
            MakeSysPart = TRUE;
            PartitionMnemonics[1] = MnemonicMakeSystemPartition;
        }                            

#endif                                                     
        if (ConsoleRunning) {
            if (MakeSysPart) {
                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    pRegion->PartitionedSpace ? 
                        SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                    SP_STAT_M_EQUALS_MAKE_SYSPART, 
                    FlipStyle ? SP_STAT_S_EQUALS_CHANGE_DISK_STYLE : 0,
                    0
                    );
            } else {
                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    pRegion->PartitionedSpace ? 
                        SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                    FlipStyle ? SP_STAT_S_EQUALS_CHANGE_DISK_STYLE : 0,
                    0
                    );
            }
        } else {
            if (FlipStyle) {
                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_INSTALL,
                    pRegion->PartitionedSpace ? 
                        SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                    SP_STAT_S_EQUALS_CHANGE_DISK_STYLE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );
            } else {
                if (MakeSysPart) {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_INSTALL,
                        pRegion->PartitionedSpace ? 
                            SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                        SP_STAT_M_EQUALS_MAKE_SYSPART,                                
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );
                } else {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_INSTALL,
                        pRegion->PartitionedSpace ? 
                            SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );
                }
            }
        }
    }
}


void
SpEnumerateDiskRegions(
    IN PSPENUMERATEDISKREGIONS EnumRoutine,
    IN ULONG_PTR Context
    )
{
    ULONG DiskNo;
    PDISK_REGION pThisRegion;


    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
        for(pThisRegion=PartitionedDisks[DiskNo].PrimaryDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (!EnumRoutine( &PartitionedDisks[DiskNo], pThisRegion, Context )) {
                return;
            }
        }
        for(pThisRegion=PartitionedDisks[DiskNo].ExtendedDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (!EnumRoutine( &PartitionedDisks[DiskNo], pThisRegion, Context )) {
                return;
            }
        }
    }
}


#if DBG
void
SpPtDumpPartitionData(
    void
    )
{
    ULONG DiskNo;
    PDISK_REGION pThisRegion;


    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
        for(pThisRegion=PartitionedDisks[DiskNo].PrimaryDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (pThisRegion->FreeSpaceKB != -1) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: diskno=%d, sector-start=%d, sector-count=%d, free=%dKB\n",
                    pThisRegion->DiskNumber,
                    pThisRegion->StartSector,
                    pThisRegion->SectorCount,
                    pThisRegion->FreeSpaceKB
                    ));
            }
        }
    }
}
#endif

#ifdef OLD_PARTITION_ENGINE

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    PPARTITIONED_DISK pDisk;
    WCHAR Buffer[256];
    ULONG DiskNo;
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG ValidKeysCmdCons[2] = { ASCI_ESC, 0 };
    ULONG Keypress;
    PDISK_REGION pRegion;
    PDISK_REGION FirstRegion,DefaultRegion;
    BOOLEAN unattended;
    BOOLEAN createdMenu;


    //SpPtDumpPartitionData();

    if (SpIsArc()) {
        //
        // Select a system partition from among those defined in NV-RAM.
        //
        *SystemPartitionRegion = SpPtValidSystemPartitionArc(SifHandle,
                                        SetupSourceDevicePath,
                                        DirectoryOnSetupSource);
                                        
        (*SystemPartitionRegion)->IsSystemPartition = 2;
    }

    unattended = UnattendedOperation;

    while(1) {

        createdMenu = FALSE;

        Keypress = 0;

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup && HardDiskCount == 0) {

            //
            // If there are no hard disks, allow diskless install
            //

            pRegion = NULL;

            //
            // Run through the rest of the code as if the user had just
            // hit enter to select this partition.
            //

            Keypress = ASCI_CR;

        } else
#endif // defined(REMOTE_BOOT)

        if (unattended && RemoteBootRepartition) {

            ULONG DiskNumber;

            //
            // Prepare the disk for remote boot installation. This involves
            // converting disk 0 into as big a partition as possible.
            //

            if (*SystemPartitionRegion != NULL) {
                DiskNumber = (*SystemPartitionRegion)->DiskNumber;
            } else {
#ifdef _X86_
                DiskNumber = SpDetermineDisk0();
#else
                DiskNumber = 0;
#endif
            }

            if (NT_SUCCESS(SpPtPartitionDiskForRemoteBoot(DiskNumber, &pRegion))) {

                SpPtRegionDescription(
                    &PartitionedDisks[pRegion->DiskNumber],
                    pRegion,
                    Buffer,
                    sizeof(Buffer)
                    );

                //
                // Run through the rest of the code as if the user had just
                // hit enter to select this partition.
                //

                Keypress = ASCI_CR;
            }
        }

        if (Keypress == 0) {

            //
            // Display the text that goes above the menu on the partitioning screen.
            //
            SpDisplayScreen(ConsoleRunning?SP_SCRN_PARTITION_CMDCONS:SP_SCRN_PARTITION,3,CLIENT_TOP+1);

            //
            // Calculate menu placement.  Leave one blank line
            // and one line for a frame.
            //
            MenuTopY = NextMessageTopLine+2;

            //
            // Create a menu.
            //
            Menu = SpMnCreate(
                        MENU_LEFT_X,
                        MenuTopY,
                        MENU_WIDTH,
                        VideoVars.ScreenHeight-MenuTopY-(SplangQueryMinimizeExtraSpacing() ? 1 : 2)-STATUS_HEIGHT
                        );

            if(!Menu) {
                return(STATUS_NO_MEMORY);
            }

            createdMenu = TRUE;

            //
            // Build up a menu of partitions and free spaces.
            //
            FirstRegion = NULL;
            for(DiskNo=0; DiskNo<HardDiskCount; DiskNo++) {

                pDisk = &PartitionedDisks[DiskNo];

                if(!SpPtGenerateMenu(Menu,pDisk,&FirstRegion)) {

                    SpMnDestroy(Menu);
                    return(STATUS_NO_MEMORY);
                }
            }

            ASSERT(FirstRegion);

            //
            // If this is unattended operation, try to use the local source
            // region if there is one. If this fails, the user will have to
            // intervene manually.
            //
            if(unattended &&
               LocalSourceRegion &&
               (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS)
              ) {

                pRegion = LocalSourceRegion;
                Keypress = ASCI_CR;

            } else {

                pRegion = NULL;

                if (AutoPartitionPicker && !ConsoleRunning
#if defined(REMOTE_BOOT)
                    && (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
                    ) {
                    PDISK_REGION pThisRegion;
                    ULONG RequiredKB = 0;
                    ULONG SectorNo;
                    ULONG pass;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: -------------------------------------------------------------\n" ));
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Looking for an install partition\n\n" ));
                    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
                        for( pass = 0; ((pass < 2) && (pRegion == NULL)); pass ++ ) {
                            for(pThisRegion= (pass == 0) ? PartitionedDisks[DiskNo].PrimaryDiskRegions : PartitionedDisks[DiskNo].ExtendedDiskRegions,SectorNo=0; pThisRegion; pThisRegion=pThisRegion->Next,SectorNo++) {

                                //
                                // Fetch the amount of free space required on the windows nt drive.
                                //
                                SpFetchDiskSpaceRequirements( SifHandle,
                                                              pThisRegion->BytesPerCluster,
                                                              &RequiredKB,
                                                              NULL);

                                if (SpPtDeterminePartitionGood(pThisRegion,RequiredKB,TRUE))
                                {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Selected install partition = (%d,%d),(%wc:),(%ws)\n",
                                             DiskNo,SectorNo,pThisRegion->DriveLetter,pThisRegion->VolumeLabel));
                                    pRegion = pThisRegion;
                                    Keypress = ASCI_CR;
                                    break;
                                }
                            }

                        }
                    }
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: -------------------------------------------------------------\n" ));
                }


                if( !pRegion ) {
                    //
                    // If there is a local source, make it the default partition.
                    //
                    DefaultRegion = (LocalSourceRegion &&
                                     (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS))?
                                     LocalSourceRegion : FirstRegion;

                    //
                    // Call the menu callback to initialize the status line.
                    //
                    SpPtMenuCallback((ULONG_PTR)DefaultRegion);

                    SpMnDisplay(
                        Menu,
                        (ULONG_PTR)DefaultRegion,
                        TRUE,
                        ConsoleRunning?ValidKeysCmdCons:ValidKeys,
                        PartitionMnemonics,
                        SpPtMenuCallback,
                        &Keypress,
                        (PULONG_PTR)(&pRegion)
                        );
                }
            }
        }

        //
        // Now act on the user's selection.
        //
        if(Keypress & KEY_MNEMONIC) {
            Keypress &= ~KEY_MNEMONIC;
        }

        if (IsNEC_98) { //NEC98
            //
            // If target hard drive has no/wrong MBR, force initialize it right now.
            //
            PPARTITIONED_DISK pDisk;
            ULONG ValidKeysInit[] = {ASCI_ESC, 0 };
            ULONG MnemonicKeysInit[] = { MnemonicInitializeDisk, 0 };


            pDisk = &PartitionedDisks[pRegion->DiskNumber];

            if(!(pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) &&
               ((U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) != MBR_SIGNATURE) ||
                (pDisk->HardDisk->FormatType != DISK_FORMAT_TYPE_NEC98)) &&
               ((Keypress == MnemonicCreatePartition) ||
                (Keypress == MnemonicDeletePartition) || (Keypress == ASCI_CR))) {

                //SpDisplayScreen(SP_SCRN_INIT_DISK_NEC98,3,HEADER_HEIGHT+1);
                SpStartScreen(
                    SP_SCRN_INIT_DISK_NEC98,
                    3,
                    CLIENT_TOP+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    pDisk->HardDisk->Description
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_I_EQUALS_INIT_NEC98,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    0
                    );

                if(SpWaitValidKey(ValidKeysInit,NULL,MnemonicKeysInit) == ASCI_ESC) {
                    SpMnDestroy(Menu);
                    continue;
                }

                //
                // It will be not return, if successfully complete.
                //
                return( SpInitializeHardDisk_Nec98(pRegion) );
            }
        } //NEC98


        switch(Keypress) {

        case MnemonicCreatePartition:

            SpPtDoCreate(pRegion,NULL,FALSE,0,0,TRUE);
            break;

        case MnemonicDeletePartition:

            SpPtDoDelete(pRegion,SpMnGetText(Menu,(ULONG_PTR)pRegion),TRUE);
            break;

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            if (ConsoleRunning) {
                SpPtDoCommitChanges();
            }
            if (createdMenu) {
                SpMnDestroy(Menu);
                return(STATUS_SUCCESS);
            }
            return(STATUS_SUCCESS);

        case ASCI_CR:

            if(SpPtDoPartitionSelection(&pRegion,
                                        (!createdMenu) ? Buffer :
                                          SpMnGetText(Menu,(ULONG_PTR)pRegion),
                                        SifHandle,
                                        unattended,
                                        SetupSourceDevicePath,
                                        DirectoryOnSetupSource,
                                        RemoteBootRepartition)) {
                //
                // We're done here.
                //
                if (createdMenu) {
                    SpMnDestroy(Menu);
                }

                *InstallRegion = pRegion;
#if defined(REMOTE_BOOT)
                //
                // Set the install region differently if this is a remote
                // boot -- in that case, the install region is always remote.
                //
                if (RemoteBootSetup && !RemoteInstallSetup) {
                    *InstallRegion = RemoteBootTargetRegion;
                }
#endif // defined(REMOTE_BOOT)

                if (!SpIsArc()) {
                if (!IsNEC_98) { //NEC98
                    *SystemPartitionRegion = SpPtValidSystemPartition();
                } else {
                    *SystemPartitionRegion = *InstallRegion;
                } //NEC98
                }else{
                //
                // Select a system partition from among those defined in NV-RAM.
                // We have to do this again because the user may have deleted the
                // system partition previously detected.
                // Note that SpPtValidSystemPartitionArc(SifHandle) will not return if
                // a valid system partition is not found.
                //
                *SystemPartitionRegion = SpPtValidSystemPartitionArc(SifHandle, 
                                                            SetupSourceDevicePath,
                                                            DirectoryOnSetupSource);
                }

#if defined(REMOTE_BOOT)
                ASSERT(*SystemPartitionRegion ||
                       (RemoteBootSetup && !RemoteInstallSetup && (HardDiskCount == 0)));
#else
                ASSERT(*SystemPartitionRegion);
#endif // defined(REMOTE_BOOT)

                return(STATUS_SUCCESS);
            } else {
                //
                // Something happened when we tried to select the
                // partition.  Make sure that autopartition-picker
                // doesn't invoke next time through our while loop.
                //
                AutoPartitionPicker = FALSE;
            }
            break;
        }

        if (createdMenu) {
            SpMnDestroy(Menu);
        }
        unattended = FALSE;
    }
}

VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };          // do not change order
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };
    ULONG k;
    BOOLEAN b;
    PPARTITIONED_DISK pDisk;
    BOOLEAN LastLogical;
    ULONG           Count;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
        SpPtnDoDelete(pRegion,
                    RegionDescription,
                    ConfirmIt);                

        return;
    }        
#endif

    //
    // Special warning if this is a system partition.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(ConfirmIt && pRegion->IsSystemPartition) {

            SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_SYSPART,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
                return;
            }
        }
    } //NEC98

    if(ConfirmIt && pRegion->DynamicVolume) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_DYNVOL,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return;
        }
    }

    //
    // CR is no longer a valid key.
    //
    ValidKeys[1] = 0;

    pDisk = &PartitionedDisks[pRegion->DiskNumber];

    //
    // Put up the confirmation screen.
    //
    if (ConfirmIt) {
        if( ( pRegion->Filesystem == FilesystemFat ) &&
            ( pRegion->NextCompressed != NULL ) ) {
            //
            // Warn the user that the partition contains compressed volumes
            //

            Count = SpGetNumberOfCompressedDrives( pRegion );

            SpStartScreen(
                SP_SCRN_CONFIRM_REMOVE_PARTITION_COMPRESSED,
                3,
                CLIENT_TOP+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescription,
                pDisk->HardDisk->Description,
                Count
                );
        } else {

            SpStartScreen(
                SP_SCRN_CONFIRM_REMOVE_PARTITION,
                3,
                CLIENT_TOP+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescription,
                pDisk->HardDisk->Description
                );
        }
    }

    //
    // Display the staus text.
    //
    if (ConfirmIt) {
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_L_EQUALS_DELETE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        k = SpWaitValidKey(ValidKeys,NULL,Mnemonics);

        if(k == ASCI_ESC) {
            return;
        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_PLEASE_WAIT,
            0);
        
    }

    //
    // User wants to go ahead.
    // Determine whether this is the last logical drive in the
    // extended partition.
    //
    if((pRegion->MbrInfo == pDisk->FirstEbrInfo.Next)
    && (pDisk->FirstEbrInfo.Next->Next == NULL))
    {
        LastLogical = TRUE;
    } else {
        LastLogical = FALSE;
    }
    
    //
    //  Get rid of the compressed drives, if any
    //
    if( pRegion->NextCompressed != NULL ) {
        SpDisposeCompressedDrives( pRegion->NextCompressed );
        pRegion->NextCompressed = NULL;
        pRegion->MountDrive  = 0;
        pRegion->HostDrive  = 0;
    }

    b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
    
    if (!b) {
        if (ConfirmIt) {
            SpDisplayScreen(SP_SCRN_PARTITION_DELETE_FAILED,3,HEADER_HEIGHT+1);
            SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        }
        return;
    }

    //
    // If we deleted the last logical drive in the extended partition,
    // then remove the extended partition also.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(LastLogical) {

            //
            // Locate the extended partition.
            //
            for(pRegion=pDisk->PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

                if(pRegion->PartitionedSpace
                && IsContainerPartition(pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId))
                {
                    //
                    // Found it -- now delete it.
                    //
                    b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
                    ASSERT(b);
                    break;
                }
            }
        }
    } //NEC98

    //
    //  Delete the drive letters if the necessary. This is to ensure that the drive letters assigned to CD-ROM
    //  drives will go away, when the the disks have no partitioned space.
    //
    SpPtDeleteDriveLetters();
}

BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };
    BOOLEAN b;
    PPARTITIONED_DISK pDisk;
    ULONGLONG MinMB,MaxMB;
    ULONG TotalPrimary,RecogPrimary;
    BOOLEAN InExtended;
    UCHAR CreateSysId;
    UCHAR RealSysId;
    BOOLEAN ExtendedExists;
    ULONGLONG SizeMB,RealSizeMB;
    WCHAR Buffer[200];
    WCHAR SizeBuffer[10];
    BOOLEAN Beyond1024;
    BOOLEAN ReservedRegion;
    UCHAR DesiredSysId = 0;
    PARTITION_INFORMATION_EX NewPartInfo;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
        return SpPtnDoCreate(pRegion,
                        pActualRegion,
                        ForNT,
                        DesiredMB,
                        PartInfo,
                        ConfirmIt);
    }                                
#endif                        

    RtlZeroMemory(&NewPartInfo, sizeof(PARTITION_INFORMATION_EX));

    DesiredSysId = PartInfo ? PartInfo->Mbr.PartitionType : 0;

    ASSERT(!pRegion->PartitionedSpace);

    pDisk = &PartitionedDisks[pRegion->DiskNumber];

    //
    // Determine whether this space is within the extended partition.
    //

# if 0
    //
    // No NEC98 has Extended partition.
    // All of partition on NEC98 are Primary.
    //
    InExtended = (!IsNEC_98) ? (BOOLEAN)(SpPtLookupRegionByStart(pDisk,TRUE,pRegion->StartSector) != NULL) : FALSE; //NEC98
# endif //0
    InExtended = (BOOLEAN)(SpPtLookupRegionByStart(pDisk,TRUE,pRegion->StartSector) != NULL);
    Beyond1024 = SpIsRegionBeyondCylinder1024(pRegion);

    if( pDisk->HardDisk->Geometry.MediaType == RemovableMedia ) {
        ULONG           pass;
        PDISK_REGION    p;

        //
        // If the user is attempting to create a partition on a removable drive, then make sure that
        // the drive doesn't already contain a primary partition or a logical drive.
        //
        for( pass = 0; pass < 2; pass++ ) {
            for( p = (pass == 0)? pDisk->PrimaryDiskRegions : pDisk->ExtendedDiskRegions;
                 p;
                 p = p->Next ) {
                if( p->PartitionedSpace ) {
                    PON_DISK_PTE pte;
                    UCHAR   TmpSysId;

                    pte = &p->MbrInfo->OnDiskMbr.PartitionTable[p->TablePosition];
                    TmpSysId = pte->SystemId;
                    if( !IsContainerPartition(TmpSysId) ) {
                        ULONG ValidKeys1[2] = { ASCI_CR ,0 };

                        //
                        // Disk is already partitioned
                        //
                        SpDisplayScreen(SP_SCRN_REMOVABLE_ALREADY_PARTITIONED,3,HEADER_HEIGHT+1);
                        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                        SpWaitValidKey(ValidKeys1,NULL,NULL);
                        return( FALSE );
                    }
                }
            }
        }
    }

    //
    // Determine the type of partition to create for this space,
    // excluding any issues with extended partitions.
    //

    if (DesiredSysId != 0) {
        //
        // If the caller specified a partition type, use it unless it
        // won't work due to being beyond 1024 cylinders.
        //
#if 0
        RealSysId = DesiredSysId;
        if (Beyond1024) {
            if (RealSysId == PARTITION_FAT32) {
                RealSysId = PARTITION_FAT32_XINT13;
            } else {
                RealSysId = PARTITION_XINT13;
            }
        }
#else
        //
        // Keep this code in until I determine if we will be explicitly
        // creating extended partitions.
        //
        RealSysId = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;
#endif
    } else {
        RealSysId = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;
    }

    //
    // Determine the type of partition to create in the space.
    //
    // If the free space is within the extended partition, create
    // a logical drive.
    //
    // If there is no primary partition, create a primary partition.
    //
    // If there is a primary partition and no extended partition,
    // create an extended partition spanning the entire space and
    // then a logical drive within it of the size given by the user.
    //
    // If there is space in the partition table, create a primary partition.
    //
    if(InExtended) {

        CreateSysId = RealSysId;

    } else {

        //
        // Get statistics about primary partitions.
        //
        SpPtCountPrimaryPartitions(pDisk,&TotalPrimary,&RecogPrimary,&ExtendedExists);

        //
        // If there is no primary partition, create one.
        //
        if(!RecogPrimary) {

            CreateSysId = RealSysId;

        } else {

            //
            // Make sure we can create a new primary/extended partition.
            //
            if(TotalPrimary < PTABLE_DIMENSION) {

                //
                // If there is an extended partition, then we have no choice but
                // to create another primary.
                //
                if(ExtendedExists) {
                    CreateSysId = RealSysId;
                } else {
                    //
                    // Firmware doesn't understand type F link partitions.
                    // No great need to use on x86 either; assume that creating
                    // logical drives with the correct type is good enough.
                    //

                    //
                    // No NEC98 has PARTITION_EXTENDED, just PARTITION_HUGE only.
                    //
                    CreateSysId = (!IsNEC_98 ||
                                   (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT))
                        ? PARTITION_EXTENDED : PARTITION_HUGE; //NEC98
                    if((CreateSysId == PARTITION_EXTENDED) && Beyond1024) {
                                    CreateSysId = PARTITION_XINT13_EXTENDED;
                    }
                }
            } else {
                if (ConfirmIt) {
                    while (TRUE) {
                        ULONG ks[2] = { ASCI_CR,0 };

                        SpDisplayScreen(SP_SCRN_PART_TABLE_FULL,3,CLIENT_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        switch(SpWaitValidKey(ks,NULL,NULL)) {
                        case ASCI_CR:
                            return(FALSE);
                        }
                    }
                } else {
                    return TRUE;
                }
            }
        }
    }

    //
    // Get the mimimum and maximum sizes for the partition.
    //
    ReservedRegion = FALSE;
    SpPtQueryMinMaxCreationSizeMB(
        pRegion->DiskNumber,
        pRegion->StartSector,
        (BOOLEAN)IsContainerPartition(CreateSysId),
        InExtended,
        &MinMB,
        &MaxMB,
        &ReservedRegion
        );

    if( ReservedRegion ) {
        ULONG ValidKeys1[2] = { ASCI_CR ,0 };

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    if(ForNT) {

        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB != 0) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;
            }
        } else {
            SizeMB = MaxMB;
        }

    } else {

        //
        // Put up a screen displaying min/max size info.
        //
        SpStartScreen(
            SP_SCRN_CONFIRM_CREATE_PARTITION,
            3,
            CLIENT_TOP+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            pDisk->HardDisk->Description,
            MinMB,
            MaxMB
            );

        //
        // Display the staus text.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CREATE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        //
        // Get and display the size prompt.
        //
        SpFormatMessage(Buffer,sizeof(Buffer),SP_TEXT_SIZE_PROMPT);

        SpvidDisplayString(Buffer,DEFAULT_ATTRIBUTE,3,NextMessageTopLine);

        //
        // Get the size from the user.
        //
        do {

            swprintf(SizeBuffer,L"%u",MaxMB);
            if(!SpGetInput(SpPtnGetSizeCB,SplangGetColumnCount(Buffer)+5,NextMessageTopLine,5,SizeBuffer,TRUE)) {

                //
                // User pressed escape and bailed.
                //
                return(FALSE);
            }

            SizeMB = (ULONG)SpStringToLong(SizeBuffer,NULL,10);

        } while((SizeMB < MinMB) || (SizeMB > MaxMB));
    }

    if(IsContainerPartition(CreateSysId)) {
        RealSizeMB = SizeMB;
        SizeMB = MaxMB;
    }

    NewPartInfo.PartitionStyle = PARTITION_STYLE_MBR;
    NewPartInfo.Mbr.PartitionType = CreateSysId;

    //
    // Create the partition.
    //
    b = SpPtCreate(
            pRegion->DiskNumber,
            pRegion->StartSector,
            SizeMB,
            InExtended,
            &NewPartInfo,
            pActualRegion
            );

    ASSERT(b);

    //
    // Create the logical drive if we just created the extended partition.
    //
    if(IsContainerPartition(CreateSysId)) {

        ASSERT(!InExtended);

        NewPartInfo.Mbr.PartitionType = RealSysId;

        b = SpPtCreate(
                pRegion->DiskNumber,
                pRegion->StartSector,
                RealSizeMB,
                TRUE,
                &NewPartInfo,
                pActualRegion
                );

        ASSERT(b);
    }

    return(TRUE);
}

#endif // NEW_PARTITION_ENGINE



//
// The following table contains offsets from SP_TEXT_PARTITION_NAME_BASE
// to get the message id of the name of each type of partition.
// A -1 entry means there is no name in the message file for this type
// of partition or that the filesystem should be determined instead.
//
//
#define PT(id)      ((UCHAR)((SP_TEXT_PARTITION_NAME_##id)-SP_TEXT_PARTITION_NAME_BASE))
#define UNKNOWN     PT(UNK)
#define M1          ((UCHAR)(-1))

UCHAR PartitionNameIds[256] = {

    M1,M1,PT(XENIX),PT(XENIX),                      // 00-03
    M1,M1,M1,M1,                                    // 04-07
    UNKNOWN,UNKNOWN,PT(BOOTMANAGER),M1,             // 08-0b
    M1,UNKNOWN,M1,M1,                               // 0c-0f
    UNKNOWN,UNKNOWN,PT(EISA),UNKNOWN,               // 10-13
    UNKNOWN,UNKNOWN,PT(BMHIDE),PT(BMHIDE),          // 14-17
    UNKNOWN,UNKNOWN,UNKNOWN,PT(BMHIDE),             // 18-1b
    PT(BMHIDE),UNKNOWN,UNKNOWN,UNKNOWN,             // 1c-1f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 20-23
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 24-27
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 28-2b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 2c-2f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 30-33
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 34-37
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 38-3b
    PT(PWRQST),UNKNOWN,UNKNOWN,UNKNOWN,             // 3c-3f
    UNKNOWN,PT(PPCBOOT),PT(VERIT),PT(VERIT),        // 40-43
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 44-47
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 48-4b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 4c-4f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 50-53
    PT(ONTRACK),PT(EZDRIVE),UNKNOWN,UNKNOWN,        // 54-57
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 58-5b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 5c-5f
    UNKNOWN,UNKNOWN,UNKNOWN,PT(UNIX),               // 60-63
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 64-67
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 68-6b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 6c-6f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 70-73
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 74-77
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 78-7b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 7c-7f
    UNKNOWN,PT(NTFT),UNKNOWN,UNKNOWN,               // 80-83
    PT(NTFT),UNKNOWN,PT(NTFT),PT(NTFT),             // 84-87
    UNKNOWN,UNKNOWN,UNKNOWN,PT(NTFT),               // 88-8b
    PT(NTFT),UNKNOWN,PT(NTFT),UNKNOWN,              // 8c-8f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 90-93
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 94-97
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 98-9b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 9c-9f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a0-a3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a4-a7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a8-ab
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // ac-af
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b0-b3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b4-b7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b8-bb
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // bc-bf
    UNKNOWN,PT(NTFT),UNKNOWN,UNKNOWN,               // c0-c3
    PT(NTFT),UNKNOWN,PT(NTFT),PT(NTFT),             // c4-c7
    UNKNOWN,UNKNOWN,UNKNOWN,PT(NTFT),               // c8-cb
    PT(NTFT),UNKNOWN,PT(NTFT),UNKNOWN,              // cc-cf
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d0-d3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d4-d7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d8-db
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // dc-df
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e0-e3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e4-e7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e8-eb
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // ec-ef
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f0-f3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f4-f7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f8-fb
    UNKNOWN,UNKNOWN,UNKNOWN,PT(XENIXTABLE)          // fc-ff
};


WCHAR
SpGetDriveLetter(
    IN  PWSTR   DeviceName,
    OUT  PMOUNTMGR_MOUNT_POINT * MountPoint OPTIONAL
    )

/*++

Routine Description:

    This routine returns the drive letter associated to a given device.

Arguments:

    DeviceName  - Supplies the device name.

    MountPoint  - If specified, causes the function to allocate a mount
                  manager point and fills it in.

Return Value:

    A drive letter, if one exists.

--*/

{
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               Obja;
    UNICODE_STRING                  UnicodeString;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE                          Handle;
    DWORD                           nameLen;
    DWORD                           mountPointSize;
    PMOUNTMGR_MOUNT_POINT           mountPoint;
    PMOUNTMGR_MOUNT_POINTS          mountPoints;
    PMOUNTMGR_TARGET_NAME           mountTarget;
    DWORD                           bytes;
    WCHAR                           driveLetter;
    DWORD                           i;
    PWSTR                           s;
    LARGE_INTEGER                   DelayTime;


    INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return L'\0';
    }

    //
    // setup a good device name
    //

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_TARGET_NAME) + nameLen*sizeof(WCHAR) + 28;
    mountTarget = SpMemAlloc(mountPointSize);

    if (!mountTarget) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountTarget, mountPointSize);
    mountTarget->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);
    RtlCopyMemory((PCHAR) &mountTarget->DeviceName, DeviceName, nameLen*sizeof(WCHAR));

    //
    // this loop is necessary as a synchronization
    // method.  we have previously committed changes, but
    // the volume manager has not had a chance to
    // do it's thing so here we wait......
    //

    for (i=0; i<20; i++) {
        Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
                        mountTarget,
                        mountPointSize,
                        NULL,
                        0
                        );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION failed - %08x\n",Status));
            DelayTime.HighPart = -1;
            DelayTime.LowPart = (ULONG)(-5000000);
            KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
        } else {
            //
            //  On removable disks, a drive letter may not have been assigned yet.
            //  So make sure one is assigned on this case.
            //
            MOUNTMGR_DRIVE_LETTER_INFORMATION DriveLetterInformation;
            NTSTATUS                          Status1;

            Status1 = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
                            mountTarget,
                            mountPointSize,
                            &DriveLetterInformation,
                            sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION)
                            );
            if (!NT_SUCCESS( Status1 )) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER failed. Status = %lx \n",Status1));
            }
            break;
        }
    }

    if (!NT_SUCCESS( Status )) {
        SpMemFree(mountTarget);
        ZwClose(Handle);
        return L'\0';
    }

    SpMemFree(mountTarget);

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + nameLen*sizeof(WCHAR) + 28;
    mountPoint = SpMemAlloc(mountPointSize);
    if (!mountPoint) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountPoint, mountPointSize);
    mountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);

    RtlCopyMemory((PCHAR) mountPoint + sizeof(MOUNTMGR_MOUNT_POINT),
               DeviceName, nameLen*sizeof(WCHAR));

    mountPoints = SpMemAlloc( 4096 );
    if (!mountPoints) {
        SpMemFree(mountPoint);
        ZwClose(Handle);
        return L'\0';
    }

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    mountPoint,
                    mountPointSize,
                    mountPoints,
                    4096
                    );

    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            bytes = mountPoints->Size;
            SpMemFree(mountPoints);
            mountPoints = SpMemAlloc(bytes);
            if (!mountPoints) {
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_QUERY_POINTS,
                            mountPoint,
                            mountPointSize,
                            mountPoints,
                            bytes
                          );

            if (!NT_SUCCESS( Status )) {
                SpMemFree(mountPoints);
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }
        } else {
            mountPoints->NumberOfMountPoints = 0;
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "SETUP: IOCTL_MOUNTMGR_QUERY_POINTS : Number = %d \n",
        mountPoints->NumberOfMountPoints));
    

    driveLetter = 0;
    
    for (i = 0; i < mountPoints->NumberOfMountPoints; i++) {

        if (mountPoints->MountPoints[i].SymbolicLinkNameLength != 28) {
            continue;
        }

        s = (PWSTR) ((PCHAR) mountPoints +
                     mountPoints->MountPoints[i].SymbolicLinkNameOffset);

        if (s[0] != L'\\' ||
            (s[1] != L'D' && s[1] != L'd') ||
            (s[2] != L'O' && s[2] != L'o') ||
            (s[3] != L'S' && s[3] != L's') ||
            (s[4] != L'D' && s[4] != L'd') ||
            (s[5] != L'E' && s[5] != L'e') ||
            (s[6] != L'V' && s[6] != L'v') ||
            (s[7] != L'I' && s[7] != L'i') ||
            (s[8] != L'C' && s[8] != L'c') ||
            (s[9] != L'E' && s[9] != L'e') ||
            (s[10]!= L'S' && s[10]!= L's') ||
            s[11] != L'\\' ||
            s[13] != L':') {

            continue;
        }

        if (s[12] < ((!IsNEC_98) ? L'C' : L'A') || s[12] > L'Z') { //NEC98
            continue;
        }

        driveLetter = s[12];

        if (ARGUMENT_PRESENT( MountPoint )) {

            ULONG newMountPointSize;
            PMOUNTMGR_MOUNT_POINT newMountPoint, oldMountPoint;
            ULONG currentOffset;

            //
            // The caller wants us to return the actual mount point information.
            //

            oldMountPoint = &mountPoints->MountPoints[i];

            newMountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) +
                                oldMountPoint->SymbolicLinkNameLength +
                                oldMountPoint->UniqueIdLength +
                                oldMountPoint->DeviceNameLength;
            newMountPoint = SpMemAlloc(newMountPointSize);
            if (newMountPoint) {

                currentOffset = sizeof(MOUNTMGR_MOUNT_POINT);

                newMountPoint->SymbolicLinkNameLength = oldMountPoint->SymbolicLinkNameLength;
                newMountPoint->SymbolicLinkNameOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->SymbolicLinkNameOffset,
                       (PCHAR)mountPoints + oldMountPoint->SymbolicLinkNameOffset,
                       oldMountPoint->SymbolicLinkNameLength);
                currentOffset += oldMountPoint->SymbolicLinkNameLength;

                newMountPoint->UniqueIdLength = oldMountPoint->UniqueIdLength;
                newMountPoint->UniqueIdOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->UniqueIdOffset,
                       (PCHAR)mountPoints + oldMountPoint->UniqueIdOffset,
                       oldMountPoint->UniqueIdLength);
                currentOffset += oldMountPoint->UniqueIdLength;

                newMountPoint->DeviceNameLength = oldMountPoint->DeviceNameLength;
                newMountPoint->DeviceNameOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->DeviceNameOffset,
                       (PCHAR)mountPoints + oldMountPoint->DeviceNameOffset,
                       oldMountPoint->DeviceNameLength);

                *MountPoint = newMountPoint;
            }
        }
        break;
    }

    SpMemFree(mountPoints);
    SpMemFree(mountPoint);
    ZwClose(Handle);

    return driveLetter;
}

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    )

/*++

Routine Description:

    This routine returns the drive letter associated to a given device.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    A drive letter, if one exists.

--*/

{
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               Obja;
    UNICODE_STRING                  UnicodeString;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE                          Handle;
    DWORD                           nameLen;
    DWORD                           mountPointSize;
    PMOUNTMGR_MOUNT_POINT           mountPoint;
    PMOUNTMGR_MOUNT_POINTS          mountPoints;
    DWORD                           bytes;
    WCHAR                           driveLetter;


    INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return L'\0';
    }

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + nameLen*sizeof(WCHAR) + 28;
    mountPoint = SpMemAlloc(mountPointSize);
    if (!mountPoint) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    mountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);

    RtlCopyMemory((PCHAR) mountPoint + sizeof(MOUNTMGR_MOUNT_POINT),
               DeviceName, nameLen*sizeof(WCHAR));

    mountPoints = SpMemAlloc( 4096 );
    if (!mountPoints) {
        SpMemFree(mountPoint);
        ZwClose(Handle);
        return L'\0';
    }

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_DELETE_POINTS,
                    mountPoint,
                    mountPointSize,
                    mountPoints,
                    4096
                    );



    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            bytes = mountPoints->Size;
            SpMemFree(mountPoints);
            mountPoints = SpMemAlloc(bytes);
            if (!mountPoints) {
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_DELETE_POINTS,
                            mountPoint,
                            mountPointSize,
                            mountPoints,
                            bytes
                          );

            if (!NT_SUCCESS( Status )) {
                SpMemFree(mountPoints);
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }
        } else {
            mountPoints->NumberOfMountPoints = 0;
        }
    }

    driveLetter = 0;

    SpMemFree(mountPoints);
    SpMemFree(mountPoint);
    ZwClose(Handle);

    return driveLetter;
}

VOID
SpPtDeleteDriveLetters(
    VOID
    )

/*++

Routine Description:

    This routine will delete all drive letters assigned to disks and CD-ROM drives. The deletion will
    occur only if setup was started booting from the CD or boot floppies (in which case drive letter
    migration does not take place), and only if the non-removable dissks have no partitioned spaces.
    This ensures that on a clean install from the CD or boot floppies, the drive letters assigned to
    partitions on removable disks and CD-ROM drives will always be greater than the drive letters assigned
    to partitions on non-removable disks (unless the partitions on the removable disks were created before
    the ones in the removable disks, during textmode setup).


Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;
    BOOLEAN PartitionedSpaceFound = FALSE;

    if( WinntSetup ) {
        //
        // If setup started from winnt32.exe then do not delete the drive letters since we want to preserve them
        //
        return;
    }

    //
    //  Setup started booting from a CD or from the boot floppies
    //  Find out if the disks contain at least one partition that is not a container.
    //  Note that we do not take into consideration partitions that are on removable media.
    //  This is to avoid the situation in which a newly created partition on a non-removable disk ends up with
    //  a drive letter that is greater than the one assigned to an existing partition on a removable disk.
    //
    for(disk = 0;
        !PartitionedSpaceFound &&
        (disk<HardDiskCount);
        disk++) {
        if((PartitionedDisks[disk].HardDisk)->Geometry.MediaType != RemovableMedia) {
            for(pass=0; !PartitionedSpaceFound && (pass<2); pass++) {
                pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                for( ; !PartitionedSpaceFound && pRegion; pRegion=pRegion->Next) {
                    UCHAR SystemId = PARTITION_ENTRY_UNUSED;

#ifdef OLD_PARTITION_TABLE                    
                    SystemId = pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId;
#else
                    if (SPPT_IS_MBR_DISK(disk) && SPPT_IS_REGION_PARTITIONED(pRegion)) {
                        SystemId = SPPT_GET_PARTITION_TYPE(pRegion);
                    } 
#endif                    
                                        
                    if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                        PartitionedSpaceFound = TRUE;
                    }
                }
            }
        }
    }

    if( !PartitionedSpaceFound ) {
        //
        //  If the disks have no partitioned regions that are not a container,
        //  then delete all drive letters, so that the drive letters for each CD-ROM drive
        //  also get deleted.
        //

        NTSTATUS                Status;
        OBJECT_ATTRIBUTES       Obja;
        IO_STATUS_BLOCK         IoStatusBlock;
        UNICODE_STRING          UnicodeString;
        HANDLE                  Handle;

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile( &Handle,
                             (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_NON_DIRECTORY_FILE );

        if( NT_SUCCESS( Status ) ) {

            MOUNTMGR_MOUNT_POINT    MountMgrMountPoint;

            MountMgrMountPoint.SymbolicLinkNameOffset = 0;
            MountMgrMountPoint.SymbolicLinkNameLength = 0;
            MountMgrMountPoint.UniqueIdOffset = 0;
            MountMgrMountPoint.UniqueIdLength = 0;
            MountMgrMountPoint.DeviceNameOffset = 0;
            MountMgrMountPoint.DeviceNameLength = 0;

            Status = ZwDeviceIoControlFile( Handle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_MOUNTMGR_DELETE_POINTS,
                                            &MountMgrMountPoint,
                                            sizeof( MOUNTMGR_MOUNT_POINT ),
                                            TemporaryBuffer,
                                            sizeof( TemporaryBuffer ) );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete drive letters. ZwDeviceIoControl( IOCTL_MOUNTMGR_DELETE_POINTS ) failed. Status = %lx \n", Status));
            } else {
                //
                // If the drive letters got deleted then reset the drive letters assigned to all partitions.
                // Note that we only really care about resetting the drive letters on the partitions on the
                // removable disks, since, if we got that far, there won't be any partition on the non-removable
                // disks
                //
                for(disk = 0; (disk<HardDiskCount); disk++) {
                    if ((PartitionedDisks[disk].HardDisk)->Geometry.MediaType == RemovableMedia) {
                        for(pass=0; pass<2; pass++) {
                            pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                            for( ; pRegion; pRegion=pRegion->Next) {
                                UCHAR SystemId = SpPtGetPartitionType(pRegion);
                            
                                if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                                   pRegion->DriveLetter = 0;
                                }
                            }
                        }
                    }
                }
            }

            ZwClose( Handle );

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete drive letters. ZwOpenFile( %ls ) failed. Status = %lx \n", MOUNTMGR_DEVICE_NAME, Status));
        }
    }
}

VOID
SpPtAssignDriveLetters(
    VOID
    )
{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;

    //
    // Before initializing the drive letters, delete them if necessary.
    // This is to get rid of the letters assigned to CD-ROM drives and removables, when the disks have no
    // partitioned space.
    //
    SpPtDeleteDriveLetters();

    //
    // Initialize all drive letters to nothing.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
        // assign drive letters for removeable media also for command console
        if(ForceConsole || ((PartitionedDisks[disk].HardDisk)->Geometry.MediaType != RemovableMedia)) {
            for(pass=0; pass<2; pass++) {
                pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                for( ; pRegion; pRegion=pRegion->Next) {
                    UCHAR SystemId = SpPtGetPartitionType(pRegion);
                    
                    pRegion->DriveLetter = 0;
                    
                    if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                        //
                        // Get the nt pathname for this region.
                        //
                        SpNtNameFromRegion(
                            pRegion,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            PartitionOrdinalCurrent
                            );
                        //
                        //  Assign a drive letter for this region
                        //
                        pRegion->DriveLetter = SpGetDriveLetter( TemporaryBuffer, NULL );
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (pass)? L"Extended" : L"Primary", pRegion->DriveLetter));
                    }
                }
            }
        }
    }
}


VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    )
{
    PWSTR p;
    NTSTATUS Status;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;
    STRING ntDeviceName;
    UCHAR deviceNameBuffer[256] = "\\Device\\Harddisk0\\Partition1";
    UCHAR systemRootBuffer[256] = "C:\\$WIN_NT$.~BT";
    ANSI_STRING ansiString;
    BOOLEAN ForceUnmap = FALSE;

    RTL_QUERY_REGISTRY_TABLE SetupTypeTable[]=
        {
          {NULL,
           RTL_QUERY_REGISTRY_DIRECT,
           L"DriveLetter",
           &StartDriveLetterFrom,
           REG_SZ,
           &Dummy,
           0
           },
          {NULL,0,NULL,NULL,REG_NONE,NULL,0}
        };

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DriveAssign_AT = %d.\n",(DriveAssign_AT ? 1 : 0)));


    //
    //  Determin whether how to drive assign is 98 (HD start is A) or
    //  AT (HD start C).
    //
    RtlInitUnicodeString(&StartDriveLetterFrom, NULL);
    RtlInitUnicodeString(&Dummy, NULL);

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                         L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                         SetupTypeTable,
                         NULL,
                         NULL);

    if (NT_SUCCESS(Status)) {
        if ((StartDriveLetterFrom.Buffer[0] == L'C') ||
        (StartDriveLetterFrom.Buffer[0] == L'c')) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DriveLetter is in setupreg.hiv.\n"));
            if (!DriveAssign_AT) {

                //
                // Delete hive value "DriveLetter".
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-assign as NEC assign.\n"));
                Status = RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                                L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                                L"DriveLetter");
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Fail to delete KEY DriveLetter.\n"));
                }
            }
        } else {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: There is no DriveLetter.\n"));
            if (DriveAssign_AT) {

                //
                // Add hive value "DriveLetter" as "C".
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-assign as AT assign.\n"));
                Status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                               L"\\Registry\\Machine\\System\\Setup",
                                               L"DriveLetter",
                                               REG_SZ,
                                               L"C",
                                               sizeof(L"C")+sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Fail to add KEY DriveLetter.\n"));
                }
            }
        }
        ForceUnmap = TRUE;
    }

    //
    // Cancel all drive letters and Remap drive letters.
    //
    if (ForceUnmap) {

    SpPtUnAssignDriveLetters();

    ntDeviceName.Buffer = deviceNameBuffer;
    ntDeviceName.MaximumLength = sizeof(deviceNameBuffer);
    ntDeviceName.Length = 0;

        ansiString.MaximumLength = sizeof(systemRootBuffer);
        ansiString.Length = 0;
        ansiString.Buffer = systemRootBuffer;

    IoAssignDriveLetters( *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock,
                  &ntDeviceName,
                  ansiString.Buffer,
                  &ansiString );
    }

    RtlFreeUnicodeString(&StartDriveLetterFrom);
    RtlFreeUnicodeString(&Dummy);
}


VOID
SpPtUnAssignDriveLetters(
    VOID
    )
{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;
    ULONG CdCount, cdrom, dlet;
    UNICODE_STRING linkString;
    WCHAR  tempBuffer[] = L"\\DosDevices\\A:";

    //
    // Release all drive letters of device.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
        for(pass=0; pass<2; pass++) {
            pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                UCHAR SystemId = SpPtGetPartitionType(pRegion);

                //pRegion->DriveLetter = 0;
                if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                    //
                    // Get the nt pathname for this region.
                    //
                    SpNtNameFromRegion(
                        pRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalOriginal
                        );
                    //
                    //  Assign a drive letter for this region
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: delete Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (pass)? L"Extended" : L"Primary", pRegion->DriveLetter));
                    SpDeleteDriveLetter( TemporaryBuffer );
                    pRegion->DriveLetter = 0;
                }
            }
        }
    }

    if(CdCount = IoGetConfigurationInformation()->CdRomCount) {

        //
        // Unlink CD-ROM drive letters.
        //
        for(cdrom=0; cdrom<CdCount; cdrom++) {
            swprintf(TemporaryBuffer,L"\\Device\\Cdrom%u",cdrom);
            SpDeleteDriveLetter( TemporaryBuffer );
        }
    }

    //
    // Delete all symbolic link related in drive letter.
    //
    for (dlet=0; dlet<26; dlet++) {
        tempBuffer[12] = (WCHAR)(L'A' + dlet);
        RtlInitUnicodeString( &linkString, tempBuffer);
        IoDeleteSymbolicLink (&linkString);
    }

}



#ifndef NEW_PARTITION_ENGINE

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    )
{
    PDISK_REGION pRegion;
    PDISK_REGION pNextDeleteRegion;
    BOOLEAN passedEndRegion = FALSE;
    BOOLEAN b;


#ifdef GPT_PARTITION_ENGINE

    if (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_GPT) {
        SpPtnDeletePartitionsForRemoteBoot(pDisk,
                startRegion,
                endRegion,
                Extended);

        return;                
    }

#endif    
    
    //
    // Delete all disk regions from startRegion to endRegion.
    //

    pRegion = startRegion;

    while (pRegion) {

        //
        // Before deleting this region, we need to save the next region
        // to delete, since the list may get modified as a result of
        // deleting this one (but a partitioned region won't get
        // changed, only free ones). Note that endRegion might
        // be unpartitioned so we need to be careful to check for
        // the exit case.
        //

        pNextDeleteRegion = pRegion->Next;

        while (pNextDeleteRegion) {
            if (pNextDeleteRegion->PartitionedSpace) {
                break;
            } else {
                if (pNextDeleteRegion == endRegion) {
                    passedEndRegion = TRUE;
                }
                pNextDeleteRegion = pNextDeleteRegion->Next;
            }
        }

        //
        // If this is the extended partition, first kill all the
        // logical drives.
        //

        if (IsContainerPartition(pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId)) {

            ASSERT(!Extended);

            SpPtDeletePartitionsForRemoteBoot(
                pDisk,
                pDisk->ExtendedDiskRegions,
                NULL,
                TRUE   // used to check for another recursion
                );

        }

        //
        // Remove any boot entries pointing to this region.
        //

        SpPtDeleteBootSetsForRegion(pRegion);

        //
        //  Get rid of the compressed drives, if any
        //

        if( pRegion->NextCompressed != NULL ) {
            SpDisposeCompressedDrives( pRegion->NextCompressed );
            pRegion->NextCompressed = NULL;
            pRegion->MountDrive  = 0;
            pRegion->HostDrive  = 0;
        }

        if (pRegion->PartitionedSpace) {
            b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
        }

        ASSERT(b);

        if ((pRegion == endRegion) ||
            passedEndRegion) {

            break;
        }

        pRegion = pNextDeleteRegion;

    }
}

#endif  // ! NEW_PARTITION_ENGINE


NTSTATUS
SpPtPartitionDiskForRemoteBoot(
    IN ULONG DiskNumber,
    OUT PDISK_REGION *RemainingRegion
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    ULONG PartitionCount = 0;
    ULONGLONG firstRegionStartSector;
    PDISK_REGION firstRegion = NULL, lastRegion = NULL;
    BOOLEAN IsGPTDisk = FALSE;

    pDisk = &PartitionedDisks[DiskNumber];

    IsGPTDisk = SPPT_IS_GPT_DISK(DiskNumber);
    
    //
    // Scan through the disk and see how many contiguous recognized
    // partitions there are.
    //

    if (pDisk->HardDisk->Status == DiskOffLine) {
        return STATUS_DEVICE_OFF_LINE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "SpPtPartitionDiskForRemoteBoot: cylinder size is %lx\n", 
        pDisk->HardDisk->SectorsPerCylinder));

    pRegion = pDisk->PrimaryDiskRegions;

    for( ; pRegion; pRegion=pRegion->Next) {

        if (!pRegion->PartitionedSpace) {
            //
            // If the region is not partitioned, then add it to our list
            // to merge if we have one.
            //
            if (firstRegion) {
                //
                // If this is a final free region covering the last
                // partial cylinder on the disk, then don't add it.
                //
                if ((pRegion->Next == NULL) &&
                    (pRegion->SectorCount < pDisk->HardDisk->SectorsPerCylinder) &&
                    ((pRegion->StartSector % pDisk->HardDisk->SectorsPerCylinder) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Skipping final partial cylinder free region %lx for %lx\n",
                        pRegion->StartSector, pRegion->SectorCount));
                } else {
                    lastRegion = pRegion;
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Adding free region %lx for %lx\n",
                        pRegion->StartSector, pRegion->SectorCount));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Skipping free region %lx for %lx\n",
                    pRegion->StartSector, pRegion->SectorCount));
            }
        } else {
            PON_DISK_PTE    pte;
            UCHAR           SystemId = 0;

            if (IsGPTDisk) {
                if (SPPT_IS_RECOGNIZED_FILESYSTEM(pRegion->Filesystem)) {
                    //
                    // TBD : Fix for cases where FT / Dynamic volumes can
                    // reside on the GPT disk
                    //
                    SystemId = PARTITION_FAT32;
                } else {
                    SystemId = PARTITION_ENTRY_UNUSED;
                }                    
            } else {                                
                SystemId = SpPtGetPartitionType(pRegion);
            }

            if (IsContainerPartition(SystemId)) {
                //
                // If this is the extended partition, we want to remove it.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Adding extended region [type %d] %lx for %lx\n",
                    SystemId, pRegion->StartSector, pRegion->SectorCount));
                    
                if (!firstRegion) {
                    firstRegion = pRegion;
                }
                
                lastRegion = pRegion;
            } else if ((PartitionNameIds[SystemId] == (UCHAR)(-1)) ||
                       (PartitionNameIds[SystemId] == PT(VERIT))) {
                //
                // For a recognized partition, remove it if we have already found
                // a firstRegion; otherwise we will start our list with this
                // region.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Adding recognized region [type %d] %lx for %lx\n",
                    SystemId, pRegion->StartSector, pRegion->SectorCount));
                    
                if (!firstRegion) {
                    firstRegion = pRegion;
                }
                
                lastRegion = pRegion;
            } else {
                //
                // If the partition is *not* recognized, and we have a list we
                // have been keeping, then stop before this one, otherwise
                // skip it.
                //

                if (firstRegion) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Stopping at unrecognized region [type %d] %lx for %lx\n",
                        SystemId, pRegion->StartSector, pRegion->SectorCount));
                        
                    break;
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Skipping unrecognized region [type %d] %lx for %lx\n",
                        SystemId, pRegion->StartSector, pRegion->SectorCount));
                }
            }
        }
    }

    //
    // We should have found at least one region. If we didn't then the
    // disk is alternating unpartitioned and unrecognized regions. In this
    // case, use the largest unpartitioned region.
    //

    if (firstRegion == NULL) {

        ULONGLONG BiggestUnpartitionedSectorCount = 0;

        pRegion = pDisk->PrimaryDiskRegions;
        
        for( ; pRegion; pRegion=pRegion->Next) {
            if (!pRegion->PartitionedSpace) {
                if (pRegion->SectorCount > BiggestUnpartitionedSectorCount) {
                    firstRegion = pRegion;
                    BiggestUnpartitionedSectorCount = pRegion->SectorCount;
                }
            }
        }
        
        if (firstRegion == NULL) {
            return STATUS_DEVICE_OFF_LINE;
        }
        
        lastRegion = firstRegion;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
            "Adding single free region %lx for %lx\n",
            firstRegion->StartSector, firstRegion->SectorCount));
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "first is %lx, last is %lx\n", firstRegion, lastRegion));

    //
    // If we found exactly one region and it has a known filesystem on
    // it, then we don't need to do any repartitioning. We still delete
    // if the filesystem is unknown because later in setup there are
    // some checks that the Filesystem is valid for this region, so by
    // deleting it here we will ensure that Filesystem becomes
    // NewlyCreated which is considered acceptable.
    //
    // We also don't need to repartition if we have just one region
    // and it is already unpartitioned.
    //

    if (firstRegion == lastRegion) {

        SpPtDeleteBootSetsForRegion(firstRegion);

        if (!firstRegion->PartitionedSpace) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "One region, unpartitioned, not repartitioning\n"));
                
            *RemainingRegion = firstRegion;
            
            return STATUS_SUCCESS;
            
        } else if ((firstRegion->Filesystem == FilesystemNtfs) ||
                   (firstRegion->Filesystem == FilesystemFat) ||
                   (firstRegion->Filesystem == FilesystemFat32)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "One region, filesystem %d, not repartitioning\n", 
                firstRegion->Filesystem));
                
            *RemainingRegion = firstRegion;
            
            return STATUS_SUCCESS;
        }
    }

    //
    // We need to remove all the regions between firstRegion and
    // lastRegion. Save the start sector of firstRegion for later,
    // since after this call firstRegion may be invalid.
    //

    firstRegionStartSector = firstRegion->StartSector;

    SpPtDeletePartitionsForRemoteBoot(
        pDisk,
        firstRegion,
        lastRegion,
        FALSE       // these are not extended regions
        );

    //
    // Now we need to find the region occupying the space we have
    // freed. We scan for the region that includes firstRegionStartSector
    // (the region we find may start before then if there was a small free
    // region before it).
    //

    for (pRegion = pDisk->PrimaryDiskRegions;
         pRegion;
         pRegion=pRegion->Next) {

        if (pRegion->StartSector <= firstRegionStartSector) {
            firstRegion = pRegion;
        } else {
            break;
        }
    }

    //
    // Return this -- SpPtPrepareDisks handles the case where the
    // selected region is free.
    //

    *RemainingRegion = firstRegion;

    return STATUS_SUCCESS;
}


//
// Hard Disk Inialize data for NEC98
//
#define IPL_SIZE 0x8000 //NEC98


NTSTATUS
SpInitializeHardDisk_Nec98(
    IN PDISK_REGION     pRegionDisk
)

{
    PHARD_DISK      pHardDisk;
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    ULONG i,bps;
    HANDLE Handle;
    NTSTATUS Sts;
    PUCHAR Buffer,UBuffer;
    ULONG       buffersize;
    ULONG       sectoraddress;
    PUCHAR      HdutlBuffer;
    IO_STATUS_BLOCK IoStatusBlock;

    pHardDisk = &HardDisks[pRegionDisk->DiskNumber];
    bps = HardDisks[pRegionDisk->DiskNumber].Geometry.BytesPerSector;
    Sts = SpOpenPartition0(pHardDisk->DevicePath,&Handle,TRUE);
    if(!NT_SUCCESS(Sts)) {
        return(Sts);
    }

    //
    // Initialize Hard Disk
    //

    if(bps==256){
        bps=512;
    }

    HdutlBuffer = SpMemAlloc(IPL_SIZE);
    if(!HdutlBuffer) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(HdutlBuffer,IPL_SIZE);

    //
    // Clear head of hard drive, instead of Physical Format.
    //
    Sts = SpReadWriteDiskSectors(Handle,0,(ULONG)(IPL_SIZE/bps),bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Set IPL Information
    //

    //
    // Write Boot Code
    //
    sectoraddress=0;
    switch(bps){
        case    2048:   buffersize=0x800; break;
        case    1024:   buffersize=0x400; break;
        case     256:   buffersize=0x100; break;
        case     512:   buffersize=0x200; break;
        default     :   buffersize=0x800; //***max***
                        bps=0x800;
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,x86PC98BootCode,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Write Volume Info
    //
    sectoraddress=1;
    switch(bps){
        case    2048:    buffersize=0x800; break;        //***1sec***
        case    1024:    buffersize=0xc00; break;        //***3sec***
        case     256:    buffersize=0x300; break;        //***3sec***
        case     512:    buffersize=0x200; break;        //***1sec***
        default     :    buffersize=0x800;               //***max****
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Write Boot Menu
    //
    switch(bps){
        case    2048:    buffersize=0x2000;    //***8KB***
                         sectoraddress=2;
                         break;
        case    1024:    buffersize=0x2000;    //***8KB***
                         sectoraddress=4;
                         break;
        case     256:    buffersize=0x1c00;    //***7KB***
                         sectoraddress=4;
                         break;
        case     512:    buffersize=0x1c00;    //***7KB***
                         sectoraddress=2;
                         break;
        default     :    buffersize=0x1c00;    //***min***
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,x86PC98BootMenu,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        return(Sts);
    }

    //
    // Write NTFT Signature.
    //
    RtlZeroMemory(HdutlBuffer,bps);
    ((PULONG)HdutlBuffer)[0] = SpComputeSerialNumber();
    ((PUSHORT)HdutlBuffer)[bps/2 - 1] = BOOT_RECORD_SIGNATURE;

    Sts = SpReadWriteDiskSectors(Handle,16,1,bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }
    SpMemFree(HdutlBuffer);
    ZwClose(Handle);

    //
    //  Do ShutDown
    //

    SpDisplayScreen(SP_SCRN_INIT_REQUIRES_REBOOT_NEC98,3,4);
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_F3_EQUALS_REBOOT,
        0
        );

    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3) ;
    HalReturnToFirmware(HalRebootRoutine);

    return(STATUS_SUCCESS);

}


VOID
SpReassignOnDiskOrdinals(
    IN PPARTITIONED_DISK pDisk
    )
{
#if defined(NEC_98) //NEC98
    PMBR_INFO pBrInfo;
    ULONG i;

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if((pte->SystemId != PARTITION_ENTRY_UNUSED)
            && !IsContainerPartition(pte->SystemId)) {

                //
                // Reset real disk potition into OnDiskordinals.
                // RealDiskPosition value is zero origin, but partition
                // number start one.
                //
                pBrInfo->OnDiskOrdinals[i] = pte->RealDiskPosition + 1;

            } else {

                pBrInfo->OnDiskOrdinals[i] = 0;

            }
        }
    }
#endif //NEC98
}


//
// Now, only for NEC98.
//
VOID
SpTranslatePteInfo(
    IN PON_DISK_PTE   pPte,
    IN PREAL_DISK_PTE pRealPte,
    IN BOOLEAN        Write // into real PTE
    )
{
    ASSERT(pRealPte);
    ASSERT(pPte);

    if( Write ) {
        //
        // Initialize PTE
        //
        RtlZeroMemory(pRealPte, sizeof(REAL_DISK_PTE));

        //
        // Copy PTE entries from real on-disk PTE.
        //
        pRealPte->ActiveFlag    = pPte->ActiveFlag;
        pRealPte->StartHead     = pPte->StartHead;
        pRealPte->StartSector   = pPte->StartSector;
        pRealPte->StartCylinder = pPte->StartCylinder;
        pRealPte->SystemId      = pPte->SystemId;
        pRealPte->EndHead       = pPte->EndHead;
        pRealPte->EndSector     = pPte->EndSector;
        pRealPte->EndCylinder   = pPte->EndCylinder;

        RtlMoveMemory(&pRealPte->RelativeSectors, &pPte->RelativeSectors,
                      sizeof(pPte->RelativeSectors)); //4

        RtlMoveMemory(&pRealPte->SectorCount, &pPte->SectorCount,
                      sizeof(pPte->SectorCount)); //4

    } else {
        //
        // Initialize PTE
        //
        RtlZeroMemory(pPte, sizeof(ON_DISK_PTE));

        //
        // Copy PTE entries from real on-disk PTE.
        //
        pPte->ActiveFlag    = pRealPte->ActiveFlag;
        pPte->StartHead     = pRealPte->StartHead;
        pPte->StartSector   = pRealPte->StartSector;
        pPte->StartCylinder = pRealPte->StartCylinder;
        pPte->SystemId      = pRealPte->SystemId;
        pPte->EndHead       = pRealPte->EndHead;
        pPte->EndSector     = pRealPte->EndSector;
        pPte->EndCylinder   = pRealPte->EndCylinder;

        RtlMoveMemory(&pPte->RelativeSectors, &pRealPte->RelativeSectors,
                      sizeof(pRealPte->RelativeSectors)); //4

        RtlMoveMemory(&pPte->SectorCount, &pRealPte->SectorCount,
                      sizeof(pPte->SectorCount)); //4
    }
}


//
// Now, only for NEC98.
//
VOID
SpTranslateMbrInfo(
    IN PON_DISK_MBR   pMbr,
    IN PREAL_DISK_MBR pRealMbr,
    IN ULONG          bps,
    IN BOOLEAN        Write // into real MBR
    )
{
    PREAL_DISK_PTE      pRealPte;
    PON_DISK_PTE        pPte;
    ULONG               TmpData;
    ULONG               i;


    pRealPte    = pRealMbr->PartitionTable;
    pPte        = pMbr->PartitionTable;

    ASSERT(pRealMbr);
    ASSERT(pMbr);

    if( Write ) {
        //
        // Initialize REAL_DISK_MBR
        //
        RtlZeroMemory(pRealMbr, sizeof(REAL_DISK_MBR));

        //
        // Copy MBR entries into real on-disk MBR.
        //
        RtlMoveMemory(&pRealMbr->BootCode, &pMbr->BootCode,
                      sizeof(pMbr->BootCode)); //440
        RtlMoveMemory(&pRealMbr->NTFTSignature, &pMbr->NTFTSignature,
                      sizeof(pMbr->NTFTSignature)); //4
        RtlMoveMemory(&pRealMbr->Filler, &pMbr->Filler,
                      sizeof(pMbr->Filler)); //2
        RtlMoveMemory(&pRealMbr->AA55Signature, &pMbr->AA55Signature,
                      sizeof(pMbr->AA55Signature)); //2

    } else {
        //
        // Initialize ON_DISK_MBR
        //
        RtlZeroMemory(pMbr, sizeof(ON_DISK_MBR));

        //
        // Copy MBR entries from real on-disk MBR.
        //
        RtlMoveMemory(&pMbr->BootCode, &pRealMbr->BootCode,
                      sizeof(pMbr->BootCode)); //440
        RtlMoveMemory(&pMbr->NTFTSignature, &pRealMbr->NTFTSignature,
                      sizeof(pMbr->NTFTSignature)); //4
        RtlMoveMemory(&pMbr->Filler, &pRealMbr->Filler,
                      sizeof(pMbr->Filler)); //2
        RtlMoveMemory(&pMbr->AA55Signature, &pRealMbr->AA55Signature,
                      sizeof(pMbr->AA55Signature)); //2
    }

    //
    // Translate PTEs from real on-disk PTEs.
    //
    for(i=0; i<NUM_PARTITION_TABLE_ENTRIES; i++) {
        SpTranslatePteInfo(&pPte[i], &pRealPte[i], Write);
    }
}


VOID
ConvertPartitionTable(
    IN PPARTITIONED_DISK pDisk,
    IN PUCHAR            Buffer,
    IN ULONG             bps
    )
{
#if defined(NEC_98) //NEC98
    PREAL_DISK_PTE_NEC98  PteNec;
    PON_DISK_PTE      p;
    ULONG             TmpData;
    ULONG             i;

    PteNec = (PREAL_DISK_PTE_NEC98)(Buffer + bps);
    p      = pDisk->MbrInfo.OnDiskMbr.PartitionTable;

    for(i=0; i<PTABLE_DIMENSION; i++) {

        switch  (PteNec[i].SystemId){

        case 0x00: // not use
            p[i].SystemId = PARTITION_ENTRY_UNUSED;
            break;

        case 0x01: // FAT 12bit
        case 0x81:
            p[i].SystemId = PARTITION_FAT_12;
            break;

        case 0x11: // FAT 16bit
        case 0x91:
            p[i].SystemId = PARTITION_FAT_16;
            break;

        case 0x21: // FAT huge
        case 0xa1:
            p[i].SystemId = PARTITION_HUGE;
            break;

        case 0x31: // IFS
        case 0xb1:
            p[i].SystemId = PARTITION_IFS;
            break;

        case 0x41: // IFS 2nd,orphan
        case 0xc1:
            p[i].SystemId = (PARTITION_IFS | PARTITION_NTFT);
            break;

        case 0x51: // IFS deleted
        case 0xd1:
            p[i].SystemId = (PARTITION_IFS | VALID_NTFT);
            break;

        case 0x61: // FAT32
        case 0xe1:
            p[i].SystemId = PARTITION_FAT32;
            break;

        case 0x08: // FAT 12bit 2nd,orphan
        case 0x88:
            p[i].SystemId = (PARTITION_FAT_12 | PARTITION_NTFT);
            break;

        case 0x18: // FAT 12bit deleted
        case 0x98:
            p[i].SystemId = (PARTITION_FAT_12 | VALID_NTFT);
            break;

        case 0x28: // FAT 16bit 2nd,orphan
        case 0xa8:
            p[i].SystemId = (PARTITION_FAT_16 | PARTITION_NTFT);
            break;

        case 0x38: // FAT 16bit deleted
        case 0xb8:
            p[i].SystemId = (PARTITION_FAT_16 | VALID_NTFT);
            break;

        case 0x48: // FAT huge 2nd,orphan
        case 0xc8:
            p[i].SystemId = (PARTITION_HUGE | PARTITION_NTFT);
            break;

        case 0x58: // FAT huge deleted
        case 0xd8:
            p[i].SystemId = (PARTITION_HUGE | VALID_NTFT);
            break;

        case 0x68: // LDM partition
        case 0xe8:
            p[i].SystemId = PARTITION_LDM;
            break;

        default: // other
            p[i].SystemId = PARTITION_XENIX_1;
        }

        if(p[i].SystemId == PARTITION_ENTRY_UNUSED) {
            p[i].ActiveFlag         = 0x00;
            p[i].StartHead          = 0x00;
            p[i].StartSector        = 0x00;
            p[i].StartCylinderLow   = 0x00;
            p[i].StartCylinderHigh  = 0x00;
            p[i].EndHead            = 0x00;
            p[i].EndSector          = 0x00;
            p[i].EndCylinderLow     = 0x00;
            p[i].EndCylinderHigh    = 0x00;
            p[i].RelativeSectors[0] = 0x00;
            p[i].RelativeSectors[1] = 0x00;
            p[i].RelativeSectors[2] = 0x00;
            p[i].RelativeSectors[3] = 0x00;
            p[i].SectorCount[0]     = 0x00;
            p[i].SectorCount[1]     = 0x00;
            p[i].SectorCount[2]     = 0x00;
            p[i].SectorCount[3]     = 0x00;
            p[i].IPLSector          = 0x00;
            p[i].IPLHead            = 0x00;
            p[i].IPLCylinderLow     = 0x00;
            p[i].IPLCylinderHigh    = 0x00;
            //p[i].Reserved[2]        = 0x00;
            p[i].Reserved[0]        = 0x00;
            p[i].Reserved[1]        = 0x00;
            p[i].OldSystemId        = 0x00;
            memset(p[i].SystemName,0,16);

        } else {

            p[i].ActiveFlag         = (PteNec[i].ActiveFlag & 0x80);
            p[i].StartHead          = PteNec[i].StartHead;
            p[i].StartSector        = PteNec[i].StartSector;
            p[i].StartCylinderLow   = PteNec[i].StartCylinderLow;
            p[i].StartCylinderHigh  = PteNec[i].StartCylinderHigh;
            p[i].EndHead            = PteNec[i].EndHead;
            p[i].EndSector          = PteNec[i].EndSector;
            p[i].EndCylinderLow     = PteNec[i].EndCylinderLow;
            p[i].EndCylinderHigh    = PteNec[i].EndCylinderHigh;
            p[i].IPLSector          = PteNec[i].IPLSector;
            p[i].IPLHead            = PteNec[i].IPLHead;
            p[i].IPLCylinderLow     = PteNec[i].IPLCylinderLow;
            p[i].IPLCylinderHigh    = PteNec[i].IPLCylinderHigh;
            p[i].Reserved[0]        = PteNec[i].Reserved[0];
            p[i].Reserved[1]        = PteNec[i].Reserved[1];
            p[i].OldSystemId        = PteNec[i].SystemId;

            memcpy(p[i].SystemName , PteNec[i].SystemName , 16);

            TmpData =  (ULONG)PteNec[i].StartCylinderLow;
            TmpData |= ((ULONG)PteNec[i].StartCylinderHigh << 8);
            U_ULONG(p[i].RelativeSectors) = RtlEnlargedUnsignedMultiply(TmpData,
                                                pDisk->HardDisk->SectorsPerCylinder).LowPart;


            TmpData =  (ULONG)(PteNec[i].EndCylinderLow + 1);
            // In case of Low is 0xFF, Overflowed bit will be loss by OR.
            TmpData += ((ULONG)PteNec[i].EndCylinderHigh << 8);
            U_ULONG(p[i].SectorCount) = RtlEnlargedUnsignedMultiply(TmpData,
                                            pDisk->HardDisk->SectorsPerCylinder).LowPart - U_ULONG(p[i].RelativeSectors);

            //
            // Set Ipl Address
            //
            TmpData =  (ULONG)PteNec[i].IPLCylinderLow;
            TmpData |= ((ULONG)PteNec[i].IPLCylinderHigh << 8);
            TmpData = RtlEnlargedUnsignedMultiply(TmpData,pDisk->HardDisk->SectorsPerCylinder).LowPart;
            TmpData += (ULONG)(PteNec[i].IPLHead * pDisk->HardDisk->Geometry.SectorsPerTrack);
            TmpData += PteNec[i].IPLSector;
            U_ULONG(p[i].IPLSectors) = TmpData;

        }
    }

    U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = ((PUSHORT)Buffer)[bps/2 - 1];
    if(bps == 256){
        U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = 0x0000;
    }
#endif //NEC98
}


#define IPL_SIGNATURE_NEC98 "IPL1"

VOID
SpDetermineFormatTypeNec98(
    IN PPARTITIONED_DISK pDisk,
    IN PREAL_DISK_MBR_NEC98 pRealMbrNec98
    )
{
    UCHAR FormatType;

    if(!IsNEC_98) {
        FormatType = DISK_FORMAT_TYPE_PCAT;

    } else {
        if(pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {
            //
            // All removable media are AT format.
            //
            FormatType = DISK_FORMAT_TYPE_PCAT;

        } else {
            if(U_USHORT(pRealMbrNec98->AA55Signature) == MBR_SIGNATURE) {
                if(!_strnicmp(pRealMbrNec98->IPLSignature,IPL_SIGNATURE_NEC98,
                              sizeof(IPL_SIGNATURE_NEC98)-1)) {
                    //
                    // NEC98-format requires AA55Signature and "IPL1".
                    //
                    FormatType = DISK_FORMAT_TYPE_NEC98;

                } else {
                    FormatType = DISK_FORMAT_TYPE_PCAT;

                }
            } else {
                FormatType = DISK_FORMAT_TYPE_UNKNOWN;

            }
        }
    }

    pDisk->HardDisk->FormatType = FormatType;
#if 0
    pDisk->HardDisk->MaxPartitionTables = ((FormatType == DISK_FORMAT_TYPE_PCAT) ?
        NUM_PARTITION_TABLE_ENTRIES : NUM_PARTITION_TABLE_ENTRIES_NEC98);
#endif //0

    return;
}



NTSTATUS
SpPtSearchLocalSourcesInDynamicDisk(
    IN ULONG    disk
    )
{
    NTSTATUS          Status;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE            DirectoryHandle;
    BOOLEAN           RestartScan;
    ULONG             Context;
    BOOLEAN           MoreEntries;
    POBJECT_DIRECTORY_INFORMATION DirInfo;


    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,HardDisks[disk].DevicePath);

    Status = ZwOpenDirectoryObject(&DirectoryHandle,DIRECTORY_ALL_ACCESS,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = SpQueryDirectoryObject(
                        DirectoryHandle,
                        RestartScan,
                        &Context
                        );

            if(NT_SUCCESS(Status)) {
                PWSTR   DirectoryName;

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)
                            ((PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer)->Buffer;

                wcsncpy(TemporaryBuffer,DirInfo->Name.Buffer,DirInfo->Name.Length / sizeof(WCHAR));
                (TemporaryBuffer)[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
                DirectoryName = SpDupStringW(TemporaryBuffer);
                SpStringToLower(TemporaryBuffer);
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Checking directory object %ws\\%ws \n", HardDisks[disk].DevicePath, DirectoryName));
                if( _wcsicmp(TemporaryBuffer,L"partition0") &&
                    wcsstr(TemporaryBuffer,L"partition") ) {

                    FilesystemType  FsType;
                    WCHAR           FsName[32];
                    ULONG           NameId;
                    ULONG           PartitionNumber;

                    PartitionNumber = SpStringToLong( DirectoryName + ((sizeof(L"partition") - sizeof(WCHAR)) / sizeof(WCHAR)),
                                                      NULL,
                                                      10 );
                    FsType = SpIdentifyFileSystem( HardDisks[disk].DevicePath,
                                                   HardDisks[disk].Geometry.BytesPerSector,
                                                   PartitionNumber );
                    NameId = SP_TEXT_FS_NAME_BASE + FsType;
                    SpFormatMessage( FsName,
                                     sizeof(FsName),
                                     NameId );

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: File system in dynamic volume %ws\\%ws is %ws. \n", HardDisks[disk].DevicePath, DirectoryName, FsName));
                    if( FsType >= FilesystemFirstKnown ) {
                        PWSTR LocalSourceFiles[1] = { LocalSourceDirectory };

                        wcscpy( TemporaryBuffer,HardDisks[disk].DevicePath );
                        SpConcatenatePaths( TemporaryBuffer,DirectoryName );

                        if(SpNFilesExist(TemporaryBuffer,LocalSourceFiles,ELEMENT_COUNT(LocalSourceFiles),TRUE)) {
                            //
                            //  Found local source directory
                            //
                            PDISK_REGION pRegion;

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Found %ws in dynamic volume %ws\\%ws. \n", LocalSourceDirectory, HardDisks[disk].DevicePath, DirectoryName));
                            pRegion = SpPtAllocateDiskRegionStructure( disk,
                                                                       0,
                                                                       0,
                                                                       TRUE,
                                                                       NULL,
                                                                       PartitionNumber );
                            pRegion->DynamicVolume = TRUE;
                            pRegion->DynamicVolumeSuitableForOS = FALSE;
                            pRegion->IsLocalSource = TRUE;
                            pRegion->Filesystem = FsType;
                            LocalSourceRegion = pRegion;
                            MoreEntries = FALSE;
                        }
                    }
                }
                SpMemFree( DirectoryName );
            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries);

        ZwClose(DirectoryHandle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws directory. Status = %lx\n", HardDisks[disk].DevicePath, Status));
    }
    return( Status );
}


VOID
SpPtFindLocalSourceRegionOnDynamicVolumes(
    VOID
    )
{
    ULONG             disk;
    PPARTITIONED_DISK partdisk;
    PDISK_REGION      pRegion;
    BOOLEAN           DiskIsDynamic;
    ULONG             pass;

    ASSERT(HardDisksDetermined);


    //
    // For each hard disk attached to the system, read its partition table.
    //
    for(disk=0; disk<HardDiskCount && !LocalSourceRegion; disk++) {
        partdisk = &PartitionedDisks[disk];
        DiskIsDynamic = FALSE;
        for( pass=0;
             (pass < 2) &&  !DiskIsDynamic;
             pass++ ) {
            for( pRegion = ((pass == 0)? partdisk->PrimaryDiskRegions : partdisk->ExtendedDiskRegions);
                 pRegion && !DiskIsDynamic;
                 pRegion = pRegion->Next ) {
                if( pRegion->DynamicVolume ) {
                    //
                    //  This is a dynamic disk.
                    //
                    DiskIsDynamic = TRUE;
                    //
                    // Scan all dynamic volumes in the disk for the $win_nt$.~ls
                    //
                    SpPtSearchLocalSourcesInDynamicDisk( disk );
                }
            }
        }
    }
}



NTSTATUS
SpPtCheckDynamicVolumeForOSInstallation(
    IN PDISK_REGION Region
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONG bps;
    ULONG r;
    ULONG StartSector;
    ULONG SectorCount;
    ULONG RelativeSectors;

    ASSERT(Region->DynamicVolume);

    Status = SpOpenPartition( HardDisks[Region->DiskNumber].DevicePath,
                              SpPtGetOrdinal(Region,PartitionOrdinalOnDisk),
                              &Handle,
                              FALSE );

#if DBG
    SpNtNameFromRegion( Region,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalOnDisk);
#endif

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open dynamic volume %ws. Status = %lx\n",TemporaryBuffer, Status));
        return(Status);
    }
    
    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(NT_SUCCESS(Status)) {
        bps = HardDisks[Region->DiskNumber].Geometry.BytesPerSector;
        RelativeSectors = 0;

        if( SpPtLookupRegionByStart(&PartitionedDisks[Region->DiskNumber],
                                    TRUE,
                                    Region->StartSector) == Region ) {
            //
            //  The region is on an extended partition (logical drive)
            //

            PON_DISK_PTE pte;

            //
            // TBD : fix this
            //
            pte = &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];
            RelativeSectors = U_ULONG(pte->RelativeSectors);
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is logical drive on extended partition. RelativeSectors = %lx \n",TemporaryBuffer, RelativeSectors));
        }

        StartSector = RtlExtendedLargeIntegerDivide(PartitionInfo.StartingOffset,bps,&r).LowPart;
        SectorCount = RtlExtendedLargeIntegerDivide(PartitionInfo.PartitionLength,bps,&r).LowPart;
        Region->DynamicVolumeSuitableForOS = ((Region->StartSector + RelativeSectors) == StartSector) &&
                                             ((Region->SectorCount - RelativeSectors) == SectorCount);

        if( Region->DynamicVolumeSuitableForOS ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is suitable for OS installation\n",TemporaryBuffer));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is not suitable for OS installation\n",TemporaryBuffer));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    StartSector = %lx (from MBR)\n", Region->StartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    SectorCount = %lx (from MBR)\n", Region->SectorCount));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    StartSector = %lx (from IOCTL_DISK_GET_PARTITION_INFO)\n", StartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    SectorCount = %lx (from IOCTL_DISK_GET_PARTITION_INFO)\n", SectorCount));
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get partition info for dynamic volume %ws. Status = %lx\n",TemporaryBuffer, Status));
    }

    ZwClose(Handle);
    return(Status);
}


UCHAR
SpPtGetPartitionType(
    IN PDISK_REGION Region
    )
{
    UCHAR   SystemId = PARTITION_ENTRY_UNUSED;

    if (!Region->PartitionedSpace)
        return SystemId;

#ifdef OLD_PARTITION_ENGINE
    SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;
#endif      

#ifdef NEW_PARTITION_ENGINE
    SystemId = PARTITION_FAT32;

    if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
        SystemId = SPPT_GET_PARTITION_TYPE(Region);   
    }        
#endif                                

#ifdef GPT_PARTITION_ENGINE
    SystemId = PARTITION_FAT32;
    
    if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
        SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;
    }
#endif    

    return SystemId;
}    

BOOLEAN
SpPtnIsRegionSpecialMBRPartition(
    IN PDISK_REGION Region
    )
{   
    BOOLEAN Result = FALSE;

    if (Region && SPPT_IS_MBR_DISK(Region->DiskNumber) && 
        SPPT_IS_REGION_PARTITIONED(Region)) {

        UCHAR PartId = PartitionNameIds[SPPT_GET_PARTITION_TYPE(Region)];
        
        Result = (PartId != (UCHAR)0xFF) && 
                 (SPPT_GET_PARTITION_TYPE(Region) != PARTITION_LDM) &&
                 ((PartId + SP_TEXT_PARTITION_NAME_BASE) != 
                    SP_TEXT_PARTITION_NAME_UNK);
    }

    return Result;
}              

PWSTR
SpPtnGetPartitionName(
    IN PDISK_REGION Region,
    IN OUT PWSTR NameBuffer,
    IN ULONG NameBufferSize
    )
/*++

Routine Description:

    Formats the name of the partition, with volume label
    and file system type and returns it.

    Note : Region is assumed to be of partitioned type

Arguments:

    Region - The region whose name is to be formatted

    NameBuffer - Buffer in which the name needs to be formatted

    NameBuffer - The size of the NameBuffer (in characters)

Return Value:

    Formatted partition name for the region, if any.

--*/
{
    BOOLEAN SpecialPartition = FALSE;
    
    if (NameBuffer) {
        if (Region) {
            if (SpPtnIsRegionSpecialMBRPartition(Region)) {
                WCHAR Buffer[128];

                SpFormatMessage(Buffer, sizeof(Buffer),
                    SP_TEXT_PARTITION_NAME_BASE + 
                        PartitionNameIds[SPPT_GET_PARTITION_TYPE(Region)]);
                    
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_3,
                    Region->PartitionNumber,
                    Buffer);                    
            } else if (Region->VolumeLabel[0]) {
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_1,
                    Region->PartitionNumber,
                    Region->VolumeLabel,
                    Region->TypeName);
            } else {
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_2,
                    Region->PartitionNumber,
                    Region->TypeName);
            }

            wcsncpy(NameBuffer, TemporaryBuffer, NameBufferSize - 1);
            NameBuffer[NameBufferSize - 1] = 0; // Null terminate
        } else {
            *NameBuffer = 0;    // Null terminate
        }
    }

    return NameBuffer;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spntupg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spntupg.h

Abstract:

    initializing and maintaining list of nts to upgrade

Author:

    Sunil Pai (sunilp) 26-Nov-1993

Revision History:

--*/

//
// Public functions
//

ENUMUPGRADETYPE
SpFindNtToUpgrade(
    IN PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    );

BOOLEAN
SpDoBuildsMatch(
    IN PVOID SifHandle,
    ULONG TestBuildNum,
    NT_PRODUCT_TYPE TestBuildType,
    ULONG TestBuildSuiteMask,
    BOOLEAN CurrentProductIsServer,
    ULONG CurrentSuiteMask,
    IN LCID LangId
    );

BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    );    

//
// Private functions
//
BOOLEAN
SppResumingFailedUpgrade(
    IN PDISK_REGION Region,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN BOOLEAN     AllowCancel
    );

VOID
SppUpgradeDiskFull(
    IN PDISK_REGION OsRegion,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN PDISK_REGION SysPartRegion,
    IN ULONG        MinOsFree,
    IN ULONG        MinSysFree,
    IN BOOLEAN      Fatal
    );

ENUMUPGRADETYPE
SppSelectNTToRepairByUpgrade(
    OUT PSP_BOOT_ENTRY *BootSetChosen
    );

ENUMUPGRADETYPE
SppNTMultiFailedUpgrade(
    PDISK_REGION   OsPartRegion,
    PWSTR          OsLoadFileName,
    PWSTR          LoadIdentifier
    );

VOID
SppNTMultiUpgradeDiskFull(
    PDISK_REGION   OsRegion,
    PWSTR          OsLoadFileName,
    PWSTR          LoadIdentifier,
    PDISK_REGION   SysPartRegion,
    ULONG          MinOsFree,
    ULONG          MinSysFree
    );

VOID
SppBackupHives(
    PDISK_REGION TargetRegion,
    PWSTR        SystemRoot
    );

BOOLEAN
SppWarnUpgradeWorkstationToServer(
    IN ULONG    MsgId
    );

NTSTATUS
SpGetMediaDetails(
    IN  PWSTR     CdInfDirPath,
    OUT PCCMEDIA  MediaObj 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sppartp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartp.h

Abstract:

    Private header file for partitioning engine and UI.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/



#ifndef _SPPARTITP_
#define _SPPARTITP_

#define MBR_SIGNATURE       0xaa55


BOOLEAN
SpPtDoPartitionSelection(
    IN OUT PDISK_REGION *Region,
    IN     PWSTR         RegionDescription,
    IN     PVOID         SifHandle,
    IN     BOOLEAN       Unattended,
    IN     PWSTR         SetupSourceDevicePath,
    IN     PWSTR         DirectoryOnSetupSource,
    IN     BOOLEAN       RemoteBootRepartition,
    OUT PBOOLEAN Win9xInstallationPresent
    );

BOOLEAN
SpPtDeterminePartitionGood(
    IN PDISK_REGION Region,
    IN ULONGLONG    RequiredKB,
    IN BOOLEAN      DisallowOtherInstalls
    );

BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    );
    

VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    );

ULONG
SpComputeSerialNumber(
    VOID
    );

NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    );

VOID
SpPtDoCommitChanges(
    VOID
    );

VOID
FatalPartitionUpdateError(
    IN PWSTR DiskDescription
    );

NTSTATUS
FmtFillFormatBuffer(
    IN  ULONGLONG NumberOfSectors,
    IN  ULONG SectorSize,
    IN  ULONG SectorsPerTrack,
    IN  ULONG NumberOfHeads,
    IN  ULONGLONG NumberOfHiddenSectors,
    OUT PVOID    FormatBuffer,
    IN  ULONG    FormatBufferSize,
    OUT PULONGLONG SuperAreaSize,
    IN  PULONG   BadSectorsList,
    IN  ULONG    NumberOfBadSectors,
    OUT PUCHAR   SystemId
    );

VOID
SpPtMarkActive(
    IN ULONG TablePosition
    );

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    );

BOOLEAN
SpPtValidateCColonFormat(
    IN PVOID        SifHandle,
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN BOOLEAN      CheckOnly,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    );

PDISK_REGION
SpPtValidSystemPartition(
    VOID
    );

ULONG
SpDetermineDisk0(
    VOID
    );


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    );


#endif // ndef _SPPARTITP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spprecmp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    spprecmp.h

Abstract:

    precompiled header for textmode setup

Revision History:

--*/

#pragma once

#if !defined(NOWINBASEINTERLOCK)
#define NOWINBASEINTERLOCK
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#include "msg.h"
#include "textmode.h"

#define ACTUAL_MAX_PATH 320
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spprintf.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spprintf.h

Abstract:

    safer sprintf variants

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/
#pragma once
#include <stdarg.h>

//
// _snprintf and co. do not write a terminal nul when the string just fits.
// These function do.
//

// use instead of VsNprintf or Vsprintf
// VN V
void         SpFormatStringVaA(PSTR Buffer, SIZE_T Size,  PCSTR Format, va_list Args);

// use instead of sNprintf or sprintf
// N .
void __cdecl SpFormatStringA(PSTR Buffer, SIZE_T Size,  PCSTR Format, ...);

// use instead of VsNWprintf or VsWprintf
// VNW VW
void         SpFormatStringVaW(PWSTR Buffer, SIZE_T Size, PCWSTR Format, va_list Args);

// use instead of sNWprintf or sWprintf
// NW W
void __cdecl SpFormatStringW(PWSTR Buffer, SIZE_T Size, PCWSTR Format, ...);

NTSTATUS __cdecl SpFormatStringWToA(PSTR Buffer, SIZE_T Size, PCWSTR Format, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spprintf.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spprintf.c

Abstract:

    safer sprintf variants

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include <stdarg.h>
#include <stdio.h>
#include "spprintf.h"
#include "spcab.h"

//
// _snprintf and co. do not write a terminal nul when the string just fits.
// These function do.
//

void
SpFormatStringVaA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
            _vsnprintf(Buffer, Size, Format, Args);
        Buffer[Size] = 0;
    }
}

void
__cdecl
SpFormatStringA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    SpFormatStringVaA(Buffer, Size, Format, Args);
    va_end(Args);
}

void
SpFormatStringVaW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
            _vsnwprintf(Buffer, Size, Format, Args);
        Buffer[Size] = 0;
    }
}

void
__cdecl
SpFormatStringW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    SpFormatStringVaW(Buffer, Size, Format, Args);
    va_end(Args);
}

NTSTATUS
__cdecl
SpFormatStringWToA(
    PSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    ...
    )
{
    va_list Args;
    UNICODE_STRING UnicodeBuffer = { 0 };
    ANSI_STRING AnsiBuffer = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    va_start(Args, Format);

    UnicodeBuffer.Buffer = (PWSTR)SpMemAlloc(Size * sizeof(UnicodeBuffer.Buffer[0]));
    if (UnicodeBuffer.Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    if (Size != 0) {
        UnicodeBuffer.Buffer[0] = 0;
    }
    SpFormatStringVaW(UnicodeBuffer.Buffer, Size, Format, Args);

    UnicodeBuffer.Length = (USHORT)(wcslen(UnicodeBuffer.Buffer) + 1) * sizeof(UnicodeBuffer.Buffer[0]);
    AnsiBuffer.MaximumLength = (USHORT)Size * sizeof(AnsiBuffer.Buffer[0]);
    Status = SpUnicodeStringToAnsiString(&AnsiBuffer, &UnicodeBuffer, FALSE);

Exit:
    va_end(Args);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spptdump.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptdump.h

Abstract:

    Various dump routines for partition, disk and
    file system information

Author:

    Vijay Jayaseelan    (vijayj)

Revision History:

    None

--*/


#ifndef _SPPTDUMP_H_
#define _SPPTDUMP_H_

#define SPPT_GET_PARTITION_STYLE_STR(_Style) \
    (((_Style) == PARTITION_STYLE_MBR) ? (L"MBR") : \
        (((_Style) == PARTITION_STYLE_GPT) ? (L"GPT") : (L"UNKNOWN")))

PWSTR
SpPtGuidToString(
    IN GUID* Guid,
    IN OUT PWSTR Buffer
    );


VOID
SpPtDumpDiskRegion(
    IN PDISK_REGION Region
    );
    
VOID
SpPtDumpDiskRegionInformation(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ExtendedRegionAlso
    );

VOID
SpPtDumpDiskDriveInformation(
    IN BOOLEAN ExtenedRegionAlso
    );

VOID
SpPtDumpPartitionInformation(
    IN PPARTITION_INFORMATION_EX PartInfo
    );

VOID
SpPtDumpDriveLayoutInformation(
    IN PWSTR DevicePath,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    );

VOID
SpPtDumpFSAttributes(
    IN PFILE_FS_ATTRIBUTE_INFORMATION  FsAttrs
    );

VOID
SpPtDumpFSSizeInfo(
    IN PFILE_FS_SIZE_INFORMATION FsSize
    );

VOID
SpPtDumpFSVolumeInfo(
    IN PFILE_FS_VOLUME_INFORMATION FsVolInfo
    );
   
#endif // for _SPPTDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spreg.c ===
#include "spprecmp.h"
#pragma hdrstop



NTSTATUS
SpDeleteServiceEntry(
    IN PWCHAR ServiceKey
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;

    RtlInitUnicodeString(&UnicodeString,ServiceKey);
    InitializeObjectAttributes(&Obja,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = ZwOpenKey(&KeyHandle,KEY_WRITE|DELETE,&Obja);

    if(NT_SUCCESS(Status)) {
        Status = ZwDeleteKey(KeyHandle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwDeleteKey of %ws returned %lx\n",ServiceKey,Status));
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwOpenKey of %ws returned %lx\n",ServiceKey,Status));
    }

    return(Status);
}


NTSTATUS
SpCreateServiceEntry(
    IN  PWCHAR  ImagePath,
    IN OUT PWCHAR *ServiceKey
    )

/*++

Routine Description:

    Create an services entry in the registry suitable for loading
    a given device driver file.

Arguments:

    ImagePath - supplies the fully-qualified pathname of the device driver.

    ServiceKey - If *ServiceKey is not NULL, then it specifies the registry
        path to the service node for this driver. If it is NULL, then it
        receives a pointer to a buffer containing the name of the
        service node created by this routine.  The caller must free this
        buffer via SpMemFree when finished.

Return Value:

    Status code indicating outcome.

--*/

{
    WCHAR KeyName[128];
    WCHAR FilePart[32];
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE KeyHandle;
    ULONG u;
    NTSTATUS Status;
    PWSTR p;
    BYTE DataBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    ULONG ResultLength;
    
    if (*ServiceKey) {
        wcscpy(KeyName, *ServiceKey);
    } else {
        //
        // Isolate the name of the device driver file from its path.
        //
        if(p = wcsrchr(ImagePath,L'\\')) {
            p++;
        } else {
            p = ImagePath;
        }
        wcsncpy(FilePart,p,(sizeof(FilePart)/sizeof(FilePart[0]))-1);
        FilePart[(sizeof(FilePart)/sizeof(FilePart[0]))-1] = 0;
        if(p=wcsrchr(FilePart,L'.')) {
            *p = 0;
        }

        //
        // Form a unique key name in
        // HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services.
        //

        swprintf(
            KeyName,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%ws",
            FilePart
            );
    }

    //
    // Attempt to create the key for the service.
    //
    RtlInitUnicodeString(&UnicodeString,KeyName);
    InitializeObjectAttributes(&Obja,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_READ | KEY_WRITE,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCreateServiceEntry: ZwCreateKey %ws returns %lx\n",KeyName,Status));
        return(Status);
    }


    //
    // Set the ImagePath value in the service key.
    //
    RtlInitUnicodeString(&UnicodeString,L"ImagePath");
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_SZ,
                ImagePath,
                (wcslen(ImagePath) + 1) * sizeof(WCHAR)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set ImagePath value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }

    //
    // Set the Type value in the service key. If the type is preset in the registry to SERVICE_FILE_SYSTEM_DRIVER
    // leave it alone.  Otherwise set it to SERVICE_KERNEL_DRIVER.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_TYPE);
 
    ResultLength = 0;
    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             (PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer,
                             sizeof(DataBuffer),
                             &ResultLength);

    if( NT_SUCCESS(Status) && 
        ResultLength &&
        ( (INT) ( (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer)->Type == REG_DWORD ) &&
        ( (INT) *(( (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer)->Data) == SERVICE_FILE_SYSTEM_DRIVER ) ) {
    
        u = SERVICE_FILE_SYSTEM_DRIVER;
    }
    else { 
        //
        // If the type is not preset in the registry to SERVICE_FILE_SYSTEM_DRIVER set it to SERVICE_KERNEL_DRIVER by default.
        //
        u = SERVICE_KERNEL_DRIVER;
    }
    
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &u,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set Type value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }

    //
    // Set the Start value in the service key.
    //
    u = SERVICE_DEMAND_START;
    RtlInitUnicodeString(&UnicodeString,L"Start");
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &u,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set Start value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }


  cs1:

    //
    // If we were not entirely successful creating the service,
    // we'll want to clean it out here.  Otherwise duplicate the KeyName
    // string to return to the caller, if it was not passed in.
    //
    if(NT_SUCCESS(Status)) {

        if (*ServiceKey == NULL) {
            if((*ServiceKey = SpDupStringW(KeyName)) == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        //
        // Remove the key we just created.
        //
        s = ZwDeleteKey(KeyHandle);
        if(!NT_SUCCESS(s)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwDeleteKey of %ws returned %lx\n",KeyName,s));
        }
    }

    NtClose(KeyHandle);

    return(Status);
}




NTSTATUS
SpLoadDeviceDriver(
    IN PWSTR Description,
    IN PWSTR PathPart1,
    IN PWSTR PathPart2,     OPTIONAL
    IN PWSTR PathPart3      OPTIONAL
    )

/*++

Routine Description:

    Load a device driver by creating a services entry for the driver and
    then calling the I/O subsystem.

Arguments:

    Description - supplies a human-readable description of the driver
        or hardware that the driver targets.

    PathPart1 - supplies first part of full pathname to driver file.

    PathPart2 - if specified, supplies the second part of the full pathname;
        PathPart2 will be concatenated to PathPart1. If not specified,
        then PathPart1 is the full path.

    PathPart3 - if specified, supplies a third part of the full pathname;
        PathPart3 will be concatenated to PathPart1 and PathPart2.

Return Value:

    Status code indicating outcome.

--*/

{
    PWCHAR FullName;
    NTSTATUS Status;
    PWCHAR ServiceKey;
    UNICODE_STRING ServiceKeyU;
    PWSTR pwstr;

    SpDisplayStatusText(
        SP_STAT_LOADING_DRIVER,
        DEFAULT_STATUS_ATTRIBUTE,
        Description
        );

    pwstr = TemporaryBuffer;

    //
    // Form the full name of the device driver file.
    //
    wcscpy(pwstr,PathPart1);
    if(PathPart2) {
        SpConcatenatePaths(pwstr,PathPart2);
    }
    if(PathPart3) {
        SpConcatenatePaths(pwstr,PathPart3);
    }

    FullName = SpDupStringW(pwstr);

    //
    // Create a service entry for the driver.
    //
    ServiceKey = NULL;
    Status = SpCreateServiceEntry(FullName,&ServiceKey);
    if(NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&ServiceKeyU,ServiceKey);

        //
        // Attempt to load the driver.
        //
        Status = ZwLoadDriver(&ServiceKeyU);
        if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwLoadDriver %ws returned %lx\n",FullName,Status));

            //
            // Remove the service entry we created in the registry.
            //
            SpDeleteServiceEntry(ServiceKey);
        }

        SpMemFree(ServiceKey);
    }

    SpMemFree(FullName);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spptdump.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptdump.c

Abstract:

    Various dump routines for partition, disk and
    file system information

Author:

    Vijay Jayaseelan    (vijayj)


Revision History:

    None

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>
#include <diskguid.h>


//
// The dump level for dump routines
//
//#define PARTITION_DUMP_LEVEL    DPFLTR_ERROR_LEVEL
#define PARTITION_DUMP_LEVEL    DPFLTR_INFO_LEVEL

ULONG SPPT_DUMP_LEVEL = PARTITION_DUMP_LEVEL;

PWSTR
SpPtGuidToString(
    IN GUID* Guid,
    IN OUT PWSTR Buffer
    )
/*++

Routine Description:

    Converts a given GUID to string representation    
    
Arguments:

    Guid    -   The GUID that needs string representation
    Buffer  -   Place holder for string version of the GUID

Return Value:

    Returns the converted string version of the given GUID

--*/            
{
    if (Guid && Buffer) {
        swprintf(Buffer, L"(%x-%x-%x-%x%x%x%x%x%x%x%x)",
                   Guid->Data1, Guid->Data2,
                   Guid->Data3,
                   Guid->Data4[0], Guid->Data4[1],
                   Guid->Data4[2], Guid->Data4[3],
                   Guid->Data4[4], Guid->Data4[5],
                   Guid->Data4[6], Guid->Data4[7]);
    }        

    if (!Guid && Buffer)
        *Buffer = UNICODE_NULL;

    return Buffer;
}

VOID
SpPtDumpDiskRegion(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Dumps the details for the given disk region
    
Arguments:

    Region  -   The region whose information needs to be
                dumped

Return Value:

    None

--*/           
{
    if (Region) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: Region:%p,DiskNumber=%d,PartitionNumber=%d,Sector-Start=%I64d,"
            "Sector-Count=%I64d,\nFreeSpace=%I64dKB,AdjustedFreeSpace=%I64dKB,"
            "FileSystem=%d,Partitioned:%d,Dirty:%d,Deleted:%d,EPType=%d,Container=%p,Sys:%d\n,"
            "DynVol=%d,DynVolSuitable=%d\n",
            Region,
            Region->DiskNumber,
            Region->PartitionNumber,
            Region->StartSector,
            Region->SectorCount,
            Region->FreeSpaceKB,
            Region->AdjustedFreeSpaceKB,
            Region->Filesystem,
            Region->PartitionedSpace,
            Region->Dirty,
            Region->Delete,
            Region->ExtendedType,
            Region->Container,
            Region->IsSystemPartition,
            Region->DynamicVolume,
            Region->DynamicVolumeSuitableForOS
            ));            
    }            
}


VOID
SpPtDumpDiskRegionInformation(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ExtendedRegionAlso
    )
/*++

Routine Description:

    Dumps all the regions for the given disk
    
Arguments:

    DiskNumber  :   Disk whose regions need to be dumped
    ExtenededRegionAlso :   Whether the extended region also
                            needs to be dumped.

Return Value:

    None

--*/            
{
    if (DiskNumber < HardDiskCount) {
        PDISK_REGION    Region = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: Dumping Primary Regions for DiskNumber=%d\n",
            DiskNumber));

        while (Region) {
            SpPtDumpDiskRegion(Region);
            Region = Region->Next;                                                    
        }

        if (ExtendedRegionAlso) {
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
                "SETUP: Dumping Extended Regions for DiskNumber=%d\n",
                DiskNumber));

            Region = PartitionedDisks[DiskNumber].ExtendedDiskRegions;                           
                
            while (Region) {
                SpPtDumpDiskRegion(Region);
                Region = Region->Next;                                                    
            }
        }
    }       
}

VOID
SpPtDumpDiskDriveInformation(
    IN BOOLEAN ExtenedRegionAlso
    )
/*++

Routine Description:

    Dumps the region information for all the disks
    
Arguments:

    ExtendedRegionAlso  :   Indicates whether to dump the
                            regions in the exteneded region
                            or not

Return Value:

    None
    
--*/            
{
    ULONG           DiskNumber;
    PDISK_REGION    pDiskRegion;

    for ( DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++ ) {
        SpPtDumpDiskRegionInformation(DiskNumber, ExtenedRegionAlso);
    }
}

VOID
SpPtDumpPartitionInformation(
    IN PPARTITION_INFORMATION_EX PartInfo
    )
/*++

Routine Description:

    Dumps all the information in the given PARTITION_INFORMATION_EX
    structure (header all the partition entries)
            
Arguments:

    PartInfo    -   The partition information structure that needs to
                    be dumped

Return Value:

    None

--*/            
{
    if (PartInfo) {        
        PPARTITION_INFORMATION_MBR  MbrInfo;
        PPARTITION_INFORMATION_GPT  GptInfo;
        WCHAR   GuidBuffer1[256];
        WCHAR   GuidBuffer2[256];
        
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: PartitionInformation = Number:%d, Style:%ws,"
            "Start=%I64u, Length = %I64u, Rewrite:%d\n",
            PartInfo->PartitionNumber,
            SPPT_GET_PARTITION_STYLE_STR(PartInfo->PartitionStyle),
            PartInfo->StartingOffset.QuadPart,
            PartInfo->PartitionLength.QuadPart,
            PartInfo->RewritePartition));    

        switch (PartInfo->PartitionStyle) {
            case PARTITION_STYLE_MBR:
                MbrInfo = &(PartInfo->Mbr);
                
                KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,
                            "Type:%d,Active:%d,Recognized:%d,HiddenSectors:%d\n",
                            MbrInfo->PartitionType,
                            MbrInfo->BootIndicator,
                            MbrInfo->RecognizedPartition,
                            MbrInfo->HiddenSectors));
                            
                break;
        
            case PARTITION_STYLE_GPT:
                GptInfo = &(PartInfo->Gpt);

                KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,
                            "Type:%ws,Id:%ws,Attributes:%I64X,Name:%ws\n",
                            SpPtGuidToString(&GptInfo->PartitionType, GuidBuffer1),
                            SpPtGuidToString(&GptInfo->PartitionId, GuidBuffer2),
                            GptInfo->Attributes,
                            GptInfo->Name));
                                                            
                break;

            default:
                break;
        }
    }
}

VOID
SpPtDumpDriveLayoutInformation(
    IN PWSTR DevicePath,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )
/*++

Routine Description:

    Dumps the drive layout information for the given
    device
    
Arguments:

    DevicePath  -  The device whose drive layout is being 
                    dumped

    DriveLayout -   The drive layout structure that needs to
                    be dumped

Return Value:

    None

--*/            
{
    if (DriveLayout) {
        ULONG Index;

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "\nSETUP: Drive layout for %ws with %d partitions (%ws)\n",
              DevicePath,
              DriveLayout->PartitionCount,
              SPPT_GET_PARTITION_STYLE_STR(DriveLayout->PartitionStyle)
              ));

        if (DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "Signature:%X\n", DriveLayout->Mbr.Signature));
        } else {
            WCHAR   GuidBuffer[256];
            PDRIVE_LAYOUT_INFORMATION_GPT Gpt = &(DriveLayout->Gpt);
            
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "Disk Guid:%ws,Starting Usable Offset:%I64d,Usable Length:%I64d,"
              "MaxPartitionCount:%u\n",
              SpPtGuidToString(&Gpt->DiskId, GuidBuffer),
              Gpt->StartingUsableOffset.QuadPart,
              Gpt->UsableLength.QuadPart,
              Gpt->MaxPartitionCount));
        }

        for (Index=0; Index < DriveLayout->PartitionCount; Index++) {
            SpPtDumpPartitionInformation(&(DriveLayout->PartitionEntry[Index]));
        }

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, "\n"));        
    }
}


VOID
SpPtDumpFSAttributes(
    IN PFILE_FS_ATTRIBUTE_INFORMATION  FsAttrs
    )
/*++

Routine Description:

    Dumps the given file system attribute information
    structure.    
    
Arguments:

    FsAttrs :   The file system attribute information structure
                that needs to be dumped

Return Value:

    None

--*/            
{
    if (FsAttrs) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Attributes = Attrs:%lX,MaxCompNameLen=%d,Name:%ws\n",
              FsAttrs->FileSystemAttributes,
              FsAttrs->MaximumComponentNameLength,
              FsAttrs->FileSystemName));
    }
}

VOID
SpPtDumpFSSizeInfo(
    IN PFILE_FS_SIZE_INFORMATION FsSize
    )
/*++

Routine Description:

   Dumps the give file size information structure    
    
Arguments:

    FsSize  :   The file size information structure that needs to
                be dumped

Return Value:

    None

--*/            
{
    if (FsSize) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Size Info = TotalUnits:%I64u, AvailUnits:%I64u,"
              "Sectors/Unit:%u,Bytes/Sector:%u\n",
              FsSize->TotalAllocationUnits.QuadPart,
              FsSize->AvailableAllocationUnits.QuadPart,
              FsSize->SectorsPerAllocationUnit,
              FsSize->BytesPerSector
              ));    
    }
}
   

VOID
SpPtDumpFSVolumeInfo(
    IN PFILE_FS_VOLUME_INFORMATION FsVolInfo
    )
/*++

Routine Description:

    Dumps the give volume information structure
        
Arguments:

    FsVolInfo   :   The volume information structure that
                    needs to be dumped

Return Value:

    None

--*/            
{
    if (FsVolInfo) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Vol Info = CreationTime:%I64X, Serial#:%d\n",
              "SupportsObject:%d, Name:%ws\n",
              FsVolInfo->VolumeCreationTime.QuadPart,
              FsVolInfo->VolumeSerialNumber,
              FsVolInfo->SupportsObjects,
              FsVolInfo->VolumeLabel
              ));    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spptwrt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptwrt.c

Abstract:

    Creates, Deletes and Commits the partitions 
    to the disk.

Author:

    Vijay Jayaseelan    (vijayj)

Revision History:

    None

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "sppart3.h"
#include <oemtypes.h>

//
// If we are testing commit then we don't commit on
// disk zero (i.e. primary disk) where we have our
// NT and recovery console installation
//
//#define TESTING_COMMIT          1

#if 0
//
// To test GPT partitions using existing loader
//
//#define STAMP_MBR_ON_GPT_DISK   1
#endif

//
// Variable to selectively trun on/off commits to
// the disk
//
BOOLEAN DoActualCommit = TRUE;


ULONG
SpPtnGetContainerPartitionCount(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of container partitions in the region 
    list for the given disk
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the container partitions for the disk

--*/        
{
    ULONG Count = 0;

    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(Region))
                Count++;

            Region = Region->Next;            
        }
    }        

    return Count;
}

ULONG
SpPtnGetLogicalDriveCount(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of logical drives in the regions list
    for the given disk
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the logical drives for the disk

--*/        
{
    ULONG Count = 0;

    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_LOGICAL_DRIVE(Region))
                Count++;

            Region = Region->Next;            
        }
    }        

    return Count;
}        

ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of partitions for the given
    disk.
    
Arguments:

    DiskId  : Disk ID

Return Value:

    Count of number of partitions for the disk   

--*/        
{
    ULONG PartCount = 0;
    
    if (DiskId < HardDiskCount) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region))
                PartCount++;
                
            Region = Region->Next;
        }

        Region = SPPT_GET_EXTENDED_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region))
                PartCount++;
                
            Region = Region->Next;
        }
    }

    return PartCount;
}

ULONG
SpPtnGetDirtyPartitionCountDisk(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of dirty partitions for the given
    disk.

    NB: A partition is dirty if it needs to be commit
    to the disk with some new information
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the number of dirty partitions for the given
    disk

--*/        
{
    ULONG PartCount = 0;
    
    if (DiskId < HardDiskCount) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_DIRTY(Region))
                PartCount++;

            Region = Region->Next;
        }

        Region = SPPT_GET_EXTENDED_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_DIRTY(Region))
                PartCount++;
                
            Region = Region->Next;
        }
    }

    return PartCount;
}

VOID
SpPtnGetPartitionTypeCounts(
    IN ULONG DiskId,
    IN BOOLEAN SkipDeleted,
    IN PULONG PrimaryPartitions,    OPTIONAL
    IN PULONG ContainerPartitions,  OPTIONAL
    IN PULONG LogicalDrives,        OPTIONAL
    IN PULONG KnownPrimaryCount,    OPTIONAL
    IN PULONG KnownLogicalCount     OPTIONAL
    )
/*++

Routine Description:

    Counts various partition types for the given disk.
    
Arguments:

    DiskId          :   Disk ID
    
    SkipDeleted     :   Whether to skip the partitions marked
                        deleted or not

    PrimaryPartitions   :   Place holder for primary partition count

    ContainerPartitions :   Place holder for container partition count

    LogicalDrives       :   Place holder for logical drives count

Return Value:

    None

--*/        
{   
    if (SPPT_IS_MBR_DISK(DiskId) &&
        (ARGUMENT_PRESENT(PrimaryPartitions) || 
         ARGUMENT_PRESENT(ContainerPartitions) ||
         ARGUMENT_PRESENT(LogicalDrives))) {

        ULONG   Primary = 0, Container = 0, Logical = 0;    
        ULONG   ValidPrimary = 0, ValidLogical = 0;
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (!(SkipDeleted && SPPT_IS_REGION_MARKED_DELETE(Region))) {
                if (SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                    Container++;            
                    
                    ASSERT(SPPT_IS_REGION_LOGICAL_DRIVE(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_PRIMARY_PARTITION(Region) == FALSE);
                    
                } else if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                    UCHAR SystemId = SPPT_GET_PARTITION_TYPE(Region);
                    
                    Logical++;

                    if(SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(SystemId)) {
                        ValidLogical++;
                    }                    
                    
                    ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_PRIMARY_PARTITION(Region) == FALSE);
                    
                } else if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                    UCHAR SystemId = SPPT_GET_PARTITION_TYPE(Region);
                    
                    Primary++;                   

                    if(SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(SystemId)) {
                        ValidPrimary++;
                    }                    
                    
                    ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_LOGICAL_DRIVE(Region) == FALSE);
                }
            }                

            Region = Region->Next;
        }

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnGetPartitionTypeCounts(%d):P:%d,C:%d,L:%d,VP:%d,VL:%d\n",
            DiskId,
            Primary,
            Container,
            Logical,
            ValidPrimary,
            ValidLogical));
                                
        ASSERT((Logical <= Container) && (Primary < PTABLE_DIMENSION));

        if (ARGUMENT_PRESENT(PrimaryPartitions))
            *PrimaryPartitions = Primary;

        if (ARGUMENT_PRESENT(ContainerPartitions))
            *ContainerPartitions = Container;

        if (ARGUMENT_PRESENT(LogicalDrives))
            *LogicalDrives = Logical;

        if (ARGUMENT_PRESENT(KnownPrimaryCount))
            *KnownPrimaryCount = ValidPrimary;

        if (ARGUMENT_PRESENT(KnownLogicalCount))
            *KnownLogicalCount = ValidLogical;
    }            
}

VOID
SpPtnFreeDiskRegions(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Free the disk region linked list. Its assumed that
    this list has all the regions allocated in heap
    
Arguments:

    DiskId  :   Disk ID
    
Return Value:

    None
    
--*/        
{
    NTSTATUS Status;
    PPARTITIONED_DISK  Disk = SPPT_GET_PARTITIONED_DISK(DiskId);
    PDISK_REGION Region = Disk->PrimaryDiskRegions;
    PDISK_REGION Temp;

    while (Region) {
        Temp = Region;
        Region = Region->Next;

        SpMemFree(Temp);
    }            

    Disk->PrimaryDiskRegions = NULL;

    //
    // Mark the disk blank since we don't have any regions
    // for the disk currently
    //
    SPPT_SET_DISK_BLANK(DiskId, TRUE);
}

NTSTATUS
SpPtnZapSectors(
    IN HANDLE DiskHandle,
    IN ULONG BytesPerSector,
    IN ULONGLONG StartSector,
    IN ULONG SectorCount
    )
/*++

Routine Description:

    Zaps (zeros) the requested sector(s).
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    StartSector :   Starting sector to Zap

    Sector Count:   Number of sectors to Zap 
                    (includes starting sector also)
    
Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (SectorCount) {
        ULONG       BufferSize = (BytesPerSector * 2);    
        PVOID       UBuffer = SpMemAlloc(BufferSize);    
        ULONGLONG   SectorIdx = StartSector;

        if (UBuffer) {
            PVOID Buffer = UBuffer;
            
            RtlZeroMemory(UBuffer, BufferSize);
            
            Buffer = ALIGN(Buffer, BytesPerSector);

            Status = STATUS_SUCCESS;
            
            while (NT_SUCCESS(Status) && SectorCount) {
                Status = SpReadWriteDiskSectors(DiskHandle,
                                SectorIdx,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE);
                SectorIdx++;
                SectorCount--;
            }                
                                                
            SpMemFree(UBuffer);
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }        

    return Status;
}

NTSTATUS
SpPtnZapRegionBootSector(
    IN HANDLE DiskHandle,
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Zaps (zeros) the starting sector for the given
    region. Generally used to zap the boot sector after 
    creating a new partition

    Currently skips the zapping for Container partitions
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    Region      :   The region, whose boot sector (starting sector)
                    needs to be zapped

Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Region) {
        if (!SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
            Status = SpPtnZapSectors(DiskHandle,
                            SPPT_DISK_SECTOR_SIZE(Region->DiskNumber),
                            Region->StartSector,
                            1);
        } else {
            Status = STATUS_SUCCESS;
        }            
    } 

    return Status;
}


#if 0

NTSTATUS
SpPtnStampMBROnGptDisk(
    IN HANDLE DiskHandle,
    IN ULONG DiskId,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo
    )    
/*++

Routine Description:

    Stamps the first 3 partitions as primary partitions in the
    MBR of the GPT disk (for testing)
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    DiskId      :   The disk which we are operating on.

    LayoutInfo  :   The partition information for the disk

Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    
    if ((DiskId < HardDiskCount) && LayoutInfo && SPPT_IS_GPT_DISK(DiskId)) {
        PPARTITION_INFORMATION_EX   PartInfo;
        ON_DISK_PTE                 PartEntries[4];
        BOOLEAN                     WriteMBR = FALSE;
        PHARD_DISK                  Disk = SPPT_GET_HARDDISK(DiskId);
        ULONG                       BytesPerSector = Disk->Geometry.BytesPerSector;
        ULONG Index;        

        RtlZeroMemory(PartEntries, sizeof(ON_DISK_PTE) * 4);

        //
        // Go through the partitions and pick up the partitions
        // whose number are less than 4 (and not zero)
        //
        for (Index = 0; Index < LayoutInfo->PartitionCount; Index++) {
            ULONG PartIndex = 0;

            PartInfo = LayoutInfo->PartitionEntry + Index;
            PartIndex = PartInfo->PartitionNumber;

            if ((PartIndex > 0) && (PartIndex < 4)) {
                ULONGLONG   SectorStart = (PartInfo->StartingOffset.QuadPart / 
                                            BytesPerSector);
                ULONGLONG   SectorCount = (PartInfo->PartitionLength.QuadPart / 
                                            BytesPerSector);
                ULONGLONG   SectorEnd = SectorStart + SectorCount;                                            
                
                
                WriteMBR = TRUE;    // need to write MBR

                SpPtInitializeCHSFields(Disk,
                        SectorStart,
                        SectorEnd,
                        PartEntries + PartIndex);

                U_ULONG(&(PartEntries[PartIndex].RelativeSectors)) = (ULONG)SectorStart;
                U_ULONG(&(PartEntries[PartIndex].SectorCount)) = (ULONG)SectorCount;
                PartEntries[PartIndex].SystemId = PARTITION_HUGE;
            }
        }
        
        if (WriteMBR) {
            PUCHAR          UBuffer;
            PUCHAR          Buffer;
            PON_DISK_MBR    DummyMbr;

            UBuffer = SpMemAlloc(BytesPerSector * 2);

            if (UBuffer) {
            
                RtlZeroMemory(UBuffer, BytesPerSector * 2);

                //
                // align the buffer on sector boundary
                //
                Buffer = ALIGN(UBuffer, BytesPerSector);                


                //
                // Read sector 0 (for existing boot code)
                //
                Status = SpReadWriteDiskSectors(
                            DiskHandle,
                            (Disk->Int13Hooker == HookerEZDrive) ? 1 : 0,
                            1,
                            BytesPerSector,
                            Buffer,
                            FALSE
                            );

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP:SpPtnStampMBROnGptDisk():Read MBR on an GPT Disk for testing (%lx)\n",
                    Status));                            

                if (NT_SUCCESS(Status)) {
                    ASSERT(512 == BytesPerSector);

                    DummyMbr = (PON_DISK_MBR)Buffer;

                    //
                    // copy the 3 entries in partition table (which we created eariler)
                    //
                    RtlCopyMemory(DummyMbr->PartitionTable + 1, PartEntries + 1,
                                    sizeof(PartEntries) - sizeof(ON_DISK_PTE));
                                                    
                    //
                    // Write the sector(s).
                    //
                    Status = SpReadWriteDiskSectors(
                                DiskHandle,
                                (Disk->Int13Hooker == HookerEZDrive) ? 1 : 0,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE
                                );

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                        "SETUP:SpPtnStampMBROnGtpDisk():Wrote MBR on an GPT Disk for testing (%lx)\n",
                        Status));                            
                }                                

                SpMemFree(UBuffer);
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        } else {
            Status = STATUS_SUCCESS;            
        }
    }

    return Status;
}

#endif // 0, comment out

NTSTATUS
SpPtnAssignPartitionNumbers(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )
/*++

Routine Description:

    Given a drive layout structure with number of partitions,
    walks through each partitions assigning a partition number
    if one is not already assigned.

    Does not assign partition number to container partitions
    
Arguments:

    LayoutEx  - Contains all the partitions some of which needs
                partition numbers

Return Value:

    Appropriate error code.

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (LayoutEx && LayoutEx->PartitionCount) {
        ULONG       Index;
        PBOOLEAN    UsedArray;
        ULONG       PartCount = LayoutEx->PartitionCount;
        ULONG       Size = PartCount;
        ULONG       MaxPartAssigned;
        PPARTITION_INFORMATION_EX PartInfo = LayoutEx->PartitionEntry;

        //
        // Find out the space needed for boolean array
        //
        for (Index = 0, MaxPartAssigned = 0; Index < PartCount; Index++) {
            if (PartInfo[Index].PartitionNumber > MaxPartAssigned)
                MaxPartAssigned = PartInfo[Index].PartitionNumber;
        }

        Size = max(MaxPartAssigned, PartCount);
        Size++;

        UsedArray = (PBOOLEAN)SpMemAlloc(sizeof(BOOLEAN) * Size);

        if (UsedArray) {
            BOOLEAN Assign = FALSE;
            
            RtlZeroMemory(UsedArray, (sizeof(BOOLEAN) * Size));
            UsedArray[0] = TRUE;    // don't assign '0' to any partition

            //
            // Mark the already assigned partition numbers
            //
            for (Index = 0; Index < PartCount; Index++) {
                if (PartInfo[Index].PartitionNumber != 0) 
                    UsedArray[PartInfo[Index].PartitionNumber] = TRUE;
                else 
                    Assign = TRUE;
            }

            if (Assign) {
                ULONG   NextFreeEntry;

                //
                // Find the next available partition number for assignment
                //
                for (Index = 1, NextFreeEntry = 0; Index < Size; Index++) {
                    if (!UsedArray[Index]) {
                        NextFreeEntry = Index;

                        break;
                    }                        
                }

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAssignPartitionNumber : NextFreeEntry = %d\n",
                    NextFreeEntry));                

                //
                // Assign the partition numbers for the needed partitions
                //
                for (Index = 0; (Index < PartCount); Index++) {
                    if (SPPT_PARTITION_NEEDS_NUMBER(PartInfo + Index)) {
                        PartInfo[Index].PartitionNumber = NextFreeEntry; 
                        UsedArray[NextFreeEntry] = TRUE;

                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                            "SETUP: SpPtnAssignPartitionNumber : Assigning = %d to %d\n",
                            NextFreeEntry, Index));                

                        while ((NextFreeEntry < Size) && UsedArray[NextFreeEntry])
                            NextFreeEntry++;
                    }                        
                }
            }

            Status = STATUS_SUCCESS;

            SpMemFree(UsedArray);                
        } else {
            Status = STATUS_NO_MEMORY;
        }            
    }

    return Status;
}


NTSTATUS
SpPtnInitializeDiskStyle(
    IN ULONG DiskId,
    IN PARTITION_STYLE Style,
    IN PCREATE_DISK DiskInfo OPTIONAL
    )
/*++

Routine Description:

    Given the disk, changes the disk style (MBR/GPT) as
    requested.

    For RAW disks, uses the default partition type style
    which can differ from platform to platform.
    
Arguments:

    DiskId      :   Disk ID

    Style       :   Partition Style

    DiskInfo    :   Disk information which needs to be used,
                    while initializing the disk
                    
Return Value:

    Appropriate error code

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

#ifdef COMMIT_TESTING
    if (!DiskId)
        return STATUS_SUCCESS;
#endif
        

    if (SPPT_IS_BLANK_DISK(DiskId) && 
        ((Style == PARTITION_STYLE_GPT) || (Style == PARTITION_STYLE_MBR))) {        
        WCHAR    DiskPath[MAX_PATH];
        HANDLE   DiskHandle;

        //
        // form the name
        //
        swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskId);        

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

        if (NT_SUCCESS(Status)) {
            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS InitStatus;


            if (Style == PARTITION_STYLE_GPT) {
                CREATE_DISK  CreateInfo;

                RtlZeroMemory(&CreateInfo, sizeof(CREATE_DISK));

                if (DiskInfo) {
                    CreateInfo = *DiskInfo;
                    CreateInfo.PartitionStyle = Style;
                } else {
                    CreateInfo.PartitionStyle = Style; 
                    SpCreateNewGuid(&(CreateInfo.Gpt.DiskId));
                    CreateInfo.Gpt.MaxPartitionCount = 0;  // will be 128 actually
                }                    

                Status = ZwDeviceIoControlFile( DiskHandle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_DISK_CREATE_DISK,
                                            &CreateInfo,
                                            sizeof(CREATE_DISK),
                                            NULL,
                                            0);

            } else {
                //
                // Note : This is needed since CREATE_DISK doesn't work for
                // MBR disks :(
                //
                ULONG LayoutSize;
                PDRIVE_LAYOUT_INFORMATION_EX DriveLayout;
                PHARD_DISK  Disk;

                Disk = SPPT_GET_HARDDISK(DiskId);

                LayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                                (3 * sizeof(PARTITION_INFORMATION_EX));
                                
                DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

                if (DriveLayout) {
                    RtlZeroMemory(DriveLayout, LayoutSize);

                    DriveLayout->PartitionStyle = PARTITION_STYLE_MBR;
                    DriveLayout->PartitionCount = 4;

                    if (DiskInfo) {
                        Disk->Signature = DriveLayout->Mbr.Signature = 
                            DiskInfo->Mbr.Signature;
                    } else {                    
                        Disk->Signature = DriveLayout->Mbr.Signature = 
                            SPPT_GET_NEW_DISK_SIGNATURE();
                    }                        

                    DriveLayout->PartitionEntry[0].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[1].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[2].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[3].RewritePartition = TRUE;

                    Status = ZwDeviceIoControlFile( DiskHandle,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &IoStatusBlock,
                                                    IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                                    DriveLayout,
                                                    LayoutSize,
                                                    NULL,
                                                    0);                    

                    if (NT_SUCCESS(Status)) {                    
                        ULONG   Signature = 0;

                        //
                        // Zero out sector 1 & 2 also since it might contain
                        // stale GPT information
                        //
                        if (!SPPT_IS_REMOVABLE_DISK(DiskId)) {
                            SpPtnZapSectors(DiskHandle, 
                                        SPPT_DISK_SECTOR_SIZE(DiskId),
                                        1, 
                                        2);
                        }                            
                                                                
                        Status = SpMasterBootCode(DiskId, DiskHandle, &Signature);
                    }

                    SpMemFree(DriveLayout);                                                
                } else {
                    Status = STATUS_NO_MEMORY;
                }                
            }            

            ZwClose(DiskHandle);
        }
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnInitializeDiskStyle (%d, %d) failed with (%lx)\n",
            DiskId, Style, Status));
    }

    SpAppendDiskTag(SPPT_GET_HARDDISK(DiskId));    
    
    return Status;
}

BOOLEAN
SpPtnRegionToPartitionInfoEx(
    IN  PDISK_REGION Region,
    OUT PPARTITION_INFORMATION_EX PartInfo
    )
/*++

Routine Description:

    Fills in the PartInfo structure from the given region.

    NB. If the region is not dirty uses the cached partition 
    information to fill the structure.
    
Arguments:

    Region      -   Which has the details to be filled 
                    into PartInfo

    PartInfo    -   The structure which needs to filled

Return Value:

    TRUE if successful, otherwise FALSE

--*/        
{
    BOOLEAN Result = FALSE;
    
    if (Region && PartInfo && 
        (SPPT_IS_REGION_CONTAINER_PARTITION(Region) || SPPT_IS_REGION_PARTITIONED(Region))) {
        if (SPPT_IS_REGION_DIRTY(Region)) {            
            PHARD_DISK  Disk = SPPT_GET_HARDDISK(Region->DiskNumber);
            
            PartInfo->StartingOffset.QuadPart = Region->StartSector * 
                    Disk->Geometry.BytesPerSector;

            PartInfo->PartitionLength.QuadPart = Region->SectorCount *
                    Disk->Geometry.BytesPerSector;

            PartInfo->PartitionNumber = Region->PartitionNumber;                
            PartInfo->RewritePartition = TRUE;

            if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {                        
                PPARTITION_INFORMATION_GPT  GptInfo;

                PartInfo->PartitionStyle = PARTITION_STYLE_GPT;
                GptInfo = &(PartInfo->Gpt);

                if (Region->PartInfoDirty) {
                    //
                    // User specified partition attributes
                    //
                    *GptInfo = Region->PartInfo.Gpt;
                } else {                  
                    GptInfo->Attributes = 0;

                    if (SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                        GptInfo->PartitionType = PARTITION_SYSTEM_GUID;
                    } else {
                        GptInfo->PartitionType = PARTITION_BASIC_DATA_GUID;                        
                    }
                    
                    SpCreateNewGuid(&(GptInfo->PartitionId));
                }                    

                SpPtnGetPartitionNameFromGUID(&(GptInfo->PartitionType),
                    GptInfo->Name);                
            } else {
                PPARTITION_INFORMATION_MBR  MbrInfo;

                PartInfo->PartitionStyle = PARTITION_STYLE_MBR;
                MbrInfo = &(PartInfo->Mbr);

                MbrInfo->PartitionType = SPPT_GET_PARTITION_TYPE(Region); 

                if (!MbrInfo->PartitionType)
                    MbrInfo->PartitionType = PARTITION_IFS;        

                MbrInfo->BootIndicator = SPPT_IS_REGION_ACTIVE_PARTITION(Region);

                //
                // System partition must be active partition for MBR disks
                // on Non-ARC machines
                //
                if (SPPT_IS_REGION_SYSTEMPARTITION(Region) && !SpIsArc() ) {
                    ASSERT(MbrInfo->BootIndicator);
                }
                
                MbrInfo->RecognizedPartition = 
                    IsRecognizedPartition(MbrInfo->PartitionType);

                MbrInfo->HiddenSectors = 0;                     
            }                                    
        } else {
            *PartInfo = Region->PartInfo;
        }

        Result = TRUE;
    }

    return Result;
}


BOOLEAN
SpPtnInitDiskInfo(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    OUT PCREATE_DISK CreateInfo
    )
/*++

Routine Description:

    Fills the information needed for creating a disk,
    form the given drive layout structure

    NB. If the LayoutInfo is marked as RAW disk style
    then used the default partition style for the disk.
    This default style can vary from platform to platform
    
Arguments:

    LayoutInfo  -   The drive layout information to use

    CreateInfo  -   The disk information to be filled in

Return Value:

    TRUE if successful otherwise FALSE.1

--*/        
{
    BOOLEAN Result = FALSE;

    if (LayoutInfo && CreateInfo) {
        RtlZeroMemory(CreateInfo, sizeof(CREATE_DISK));

        CreateInfo->PartitionStyle = LayoutInfo->PartitionStyle;

        switch (CreateInfo->PartitionStyle) {
            case PARTITION_STYLE_MBR:
                CreateInfo->Mbr.Signature = LayoutInfo->Mbr.Signature;
                Result = TRUE;

                break;

            case PARTITION_STYLE_GPT:
                CreateInfo->Gpt.DiskId = LayoutInfo->Gpt.DiskId;

                CreateInfo->Gpt.MaxPartitionCount = 
                        LayoutInfo->Gpt.MaxPartitionCount;

                Result = TRUE;                        

                break;


            case PARTITION_STYLE_RAW:
                CreateInfo->PartitionStyle = SPPT_DEFAULT_PARTITION_STYLE;

                if (CreateInfo->PartitionStyle == PARTITION_STYLE_GPT) {
                    SpCreateNewGuid(&(CreateInfo->Gpt.DiskId));      
                } else {
                    CreateInfo->Mbr.Signature = SPPT_GET_NEW_DISK_SIGNATURE();
                }

                Result = TRUE;

                break;

            default:
                break;
        }
    }

    return Result;
}


NTSTATUS
SpPtnCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
/*++

Routine Description:

    Given the disk, commits the in memory disk region structures
    to the disk as partitions.

    The commit happens only if atlease a single disk region for the
    given disk is dirty.
    
Arguments:

    DiskNumber  :   Disk to commit for.

    AnyChanges  :   Place holder, indicating if any thing was committed
                    or not.
    
Return Value:

    Appropriate error code.

--*/        
{
    NTSTATUS    Status;
    ULONG       LayoutSize;
    HANDLE      Handle = NULL;
    ULONG       Index;
    ULONG       PartitionCount;    
    ULONG       DirtyCount;
    WCHAR       DevicePath[MAX_PATH];
    BOOLEAN     ProcessExtended;
    PHARD_DISK  Disk;
    PDISK_REGION    Region;
    IO_STATUS_BLOCK IoStatusBlock;    
    PPARTITION_INFORMATION_EX       PartInfo;
    PDRIVE_LAYOUT_INFORMATION_EX    DriveLayoutEx;

    //
    // For the time being lets not commit the primary disk
    // where we have our OS/RC installed
    //
#ifdef TESTING_COMMIT    
    if (!DiskNumber)
        return STATUS_SUCCESS;
#endif        
    
    if (DiskNumber >= HardDiskCount)
        return STATUS_INVALID_PARAMETER;

    *AnyChanges = FALSE;

    SpPtDumpDiskRegionInformation(DiskNumber, TRUE);
    
    //
    // Check to see if we need to commit
    //    
    DirtyCount = SpPtnGetDirtyPartitionCountDisk(DiskNumber);
    
    if (DoActualCommit && !DirtyCount)
        return STATUS_SUCCESS;

    *AnyChanges = TRUE;

    if (!SpPtnGetContainerPartitionCount(DiskNumber)) {
        //
        // Recreate the DRIVE_LAYOUT_INFORMATION_EX structure
        //
        PartitionCount = SpPtnGetPartitionCountDisk(DiskNumber);    
        LayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX);

        if (PartitionCount == 0) { 
            CREATE_DISK DiskInfo;

            SpPtnInitDiskInfo(&(SPPT_GET_HARDDISK(DiskNumber)->DriveLayout), 
                             &DiskInfo);

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);                                                                      

            Status = SpPtnInitializeDiskStyle(DiskNumber, 
                        DiskInfo.PartitionStyle, &DiskInfo);

            SpPtnFreeDiskRegions(DiskNumber);

            //
            // Update the boot entries to point to null regions
            // (if any)
            //
            SpUpdateRegionForBootEntries();            

            return Status;                                        
        } 
        
        if (PartitionCount > 1) {    
            LayoutSize += ((PartitionCount  - 1) * sizeof(PARTITION_INFORMATION_EX));
        }                        

        if (PartitionCount < 4) {
            LayoutSize += ((4 - PartitionCount) * sizeof(PARTITION_INFORMATION_EX));
        }
        
        DriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

        if (!DriveLayoutEx)
            return STATUS_NO_MEMORY;

        RtlZeroMemory(DriveLayoutEx, LayoutSize);

        RtlCopyMemory(DriveLayoutEx, &(HardDisks[DiskNumber].DriveLayout),
                    FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry));
         
        DriveLayoutEx->PartitionCount = PartitionCount;                
                
        PartInfo = DriveLayoutEx->PartitionEntry;
        Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ProcessExtended = TRUE;

        //
        // Initialize stray partitions
        //
        if (SPPT_IS_MBR_DISK(DiskNumber) && (PartitionCount < 4)) {        
            ULONG Index = PartitionCount;
            
            DriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            DriveLayoutEx->PartitionCount = 4;        

            while (Index < 4) {
                DriveLayoutEx->PartitionEntry[Index].PartitionStyle = PARTITION_STYLE_MBR;
                DriveLayoutEx->PartitionEntry[Index].RewritePartition = TRUE;                    
                Index++;
            }
        }
        
        //
        // Make PARTITION_INFORMATION_EXs from DISK_REGIONs for all non deleted
        // partitions
        //
        for (Index=0; (Region && (Index < PartitionCount));) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                (!SPPT_IS_REGION_MARKED_DELETE(Region))) {
                
                Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                
                ASSERT(NT_SUCCESS(Status));
                Index++;
            } 
            
            Region = Region->Next;
        }
    } else {
        //
        // The disk has container partitions and possibly logical
        // drives
        //
        ULONG   PrimaryCount = 0, ContainerCount = 0, LogicalCount = 0;
        ULONG   TotalPartitions;

        //SpPtDumpDiskRegionInformation(DiskNumber, TRUE);

        SpPtnGetPartitionTypeCounts(DiskNumber, 
                    TRUE, 
                    &PrimaryCount, 
                    &ContainerCount, 
                    &LogicalCount, 
                    NULL, 
                    NULL);
                    
        TotalPartitions = PrimaryCount + ContainerCount + LogicalCount;

        if (TotalPartitions == 0) {            
            CREATE_DISK DiskInfo;
            
            SpPtnInitDiskInfo(&(SPPT_GET_HARDDISK(DiskNumber)->DriveLayout), 
                             &DiskInfo);

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);                             
        
            Status = SpPtnInitializeDiskStyle(DiskNumber, 
                        DiskInfo.PartitionStyle, &DiskInfo);

            SpPtnFreeDiskRegions(DiskNumber);                        

            //
            // Update the boot entries to point to null regions
            // (if any)
            //
            SpUpdateRegionForBootEntries();            
            
            return Status;                        
        } else {
            BOOLEAN FirstContainer = FALSE;

            //
            // allocate adequate space for the drive layout information
            //
            PartitionCount = (4 * (ContainerCount + 1));            

            LayoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                            (PartitionCount * sizeof(PARTITION_INFORMATION_EX));

            DriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

            if (!DriveLayoutEx)
                return STATUS_NO_MEMORY;

            //
            // initialize the drive layout information
            //
            RtlZeroMemory(DriveLayoutEx, LayoutSize);

            RtlCopyMemory(DriveLayoutEx, &(HardDisks[DiskNumber].DriveLayout),
                    FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry));

            DriveLayoutEx->PartitionCount = PartitionCount;                    

            PartInfo = DriveLayoutEx->PartitionEntry;
            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);           

            //SpPtDumpDiskRegionInformation(DiskNumber, TRUE);

            //
            // first pickup the primary partitions and the first
            // container partition and put them in the drive layout 
            // information 
            //
            for (Index=0; (Region && (Index < 4)); ) {
                if (!SPPT_IS_REGION_MARKED_DELETE(Region)){
                    if (!FirstContainer && 
                         SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {                         
                        FirstContainer = TRUE;
                        Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                        ASSERT(NT_SUCCESS(Status));                        
                        Index++;
                    } else if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                        Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                        ASSERT(NT_SUCCESS(Status));                        
                        Index++;
                    }
                }

                Region = Region->Next;
            }

            //SpPtDumpDriveLayoutInformation(NULL, DriveLayoutEx);

            //
            // further container and logical drives need to start at
            // multiple of 4 index, in drive layout
            //
            if (Index)
                Index = 4;

            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);                

            //
            // pickup the remaining valid container and logical drives
            // and put them in the drive layout information except
            // for the first container partition, which we have
            // already processed
            //
            while (Region && (Index < PartitionCount)) {
                if ((!SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(Region)) &&
                    (!SPPT_IS_REGION_MARKED_DELETE(Region)) &&
                    (!SPPT_IS_REGION_PRIMARY_PARTITION(Region)) &&
                    (SPPT_IS_REGION_PARTITIONED(Region) || 
                     SPPT_IS_REGION_CONTAINER_PARTITION(Region))) {
                    
                    Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                    ASSERT(NT_SUCCESS(Status));                   

                    if (SPPT_IS_REGION_CONTAINER_PARTITION(Region) && 
                        (Region->Next) &&
                        SPPT_IS_REGION_LOGICAL_DRIVE(Region->Next)) {

                        //
                        // think about this ;)                                
                        //
                        if (Index % 4)
                            Index += 3; 
                        else
                            Index += 4;
                    } else {
                        Index++;
                    }
                }

                Region = Region->Next;
            }
        }
    }

    //
    // Assign proper partition numbers
    //
    // TBD : Needed ?
    // Status = SpPtnAssignPartitionNumbers(DriveLayoutEx);
    //
    Status = STATUS_SUCCESS;

    if (NT_SUCCESS(Status)) {    
        //
        // Need to rewrite all the partitions
        //
        for (Index = 0; Index < DriveLayoutEx->PartitionCount; Index++)
            PartInfo[Index].RewritePartition = TRUE;      

        //
        // Commit the Partition changes
        //

        //
        // Create a device path (NT style!) that will describe this disk.  This
        // will be of the form: \Device\Harddisk0
        //
        swprintf(DevicePath, L"\\Device\\Harddisk%u", DiskNumber);


        //SpPtDumpDriveLayoutInformation(DevicePath, DriveLayoutEx);

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DevicePath, &Handle, TRUE);

        if(NT_SUCCESS(Status)){
            if (DoActualCommit) {
                // write the drive layout information
                Status = ZwDeviceIoControlFile( Handle,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoStatusBlock,
                                                IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                                DriveLayoutEx,
                                                LayoutSize,
                                                NULL,
                                                0);

                if(NT_SUCCESS(Status)) {
                    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                          "SETUP: SpPtnCommitChanges : Commited partitions "
                          "successfully on %ws (%lx)\n",                          
                          DevicePath));

                    if (NT_SUCCESS(Status)) {                       
                        ULONG   Signature = 0;
                        ULONG   Count = 0;

                        if (SPPT_IS_MBR_DISK(DiskNumber)) {
                            Status = SpMasterBootCode(DiskNumber,
                                            Handle,
                                            &Signature);

                            if (!NT_SUCCESS(Status)) {                                        
                                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                                      "SETUP: SpPtnCommitChanges : Unable to write "
                                      "master boot code (%lx)\n",                          
                                      Status));
                            }                                                                          
                        }                                                            
                        
                        while (Region && NT_SUCCESS(Status)) {
                            if (Region->Filesystem == FilesystemNewlyCreated) {                        
                               Status = SpPtnZapRegionBootSector(Handle, Region);
                               Count++;
                            }

                            Region = Region->Next;
                        }

                        if (!NT_SUCCESS(Status)) {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                  "SETUP: SpPtnCommitChanges : Error in Zapping\n"));

                            //SpPtDumpDiskRegion(Region);                            
                        } else {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                                  "SETUP: SpPtnCommitChanges : Zapped %d sectors :)\n",
                                  Count));

#ifdef STAMP_MBR_ON_GPT_DISK                                  
                            Status = ZwDeviceIoControlFile( Handle,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            &IoStatusBlock,
                                                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                                            NULL,
                                                            0,
                                                            DriveLayoutEx,
                                                            LayoutSize);  

                            if (NT_SUCCESS(Status)) {
                                Status = SpPtnStampMBROnGptDisk(Handle,
                                            DiskNumber,
                                            DriveLayoutEx);
                            }
#endif                            
                        }
                    }                        
                } else {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                          "SETUP: SpPtnCommitChanges : unable to do "
                          "IOCTL_DISK_SET_DRIVE_LAYOUT_EX on device %ws (%lx)\n",
                          DevicePath,
                          Status));
                }
            } else {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnCommitChanges : Skipping acutal commit to disk "
                    "for %ws\n",
                    DevicePath));
            }

            ZwClose(Handle);                            
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtnCommitChanges : unable to open "
                "partition0 on device %ws (%lx)\n",
                DevicePath,
                Status ));
        }
    } else {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCommitChanges : unable to assign "
            "partition numbers for %ws (%lx)\n",
            DevicePath,
            Status ));
    }
    
    SpMemFree(DriveLayoutEx);

    return Status;
}

NTSTATUS
SpPtnRemoveLogicalDrive(
    IN PDISK_REGION LogicalDrive
    )
/*++

Routine Description:

    Manipulates the in memory region data structure
    so as to mark the logical drive as deleted.

    NB. When a logical drive gets deleted, the container
    partition needs to be deleted based on some
    conditions.
    
Arguments:

    LogicalDrive :  The region representing the logical
                    drive which needs to be deleted.

Return Value:

    Approprate error code

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (SPPT_IS_REGION_LOGICAL_DRIVE(LogicalDrive) && 
            (LogicalDrive->Container)){
        PDISK_REGION ContainerRegion = LogicalDrive->Container;
        BOOLEAN LastLogicalDrive = 
                    (SpPtnGetLogicalDriveCount(LogicalDrive->DiskNumber) == 1);

        SPPT_SET_REGION_DELETED(LogicalDrive, TRUE);
        SPPT_SET_REGION_DIRTY(LogicalDrive, TRUE);
        SPPT_SET_REGION_PARTITIONED(LogicalDrive, FALSE);

        if (LastLogicalDrive) {
            Kd