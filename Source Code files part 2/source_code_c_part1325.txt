, allocated by
//                  the KDC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine is exported from the DLL and called from the
//              client dll.
//
//
//--------------------------------------------------------------------------

extern "C"
KERBERR
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError; // needed for macro
    PKERB_KDC_REQUEST RequestMessage = NULL;
    KERB_KDC_REPLY ReplyMessage = {0};
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_MESSAGE_BUFFER Response = NULL;
    KERB_MESSAGE_BUFFER ErrorData = {0};
    ULONG InputPdu = KERB_TGS_REQUEST_PDU;
    ULONG OutputPdu = KERB_TGS_REPLY_PDU;
    ULONG InnerPdu = KERB_ENCRYPTED_TGS_REPLY_PDU;
    UNICODE_STRING RequestRealm = {0};
    PKERB_INTERNAL_NAME RequestServer = NULL;
    UNICODE_STRING ClientRealm = {0};
    PUNICODE_STRING ExtendedErrorServerRealm = SecData.KdcDnsRealmName();
    PKERB_INTERNAL_NAME ExtendedErrorServerName = SecData.KdcInternalName();

#if DBG
    DWORD StartTime = 0;
#endif

    TRACE(KDC, KdcGetTicket, DEB_FUNCTION );

    //
    // Make sure we are allowed to execute
    //

    if (!NT_SUCCESS(EnterApiCall()))
    {
        return(KDC_ERR_NOT_RUNNING);
    }

    RtlZeroMemory(
        &ReplyMessage,
        sizeof(KERB_KDC_REPLY)
        );

    //
    // First initialize the return parameters.
    //

    OutputMessage->Buffer = NULL;
    OutputMessage->BufferSize = 0;

    //
    // Check the first byte of the message to indicate the type of message
    //

    if ((InputMessage->BufferSize > 0) && (
        (InputMessage->Buffer[0] & KERB_BER_APPLICATION_TAG) != 0))
    {
        if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) == KERB_AS_REQ_TAG)
        {
            InputPdu = KERB_AS_REQUEST_PDU;
            OutputPdu = KERB_AS_REPLY_PDU;
            InnerPdu = KERB_ENCRYPTED_AS_REPLY_PDU;
        }
        else if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) != KERB_TGS_REQ_TAG)
        {
            D_DebugLog((DEB_T_SOCK,
                      "KLIN(%x) Bad message sent to KDC - not AS or TGS request\n",
                      KLIN(FILENO,__LINE__)));
            
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto NoMsgCleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_T_SOCK,"KLIN(%x) Bad message sent to KDC - length to short or bad first byte\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KRB_ERR_FIELD_TOOLONG;
        goto NoMsgCleanup;

    }

    //
    // First decode the input message
    //

    KerbErr = (KERBERR) KerbUnpackData(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            InputPdu,
                            (PVOID *) &RequestMessage
                            );

    if (KerbErr == KDC_ERR_MORE_DATA)
    {
        //
        // Reallocate an retry the read from the socket
        //

        if (Context != NULL)
        {
            KerbErr = KdcAtqRetrySocketRead(
                        (PKDC_ATQ_CONTEXT *) Context,
                        InputMessage
                        );

            //
            // On success, just return so that the read continues. On failure,
            // post cleanup and send an error response.
            //

            if (KERB_SUCCESS(KerbErr))
            {
                LeaveApiCall();
                return(KerbErr);
            }
            else
            {
                goto NoMsgCleanup;
            }
        }
        else
        {
            D_DebugLog((DEB_ERROR, "KLIN(%x) Datagram context with not enough data!\n", 
                      KLIN(FILENO,__LINE__)));
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto Cleanup;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack KDC request: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));

        //
        // We don't want to return an error on a badly formed
        // packet,as it can be used to set up a flood attack
        //

        goto NoMsgCleanup;
    }

    //
    // First check the version of the request.
    //

    if (RequestMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Bad request version: 0x%x\n",
                  KLIN(FILENO,__LINE__), RequestMessage->version));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }

    //
    // now call the internal version to do all the hard work
    //

    //
    // Verify the realm name in the request
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                &RequestRealm,
                &RequestMessage->request_body.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &RequestServer,
                &RequestMessage->request_body.server_name
                );

    if ( !KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now that we have the request realm and request server, any subsequent
    // error will result in those values being placed into the extended error
    //

    ExtendedErrorServerRealm = &RequestRealm;
    ExtendedErrorServerName = RequestServer;

    if (!SecData.IsOurRealm(
            &RequestRealm
            ))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Request sent for wrong realm: %wZ\n",
                  KLIN(FILENO,__LINE__), &RequestRealm));

        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }

    if (RequestMessage->message_type == KRB_AS_REQ)
    {
        if (InputPdu != KERB_AS_REQUEST_PDU) {
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
            goto Cleanup;
        }

        SamIIncrementPerformanceCounter(
            KdcAsReqCounter
            );

        //
        // If WMI event tracing is enabled, notify it of the begin and end
        // of the ticket request
        //

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = I_GetASTicket(
                    ClientAddress,
                    RequestMessage,
                    &RequestRealm,
                    InnerPdu,
                    OutputPdu,
                    InputMessage,
                    OutputMessage,
                    &ErrorData,
                    &ExtendedError,
                    &ClientRealm
                    );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "I_GetASTicket took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif

    }
    else if (RequestMessage->message_type == KRB_TGS_REQ)
    {

        SamIIncrementPerformanceCounter(
            KdcTgsReqCounter
            );

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = HandleTGSRequest(
                    ClientAddress,
                    RequestMessage,
                    &RequestRealm,
                    OutputMessage,
                    &ExtendedError
                    );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "HandleTGSRequest took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Invalid message type: %d\n",
                  KLIN(FILENO,__LINE__),
                  RequestMessage->message_type));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto Cleanup;
    }


    //
    // If the response is too big and we are using UDP, make the client
    // change transports. We can tell the caller is UDP because it doesn't
    // have an ATQ context but it does provide the client address.
    //

    if ((Context == NULL) && (ClientAddress != NULL))
    {
        if (OutputMessage->BufferSize >= KERB_MAX_KDC_RESPONSE_SIZE)
        {
            D_DebugLog((DEB_WARN,"KLIN(%x) KDC response too big for UDP: %d bytes\n",
                      KLIN(FILENO,__LINE__), OutputMessage->BufferSize ));

            KerbErr = KRB_ERR_RESPONSE_TOO_BIG;
            MIDL_user_free(OutputMessage->Buffer);
            OutputMessage->Buffer = NULL;
            OutputMessage->BufferSize = 0;
        }
    }

Cleanup:

    // TBD:  Put in extended error return goo here for client

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // We may have a message built by someone else - the PDC
        //     
        if (OutputMessage->Buffer == NULL)
        {
            KerbBuildErrorMessageEx(
                KerbErr,
                &ExtendedError,
                ExtendedErrorServerRealm,
                ExtendedErrorServerName,
                &ClientRealm,
                ErrorData.Buffer,
                ErrorData.BufferSize,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );
        } 
     }

NoMsgCleanup:

    KerbFreeString(&RequestRealm);
    MIDL_user_free(RequestServer);

    if (RequestMessage != NULL)
    {
        KerbFreeData(InputPdu,RequestMessage);
    }

    if (ErrorData.Buffer != NULL)
    {
        MIDL_user_free(ErrorData.Buffer);
    }
    LeaveApiCall();

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\events.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       events.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-03-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include <netlib.h>
extern "C" {
#include <lmserver.h>
#include <srvann.h>
}

HANDLE  hEventLog = (HANDLE)NULL;
DWORD   LoggingLevel = (1 << EVENTLOG_ERROR_TYPE) | (1 << EVENTLOG_WARNING_TYPE);
WCHAR   EventSourceName[] = TEXT("KDC");

#define MAX_EVENT_STRINGS 8
#define MAX_ETYPE_LONG   999
#define MIN_ETYPE_LONG  -999
#define MAX_ETYPE_STRING 16  // 4wchar + , + 2 space
#define WSZ_NO_KEYS L"< >"


//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeEvents(void)
{
    TRACE(KDC, InitializeEvents, DEB_FUNCTION);
//
// Interval with which we'll log the same event twice
//

#define KDC_EVENT_LIFETIME (60*60*1000)

    hEventLog = NetpEventlogOpen(EventSourceName, KDC_EVENT_LIFETIME);
    if (hEventLog)
    {
        return(TRUE);
    }

    DebugLog((DEB_ERROR, "Could not open event log, error %d\n", GetLastError()));
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportServiceEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReportServiceEvent(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    TRACE(KDC, ReportServiceEvent, DEB_FUNCTION);

    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "Cannot log event, no handle!\n"));
        return((DWORD)-1);
    }
#ifdef notdef
    //
    // We're not supposed to be logging this, so nuke it
    //
    if ((LoggingLevel & (1 << EventType)) == 0)
    {
        return(0);
    }
#endif

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    
    }

    for (i=0; i<NumberOfStrings; i++) {
        Strings[ i ] = va_arg( arglist, PWSTR );
    }


    //
    // Report the event to the eventlog service
    //

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EventType,
                (PBYTE) RawData,
                SizeOfRawData,
                (LPWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)

    {
        DebugLog((DEB_ERROR,  "NetpEventlogWrite( 0x%x ) failed - %u\n", EventId, rv ));

    }

    return rv;
}

BOOL
ShutdownEvents(void)
{
    TRACE(KDC, ShutdownEvents, DEB_FUNCTION);

    NetpEventlogClose(hEventLog);

    return TRUE;  

}


NTSTATUS
KdcBuildEtypeStringFromStoredCredential(
    IN PKERB_STORED_CREDENTIAL Cred,
    IN OUT PWSTR * EtypeString
    )
{

    ULONG BuffSize;
    PWSTR Ret = NULL;   
    WCHAR Buff[12];

    *EtypeString = NULL;


        if (Cred == NULL
         || ((Cred->CredentialCount + Cred->OldCredentialCount) == 0)   )
        {
                BuffSize = sizeof(WCHAR) * (wcslen(WSZ_NO_KEYS)+1); 
                *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);
                if (NULL == *EtypeString)
                        {
                        return STATUS_INSUFFICIENT_RESOURCES;
                }

                wcscpy(*EtypeString, WSZ_NO_KEYS);

                return STATUS_SUCCESS;
        }




    // Guess maximum buffer... Etypes are 4 chars at most
    BuffSize = ((Cred->CredentialCount + Cred->OldCredentialCount )* MAX_ETYPE_STRING);
    Ret = (LPWSTR)MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (LONG Index = 0;Index < (Cred->CredentialCount + Cred->OldCredentialCount ); Index++ )
    {
        if (Cred->Credentials[Index].Key.keytype > MAX_ETYPE_LONG ||
            Cred->Credentials[Index].Key.keytype < MIN_ETYPE_LONG)
        {
            DebugLog((DEB_ERROR, "Keytype too large for string conversion\n"));
            DsysAssert(FALSE);
        }
        else
        {                     
            _itow(Cred->Credentials[Index].Key.keytype, Buff, 10);
            wcscat(Ret, Buff);
            wcscat(Ret, L"  ");
        }                        
    }
    *EtypeString = Ret;
    return STATUS_SUCCESS;
}

NTSTATUS
KdcBuildEtypeStringFromCryptList(
    IN PKERB_CRYPT_LIST CryptList,
    IN OUT LPWSTR * EtypeString
    )
{      

    ULONG BuffSize = 0, CryptCount = 0;
    PWSTR Ret = NULL;   
    WCHAR Buff[30];
    
    PKERB_CRYPT_LIST ListPointer = CryptList;

    *EtypeString = NULL;
    

        if (CryptList == NULL)
        {
                BuffSize = sizeof(WCHAR) * (wcslen(WSZ_NO_KEYS)+1); 
                *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);
                if (NULL == *EtypeString)
                {
                        return STATUS_INSUFFICIENT_RESOURCES;
                }

                wcscpy(*EtypeString, WSZ_NO_KEYS);

                return STATUS_SUCCESS;
        }





    while (TRUE)
    {                                
        if (ListPointer->value > MAX_ETYPE_LONG || ListPointer->value < MIN_ETYPE_LONG)
        {
           DebugLog((DEB_ERROR, "Maximum etype exceeded\n"));
           return STATUS_INVALID_PARAMETER;
        }

        BuffSize += MAX_ETYPE_STRING;
        if (NULL == ListPointer->next)
        {
            break;
        }
        ListPointer = ListPointer->next;

    }     
    
    Ret = (LPWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    while (TRUE)
    { 
        _itow(CryptList->value, Buff, 10);
        wcscat(Ret,Buff);
        wcscat(Ret, L"  ");
        if (NULL == CryptList->next)
        {
            break;
        }

        CryptList = CryptList->next;

    }   
    
    *EtypeString = Ret;

    return STATUS_SUCCESS;
}

void
KdcReportKeyError(
    IN PUNICODE_STRING AccountName,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN ULONG EventId,
    IN OPTIONAL PKERB_CRYPT_LIST RequestEtypes,
    IN OPTIONAL PKERB_STORED_CREDENTIAL StoredCredential
    )
{


    ULONG NumberOfStrings;
    NTSTATUS Status;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    PWSTR RequestEtypeString = NULL;
    PWSTR AccountNameEtypeString = NULL;
    DWORD rv;

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "Cannot log event, no handle!\n"));
        return;
    }

    Status = KdcBuildEtypeStringFromCryptList(
                    RequestEtypes,
                    &RequestEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromCryptList failed\n"));
        goto cleanup;
    }

    Status = KdcBuildEtypeStringFromStoredCredential(
                    StoredCredential,
                    &AccountNameEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromStoredCredential failed\n"));
        goto cleanup;
    } 


    if (EventId == KDCEVENT_NO_KEY_UNION_AS )
    {
        Strings[0] = AccountName->Buffer;
        Strings[1] = RequestEtypeString;
        Strings[2] = AccountNameEtypeString;
        NumberOfStrings = 3;
    } 
    else if (EventId == KDCEVENT_NO_KEY_UNION_TGS )
    {
        if (!ARGUMENT_PRESENT(ServerName))
        {
            DebugLog((DEB_ERROR, "Invalid arg to KdcReportKeyError!\n"));
            DsysAssert(FALSE);
            goto cleanup;
        }
        Strings[0] = ServerName->Buffer;
        Strings[1] = AccountName->Buffer;
        Strings[2] = RequestEtypeString;
        Strings[3] = AccountNameEtypeString;
        NumberOfStrings = 4;

    }  
    else 
    {
        goto cleanup;
    }

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EVENTLOG_ERROR_TYPE,
                NULL,
                0, // no raw data
                (LPWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)

    {
        DebugLog((DEB_ERROR,  "NetpEventlogWrite( 0x%x ) failed - %u\n", EventId, rv ));
    } 


    cleanup:


    if (NULL != RequestEtypeString )
    {
        MIDL_user_free(RequestEtypeString);
    }

    if (NULL != AccountNameEtypeString )
    {
        MIDL_user_free(AccountNameEtypeString);
    }

    return;

}
    
    
    


\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\kdc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KDC.CXX
//
// Contents:    Base part of the KDC.  Global vars, main functions, init
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

extern "C" {
#include <lmserver.h>
#include <srvann.h>
#include <nlrepl.h>
#include <dsgetdc.h>
}
#include "rpcif.h"
#include "sockutil.h"
#include "kdctrace.h"
#include "fileno.h"
#define  FILENO FILENO_KDC



VOID
KdcPolicyChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

//
// Global data
//

KDC_STATE KdcState = Stopped;                   // used to signal when
                                                // authenticated RPC is
                                                // ready to use - e.g.
                                                // spmgr has found the
                                                // kdc
SERVICE_STATUS_HANDLE hService;
SERVICE_STATUS SStatus;
UNICODE_STRING GlobalDomainName;
UNICODE_STRING GlobalKerberosName;
UNICODE_STRING GlobalKdcName;
PKERB_INTERNAL_NAME GlobalKpasswdName = NULL;
PSID GlobalDomainSid;
LSAPR_HANDLE GlobalPolicyHandle;
SAMPR_HANDLE GlobalAccountDomainHandle;
BYTE GlobalLocalhostAddress[4];
HANDLE KdcGlobalDsPausedWaitHandle;
HANDLE KdcGlobalDsEventHandle;
BOOL KdcGlobalAvoidPdcOnWan = FALSE;
#if DBG
LARGE_INTEGER tsIn,tsOut;
#endif

HANDLE hKdcHandles[MAX_KDC_HANDLE];

//
// Prototypes
//

CRITICAL_SECTION ApiCriticalSection;
ULONG CurrentApiCallers;



//+---------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Updates the KDC's service status with the service controller
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
UpdateStatus(DWORD   dwState)
{
    TRACE(KDC, UpdateStatus, DEB_FUNCTION);

    SStatus.dwCurrentState = dwState;
    if ((dwState == SERVICE_START_PENDING) || (dwState == SERVICE_STOP_PENDING))
    {
        SStatus.dwCheckPoint++;
        SStatus.dwWaitHint = 10000;
    }
    else
    {
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
    }

    if (!SetServiceStatus(hService, &SStatus)) {
        DebugLog((DEB_ERROR,"(%x)Failed to set service status: %d\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Handler
//
//  Synopsis:   Process and respond to a control signal from the service
//              controller.
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

void
Handler(DWORD   dwControl)
{
    TRACE(KDC, Handler, DEB_FUNCTION);

    switch (dwControl)
    {

    case SERVICE_CONTROL_STOP:
        ShutDown( L"Service" );
        break;

    default:
        D_DebugLog((DEB_WARN, "Ignoring SC message %d\n",dwControl));
        break;

    }

}



BOOLEAN
KdcWaitForSamService(
    VOID
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:


Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            DebugLog((DEB_ERROR,
                "KdcWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            return( FALSE );
        }
    }

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {
            DebugLog((DEB_WARN,
               "KdcWaitForSamService 5-second timeout (Rewaiting)\n" ));
            if (!UpdateStatus( SERVICE_START_PENDING )) {
                (VOID) NtClose( EventHandle );
                return FALSE;
            }
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            DebugLog((DEB_ERROR,
                     "KdcWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;

}

VOID
KdcDsNotPaused(
    IN PVOID Context,
    IN BOOLEAN TimedOut
    )
/*++

Routine Description:

    Worker routine that gets called when the DS is no longer paused.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
   // Tell the kerberos client that we that a DC.

    NtStatus = KerbKdcCallBack();
    if ( !NT_SUCCESS(NtStatus) )
    {
        D_DebugLog((DEB_ERROR,"Can't tell Kerberos that we're a DC 0x%x\n", NtStatus ));
        goto Cleanup;
    }

    NtStatus = I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    if ( !NT_SUCCESS(NtStatus) )
    {
        D_DebugLog((DEB_ERROR,"Can't tell netlogon we're started 0x%x\n", NtStatus ));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Ds is no longer paused\n"));

Cleanup:
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( TimedOut );
}


BOOLEAN
KdcRegisterToWaitForDS(
    VOID
    )
/*++

Routine Description:

    This procedure registers to wait for the DS to start and to complete
    all its initialization. The main reason we do this is because we don't
    want to start doing kerberos authentications because we don't know that
    the DS has the latest db. It needs to check with all the existing Dc's
    out there to see if there's any db merges to be done. When the
    DS_SYNCED_EVENT_NAME is set, we're ready.

Arguments:


Return Value:

    TRUE : if the register to wait succeeded

    FALSE : if the register to wait  didn't succeed.

--*/
{
    BOOLEAN fRet = FALSE;

    //
    // open the DS event
    //

    KdcGlobalDsEventHandle = OpenEvent( SYNCHRONIZE,
                             FALSE,
                             DS_SYNCED_EVENT_NAME_W);

    if ( KdcGlobalDsEventHandle == NULL)
    {
        //
        // could not open the event handle
        //

        D_DebugLog((DEB_ERROR,"KdcRegisterToWaitForDS couldn't open the event handle\n"));
        goto Cleanup;
    }

    if ( !RegisterWaitForSingleObject(
                    &KdcGlobalDsPausedWaitHandle,
                    KdcGlobalDsEventHandle,
                    KdcDsNotPaused, // Callback routine
                    NULL,           // No context
                    -1,             // Wait forever
                    WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE ) )
    {
        D_DebugLog((DEB_ERROR, "KdcRegisterToWaitForDS: Cannot register for DS Synced callback 0x%x\n", GetLastError()));
        goto Cleanup;
    }

    fRet = TRUE;

Cleanup:
    return fRet;

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcOpenEvent
//
//  Synopsis:   Just like the Win32 function, except that it allows
//              for names at the root of the namespace.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The code was copied from private\windows\base\client\synch.c
//              and the base directory was changed to NULL
//
//--------------------------------------------------------------------------

HANDLE
APIENTRY
KdcOpenEvent(
    DWORD DesiredAccess,
    BOOL bInheritHandle,
    LPWSTR lpName
    )
{
    TRACE(KDC, KdcOpenEvent, DEB_FUNCTION);

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      ObjectName;
    NTSTATUS            Status;
    HANDLE Object;

    if ( !lpName ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
                                   NULL,
        NULL
        );

    Status = NtCreateEvent(
                   &Object,
                   DesiredAccess,
                   &Obja,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &Object,
                                  DesiredAccess,
                                  &Obja );

        }
    }

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError( Status ));
        return NULL;
    }
    return Object;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcStartEvent
//
//  Synopsis:   sets the KdcStartEvent
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The SPMgr must have created this event before this
//              is called
//
//
//--------------------------------------------------------------------------


void
SetKdcStartEvent()
{
    TRACE(KDC, SetKdcStartEvent, DEB_FUNCTION);

    HANDLE hEvent;
    hEvent = KdcOpenEvent(EVENT_MODIFY_STATE,FALSE,KDC_START_EVENT);
    if (hEvent != NULL)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
        D_DebugLog((DEB_TRACE,"Set event %ws\n",KDC_START_EVENT));
    }
    else
    {
        DWORD dw = GetLastError();
        if (dw != ERROR_FILE_NOT_FOUND)
            DebugLog((DEB_ERROR,"Error opening %ws: %d\n",KDC_START_EVENT,dw));
        else
            D_DebugLog((DEB_TRACE,"Error opening %ws: %d\n",KDC_START_EVENT,dw));
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcLoadParameters
//
//  Synopsis:   Loads random parameters from registry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcLoadParameters(
    VOID
    )
{
    NET_API_STATUS NetStatus;
    LPNET_CONFIG_HANDLE ConfigHandle = NULL;
    LPNET_CONFIG_HANDLE NetlogonInfo = NULL;

    NetStatus = NetpOpenConfigData(
                    &ConfigHandle,
                    NULL,               // noserer name
                    SERVICE_KDC,
                    TRUE                // read only
                    );
    if (NetStatus != NO_ERROR)
    {
        // we could return, but then we'd lose data
        D_DebugLog((DEB_WARN, "Couldn't open KDC config data - %x\n", NetStatus));
        // return;
    }
    
    //
    //  Open Netlogon service key for AvoidPdcOnWan
    //
    NetStatus = NetpOpenConfigData(
                    &NetlogonInfo,
                    NULL,
                    SERVICE_NETLOGON,
                    TRUE
                    );

    if (NetStatus != NO_ERROR)
    {
        D_DebugLog((DEB_WARN, "Failed to open netlogon key - %x\n", NetStatus));
        return;
    }

    NetStatus = NetpGetConfigBool(
                    NetlogonInfo,
                    L"AvoidPdcOnWan",
                    FALSE,
                    &KdcGlobalAvoidPdcOnWan
                    );

    if (NetStatus != NO_ERROR)
    {
        D_DebugLog((DEB_WARN, "Failed to open netlogon key - %x\n", NetStatus));
        return;
    }
                                        
    NetpCloseConfigData( ConfigHandle );
    NetpCloseConfigData( NetlogonInfo );
}



//+-------------------------------------------------------------------------
//
//  Function:   OpenAccountDomain
//
//  Synopsis:   Opens the account domain and stores a handle to it.
//
//  Effects:    Sets GlobalAccountDomainHandle and GlobalPolicyHandle on
//              success.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
OpenAccountDomain()
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    SAMPR_HANDLE ServerHandle = NULL;

    Status = LsaIOpenPolicyTrusted( & GlobalPolicyHandle );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to open policy trusted: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = LsarQueryInformationPolicy(
                GlobalPolicyHandle,
                PolicyAccountDomainInformation,
                &PolicyInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Get the name and SID out of the account domain information
    //

    Status = KerbDuplicateString(
                &GlobalDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyAccountDomainInfo.DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    GlobalDomainSid = (PSID) LocalAlloc(0, RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid));
    if (GlobalDomainSid == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlCopyMemory(
        GlobalDomainSid,
        PolicyInformation->PolicyAccountDomainInfo.DomainSid,
        RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid)
        );

    //
    // Connect to SAM and open the account domain
    //

    Status = SamIConnect(
                NULL,           // no server name
                &ServerHandle,
                0,              // ignore desired access,
                TRUE            // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to connect to SAM: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Finally open the account domain.
    //

    Status = SamrOpenDomain(
                ServerHandle,
                DOMAIN_ALL_ACCESS,
                (PRPC_SID) PolicyInformation->PolicyAccountDomainInfo.DomainSid,
                &GlobalAccountDomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to open account domain: 0x%x\n",Status));
        goto Cleanup;
    }

Cleanup:
    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                PolicyInformation
                );
    }
    if (ServerHandle != NULL)
    {
        SamrCloseHandle(&ServerHandle);
    }
    if (!NT_SUCCESS(Status))
    {
        if (GlobalPolicyHandle != NULL)
        {
            LsarClose(&GlobalPolicyHandle);
            GlobalPolicyHandle = NULL;
        }
        if (GlobalAccountDomainHandle != NULL)
        {
            SamrCloseHandle(&GlobalAccountDomainHandle);
            GlobalAccountDomainHandle = NULL;
        }
    }

    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupAccountDomain
//
//  Synopsis:   cleans up resources associated with SAM and LSA
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CleanupAccountDomain()
{

    if (GlobalPolicyHandle != NULL)
    {
        LsarClose(&GlobalPolicyHandle);
        GlobalPolicyHandle = NULL;
    }
    if (GlobalAccountDomainHandle != NULL)
    {
        SamrCloseHandle(&GlobalAccountDomainHandle);
        GlobalAccountDomainHandle = NULL;
    }

    KerbFreeString(&GlobalDomainName);

    if (GlobalDomainSid != NULL)
    {
        LocalFree(GlobalDomainSid);
        GlobalDomainSid = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Name:       KdcServiceMain
//
//  Synopsis:   This is the main KDC thread.
//
//  Arguments:  dwArgc   -
//              pszArgv  -
//
//  Notes:      This intializes everything, and starts the working threads.
//
//--------------------------------------------------------------------------

extern "C"
void
KdcServiceMain( DWORD   dwArgc,
                LPTSTR *pszArgv)
{
    TRACE(KDC, KdcServiceMain, DEB_FUNCTION);

    NTSTATUS  hrRet;
    ULONG     RpcStatus;
    ULONG     ThreadID;
    HANDLE    hThread;
    HANDLE    hParamEvent = NULL;
    ULONG     ulStates = 0;
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    NTSTATUS  TempStatus;
    KERBERR KerbErr;
    NT_PRODUCT_TYPE NtProductType;

#define RPCDONE        0x1
#define LOCATORSTARTED 0x2
#define CRITSECSDONE   0x4

    KdcState = Starting;

    //
    // Get the debugging parameters
    //

    GetDebugParams();

    //
    // Get other parameters, register wait on debug key..
    //

    KdcLoadParameters();

    hParamEvent = CreateEvent(NULL,
                              FALSE,
                              FALSE,
                              NULL);

    if (NULL == hParamEvent) 
    {
        D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
    } else {
        KerbWatchParamKey(hParamEvent, FALSE);
    }
                                      
    D_DebugLog((DEB_TRACE, "Start KdcServiceMain\n"));

    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_KDC, Handler);
    if (!hService)
    {
        D_DebugLog((DEB_ERROR, "Could not register handler, %d\n", GetLastError()));
    }

    SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    SStatus.dwCurrentState = SERVICE_STOPPED;
    SStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    SStatus.dwWin32ExitCode = 0;
    SStatus.dwServiceSpecificExitCode = 0;
    SStatus.dwCheckPoint = 0;
    SStatus.dwWaitHint = 0;

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Set up the event log service
    //

    InitializeEvents();

    //
    // Check out product type
    //

    if ( !RtlGetNtProductType( &NtProductType ) || ( NtProductType != NtProductLanManNt ) ) {
        D_DebugLog((DEB_WARN, "Can't start KDC on non-lanmanNT systems\n"));
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Shutdown;
    }

    RtlInitUnicodeString(
        &GlobalKerberosName,
        MICROSOFT_KERBEROS_NAME_W
        );

    RtlInitUnicodeString(
        &GlobalKdcName,
        SERVICE_KDC
        );

    //
    // Build our Kpasswd name, so we don't have to alloc on 
    // every TGS request.
    //
    NtStatus = KerbBuildKpasswdName(
                  &GlobalKpasswdName
                  );

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build KPASSWED name, error 0x%X\n", NtStatus));
        goto Shutdown;
    }
    
    GlobalLocalhostAddress[0] = 127;
    GlobalLocalhostAddress[1] = 0;
    GlobalLocalhostAddress[2] = 0;
    GlobalLocalhostAddress[3] = 1;
    //
    // Wait for SAM to start
    //

    if (!KdcWaitForSamService( ))
    {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Can't proceed unless the kerb SSPI package has initialized
    // (KdrbKdcCallback might get invoked and that requires kerb
    //  global resource being intialized)
    //

    if ( !KerbIsInitialized()) {

        NtStatus = STATUS_UNSUCCESSFUL;
        DebugLog((DEB_ERROR, "Kerb SSPI package not initialized: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    //
    // Register for the Ds callback
    //

    if (!KdcRegisterToWaitForDS( ))
    {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Initialize notification
    //

    if (!InitializeChangeNotify())
    {
        hrRet = STATUS_INTERNAL_ERROR;
        goto Shutdown;
    }

    //
    // Get a handle to the SAM account domain
    //

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    NtStatus = OpenAccountDomain();

    if (!NT_SUCCESS(NtStatus))
    {
        DebugLog((DEB_ERROR, "Failed to get domain handle: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Initialize the PK infrastructure
    //

    NtStatus = KdcInitializeCerts();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize certs: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Start the RPC sequences
    //

    NtStatus = StartAllProtSeqs();

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to start RPC, error 0x%X\n", NtStatus));
        goto Shutdown;
    }

    //
    // Start the socket listening code.
    //

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Load all global data into the SecData structure.
    //

    NtStatus = SecData.Init();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to init SecData error 0x%X\n", NtStatus));
        goto Shutdown;
    }


    //
    // Set the flag to indicate this is a trust account
    //

    // KdcTicketInfo.UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT;



    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Create the KDC shutdown event, set to FALSE
    //
    hKdcShutdownEvent = CreateEvent( NULL,      // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();
        
        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown event: wincode=%d.\n",
                    NtStatus ));
        
        goto Shutdown;
    }



    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }



#if DBG
    NtStatus = RegisterKdcEps();
    if(!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Ep register failed %x\n", NtStatus));
//        goto Shutdown;
    }
#endif // DBG

    ulStates |= RPCDONE;

    //
    // 1 is the minimum number of threads.
    // TRUE means the call will return, rather than waiting until the
    //     server shuts down.
    //

    NtStatus = KdcInitializeSockets();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to initailzie sockets\n"));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    InitializeListHead(&KdcDomainList);
    NtStatus = (NTSTATUS) KdcReloadDomainTree( NULL );
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build domain tree: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    NtStatus = LsaIKerberosRegisterTrustNotification( KdcTrustChangeCallback, LsaRegister );
    if (!NT_SUCCESS( NtStatus ))
    {
        D_DebugLog((DEB_ERROR, "Failed to register notification\n"));
    }


    RpcStatus = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);

    if (RpcStatus != ERROR_SUCCESS)
    {
        if (RpcStatus != RPC_S_ALREADY_LISTENING)
        {
            D_DebugLog(( DEB_ERROR, "Error from RpcServerListen: %d\n", RpcStatus ));
            NtStatus = I_RpcMapWin32Status(RpcStatus);
            goto Shutdown;
        }
    }

    //
    // At this point the KDC is officially started.
    // 3 * ( 2*(hip) horray! )
    //

    if (!UpdateStatus(SERVICE_RUNNING) )
    {
        goto Shutdown;
    }

#if DBG
    GetSystemTimeAsFileTime((PFILETIME)&tsOut);
    D_DebugLog((DEB_TRACE, "Time required for KDC to start up: %d ms\n",
                         (tsOut.LowPart-tsIn.LowPart) / 10000));
#endif


    SetKdcStartEvent();

    KdcState = Running;

    KdcInitializeTrace();

    // This function will loop until the event is true.
    
    // WAS BUG: turn off cache manager for now.
    // This bug comment is a stale piece of code from
    // Cairo days - per MikeSw
    //

    WaitForSingleObject(hKdcShutdownEvent, INFINITE);


Shutdown:


    LsaIKerberosRegisterTrustNotification( KdcTrustChangeCallback, LsaUnregister );
    LsaIUnregisterAllPolicyChangeNotificationCallback(KdcPolicyChangeCallBack);


    //
    // Time to cleanup up all resources ...
    //

    TempStatus = I_NetLogonSetServiceBits( DS_KDC_FLAG, 0 );
    if ( !NT_SUCCESS(TempStatus) ) {
        D_DebugLog((DEB_TRACE,"Can't tell netlogon we're stopped 0x%lX\n", TempStatus ));
    }

    //
    // Remove the wait routine for the DS paused event
    //

    if ( KdcGlobalDsPausedWaitHandle != NULL ) {

        UnregisterWaitEx( KdcGlobalDsPausedWaitHandle,
                          INVALID_HANDLE_VALUE ); // Wait until routine finishes execution

        KdcGlobalDsPausedWaitHandle = NULL;
    }

    if (NULL != GlobalKpasswdName)
    {
       KerbFreeKdcName(&GlobalKpasswdName);
    }                                    

    if (KdcGlobalDsEventHandle)
    {
        CloseHandle( KdcGlobalDsEventHandle );
        KdcGlobalDsEventHandle = NULL;
    }

    //
    // Shut down event log service.
    //
    ShutdownEvents();


    UpdateStatus(SERVICE_STOP_PENDING);


#if DBG
    if(ulStates & RPCDONE)
    {
       (VOID)UnRegisterKdcEps();
       UpdateStatus(SERVICE_STOP_PENDING);
    }
#endif // DBG

    KdcShutdownSockets();

    KdcCleanupCerts(
        TRUE            // cleanup scavenger
        );

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Close all of the events.
    //

    {
        PHANDLE ph = &hKdcHandles[0];

        for(;ph < &hKdcHandles[MAX_KDC_HANDLE]; ph++)
        {
            if(*ph)
            {
                CloseHandle(*ph);
                *ph = NULL;
            }
        }
    }
#ifdef  RETAIL_LOG_SUPPORT 
    if (hParamEvent) {
        WaitCleanup(hParamEvent);
    }
#endif


    //
    // Cleanup handles to SAM & LSA and global variables
    //

    CleanupAccountDomain();

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Cleanup the domain list
    //

    //
    // BUGBUG: need to make sure it is not being used.
    //

    KdcFreeDomainList(&KdcDomainList);
    KdcFreeReferralCache(&KdcReferralCache);

    SStatus.dwWin32ExitCode = RtlNtStatusToDosError(NtStatus);
    SStatus.dwServiceSpecificExitCode = 0;


    D_DebugLog(( DEB_TRACE, "KDC shutting down.\n" ));
    UpdateStatus(SERVICE_STOPPED);
    D_DebugLog((DEB_TRACE, "End KdcServiceMain\n"));
}



////////////////////////////////////////////////////////////////////
//
//  Name:       ShutDown
//
//  Synopsis:   Shuts the KDC down.
//
//  Arguments:  pszMessage   - message to print to debug port
//
//  Notes:      Stops RPC from accepting new calls, waits for pending calls
//              to finish, and sets the global event "hKdcShutDownEvent".
//
NTSTATUS
ShutDown(LPWSTR pszMessage)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    TRACE(KDC, ShutDown, DEB_FUNCTION);

    D_DebugLog((DEB_WARN, "Server Shutdown:  %ws\n", pszMessage));


    //
    // Notify the all threads that we are exiting.
    //


    //
    // First set the started flag to false so nobody will try any more
    // direct calls to the KDC.
    //

    KdcState = Stopped;

    //
    // If there are any outstanding calls, let them trigger the shutdown event.
    // Otherwise set the shutdown event ourselves.
    //

    EnterCriticalSection(&ApiCriticalSection);
    if (CurrentApiCallers == 0)
    {

        if (!SetEvent( hKdcShutdownEvent ) )
        {
            D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown event.  winerr=%d.\n",
                        GetLastError() ));
            NtStatus = STATUS_UNSUCCESSFUL;
        }
        SecData.Cleanup();
        if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( KdcTraceRegistrationHandle );
        }
    }
    LeaveCriticalSection(&ApiCriticalSection);

    return(NtStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL initialization routine
//
//--------------------------------------------------------------------------

extern "C" BOOL WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    )
{
    BOOL bReturn = TRUE;
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls ( hInstance );

        //
        // WAS BUG: call the Rtl version here because it returns an error
        // instead of throwing an exception.  Leave it here, as we don't
        // really need to put a try/except around InitCritSec.
        //

        bReturn = NT_SUCCESS(RtlInitializeCriticalSection( &ApiCriticalSection ));
    } else if (dwReason == DLL_PROCESS_DETACH) {
        DeleteCriticalSection(&ApiCriticalSection);
    }

    return bReturn;
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(hInstance);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\gettgs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       gettgs.cxx
//
//  Contents:   GetTGSTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------
#include "kdcsvr.hxx"
#include "kdctrace.h"
#include <tostring.hxx>
#include <userall.h>

#include "fileno.h"


#define FILENO  FILENO_GETTGS

extern LARGE_INTEGER tsInfinity;
extern LONG lInfinity;

UNICODE_STRING KdcNullString = {0,0,NULL};



//--------------------------------------------------------------------
//
//  Name:       KdcGetS4UPac
//
//  Synopsis:   Track down the user acct for PAC info.
//
//  Effects:    Get the PAC
//
//  Arguments:  S4UClientName    - ClientName from S4U PA Data
//              PAC              - Resultant PAC (signed w/? key) 
//                            
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/ 
//
//
//--------------------------------------------------------------------------
KERBERR
KdcGetS4UTicketInfo(
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN OUT PUSER_INTERNAL6_INFORMATION * UserInfo,
    IN OUT PSID_AND_ATTRIBUTES_LIST GroupMembership, 
    IN OUT PKERB_EXT_ERROR ExtendedError
    )
{   

    KERBERR KerbErr;
    UNICODE_STRING  S4UClient = {0};
    KDC_TICKET_INFO S4UClientInfo;

    KerbErr = KerbConvertKdcNameToString(
                    &S4UClient,
                    S4UClientName,
                    NULL
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    } 

    //
    // Get the user information...
    //
    KerbErr = KdcGetTicketInfo(
                &S4UClient,
                SAM_OPEN_BY_UPN_OR_ACCOUNTNAME,  // extra flags?
                S4UClientName,
                NULL, 
                &S4UClientInfo,
                ExtendedError,
                NULL,
                USER_ALL_KDC_GET_PAC_AUTH_DATA,
                0L,
                UserInfo,
                GroupMembership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Getting the ticket info for S4U req failed - %x\n", KerbErr));
        DsysAssert(FALSE);
        goto Cleanup;
    }

Cleanup:

    KerbFreeString(&S4UClient);
    FreeTicketInfo(
        &S4UClientInfo
        );

    return KerbErr;

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcAuditAccountMapping
//
//  Synopsis:   Generates, if necessary, a success/failure audit for name
//              mapping. The names are converted to a string before
//              being passed to the LSA.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcAuditAccountMapping(
    IN PKERB_INTERNAL_NAME ClientName,
    IN KERB_REALM ClientRealm,
    IN OPTIONAL PKDC_TICKET_INFO MappedTicketInfo
    )
{
    UNICODE_STRING ClientString = {0};
    PUNICODE_STRING MappedName = NULL;
    UNICODE_STRING UnicodeRealm = {0};
    UNICODE_STRING NullString = {0};
    KERBERR KerbErr;
    BOOLEAN Successful;

    if (ARGUMENT_PRESENT(MappedTicketInfo))
    {
        if (!SecData.AuditKdcEvent(KDC_AUDIT_MAP_SUCCESS))
        {
            return;
        }
        Successful = TRUE;
        MappedName = &MappedTicketInfo->AccountName;
    }
    else
    {
        if (!SecData.AuditKdcEvent(KDC_AUDIT_MAP_FAILURE))
        {
            return;
        }
        MappedName = &NullString;
        Successful = FALSE;
    }


    KerbErr = KerbConvertRealmToUnicodeString(
                &UnicodeRealm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        return;
    }


    if (KERB_SUCCESS(KerbConvertKdcNameToString(
            &ClientString,
            ClientName,
            &UnicodeRealm
            )))
    {
        LsaIAuditAccountLogon(
            SE_AUDITID_ACCOUNT_MAPPED,
            Successful,
            &GlobalKdcName,
            &ClientString,
            MappedName,
            0                   // no status
            );

        KerbFreeString(
            &ClientString
            );

    }

    KerbFreeString(
        &UnicodeRealm
        );
}

//----------------------------------------------------------------
//
//  Name:       KdcInsertAuthorizationData
//
//  Synopsis:   Inserts auth data into a newly created ticket.
//
//  Arguments:  FinalTicket - Ticket to insert Auth data into
//              EncryptedAuthData - Auth data (optional)
//              SourceTicket - Source ticket
//
//  Notes:      This copies the authorization data from the source ticket
//              to the destiation ticket, and adds the authorization data
//              passed in.  It is called by GetTGSTicket.
//
//              This assumes that pedAuthData is an encrypted
//              KERB_AUTHORIZATION_DATA.
//              It will copy all the elements of that list to the new ticket.
//              If pedAuthData is not supplied (or is empty), and there is
//              auth data in the source ticket, it is copied to the new
//              ticket.  If no source ticket, and no auth data is passed
//              in, nothing is done.
//
//----------------------------------------------------------------

KERBERR
KdcInsertAuthorizationData(
    OUT PKERB_ENCRYPTED_TICKET FinalTicket,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN OPTIONAL PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN BOOLEAN DoingS4U,
    IN PKERB_ENCRYPTED_TICKET SourceTicket,
    IN BOOLEAN AddResourceGroups,
    IN OPTIONAL PKDC_TICKET_INFO OriginalServerInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY OriginalServerKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TargetServerKey
    )
{
    PKERB_AUTHORIZATION_DATA SourceAuthData = NULL;
    PKERB_AUTHORIZATION_DATA FinalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA NewPacAuthData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA_LIST * TempAuthData = NULL;
    PKERB_AUTHORIZATION_DATA NextAuthData;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA SuppliedAuthData = NULL;
    UNICODE_STRING DummyName = {0};
    SID_AND_ATTRIBUTES_LIST S4UGroupMembership = {0};
    PUSER_INTERNAL6_INFORMATION S4UUserInfo = NULL;
    



    TRACE(KDC, InsertAuthorizationData, DEB_FUNCTION);

    D_DebugLog(( DEB_T_TICKETS, "Inserting authorization data into ticket.\n" ));

    //
    // First try to decrypt the supplied authorization data
    //

    if (!DoingS4U)
    {

        if (ARGUMENT_PRESENT(EncryptedAuthData))
        {
            KerbErr = KerbDecryptDataEx(
                            EncryptedAuthData,
                            &SourceTicket->key,
                            KERB_NON_KERB_SALT,         // WAS BUG: wrong salt, removed per MikeSw
                            &EncryptedAuthData->cipher_text.length,
                            EncryptedAuthData->cipher_text.value
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_WARN,
                          "KLIN(%x) Failed to decrypt encrypted auth data: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
                goto Cleanup;
            }

            //      
            // Now decode it
            //              

            KerbErr = KerbUnpackData(
                            EncryptedAuthData->cipher_text.value,
                            EncryptedAuthData->cipher_text.length,
                            PKERB_AUTHORIZATION_DATA_LIST_PDU,
                            (PVOID *) &TempAuthData
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            if (TempAuthData != NULL)
            {
                SuppliedAuthData = *TempAuthData;
            }
        }


        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
        {
            DsysAssert(SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL);
            SourceAuthData = SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data;

            //      
            // Get the AuthData from the source ticket
            //              

            KerbErr = KerbGetPacFromAuthData(
                SourceAuthData,
                &IfRelevantData,
                &PacAuthData
                );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to get pac from auth data: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
                goto Cleanup;
            }


        }


        //      
        // The new auth data is the original auth data appended to the
        // supplied auth data. The new auth data goes first, followed by the
        // auth data from the original ticket.
        //                      


        //      
        // Update the PAC, if it is present.
        //              

        if (ARGUMENT_PRESENT(OriginalServerKey) && (PacAuthData != NULL))
        {
            KerbErr = KdcVerifyAndResignPac(
                        OriginalServerKey,
                        TargetServerKey,
                        OriginalServerInfo,
                        AddResourceGroups,
                        PacAuthData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify & resign pac: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));

                goto Cleanup;
            }

            //      
            // Copy the old auth data & insert the PAC
            //              

            KerbErr = KdcInsertPacIntoAuthData(
                        SourceAuthData,
                        (IfRelevantData != NULL) ? *IfRelevantData : NULL,
                        PacAuthData,
                        &FinalAuthData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert pac into auth data: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));

                goto Cleanup;
            }
        }
    }
    


    if (DoingS4U)
    {
    
        //
        // Use the PAC from the S4U data to return in the TGT / Service Ticket
        //
   
        KerbErr = KdcGetS4UTicketInfo(
                    S4UClientName,
                    &S4UUserInfo,
                    &S4UGroupMembership,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KdcGetPacAuthData(
                     S4UUserInfo,
                     &S4UGroupMembership,
                     TargetServerKey,
                     NULL,                   // no credential key
                     AddResourceGroups,
                     FinalTicket,
                     S4UClientName,
                     &NewPacAuthData,
                     pExtendedError
                     );
        
        SamIFreeSidAndAttributesList(&S4UGroupMembership);
        SamIFree_UserInternal6Information( S4UUserInfo );


        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Failed to get S4UPacAUthData\n"));
            DsysAssert(FALSE);
            goto Cleanup;
        }

        FinalAuthData = NewPacAuthData;
        NewPacAuthData = NULL;

    }

    //
    // If there was no original PAC, try to insert one here. If the ticket
    // was issued from this realm we don't add a pac.
    //
    
    else if ((PacAuthData == NULL) && !SecData.IsOurRealm(&SourceTicket->client_realm))
    {  
        KDC_TICKET_INFO ClientTicketInfo = {0};
        SID_AND_ATTRIBUTES_LIST GroupMembership = {0};
        PUSER_INTERNAL6_INFORMATION UserInfo = NULL;

             
        //
        // Try mapping the name to get a PAC
        //

        KerbErr = KerbConvertPrincipalNameToKdcName(
                        &ClientName,
                        &SourceTicket->client_name
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KdcGetTicketInfo(
                    &DummyName,
                    SAM_OPEN_BY_ALTERNATE_ID,
                    ClientName,
                    &SourceTicket->client_realm,
                    &ClientTicketInfo,
                    pExtendedError,
                    NULL,                   // no handle
                    USER_ALL_KDC_GET_PAC_AUTH_DATA,
                    0L,                     // no extended fields
                    &UserInfo,
                    &GroupMembership
                    );

        if (KERB_SUCCESS(KerbErr))
        {

            KdcAuditAccountMapping(
                ClientName,
                SourceTicket->client_realm,
                &ClientTicketInfo
                );

            FreeTicketInfo(&ClientTicketInfo);
            KerbFreeKdcName(&ClientName);

            KerbErr = KdcGetPacAuthData(
                        UserInfo,
                        &GroupMembership,
                        TargetServerKey,
                        NULL,                   // no credential key
                        AddResourceGroups,
                        FinalTicket,
                        NULL, // no S4U client
                        &NewPacAuthData,
                        pExtendedError
                        );

            SamIFreeSidAndAttributesList(&GroupMembership);
            SamIFree_UserInternal6Information( UserInfo );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

        } else if (KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN) {

            KdcAuditAccountMapping(
                ClientName,
                SourceTicket->client_realm,
                NULL
                );

            KerbFreeKdcName(&ClientName);

            KerbErr = KDC_ERR_NONE;
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // If we got a PAC, stick it in the list
        //

        if (NewPacAuthData != NULL)
        {
            //
            // Copy the old auth data & insert the PAC
            //

            KerbErr = KerbCopyAndAppendAuthData(
                        &NewPacAuthData,
                        SourceAuthData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert pac into auth data: 0x%x\n",
                    KLIN(FILENO, __LINE__), KerbErr));
                goto Cleanup;
            }
            FinalAuthData = NewPacAuthData;
            NewPacAuthData = NULL;
        }
    }


    //
    // if there was any auth data and  we didn't copy it transfering the
    // PAC, do so now
    //

    if ((SourceAuthData != NULL) && (FinalAuthData == NULL))
    {
        KerbErr = KerbCopyAndAppendAuthData(
                    &FinalAuthData,
                    SourceAuthData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (SuppliedAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
                    &FinalAuthData,
                    SuppliedAuthData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    if (FinalAuthData != NULL)
    {
        FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;
        FinalAuthData = NULL;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    KerbFreeAuthData(
        FinalAuthData
        );

    if (TempAuthData != NULL)
    {
        KerbFreeData(
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            TempAuthData
            );
    }

    KerbFreeAuthData(NewPacAuthData);

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }


    return(KerbErr);
}


                                  
//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketTGS
//
//  Synopsis:   Builds (most of) a TGS ticket
//
//  Arguments:  ServiceTicketInfo - Ticket info for the requested service
//              ReferralRealm - Realm to build referral to
//              RequestBody - The request causing this ticket to be built
//              SourceTicket - The TGT used to make this request
//              Referral - TRUE if this is an inter-realm referral ticke
//              CommonEType - Contains the common encryption type between
//                      client and server
//              NewTicket - The new ticket built here.
//
//
//  History:    24-May-93   WadeR   Created
//
//  Notes:      see 3.3.3, A.6 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------


KERBERR
BuildTicketTGS(
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_TICKET SourceTicket,
    IN BOOLEAN Referral,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    IN ULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    IN OUT PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET OutputTicket;
    PKERB_ENCRYPTED_TICKET EncryptedTicket;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart;
    LARGE_INTEGER SourceRenewUntil;
    LARGE_INTEGER SourceEndTime;
    LARGE_INTEGER SourceStartTime;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    UNICODE_STRING NewTransitedInfo = {0,0,NULL};
    UNICODE_STRING ClientRealm = {0,0,NULL};
    UNICODE_STRING TransitedRealm = {0,0,NULL};
    UNICODE_STRING OldTransitedInfo = {0,0,NULL};
    STRING OldTransitedString;
    ULONG KdcOptions = 0;
    BOOLEAN fKpasswd = FALSE;
    ULONG TicketFlags = 0;
    ULONG SourceTicketFlags = 0;
    PKERB_HOST_ADDRESSES Addresses = NULL;
    
    TRACE(KDC, BuildTicketTGS, DEB_FUNCTION);

    D_DebugLog(( DEB_T_TICKETS, "Building a TGS ticket\n" ));

    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputTicket = *NewTicket;
    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) OutputTicket.encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Get the times from the source ticket into a usable form
    //

    if (SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &SourceRenewUntil,
            &SourceEncryptPart->KERB_ENCRYPTED_TICKET_renew_until,
            0
            );
    }
    else
    {
        SourceRenewUntil.QuadPart = 0;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &SourceEndTime,
        &SourceEncryptPart->endtime,
        0
        );

    if (SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {

        KerbConvertGeneralizedTimeToLargeInt(
            &SourceStartTime,
            &SourceEncryptPart->KERB_ENCRYPTED_TICKET_starttime,
            0
            );

    }
    else
    {
        SourceStartTime.QuadPart = 0;
    }

    
    //
    // Check to see if the request is for the kpasswd service, in
    // which case, we only want the ticket to be good for 2 minutes.
    //
    KerbErr = KerbCompareKdcNameToPrincipalName(
                  &RequestBody->server_name,
                  GlobalKpasswdName,
                  &fKpasswd
                  );

    if (!fKpasswd || !KERB_SUCCESS(KerbErr))
    {
       TicketLifespan = SecData.KdcTgsTicketLifespan();
       TicketRenewspan = SecData.KdcTicketRenewSpan();
    }
    else
    {
       TicketLifespan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
       TicketRenewspan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
    }


    //
    // TBD:  We need to make the ticket 10 minutes if we're doing s4U
    //

    KerbErr = KdcBuildTicketTimesAndFlags(
                0,                      // no client policy
                ServiceTicketInfo->fTicketOpts,
                &TicketLifespan,
                &TicketRenewspan,
                NULL,                   // no logoff time
                NULL,                   // no acct expiry.
                RequestBody,
                SourceEncryptPart,
                EncryptedTicket,
                ExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    TicketFlags = KerbConvertFlagsToUlong( &EncryptedTicket->flags );
    SourceTicketFlags = KerbConvertFlagsToUlong( &SourceEncryptPart->flags );

    KerbErr = KerbMakeKey(
                CommonEType,
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    OldTransitedString.Buffer = (PCHAR) SourceEncryptPart->transited.contents.value;
    OldTransitedString.Length = OldTransitedString.MaximumLength = (USHORT) SourceEncryptPart->transited.contents.length;

    //
    // Fill in the service names
    //

    if (Referral)
    {
        PKERB_INTERNAL_NAME TempServiceName;

        //
        // For referral tickets we put a the name "krbtgt/remoterealm@localrealm"
        //


        //
        // We should only be doing this when we didn't get a non-ms principal
        //


        KerbErr = KerbBuildFullServiceKdcName(
                    &ServiceTicketInfo->AccountName,
                    SecData.KdcServiceName(),
                    KRB_NT_SRV_INST,
                    &TempServiceName
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertKdcNameToPrincipalName(
                    &OutputTicket.server_name,
                    TempServiceName
                    );

        KerbFreeKdcName(&TempServiceName);

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // If we got here on a referral ticket and are generating one
        // and the referral ticket we received was not from the client's
        // realm, add in the transited information.
        //

        if (!KerbCompareRealmNames(
                &SourceEncryptPart->client_realm,
                &SourceTicket->realm))
        {


            KerbErr = KerbStringToUnicodeString(
                        &OldTransitedInfo,
                        &OldTransitedString
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            KerbErr = KerbConvertRealmToUnicodeString(
                        &TransitedRealm,
                        &SourceTicket->realm
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &ClientRealm,
                        &SourceEncryptPart->client_realm
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KdcInsertTransitedRealm(
                        &NewTransitedInfo,
                        &OldTransitedInfo,
                        &ClientRealm,
                        &TransitedRealm,
                        SecData.KdcDnsRealmName()
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }


        }
    }
    else
    {
        UNICODE_STRING TempServiceName;

        //
        // If the client didn't request name canonicalization, use the
        // name supplied by the client
        //

        if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
            ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
        {
            if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
            {
                PKERB_INTERNAL_NAME TempServiceName = NULL;

                KerbErr = KerbBuildFullServiceKdcName(
                            SecData.KdcDnsRealmName(),
                            SecData.KdcServiceName(),
                            KRB_NT_SRV_INST,
                            &TempServiceName
                            );

                if (!KERB_SUCCESS(KerbErr))
                {
                    goto Cleanup;
                }

                KerbErr = KerbConvertKdcNameToPrincipalName(
                            &OutputTicket.server_name,
                            TempServiceName
                            );

                KerbFreeKdcName(&TempServiceName);

            }
            else
            //
            // We no longer use the NC bit to change the server name, so just
            // duplicate the non-NC case, and return the server name from 
            // the TGS_REQ.  NC is still used for building PA DATA for referral
            // however. and we should keep it for TGT renewal.  TS 2001-4-03
            //

            {

                KerbErr = KerbDuplicatePrincipalName(
                            &OutputTicket.server_name,
                            &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                            );

            }
        }
        else
        {

            KerbErr = KerbDuplicatePrincipalName(
                        &OutputTicket.server_name,
                        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                        );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    //
    // Copy all the other strings over
    //

    EncryptedTicket->client_realm = SourceEncryptPart->client_realm;
    

    //
    // S4U dance...  Get the client name and realm from 
    //
    if (ARGUMENT_PRESENT(S4UClientName) && 
        ARGUMENT_PRESENT(S4UClientRealm) &&
        !Referral)
    { 

        DebugLog((DEB_ERROR, "Swapping real client name for S4U CLient name\n"));

        KerbErr = KerbConvertKdcNameToPrincipalName(
                        &EncryptedTicket->client_name,
                        S4UClientName
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }  

        KerbErr = KerbConvertUnicodeStringToRealm(
                    &EncryptedTicket->client_realm,
                    S4UClientRealm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
    else
    { 
        KerbErr = KerbDuplicatePrincipalName(
                    &EncryptedTicket->client_name,
                    &SourceEncryptPart->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        EncryptedTicket->client_realm = SourceEncryptPart->client_realm;

    }

    //
    // If the client did not request canonicalization, return the same
    // realm as it sent. Otherwise, send our DNS realm name
    //

//    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) ||
//        ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
//
//    {
        OutputTicket.realm = SecData.KdcKerbDnsRealmName();
//    }
//    else
//    {
//        OutputTicket.realm = RequestBody->realm;
//    }


    //
    // Insert transited realms, if present
    //

    if (NewTransitedInfo.Length != 0)
    {
        STRING TempString;
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempString,
                    &NewTransitedInfo
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {

        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) MIDL_user_allocate(OldTransitedString.Length);
        if (EncryptedTicket->transited.contents.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        EncryptedTicket->transited.contents.length = (int) OldTransitedString.Length;
        RtlCopyMemory(
            EncryptedTicket->transited.contents.value,
            OldTransitedString.Buffer,
            OldTransitedString.Length
            );

    }

    //
    // Insert the client addresses. We only update them if the new ticket
    // is forwarded of proxied and the source ticket was forwardable or proxiable
    // - else we copy the old ones
    //

    if ((((TicketFlags & KERB_TICKET_FLAGS_forwarded) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) != 0)) ||
        (((TicketFlags & KERB_TICKET_FLAGS_proxy) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) != 0)))
    {
        if ((RequestBody->bit_mask & addresses_present) != 0)
        {
            Addresses = RequestBody->addresses;
        }
    }
    else
    {
        if ((SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0)
        {
            Addresses = SourceEncryptPart->KERB_ENCRYPTED_TICKET_client_addresses;
        }
    }

    if (Addresses != NULL)
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = Addresses;
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
    }


    //
    // The authorization data will be added by the caller, so set it
    // to NULL here.
    //

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;


    OutputTicket.ticket_version = KERBEROS_VERSION;
    *NewTicket = OutputTicket;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(&OutputTicket);
    }

    KerbFreeString(&NewTransitedInfo);
    KerbFreeString(&OldTransitedInfo);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&TransitedRealm);
    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsLogonRestrictions
//
//  Synopsis:   Verifies that a client is allowed to request a TGS ticket
//              by checking logon restrictions.
//
//  Effects:
//
//  Arguments:  ClientName - Name of client to check
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or a logon restriction error
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcCheckTgsLogonRestrictions(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm, 
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR Status;
    UNICODE_STRING MappedClientRealm = {0};
    BOOLEAN ClientReferral;
    KDC_TICKET_INFO ClientInfo = {0};
    SAMPR_HANDLE UserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    LARGE_INTEGER LogoffTime;
    NTSTATUS LogonStatus = STATUS_SUCCESS;

    //
    // If the client is from a different realm, don't bother looking
    // it up - the account won't be here.
    //

    if (!SecData.IsOurRealm(
            ClientRealm
            ))
    {
        return(KDC_ERR_NONE);
    }

    //
    // Normalize the client name
    //

    
    Status = KdcNormalize(
                ClientName,
                NULL,
                ClientRealm,
                KDC_NAME_CLIENT,
                &ClientReferral,
                &MappedClientRealm,
                &ClientInfo,
                pExtendedError,
                &UserHandle,
                USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS,
                0L,
                &UserInfo,
                NULL            // no group memberships
                );

    if (!KERB_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name ", KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    Status = KerbCheckLogonRestrictions(
                UserHandle,
                NULL,           // No client address is available
                &UserInfo->I1,
                KDC_RESTRICT_PKINIT_USED | KDC_RESTRICT_IGNORE_PW_EXPIRATION,           // Don't bother checking for password expiration
                &LogoffTime,
                &LogonStatus
                );

    if (!KERB_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"KLIN (%x) Logon restriction check failed: 0x%x\n",
            KLIN(FILENO, __LINE__),Status));
        //
        //  This is a *very* important error to trickle back.  See 23456 in bug DB
        //
        FILL_EXT_ERROR(pExtendedError, LogonStatus, FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &MappedClientRealm );
    FreeTicketInfo( &ClientInfo );
    SamIFree_UserInternal6Information( UserInfo );

    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildReferralInfo
//
//  Synopsis:   Builds the referral information to return to the client.
//              We only return the realm name and no server name
//
//  Effects:
//
//  Arguments:  ReferralRealm - realm to refer client to
//              ReferralInfo - recevies encoded referral info
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildReferralInfo(
    IN PUNICODE_STRING ReferralRealm,
    OUT PKERB_PA_DATA_LIST *ReferralInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST ListElem = NULL;
    KERB_PA_SERV_REFERRAL ReferralData = {0};

    //
    // Fill in the unencoded structure.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &ReferralData.referred_server_realm,
                ReferralRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ListElem = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElem == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(ListElem, sizeof(KERB_PA_DATA_LIST));

    ListElem->value.preauth_data_type = KRB5_PADATA_REFERRAL_INFO;

    KerbErr = KerbPackData(
                &ReferralData,
                KERB_PA_SERV_REFERRAL_PDU,
                (PULONG) &ListElem->value.preauth_data.length,
                &ListElem->value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    *ReferralInfo = ListElem;
    ListElem = NULL;

Cleanup:
    if (ListElem != NULL)
    {
        if (ListElem->value.preauth_data.value != NULL)
        {
            KdcFreeEncodedData(ListElem->value.preauth_data.value);
        }
        MIDL_user_free(ListElem);
    }
    KerbFreeRealm(&ReferralData.referred_server_realm);
    return(KerbErr);

}


//--------------------------------------------------------------------
//
//  Name:       I_RenewTicket
//
//  Synopsis:   Renews an internal ticket.
//
//  Arguments:  SourceTicket - Source ticket for this request
//              ServiceName - Name of service for ticket
//              ClientRealm - Realm of client
//              ServiceTicketInfo - Ticket info from service account
//              RequestBody - Body of ticket request
//              NewTicket - Receives new ticket
//              CommonEType - Receives common encryption type for service ticket
//              TicketKey - Receives key used to encrypt the ticket
//
//  Notes:      Validates the ticket, gets the service's current key,
//              and builds the reply.
//
//
//--------------------------------------------------------------------


KERBERR
I_RenewTicket(
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    PKERB_ENCRYPTED_TICKET NewEncryptPart = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;
    PKERB_ENCRYPTION_KEY ServerKey;
    BOOLEAN NamesEqual = FALSE;
    
    TRACE(KDC, I_RenewTicket, DEB_FUNCTION);


    D_DebugLog(( DEB_TRACE, "Trying to renew a ticket to "));
    D_KerbPrintKdcName(DEB_TRACE, ServiceName );


    //
    // Make sure the original is renewable.
    //

    if ((KerbConvertFlagsToUlong(&SourceEncryptPart->flags) & KERB_TICKET_FLAGS_renewable) == 0)
    {
        D_DebugLog((DEB_WARN, "KLIN(%x) Attempt made to renew non-renewable ticket\n",
            KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure the source ticket service equals the service from the ticket info
    //

    KerbErr = KerbCompareKdcNameToPrincipalName(
                &SourceTicket->server_name,
                ServiceName,
                &NamesEqual
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!NamesEqual)
    {
        //
        // Make sure we the renewed ticket is for the same service as the original.
        //
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Find the common crypt system.
    //

    KerbErr = KerbFindCommonCryptSystem(
                RequestBody->encryption_type,
                ServiceTicketInfo->Passwords,
                NULL,
                CommonEType,
                &ServerKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcReportKeyError(
                &ServiceTicketInfo->AccountName,
                &ServiceTicketInfo->AccountName,
                KDCEVENT_NO_KEY_UNION_TGS,
                RequestBody->encryption_type,
                ServiceTicketInfo->Passwords
                );

        goto Cleanup;
    }

    //
    // Build the renewal ticket
    //


    KerbErr = BuildTicketTGS(
                ServiceTicketInfo,
                RequestBody,
                SourceTicket,
                FALSE,          // not referral
                NULL,           // not doing s4u
                NULL,           // not doing s4u
                *CommonEType,
                NewTicket,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,
            "KLIN(%x) Failed to build TGS ticket for renewal: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }


    //
    // BuildTicket puts a random session key in the ticket,
    // so replace it with the one from the source ticket.
    //

    KerbFreeKey(
        &NewEncryptPart->key
        );

    KerbErr = KerbDuplicateKey(
                &NewEncryptPart->key,
                &SourceEncryptPart->key
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Insert the auth data into the new ticket.
    //

    //
    // BUG 455049: if the service password changes, this will cause problems
    // because we don't resign the pac.
    //

    
    KerbErr = KdcInsertAuthorizationData(
                NewEncryptPart,
                pExtendedError,
                (RequestBody->bit_mask & enc_authorization_data_present) ?
                    &RequestBody->enc_authorization_data : NULL,
                NULL,
                FALSE,
                SourceEncryptPart,
                FALSE,                          // don't add local groups
                NULL,
                NULL,
                NULL
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            NewTicket
            );
    }

    return(KerbErr);

}

//--------------------------------------------------------------------
//
//  Name:       I_Validate
//
//  Synopsis:   Validates a post-dated ticket so that it can be used.
//              This is not implemented.
//
//  Arguments:  pkitSourceTicket    - (in) ticket to be validated
//              pkiaAuthenticator   -
//              pService            - (in) service ticket is for
//              pRealm              - (in) realm service exists in
//              pktrRequest         - (in) holds nonce for new ticket
//              pkdPAData           - (in)
//              pkitTicket          - (out) new ticket
//
//  Notes:      See 3.3 of the Kerberos V5 R5.2 spec
//
//--------------------------------------------------------------------


KERBERR
I_Validate(
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    return(KRB_ERR_GENERIC);
#ifdef notdef
    TRACE(KDC, I_Validate, DEB_FUNCTION);

    HRESULT hr;

    D_DebugLog(( DEB_TRACE, "Trying to validate a ticket to '%ws' for '%ws'...\n",
                pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                pkitSourceTicket->kitEncryptPart.Principal.accsid.pwszDisplayName ));
    PrintRequest( DEB_T_TICKETS, pktrRequest );
    PrintTicket( DEB_T_TICKETS, "Ticket to validate:", pkitSourceTicket );


    if ( (pkitSourceTicket->kitEncryptPart.fTicketFlags &
            (KERBFLAG_POSTDATED | KERBFLAG_INVALID))
         != (KERBFLAG_POSTDATED | KERBFLAG_INVALID) )
    {
        hr = KDC_E_BADOPTION;
    }
    else if (_wcsicmp(pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                     pasService->pwszDisplayName) != 0)
    {
        hr = KDC_E_BADOPTION;
    }
    else
    {
        TimeStamp tsNow, tsMinus, tsPlus;
        GetCurrentTimeStamp( &tsNow );
        tsMinus = tsNow - SkewTime;
        tsPlus = tsNow + SkewTime;
        PrintTime(DEB_TRACE, "Current time: ", tsNow );
        PrintTime(DEB_TRACE, "Past time: ", tsMinus );
        PrintTime(DEB_TRACE, "Future time: ", tsPlus );

        if (pkitSourceTicket->kitEncryptPart.tsStartTime > tsPlus )
            hr = KRB_E_TKT_NYV;
        else if (pkitSourceTicket->kitEncryptPart.tsEndTime < tsMinus )
            hr = KRB_E_TKT_EXPIRED;
        else
        {

            *pkitTicket = *pkitSourceTicket;
            pkitTicket->kitEncryptPart.fTicketFlags &= (~KERBFLAG_INVALID);
            hr = S_OK;
        }
    }
    return(hr);
#endif // notdef
}



//--------------------------------------------------------------------
//
//  Name:       I_GetTGSTicket
//
//  Synopsis:   Gets an internal ticket using a KDC ticket (TGT).
//
//  Arguments:  SourceTicket - TGT for the client
//              ServiceName - Service to get a ticket to
//              RequestBody - Body of KDC request message
//              ServiceTicketInfo - Ticket info for the service of the
//                      source ticket
//              TicketEncryptionKey - If present, then this is a
//                      enc_tkt_in_skey request and the PAC should be
//                      encrypted with this key.
//              CommonEType - Receives common encrytion type
//              NewTicket - Receives newly created ticket
//              ReplyPaData - Contains any PA data to put in the reply
//
//  Notes:      See GetTGSTicket.
//
//
//--------------------------------------------------------------------


KERBERR
I_GetTGSTicket(
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RequestRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketEncryptionKey,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_PA_DATA_LIST * ReplyPaData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{

    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING LocalServiceName;
    UNICODE_STRING ServicePrincipal;
    UNICODE_STRING ServiceRealm = {0};
    UNICODE_STRING ClientRealm = {0};
    BOOLEAN Referral = FALSE;
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET OutputEncryptedTicket = NULL;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_INTERNAL_NAME TargetPrincipal = ServiceName; 
    KERB_TICKET NewTicket = {0};
    PKERB_ENCRYPTION_KEY ServerKey;
    PKERB_ENCRYPTION_KEY OldServerKey;
    KDC_TICKET_INFO OldServiceTicketInfo = {0};
    ULONG NameFlags = 0;
    ULONG KdcOptions = 0;
    BOOLEAN GetS4UPac = FALSE;

    TRACE(KDC, I_GetTGSTicket, DEB_FUNCTION);

    //
    // Store away the encrypted ticket from the output ticket to
    // assign it at the end.
    //
    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputEncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Copy the space for flags from the real destination.
    //

    EncryptedTicket.flags = OutputEncryptedTicket->flags;

    LocalServiceName.Buffer = NULL;

    D_DebugLog(( DEB_TRACE, "Trying to build a new ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServiceName );


    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );
    if (KdcOptions & (KERB_KDC_OPTIONS_unused7 |
                        KERB_KDC_OPTIONS_reserved |
                        KERB_KDC_OPTIONS_unused9) )
    {
        DebugLog(( DEB_ERROR,"KLIN(%x) Bad options in TGS request: 0x%x\n",
            KLIN(FILENO, __LINE__), KdcOptions ));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

//    if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_NAME_CHECK_GC;
    }

    
    //
    // Verify this account is allowed to issue tickets.
    //

    if ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
        ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0))
    {
        D_DebugLog((DEB_ERROR,"Trying to make a TGS request with a ticket to %wZ\n",
            &ServiceTicketInfo->AccountName ));

        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Copy the ticket info into the old structure. It will be replaced with
    // new info from Normalize.
    //

    OldServiceTicketInfo = *ServiceTicketInfo;
    RtlZeroMemory(
        ServiceTicketInfo,
        sizeof(KDC_TICKET_INFO)
        );

    // 
    // If the client name is in our realm, verify client
    // identity and build the PAC for the client.
    //
    if ( ARGUMENT_PRESENT(S4UClientRealm) &&
         SecData.IsOurRealm(S4UClientRealm) )
    {  
        // Fester:
        DebugLog((DEB_ERROR, "Doing S4U client lookup!\n"));
        
        GetS4UPac = TRUE;
        
    }            
    //
    // If we have to refer, Normalize will put the credentials of the target
    // realm in ServiceTicketInfo.  Otherwise, it will be NULL.
    //

    KerbErr = KdcNormalize(
                TargetPrincipal,
                NULL,
                RequestRealm,
                NameFlags | KDC_NAME_SERVER | KDC_NAME_FOLLOW_REFERRALS,
                &Referral,
                &ServiceRealm,
                ServiceTicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all information
                NULL                    // no group membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) Failed to normalize ", KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_WARN,ServiceName);
        DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
        goto Cleanup;
    }


    if (ServiceTicketInfo != NULL)
    {
        if ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
            (ServiceTicketInfo->UserAccountControl & USER_ACCOUNT_DISABLED) != 0)
        {
            KerbErr = KDC_ERR_CLIENT_REVOKED;
            D_DebugLog((DEB_WARN,"KLIN(%x) Failed to normalize, account is disabled ",
                KLIN(FILENO, __LINE__)));
            KerbPrintKdcName(DEB_WARN,ServiceName);
            D_DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
            FILL_EXT_ERROR(pExtendedError, STATUS_ACCOUNT_DISABLED, FILENO, __LINE__);
            goto Cleanup;
        }
    }

    //
    // If this isn't an interdomain trust account, go ahead and issue a normal
    // ticket.
    //

    if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0)
    {

        //
        // Find the common crypt system.
        //

        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ServiceTicketInfo->Passwords,
                    NULL,
                    CommonEType,
                    &ServerKey
                    );

        
        if (!KERB_SUCCESS(KerbErr))
        {
            KdcReportKeyError(
                &ServiceTicketInfo->AccountName,
                &ServiceTicketInfo->AccountName,
                KDCEVENT_NO_KEY_UNION_TGS,
                RequestBody->encryption_type,
                ServiceTicketInfo->Passwords
                );

            goto Cleanup;
        }

        //
        // Check whether service is interactive, 'cause you can't
        // get a ticket to an interactive service.
        // 
        KerbErr = BuildTicketTGS(
                    ServiceTicketInfo,
                    RequestBody,
                    SourceTicket,
                    Referral,
                    S4UClientName,
                    S4UClientRealm,
                    *CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n",
                    KLIN(FILENO, __LINE__), &LocalServiceName, KerbErr ));
            goto Cleanup;
        }
    }
    else
    {
        //
        // Need to build a referal ticket.
        //

        D_DebugLog(( DEB_T_KDC, "GetTGSTicket: referring to domain '%wZ'\n",
                                &ServiceTicketInfo->AccountName ));


        //
        // Verify that if the trust is not transitive, the client is from
        // this realm.
        //

        SourceEncryptPart =(PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
                           
        if (((ServiceTicketInfo->fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0) &&
             (ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT))

        {
            if (!SecData.IsOurRealm(&SourceEncryptPart->client_realm))
            {
                D_DebugLog((DEB_WARN,"Client from realm %s attempted to access non transitve trust to %wZ : illegal\n",
                    SourceEncryptPart->client_realm,
                    &ServiceTicketInfo->AccountName
                    ));
                     
                KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
            }
        }

        //
        // Verify that the trust for the client is transitive as well, if it isn't
        // from this domain. This means that if the source ticket trust isn't
        // transitive, then this ticket can't be used to get further
        // tgt's, in any realm.
        //
        //  e.g. the TGT from client comes from a domain w/ which we don't
        //  have transitive trust.
        //

        if (((OldServiceTicketInfo.fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0) &&
            (OldServiceTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT))
        {
            KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
        }

        //
        //   This is probably not a common error, but could
        //   indicate a configuration problem, so log an explicit
        //   error.  See bug 87879.
        //
        if (KerbErr == KDC_ERR_PATH_NOT_ACCEPTED)
        {

           KerbErr = KerbConvertRealmToUnicodeString(
              &ClientRealm,
              &SourceEncryptPart->client_realm
              );

           if (KERB_SUCCESS(KerbErr))
           {
              ReportServiceEvent(
                 EVENTLOG_ERROR_TYPE,
                 KDCEVENT_FAILED_TRANSITIVE_TRUST,
                 0,                              // no raw data
                 NULL,                   // no raw data
                 2,                              // number of strings
                 ClientRealm.Buffer,
                 ServiceTicketInfo->AccountName.Buffer
                 );
           }
           
           KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
           goto Cleanup;
        }

        //
        // Find the common crypt system.
        //

        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ServiceTicketInfo->Passwords,
                    NULL,
                    CommonEType,
                    &ServerKey
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            KdcReportKeyError(
                &ServiceTicketInfo->AccountName,
                &ServiceTicketInfo->AccountName,
                KDCEVENT_NO_KEY_UNION_TGS,
                RequestBody->encryption_type,
                ServiceTicketInfo->Passwords
                );

            goto Cleanup;
        }

        

        KerbErr = BuildTicketTGS(
                    ServiceTicketInfo,
                    RequestBody,
                    SourceTicket,
                    TRUE,
                    NULL,  // not doing s4u
                    NULL,  // not doing s4u
                    *CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n",
                    KLIN(FILENO, __LINE__), &ServiceTicketInfo->AccountName, KerbErr ));
            goto Cleanup;
        }


        //
        // If this is a referral/canonicaliztion, return the target realm
        //

        if (Referral && ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
        {
            D_DebugLog((DEB_TRACE,"Building referral info for realm %wZ\n",
                        &ServiceRealm ));
            KerbErr = KdcBuildReferralInfo(
                        &ServiceRealm,
                        ReplyPaData
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

    }

    OldServerKey = KerbGetKeyFromList(
                    OldServiceTicketInfo.Passwords,
                    SourceTicket->encrypted_part.encryption_type
                    );

    DsysAssert(OldServerKey != NULL);
    if (OldServerKey == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Insert the auth data into the new ticket.
    //

    KerbErr = KdcInsertAuthorizationData(
                &EncryptedTicket,
                pExtendedError,
                (RequestBody->bit_mask & enc_authorization_data_present) ?
                    &RequestBody->enc_authorization_data : NULL,
                S4UClientName,
                GetS4UPac,
                (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value,
                ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
                    ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0)),    // only insert for non-referrals
                &OldServiceTicketInfo,
                OldServerKey,
                ARGUMENT_PRESENT(TicketEncryptionKey) ? TicketEncryptionKey : ServerKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    *Ticket = NewTicket;
    *OutputEncryptedTicket = EncryptedTicket;
    Ticket->encrypted_part.cipher_text.value = (PUCHAR) OutputEncryptedTicket;

Cleanup:
    //
    // Now free the original service ticket info (which was for the KDC) so
    // we can get it for the real service
    //

    FreeTicketInfo(
        &OldServiceTicketInfo
        );

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            &NewTicket
            );
    }
    KerbFreeString(
        &ServiceRealm
        );

    KerbFreeString(
        &ClientRealm
        );

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAdditionalTickets
//
//  Synopsis:   Unpacks the AdditionalTickets field of a KDC request
//              and (a) verifies that the ticket is TGT for this realm
//              and (b) the ticket is encrypted with the corret key and
//              (c) the ticket is valid
//
//  Effects:    allocate output ticket
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      there can only be one additional ticket
//
//
//--------------------------------------------------------------------------


KERBERR
KdcUnpackAdditionalTickets(
    IN PKERB_TICKET_LIST TicketList,
    OUT PKERB_ENCRYPTED_TICKET * AdditionalTicket
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    UNICODE_STRING ServerNames[3];
    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    PKERB_TICKET Ticket;
    KERB_REALM LocalRealm;
    KDC_TICKET_INFO KrbtgtTicketInfo = {0};

    //
    // Verify that there is a ticket & that there is only one ticket
    //

    //
    // TBD:  Make this work w/ S4U && U2U as there will be more than 1 ticket
    // at that point.  Evaluate options by lowest id first...
    // S4UToSelf (12) 
    //

    if ((TicketList == NULL) || (TicketList->next != NULL))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Trying to unpack null ticket or more than one ticket\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = SecData.GetKrbtgtTicketInfo(&KrbtgtTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Ticket = &TicketList->value;
    //
    // Verify the ticket, first with the normal password list
    //

    ServerNames[0] = *SecData.KdcFullServiceKdcName();
    ServerNames[1] = *SecData.KdcFullServiceDnsName();
    ServerNames[2] = *SecData.KdcFullServiceName();

    EncryptionKey = KerbGetKeyFromList(
                        KrbtgtTicketInfo.Passwords,
                        Ticket->encrypted_part.encryption_type
                        );
    if (EncryptionKey == NULL)
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    // NOTE: we only allow additional tickets from our realm. This
    // means cross-realm TGTs can't be used as additional tickets.
    //

    KerbErr = KerbVerifyTicket(
                Ticket,
                3,                              // 3 names
                ServerNames,
                SecData.KdcDnsRealmName(),
                EncryptionKey,
                &SkewTime,
                &EncryptedTicket
                );
    //
    // if it failed due to wrong password, try again with older password
    //

    if ((KerbErr == KRB_AP_ERR_MODIFIED) && (KrbtgtTicketInfo.OldPasswords != NULL))
    {
        EncryptionKey = KerbGetKeyFromList(
                            KrbtgtTicketInfo.OldPasswords,
                            Ticket->encrypted_part.encryption_type
                            );
        if (EncryptionKey == NULL)
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            goto Cleanup;
        }
        KerbErr = KerbVerifyTicket(
                    &TicketList->value,
                    2,                          // 2 names
                    ServerNames,
                    SecData.KdcDnsRealmName(),
                    EncryptionKey,
                    &SkewTime,
                    &EncryptedTicket
                    );

    }
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify additional ticket: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    LocalRealm = SecData.KdcKerbDnsRealmName();

    //
    // Verify the realm of the ticket
    //

    if (!KerbCompareRealmNames(
            &LocalRealm,
            &Ticket->realm
            ))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket realm is wrong: %s instead of %s\n",
                  KLIN(FILENO, __LINE__), Ticket->realm, LocalRealm));
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }

    //
    // Verify the realm of the client is the same as our realm
    //

    if (!KerbCompareRealmNames(
            &LocalRealm,
            &EncryptedTicket->client_realm
            ))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket client realm is wrong: %s instead of %s\n",
            KLIN(FILENO, __LINE__),EncryptedTicket->client_realm, LocalRealm));
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }

    *AdditionalTicket = EncryptedTicket;
    EncryptedTicket = NULL;

Cleanup:
    if (EncryptedTicket != NULL)
    {
        KerbFreeTicket(EncryptedTicket);
    }
    FreeTicketInfo(&KrbtgtTicketInfo);
    return(KerbErr);

}



//--------------------------------------------------------------------
//
//  Name:       KdcFindS4UClientAndRealm
//
//  Synopsis:   Decodes PA DATA to find PA_DATA_FOR_USER entry.
//
//  Effects:    Get a client name and realm for processing S4U request
//
//  Arguments:  PAList       - Preauth data list from TGS_REQ
//              ServerKey    - Key in authenticator, used to sign PA_DATA.
//              ClientRealm  - Target for client realm
//              ClientName   - Principal to get S4U ticket for
//                            
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/ 
//
//
//--------------------------------------------------------------------------
KERBERR
KdcFindS4UClientAndRealm(
    IN      PKERB_PA_DATA_LIST PaList,
    IN OUT  PUNICODE_STRING ClientRealm,
    IN OUT  PKERB_INTERNAL_NAME * ClientName
    )
{

    KERBERR Kerberr = KRB_ERR_GENERIC;
    PKERB_PA_DATA PaData = NULL;
    PKERB_PA_FOR_USER S4URequest = NULL;

    *ClientName = NULL;
    RtlInitUnicodeString(
        ClientRealm, 
        NULL
        );


    PaData = KerbFindPreAuthDataEntry(
                KRB5_PADATA_S4U,
                PaList
                );

    if (NULL == PaData)
    {
        DebugLog((DEB_ERROR, "No S4U pa data \n"));
        Kerberr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }
    
    Kerberr = KerbUnpackData(
                    PaData->preauth_data.value,
                    PaData->preauth_data.length,
                    KERB_PA_FOR_USER_PDU,
                    (PVOID* ) &S4URequest
                    );


    if (!KERB_SUCCESS(Kerberr))
    {
        DebugLog((DEB_ERROR, "Failed to unpack PA_FOR_USER\n"));
        goto Cleanup;
    }


    Kerberr = KerbConvertRealmToUnicodeString(
                    ClientRealm,
                    &S4URequest->client_realm
                    );

    if (!KERB_SUCCESS(Kerberr))
    {
        goto Cleanup;
    }


    Kerberr = KerbConvertPrincipalNameToKdcName(
                    ClientName,
                    &S4URequest->client_name
                    );

    if (!KERB_SUCCESS(Kerberr))
    {
        goto Cleanup;
    }


Cleanup:


    if (S4URequest != NULL)
    {         
        KerbFreeData(
            KERB_PA_FOR_USER_PDU,
            S4URequest
            );

    }

    return Kerberr;

}




//--------------------------------------------------------------------
//
//  Name:       HandleTGSRequest
//
//  Synopsis:   Gets a ticket using a KDC ticket (TGT).
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  ClientAddress - Optionally contains client IP address
//              RequestMessage - contains the TGS request message
//              RequestRealm - The realm of the request, from the request
//                      message
//              OutputMessage - Contains the buffer to send back to the client
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
HandleTGSRequest(
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN PKERB_TGS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    KDC_TICKET_INFO ServerTicketInfo = {0};
    KDC_TICKET_INFO TgtTicketInfo = {0};

    KERB_TICKET SourceTicket = {0};
    KERB_TICKET NewTicket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_ENCRYPTED_TICKET AdditionalTicket = NULL;

    PKERB_KDC_REQUEST_BODY RequestBody = &RequestMessage->request_body;
    KERB_TGS_REPLY Reply = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    PKERB_AP_REQUEST UnmarshalledApRequest = NULL;
    PKERB_AUTHENTICATOR UnmarshalledAuthenticator = NULL;
    PKERB_PA_DATA ApRequest = NULL;
    PKERB_PA_DATA_LIST ReplyPaData = NULL;
    KERB_ENCRYPTION_KEY ReplyKey = {0};
    PKERB_ENCRYPTION_KEY ServerKey;

    PKERB_INTERNAL_NAME ServerName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_INTERNAL_NAME S4UClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING ServerStringName = {0};
    UNICODE_STRING S4UClientRealm = {0};
    PUNICODE_STRING S4URealm = NULL;


    ULONG CommonEType;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;

    BOOLEAN Validating = FALSE;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN Renew = FALSE;
    BOOLEAN CheckAdditionalTicketMatch = FALSE;

    KDC_TGS_EVENT_INFO TGSEventTraceInfo = {0};

    TRACE(KDC, HandleTGSRequest, DEB_FUNCTION);

    //
    // Initialize [out] structures, so if we terminate early, they can
    // be correctly marshalled by the stub
    //

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;


    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Start event tracing
    //

    if (KdcEventTraceFlag){

        TGSEventTraceInfo.EventTrace.Guid = KdcHandleTGSRequestGuid;
        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        TGSEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        TGSEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
            );
    }

    //
    // Check for additional tickets
    //

    if ((RequestBody->bit_mask & additional_tickets_present) != 0)
    {
        //
        // The ticket must be unpacked with the krbtgt key
        //

        KerbErr = KdcUnpackAdditionalTickets(
                    RequestBody->additional_tickets,
                    &AdditionalTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack additional tickets: 0x%x\n",
                      KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }
    }

    //
    // Make sure that if there is a ticket, then enc_tkt_in_skey is set and
    // if not, then it isn't set
    //

    //
    // TBD: S4UToProxy (E)  Ok to have additional ticket if 
    // CNAME-IN-ADDL-TKT set.
    //
    
    if ((((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0) ^
        (AdditionalTicket != NULL)))
    {

        // tbd:  more logic for determining if multiple addl tickets are "bad option"

        D_DebugLog((DEB_ERROR,"KLIN(%x) Client didn't match enc_tkt_in_skey with additional tickts : %d vs %d\n",
                  KLIN(FILENO, __LINE__),((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0),
                  (AdditionalTicket != NULL)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Pass data to next level, w/ flag
    //


    // TBD: S4UToProxy (D)
    // Forwardable flag must be set in the service ticket
    // Check our options, that the additional ticket has bit set.
    // This additional service ticket must have the fwdable flag set,
    // and must validate correctly.
    //
    // We'll need to crack the server key, and the ticket, as validation of 
    // identity.
    //




    //
    // The server name is optional.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the at the server name is the same as the client name
        // from the addional ticket by getting the ticket info for supplied
        // TGT for the server. Later on we will compare it against the real
        // ticket info.
        //

        
        if (AdditionalTicket != NULL)
        {
            PKERB_INTERNAL_NAME TgtClientName = NULL;
            UNICODE_STRING TgtRealmName = {0};
            UNICODE_STRING CrackedRealm = {0};
            BOOLEAN Referral = FALSE;

            KerbErr = KerbConvertPrincipalNameToKdcName(
                        &TgtClientName,
                        &AdditionalTicket->client_name
                        );
            if (KERB_SUCCESS(KerbErr))
            {

                KerbErr = KerbConvertRealmToUnicodeString(
                            &TgtRealmName,
                            &AdditionalTicket->client_realm
                            );
                if (KERB_SUCCESS(KerbErr))
                {

                    // TBD:  make sure normalize takes into account
                    // deleg restrictions, but not here, for god' sake.
                    // .
                    KerbErr = KdcNormalize(
                                TgtClientName,
                                &TgtRealmName,
                                &TgtRealmName,
                                KDC_NAME_CLIENT | KDC_NAME_INBOUND,
                                &Referral,
                                &CrackedRealm,
                                &TgtTicketInfo,
                                pExtendedError,
                                NULL,           // no user handle
                                0L,             // no fields to fetch
                                0L,             // no extended fields
                                NULL,           // no user all
                                NULL            // no group membership
                                );
                    if (KERB_SUCCESS(KerbErr))
                    {
                        KerbFreeString(&CrackedRealm);
                        if (Referral)
                        {
                            KerbErr = KRB_AP_ERR_BADMATCH;
                        }
                        else
                        {
                            CheckAdditionalTicketMatch = FALSE;
                        }
                    }

                    KerbFreeString(&TgtRealmName);
                }
                KerbFreeKdcName(&TgtClientName);
            }
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize client name from supplied ticket\n",
                          KLIN(FILENO, __LINE__)));
                goto Cleanup;
            }
        }
    }
    else
    {
        //
        // There must be an additional ticket.
        //

        if (AdditionalTicket == NULL)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &AdditionalTicket->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }


    //
    // Convert the server name to a string for auditing.
    //

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "GetTGSTicket called. Service=" ));
    D_KerbPrintKdcName(DEB_TRACE, ServerName );

    //
    // The TGS and authenticator are in an AP request in the pre-auth data.
    // Find it and decode the AP request now.
    //

    if ((RequestMessage->bit_mask & KERB_KDC_REQUEST_preauth_data_present) == 0)
    {
        D_DebugLog((DEB_ERROR,
                  "KLIN(%x) No pre-auth data in TGS request - not allowed.\n", 
                  KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Get the TGT from the PA data.
    //

    ApRequest = KerbFindPreAuthDataEntry(
                    KRB5_PADATA_TGS_REQ,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data
                    );
    if (ApRequest == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        FILL_EXT_ERROR(pExtendedError, STATUS_NO_PA_DATA, FILENO, __LINE__);
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Verify the request. This includes decoding the AP request,
    // finding the appropriate key to decrypt the ticket, and checking
    // the ticket.
    //

    KerbErr = KdcVerifyKdcRequest(
                ApRequest->preauth_data.value,
                ApRequest->preauth_data.length,
                ClientAddress,
                TRUE,                           // this is a kdc request
                &UnmarshalledApRequest,
                &UnmarshalledAuthenticator,
                &SourceEncryptPart,
                &ReplyKey,
                NULL,                           // no ticket key
                &ServerTicketInfo,
                &UseSubKey,
                pExtendedError
                );
    //
    // If you want to validate a ticket, then it's OK if it isn't
    // currently valid.
    //

    if (KerbErr == KRB_AP_ERR_TKT_NYV && (KdcOptions & KERB_KDC_OPTIONS_validate))
    {
        D_DebugLog((DEB_TRACE,"Validating a not-yet-valid ticket\n"));
        KerbErr = KDC_ERR_NONE;
    }
    else if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        //
        // Bug 276943: When the authenticator is encrypted with something other
        //             than the session key, KRB_AP_ERR_BAD_INTEGRITY must be
        //             returned per RFC 1510
        //
        D_DebugLog((DEB_TRACE,"Could not decrypt the ticket\n"));
        KerbErr = KRB_AP_ERR_BAD_INTEGRITY;
    }

    //
    // Verify the checksum on the ticket, if present
    //

    if ( KERB_SUCCESS(KerbErr) &&
        (UnmarshalledAuthenticator != NULL) &&
        (UnmarshalledAuthenticator->bit_mask & checksum_present) != 0)
    {
        KerbErr = KdcVerifyTgsChecksum(
                    &RequestMessage->request_body,
                    &ReplyKey,
                    &UnmarshalledAuthenticator->checksum
                    );

    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify TGS request: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }



    //
    // Now that we've validated the request,
    // Check to see if the cname in padata bit is set, and
    // we have the KDC option set.
    //
    
    if ((KdcOptions & KERB_KDC_OPTIONS_cname_in_pa_data) != 0)
    {         
        KerbErr = KdcFindS4UClientAndRealm(
                        RequestMessage->KERB_KDC_REQUEST_preauth_data,
                        &S4UClientRealm,
                        &S4UClientName
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "KdcFindS4UClientAndRealm failed\n"));
            FILL_EXT_ERROR(pExtendedError, STATUS_NO_PA_DATA, FILENO, __LINE__);
            goto Cleanup;
        }     
                      
        S4URealm = &S4UClientRealm;
    }
    
    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ClientName,
                &SourceEncryptPart->client_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                &ClientStringName,
                ClientName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // And the realm
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                &ClientRealm,
                &SourceEncryptPart->client_realm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // If the client is in this domain and if we are supposed to
    // verify the client's account is still good,
    // do it now.
    //

    if ((SecData.KdcFlags() & AUTH_REQ_VALIDATE_CLIENT) != 0)
    {
        LARGE_INTEGER AuthTime;
        LARGE_INTEGER CurrentTime;

        NtQuerySystemTime(&CurrentTime);
        KerbConvertGeneralizedTimeToLargeInt(
            &AuthTime,
            &SourceEncryptPart->authtime,
            0
            );

        //
        // Only check if we haven't checked recently
        //

        if ((CurrentTime.QuadPart > AuthTime.QuadPart) &&
            ((CurrentTime.QuadPart - AuthTime.QuadPart) > SecData.KdcRestrictionLifetime().QuadPart))
        {

            KerbErr = KdcCheckTgsLogonRestrictions(
                        ClientName,
                        &ClientRealm,
                        pExtendedError
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_WARN, "KLIN(%x) Client failed TGS logon restrictions: 0x%x : ",
                          KLIN(FILENO, __LINE__),KerbErr));
                KerbPrintKdcName(DEB_WARN, ClientName);
                goto Cleanup;
            }
        }

    }

    //
    // Build a ticket struture to pass to the worker functions
    //

    SourceTicket = UnmarshalledApRequest->ticket;
    SourceTicket.encrypted_part.cipher_text.value = (PUCHAR) SourceEncryptPart;


    //
    // Build the new ticket
    //
    D_DebugLog((DEB_TRACE, "Handle TGS request: Client = %wZ,\n ",&ClientRealm));
    D_KerbPrintKdcName(DEB_TRACE, ClientName);
    D_DebugLog((DEB_TRACE, "\t ServerName = \n"));
    D_KerbPrintKdcName(DEB_TRACE, ServerName);

    //
    // Pass off the work to the worker routines
    //


    if (KdcOptions & KERB_KDC_OPTIONS_renew)
    {
        D_DebugLog((DEB_T_KDC,"Renewing ticket ticket\n"));

        Renew = TRUE;
        KerbErr = I_RenewTicket(
                    &SourceTicket,
                    ServerName,
                    &ServerTicketInfo,
                    RequestBody,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );
    }
    else if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        D_DebugLog((DEB_T_KDC,"Validating ticket\n"));

        KerbErr = I_Validate(
                    &SourceTicket,
                    ServerName,
                    &ClientRealm,
                    RequestBody,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        Validating = TRUE;

    }
    else
    {
        D_DebugLog((DEB_T_KDC,"Getting TGS ticket\n"));


        KerbErr = I_GetTGSTicket(
                    &SourceTicket,
                    ServerName,
                    RequestRealm,
                    RequestBody,
                    &ServerTicketInfo,
                    AdditionalTicket != NULL ? &AdditionalTicket->key : NULL,
                    S4UClientName,
                    S4URealm,
                    &CommonEType,
                    &NewTicket,
                    &ReplyPaData,
                    pExtendedError
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) TGS ticket worker failed: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    DsysAssert(ServerTicketInfo.Passwords != NULL);

    //
    // Check to see if the additional ticket supplied is the one for this
    // server, if necessary
    //

    if (CheckAdditionalTicketMatch )
    {
        if (ServerTicketInfo.UserId != TgtTicketInfo.UserId)
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Supplied ticket is not for server: %wZ vs. %wZ\n",
                      KLIN(FILENO, __LINE__),&TgtTicketInfo.AccountName, 
                      &ServerTicketInfo.AccountName ));
            KerbErr = KRB_AP_ERR_BADMATCH;
            goto Cleanup;
        }
    }

    //
    // Determine the keys to encrypt the ticket with.  (The key to encrypt the
    // reply with was determined by CheckTicket.)
    
    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) &&
        (AdditionalTicket != NULL))
    {
        
        //
        // Use the session key from the tgt
        //
        
        ServerKey = &AdditionalTicket->key;
        
    } else {
        
        ServerKey = KerbGetKeyFromList(
            ServerTicketInfo.Passwords,
            CommonEType
            );
        
        DsysAssert(ServerKey != NULL);
        
        if (ServerKey == NULL)
        {
            D_DebugLog((DEB_ERROR,
                      "KLIN(%x) BADERROR: cannot find server key while validating\n",
                      KLIN(FILENO, __LINE__)));
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            goto Cleanup;
        }
        
    } 


    KerbErr = BuildReply(
                NULL,
                RequestBody->nonce,
                &NewTicket.server_name,
                NewTicket.realm,
                ((EncryptedTicket.bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0) ?
                    EncryptedTicket.KERB_ENCRYPTED_TICKET_client_addresses : NULL,
                &NewTicket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Put in any PA data for the reply
    //

    if (ReplyPaData != NULL)
    {
        ReplyBody.encrypted_pa_data = (struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s *) ReplyPaData;
        ReplyBody.bit_mask |= encrypted_pa_data_present;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    Reply.client_realm = SourceEncryptPart->client_realm;
    Reply.client_name = SourceEncryptPart->client_name;



    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &NewTicket,
                ServerKey,
                CommonEType,
                &Reply.ticket
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Copy in the encrypted part
    //

    KerbErr = KerbPackKdcReplyBody(
                &ReplyBody,
                &ReplyKey,
                ReplyKey.keytype,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                &Reply.encrypted_part
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x)Failed to pack KDC reply body: 0x%x\n",
                KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Now build the real reply message
    //


    KerbErr = KerbPackData(
                &Reply,
                KERB_TGS_REPLY_PDU,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Audit the successful ticket generation
    //

    if (SecData.AuditKdcEvent(KDC_AUDIT_TGS_SUCCESS))
    {
        BYTE ServerSid[MAX_SID_LEN];
        GUID LogonGuid;
        NTSTATUS Status = STATUS_SUCCESS;
        PKERB_TIME pStartTime;

        pStartTime =
            &(((PKERB_ENCRYPTED_TICKET) NewTicket.encrypted_part.cipher_text.value)->KERB_ENCRYPTED_TICKET_starttime);
        
        
        Status = LsaIGetLogonGuid(
                     &ClientStringName,
                     &ClientRealm,
                     (PBYTE) pStartTime,
                     sizeof(KERB_TIME),
                     &LogonGuid
                     );
        ASSERT(NT_SUCCESS( Status ));
        
        KdcMakeAccountSid(ServerSid, ServerTicketInfo.UserId);
        KdcLsaIAuditKdcEvent(
            Renew ? SE_AUDITID_TICKET_RENEW_SUCCESS : SE_AUDITID_TGS_TICKET_REQUEST,
            &ClientStringName,
            &ClientRealm,
            NULL,                               // no client SID
            &ServerTicketInfo.AccountName,
            ServerSid,
            (PULONG) &KdcOptions,
            NULL,                               // success
            &CommonEType,
            NULL,                               // no preauth type
            GET_CLIENT_ADDRESS(ClientAddress),
            &LogonGuid
            );
    }


Cleanup:

    //
    // Complete the event
    //

    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                             WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        TGSEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        TGSEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        TGSEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings.
        // If data is unavailable then output a NULL string

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;

        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;

        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ClientRealm.Buffer != NULL &&
            ClientRealm.Length > 0)
        {
            pStringToCopy = &ClientRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[6].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
             KdcTraceLoggerHandle,
             (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
             );
    }

    //
    // Audit *most* failures (see bug 37126)
    //

    if (!KERB_SUCCESS(KerbErr) &&
        SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
    {
       // it is not uncommon to hit this error when 
       // clients attempt to get a ticket outside of their
       // realm...
       if (KerbErr != KDC_ERR_S_PRINCIPAL_UNKNOWN && SecData.IsOurRealm(RequestRealm))
       {
          KdcLsaIAuditKdcEvent(
             SE_AUDITID_TGS_TICKET_REQUEST,
             (ClientStringName.Buffer != NULL) ? &ClientStringName : &KdcNullString,      
             &ClientRealm,                       // no domain name
             NULL,
             &ServerStringName,
             NULL,
             &KdcOptions,
             (PULONG) &KerbErr,
             NULL,                               // no etype
             NULL,                               // no preauth type
             GET_CLIENT_ADDRESS(ClientAddress),
             NULL                                // no logon guid
          );
       }

    }

    KerbFreeKdcName(
        &ClientName
        );
    KerbFreeString(
        &ClientRealm
        );

    KerbFreeKdcName(
        &S4UClientName
        );

    KerbFreeString(
        &S4UClientRealm
        );

    KerbFreeKdcName(
        &ServerName
        );
    KerbFreeKey(
        &ReplyKey
        );

    KdcFreeKdcReplyBody(
        &ReplyBody
        );
    KerbFreeString(
        &ClientStringName
        );
    KerbFreeString(
        &ServerStringName
        );

    //
    // If we are validating the ticket key is in the serverticketinfo
    //
    if (AdditionalTicket != NULL)
    {
        KerbFreeTicket(AdditionalTicket);
    }

    if (ReplyPaData != NULL)
    {
        KerbFreePreAuthData(ReplyPaData);
    }

    KerbFreeApRequest(UnmarshalledApRequest);
    KerbFreeAuthenticator(UnmarshalledAuthenticator);
    KerbFreeTicket(SourceEncryptPart);

    KdcFreeInternalTicket(&NewTicket);
    FreeTicketInfo(&ServerTicketInfo);
    FreeTicketInfo(&TgtTicketInfo);

    KdcFreeKdcReply(
        &Reply
        );

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\kdcdbg_s_stub.c ===
#include "kdcdbg_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\kpasswd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       kpasswd.cxx
//
//  Contents:   Functions for the kpasswd protocol
//
//  History:    30-Sep-97   MikeSw      Created
//
//----------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "kpasswd.h"
#include "kdctrace.h"
extern "C"
{
#include <nlrepl.h>
}

#define FILENO FILENO_KPASSWD

//+-------------------------------------------------------------------------
//
//  Function:   KdcbMarshallApReply
//
//  Synopsis:   Takes a reply and reply body and encrypts and marshalls them
//              into a return message
//
//  Effects:    Allocates output buffer
//
//  Arguments:  Reply - The outer reply to marshall
//              ReplyBody - The reply body to marshall
//              EncryptionType - Encryption algorithm to use
//              SessionKey - Session key to encrypt reply
//              PackedReply - Recives marshalled reply buffer
//              PackedReplySize - Receives size in bytes of marshalled reply
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcMarshallApReply(
    IN PKERB_AP_REPLY Reply,
    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody,
    IN ULONG EncryptionType,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    OUT PUCHAR * PackedReply,
    OUT PULONG PackedReplySize
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG PackedApReplySize;
    PUCHAR PackedApReply = NULL;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    ULONG ReplySize;

    KerbErr = KerbPackApReplyBody(
                ReplyBody,
                &PackedApReplySize,
                &PackedApReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the response
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                EncryptionType,
                PackedApReplySize,
                &Reply->encrypted_part.cipher_text.length,
                &Reply->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }



    KerbErr = KerbEncryptDataEx(
                        &Reply->encrypted_part,
                        PackedApReplySize,
                        PackedApReply,
                        EncryptionType,
                        KERB_AP_REP_SALT,
                        SessionKey
                        );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to encrypt AP Reply.%d\n", KerbErr));
        goto Cleanup;
    }

    //
    // Now pack the reply into the output buffer
    //

    KerbErr = KerbPackApReply(
                        Reply,
                        PackedReplySize,
                        PackedReply
                        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:
    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
        Reply->encrypted_part.cipher_text.value = NULL;
    }
    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildKpasswdResponse
//
//  Synopsis:   builds the response to a kpasswd request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildKpasswdResponse(
    IN OPTIONAL PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN OPTIONAL PKERB_AUTHENTICATOR Authenticator,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN NTSTATUS ChangeResult,
    IN KERBERR ProtocolResult,
    IN PKERB_EXT_ERROR pExtendedError,
    OUT PKERB_MESSAGE_BUFFER Response
    )
{
    KERB_PRIV_MESSAGE PrivMessage = {0};
    KERB_ENCRYPTED_PRIV PrivBody = {0};
    USHORT ReplySize = 0;
    PBYTE PackedApReply = NULL;
    ULONG PackedApReplySize = 0;
    BYTE ResultData[2] = {0};
    PBYTE PackedPrivBody = NULL;
    ULONG PackedPrivBodySize = 0;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    KERBERR KerbErr = KRB_ERR_GENERIC;
    PBYTE ReplyData = NULL;
    ULONG ReplyDataSize = 0;
    PSOCKET_ADDRESS IpAddresses = NULL;
    ULONG AddressCount = 0;
    BOOLEAN ReturningError = TRUE;

    if (!NT_SUCCESS(ChangeResult))
    {
        switch(ChangeResult)
        {
        case STATUS_PASSWORD_RESTRICTION:
            SET_SHORT(ResultData,KERB_KPASSWD_POLICY);
            ProtocolResult = KDC_ERR_POLICY;
            break;
        case STATUS_ACCOUNT_RESTRICTION:
            SET_SHORT(ResultData, KERB_KPASSWD_AUTHENTICATION);
            ProtocolResult = KDC_ERR_CLIENT_REVOKED;
            break;
        case STATUS_INVALID_PARAMETER:
            SET_SHORT(ResultData, KERB_KPASSWD_MALFORMED);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        case STATUS_ACCESS_DENIED:
            SET_SHORT(ResultData, KERB_KPASSWD_AUTHORIZATION);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        default:
            SET_SHORT(ResultData, KERB_KPASSWD_ERROR);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        }
    }
    else if (!KERB_SUCCESS(ProtocolResult))
    {
        switch(ProtocolResult)
        {
        case KRB_ERR_GENERIC:
            //
            // BUG 453652: how does this distinguish between random hard errors
            // and malformed data?
            //
            SET_SHORT(ResultData, KERB_KPASSWD_MALFORMED);
            break;
        default:
            //
            // The other errors come from the call to verify the
            // AP request
            //

            SET_SHORT(ResultData, KERB_KPASSWD_AUTHENTICATION);
            break;
        }
    }

    //
    // Now build the AP reply, if possible.
    //

    if (ARGUMENT_PRESENT(EncryptedTicket))
    {
        NTSTATUS Status = STATUS_SUCCESS;
        KERB_AP_REPLY Reply = {0};
        KERB_ENCRYPTED_AP_REPLY ReplyBody = {0};


        Reply.version = KERBEROS_VERSION;
        Reply.message_type = KRB_AP_REP;



        ReplyBody.client_time = Authenticator->client_time;
        ReplyBody.client_usec = Authenticator->client_usec;


        KerbErr = KdcMarshallApReply(
                    &Reply,
                    &ReplyBody,
                    EncryptedTicket->key.keytype,
                    &EncryptedTicket->key,
                    &PackedApReply,
                    &PackedApReplySize
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        PrivBody.sender_address.addr_type = KERB_ADDRTYPE_INET;

        if (ARGUMENT_PRESENT(ServerAddress))
        {
            PrivBody.sender_address.address.length = 4;
            PrivBody.sender_address.address.value =
                        (PUCHAR) &((PSOCKADDR_IN)ServerAddress)->sin_addr.S_un.S_addr;

        }
        else
        {
            PrivBody.sender_address.address.length = 0;
            PrivBody.sender_address.address.value = NULL;
        }

        PrivBody.user_data.length = sizeof(ResultData);
        PrivBody.user_data.value = ResultData;

        KerbErr = KerbPackData(
                    &PrivBody,
                    KERB_ENCRYPTED_PRIV_PDU,
                    &PackedPrivBodySize,
                    &PackedPrivBody
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        //
        // Now encrypt it with the session key
        //


        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    SessionKey->keytype,
                    PackedPrivBodySize,
                    &PrivMessage.encrypted_part.cipher_text.length,
                    &PrivMessage.encrypted_part.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }


        KerbErr = KerbEncryptDataEx(
                    &PrivMessage.encrypted_part,
                    PackedPrivBodySize,
                    PackedPrivBody,
                    SessionKey->keytype,
                    KERB_PRIV_SALT,
                    SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        PrivMessage.version = KERBEROS_VERSION;
        PrivMessage.message_type = KRB_PRIV;

        //
        // Now pack the KERB_PRIV
        //

        KerbErr = KerbPackData(
                    &PrivMessage,
                    KERB_PRIV_MESSAGE_PDU,
                    &ReplyDataSize,
                    &ReplyData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }
        ReturningError = FALSE;
    }

BuildError:

    //
    // If we have an error of one of the three error codes, build the
    // appropriate result code & error code for the KERB_ERROR
    //

    if (!KERB_SUCCESS(KerbErr) || (ReplyData == NULL))
    {
        UNICODE_STRING TempString;
        RtlInitUnicodeString(
            &TempString,
            KERB_KPASSWD_NAME
            );

        KerbErr = KerbBuildErrorMessageEx(
                    ProtocolResult,
                    pExtendedError, // note:  probably won't get used
                    SecData.KdcDnsRealmName(),
                    SecData.KpasswdInternalName(),
                    NULL,               // no client realm,
                    ResultData,
                    sizeof(ResultData),
                    &ReplyDataSize,
                    &ReplyData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Now, if we have an AP reply, build a kpasswd response. Otherwise
    // return the kerb_error message
    //

    if (ReturningError)
    {
        Response->Buffer = ReplyData;
        ReplyData = NULL;
        Response->BufferSize = ReplyDataSize;
        goto Cleanup;
    }
    else
    {
        USHORT TempShort;
        PKERB_KPASSWD_REP Reply = NULL;
        if ((FIELD_OFFSET(KERB_KPASSWD_REP,Data) +
                    PackedApReplySize +
                    ReplyDataSize) > SHRT_MAX)
        {
            D_DebugLog((DEB_ERROR,"Kpasswd reply too long!\n"));
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto Cleanup;
        }
        ReplySize = (USHORT) (FIELD_OFFSET(KERB_KPASSWD_REP,Data) +
                                PackedApReplySize +
                                ReplyDataSize);

        Reply = (PKERB_KPASSWD_REP) MIDL_user_allocate(ReplySize);

        if (Reply == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        SET_SHORT(Reply->MessageLength,ReplySize);
        SET_SHORT(Reply->Version, KERB_KPASSWD_VERSION);
        SET_SHORT(Reply->ApRepLength, (USHORT) PackedApReplySize);
        RtlCopyMemory(
            Reply->Data,
            PackedApReply,
            PackedApReplySize
            );
        RtlCopyMemory(
            Reply->Data + PackedApReplySize,
            ReplyData,
            ReplyDataSize
            );
        Response->Buffer = (PBYTE) Reply;
        Response->BufferSize = ReplySize;
    }

Cleanup:

    if (IpAddresses != NULL)
    {
        I_NetLogonFree(IpAddresses);
    }

    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }
    if (PackedPrivBody !=NULL)
    {
        MIDL_user_free(PackedPrivBody);
    }
    if (ReplyData != NULL)
    {
        MIDL_user_free(ReplyData);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcChangePassword
//
//  Synopsis:   receives a kerb-change-password buffer and attempts the
//              password change
//
//  Effects:
//
//  Arguments:  Context - ATQ context, used for requesting more data if the
//                      buffer isn't complete
//              ClientAddress - Address of client, from the socket
//              ServerAddress - address client used to contact this server.
//              InputMessage - Receives data sent by client
//              OutputMessage - Contains data to be sent to client & freed
//                      using KdcFreeEncodedData
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


extern "C"
KERBERR
KdcChangePassword(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    PKERB_KPASSWD_REQ Request = NULL;
    PKERB_KPASSWD_REP Reply = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError;
    USHORT ProtocolVersion;
    USHORT MessageLength;
    USHORT ApReqLength;
    ULONG PrivLength;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    KERB_ENCRYPTION_KEY SessionKey = {0};
    KERB_ENCRYPTION_KEY ServerKey = {0};
    KDC_TICKET_INFO ServerTicketInfo = {0};
    KDC_TICKET_INFO ClientTicketInfo = {0};
    UNICODE_STRING Password = {0};
    ANSI_STRING AnsiPassword = {0};
    PKERB_PRIV_MESSAGE PrivMessage = NULL;
    PKERB_ENCRYPTED_PRIV PrivBody = NULL;
    BOOLEAN UseSubKey = FALSE;
    ULONG TicketFlags;
    BOOLEAN DoPasswordSet = FALSE;
    PKERB_CHANGE_PASSWORD_DATA ChangeData = NULL;

    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ReferralRealm = {0};
    BOOLEAN ClientReferral = FALSE;
    HANDLE TokenHandle = NULL;
    PSID UserSid = NULL;
    ULONG UserRid = 0;

    SAM_CLIENT_INFO SamClientInfoBuffer;
    PSAM_CLIENT_INFO SamClientInfo = NULL;

    KDC_CHANGEPASS_INFO ChangePassTraceInfo;
    if( KdcEventTraceFlag ) // Event Trace: KerbChangePasswordStart {No Data}
    {
        ChangePassTraceInfo.EventTrace.Guid       = KdcChangePassGuid;
        ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

        TraceEvent( KdcTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (InputMessage->BufferSize < sizeof(KERB_KPASSWD_REQ))
    {
        D_DebugLog((DEB_ERROR,"Bad message size to KdcChangePassword: %d\n",InputMessage->BufferSize));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    Request = (PKERB_KPASSWD_REQ) InputMessage->Buffer;
    //
    // Verify the length & protocol version
    //

    GET_SHORT(MessageLength, Request->MessageLength);
    GET_SHORT(ProtocolVersion, Request->Version);

    if (ProtocolVersion == KERB_KPASSWD_SET_VERSION)
    {
        //
        // This is the advanced protocol
        //

        DoPasswordSet = TRUE;
    }
    else if (ProtocolVersion != KERB_KPASSWD_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Bad version passed to KdcChangePassword: %d\n",
            ProtocolVersion ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    if ((ULONG)MessageLength != InputMessage->BufferSize)
    {
        D_DebugLog((DEB_ERROR,"Bad length passed to KdcChangePassword: %d instead of %d\n",
            MessageLength, InputMessage->BufferSize ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    //
    // Unpack the AP request
    //

    GET_SHORT(ApReqLength, Request->ApReqLength);

    if (FIELD_OFFSET(KERB_KPASSWD_REQ, ApReqLength) + ApReqLength > MessageLength)
    {
        D_DebugLog((DEB_ERROR,"ApReqLength in kpasswd request bad: %d\n",ApReqLength));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    //
    // Verify the AP request
    //

    KerbErr = KdcVerifyKdcRequest(
                Request->Data,
                ApReqLength,
                ClientAddress,
                FALSE,                  // this is not a kdc request
                NULL,
                &Authenticator,
                &EncryptedTicket,
                &SessionKey,
                &ServerKey,
                &ServerTicketInfo,
                &UseSubKey,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        if (KerbErr == KDC_ERR_NO_RESPONSE)
        {
            goto NoMsgResponse;
        }

        DebugLog((DEB_WARN,"Failed to unpack AP req in kpasswd request: 0x%x\n",
            KerbErr ));
        goto Cleanup;
    }

    //
    // The spec says the client has to ask for a sub key.
    //

    if (!UseSubKey)
    {
        D_DebugLog((DEB_ERROR,"The client of kpasswd did not ask for a sub key.\n"));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // The name of the principal must be correct.
    //
    // WAS BUG: check by RID
    //

    if (ServerTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT)
    {
        D_DebugLog((DEB_ERROR,"Wrong principal for kpasswd: %wZ\n",
            &ServerTicketInfo.AccountName ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Now try to unpack the KERB_PRIV
    //

    PrivLength = MessageLength - (ApReqLength + FIELD_OFFSET(KERB_KPASSWD_REQ, Data));
    KerbErr = KerbUnpackData(
                Request->Data + ApReqLength,
                PrivLength,
                KERB_PRIV_MESSAGE_PDU,
                (PVOID *) &PrivMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode priv message in kpasswd req: 0x%x\n",KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Now decrypt the KERB_PRIV message
    //

    if (PrivMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Bad version in kpasswd priv message: %d\n",
            PrivMessage->version ));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }

    if (PrivMessage->message_type != KRB_PRIV)
    {
        D_DebugLog((DEB_ERROR,"Bad message type in kpasswd priv message: %d\n",
            PrivMessage->message_type ));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }



    KerbErr = KerbDecryptDataEx(
                &PrivMessage->encrypted_part,
                &SessionKey,
                KERB_PRIV_SALT,
                (PULONG) &PrivMessage->encrypted_part.cipher_text.length,
                PrivMessage->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt priv message from kpasswd: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

    //
    // Now decode the kerb priv body
    //

    KerbErr = KerbUnpackData(
                PrivMessage->encrypted_part.cipher_text.value,
                (ULONG) PrivMessage->encrypted_part.cipher_text.length,
                KERB_ENCRYPTED_PRIV_PDU,
                (PVOID *) &PrivBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack priv body from kpasswd: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

    //
    // Verify the client's address
    //

    if (ARGUMENT_PRESENT(ClientAddress))
    {
        KERB_HOST_ADDRESSES Addresses;
        //
        // Build a host_addresses structure because the caller sent a single
        // address.
        //

        Addresses.next = NULL;
        Addresses.value.address_type = PrivBody->sender_address.addr_type;
        Addresses.value.address.value = PrivBody->sender_address.address.value;
        Addresses.value.address.length = PrivBody->sender_address.address.length;

        KerbErr = KdcVerifyClientAddress(
                    ClientAddress,
                    &Addresses
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"Client sent kpasswd request with wrong address\n"));
            goto Cleanup;
        }
    }

    //
    // Now, we should have a password
    //

    if (DoPasswordSet)
    {
        //
        // Unpack the chaneg password data in the priv body.
        //

        KerbErr = KerbUnpackData(
                    PrivBody->user_data.value,
                    PrivBody->user_data.length,
                    KERB_CHANGE_PASSWORD_DATA_PDU,
                    (PVOID *) &ChangeData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"Failed to unpack password change data from kpasswd: 0x%x\n",
                KerbErr));
            goto Cleanup;
        }

        if (ChangeData->new_password.length > SHRT_MAX / 2)
        {
            D_DebugLog((DEB_ERROR,"Password length too long: %d\n",
                ChangeData->new_password.length ));
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto Cleanup;
        }
        AnsiPassword.Length = (USHORT)ChangeData->new_password.length;
        AnsiPassword.MaximumLength = AnsiPassword.Length;
        AnsiPassword.Buffer = (PCHAR) ChangeData->new_password.value;

        KerbErr = KerbStringToUnicodeString(
                    &Password,
                    &AnsiPassword
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // if the target name and realm aren't present, this is a
        // change password
        //

        if ((ChangeData->bit_mask & (target_name_present | target_realm_present)) !=
                (target_name_present | target_realm_present))
        {
            DoPasswordSet = FALSE;
        }
        else
        {
            //
            // Get the names from the change data
            //

            KerbErr = KerbConvertPrincipalNameToKdcName(
                        &ClientName,
                        &ChangeData->target_name
                        );
            if (!NT_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &ClientRealm,
                        &ChangeData->target_realm
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

    }

    if (!DoPasswordSet)
    {
        //
        // The spec says the ticket must be an initial ticket for a
        // change.
        //

        TicketFlags = KerbConvertFlagsToUlong(&EncryptedTicket->flags);
        if ((TicketFlags & KERB_TICKET_FLAGS_initial) == 0)
        {
            D_DebugLog((DEB_ERROR,"Ticket to kpasswd was not initial\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // NOTE: verify other kerb-priv fields here
        // Current ID doesn't require other kerb priv fields, so
        // this is a no-op.  If things change, however, we'll need
        // to add code here.
        //
        //
        // If we didn't get a password from the change password data,
        // get it directly from the data
        //

        if (Password.Buffer == NULL)
        {

            //
            // The password has to fit in a unicode string, so it can't be longer
            // than half a ushort.
            //

            if (PrivBody->user_data.length > SHRT_MAX / 2)
            {
                D_DebugLog((DEB_ERROR,"Password length too long: %d\n",
                    PrivBody->user_data.length ));
                KerbErr = KRB_ERR_FIELD_TOOLONG;
                goto Cleanup;
            }
            AnsiPassword.Length = (USHORT)PrivBody->user_data.length;
            AnsiPassword.MaximumLength = AnsiPassword.Length;
            AnsiPassword.Buffer = (PCHAR) PrivBody->user_data.value;

            KerbErr = KerbStringToUnicodeString(
                        &Password,
                        &AnsiPassword
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

        }

        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &EncryptedTicket->client_name
                    );
        if (!NT_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertRealmToUnicodeString(
                    &ClientRealm,
                    &EncryptedTicket->client_realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Get the client ticket info so we can do a set pass
    //

    KerbErr = KdcNormalize(
                ClientName,
                NULL,
                &ClientRealm,
                KDC_NAME_CLIENT,
                &ClientReferral,
                &ReferralRealm,
                &ClientTicketInfo,
                pExtendedError,
                NULL,                   // no UserHandle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no fields to fetch
                NULL                    // no GroupMembership
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to normalize name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }


    {

        LUID LogonId = {0};
        UNICODE_STRING UClientName = {0};
        UNICODE_STRING UClientDomain = {0};

        Status = KerbCreateTokenFromTicket(
                    EncryptedTicket,
                    Authenticator,
                    0,                  // no flags
                    &ServerKey,
                    SecData.KdcDnsRealmName(),
                    &SessionKey,
                    &LogonId,
                    &UserSid,
                    &TokenHandle,
                    &UClientName,
                    &UClientDomain
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Setup the client info
        //
        if ( (ClientAddress == NULL)
          || (ClientAddress->sa_family == AF_INET) ) {
            // Set to local address (known to be 4 bytes) or IP address
            RtlZeroMemory(&SamClientInfoBuffer, sizeof(SamClientInfoBuffer));
            SamClientInfoBuffer.Type = SamClientIpAddr;
            SamClientInfoBuffer.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
            SamClientInfo = &SamClientInfoBuffer;
        }

        //
        // Free all the memory returned
        //
        KerbFree(UClientName.Buffer);
        KerbFree(UClientDomain.Buffer);
        KerbFree(UserSid);
        //
        // Store the password on the user's account
        //

        //
        //  We shouldn't enforce password policy restrictions if we do a password SET
        //

        if (!DoPasswordSet)
        {
           Status = SamIChangePasswordForeignUser2(
                     SamClientInfo,
                     &ClientTicketInfo.AccountName,
                     &Password,
                     TokenHandle,
                     USER_CHANGE_PASSWORD
                     );

        } else {

           Status = SamISetPasswordForeignUser2(
                        SamClientInfo,
                        &ClientTicketInfo.AccountName,
                        &Password,
                        TokenHandle
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to change password for user %wZ: 0x%x\n",
                &ClientTicketInfo.AccountName, Status ));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
    }


Cleanup:
    KerbErr = KdcBuildKpasswdResponse(
                EncryptedTicket,
                Authenticator,
                &SessionKey,
                ServerAddress,
                Status,
                KerbErr,
                pExtendedError,
                OutputMessage
                );

NoMsgResponse:



    if( KdcEventTraceFlag ) // Event Trace: KdcChangePasswordEnd {KerbErr, ExtErr, Klininfo, (ClientRealm), (AccountName)}
    {
        INSERT_ULONG_INTO_MOF( KerbErr, ChangePassTraceInfo.MofData, 0 );
        INSERT_ULONG_INTO_MOF( ExtendedError.status, ChangePassTraceInfo.MofData, 1 );
        INSERT_ULONG_INTO_MOF( ExtendedError.klininfo, ChangePassTraceInfo.MofData, 2 );

        // Protect against uninitialized UNICODE_STRINGs

        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};
        PUNICODE_STRING pClientRealmTraceString = &ClientRealm;
        PUNICODE_STRING pAccountNameTraceString = &ClientTicketInfo.AccountName;

        if( ClientRealm.Buffer == NULL || ClientRealm.Length <= 0 )
            pClientRealmTraceString = &UnicodeEmptyString;

        if( ClientTicketInfo.AccountName.Buffer == NULL || ClientTicketInfo.AccountName.Length <= 0 )
            pAccountNameTraceString = &UnicodeEmptyString;

        //

        INSERT_UNICODE_STRING_INTO_MOF( *pClientRealmTraceString, ChangePassTraceInfo.MofData, 3 );
        INSERT_UNICODE_STRING_INTO_MOF( *pAccountNameTraceString, ChangePassTraceInfo.MofData, 5 );

        ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER) + 7*sizeof(MOF_FIELD);

        ChangePassTraceInfo.EventTrace.Guid       = KdcChangePassGuid;
        ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent( KdcTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    KerbFreeKey( &SessionKey );
    KerbFreeKey( &ServerKey );
    KerbFreeTicket(EncryptedTicket);
    FreeTicketInfo(&ServerTicketInfo);
    FreeTicketInfo(&ClientTicketInfo);
    KerbFreeData(KERB_PRIV_MESSAGE_PDU, PrivMessage);
    KerbFreeData(KERB_ENCRYPTED_PRIV_PDU, PrivBody);
    KerbFreeData(KERB_CHANGE_PASSWORD_DATA_PDU, ChangeData);
    KerbFreeString(&Password);
    KerbFreeAuthenticator(Authenticator);

    KerbFreeKdcName(&ClientName);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&ReferralRealm);

    if (TokenHandle != NULL)
    {
        NtClose(TokenHandle);
    }

    LeaveApiCall();

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\kdctrace.h ===
#ifndef _KDCTRACE_H
#define _KDCTRACE_H
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kdctrace.h

Abstract:

    Include file to contain variables required for event tracing of kerberos
    server

Author:

    07-May-1998  JeePang

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C unsigned long    KdcEventTraceFlag;
EXTERN_C TRACEHANDLE      KdcTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      KdcTraceLoggerHandle;

EXTERN_C
ULONG
KdcInitializeTrace();

// The current limit is 8 MOF fields.
// Each UNICODE strings needs two MOF fields.
// The ClientRealm is available and should be added to the AS
// if the MOF field limit is increased

typedef struct _KDC_AS_EVENT_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    union {
        ULONG KdcOptions;
        MOF_FIELD eventInfo[7];
    };
} KDC_AS_EVENT_INFO, *PKDC_AS_EVENT_INFO;

// SID info is used in audit log, could be added to TGS event
// if MOF limited increased.

typedef struct _KDC_TGS_EVENT_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    union {
        ULONG KdcOptions;
        MOF_FIELD eventInfo[7];
    };
        
} KDC_TGS_EVENT_INFO, *PKDC_TGS_EVENT_INFO;

typedef struct _KDC_CHANGEPASS_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[7];
} KDC_CHANGEPASS_INFO, *PKDC_CHANGEPASSINFO;

#define KDC_TRACE_VERSION            1

// be careful with INSERT_ULONG_INTO_MOF; it evaluates its arguments more than once 
#define INSERT_ULONG_INTO_MOF( x, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&(x); \
	 (MOF)[(Start)].Length    = sizeof(ULONG);
	 
// be careful with INSERT_UNICODE_STRING_INTO_MOF; it evaluates its arguments more than once
#define INSERT_UNICODE_STRING_INTO_MOF( USTRING, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&((USTRING).Length); \
	 (MOF)[(Start)].Length    = sizeof      ((USTRING).Length); \
	 (MOF)[(Start)+1].DataPtr = (ULONGLONG)  (USTRING).Buffer;  \
	 (MOF)[(Start)+1].Length  =              (USTRING).Length;

//
// This is the control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 24db8964-e6bc-11d1-916a-0000f8045b04 */
    KdcControlGuid,
    0x24db8964,
    0xe6bc,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

//
// This is the Get AS Ticket transaction guid
//
DEFINE_GUID ( /* 50af5304-e6bc-11d1-916a-0000f8045b04 */
    KdcGetASTicketGuid,
    0x50af5304,
    0xe6bc,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

//
// This is the Handle TGS Request transaction guid
//
DEFINE_GUID ( /* c11cf384-e6bd-11d1-916a-0000f8045b04 */
    KdcHandleTGSRequestGuid,
    0xc11cf384,
    0xe6bd,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

DEFINE_GUID ( /* a34d7f52-1dd0-434e-88a1-423e2a199946 */
    KdcChangePassGuid,
    0xa34d7f52,
    0x1dd0,
    0x434e,
    0x88, 0xa1, 0x42, 0x3e, 0x2a, 0x19, 0x99, 0x46
  );


#endif /* _KDCTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\kdctrace.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kdctrace.c

Abstract:

    Include file to contain variables required for event tracing of kerberos
    server

Author:

    07-May-1998  JeePang

Revision History:

--*/

//
//
//
#include <kdcsvr.hxx>
#include <wmistr.h>
#define INITGUID
#include "kdctrace.h"
#include "debug.hxx"

#define RESOURCE_NAME       __TEXT("MofResource")
#define IMAGE_PATH          __TEXT("kdcsvc.dll")

unsigned long    KdcEventTraceFlag = FALSE;
TRACEHANDLE      KdcTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      KdcTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
KdcTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION KdcTraceGuids[] =
{
    { &KdcGetASTicketGuid, NULL },
    { &KdcHandleTGSRequestGuid, NULL },
    { &KdcChangePassGuid, NULL }
};

#define KdcGuidCount (sizeof(KdcTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
KdcInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                KdcTraceControlCallback,
                NULL,
                &KdcControlGuid,
                KdcGuidCount,
                KdcTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &KdcTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DebugLog((DEB_TRACE,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
KdcTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            KdcTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            KdcEventTraceFlag = 1;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            KdcEventTraceFlag = 0;
            RetSize = 0;
            KdcTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // KdcTraceControlCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\refer.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.h
//
// Contents:    Structurs and prototypes for interdomain referrals
//
//
// History:     26-Mar-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __REFER_H__
#define __REFER_H__

extern LIST_ENTRY KdcDomainList;
extern LIST_ENTRY KdcReferralCache;

//
// For NT5 domains in the enterprise the dns name will contain the
// real DNS name. For non- tree domains it will contain the name from
// the trusted domain object
//

#define KDC_DOMAIN_US           0x0001
#define KDC_DOMAIN_TREE_ROOT    0x0002
#define KDC_TRUST_INBOUND       0x0004

// cache flags
#define KDC_NO_ENTRY            0x0000
#define KDC_UNTRUSTED_REALM     0x0001
#define KDC_TRUSTED_REALM       0x0002

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target for this domain or NULL if unreachable
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
    PSID Sid;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;


typedef struct _REFERRAL_CACHE_ENTRY {
    LIST_ENTRY ListEntry;
    LONG References;
    TimeStamp EndTime;
    UNICODE_STRING RealmName;
    ULONG CacheFlags;
} REFERRAL_CACHE_ENTRY, *PREFERRAL_CACHE_ENTRY;


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    );

KERBERR
KdcCheckForCrossForestReferral(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    );


KERBERR
KdcFindReferralTarget(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN BOOLEAN InboundWanted
    );


KERBERR
KdcGetTicketInfoForDomain(
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    );

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

NTSTATUS
KdcBuildDomainTree(
    );

ULONG __stdcall
KdcReloadDomainTree(
    PVOID Dummy
    );

fLsaTrustChangeNotificationCallback KdcTrustChangeCallback;

VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    );

VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    );

VOID 
KdcLockDomainListFn(
   );

VOID 
KdcUnlockDomainListFn(
   );

#endif // __REFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\pkserv.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.cxx
//
// Contents:    Server side public key support for Kerberos
//
//
// History:     24-Nov-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
#include <cryptui.h>    // for CryptUiXXX
#include <certca.h>     // for CA*XXX

#define FILENO FILENO_PKSERV
//
// This is the cert store containing the CTL used to verify client certificates
//

HCERTSTORE KdcCertStore = NULL;
HCRYPTPROV KdcClientProvider = NULL;

PCCERT_CONTEXT GlobalKdcCert = NULL;
HANDLE   KdcCertStoreChangeEvent = NULL;
TimeStamp KdcLastChangeEventTime;

RTL_CRITICAL_SECTION KdcGlobalCertCritSect;
BOOLEAN              KdcGlobalCertCritSectInitialized = FALSE;

HANDLE KdcCertStoreWait = NULL;
BOOLEAN KdcPKIInitialized = FALSE;

BOOLEAN Kdc3DesSupported = TRUE;
HANDLE KdcCaNotificationHandle = NULL;
#define KDC_ROOT_STORE L"ROOT"
#define KDC_PRIVATE_MY_STORE L"MY"

#define MAX_TEMPLATE_NAME_VALUE_SIZE             80 // sizeof (CERT_NAME_VALUE) + wcslen(SmartcardLogon)

KERB_OBJECT_ID KdcSignatureAlg[10];


NTSTATUS
KdcGetKdcCertificate(PCCERT_CONTEXT *KdcCert);

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckCertificate
//
//  Synopsis:   a helper routine to verify the certificate. It will check
//              CRLs, CTLs
//
//  Effects:
//
//  Arguments:
//          CertContext - the certificate to check
//          EmbeddedUPNOk - returns TRUE if the certificate can
//                           be translated to a user by looking at the
//                           subject name.
//                           returns FALSE if the certificate must be
//                           mapped by looking in the user's mapped certificate
//                           ds attribute.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    OUT PBOOLEAN EmbeddedUPNOk,
    IN OUT PKERB_EXT_ERROR pExtendedError,
    IN OUT OPTIONAL PCERT_CHAIN_POLICY_STATUS FinalChainStatus,
    IN BOOLEAN KdcCert
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR Usage = (KdcCert ? KERB_PKINIT_KDC_CERT_TYPE : KERB_PKINIT_CLIENT_CERT_TYPE);
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;
    CERT_CHAIN_POLICY_STATUS PolicyStatus ={0};

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;

    *EmbeddedUPNOk = FALSE;
    

    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          CertContext,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
        goto Cleanup;

    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;


        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_NT_AUTH,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {  
           DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
           KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
           goto Cleanup;
        }

        if(PolicyStatus.dwError == S_OK)
        {
            *EmbeddedUPNOk = TRUE;
        }
        else if(CERT_E_UNTRUSTEDCA == PolicyStatus.dwError)
        {
            // We can't use this cert for fast-mapping, but we can still
            // slow-map it.
            *EmbeddedUPNOk = FALSE;
        }
        else
        {
            DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
            goto Cleanup;
        }
    }

Cleanup:
    if (PolicyStatus.dwError != S_OK)
    {
       FILL_EXT_ERROR_EX(pExtendedError, PolicyStatus.dwError,FILENO,__LINE__);
       if (ARGUMENT_PRESENT(FinalChainStatus))
       {
           RtlCopyMemory(
               FinalChainStatus,
               &PolicyStatus,
               sizeof(CERT_CHAIN_POLICY_STATUS)
               );
       }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientCertName
//
//  Synopsis:   Verifies that the mapping of a client's cert name matches
//              the mapping of the client name from the AS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientCertName(
    IN PCCERT_CONTEXT ClientCert,
    IN PKDC_TICKET_INFO ClientTicketInfo
    )
{
    ULONG NameLength = 0;
    UNICODE_STRING NameString = {0};
    UNICODE_STRING ClientRealm = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    KDC_TICKET_INFO TicketInfo = {0};
    BOOLEAN ClientReferral = FALSE;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR   ExtendedError;
    ULONG   ExtensionIndex = 0;

    //
    // Get the client name from the cert
    //
    if(STATUS_SUCCESS != KerbGetPrincipalNameFromCertificate(ClientCert, &NameString))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Email name from certificate is %wZ\n",&NameString));

    KerbErr = KerbConvertStringToKdcName(
                &ClientName,
                &NameString
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ClientName->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;

    //
    // Now crack the name & see if it refers to us
    //

    //
    // Normalize the client name.
    //

    KerbErr = KdcNormalize(
                ClientName,
                NULL,
                NULL,
                KDC_NAME_CLIENT,
                &ClientReferral,
                &ClientRealm,
                &TicketInfo,
                &ExtendedError,
                NULL,                   // no user handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no group membership
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to normalize name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //

    if (ClientReferral)
    {
        KerbErr = KDC_ERR_WRONG_REALM;
        DebugLog((DEB_WARN,"Client tried to logon to account in another realm\n"));
        goto Cleanup;
    }

    //
    // Verify the client cert matches the client
    //

    if (TicketInfo.UserId != ClientTicketInfo->UserId)
    {
        DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ, %wZ\n",
            &NameString, &ClientTicketInfo->AccountName));
        KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &NameString);
    KerbFreeKdcName( &ClientName );
    FreeTicketInfo( &TicketInfo );
    return(KerbErr);


}


//+-------------------------------------------------------------------------
//
//  Function:   KdcConvertNameString
//
//  Synopsis:   Converts the cr-lf to , in a dn
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void
KdcConvertNameString(
    IN PUNICODE_STRING Name,
    IN WCHAR ReplacementChar
    )
{
    PWCHAR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to the replacement char.  This
    // should be done by the CertNameToStr APIs, but that won't happen for
    // a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = ReplacementChar;
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = wcslen( Name->Buffer ) * sizeof( WCHAR );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyMappedClientCertIdentity
//
//  Synopsis:   Verifies that the mapping of a client's cert identity
//              the mapping of the client name from the AS request.  The
//              cert should be in the list of mapped ceritificates for this
//              user.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


#define ISSUER_HEADER       L"<I>"
#define CCH_ISSUER_HEADER   3
#define SUBJECT_HEADER      L"<S>"
#define CCH_SUBJECT_HEADER  3

KERBERR
KdcVerifyMappedClientCertIdentity(
    IN PCCERT_CONTEXT ClientCert,
    IN PKDC_TICKET_INFO ClientTicketInfo
    )
{
    KERBERR KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
    //
    // Disable this code for now
    //
#ifdef notdef
    UNICODE_STRING CompoundName = {0};
    ULONG SubjectLength ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    PWCHAR Current ;
    KDC_TICKET_INFO TicketInfo = {0};
    DWORD dwNameToStrFlags = CERT_X500_NAME_STR |
                                   CERT_NAME_STR_NO_PLUS_FLAG |
                                   CERT_NAME_STR_CRLF_FLAG;


    //
    // Build the name of the form <i>issuer <s> subject
    //

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                                   &ClientCert->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                            &ClientCert->pCertInfo->Subject,
                            dwNameToStrFlags,
                            NULL,
                            0 );

    if ( ( IssuerLength == 0 ) ||
         ( SubjectLength == 0 ) )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    CompoundName.MaximumLength = (USHORT) (SubjectLength + IssuerLength +
                                 CCH_ISSUER_HEADER + CCH_SUBJECT_HEADER) *
                                 sizeof( WCHAR ) ;

    CompoundName.Buffer = (LPWSTR) MIDL_user_allocate( CompoundName.MaximumLength );

    if ( CompoundName.Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    wcscpy( CompoundName.Buffer, ISSUER_HEADER );
    Current = CompoundName.Buffer + CCH_ISSUER_HEADER ;

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                               &ClientCert->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               Current,
                               IssuerLength );

    Current += IssuerLength - 1 ;
    wcscpy( Current, SUBJECT_HEADER );
    Current += CCH_SUBJECT_HEADER ;

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                        &ClientCert->pCertInfo->Subject,
                        dwNameToStrFlags,
                        Current,
                        SubjectLength );

    KdcConvertNameString(
        &CompoundName,
        L','
        );

    //
    // Get ticket info for this name
    //

    KerbErr = KdcGetTicketInfo(
                &CompoundName,
                SAM_OPEN_BY_ALTERNATE_ID,
                NULL,                   // no kerb principal name
                NULL,
                &TicketInfo,
                NULL,                   // no handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to get ticket info for %wZ to verify certZ\n",
            &CompoundName));
        goto Cleanup;
    }

    if (TicketInfo.UserId != ClientTicketInfo->UserId)
    {
        D_DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ, %wZ\n",
            &TicketInfo.AccountName, &ClientTicketInfo->AccountName));
        KerbErr = KRB_AP_ERR_BADMATCH;
        goto Cleanup;
    }


Cleanup:
    KerbFreeString(&CompoundName);
    FreeTicketInfo( &TicketInfo );
#endif
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForEtype
//
//  Synopsis:   Checks if a client supports a particular etype
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if it does, false if it doesn't
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    )
{
    PKERB_CRYPT_LIST List = CryptList;

    while (List != NULL)
    {
        if ((ULONG) List->value == Etype)
        {
            return(TRUE);
        }
        List=List->next;
    }

    return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPkinitPreAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//  
//--------------------------------------------------------------------------

KERBERR
KdcCheckPkinitPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY ClientRequest,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealm,
    IN OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_PK_AS_REQ PkAsReq = NULL;
    PKERB_PA_PK_AS_REQ2 PkAsReq2 = NULL;
    PKERB_CERTIFICATE UserCert = NULL;
    PCCERT_CONTEXT CertContext = NULL;
    PCCERT_CONTEXT KdcCert = NULL;
    HCRYPTKEY ClientKey = NULL;
    PBYTE PackedAuthenticator = NULL;
    ULONG PackedAuthenticatorSize;
    PBYTE PackedKeyPack = NULL;
    ULONG PackedKeyPackSize;
    PBYTE SignedKeyPack = NULL;
    ULONG SignedKeyPackSize;
    PKERB_SIGNATURE Signature = NULL;
    PKERB_PK_AUTHENTICATOR PkAuthenticator = NULL;
    CERT_CHAIN_POLICY_STATUS FinalChainStatus = {0};
    UNICODE_STRING ClientKdcName = {0};
    ULONG ClientKdcNameType;
    LARGE_INTEGER ClientTime;
    LARGE_INTEGER CurrentTime;
    PULONG EtypeArray = NULL;
    ULONG EtypeCount = 0;
    ULONG CommonEtype;
    KERB_SIGNED_REPLY_KEY_PACKAGE KeyPack = {0};
    KERB_REPLY_KEY_PACKAGE ReplyKey = {0};
    HCRYPTPROV KdcProvider = NULL;
    BOOL FreeProvider = FALSE;
#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE PkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG PkSignatureLength = KERB_PK_MAX_SIGNATURE_SIZE;
    ULONG RequiredSize = 0;
    PBYTE EncryptedKeyPack = NULL;
    PKERB_PA_DATA_LIST PackedPkAsRep = NULL;
    CRYPT_ENCRYPT_MESSAGE_PARA MessageParam = {0};
    PBYTE PackedKey = NULL;
    ULONG PackedKeySize = 0;
    ULONG EncryptionOverhead = 0;
    ULONG BlockSize = 0;
    KERB_ENCRYPTION_KEY TempKey = {0};
    PKERB_CERTIFICATE_LIST CertList = NULL;
    CRYPT_ALGORITHM_IDENTIFIER CryptAlg = {0};
    PKERB_AUTH_PACKAGE AuthPack = NULL;
    BOOLEAN EmbeddedUPNOk = FALSE;
    BOOLEAN Used3Des = FALSE;
    ULONG TransitedLength = 0;
    ULONG Index;
    DWORD dwNameToStrFlags = CERT_X500_NAME_STR |
                                   CERT_NAME_STR_NO_PLUS_FLAG |
                                   CERT_NAME_STR_CRLF_FLAG;
    
    //
    // Prepare the output variables
    //

    *OutputPreAuthData = NULL;
    RtlZeroMemory(
        EncryptionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    *Nonce = 0;
    
    //
    // If we don't do this preauth, return such
    //

    Status = KdcGetKdcCertificate(&KdcCert);
    if (!NT_SUCCESS(Status))
    {            

       //
       // Log an event
       //        
       ReportServiceEvent(
               EVENTLOG_ERROR_TYPE,
               KDCEVENT_NO_KDC_CERTIFICATE,
               0,
               NULL,
               0
               );

       FILL_EXT_ERROR_EX(pExtendedError, STATUS_PKINIT_FAILURE, FILENO, __LINE__);
       return(KDC_ERR_PADATA_TYPE_NOSUPP);
    }


    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // First, unpack the outer KRB-PA-PK-AS-REQ
    //


    KerbErr = KerbUnpackData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                KERB_PA_PK_AS_REQ_PDU,
                (PVOID *) &PkAsReq
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try the older variation
        //

        KerbErr = KerbUnpackData(
                    PreAuthData->value.preauth_data.value,
                    PreAuthData->value.preauth_data.length,
                    KERB_PA_PK_AS_REQ2_PDU,
                    (PVOID *) &PkAsReq2
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unpack PA-PK-AS-REQ(2): 0x%x\n",KerbErr));
            goto Cleanup;
        }

    }

    if (PkAsReq != NULL)
    {
        //
        // Verify the signature
        //

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    KdcClientProvider,
                    PkAsReq->signed_auth_pack.value,
                    PkAsReq->signed_auth_pack.length,
                    PackedAuthenticator,
                    &PackedAuthenticatorSize,
                    NULL        // don't return certificate context
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        PackedAuthenticator = (PBYTE) MIDL_user_allocate(PackedAuthenticatorSize);
        if (PackedAuthenticator == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    KdcClientProvider,
                    PkAsReq->signed_auth_pack.value,
                    PkAsReq->signed_auth_pack.length,
                    PackedAuthenticator,
                    &PackedAuthenticatorSize,
                    &CertContext
                    );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Unpack the auth package
        //

        KerbErr = KerbUnpackData(
                    PackedAuthenticator,
                    PackedAuthenticatorSize,
                    KERB_AUTH_PACKAGE_PDU,
                    (PVOID *)&AuthPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        PkAuthenticator = &AuthPack->pk_authenticator;

    }
    else
    {
        DsysAssert(PkAsReq2 != NULL);

        //
        // Get the user certificate & verify
        //

        if ((PkAsReq2->bit_mask & user_certs_present) == 0)
        {
            DebugLog((DEB_ERROR,"Client tried to use pkinit w/o client cert\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Just use the first of the certificates
        //

        UserCert = &PkAsReq2->user_certs->value;

        //
        // We only handle x509 certificates
        //

        if (UserCert->cert_type != KERB_CERTIFICATE_TYPE_X509)
        {
            DebugLog((DEB_ERROR,"User supplied bad cert type: %d\n",UserCert->cert_type));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Decode the certificate.
        //

        CertContext = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        UserCert->cert_data.value,
                        UserCert->cert_data.length
                        );
        if (CertContext == NULL)
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to create certificate context: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }



        //
        // Verify the authenticator
        //

        Signature = &PkAsReq2->signed_auth_pack.auth_package_signature;

        //
        // Now import the key from the certificate
        //

        if (!CryptImportPublicKeyInfo(
                KdcClientProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertContext->pCertInfo->SubjectPublicKeyInfo,
                &ClientKey
                ))
        {
            DebugLog((DEB_ERROR,"Failed to import public key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Encode the data to be verified
        //

        KerbErr = KerbPackData(
                    &PkAsReq2->signed_auth_pack.auth_package,
                    KERB_AUTH_PACKAGE_PDU,
                    &PackedAuthenticatorSize,
                    &PackedAuthenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the signature on the message
        //

        if (!KerbCompareObjectIds(
                Signature->signature_algorithm.algorithm,
                KdcSignatureAlg
                ))
        {
            DebugLog((DEB_ERROR,"Unsupported signature algorithm (not MD5)\n"));
            KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
            goto Cleanup;
        }

        Status = ScHelperVerifyMessage(
                    NULL,                           // no logon info
                    KdcClientProvider,
                    CertContext,
                    KERB_PKINIT_SIGNATURE_ALG,
                    PackedAuthenticator,
                    PackedAuthenticatorSize,
                    Signature->pkcs_signature.value,
                    Signature->pkcs_signature.length / 8            // because it is a bit string
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_INVALID_SIG;
            goto Cleanup;
        }

        //
        // Now check the information in the authenticator itself.
        //

        PkAuthenticator = &PkAsReq2->signed_auth_pack.auth_package.pk_authenticator;

    }

    //
    // Call a helper routine to verify the certificate. It will check
    // CRLs, CTLs,
    //

    KerbErr = KdcCheckCertificate(
                CertContext,
                &EmbeddedUPNOk,
                pExtendedError,
                &FinalChainStatus,
                FALSE // not a kdc certificate
                );
    
    //
    // Assume B3 certs aren't being used
    // anymore
    //
    /*if(!KERB_SUCCESS(KerbErr))
    {
        KerbErr = KdcCheckB3Certificate(
                    CertContext,
                    &EmbeddedUPNOk
                    );
    } */
    if (!KERB_SUCCESS(KerbErr))
    { 
        //
        // Dumb this down for release?  FESTER
        //
        if ((KDCInfoLevel & DEB_T_PKI) != 0)
        {
            LPWSTR Tmp = NULL;
            Tmp = KerbBuildNullTerminatedString(&ClientTicketInfo->AccountName);
            
            if (Tmp != NULL)
            {
                ReportServiceEvent(
                    EVENTLOG_WARNING_TYPE,
                    KDCEVENT_INVALID_CLIENT_CERTIFICATE,
                    sizeof(FinalChainStatus) - sizeof(void*),  // don't need ptr. 
                    &FinalChainStatus,
                    1,
                    Tmp
                    );

                MIDL_user_free(Tmp);
            }

        }         

        DebugLog((DEB_ERROR,"Failed to check CLIENT certificate: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Verify the cert is for the right client
    //

    if(EmbeddedUPNOk)
    {
        KerbErr = KdcVerifyClientCertName(
                    CertContext,
                    ClientTicketInfo
                    );
    }
    else
    {
        KerbErr = KdcVerifyMappedClientCertIdentity(
                    CertContext,
                    ClientTicketInfo
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KDC failed to verify client's identity from cert\n"));
        goto Cleanup;
    }

#ifdef later
    //
    // BUG 455112: this code breaks MIT KDCs, which can't handle a strange
    // x.500 name in the transited field. So, for NT5, disable the code
    //

    //
    // Put the issuer name in as a transited realm, as it is invovled in
    // the authentication decision.
    //

    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                                   &CertContext->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );


    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedRealm->MaximumLength = (USHORT) TransitedLength * sizeof(WCHAR) + sizeof(WCHAR);
    TransitedRealm->Length = (USHORT) TransitedLength * sizeof(WCHAR);
    TransitedRealm->Buffer = (LPWSTR) MIDL_user_allocate( TransitedRealm->MaximumLength );

    if ( TransitedRealm->Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                               &CertContext->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               TransitedRealm->Buffer,
                               TransitedLength );

    if ( TransitedLength == 0 )
    {
        DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Convert the "." to "/"
    //


    KdcConvertNameString(
        TransitedRealm,
        L'/'
        );

#endif // later

    //
    // Verify the realm name is correct
    //

    if (!SecData.IsOurRealm(
            &PkAuthenticator->kdc_realm
            ))
    {
        DebugLog((DEB_ERROR,"Client used wrong realm in PK authenticator: %s\n",
            PkAuthenticator->kdc_realm
            ));

        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;

    }

    //
    // Verify the service realm and kdc name is correct
    //

    KerbErr = KerbConvertPrincipalNameToString(
                &ClientKdcName,
                &ClientKdcNameType,
                &PkAuthenticator->kdc_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!RtlEqualUnicodeString(
            SecData.KdcFullServiceKdcName(),
            &ClientKdcName,
            TRUE))
    {
        if (!RtlEqualUnicodeString(
                SecData.KdcFullServiceDnsName(),
                &ClientKdcName,
                TRUE))
        {
            if (!RtlEqualUnicodeString(
                    SecData.KdcFullServiceName(),
                    &ClientKdcName,
                    TRUE))
            {
                DebugLog((DEB_ERROR,"Client provided KDC name is wrong: %wZ\n",
                    &ClientKdcName));
                
                KerbErr = KDC_ERR_KDC_NAME_MISMATCH;
                goto Cleanup;
            }

        }
    }

    //
    // Now verify the time
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &PkAuthenticator->client_time,
        PkAuthenticator->cusec
        );

    if (!KerbCheckTimeSkew(
            &CurrentTime,
            &ClientTime,
            &SkewTime))
    {
        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    *Nonce = PkAuthenticator->nonce;

    //
    // Generate a temporary key. First find a good encryption type
    //

    KerbErr = KerbConvertCryptListToArray(
                &EtypeArray,
                &EtypeCount,
                ClientRequest->encryption_type
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Status = CDFindCommonCSystem(
                EtypeCount,
                EtypeArray,
                &CommonEtype
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = KerbMakeKey(
                CommonEtype,
                EncryptionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build the return structure
    //

    PackedPkAsRep = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (PackedPkAsRep == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        PackedPkAsRep,
        sizeof(KERB_PA_DATA_LIST)
        );

    PackedPkAsRep->next = NULL;
    PackedPkAsRep->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

    //
    // Success. Now build the reply
    //

    if (PkAsReq2 != NULL)
    {
        KERB_PA_PK_AS_REP2 Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        KeyPack.reply_key_package.nonce = *Nonce;
        KeyPack.reply_key_package.reply_key = *EncryptionKey;

        KerbErr = KerbPackData(
                    &KeyPack.reply_key_package,
                    KERB_REPLY_KEY_PACKAGE2_PDU,
                    &PackedKeyPackSize,
                    &PackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    KdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &KdcProvider,
                    NULL,           // no key spec
                    &FreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        Status = ScHelperSignMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KERB_PKINIT_SIGNATURE_ALG,
                    PackedKeyPack,
                    PackedKeyPackSize,
                    PkSignature,
                    &PkSignatureLength
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to sign keypack: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Copy the temporary signature into the return structure
        //

        KeyPack.reply_key_signature.pkcs_signature.length = PkSignatureLength * 8;  // because it is a bit string
        KeyPack.reply_key_signature.pkcs_signature.value = PkSignature;
        KeyPack.reply_key_signature.signature_algorithm.algorithm = KdcSignatureAlg;

        //
        // Now marshall the signed key package
        //

        KerbErr = KerbPackData(
                    &KeyPack,
                    KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
                    &SignedKeyPackSize,
                    &SignedKeyPack
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Just encrypt the key package
        //

        PackedKey = SignedKeyPack;
        PackedKeySize = SignedKeyPackSize;

        //
        // Zero these out so we don't free them twice
        //

        SignedKeyPack = NULL;
        SignedKeyPackSize = 0;


        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg2:

        if (Kdc3DesSupported && KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_SEAL_ETYPE))
        {
            Used3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        RequiredSize = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    PackedKey,
                    PackedKeySize,
                    NULL,
                    (PULONG) &RequiredSize
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (Used3Des))
            {
                Kdc3DesSupported = FALSE;
                goto ChangeCryptAlg2;
            }
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        EncryptedKeyPack  = (PBYTE) MIDL_user_allocate(RequiredSize);
        if (EncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    PackedKey,
                    PackedKeySize,
                    EncryptedKeyPack,
                    &RequiredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Create the cert list for the reply
        //

        KerbErr = KerbCreateCertificateList(
                    &CertList,
                    KdcCert
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // We will be returning the KDC cert as well as a package containing
        // a temporary key
        //

        Reply.bit_mask |= KERB_PA_PK_AS_REP2_kdc_cert_present;


        //
        // Now, to finish the reply, we need a handle to the KDCs certificate
        //

        Reply.kdc_cert = (KERB_PA_PK_AS_REP2_kdc_cert) CertList;

        Reply.temp_key_package.choice = pkinit_enveloped_data_chosen;
        Reply.temp_key_package.u.pkinit_enveloped_data.length = (int) RequiredSize;
        Reply.temp_key_package.u.pkinit_enveloped_data.value = EncryptedKeyPack;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP2_PDU,
                    (PULONG) &PackedPkAsRep->value.preauth_data.length,
                    &PackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERB_PA_PK_AS_REP Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        ReplyKey.nonce = *Nonce;
        ReplyKey.reply_key = *EncryptionKey;

        KerbErr = KerbPackData(
                    &ReplyKey,
                    KERB_REPLY_KEY_PACKAGE_PDU,
                    &PackedKeyPackSize,
                    &PackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    KdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &KdcProvider,
                    NULL,           // no key spec
                    &FreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;

        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    PackedKeyPack,
                    PackedKeyPackSize,
                    SignedKeyPack,
                    &SignedKeyPackSize
                    );



        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        SignedKeyPack = (PBYTE) MIDL_user_allocate(SignedKeyPackSize);
        if (SignedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    PackedKeyPack,
                    PackedKeyPackSize,
                    SignedKeyPack,
                    &SignedKeyPackSize
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now encrypt the content
        //

        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg:
        if (Kdc3DesSupported && KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_SEAL_ETYPE))
        {
            Used3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        RequiredSize = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    SignedKeyPack,
                    SignedKeyPackSize,
                    NULL,
                    (PULONG) &RequiredSize
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (Used3Des))
            {
                Kdc3DesSupported = FALSE;
                goto ChangeCryptAlg;
            }

            DebugLog((DEB_ERROR,"Failed to encrypt message (crypto mismatch?): %x\n",Status));
            FILL_EXT_ERROR_EX(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        EncryptedKeyPack  = (PBYTE) MIDL_user_allocate(RequiredSize);
        if (EncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    SignedKeyPack,
                    SignedKeyPackSize,
                    EncryptedKeyPack,
                    &RequiredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        Reply.u.key_package.value = EncryptedKeyPack;
        Reply.u.key_package.length = RequiredSize;
        Reply.choice = pkinit_enveloped_data_chosen;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP_PDU,
                    (PULONG) &PackedPkAsRep->value.preauth_data.length,
                    &PackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    *OutputPreAuthData = PackedPkAsRep;
    PackedPkAsRep = NULL;

Cleanup:

    if (FreeProvider)
    {
        CryptReleaseContext(
            KdcProvider,
            0
            );
    }
    if (PkAsReq != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ_PDU,
            PkAsReq
            );
    }
    if (PkAsReq2 != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ2_PDU,
            PkAsReq2
            );
    }
    if (SignedKeyPack != NULL)
    {
        KdcFreeEncodedData(SignedKeyPack);
    }
    if (PackedKeyPack != NULL)
    {
        KdcFreeEncodedData(PackedKeyPack);
    }
    if (PackedAuthenticator != NULL)
    {
        KdcFreeEncodedData(PackedAuthenticator);
    }
    if (ClientKey != NULL)
    {
        CryptDestroyKey(ClientKey);
    }
    if (CertContext != NULL)
    {
        CertFreeCertificateContext(CertContext);
    }
    if(KdcCert)
    {
        CertFreeCertificateContext(KdcCert);
    }
    if (EncryptedKeyPack != NULL)
    {
        MIDL_user_free(EncryptedKeyPack);
    }
    if (EtypeArray != NULL)
    {
        MIDL_user_free(EtypeArray);
    }
    KerbFreeCertificateList(
        CertList
        );
    KerbFreeKey(&TempKey);
    if (PackedKey != NULL)
    {
        MIDL_user_free(PackedKey);
    }
    if (PackedPkAsRep != NULL)
    {
        if (PackedPkAsRep->value.preauth_data.value != NULL)
        {
            MIDL_user_free(PackedPkAsRep->value.preauth_data.value);
        }
        MIDL_user_free(PackedPkAsRep);
    }

    KerbFreeString(&ClientKdcName);
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyDCCertificate
//
//  Synopsis:   
//
//  Effects:
//
//  Arguments:  IN: A certificate context
//
//  Requires:   TRUE is the certificate has a smart card logon EKU; or its template
//              name is DomainController
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL VerifyDCCertificate(PCCERT_CONTEXT pCertContext)
{
    BOOL                fDCCert=FALSE;
    CERT_EXTENSION      *pExtension = NULL;
    DWORD               cbSize = 0;
    DWORD               dwIndex = 0;

    PCERT_NAME_VALUE    pTemplateName = NULL;
    CERT_ENHKEY_USAGE   *pEnhKeyUsage=NULL;

    if(NULL == (pCertContext->pCertInfo))
        goto Cleanup;    


    //find the EKU extension
    pExtension =CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension);

    if(pExtension)
    {
        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          NULL,
                          &cbSize))

        {
            pEnhKeyUsage=(CERT_ENHKEY_USAGE *)MIDL_user_allocate(cbSize);

            if(pEnhKeyUsage)
            {
                if(CryptDecodeObject(X509_ASN_ENCODING,
                                  X509_ENHANCED_KEY_USAGE,
                                  pExtension->Value.pbData,
                                  pExtension->Value.cbData,
                                  0,
                                  pEnhKeyUsage,
                                  &cbSize))
                {
                    for(dwIndex=0; dwIndex < pEnhKeyUsage->cUsageIdentifier; dwIndex++)
                    {
                        if(0 == strcmp(szOID_KP_SMARTCARD_LOGON, 
                                       (pEnhKeyUsage->rgpszUsageIdentifier)[dwIndex]))
                        {
                            //we find it
                            fDCCert=TRUE;
                            break;
                        }
                    }
                }
            }
        }
    }

    //check if we have found it via the enhanced key usage extension
    if(fDCCert)
        goto Cleanup;


    //find the V1 template extension
    pExtension =CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension);
    if(pExtension == NULL)
        goto Cleanup;
        

    cbSize=0;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_UNICODE_ANY_STRING,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          NULL,
                          &cbSize))

        goto Cleanup;

    pTemplateName = (CERT_NAME_VALUE *)MIDL_user_allocate(cbSize);

    if(NULL == pTemplateName)
        goto Cleanup;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_UNICODE_ANY_STRING,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          pTemplateName,
                          &cbSize))

        goto Cleanup;

    if(wcscmp((LPWSTR)  pTemplateName->Value.pbData, wszCERTTYPE_DC) != 0)
        goto Cleanup;

    fDCCert=TRUE;


Cleanup:

    if(pEnhKeyUsage)
        MIDL_user_free(pEnhKeyUsage);

    if(pTemplateName)
        MIDL_user_free(pTemplateName);

    return fDCCert;

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcMyStoreWaitHandler
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID 
KdcMyStoreWaitHandler(
    PVOID pVoid, 
    BOOLEAN fTimeout
    )
{
    
    PCCERT_CONTEXT Certificate = NULL, OldCertificate = NULL;
    CERT_CHAIN_POLICY_STATUS  FinalChainStatus = {0};
    KERB_EXT_ERROR            DummyError;

    KERBERR KerbErr;
    BOOLEAN DummyBool, Found = FALSE;
    BOOLEAN UsedPrexistingCertificate = FALSE;
    ULONG   PropertySize = 0;

    // Diagnostic: When's the last time this event fired?    
    GetSystemTimeAsFileTime((PFILETIME) &KdcLastChangeEventTime);

    //
    // This was triggered by a timeout, so disable the store notification
    // for now...
    //
    if (fTimeout)
    {
        if (!CertControlStore(
                    KdcCertStore,                // in, the store to be controlled
                    0,                           // in, not used.
                    CERT_STORE_CTRL_CANCEL_NOTIFY,      
                    &KdcCertStoreChangeEvent                         
                    ))
        {
            D_DebugLog((DEB_ERROR, "CertControlStore (cancel notify) failed - %x\n", GetLastError()));
        }
    }

    D_DebugLog((DEB_T_PKI, "Triggering KdcMyStoreWaitHandler()\n"));

        
    //
    // Resync store
    //
    CertControlStore(
                KdcCertStore,               // in, the store to be controlled
                0,                          // in, not used.
                CERT_STORE_CTRL_RESYNC,     // in, control action type
                NULL                        // Just resync store
                );                 
         

    RtlEnterCriticalSection(&KdcGlobalCertCritSect);


    // Our my store changed, so we need to find the cert again.
    if(GlobalKdcCert)
    {
        OldCertificate = GlobalKdcCert;
        KerbErr = KdcCheckCertificate(
                     GlobalKdcCert,
                     &DummyBool,
                     &DummyError,
                     &FinalChainStatus,
                     TRUE // this is a kdc certificate
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            GlobalKdcCert = NULL;
        } 
        else
        {
            // certificate is good!
            // However, it may have been deleted, so
            // verify its existance
            while ((Certificate = CertEnumCertificatesInStore(
                                        KdcCertStore,
                                        Certificate)) != NULL)
            {
                if (CertCompareCertificate(
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            GlobalKdcCert->pCertInfo,
                            Certificate->pCertInfo 
                            ))
                {
                    Found = TRUE;
                    break; // still there
                } 
            }

            if (NULL != Certificate)
            {
                CertFreeCertificateContext(Certificate);
                Certificate = NULL;
            }                      

            if (Found)
            {
                goto Rearm;
            }  

            GlobalKdcCert = NULL;
        }   
    }

    if (NULL == GlobalKdcCert)
    {
        //      
        // Enumerate all the certificates looking for the one we want
        //              
        while ((Certificate = CertEnumCertificatesInStore(
                                            KdcCertStore,
                                            Certificate)) != NULL)
        {
            
            //      
            // Check to see if the certificate is the one we want
            //              
            if (!CertGetCertificateContextProperty(
                Certificate,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,                           // no data
                &PropertySize))
            {
                continue;
            }


            //
            // Make sure the certificate is indeed a domain conroller cert
            if(!VerifyDCCertificate(Certificate))
            {
                continue;
            }

            //      
            // Make sure the cert we selected was "good"
            //              
            KerbErr = KdcCheckCertificate(
                            Certificate,
                            &DummyBool,
                            &DummyError,
                            NULL,
                            TRUE // this is a kdc certificate
                            );


            if (!KERB_SUCCESS(KerbErr))
            {
                continue;
            }           

            break;
        }
    }

    // Couldn't find a good certificate!
    if (NULL == Certificate)
    {
        DebugLog((DEB_ERROR, "No valid KDC certificate was available\n")); 
        
        //
        // Keep the old one... We might just be getting an offline CA
        //
        if (OldCertificate != NULL)
        {
            DebugLog((DEB_T_PKI, "Re-using old certificate\n"));
            GlobalKdcCert = OldCertificate;

            if ((KDCInfoLevel & DEB_T_PKI) != 0)
            { 
                ReportServiceEvent(
                    EVENTLOG_WARNING_TYPE,
                    KDCEVENT_INVALID_KDC_CERTIFICATE,
                    sizeof(FinalChainStatus) - sizeof(void*),  // don't need ptr. 
                    &FinalChainStatus,
                    0
                    );
            }
        }
        else
        // 
        // Never had one...
        //
        {
            GlobalKdcCert = NULL;
        }                        
    }
    else
    {   
        D_DebugLog((DEB_T_PKI, "Picked new KDC certificate\n"));
        GlobalKdcCert = Certificate;
        if (OldCertificate != NULL)
        {
            CertFreeCertificateContext(OldCertificate);
        }
    }


Rearm:

    RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

    //
    // This was moved here because of race conditions associated w/ my store 
    // chain building, where the event was getting fired rapidly, leading
    // us to loose notification, and thus- the re-arm.
    //

    
    CertControlStore(
        KdcCertStore,                       // in, the store to be controlled
        0,                                  // in, not used.
        CERT_STORE_CTRL_NOTIFY_CHANGE,      // in, control action type
        &KdcCertStoreChangeEvent            // in, the handle of the event
        );

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetKdcCertificate
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcGetKdcCertificate(
                     PCCERT_CONTEXT *KdcCert
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(!KdcGlobalCertCritSectInitialized)
    {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    RtlEnterCriticalSection(&KdcGlobalCertCritSect);


    if (GlobalKdcCert == NULL)
    {
        DebugLog((DEB_WARN,"Unable to find KDC certificate in KDC store\n"));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

    // Increment the ref count, so if we change certs while the caller of this
    // is still using this cert, we won't delete it out from under.

    *KdcCert = CertDuplicateCertificateContext(GlobalKdcCert);
    if(*KdcCert == NULL)
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

Cleanup:


    RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeCerts
//
//  Synopsis:   Initializes data for cert handling
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcInitializeCerts(
    VOID
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PCCERT_CONTEXT Certificate = NULL;
    ULONG Index;
    LPSTR TempString = NULL, StringCopy = NULL, EndPtr = NULL;
    ULONG TenHours;

    TenHours = (ULONG) 1000 * 60 * 60 * 10; 

    Status = RtlInitializeCriticalSection(&KdcGlobalCertCritSect);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KdcGlobalCertCritSectInitialized = TRUE;

    if (!CryptAcquireContext(
            &KdcClientProvider,
            NULL,               // default container
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT
            ))
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,"Failed to acquire client crypt context: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Open the KDC store to get the KDC cert
    //

    KdcCertStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    0,                  // no encoding
                    NULL,               // no provider
                    CERT_STORE_OPEN_EXISTING_FLAG |
                    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    KDC_PRIVATE_MY_STORE
                    );
    if (KdcCertStore == NULL)
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,"Failed to open %ws store: 0x%x\n", KDC_PRIVATE_MY_STORE,Status));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }


    // Create an auto-reset event that is to be signaled when
    // the my store is changed.  This event is initialized to Signaled
    // so that on first call to get a cert, we assume the my store is changed
    // and do all the work.

    KdcCertStoreChangeEvent = CreateEvent(
                                            NULL,
                                            FALSE,
                                            FALSE,
                                            NULL);

    if(NULL == KdcCertStoreChangeEvent)
    {
        Status = GetLastError();
        goto Cleanup;
    }


    if (! RegisterWaitForSingleObject(&KdcCertStoreWait,
                                      KdcCertStoreChangeEvent,
                                      KdcMyStoreWaitHandler,
                                      NULL,
                                      TenHours,
                                      WT_EXECUTEDEFAULT
                                      ))
    {                                                                                              
        Status = GetLastError();
        goto Cleanup;
    }


    //  Arm the cert store for change notification
    //  CERT_CONTROL_STORE_NOTIFY_CHANGE.

    if(!CertControlStore(
        KdcCertStore,                    // The store to be controlled
        0,                             // Not used
        CERT_STORE_CTRL_NOTIFY_CHANGE, // Control action type
        &KdcCertStoreChangeEvent))                      // Points to the event handle.
                                       //  When a change is detected,
                                       //  a signal is written to the
                                       //  space pointed to by
                                       //  hHandle.
    {
        // Notification is not avaialble, so kill the Event
        Status = GetLastError();
        goto Cleanup;
    }

    // Initialize the GlobalCert
    KdcMyStoreWaitHandler (NULL, TRUE);

    //
    // Initialize the object IDs
    //

    Index = 0;
    StringCopy = (LPSTR) MIDL_user_allocate(strlen(KERB_PKINIT_SIGNATURE_OID)+1);
    if (StringCopy == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    //
    // Scan the string for every '.' separated number
    //

    strcpy(
        StringCopy,
        KERB_PKINIT_SIGNATURE_OID
        );

    TempString = StringCopy;
    EndPtr = TempString;

    while (TempString != NULL)
    {
        ULONG Temp;

        while (*EndPtr != '\0' && *EndPtr != '.')
        {
            EndPtr++;
        }
        if (*EndPtr == '.')
        {
            *EndPtr = '\0';
            EndPtr++;
        }
        else
        {
            EndPtr = NULL;
        }

        sscanf(TempString,"%u",&Temp);
        KdcSignatureAlg[Index].value = (USHORT) Temp;
        KdcSignatureAlg[Index].next = &KdcSignatureAlg[Index+1];
        Index++;


        TempString = EndPtr;


    }
    DsysAssert(Index != 0);
    KdcSignatureAlg[Index-1].next = NULL;
    MIDL_user_free(StringCopy);
    StringCopy = NULL;



Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcCleanupCerts(FALSE);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCleanupCerts
//
//  Synopsis:   Cleans up data associated with certificate handling
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcCleanupCerts(
    IN BOOLEAN CleanupScavenger
    )
{
    
    HANDLE WaitHandle;


    //
    // Pete code used to hold the critsec in the callback.
    //
    if(KdcCertStoreWait)
    {                 
        WaitHandle = (HANDLE) InterlockedExchangePointer(&KdcCertStoreWait,NULL);
        UnregisterWaitEx(WaitHandle, INVALID_HANDLE_VALUE);
    }
    
    
    if(KdcGlobalCertCritSectInitialized)
    {
        RtlEnterCriticalSection(&KdcGlobalCertCritSect);
    }

    if (GlobalKdcCert != NULL)
    {
        CertFreeCertificateContext(
            GlobalKdcCert
            );
       GlobalKdcCert = NULL;
    }

    if (KdcCertStore != NULL)
    {
        CertCloseStore(
            KdcCertStore,
            CERT_CLOSE_STORE_FORCE_FLAG
            );
        KdcCertStore = NULL;
    }

    if(KdcCertStoreChangeEvent)
    {
        CloseHandle(KdcCertStoreChangeEvent);
        KdcCertStoreChangeEvent = NULL;
    }

    if (KdcClientProvider != NULL)
    {
        CryptReleaseContext(
            KdcClientProvider,
            0   // no flags
            );
        KdcClientProvider = NULL;
    }



    if(KdcGlobalCertCritSectInitialized)
    {
        RtlLeaveCriticalSection(&KdcGlobalCertCritSect);

        RtlDeleteCriticalSection(&KdcGlobalCertCritSect);
        KdcGlobalCertCritSectInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\notify2.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        notify.cxx
//
// Contents:    KDC password change notification code
//
//
// History:     19-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
}

SAMPR_HANDLE KdcNotifyAccountDomainHandle = NULL;
UNICODE_STRING KdcNotifyDnsDomainName;
UNICODE_STRING KdcNotifyDomainName;
RTL_CRITICAL_SECTION KdcNotifyCritSect;
BOOLEAN KdcNotificationInitialized;


//+-------------------------------------------------------------------------
//
//  Function:   KdcNotifyOpenAccountDomain
//
//  Synopsis:   Opens the account domain and stores a handle to it.
//
//  Effects:    Sets KdcNotifyAccountDomainHandle on success.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcNotifyOpenAccountDomain(
    OUT SAMPR_HANDLE * AccountDomainHandle
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    SAMPR_HANDLE ServerHandle = NULL;


    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &PolicyInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &KdcNotifyDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyDnsDomainInfo.Name
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &KdcNotifyDnsDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyDnsDomainInfo.DnsDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlUpcaseUnicodeString(
                &KdcNotifyDnsDomainName,
                &KdcNotifyDnsDomainName,
                FALSE   // don't allocate
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    //
    // Connect to SAM and open the account domain
    //

    Status = SamIConnect(
                NULL,           // no server name
                &ServerHandle,
                0,              // ignore desired access,
                TRUE            // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to connect to SAM: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Finally open the account domain.
    //

    Status = SamrOpenDomain(
                ServerHandle,
                DOMAIN_ALL_ACCESS,
                (PRPC_SID) PolicyInformation->PolicyDnsDomainInfo.Sid,
                AccountDomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to open account domain: 0x%x\n",Status));
        goto Cleanup;
    }


Cleanup:
    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyDnsDomainInformation,
                PolicyInformation
                );
    }

    if (ServerHandle != NULL)
    {
        SamrCloseHandle(&ServerHandle);
    }

    return(Status);


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPasswordList
//
//  Synopsis:   Builds a list of passwords for a user that just changed
//              their password.
//
//  Effects:    allocates memory
//
//  Arguments:  Password - clear or OWF password
//              PrincipalName - Name of principal
//              MarshallKeys - if TRUE, the keys will be marshalled
//              IncludeBuiltinTypes - if TRUE, include MD4 & LM hashes
//              PasswordList - Receives new password list
//              PasswordListSize - Size of list in bytes.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING DomainName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN PKERB_STORED_CREDENTIAL StoredCreds,
    IN ULONG StoredCredSize,
    IN BOOLEAN MarshallKeys,
    IN BOOLEAN IncludeBuiltinTypes,
    IN ULONG Flags,
    IN KDC_DOMAIN_INFO_DIRECTION Direction,
    OUT PKERB_STORED_CREDENTIAL * PasswordList,
    OUT PULONG PasswordListSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptCount = 0;
    PKERB_STORED_CREDENTIAL Credentials = NULL;
    ULONG CredentialSize = 0;
    ULONG KerbEncryptionKeyCount = 0;
    ULONG KerbKeyDataCount = 0;
    PCRYPTO_SYSTEM CryptoSystem;
    PCHECKSUM_FUNCTION CheckSum;
    ULONG Index, CredentialIndex = 0;
    PUCHAR Base, KeyBase;
    ULONG Offset;
    ULONG OldCredCount = 0;
    KERB_ENCRYPTION_KEY TempKey;
    UNICODE_STRING KeySalt = {0};
    UNICODE_STRING EmptySalt = {0};
    USHORT OldFlags = 0;


    *PasswordList = NULL;
    *PasswordListSize = 0;

    //
    // If we had passed in an OWF, then there is just one password.
    //

    if ((Flags & KERB_PRIMARY_CRED_OWF_ONLY) != 0)
    {
        CredentialSize += Password->Length + sizeof(KERB_ENCRYPTION_KEY);
        KerbEncryptionKeyCount++;
#ifndef DONT_SUPPORT_OLD_TYPES
        CredentialSize += Password->Length + sizeof(KERB_ENCRYPTION_KEY);
        KerbEncryptionKeyCount++;
#endif
    }
    else
    {
        //
        // The salt is the realm name concatenated with the principal name
        //

        if (AccountType != UnknownAccount)
        {
            //
            // For inbound trust, swap the domain names
            //

            if ((AccountType == DomainTrustAccount) &&
                (Direction == Inbound))
            {
                if (!KERB_SUCCESS(KerbBuildKeySalt(
                        PrincipalName,
                                    DomainName,
                        AccountType,
                        &KeySalt
                        )))
                {
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else
            {
                if (!KERB_SUCCESS(KerbBuildKeySalt(
                                    DomainName,
                        PrincipalName,
                        AccountType,
                        &KeySalt
                        )))
                {
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
        }
        else
        {
            KeySalt = *PrincipalName;
        }
        D_DebugLog((DEB_TRACE,"Building key list with salt %wZ\n",&KeySalt));

        //
        // For a cleartext password, build a list of encryption types and
        // create a key for each one
        //

        Status = CDBuildIntegrityVect(
                    &CryptCount,
                    CryptTypes
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            //
            // Skip etypes stored as normal passwords
            //

            if (!IncludeBuiltinTypes &&
                ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_NULL)))
            {
                continue;
            }

            Status = CDLocateCSystem(
                        CryptTypes[Index],
                        &CryptoSystem
                        );

            if (!NT_SUCCESS(Status) || NULL == CryptoSystem)
            {
               D_DebugLog((DEB_ERROR, "CDLocateCSystem failed for etype: %d\n", CryptTypes[Index]));
               continue;
            }

            CredentialSize += sizeof(KERB_ENCRYPTION_KEY) + CryptoSystem->KeySize;
            KerbEncryptionKeyCount++;
        }
    }


    //
    // For a cleartext password, build a list of encryption types and
    // create a key for each one
    //

    Status = CDBuildIntegrityVect(
                &CryptCount,
                CryptTypes
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

    //
    // Add the space for the salt
    //

    CredentialSize += KeySalt.Length;

    //
    // Now find the size of the key for each crypto system
    //

    for (Index = 0; Index < CryptCount; Index++ )
    {
        //
        // Skip etypes stored as normal passwords
        //

        if (!IncludeBuiltinTypes &&
            ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
             (CryptTypes[Index] == KERB_ETYPE_NULL)))
        {
            continue;
        }

        Status = CDLocateCSystem(
                    CryptTypes[Index],
                    &CryptoSystem
                    );

        if (!NT_SUCCESS(Status) || NULL == CryptoSystem)
        {
           D_DebugLog((DEB_ERROR, "CDLocateCSystem failed for etype: %d\n", CryptTypes[Index]));
           continue;
        }
        CredentialSize += sizeof(KERB_KEY_DATA) + CryptoSystem->KeySize;
        KerbKeyDataCount++;
    }

    //
    // Add in space for oldcreds
    //

    if (ARGUMENT_PRESENT(StoredCreds))
    {
        if ((StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
            (StoredCreds->CredentialCount != 0))
        {
            OldFlags = StoredCreds->Flags;
            for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
            {
                CredentialSize += sizeof(KERB_KEY_DATA) + StoredCreds->Credentials[Index].Key.keyvalue.length +
                                    StoredCreds->Credentials[Index].Salt.Length;
                KerbKeyDataCount++;
            }
            OldCredCount = StoredCreds->CredentialCount;

        }
    }

    //
    // Add in the size of the base structure
    //

    CredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));
    Credentials = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the base structure
    //

    Credentials->Revision = KERB_PRIMARY_CRED_REVISION;
    Credentials->Flags = OldFlags | (USHORT) Flags ;

    //
    // Now fill in the individual keys
    //

    Base = (PUCHAR) Credentials;
    if (MarshallKeys)
    {
        KeyBase = 0;
    }
    else
    {
        KeyBase = Base;
    }
    Offset = sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                (KerbEncryptionKeyCount * sizeof(KERB_ENCRYPTION_KEY)) +
                (KerbKeyDataCount * sizeof(KERB_KEY_DATA));


    //
    // Add the default salt
    //

    Credentials->DefaultSalt.Length =
        Credentials->DefaultSalt.MaximumLength = KeySalt.Length;
    Credentials->DefaultSalt.Buffer = (LPWSTR) (KeyBase+Offset);

    RtlCopyMemory(
        Base + Offset,
        KeySalt.Buffer,
        KeySalt.Length
        );
    Offset += Credentials->DefaultSalt.Length;



    if ((Flags & KERB_PRIMARY_CRED_OWF_ONLY) != 0)
    {
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_NT
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Credentials->Credentials[CredentialIndex].Key.keyvalue.value =
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value - Base + KeyBase;

        Offset += Password->Length;
        CredentialIndex++;

#ifndef DONT_SUPPORT_OLD_TYPES
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_OLD
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Credentials->Credentials[CredentialIndex].Key.keyvalue.value =
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value - Base + KeyBase;

        Offset += Password->Length;
        CredentialIndex++;
#endif
    }
    else // assume it's clear
    {
        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            if (!IncludeBuiltinTypes &&
                ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_NULL)))
            {
                continue;
            }

            if (!KERB_SUCCESS(KerbHashPasswordEx(
                    Password,
                    &KeySalt,
                    CryptTypes[Index],
                    &TempKey)))
            {
                //
                // It is possible that the password can't be used for every
                // encryption scheme, so skip failures
                //

                D_DebugLog((DEB_WARN, "Failed to hash pasword %wZ with type 0x%x\n",
                    Password,CryptTypes[Index] ));
                continue;
            }

#if DBG
            CDLocateCSystem(
                CryptTypes[Index],
                &CryptoSystem
                );
            DsysAssert(CryptoSystem->KeySize >= TempKey.keyvalue.length);

#endif

            Credentials->Credentials[CredentialIndex].Key = TempKey;
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = KeyBase + Offset;
            RtlCopyMemory(
                Base + Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );
            Offset += TempKey.keyvalue.length;
            KerbFreeKey(
                &TempKey
                );
            Credentials->Credentials[CredentialIndex].Salt = EmptySalt;
            CredentialIndex++;

        }
    }
    Credentials->CredentialCount = (USHORT) CredentialIndex;

    //
    // Now add in the old creds, if there were any
    //

    if (OldCredCount != 0)
    {
        for (Index = 0; Index < OldCredCount ; Index++ )
        {

            Credentials->Credentials[CredentialIndex] = StoredCreds->Credentials[Index];
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = KeyBase + Offset;
            RtlCopyMemory(
                Base + Offset,
                StoredCreds->Credentials[Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[Index].Key.keyvalue.length;

            //
            // Copy the salt
            //

            if (Credentials->Credentials[CredentialIndex].Salt.Buffer != NULL)
            {
                Credentials->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) Base+Offset;

                RtlCopyMemory(
                    Base + Offset,
                    (PBYTE) StoredCreds->Credentials[Index].Salt.Buffer + (ULONG_PTR) StoredCreds,
                    StoredCreds->Credentials[Index].Salt.Length
                    );
                Offset += StoredCreds->Credentials[Index].Salt.Length;
            }
            else
            {
                Credentials->Credentials[CredentialIndex].Salt = EmptySalt;
            }

            CredentialIndex++;
        }
        Credentials->OldCredentialCount = (USHORT) OldCredCount;
    }
    else
    {
        Credentials->OldCredentialCount = 0;
    }
    *PasswordList = Credentials;
    *PasswordListSize = CredentialSize;
    Credentials = NULL;

Cleanup:
    if (Credentials != NULL)
    {
         MIDL_user_free(Credentials);
    }
    if (AccountType != UnknownAccount)
    {
        KerbFreeString(&KeySalt);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildKeySaltFromUpn
//
//  Synopsis:   Builds the salt by parsing the UPN, stripping out "@" & "/"
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Salt
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING RealUpn;
    UNICODE_STRING LocalSalt = {0};
    ULONG Index;

    //
    // If there is an "@" in UPN, strip it out & use the dns domain name
    //

    RealUpn = *Upn;
    for ( Index = ((RealUpn.Length / sizeof(WCHAR)) - 1); Index-- > 0; )
    {
        if (RealUpn.Buffer[Index] == L'@')
        {
            RealUpn.Length = (USHORT) (Index * sizeof(WCHAR));
            break;
        }
    }

    //
    // Create the salt. It starts off with the domain name & then has the
    // UPN without any of the / pieces
    //

    LocalSalt.MaximumLength = DomainName->Length + RealUpn.Length;
    LocalSalt.Length = 0;
    LocalSalt.Buffer = (LPWSTR) MIDL_user_allocate(LocalSalt.MaximumLength);
    if (LocalSalt.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        LocalSalt.Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    LocalSalt.Length += DomainName->Length;

    //
    // We have to uppercase the realmname for users
    //

    (VOID) RtlUpcaseUnicodeString( &LocalSalt,
                                   &LocalSalt,
                                   FALSE);

    //
    // Add in the real upn but leave out any "/" marks
    //

    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] != L'/')
        {
            LocalSalt.Buffer[LocalSalt.Length / sizeof(WCHAR)] = RealUpn.Buffer[Index];
            LocalSalt.Length += sizeof(WCHAR);
        }
    }

    *Salt = LocalSalt;
Cleanup:
    return(Status);


}

//+-------------------------------------------------------------------------
//
//  Function:   PasswordChangeNotify
//
//  Synopsis:   Notifies KDC of a password change, allowing it to update
//              its credentials
//
//  Effects:    Stores Kerberos credentials on user object
//
//  Arguments:  UserName - Name of user whose password changed
//              RelativeId - RID of changed user
//              Passsword - New password of user
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
PasswordChangeNotify(
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING Password
    )
{

    //
    // Password change notify routine in kdcsvc was used to compute the
    // "DES" keys for the user upon a password change.
    // Subsequently this logic was inlined in samsrv.dll and but the original
    // code has been preserved in the #if 0 block for reference below
    //

    return(STATUS_SUCCESS);

#if 0

    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE UserHandle = NULL;
    SECPKG_SUPPLEMENTAL_CRED Credentials;
    PSAMPR_USER_INFO_BUFFER UserInfo = NULL;
    KERB_ACCOUNT_TYPE AccountType = UserAccount;
    WCHAR Nt4AccountName[UNLEN+DNLEN+2];
    WCHAR CrackedDnsDomain[DNS_MAX_NAME_LENGTH+1];
    ULONG CrackedDomainLength = sizeof(CrackedDnsDomain) / sizeof(WCHAR);
    WCHAR CrackedName[UNLEN+DNS_MAX_NAME_LENGTH+2];
    ULONG CrackedNameLength = sizeof(CrackedName);
    ULONG CrackError = 0;
    UNICODE_STRING EmailName = {0};
    UNICODE_STRING KeySalt = {0};
    PKERB_STORED_CREDENTIAL StoredCreds = NULL;
    ULONG CredentialSize;
    BOOLEAN FreeSalt = FALSE;

    Credentials.Credentials = NULL;

    //
    // Get a SAM handle
    //

    RtlEnterCriticalSection(&KdcNotifyCritSect);

    if (KdcNotifyAccountDomainHandle == NULL)
    {
        Status = KdcNotifyOpenAccountDomain(&KdcNotifyAccountDomainHandle);
    }

    RtlLeaveCriticalSection(&KdcNotifyCritSect);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrOpenUser(
                KdcNotifyAccountDomainHandle,
                USER_WRITE_ACCOUNT | USER_READ_ACCOUNT,
                RelativeId,
                &UserHandle
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"BAD ERR: Can't open account of user whose password just changed (name =%wZ, rid = 0x%x) 0x%x\n",
            UserName, RelativeId, Status ));
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &Credentials.PackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    //
    // Find out if the user is a machine account - if so, the principal name
    // takes on a different format.
    //

    Status = SamrQueryInformationUser(
                UserHandle,
                UserControlInformation,
                &UserInfo
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamIRetrievePrimaryCredentials(
                UserHandle,
                &GlobalKerberosName,
                (PVOID *) &StoredCreds,
                &CredentialSize
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to retrieve primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }

    if ((UserInfo->Control.UserAccountControl &
         (USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT)) != 0)
    {
        AccountType = MachineAccount;
    }
    else if ((UserInfo->Control.UserAccountControl &
         (USER_INTERDOMAIN_TRUST_ACCOUNT)) != 0)
    {
        AccountType = DomainTrustAccount;
    }

    //
    // Get the UPN from CrackSingleName
    //

    RtlCopyMemory(
        Nt4AccountName,
        KdcNotifyDomainName.Buffer,
        KdcNotifyDomainName.Length
        );
    Nt4AccountName[KdcNotifyDomainName.Length / sizeof(WCHAR)] = L'\\';

    RtlCopyMemory(
        Nt4AccountName + 1 + (KdcNotifyDomainName.Length) / sizeof(WCHAR),
        UserName->Buffer,
        UserName->Length
        );
    Nt4AccountName[1 + (KdcNotifyDomainName.Length + UserName->Length) / sizeof(WCHAR)] = L'\0';


    Status = CrackSingleName(
                DS_NT4_ACCOUNT_NAME,
                0,                      // don't check against GC
                Nt4AccountName,
                DS_USER_PRINCIPAL_NAME,
                &CrackedDomainLength,
                CrackedDnsDomain,
                &CrackedNameLength,
                CrackedName,
                &CrackError
                );
    if ((Status != STATUS_SUCCESS) || (CrackError != DS_NAME_NO_ERROR))
    {
        KeySalt = *UserName;
    }
    else
    {
        RtlInitUnicodeString(
            &EmailName,
            CrackedName
            );
        AccountType = UnknownAccount;

        Status = KdcBuildKeySaltFromUpn(
                    &EmailName,
                    &KdcNotifyDnsDomainName,
                    &KeySalt
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        FreeSalt = TRUE;

    }

    //
    // Build a the credentials
    //



    //
    // Set account type to unknown so it uses the UPN supplied salt
    //


    if ((Password != NULL) && (Password->Buffer != NULL))
    {
        Status = KdcBuildPasswordList(
                    Password,
                    &KeySalt,
                    &KdcNotifyDnsDomainName,
                    AccountType,
                    StoredCreds,
                    CredentialSize,
                    TRUE,               // marshall
                    FALSE,              // don't include builtins
                    0,                  // no flags
                    Unknown,
                    (PKERB_STORED_CREDENTIAL *) &Credentials.Credentials,
                    &Credentials.CredentialSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }
    else
    {
        Credentials.CredentialSize = 0;
        Credentials.Credentials = NULL;
    }

    Status = SamIStorePrimaryCredentials(
                UserHandle,
                &Credentials
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to store primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }


Cleanup:
    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }
    if (Credentials.Credentials != NULL)
    {
        MIDL_user_free(Credentials.Credentials);
    }

    if (UserInfo != NULL)
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserInfo, UserControlInformation );
    }
    if (FreeSalt)
    {
        KerbFreeString(&KeySalt);
    }

    if (StoredCreds != NULL)
    {
        LocalFree(StoredCreds);
    }
    return(Status);

#endif
}

extern "C"


NTSTATUS
KdcBuildKerbCredentialsFromPassword(
    IN PUNICODE_STRING ClearPassword,
    IN PVOID KerbCredentials,
    IN ULONG KerbCredentialLength,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID * NewKerbCredentials,
    OUT PULONG NewKerbCredentialLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_ACCOUNT_TYPE AccountType = UnknownAccount;
    UNICODE_STRING KeySalt = {0};
    BOOLEAN        FreeSalt = FALSE;

    PKERB_STORED_CREDENTIAL32 Cred32 = NULL;
    PKERB_STORED_CREDENTIAL   Cred64 = NULL;
    ULONG CredLength = KerbCredentialLength;


    //
    // Compute the correct account type
    //


    if (ARGUMENT_PRESENT(UPN))
    {
        Status = KdcBuildKeySaltFromUpn(
                    UPN,
                    DnsDomainName,
                    &KeySalt
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        FreeSalt = TRUE;
    }
    else
    {

        if ((UserAccountControl &
             (USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT)) != 0)
        {
            AccountType = MachineAccount;
        }
        else if ((UserAccountControl &
             (USER_INTERDOMAIN_TRUST_ACCOUNT)) != 0)
        {
            AccountType = DomainTrustAccount;
        }
        else
        {
            AccountType = UserAccount;
        }
        KeySalt = *UserName;
    }



#ifdef _WIN64

    Status = KdcUnpack32BitStoredCredential(
                  (PKERB_STORED_CREDENTIAL32) KerbCredentials,
                  &Cred64,
                  &CredLength
                  );

    if (!NT_SUCCESS(Status))
    {
       goto Cleanup;
    }

    KerbCredentials = (PVOID) Cred64;
    KerbCredentialLength = CredLength;

#endif

    //
    // Compute the kerb credentials
    //

    if ((ClearPassword != NULL))
    {
        UNICODE_STRING UpcaseDomainName = {0};

        Status = RtlUpcaseUnicodeString(
                    &UpcaseDomainName,
                    DnsDomainName,
                    TRUE
                    );
        if (NT_SUCCESS(Status))
        {
            Status = KdcBuildPasswordList(
                        ClearPassword,
                        &KeySalt,
                        &UpcaseDomainName,
                        AccountType,
                        (PKERB_STORED_CREDENTIAL )KerbCredentials,
                        KerbCredentialLength,
                        TRUE,               // marshall
                        FALSE,              // don't include builtins
                        0,                  // no flags
                        Unknown,
                        (PKERB_STORED_CREDENTIAL *) NewKerbCredentials,
                        NewKerbCredentialLength
                        );
            RtlFreeUnicodeString(&UpcaseDomainName);
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

#ifdef _WIN64

    // for 64 - 32 bit compat, we pack the struct in 32bit compliant form


    Status = KdcPack32BitStoredCredential(
                (PKERB_STORED_CREDENTIAL)(*NewKerbCredentials),
                &Cred32,
                NewKerbCredentialLength
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((*NewKerbCredentials) != NULL)
    {
        MIDL_user_free(*NewKerbCredentials);
        *NewKerbCredentials = Cred32;
    }

#endif

Cleanup:

    if (FreeSalt)
    {
        KerbFreeString(&KeySalt);
    }

    if (Cred64 != NULL)
    {
       MIDL_user_free(Cred64);
    }


    return(Status);
}

extern "C"
VOID
KdcFreeCredentials(
    IN PVOID Credentials
    )
{
    MIDL_user_free(Credentials);
}




//+-------------------------------------------------------------------------
//
//  Function:   InitializeChangeNotify
//
//  Synopsis:   KDC code for initializing password change notification
//              code.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


extern "C"
BOOLEAN
InitializeChangeNotify(
    )
{
    if (KdcNotificationInitialized)
    {
        return(TRUE);
    }
    D_DebugLog((DEB_TRACE, "Initialize Change Notify called!\n"));
    if (!NT_SUCCESS(RtlInitializeCriticalSection(&KdcNotifyCritSect)))
    {
        return FALSE;
    }
    KdcNotificationInitialized = TRUE;
    return(TRUE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcTimeHasElapsed
//
//  Synopsis:   Returns TRUE if the specified amount of time has
//              elapsed since the specified start time
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN PLARGE_INTEGER Delta
    )
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ElapsedTime;
    WCHAR PasswordBuffer[LM20_PWLEN];

    //
    // Check the password expiration time.
    //

    NtQuerySystemTime(&CurrentTime);
    ElapsedTime.QuadPart = CurrentTime.QuadPart - StartTime.QuadPart;

    //
    // If the window hasn't elapsed, we are done.
    //

    if ((ElapsedTime.QuadPart > 0) && (ElapsedTime.QuadPart < Delta->QuadPart))
    {
        return(FALSE);
    }
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateKrbtgtPassword
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
BOOLEAN
KdcUpdateKrbtgtPassword(
    IN PUNICODE_STRING DnsDomainName,
    IN PLARGE_INTEGER MaxPasswordAge
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR PasswordBuffer[LM20_PWLEN];
    UNICODE_STRING PasswordString;
    ULONG Index;

    BOOLEAN Result = FALSE;


    if (KdcState != Running)
    {
        goto Cleanup;
    }

    //
    // Check the password expiration time.
    //

    if (!KdcTimeHasElapsed(
            SecData.KrbtgtPasswordLastSet(),
            MaxPasswordAge
            ))
    {
        goto Cleanup;
    }


    //
    // Build a random password
    //

    if (!CDGenerateRandomBits(
                (PBYTE) PasswordBuffer,
                sizeof(PasswordBuffer)
                ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Make sure there are no zero characters
    //

    for (Index = 0; Index < LM20_PWLEN ; Index++ )
    {
        if (PasswordBuffer[Index] == 0)
        {
            PasswordBuffer[Index] = (WCHAR) Index;
        }
    }
    PasswordString.Length = sizeof(PasswordBuffer);
    PasswordString.MaximumLength = PasswordString.Length;
    PasswordString.Buffer = PasswordBuffer;

    Status = SamIChangePasswordForeignUser(
                SecData.KdcServiceName(),
                &PasswordString,
                NULL,
                0                       // no desired access
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set KRBTGT password: 0x%x\n", Status));
        Result = FALSE;
        goto Cleanup;
    }

    ReportServiceEvent(
        EVENTLOG_SUCCESS,
        KDCEVENT_KRBTGT_PASSWORD_CHANGED,
        0,                      // no data
        NULL,                   // no data
        0,                      // no strings
        NULL                    // no strings
        );

    Result = TRUE;

Cleanup:

    if (!Result && !NT_SUCCESS(Status))
    {

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            0,                          // no strings
            NULL                        // no strings
            );


    }

    return(Result);
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateNotify
//
//  Synopsis:   This routine is called from SAMSRV in order to obtain
//              new kerberos credentials to be stored as supplemental
//              credentials when ever a user's password is set/changed.
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   ClearPassword      -- the clear text password
//  IN   OldCredentials     -- the previous kerberos credentials
//  IN   OldCredentialsSize -- size of OldCredentials
//  IN   UserAccountControl -- info about the user
//  IN   UPN                -- user principal name of the account
//  IN   UserName           -- the SAM account name of the account
//  IN   DnsDomainName      -- DNS domain name of the account
//  OUT  NewCredentials     -- space allocated for SAM containing
//                             the credentials based on the input parameters
//                             to be freed by CredentialUpdateFree
//  OUT  NewCredentialSize  -- size of NewCredentials
//
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:      KDCSVC.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredentialUpdateNotify (
    IN PUNICODE_STRING ClearPassword,
    IN PVOID OldCredentials,
    IN ULONG OldCredentialsSize,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID *NewCredentials,
    OUT ULONG *NewCredentialsSize
    )
{
    UNREFERENCED_PARAMETER( NetbiosDomainName );

    return KdcBuildKerbCredentialsFromPassword(ClearPassword,
                                               OldCredentials,
                                               OldCredentialsSize,
                                               UserAccountControl,
                                               UPN,
                                               UserName,
                                               DnsDomainName,
                                               NewCredentials,
                                               NewCredentialsSize);

}

VOID
CredentialUpdateFree(
    PVOID p
    )
//
// Free's the memory allocated by CredentialUpdateNotify
//
{
    if (p) {
        KdcFreeCredentials(p);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateRegister
//
//  Synopsis:   This routine is called from SAMSRV in order to obtain
//              the name of the supplemental credentials pass into this package
//              when a password is changed or set.
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  OUT CredentialName -- the name of credential tag in the supplemental
//                        credentials.  Note this memory is never freed
//                        by SAM, but must remain valid for the lifetime
//                        of the process.
//
//  Requires:   no global requirements
//
//  Returns:    TRUE
//
//  Notes:      KDCSVC.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//
//
//--------------------------------------------------------------------------
BOOLEAN
CredentialUpdateRegister(
    OUT UNICODE_STRING *CredentialName
    )
{
    ASSERT(CredentialName);

    RtlInitUnicodeString(CredentialName, MICROSOFT_KERBEROS_NAME_W);

    return TRUE;
}


//
// This compile-time test verifies that CredentialUpdateNotify and
// CredentialUpdateRegister have the correct signature
//
#if DBG
PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE _TestCredentialUpdateNotify
                                                       = CredentialUpdateNotify;
PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE _TestCredentialFreeRegister
                                                     = CredentialUpdateFree;
PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE _TestCredentialUpdateRegister
                                                     = CredentialUpdateRegister;

#endif


#ifdef _WIN64
//
// Routines for packing and unpacking KERB_STORED_CREDENTIAL from DS
//






//+-------------------------------------------------------------------------
//
//  Function:  KdcUnpack32BitStoredCredential
//
//  Synopsis:  This function converts a 32 bit KERB_STORED_CREDENTIAL (read
//             from DS, likely) to a 64 bit KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcUnpack32BitStoredCredential(
    IN PKERB_STORED_CREDENTIAL32 Cred32,
    IN OUT PKERB_STORED_CREDENTIAL * ppCred64,
    IN OUT PULONG pCredLength
    )
{

    PKERB_STORED_CREDENTIAL Cred64 = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CredSize = sizeof(KERB_STORED_CREDENTIAL);
    ULONG CredCount = 0, Cred = 0, Offset = 0;
    PCHAR Where, Base;
    CHAR UNALIGNED * From;

    *pCredLength = 0;
    *ppCred64 = NULL;

    if (NULL == Cred32)
    {
       return STATUS_SUCCESS;
    }

    // Calculate Allocation size
    CredSize += ROUND_UP_COUNT(Cred32->DefaultSalt.MaximumLength, ALIGN_LPTSTR);

    CredSize += ((Cred32->CredentialCount + Cred32->OldCredentialCount) * sizeof(KERB_KEY_DATA));

    for (CredCount = 0; CredCount < (ULONG)(Cred32->CredentialCount + Cred32->OldCredentialCount); CredCount++)
    {
        CredSize += ROUND_UP_COUNT(Cred32->Credentials[CredCount].Key.keyvaluelength, ALIGN_LPTSTR);
        CredSize += ROUND_UP_COUNT(Cred32->Credentials[CredCount].Salt.MaximumLength, ALIGN_LPTSTR);
    }

    Cred64 = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredSize);

    if (NULL == Cred64)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // copy over data, remember, buffers packed in self-relative format
    Cred64->CredentialCount = Cred32->CredentialCount;
    Cred64->OldCredentialCount = Cred32->OldCredentialCount;
    Cred64->DefaultSalt.Length = Cred32->DefaultSalt.Length;
    Cred64->DefaultSalt.MaximumLength = Cred32->DefaultSalt.MaximumLength;
    Cred64->Flags = Cred32->Flags;
    Cred64->Revision = Cred32->Revision;

    Base = (PCHAR)Cred64;

    From = (CHAR UNALIGNED *) RtlOffsetToPointer(Cred32,Cred32->DefaultSalt.Buffer);

    // Note:  1 KERB_KEY_DATA struct is already calculated in
    //        the sizeof(KERB_STORED_CREDENTIAL)
    Offset = sizeof(KERB_STORED_CREDENTIAL) + ((CredCount) * sizeof(KERB_KEY_DATA));

    Where = RtlOffsetToPointer(Cred64, Offset);

    Cred64->DefaultSalt.Buffer = (PWSTR) (ULONG_PTR) Offset;
    RtlCopyMemory(
        Where,
        From,
        Cred32->DefaultSalt.Length
        );

    Where += ROUND_UP_COUNT(Cred64->DefaultSalt.Length, ALIGN_LPTSTR);

    // copy credentials
    for (Cred = 0; Cred < CredCount; Cred++)
    {
        Cred64->Credentials[Cred].Salt.Length = Cred32->Credentials[Cred].Salt.Length;
        Cred64->Credentials[Cred].Salt.MaximumLength = Cred32->Credentials[Cred].Salt.MaximumLength;

        From = (CHAR UNALIGNED *) RtlOffsetToPointer(Cred32, Cred32->Credentials[Cred].Salt.Buffer);
        if (Cred32->Credentials[Cred].Salt.Length != 0)
        {
           Cred64->Credentials[Cred].Salt.Buffer = (PWSTR) (ULONG_PTR) RtlPointerToOffset(Base,Where);
        }

        RtlCopyMemory(
            Where,
            From,
            Cred32->Credentials[Cred].Salt.Length
            );

        Where += ROUND_UP_COUNT(Cred64->Credentials[Cred].Salt.Length, ALIGN_LPTSTR);

        Cred64->Credentials[Cred].Key.keytype = Cred32->Credentials[Cred].Key.keytype;
        Cred64->Credentials[Cred].Key.keyvalue.length = Cred32->Credentials[Cred].Key.keyvaluelength;

        From = RtlOffsetToPointer(Cred32,Cred32->Credentials[Cred].Key.keyvaluevalue);
        Cred64->Credentials[Cred].Key.keyvalue.value = (PUCHAR) (ULONG_PTR) RtlPointerToOffset(Base,Where);

        RtlCopyMemory(
            Where,
            From,
            Cred32->Credentials[Cred].Key.keyvaluelength
            );

        Where += ROUND_UP_COUNT(Cred32->Credentials[Cred].Key.keyvaluelength, ALIGN_LPTSTR);
    }


    // TBD:  Validation code ?

   *ppCred64 = Cred64;
   *pCredLength = CredSize;

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:  KdcPack32BitStoredCredential
//
//  Synopsis:  This function converts a 64 bit KERB_STORED_CREDENTIAL
//             to a 32 bit KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Free the return value using MIDL_user_free()
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcPack32BitStoredCredential(
   IN PKERB_STORED_CREDENTIAL Cred64,
   OUT PKERB_STORED_CREDENTIAL32 * ppCred32,
   OUT PULONG pCredSize
   )
{

   ULONG Offset, CredSize = sizeof(KERB_STORED_CREDENTIAL32);
   ULONG CredCount, Cred;
   NTSTATUS Status = STATUS_SUCCESS;
   PKERB_STORED_CREDENTIAL32 Cred32 = NULL;
   PCHAR Where, From, Base;

   *ppCred32 = NULL;
   *pCredSize = 0;

   if (Cred64 == NULL)
   {
       return STATUS_SUCCESS;
   }

   // Get the expected size of the resultant blob
   CredSize += ((Cred64->CredentialCount + Cred64->OldCredentialCount) *
                  KERB_KEY_DATA32_SIZE);


   CredSize += Cred64->DefaultSalt.MaximumLength;
   for (CredCount = 0;
        CredCount < (ULONG) (Cred64->CredentialCount+Cred64->OldCredentialCount);
        CredCount++)
   {
      CredSize += Cred64->Credentials[CredCount].Salt.MaximumLength;
      CredSize += Cred64->Credentials[CredCount].Key.keyvalue.length;
   }

   Cred32 = (PKERB_STORED_CREDENTIAL32) MIDL_user_allocate(CredSize);

   if (NULL == Cred32)
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   Base = (PCHAR) Cred32;

   // Copy over USHORTS
   Cred32->Revision = Cred64->Revision;
   Cred32->Flags = Cred64->Flags;
   Cred32->CredentialCount = Cred64->CredentialCount;
   Cred32->OldCredentialCount = Cred64->OldCredentialCount;

   // Copy over salt
   Cred32->DefaultSalt.Length = Cred64->DefaultSalt.Length;
   Cred32->DefaultSalt.MaximumLength = Cred64->DefaultSalt.MaximumLength;

   Offset = KERB_STORED_CREDENTIAL32_SIZE + ((CredCount+1) * KERB_KEY_DATA32_SIZE);

   Where = RtlOffsetToPointer(Base,Offset);
   From = RtlOffsetToPointer(Cred64, Cred64->DefaultSalt.Buffer);
   Cred32->DefaultSalt.Buffer = RtlPointerToOffset(Base,Where);

   RtlCopyMemory(
         Where,
         From,
         Cred64->DefaultSalt.Length
         );

   Where += Cred64->DefaultSalt.Length;

   // Copy over creds (KERB_KEY_DATA)
   for (Cred = 0; Cred < CredCount;Cred++)
   {
      Cred32->Credentials[Cred].Salt.Length = Cred64->Credentials[Cred].Salt.Length;
      Cred32->Credentials[Cred].Salt.MaximumLength = Cred64->Credentials[Cred].Salt.MaximumLength;
      From = RtlOffsetToPointer(Cred64, Cred64->Credentials[Cred].Salt.Buffer);

      // Only add in buffer pointer if there's data to copy.
      if (Cred32->Credentials[Cred].Salt.Length != 0)
      {
         Cred32->Credentials[Cred].Salt.Buffer = RtlPointerToOffset(Base,Where);
      }

      RtlCopyMemory(
            Where,
            From,
            Cred64->Credentials[Cred].Salt.Length
            );

      Where += Cred64->Credentials[Cred].Salt.Length;

      // Keys
      Cred32->Credentials[Cred].Key.keytype = Cred64->Credentials[Cred].Key.keytype ;
      Cred32->Credentials[Cred].Key.keyvaluelength = Cred64->Credentials[Cred].Key.keyvalue.length;
      From = RtlOffsetToPointer(Cred64, Cred64->Credentials[Cred].Key.keyvalue.value);

      RtlCopyMemory(
            Where,
            From,
            Cred64->Credentials[Cred].Key.keyvalue.length
            );

      Cred32->Credentials[Cred].Key.keyvaluevalue = RtlPointerToOffset(Base,Where);
      Where += Cred64->Credentials[Cred].Key.keyvalue.length;
   }

   *ppCred32 = Cred32;
   *pCredSize = CredSize;

   return STATUS_SUCCESS;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\pkserv.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.h
//
// Contents:    types and prototypes for pk authentication
//
//
// History:     1-Dec-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __PKSERV_H__
#define __PKSERV_H__


KERBERR
KdcCheckPkinitPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY ClientRequest,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealm,
    OUT PKERB_EXT_ERROR pExtendedError
    );

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    );

NTSTATUS
KdcInitializeCerts(
    VOID
    );

VOID
KdcCleanupCerts(
    IN BOOLEAN CleanupScavenger
    );




#endif // __PKSERV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\pac.cxx ===
//+-----------------------------------------------------------------------
//
// File:        pac.cxx
//
// Contents:    KDC Pac generation code.
//
//
// History:     16-Jan-93   WadeR   Created.
//
//------------------------------------------------------------------------



#include "kdcsvr.hxx"
#include <pac.hxx>
#include "kdctrace.h"
#include "fileno.h"
#include <userall.h>

#define FILENO FILENO_GETAS
SECURITY_DESCRIPTOR AuthenticationSD;

#ifndef DONT_SUPPORT_OLD_TYPES
#define KDC_PAC_KEYTYPE         KERB_ETYPE_RC4_HMAC_OLD
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5
#else
#define KDC_PAC_KEYTYPE         KERB_ETYPE_RC4_HMAC
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5
#endif


//+-------------------------------------------------------------------------
//
//  Function:   EnterApiCall
//
//  Synopsis:   Makes sure that the KDC service is initialized and running
//              and won't terminate during the call.
//
//  Effects:    increments the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_INVALID_SERVER_STATE - the KDC service is not
//                      running
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
EnterApiCall(
    VOID
    )
{
    NTSTATUS hrRet = STATUS_SUCCESS;
    EnterCriticalSection(&ApiCriticalSection);
    if (KdcState != Stopped)
    {
        CurrentApiCallers++;
    }
    else
    {
        hrRet = STATUS_INVALID_SERVER_STATE;
    }
    LeaveCriticalSection(&ApiCriticalSection);
    return(hrRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LeaveApiCall
//
//  Synopsis:   Decrements the count of active calls and if the KDC is
//              shutting down sets an event to let it continue.
//
//  Effects:    Deccrements the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
LeaveApiCall(
    VOID
    )
{
    NTSTATUS hrRet = S_OK;
    EnterCriticalSection(&ApiCriticalSection);
    CurrentApiCallers--;

    if (KdcState == Stopped)
    {
        if (CurrentApiCallers == 0)
        {
            if (!SetEvent(hKdcShutdownEvent))
            {
                D_DebugLog((DEB_ERROR,"Failed to set shutdown event from LeaveApiCall: 0x%d\n",GetLastError()));
            }
            else
            {
                UpdateStatus(SERVICE_STOP_PENDING);
            }

            //
            // Free any DS libraries in use
            //

            SecData.Cleanup();
            if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
            {
                UnregisterTraceGuids( KdcTraceRegistrationHandle );
            }

        }

    }
    LeaveCriticalSection(&ApiCriticalSection);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertPacIntoAuthData
//
//  Synopsis:   Inserts the PAC into the auth data in the two places
//              it lives - in the IF_RELEVANT portion & in the outer body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    IN PKERB_IF_RELEVANT_AUTH_DATA IfRelevantData,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA LocalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA LocalIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewPacData = NULL;
    KERB_AUTHORIZATION_DATA TempPacData = {0};
    PKERB_AUTHORIZATION_DATA NewAuthData = NULL;
    KERB_AUTHORIZATION_DATA TempOldPac = {0};
    PKERB_AUTHORIZATION_DATA TempNextPointer,NextPointer;


    NewPacData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    NewIfRelevantData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));

    if ((NewPacData == NULL) || (NewIfRelevantData == NULL))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        NewPacData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );

    RtlZeroMemory(
        NewIfRelevantData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );


    //
    // First build the IfRelevantData
    //
    // The general idea is to replace, in line, the relevant authorization
    // data. This means (a) putting it into the IfRelevantData or making
    // the IfRelevantData be PacAuthData, and (b) putting it into AuthData
    // as well as changing the IfRelevant portions of that data
    //

    if (IfRelevantData != NULL)
    {
        LocalAuthData = KerbFindAuthDataEntry(
                            KERB_AUTH_DATA_PAC,
                            IfRelevantData
                            );
        if (LocalAuthData == NULL)
        {
            LocalIfRelevantData = PacAuthData;
            PacAuthData->next = IfRelevantData;
        }
        else
        {
            //
            // Replace the pac in the if-relevant list with the
            // new one.
            //
            TempOldPac = *LocalAuthData;
            LocalAuthData->value.auth_data.value = PacAuthData->value.auth_data.value;
            LocalAuthData->value.auth_data.length = PacAuthData->value.auth_data.length;

            LocalIfRelevantData = IfRelevantData;

        }
    }
    else
    {
        //
        // build a new if-relevant data
        //

        TempPacData = *PacAuthData;
        TempPacData.next = NULL;
        LocalIfRelevantData = &TempPacData;
    }

    //
    // Build a local if-relevant auth data
    //

    KerbErr = KerbPackData(
                &LocalIfRelevantData,
                PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                (PULONG) &NewIfRelevantData->value.auth_data.length,
                &NewIfRelevantData->value.auth_data.value
                );

    //
    // fixup the old if-relevant list, if necessary
    //

    if (TempOldPac.value.auth_data.value != NULL)
    {
        *LocalAuthData = TempOldPac;
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    NewIfRelevantData->value.auth_data_type = KERB_AUTH_DATA_IF_RELEVANT;

    *NewPacData = *PacAuthData;

    //
    // Zero this out so the old data doesn't get used
    //

    PacAuthData->value.auth_data.value = NULL;
    PacAuthData->value.auth_data.length = 0;

    //
    // Now we have a new if_relevant & a new pac for the outer auth-data list.
    //

    NewAuthData = NewIfRelevantData;
    NewIfRelevantData->next = NULL;
    NewIfRelevantData = NULL;

    //
    // Start building the list, first putting the non-pac entries at the end
    //

    NextPointer = AuthData;
    while (NextPointer != NULL)

    {
        if ((NextPointer->value.auth_data_type != KERB_AUTH_DATA_IF_RELEVANT) &&
            (NextPointer->value.auth_data_type != KERB_AUTH_DATA_PAC))
        {
            TempNextPointer = NextPointer->next;
            NextPointer->next = NULL;

            KerbErr = KerbCopyAndAppendAuthData(
                        &NewAuthData,
                        NextPointer
                        );
            NextPointer->next = TempNextPointer;
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }
        NextPointer = NextPointer->next;
    }
    *UpdatedAuthData = NewAuthData;
    NewAuthData = NULL;

Cleanup:
    if (NewPacData != NULL)
    {
        KerbFreeAuthData(NewPacData);
    }
    if (NewIfRelevantData != NULL)
    {
        KerbFreeAuthData(NewIfRelevantData);
    }
    if (NewAuthData != NULL)
    {
        KerbFreeAuthData(NewAuthData);
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPacSidList
//
//  Synopsis:   Builds a list of SIDs in the PAC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    OUT PSAMPR_PSID_ARRAY Sids
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Size = 0, i;

    Sids->Count = 0;
    Sids->Sids = NULL;


    if (UserInfo->UserId != 0)
    {
        Size += sizeof(SAMPR_SID_INFORMATION);
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);


    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }



    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL ) {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );


    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        Sids->Sids[0].SidPointer = (PRPC_SID)
                KerbMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                            UserInfo->UserId );

        if( Sids->Sids[0].SidPointer == NULL ) {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Sids->Count++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        Sids->Sids[Sids->Count].SidPointer = (PRPC_SID)
                                    KerbMakeDomainRelativeSid(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( Sids->Sids[Sids->Count].SidPointer == NULL ) {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;
    }


    //
    // Add in the extra SIDs
    //

    //
    // No need to allocate these, but...
    //
    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {


        for ( i = 0; i < UserInfo->SidCount; i++ ) {


            if (!NT_SUCCESS(KerbDuplicateSid(
                                (PSID *) &Sids->Sids[Sids->Count].SidPointer,
                                UserInfo->ExtraSids[i].Sid
                                )))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }


            Sids->Count++;
        }
    }


    //
    // Deallocate any memory we've allocated
    //

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        if (Sids->Sids != NULL)
        {
            for (i = 0; i < Sids->Count ;i++ )
            {
                if (Sids->Sids[i].SidPointer != NULL)
                {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }
            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
    }
    return KerbErr;

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAddResourceGroupsToPac
//
//  Synopsis:   Queries SAM for resources grousp and builds a new PAC with
//              those groups
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcAddResourceGroupsToPac(
    IN PPACTYPE OldPac,
    IN ULONG ChecksumSize,
    OUT PPACTYPE * NewPac
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER LogonInfo;
    ULONG Index;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;


    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );
    if (LogonInfo == NULL)
    {
        D_DebugLog((DEB_WARN,"No logon info for PAC - not adding resource groups\n"));
        goto Cleanup;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //


    if (!NT_SUCCESS(PAC_UnmarshallValidationInfo(
                        &ValidationInfo,
                        LogonInfo->Data,
                        LogonInfo->cbBufferSize)))
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info!\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KdcBuildPacSidList(
                ValidationInfo,
                &SidList
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                GlobalAccountDomainHandle,
                &SidList,
                0,              // no flags
                &ResourceGroups
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get resource groups: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                ResourceGroups,
                OldPac,
                NewPac
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:
    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }
    if (SidList.Sids != NULL)
    {
        for (Index = 0; Index < SidList.Count ;Index++ )
        {
            if (SidList.Sids[Index].SidPointer != NULL)
            {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }
        MIDL_user_free(SidList.Sids);
    }
    SamIFreeSidArray(
        ResourceGroups
        );
    return(KerbErr);

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcSignPac
//
//  Synopsis:   Signs a PAC by first checksumming it with the
//              server's key and then signing that with the KDC key.
//
//  Effects:    Modifies the server sig & privsvr sig fields of the PAC
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              PacData - An marshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcSignPac(
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN BOOLEAN AddResourceGroups,
    IN OUT PUCHAR * PacData,
    IN PULONG PacSize
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PPAC_INFO_BUFFER ServerBuffer;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA ServerSignature;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    PKERB_ENCRYPTION_KEY EncryptionKey;
    PPACTYPE Pac, NewPac = NULL;
    ULONG LocalPacSize;
    KDC_TICKET_INFO KdcTicketInfo = {0};

    TRACE(KDC, KdcSignPac, DEB_FUNCTION);

    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                KDC_PAC_CHECKSUM,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    // Unmarshal the PAC in place so we can locate the signatuer buffers
    //


    Pac = (PPACTYPE) *PacData;
    LocalPacSize = *PacSize;
    if (PAC_UnMarshal(Pac, LocalPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we are to add local groups, do so now
    //

    if (AddResourceGroups)
    {
        KerbErr = KdcAddResourceGroupsToPac(
                    Pac,
                    Check->CheckSumSize,
                    &NewPac
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        Pac = NewPac;
        LocalPacSize = PAC_GetSize(Pac);
    }


    //
    // Locate the signature buffers so the signature fields can be zeroed out
    // before computing the checksum.
    //

    ServerBuffer = PAC_Find(Pac, PAC_SERVER_CHECKSUM, NULL );
    DsysAssert(ServerBuffer != NULL);
    if (ServerBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;
    ServerSignature->SignatureType = KDC_PAC_CHECKSUM;

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if (PrivSvrBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    PrivSvrSignature->SignatureType = KDC_PAC_CHECKSUM;

    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshall the PAC to compute the checksum.
    //

    if (!PAC_ReMarshal(Pac, LocalPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the whole PAC.
    //


    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    NULL,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        LocalPacSize,
        (PUCHAR) Pac
        );
    Check->Finalize(
        CheckBuffer,
        ServerSignature->Signature
        );
    Check->Finish(
        &CheckBuffer
        );

    //
    // Now we've compute the server checksum - next compute the checksum
    // of the server checksum using the KDC account.
    //


    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }



    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    NULL,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        Check->CheckSumSize,
        ServerSignature->Signature
        );
    Check->Finalize(
        CheckBuffer,
        PrivSvrSignature->Signature
        );
    Check->Finish(
        &CheckBuffer
        );

    if (*PacData != (PBYTE) Pac)
    {
        MIDL_user_free(*PacData);
        *PacData = (PBYTE) Pac;
        *PacSize = LocalPacSize;
    }
Cleanup:
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }
    if (!KERB_SUCCESS(KerbErr) && (NewPac != NULL))
    {
        MIDL_user_free(NewPac);
    }
    FreeTicketInfo(&KdcTicketInfo);

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPacSignature
//
//  Synopsis:   Verifies a PAC by checksumming it and comparing the result
//              with the server checksum. In addition, if the pac wasn't
//              created by another realm (server ticket info is not
//              an interdomain account) verify the KDC signature on the
//              pac.
//
//  Effects:
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              Pac - An unmarshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyPacSignature(
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN PKDC_TICKET_INFO ServerInfo,
    IN ULONG PacSize,
    IN PUCHAR PacData
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    PPAC_INFO_BUFFER ServerBuffer;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA ServerSignature;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    PPAC_INFO_BUFFER LogonInfo;
    UCHAR LocalChecksum[20];
    UCHAR LocalServerChecksum[20];
    UCHAR LocalPrivSvrChecksum[20];
    PPACTYPE Pac;
    KDC_TICKET_INFO KdcTicketInfo = {0};

    TRACE(KDC, KdcVerifyPacSignature, DEB_FUNCTION);

    Pac = (PPACTYPE) PacData;

    if (PAC_UnMarshal(Pac, PacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Locate the two signatures, copy the checksum, and zero the value
    // so the checksum won't include the old checksums.
    //

    ServerBuffer = PAC_Find(Pac, PAC_SERVER_CHECKSUM, NULL );
    DsysAssert(ServerBuffer != NULL);
    if ((ServerBuffer == NULL) || (ServerBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;

    RtlCopyMemory(
        LocalServerChecksum,
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if ((PrivSvrBuffer == NULL) || (PrivSvrBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;

    RtlCopyMemory(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Remarshal the pac so we can checksum it.
    //

    if (!PAC_ReMarshal(Pac, PacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the validation information using the server's key.
    //

    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                ServerSignature->SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    LocalServerChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        PacSize,
        PacData
        );
    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );
    Check->Finish(
        &CheckBuffer
        );

    if (Check->CheckSumSize != PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize) ||
        !RtlEqualMemory(
            LocalChecksum,
            LocalServerChecksum,
            Check->CheckSumSize))
    {
        DebugLog((DEB_ERROR, "Pac was modified - server checksum doesn't match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

    //
    // If the service wasn't the KDC and it wasn't an interdomain account
    // verify the KDC checksum.
    //

    if ((ServerInfo->UserId == DOMAIN_USER_RID_KRBTGT) ||
        ((ServerInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0))
    {
        goto Cleanup;
    }


    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }


    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                PrivSvrSignature->SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    LocalPrivSvrChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        Check->CheckSumSize,
        ServerSignature->Signature
        );
    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );
    Check->Finish(
        &CheckBuffer
        );

    if ((Check->CheckSumSize != PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)) ||
        !RtlEqualMemory(
            LocalChecksum,
            LocalPrivSvrChecksum,
            Check->CheckSumSize))
    {                             
        DebugLog((DEB_ERROR, "Pac was modified - privsvr checksum doesn't match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }


Cleanup:


    if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        LPWSTR AccountName = NULL;
        AccountName = (LPWSTR) MIDL_user_allocate(ServerInfo->AccountName.Length + sizeof(WCHAR));
        //          
        // if the allocation fails don't log the name (leave it NULL)
        //               
        if (NULL != AccountName)
        {
            RtlCopyMemory(
                AccountName,
                ServerInfo->AccountName.Buffer,
                ServerInfo->AccountName.Length
                );
        }

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            sizeof(ULONG),                              
            &KerbErr,
            1,
            AccountName
            );

        if (NULL != AccountName)
        {
            MIDL_user_free(AccountName);
        }
    }

    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }
    FreeTicketInfo(&KdcTicketInfo);

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Name:       KdcGetPacAuthData
//
//  Synopsis:   Creates a PAC for the specified client, encrypts it with the
//              server's key, and packs it into a KERB_AUTHORIZATON_DATA
//
//  Arguments:  UserInfo - Information about user
//              GroupMembership - Users group memberships
//              ServerKey - Key of server, used for signing
//              CredentialKey - if present & valid, used to encrypt supp. creds
//              AddResourceGroups - if TRUE, resources groups will be included
//              EncryptedTicket - Optional ticke to tie PAC to
//              PacAuthData - Receives a KERB_AUTHORIZATION_DATA of type
//                      KERB_AUTH_DATA_PAC, containing a PAC.
//
//  Notes:      PacAuthData should be freed with KerbFreeAuthorizationData.
//
//+---------------------------------------------------------------------------

KERBERR
KdcGetPacAuthData(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PSID_AND_ATTRIBUTES_LIST GroupMembership,
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    IN BOOLEAN AddResourceGroups,
    IN PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    OUT PKERB_AUTHORIZATION_DATA * PacAuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PACTYPE *pNewPac = NULL;
    KERB_AUTHORIZATION_DATA AuthorizationData = {0};
    ULONG PacSize, NameType;
    PCHECKSUM_FUNCTION Check;
    NTSTATUS Status;
    UNICODE_STRING ClientName = {0};
    PKERB_INTERNAL_NAME KdcName = NULL;
    TimeStamp ClientId;

    TRACE(KDC, KdcGetPacAuthData, DEB_FUNCTION);

    Status = CDLocateCheckSum(
                KDC_PAC_CHECKSUM,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientId,
        &EncryptedTicket->authtime,
        0                               // no usec
        );



    //
    // Put the S4U client in the pac verifier.
    //
    if (ARGUMENT_PRESENT(S4UClientName))
    {
    
        KerbErr = KerbConvertKdcNameToString(
                        &ClientName,
                        S4UClientName,
                        NULL
                        );

    }
    else // use the ticket
    {

        KerbErr = KerbConvertPrincipalNameToString(
                            &ClientName,
                            &NameType,
                            &EncryptedTicket->client_name
                            );
    }
                              
    
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = GetPacAndSuppCred(
                UserInfo,
                GroupMembership,
                Check->CheckSumSize,            // leave space for signature
                CredentialKey,
                &ClientId,
                &ClientName,
                &pNewPac,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog(( DEB_WARN,
            "GetPAC: Can't get PAC or supp creds: 0x%x \n", KerbErr ));
        goto Cleanup;
    }


    //
    //  The PAC is going to be double-encrypted.  This is done by having the
    //  PAC in an EncryptedData, and having that EncryptedData in a AuthData
    //  as part of an AuthDataList (along with the rest of the supp creds).
    //  Finally, the entire list is encrypted.
    //
    //      KERB_AUTHORIZATION_DATA containing {
    //              PAC
    //
    //      }
    //


    //
    // First build inner encrypted data
    //


    PacSize = PAC_GetSize( pNewPac );


    AuthorizationData.value.auth_data_type = KERB_AUTH_DATA_PAC;
    AuthorizationData.value.auth_data.length = PacSize;
    AuthorizationData.value.auth_data.value = (PUCHAR) MIDL_user_allocate(PacSize);
    if (AuthorizationData.value.auth_data.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PAC_Marshal( pNewPac, PacSize, AuthorizationData.value.auth_data.value );

    //
    // Compute the signatures
    //

    KerbErr = KdcSignPac(
                ServerKey,
                AddResourceGroups,
                &AuthorizationData.value.auth_data.value,
                (PULONG) &AuthorizationData.value.auth_data.length
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Create the auth data to return
    //

    KerbErr = KdcInsertPacIntoAuthData(
                    NULL,               // no original auth data
                    NULL,               // no if-relevant auth data
                    &AuthorizationData,
                    PacAuthData
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to insert pac into new auth data: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (AuthorizationData.value.auth_data.value != NULL)
    {
        MIDL_user_free(AuthorizationData.value.auth_data.value);
    }

    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }


    KerbFreeString(&ClientName);
    KerbFreeKdcName(&KdcName);
    return(KerbErr);

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcGetUserPac
//
//  Synopsis:   Function for external users to get the PAC for a user
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
KdcGetUserPac(
    IN PUNICODE_STRING UserName,
    OUT PPACTYPE * Pac,
    OUT PUCHAR * SupplementalCredentials,
    OUT PULONG SupplementalCredSize,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KDC_TICKET_INFO TicketInfo;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST GroupMembership;
    NTSTATUS Status;
    KERBERR KerbErr;


    TRACE(KDC, KdcGetUserPac, DEB_FUNCTION);

    *SupplementalCredentials = NULL;
    *SupplementalCredSize = 0;

    RtlZeroMemory(
        &TicketInfo,
        sizeof(KDC_TICKET_INFO)
        );
    RtlZeroMemory(
        &GroupMembership,
        sizeof(SID_AND_ATTRIBUTES_LIST)
        );


    Status = EnterApiCall();
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // Get the account information
    //

    KerbErr = KdcGetTicketInfo(
                UserName,
                0,                      // no flags
                NULL,                   // no principal name
                NULL,                   // no realm
                &TicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                USER_ALL_GET_PAC_AND_SUPP_CRED,
                0L,                     // no extended fields
                &UserInfo,
                &GroupMembership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"Failed to get ticket info for user %wZ: 0x%x\n",
                  UserName->Buffer, KerbErr));
        Status = KerbMapKerbError(KerbErr);

        goto Cleanup;
    }

    //
    // Now get the PAC and supplemental credentials
    //

    KerbErr = GetPacAndSuppCred(
                UserInfo,
                &GroupMembership,
                0,              // no signature space
                NULL,           // no credential key
                NULL,           // no client ID
                NULL,           // no client name
                Pac,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to get PAC for user %wZ : 0x%x\n",
                  UserName->Buffer,KerbErr));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:

    SamIFree_UserInternal6Information( UserInfo );
    SamIFreeSidAndAttributesList(&GroupMembership);
    FreeTicketInfo(&TicketInfo);

    LeaveApiCall();

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPac
//
//  Synopsis:   Function for kerberos to pass through a pac signature
//              to be verified.
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
KdcVerifyPac(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    )
{
    NTSTATUS Status;
    KERBERR KerbErr;
    PCHECKSUM_FUNCTION Check;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    UCHAR LocalChecksum[20];
    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    KDC_TICKET_INFO KdcTicketInfo = {0};

    TRACE(KDC, KdcVerifyPac, DEB_FUNCTION);

    Status = EnterApiCall();
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }

    Status = CDLocateCheckSum(
                SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    Signature,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;

    }
    Check->Sum(
        CheckBuffer,
        ChecksumSize,
        Checksum
        );
    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );

    Check->Finish(&CheckBuffer);

    //
    // Now compare the local checksum to the supplied checksum.
    //

    if (Check->CheckSumSize != SignatureSize)
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature,
            Check->CheckSumSize
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on the PAC does not match!\n"));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

Cleanup:

    if (Status == STATUS_LOGON_FAILURE)
    {
        PUNICODE_STRING OwnName = NULL;
        //
        // since this call should only be made by pass through callback
        // this signature should be our own
        //
        OwnName = SecData.KdcFullServiceDnsName();

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            0,                              
            NULL,
            1,                              // number of strings
            OwnName->Buffer
            );

    }         

    FreeTicketInfo(&KdcTicketInfo);
    LeaveApiCall();

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacForSidFiltering
//
//  Synopsis:   If the server ticket info has a TDOSid then the function
//              makes a check to make sure the SID from the TDO matches
//              the client's home domain SID.  A call to LsaIFilterSids
//              is made to do the check.  If this function fails with
//              STATUS_TRUST_FAILURE then an audit log is generated.
//              Otherwise the function succeeds but SIDs are filtered
//              from the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPacForSidFiltering(
    IN PKDC_TICKET_INFO ServerInfo,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER LogonInfo;
    PPACTYPE OldPac;
    ULONG OldPacSize;
    PPACTYPE NewPac = NULL;
    ULONG LocalPacSize;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY ZeroResourceGroups;
    PUNICODE_STRING TrustedForest = NULL;

    if (NULL != ServerInfo->TrustSid)
    {
        OldPac = (PPACTYPE) *PacData;
        OldPacSize = *PacSize;
        if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        RtlZeroMemory(
            &ZeroResourceGroups,
            sizeof(ZeroResourceGroups));  // allows us to use PAC_InitAndUpdateGroups to remarshal the PAC

        //
        // First, find the logon information
        //

        LogonInfo = PAC_Find(
                        OldPac,
                        PAC_LOGON_INFO,
                        NULL
                        );
        if (LogonInfo == NULL)
        {
            D_DebugLog((DEB_WARN,"No logon info for PAC - not making SID filtering check\n"));
            goto Cleanup;
        }

        //
        // Now unmarshall the validation information and build a list of sids
        //


        if (!NT_SUCCESS(PAC_UnmarshallValidationInfo(
                            &ValidationInfo,
                            LogonInfo->Data,
                            LogonInfo->cbBufferSize)))
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info!\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Assumption is that if the Trust SID is in the ServerInfo then this is an
        // outbound trust with the TRUST_ATTRIBUTE_FILTER_SIDS bit set.
        //
        if ((ServerInfo->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)
        {
            TrustedForest = &(ServerInfo->TrustedForest);
            DebugLog((DEB_TRACE, "Filtering Sids for forest %wZ\n", TrustedForest));
        }    

        Status = LsaIFilterSids(
                    TrustedForest,           // Pass domain name here
                    TRUST_DIRECTION_OUTBOUND,
                    TRUST_TYPE_UPLEVEL,
                    ServerInfo->TrustAttributes,
                    ServerInfo->TrustSid,
                    NetlogonValidationSamInfo2,
                    ValidationInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            //
            // Create an audit log if it looks like the SID has been tampered with
            //

            if ((STATUS_DOMAIN_TRUST_INCONSISTENT == Status) &&
                SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
            {
                DWORD Dummy = 0;

                KdcLsaIAuditKdcEvent(
                     SE_AUDITID_TGS_TICKET_REQUEST,
                     &ValidationInfo->EffectiveName,
                     &ValidationInfo->LogonDomainName,
                     NULL,
                     &ServerInfo->AccountName,
                     NULL,
                     &Dummy,
                     (PULONG) &Status,
                     NULL,
                     NULL,                               // no preauth type
                     GET_CLIENT_ADDRESS(NULL),
                     NULL                                // no logon guid
                     );

            }

            DebugLog((DEB_ERROR,"Failed to filter SIDS (LsaIFilterSids): 0x%x\n",Status));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now build a new pac
        //

        Status = PAC_InitAndUpdateGroups(
                    ValidationInfo,
                    &ZeroResourceGroups,
                    OldPac,
                    &NewPac
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        LocalPacSize = PAC_GetSize(NewPac);
        if (!PAC_ReMarshal(NewPac, LocalPacSize))
        {
            DsysAssert(!"PAC_Remarshal Failed");
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        if (*PacData != (PBYTE)NewPac)
        {
            MIDL_user_free(*PacData);
            *PacData = (PBYTE) NewPac;
            NewPac = NULL;
            *PacSize = LocalPacSize;
        }
    }
Cleanup:
    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }
    return(KerbErr);

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyAndResignPac
//
//  Synopsis:   Verifies the signature on a PAC and re-signs it with the
//              new servers & kdc's key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyAndResignPac(
    IN PKERB_ENCRYPTION_KEY OldKey,
    IN PKERB_ENCRYPTION_KEY NewKey,
    IN PKDC_TICKET_INFO OldServerInfo,
    IN BOOLEAN AddResourceGroups,
    IN OUT PKERB_AUTHORIZATION_DATA PacAuthData
    )
{
    PPAC_SIGNATURE_DATA ServerSignature;
    ULONG ServerSiganatureSize;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    ULONG PrivSvrSiganatureSize;
    KERBERR KerbErr = KDC_ERR_NONE;

    TRACE(KDC, KdcVerifyAndResignPac, DEB_FUNCTION);


    //
    // Now verify the existing signature
    //

    KerbErr = KdcVerifyPacSignature(
                OldKey,
                OldServerInfo,
                PacAuthData->value.auth_data.length,
                PacAuthData->value.auth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Perform SID filtering if necessary
    //
    KerbErr = KdcCheckPacForSidFiltering(
                OldServerInfo,
                &PacAuthData->value.auth_data.value,
                (PULONG) &PacAuthData->value.auth_data.length
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now resign the PAC. If we add new sig algs, then we may need to
    // address growing sigs, but for now, its all KDC_PAC_CHECKSUM
    //

    KerbErr = KdcSignPac(
                NewKey,
                AddResourceGroups,
                &PacAuthData->value.auth_data.value,
                (PULONG) &PacAuthData->value.auth_data.length
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    return(KerbErr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\rpcif.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcif.h
//
// Contents:    RPC interface support functions
//
//
// History:     20-May-1996     Labeled         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCIF_H__
#define __RPCIF_H__

// #define USE_SECURE_RPC

#define MAX_CONCURRENT_CALLS 10

NTSTATUS   StartRPC(LPTSTR, LPTSTR);
NTSTATUS   StartAllProtSeqs(void);
NTSTATUS   StopRPC(void);
NTSTATUS   SetAuthData();
NTSTATUS RegisterKdcEps();
NTSTATUS UnRegisterKdcEps();

NTSTATUS   RpcTransportNameRegister();
NTSTATUS   RpcTransportNameDeRegister();
BOOLEAN    RpcTransportCheckRegistrations();
LPSTR   RpcString(LPSTR);
SECURITY_STATUS   RPC_SECNTSTATUS(ULONG);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\refer.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.cxx
//
// Contents:    Routines for interdomain referrals
//
//
// History:     26-Nov-1996     MikeSw          Created
//
// Notes:       The list of domains could be kept as a splay tree for faster
//              searches & inserts.
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <lsarpc.h>
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
}


LIST_ENTRY KdcDomainList;
RTL_CRITICAL_SECTION KdcDomainListLock;
BOOLEAN KdcDomainListInitialized = FALSE;

LIST_ENTRY KdcReferralCache;
RTL_CRITICAL_SECTION KdcReferralCacheLock;
BOOLEAN KdcReferralCacheInitialized = FALSE;
UNICODE_STRING KdcForestRootDomainName = {0};

#define KdcLockDomainList() (RtlEnterCriticalSection(&KdcDomainListLock))
#define KdcUnlockDomainList() (RtlLeaveCriticalSection(&KdcDomainListLock))

#define KdcLockReferralCache() (RtlEnterCriticalSection(&KdcReferralCacheLock))
#define KdcUnlockReferralCache() (RtlLeaveCriticalSection(&KdcReferralCacheLock))

#define KdcReferenceDomainInfo(_x_) \
    InterlockedIncrement(&(_x_)->References)

#define KdcReferenceReferralCacheEntry(_x_) \
    InterlockedIncrement(&(_x_)->References)

// temp #defines
#define NEW_KDCEVENT_TRUSTLIST_LOOP 0xC000000C
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#define FILENO FILENO_REFER
//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcDereferenceReferralCacheEntry(
    IN PREFERRAL_CACHE_ENTRY CacheEntry
    )
{
    if (InterlockedDecrement(&CacheEntry->References) == 0)
    {
       KdcLockReferralCache();
       CacheEntry->ListEntry.Blink->Flink = CacheEntry->ListEntry.Flink;
       CacheEntry->ListEntry.Flink->Blink = CacheEntry->ListEntry.Blink;
       KdcUnlockReferralCache();

       KerbFreeString(&CacheEntry->RealmName);
       MIDL_user_free(CacheEntry);
    }                             

}






//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcAddReferralCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG CacheFlags
    )
{
    
    PREFERRAL_CACHE_ENTRY CacheEntry = NULL;
    KERBERR KerbErr; 
    TimeStamp CurrentTime;


    CacheEntry = (PREFERRAL_CACHE_ENTRY) MIDL_user_allocate(sizeof(REFERRAL_CACHE_ENTRY));
    if (NULL == CacheEntry)
    {
        // We're low on memory, non-fatal
        return KRB_ERR_GENERIC;
    }  
    
    KerbErr = KerbDuplicateString(
                &(CacheEntry->RealmName),
                RealmName
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        MIDL_user_free(CacheEntry);
        return KerbErr;
    }

    CacheEntry->CacheFlags = CacheFlags;
 
    // Set cache timeout == 10 minutes 
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    CacheEntry->EndTime.QuadPart = CurrentTime.QuadPart + (LONGLONG) 60*10*10000000; 
    
        
    InterlockedIncrement(&CacheEntry->References);
    
    
    KdcLockReferralCache();
    InsertHeadList(
        &KdcReferralCache,
        &(CacheEntry->ListEntry)                 
        );

    KdcUnlockReferralCache();

    DebugLog((DEB_TRACE, "Added referal cache entry - %wZ State: %x\n",
              RealmName, CacheFlags));


    return KerbErr;

}   



//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcLocateReferralCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG NewFlags,
    OUT PULONG CacheState
    )
{
 
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PREFERRAL_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN ListLocked = FALSE;
    BOOLEAN Found = FALSE;
    
    *CacheState = KDC_NO_ENTRY;
    KdcLockReferralCache();
    ListLocked = TRUE;

    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = KdcReferralCache.Flink ;
         ListEntry !=  KdcReferralCache.Blink ;
         ListEntry = ListEntry->Flink )
   {
        CacheEntry = CONTAINING_RECORD(ListEntry, REFERRAL_CACHE_ENTRY, ListEntry.Flink);
        
        if (RtlEqualUnicodeString(
            &CacheEntry->RealmName,
            RealmName,
            TRUE // case insensitive
            ))
        {   
            TimeStamp CurrentTime;
            GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );
            
            //
            // Update the flags & time on this cache entry
            //
            if (NewFlags != KDC_NO_ENTRY)
            {
                CacheEntry->CacheFlags = NewFlags;
                CacheEntry->EndTime.QuadPart = CurrentTime.QuadPart + (LONGLONG) 10*60*10000000; 
                Found = TRUE;
            }
            else  // just a lookup
            {
                if (KdcGetTime(CacheEntry->EndTime) < KdcGetTime(CurrentTime))
                {
                    DebugLog((DEB_TRACE, "Time:  Purging KDC Referral cache entry (%x : refcount %x) for %wZ \n",
                              CacheEntry,CacheEntry->References, RealmName));
                    KdcDereferenceReferralCacheEntry(CacheEntry);
                    
                }
                else // got our flags               
                {
                    *CacheState = CacheEntry->CacheFlags;
                    DebugLog((DEB_TRACE, "Found entry for %wZ, flags - %x\n",
                              RealmName, *CacheState));

                    Found = TRUE;
                }
            }
            break;


        }
    } 

    // If it wasn't found, but if we asked for any new flags
    // we want a new cache entry
    if (!Found && (NewFlags != KDC_NO_ENTRY))
    {
        DebugLog((DEB_TRACE, "Adding referral cache entry - %wZ State: %x\n",
                  RealmName, NewFlags));

        KerbErr = KdcAddReferralCacheEntry(
                        RealmName,
                        NewFlags
                        );
    }

   
    if (ListLocked)
    {
        KdcUnlockReferralCache();
    }  

    return KerbErr;
}






//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeDomainInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    )
{
    if (ARGUMENT_PRESENT(DomainInfo))
    {
        KerbFreeString(&DomainInfo->NetbiosName);
        KerbFreeString(&DomainInfo->DnsName);
        if (NULL != DomainInfo->Sid)
        {
            MIDL_user_free(DomainInfo->Sid);
        }
        MIDL_user_free(DomainInfo);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceDomainInfo
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    )
{
     if (InterlockedDecrement(&DomainInfo->References) == 0)
     {
         KdcFreeDomainInfo(DomainInfo);
     }
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForInterdomainReferral
//
//  Synopsis:   This function makes a determination that an interdomain referral
//              that we're processing is destined for an external forest.  This
//              is important because we won't have any referral information about
//              the destination forest, so we've got to target the root of our
//              enterprise instead.  
//
//              TBD: This function currently uses the CrackSingleName API (with 
//              composed KRBTGT name to verify we're going for an xforest trust. 
//              We should cache both positive and negative results so that we can 
//              eliminate that call.
//
//
//  Effects:
//
//  Arguments:  ReferralTarget - Receives ticket info for target domain
//              ReferralRealm - Receives realm name of referral realm, if present
//              DestinationDomain - Target domain name
//              ExactMatch - The target domain has to be trusted by this domain
//
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckForCrossForestReferral(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    )
{

    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    LPWSTR KrbtgtSpn = NULL;
    UNICODE_STRING ServiceName = {0 , 0, NULL };
    WCHAR CrackedDnsDomain [DNS_MAX_NAME_LENGTH + 1];
    ULONG CrackedDomainLength = (DNS_MAX_NAME_LENGTH+1) * sizeof(WCHAR);
    WCHAR CrackedName[UNLEN+DNS_MAX_NAME_LENGTH + 2];
    ULONG CrackedNameLength = ((UNLEN+DNS_MAX_NAME_LENGTH + 2) * sizeof(WCHAR));
    ULONG CrackError = 0, CacheFlags = 0; 
    
    
    //
    // Is it in the realm list of recent rejectees or
    // positive hits?
    //
    KerbErr = KdcLocateReferralCacheEntry(
                    DestinationDomain,
                    0,   //  no new flags
                    &CacheFlags
                    );

    if (CacheFlags == KDC_NO_ENTRY)
    {
    
        //
        // Compose an SPN related to our KRBTGT account
        //
        KerbErr = KerbBuildUnicodeSpn(
                            DestinationDomain,
                            SecData.KdcServiceName(),
                            &ServiceName
                            );
    
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }       
    
        KrbtgtSpn = KerbBuildNullTerminatedString(&ServiceName);
        if (NULL == KrbtgtSpn)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;      
        }
    
        //
        // Look it up
        //
        Status = CrackSingleName(
                    DS_SERVICE_PRINCIPAL_NAME, // we know its an SPN
                    DS_NAME_FLAG_TRUST_REFERRAL | DS_NAME_FLAG_GCVERIFY, 
                    KrbtgtSpn,
                    DS_UNIQUE_ID_NAME,
                    &CrackedDomainLength,
                    CrackedDnsDomain,
                    &CrackedNameLength,
                    CrackedName,
                    &CrackError
                    );
    
        // Any error, or CrackError other than xforest result
        // means we don't know where this referral is headed.
        // TBD:  Recovery?
        if (!NT_SUCCESS(Status) || (CrackError != DS_NAME_ERROR_TRUST_REFERRAL))
        {
            DebugLog((DEB_ERROR, 
                      "KDC presented w/ a unknown Xrealm TGT (%wZ)\n",
                      DestinationDomain));
 
            // Add a negative entry
            KdcLocateReferralCacheEntry(
                        DestinationDomain,
                        KDC_UNTRUSTED_REALM,
                        &CacheFlags
                        );

            KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
            goto Cleanup;
        }
        else
        {
            KdcLocateReferralCacheEntry(
                        DestinationDomain,
                        KDC_TRUSTED_REALM,
                        &CacheFlags
                        ); 
        }
    } 
    else if (CacheFlags == KDC_UNTRUSTED_REALM)
    {

        DebugLog((DEB_ERROR,
                  "Checking for X Forest on Untrusted Realm %wZ\n",
                  DestinationDomain
                  ));

        KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
        goto Cleanup;  
    }
                                            
    //
    // Now, we're pretty sure we're going to hit this other forest,
    // somewhere.   For SPNs, we've got to find the root domain of our forest
    // to finish off the x realm transaction.  For UPNs, just
    // return the cracked domain.
    //
    if ((NameFlags & KDC_NAME_SERVER) != 0)
    {  
        UNICODE_STRING ForestRoot = {0};
        

        Status = SecData.GetKdcForestRoot(&ForestRoot);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        KerbErr = KdcFindReferralTarget(
                    ReferralTarget,
                    ReferralRealm, 
                    pExtendedError,
                    &ForestRoot,
                    FALSE, // we'll accept closest
                    FALSE // Outbound.
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Couldn't find referral info for root of forest \n"));
            goto Cleanup;

        }  

        //
        // swap w/ our dns domain for referral realm, unless we're
        // processing a UPN
        //                  
        KerbFreeString(ReferralRealm);
        KerbFreeString(&ForestRoot);
    }

    KerbDuplicateString(
        ReferralRealm,
        DestinationDomain
        );                   

    
Cleanup:


    KerbFreeString(&ServiceName);

    if (KrbtgtSpn != NULL)
    {
        MIDL_user_free(KrbtgtSpn);
    }


    return ( KerbErr );

}  
                      


//+-------------------------------------------------------------------------
//
//  Function:   KdcFindReferralTarget
//
//  Synopsis:   Takes a domain name as a parameter and returns information
//              in the closest available domain. For heirarchical links,
//              this would be a parent or child. If a cross link is available,
//              this might be the other side of a cross link. For inter-
//              organization links, this might be a whole different tree
//
//  Effects:
//
//  Arguments:  ReferralTarget - Receives ticket info for target domain
//              ReferralRealm - Receives realm name of referral realm, if present
//              DestinationDomain - Target domain name
//              ExactMatch - The target domain has to be trusted by this domain
//
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
KdcFindReferralTarget(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN BOOLEAN InboundWanted
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO ClosestRoute = NULL;
    UNICODE_STRING TempRealmName;
    BOOLEAN fListLocked = FALSE;

    TRACE(KDC, KdcFindReferralTarget, DEB_FUNCTION);

    RtlInitUnicodeString(
        ReferralRealm,
        NULL
        );
    D_DebugLog((DEB_TRACE,"Generating referral for target %wZ\n",DestinationDomain));

    if (InboundWanted)
    {
        KdcLockDomainList();

        KerbErr = KdcLookupDomainName(
                    &DomainInfo,
                    DestinationDomain,
                    &KdcDomainList
                    );

        if (!KERB_SUCCESS(KerbErr) || ((DomainInfo->Flags & KDC_TRUST_INBOUND) == 0))
        {
            DebugLog((DEB_WARN,"Failed to find inbound referral target %wZ\n",DestinationDomain));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            fListLocked = TRUE;
            goto Cleanup;
        }

        //
        // Set the closest route to be this domain & add a reference for
        // the extra pointer
        //

        KdcReferenceDomainInfo(DomainInfo);
        ClosestRoute = DomainInfo;
        KdcUnlockDomainList();

    }
    else
    {
        //
        // Check the list of domains for the target
        //

        KdcLockDomainList();

        KerbErr = KdcLookupDomainRoute(
                    &DomainInfo,
                    &ClosestRoute,
                    DestinationDomain,
                    &KdcDomainList
                    );

        KdcUnlockDomainList();

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,"Failed to find referral target %wZ\n",DestinationDomain));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            goto Cleanup;
        }

        //
        // Check to see if we needed & got an exact match
        //

        if (ExactMatch &&
            (DomainInfo != ClosestRoute))
        {
            DebugLog((DEB_ERROR,"Needed exact match and got a transitively-trusted domain.\n" ));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
    }


    //
    // Return the referral realm, if present
    //

    if (ARGUMENT_PRESENT(ReferralRealm))
    {
        if (!NT_SUCCESS(KerbDuplicateString(
                ReferralRealm,
                &DomainInfo->DnsName
                )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    //
    // Now get the ticket info for the domain
    //

    KerbErr = KdcGetTicketInfoForDomain(
                ReferralTarget,
                pExtendedError,
                ClosestRoute,
                InboundWanted ? Inbound : Outbound
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to get ticket info for domain %wZ: 0x%x. %ws, line %d\n",
            DestinationDomain, KerbErr , __FILE__, __LINE__ ));
        goto Cleanup;
    }

Cleanup:
    if (DomainInfo != NULL)
    {
        KdcDereferenceDomainInfo(DomainInfo);
    }
    if (ClosestRoute != NULL)
    {
        KdcDereferenceDomainInfo(ClosestRoute);
    }
    if (fListLocked)
    {
        KdcUnlockDomainList();
    }
    if (!KERB_SUCCESS(KerbErr) && ARGUMENT_PRESENT(ReferralRealm))
    {
        KerbFreeString(ReferralRealm);
    }
    //
    // Remap the error
    //

    if (KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
    }

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicketInfoForDomain
//
//  Synopsis:   Retrieves the ticket information for a domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcGetTicketInfoForDomain(
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    )
{
    PLSAPR_TRUSTED_DOMAIN_INFO TrustInfo = NULL;
    PLSAPR_AUTH_INFORMATION AuthInfo = NULL;
    PLSAPR_AUTH_INFORMATION OldAuthInfo = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Password;
    ULONG PasswordLength = 0;
    LARGE_INTEGER CurrentTime;
    ULONG cbSid;


    TRACE(KDC, KdcGetTicketInfoForDomain, DEB_FUNCTION);

    //
    // Get information about the domain. Note that we use the dns name
    // field. For NT5 domains in the enterprise this will contain the
    // real DNS name. For non- tree domains it will contain the name from
    // the trusted domain object, so this call should always succeed.
    //

    Status = LsarQueryTrustedDomainInfoByName(
                GlobalPolicyHandle,
                (PLSAPR_UNICODE_STRING) &DomainInfo->DnsName,
                TrustedDomainAuthInformation,
                &TrustInfo
                );
    if (!NT_SUCCESS(Status))
    {
        //
        // If the domain didn't exist, we have a problem because our
        // cache is out of date. Or, we're loooking for our domain.. this
        // is always going to return STATUS_OBJECT_NAME_NOT_FOUND
        //

        //
        // WAS BUG: reload the cache -- this is handled in the call to 
        // LSAIKerberosRegisterTrustNotification(), which will then
        // reload the cache using KdcTrustChangeCallback().  As long
        // as this callback is solid (?), we should never fail the
        // above.  If needed, we can revisit. -TS
        // 

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Domain %wZ in cache but object doesn't exist. %ws, line %d\n",
                &DomainInfo->DnsName, THIS_FILE, __LINE__ ));
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        }
        else
        {
            DebugLog((DEB_ERROR,"Failed to query domain info for %wZ: 0x%x. %ws, line %d\n",
                &DomainInfo->DnsName, Status, THIS_FILE, __LINE__ ));
                KerbErr = KRB_ERR_GENERIC;
        }

        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Note: Kerberos direction is opposite normal direction
    //

    if (Direction == Outbound)
    {
        AuthInfo = TrustInfo->TrustedAuthInfo.IncomingAuthenticationInformation;
        OldAuthInfo = TrustInfo->TrustedAuthInfo.IncomingPreviousAuthenticationInformation;
    }
    else
    {
        AuthInfo = TrustInfo->TrustedAuthInfo.OutgoingAuthenticationInformation;
        OldAuthInfo = TrustInfo->TrustedAuthInfo.OutgoingPreviousAuthenticationInformation;
    }

    if (AuthInfo == NULL)
    {
        DebugLog((DEB_ERROR,"No auth info for this trust: %wZ. %ws, line %d\n",
            &DomainInfo->DnsName, THIS_FILE, __LINE__ ));
        FILL_EXT_ERROR(pExtendedError, STATUS_TRUSTED_DOMAIN_FAILURE, FILENO, __LINE__);
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Check the last update time. If the new auth info is too new, we want
    // to keep using the old one.
    //
    if (OldAuthInfo != NULL)
    {

        GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
        if (CurrentTime.QuadPart - AuthInfo->LastUpdateTime.QuadPart < SecData.KdcDomainPasswordReplSkew().QuadPart)
        {
            PLSAPR_AUTH_INFORMATION TempAuthInfo;

            //
            // Swap current & old auth info to encrypt tickets with old password
            //

            TempAuthInfo = AuthInfo;
            AuthInfo = OldAuthInfo;
            OldAuthInfo = TempAuthInfo;

        }
    }

    //
    // So now that we have the auth info we need to build a ticket info
    //

    Password.Length = Password.MaximumLength = (USHORT) AuthInfo->AuthInfoLength;
    Password.Buffer = (LPWSTR) AuthInfo->AuthInfo;

    Status = KdcBuildPasswordList(
                &Password,
                &DomainInfo->DnsName,
                SecData.KdcDnsRealmName(),
                DomainTrustAccount,
                NULL,           // no stored creds
                0,              // no stored creds
                FALSE,          // don't marshall
                DomainInfo->Type != TRUST_TYPE_MIT,           // don;t include builtin crypt types for mit trusts,
                (AuthInfo->AuthType & TRUST_AUTH_TYPE_NT4OWF) ? KERB_PRIMARY_CRED_OWF_ONLY : 0,
                Direction,
                &TicketInfo->Passwords,
                &PasswordLength
                );

    if (!NT_SUCCESS(Status))
    {
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;

    }

    //
    // Build the old password list as well
    //

    if (OldAuthInfo != NULL)
    {


        Password.Length = Password.MaximumLength = (USHORT) OldAuthInfo->AuthInfoLength;
        Password.Buffer = (LPWSTR) OldAuthInfo->AuthInfo;

        Status = KdcBuildPasswordList(
                    &Password,
                    &DomainInfo->DnsName,
                    SecData.KdcDnsRealmName(),
                    DomainTrustAccount,
                    NULL,
                    0,
                    FALSE,          // don't marshall
                    DomainInfo->Type != TRUST_TYPE_MIT,           // don;t include builtin crypt types for mit trusts,
                    (OldAuthInfo->AuthType & TRUST_AUTH_TYPE_NT4OWF) ? KERB_PRIMARY_CRED_OWF_ONLY : 0,
                    Direction,
                    &TicketInfo->OldPasswords,
                    &PasswordLength
                    );

        if (!NT_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           KerbErr = KRB_ERR_GENERIC;
           goto Cleanup;

        }

    }

    if (!NT_SUCCESS(KerbDuplicateString(
                        &TicketInfo->AccountName,
                        &DomainInfo->DnsName
                        )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // BUG 73479: need to get ticket options
    //

    TicketInfo->fTicketOpts = AUTH_REQ_PER_USER_FLAGS |
                                AUTH_REQ_ALLOW_NOADDRESS |
                                AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                                AUTH_REQ_ALLOW_VALIDATE |
                                AUTH_REQ_OK_AS_DELEGATE;

    if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_NON_TRANSITIVE) == 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_TRANSITIVE_TRUST;
    }
    TicketInfo->PasswordExpires = tsInfinity;
    TicketInfo->UserAccountControl = USER_INTERDOMAIN_TRUST_ACCOUNT;

    if (DomainInfo->Sid)
    {
        cbSid = RtlLengthSid(DomainInfo->Sid);
        TicketInfo->TrustSid = (PSID) MIDL_user_allocate(cbSid);
        if (TicketInfo->TrustSid == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = RtlCopySid (
                    cbSid,
                    TicketInfo->TrustSid,
                    DomainInfo->Sid
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    TicketInfo->TrustAttributes = DomainInfo->Attributes;

    //
    // Add trusted forest UNICODE STRING onto ticket info
    // if its Xforest
    //
    if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) != 0)
    {
        TicketInfo->TrustAttributes = TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
        
        KerbErr = KerbDuplicateString(
                    &(TicketInfo->TrustedForest),
                    &DomainInfo->DnsName
                    );

        
        
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }                
    }                    

Cleanup:


    if (TrustInfo != NULL)
    {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainAuthInformation,
            TrustInfo
            );
    }


    if (!KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(TicketInfo);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainName
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        if (KerbCompareUnicodeRealmNames(
                DomainName,
                &Domain->DnsName
                ) ||                // case insensitive
             RtlEqualUnicodeString(
                DomainName,
                &Domain->NetbiosName,
                TRUE))                  // case insensitive
        {

            KdcReferenceDomainInfo(Domain);
            *DomainInfo = Domain;
            return(KDC_ERR_NONE);
        }
    }
    return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainRoute
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info for the closest domain.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    )
{
    KERBERR KerbErr;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainRoute, DEB_FUNCTION);


    KerbErr = KdcLookupDomainName(
                &Domain,
                DomainName,
                DomainList
                );

    if (KERB_SUCCESS(KerbErr))
    {
        if (Domain->ClosestRoute != NULL)
        {
            *DomainInfo = Domain;

            // If the closest route is this domain, then cheat and send back
            // the closest domain as the domain requested.

            if (KerbCompareUnicodeRealmNames(&(Domain->ClosestRoute->DnsName), SecData.KdcDnsRealmName()))

            {
                *ClosestRoute = Domain;
            }
            else
            {
                *ClosestRoute = Domain->ClosestRoute;
            }
            KdcReferenceDomainInfo(*ClosestRoute);
            return(KDC_ERR_NONE);
        }
        else
        {
            KdcDereferenceDomainInfo(Domain);
            DebugLog((DEB_WARN,"Asked for referral to %wZ domain, in organization but unreachable\n",
                DomainName ));
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;

        }
    }


    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainByDnsName
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKDC_DOMAIN_INFO
KdcLookupDomainByDnsName(
    IN PUNICODE_STRING DnsDomainName,
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        if (KerbCompareUnicodeRealmNames(
                DnsDomainName,
                &Domain->DnsName
                ))
        {

            return(Domain);
        }
    }
    return(NULL);
}

#if DBG

VOID
DebugDumpDomainList(
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        DebugLog((DEB_TRACE,"Domain %wZ:\n",&Domain->DnsName));
        if (Domain->ClosestRoute == NULL)
        {
            D_DebugLog((DEB_TRACE,"\t no closest route\n"));
        }
        else
        {
            D_DebugLog((DEB_TRACE,"\t closest route = %wZ\n",&Domain->ClosestRoute->DnsName));
        }

        if (Domain->Parent == NULL)
        {
            D_DebugLog((DEB_TRACE,"\t no parent\n"));
        }
        else
        {
            D_DebugLog((DEB_TRACE,"\t parent = %wZ\n",&Domain->Parent->DnsName));
        }
    }
}

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   KdcRecurseAddTreeTrust
//
//  Synopsis:   Recursively adds a tree trust - adds it and then all its
//              children.
//
//  Effects:    Adds children depth-first
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcRecurseAddTreeTrust(
    IN PLIST_ENTRY DomainList,
    IN PLSAPR_TREE_TRUST_INFO TreeTrust,
    IN OPTIONAL PKDC_DOMAIN_INFO DomainInfo
    )
{
    PKDC_DOMAIN_INFO NewDomainInfo = NULL;
    BOOLEAN Linked = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    //
    // Create new root trust
    //

    NewDomainInfo = (PKDC_DOMAIN_INFO) MIDL_user_allocate(sizeof(KDC_DOMAIN_INFO));
    if (NewDomainInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        NewDomainInfo,
        sizeof(KDC_DOMAIN_INFO)
        );

    Status = KerbDuplicateString(
                &NewDomainInfo->DnsName,
                (PUNICODE_STRING) &TreeTrust->DnsDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Uppercase the domain name here, as everything in the forest
    // is uplevel.
    //

    Status = RtlUpcaseUnicodeString(
                &NewDomainInfo->DnsName,
                &NewDomainInfo->DnsName,
                FALSE                   // don't allocate
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &NewDomainInfo->NetbiosName,
                (PUNICODE_STRING)&TreeTrust->FlatName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    NewDomainInfo->Parent = DomainInfo;

    //
    // Insert into list
    //

    NewDomainInfo->References = 1;

    InsertTailList(
        DomainList,
        &NewDomainInfo->Next
        );
    Linked = TRUE;


    //
    // Now recursively add all children
    //

    for (Index = 0; Index < TreeTrust->Children ; Index++ )
    {
        Status = KdcRecurseAddTreeTrust(
                    DomainList,
                    &TreeTrust->ChildDomains[Index],
                    NewDomainInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:
    if (!Linked && (NewDomainInfo != NULL))
    {
        KdcFreeDomainInfo(NewDomainInfo);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertDomainTrustIntoTree
//
//  Synopsis:   Adds trust information to the tree of domains. For domains
//              which are in the tree, trust direction
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInsertDomainTrustIntoForest(
    IN OUT PLIST_ENTRY DomainList,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX NewTrust
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO NewDomainInfo = NULL;
    ULONG cbSid;

    TRACE(KDC, KdcInsertDomainTrustIntoForest, DEB_FUNCTION);


    D_DebugLog((DEB_T_DOMAIN, "Inserting trusted domain into domain list: %wZ\n",&NewTrust->Name));

    //
    // Check to see if the domain is already in the tree
    //

    DomainInfo = KdcLookupDomainByDnsName(
                    (PUNICODE_STRING) &NewTrust->Name,
                    DomainList
                    );
    if (DomainInfo == NULL)
    {

        //
        // Allocate and fill in a new domain structure for this domain.
        // It is not part of the tree so the GUID will be zero.
        //

        NewDomainInfo = (PKDC_DOMAIN_INFO) MIDL_user_allocate(sizeof(KDC_DOMAIN_INFO));
        if (NewDomainInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        RtlZeroMemory(
            NewDomainInfo,
            sizeof(KDC_DOMAIN_INFO)
            );

        //
        // Copy in the names of the domain
        //

        Status = KerbDuplicateString(
                    &NewDomainInfo->DnsName,
                    (PUNICODE_STRING) &NewTrust->Name
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If the trust is uplevel, then uppercase
        //

        if (NewTrust->TrustType == TRUST_TYPE_UPLEVEL)
        {
            Status = RtlUpcaseUnicodeString(
                        &NewDomainInfo->DnsName,
                        &NewDomainInfo->DnsName,
                        FALSE                   // don't allocate
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        Status = KerbDuplicateString(
                    &NewDomainInfo->NetbiosName,
                    (PUNICODE_STRING) &NewTrust->FlatName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        NewDomainInfo->References = 1;

        InsertTailList(DomainList, &NewDomainInfo->Next);
        DomainInfo = NewDomainInfo;
        NewDomainInfo = NULL;

    }

    DomainInfo->Attributes = NewTrust->TrustAttributes;
    DomainInfo->Type = NewTrust->TrustType;
    
    //
    // If this is not an inbound-only trust, the closest route to get here
    // is to go directly here.
    //

    if ((NewTrust->TrustDirection & TRUST_DIRECTION_INBOUND) != 0)
    {
        DomainInfo->ClosestRoute = DomainInfo;
    }

    //
    // Note the confusion of inbound and outbound. For Kerberos inbound is
    // the opposite of for trust objects.
    //

    if ((NewTrust->TrustDirection & TRUST_DIRECTION_OUTBOUND) != 0)
    {
        DomainInfo->Flags |= KDC_TRUST_INBOUND;
        if ((((DomainInfo->Attributes & TRUST_ATTRIBUTE_FILTER_SIDS) != 0) &&
            ((DomainInfo->Type & TRUST_TYPE_UPLEVEL) != 0)) ||
            ((DomainInfo->Attributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0))
        { 
            if (NewTrust->Sid != NULL)
            {         
                cbSid = RtlLengthSid(NewTrust->Sid);
                DomainInfo->Sid = (PSID) MIDL_user_allocate(cbSid);
                if (DomainInfo->Sid == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                Status = RtlCopySid (
                            cbSid,
                            DomainInfo->Sid,
                            NewTrust->Sid
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }


                if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0) 
                {
                    SecData.SetCrossForestEnabled(TRUE);
                }                                         

            }

            

            
        }
    }

Cleanup:

    if (NewDomainInfo != NULL)
    {
        KdcFreeDomainInfo(NewDomainInfo);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcComputeShortestDomainPaths
//
//  Synopsis:   Compute the shortest path for each domain in the tree
//              by traversing up until either the local domain or
//              a parent of it is located, and then traverse down.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcComputeShortestDomainPaths(
    IN PLIST_ENTRY DomainList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DOMAIN_INFO * ParentList = NULL;
    ULONG CountOfParents = 0, Index;
    PKDC_DOMAIN_INFO LocalDomain;
    PKDC_DOMAIN_INFO WorkingDomain;
    PKDC_DOMAIN_INFO ParentDomain;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundParent;
    ULONG TouchedIndex = 1;

    TRACE(KDC, KdcComputeShortestDomainPaths, DEB_FUNCTION);

    //
    // If the tree is empty, then there are no shortest paths to compute.
    //

    if (IsListEmpty(DomainList))
    {
        return(STATUS_SUCCESS);
    }

    //
    // Calculate the number of parents & grandparents of the local domain.
    //

    LocalDomain = KdcLookupDomainByDnsName(
                    SecData.KdcDnsRealmName(),
                    DomainList
                    );

    if (LocalDomain == NULL)
    {
        DebugLog((DEB_ERROR,"No forest info for local domain - no transitive trust. %ws, line %d\n", THIS_FILE, __LINE__));
        return(STATUS_SUCCESS);
    }
    LocalDomain->ClosestRoute = LocalDomain;

    WorkingDomain = LocalDomain->Parent;
    while (WorkingDomain != NULL)
    {
        //
        // Stop if we've come to this domain before.
        //
        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            NEW_KDCEVENT_TRUSTLIST_LOOP,
            sizeof(NTSTATUS),
            &Status,
            0,
            NULL
            );
        
        if (WorkingDomain->Touched == TouchedIndex)
        {
            DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
            break;
        }

        WorkingDomain->Touched = TouchedIndex;
        CountOfParents++;
        WorkingDomain = WorkingDomain->Parent;
    }

    //
    // If we had any parents, build an array of all our parents.
    //

    if (CountOfParents != 0)
    {
        ParentList = (PKDC_DOMAIN_INFO *) MIDL_user_allocate(CountOfParents * sizeof(PKDC_DOMAIN_INFO));
        if (ParentList == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Store each parent in the list.
        //
        Index = 0;
        TouchedIndex++;
        WorkingDomain = LocalDomain->Parent;
        while (WorkingDomain != NULL)
        {

            //
            // Stop if we've come to this domain before.
            //

            if (WorkingDomain->Touched == TouchedIndex)
            {
                DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
                break;
            }

            //
            // Skip domains that have no domain info. They have probably been
            // deleted.
            //
            WorkingDomain->Touched = TouchedIndex;

            ParentList[Index++] = WorkingDomain;
            WorkingDomain = WorkingDomain->Parent;
        }

    }

    //
    // Now loop through every domain in the tree. For each domain, if it
    // is not trusted, check it against the list of parents. If it is a
    // parent, walk down the list until a trusted domain is found.
    //


    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList;
         ListEntry = ListEntry->Flink )
    {
        WorkingDomain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        ParentDomain = WorkingDomain;

        //
        // Walk up from this domain until we find a common ancestor with
        // the local domain
        //
        TouchedIndex++;
        while (ParentDomain != NULL)
        {

            //
            // Stop if we've come to this domain before.
            //

            if (ParentDomain->Touched == TouchedIndex)
            {
                DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
                break;
            }

            //
            // Skip domains that have no domain info. They have probably been
            // deleted.
            //

            ParentDomain->Touched = TouchedIndex;


            //
            // If the parent has a closest route, use it
            //

            if (ParentDomain->ClosestRoute != NULL)
            {
                WorkingDomain->ClosestRoute = ParentDomain->ClosestRoute;
                D_DebugLog((DEB_T_DOMAIN, "Shortest route for domain %wZ is %wZ\n",
                    &WorkingDomain->DnsName,
                    &WorkingDomain->ClosestRoute->DnsName
                    ));

                break;
            }


            //
            // Look through the list of parents for this domain to see if it
            // is trusted
            //

            Index = CountOfParents;
            FoundParent = FALSE;
            while (Index > 0)
            {
                Index--;
                if (ParentList[Index] == ParentDomain)
                {
                    //
                    // We found a domain that is a parent of
                    // ours
                    //

                    FoundParent = TRUE;

                }
                if (FoundParent && (ParentList[Index]->ClosestRoute != NULL))
                {
                    WorkingDomain->ClosestRoute = ParentList[Index]->ClosestRoute;
                    break;
                }
            }

            if (WorkingDomain->ClosestRoute != NULL)
            {
                D_DebugLog((DEB_T_DOMAIN, "Shortest route for domain %wZ is %wZ\n",
                    &WorkingDomain->DnsName,
                    &WorkingDomain->ClosestRoute->DnsName
                    ));
                break;

            }
            ParentDomain = ParentDomain->Parent;
        }
    }


Cleanup:
    if (ParentList != NULL)
    {
        MIDL_user_free(ParentList);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDomainList
//
//  Synopsis:   Frees a domain list element by element.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    )
{
    PREFERRAL_CACHE_ENTRY CacheEntry;

    TRACE(KDC, KdcFreeReferralCache, DEB_FUNCTION);

    if (ReferralCache->Flink != NULL)
    {
        while (!IsListEmpty(ReferralCache))
        {
            CacheEntry = CONTAINING_RECORD(ReferralCache->Flink, REFERRAL_CACHE_ENTRY, ListEntry );

            RemoveEntryList(&CacheEntry->ListEntry);
            InitializeListHead(&CacheEntry->ListEntry);
            KdcDereferenceReferralCacheEntry(CacheEntry);
        }
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDomainList
//
//  Synopsis:   Frees a domain list element by element.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    )
{
    PKDC_DOMAIN_INFO DomainInfo;

    TRACE(KDC, KdcFreeDomainList, DEB_FUNCTION);

    if (DomainList->Flink != NULL)
    {
        while (!IsListEmpty(DomainList))
        {
            DomainInfo = CONTAINING_RECORD(DomainList->Flink, KDC_DOMAIN_INFO, Next );

            RemoveEntryList(&DomainInfo->Next);
            InitializeListHead(&DomainInfo->Next);
            KdcDereferenceDomainInfo(DomainInfo);
        }
    }

}

#ifdef DBG_BUILD_FOREST

VOID
DebugBuildDomainForest(
    OUT PLSAPR_FOREST_TRUST_INFO * ForestInfo
    )
{
    PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;
    PLSAPR_TREE_TRUST_INFO ChildDomains = NULL;
    PLSAPR_TREE_TRUST_INFO ChildRoot = NULL;
        UNICODE_STRING TempString;
    ULONG Index;
    LPWSTR  MsNames[4] = {L"ntdev.microsoft.com",L"alpamayo.ntdev.microsoft.com",L"annapurna.alpamayo.ntdev.microsoft.com",L"lhotse.annapurna.alpamayo.ntdev.microsoft.com" };

    ForestTrustInfo = (PLSAPR_FOREST_TRUST_INFO) MIDL_user_allocate(sizeof(LSAPR_FOREST_TRUST_INFO));

    RtlInitUnicodeString(
        &TempString,
        MsNames[0]
        );
    KerbDuplicateString( (PUNICODE_STRING)
        &ForestTrustInfo->RootTrust.DnsDomainName,
        &TempString
        );
    KerbDuplicateString( (PUNICODE_STRING)
        &ForestTrustInfo->RootTrust.FlatName,
        &TempString
        );

    ChildRoot = &ForestTrustInfo->RootTrust;

    for (Index = 1; Index < 4 ; Index++ )
    {
        ChildRoot->Children = 1;
        ChildRoot->ChildDomains = (PLSAPR_TREE_TRUST_INFO) MIDL_user_allocate(sizeof(LSAPR_TREE_TRUST_INFO));
        RtlZeroMemory(
            ChildRoot->ChildDomains,
            sizeof(LSAPR_TREE_TRUST_INFO)
            );

        RtlInitUnicodeString(
            &TempString,
            MsNames[Index]
            );
        KerbDuplicateString( (PUNICODE_STRING)
            &ChildRoot->ChildDomains[0].DnsDomainName,
            &TempString
            );
        KerbDuplicateString( (PUNICODE_STRING)
            &ChildRoot->ChildDomains[0].FlatName,
            &TempString
            );

        ChildRoot = &ChildRoot->ChildDomains[0];
    }


    //
    // Should be all done now
    //


    *ForestInfo = ForestTrustInfo;
}

#endif // DBG_BUILD_FOREST


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildDomainTree
//
//  Synopsis:   Enumerates the list of domains and inserts them
//              all into a tree
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcBuildDomainTree(
    IN OUT PLIST_ENTRY DomainList
    )
{
    NTSTATUS Status;
    ULONG Index;
    PLSAPR_FOREST_TRUST_INFO ForestInfo = NULL;
    LSAPR_TRUSTED_ENUM_BUFFER_EX TrustedBuffer;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    ULONG CountReturned;
    
    TRACE(KDC, KdcBuildDomainList, DEB_FUNCTION);

    InitializeListHead(DomainList);

    RtlZeroMemory(
        &TrustedBuffer,
        sizeof(LSAPR_TRUSTED_ENUM_BUFFER_EX)
        );

    //
    // Call the LSA to enumerate all the trees in the enterprise and insert
    // them into the tree
    //

#ifndef DBG_BUILD_FOREST
    Status = LsaIQueryForestTrustInfo(
                GlobalPolicyHandle,
                &ForestInfo
                );

    //
    // If we aren't part of a tree, we may get back STATUS_OBJECT_NAME_NOT_FOUND
    // so this is o.k.
    //

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_WARN,"No trust info (0x%x) continuing\n",Status));
            Status = STATUS_SUCCESS;
        }
        else
        {
            goto Cleanup;
        }
    }
#else
    DebugBuildDomainForest(&ForestInfo);
#endif

    //
    // Only use this if the information is usable - it is present
    //


    if (ForestInfo != NULL)
    {
        Status = KdcRecurseAddTreeTrust(
                    DomainList,
                    &ForestInfo->RootTrust,
                    NULL
                    );


        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        
        Status = SecData.SetForestRoot(&(ForestInfo->RootTrust.DnsDomainName));

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }
    //
    // Now add all the trusts in.
    //
    SecData.SetCrossForestEnabled(FALSE); // set this to FALSE for now

    do
    {
        CountReturned = 0;

        Status = LsarEnumerateTrustedDomainsEx(
                    GlobalPolicyHandle,
                    &EnumContext,
                    &TrustedBuffer,
                    0xffffff           // preferred maximum length
                    );

        if (!NT_ERROR(Status))
        {
            //
            // Call the LSA to enumerate all the trust relationships and integrate
            // them into the tree
            //

            for (Index = 0; (Index < TrustedBuffer.EntriesRead) && NT_SUCCESS(Status) ; Index++ )
            {
                if (TrustedBuffer.EnumerationBuffer[Index].TrustType != TRUST_TYPE_DOWNLEVEL)
                {
                    Status = KdcInsertDomainTrustIntoForest(
                                DomainList,
                                &TrustedBuffer.EnumerationBuffer[Index]
                                );
                }
            }
        }


        LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX(&TrustedBuffer);
        RtlZeroMemory(
            &TrustedBuffer,
            sizeof(LSAPR_TRUSTED_ENUM_BUFFER_EX)
            );


    } while (NT_SUCCESS(Status) && (CountReturned != 0));

    if (NT_ERROR(Status))
    {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Failed to enumerate trusted domains: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }

    //
    // Now compute the shortest path from each domain in the tree.
    //

    Status = KdcComputeShortestDomainPaths(
                DomainList
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#if DBG
    DebugDumpDomainList(DomainList);
#endif

Cleanup:

    if (ForestInfo != NULL)
    {
        LsaIFreeForestTrustInfo(ForestInfo);
    }

    if (!NT_SUCCESS(Status))
    {
        KdcFreeDomainList(DomainList);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcReloadDomainTree
//
//  Synopsis:   Reloads the domain tree when it has changed
//
//  Effects:
//
//  Arguments:  Dummy - dummy argument requred for CreateThread calls
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KdcReloadDomainTree(
    PVOID Dummy
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LIST_ENTRY DomainList;

    TRACE(KDC, KdcBuildDomainList, DEB_FUNCTION);

    InitializeListHead(&DomainList);
    
    
    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }    
    
    if (!KdcReferralCacheInitialized)
    {
        
        Status = RtlInitializeCriticalSection(&KdcReferralCacheLock);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }                                     
        InitializeListHead(&KdcReferralCache);
        KdcReferralCacheInitialized = TRUE;
    }


  

    D_DebugLog((DEB_TRACE,"About to reload domain tree\n"));

    if (!KdcDomainListInitialized)
    {
        Status = RtlInitializeCriticalSection(&KdcDomainListLock);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        InitializeListHead(&KdcDomainList);
        KdcDomainListInitialized = TRUE;
    }

    Status = KdcBuildDomainTree(&DomainList);

    if (NT_SUCCESS(Status))
    {
        KdcLockDomainList();

        KdcFreeDomainList(&KdcDomainList);

        KdcDomainList = DomainList;

        DomainList.Flink->Blink = &KdcDomainList;
        DomainList.Blink->Flink = &KdcDomainList;

        KdcUnlockDomainList();
    }
    else
    {
        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_DOMAIN_LIST_UPDATE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            0,
            NULL
            );

    }
Cleanup:
    LeaveApiCall();
    return((ULONG)Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcTrustChangeCallback
//
//  Synopsis:   This is the callback that gets invoked with the Lsa has determined
//              that the trust tree has changed.  The call is made asynchronously.
//
//  Effects:    Potentially causes the trust tree to be rebuilt
//
//  Arguments:  DeltaType - Type of change to the trust tree
//
//  Requires:   Nothing
//
//  Returns:    VOID
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcTrustChangeCallback (
    SECURITY_DB_DELTA_TYPE DeltaType
    )
{
    NTSTATUS Status;

    TRACE(KDC, KdcTrustChangeCallback, DEB_FUNCTION);

    if ( DeltaType == SecurityDbNew || DeltaType == SecurityDbDelete  ||
         DeltaType == SecurityDbChange) {

        Status = KdcReloadDomainTree( NULL );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR,"KdcReloadDomainTree from callback failed with 0x%lx. %ws, line %d\n",
                      Status, THIS_FILE, __LINE__));
        }
    }
}


VOID
KdcLockDomainListFn(
   )
{
    KdcLockDomainList();
}

VOID
KdcUnlockDomainListFn(
   )
{
    KdcUnlockDomainList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\rpcif.cxx ===
//+-----------------------------------------------------------------------
//
// File:        RPCIF.CXX
//
// Contents:    RPC Interface specific functions
//
//
// History:     23 Feb 92   RichardW    Created
//
// BUG 453652:      Socket errors are tranlated to STATUS_OBJECT_NAME_NOT_FOUND
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "rpcif.h"
extern "C" {
#include <kdcdbg.h>
}



////////////////////////////////////////////////////////////////////
//
//  Name:       RET_IF_ERROR
//
//  Synopsis:   Evaluates an expression, returns from the caller if error.
//
//  Arguments:  l    - Error level to print error message at.
//              e    - expression to evaluate
//
// NOTE: THIS MACRO WILL RETURN FROM THE CALLING FUNCTION ON ERROR!!!!
//
// This will execute the expression (e), and check the return code.  If the
// return code indicates a failure, it prints an error message and returns
// from the calling function.
//
#define RET_IF_ERROR(l,e)                                           \
    {   ULONG X_hr_XX__=(e) ;                                       \
        if (X_hr_XX__ != ERROR_SUCCESS) {                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == %d\n"      \
                            :                                       \
                                "%s(%d):\n\t %.*s == %d\n"          \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
            return(I_RpcMapWin32Status(X_hr_XX__));                 \
        }                                                           \
    }




////////////////////////////////////////////////////////////////////
//
//  Name:       WARN_IF_ERROR
//
//  Synopsis:   Evaluates an expression, prints warning if error.
//
//  Arguments:  l    - Error level to print warning at.
//              e    - expression to evaluate
//
//  Notes:      This calls DebugLog(()) to print.  In retail, it just
//              evaluates the expression.
//
#if DBG
#define WARN_IF_ERROR(l,e)                                          \
    {   ULONG X_hr_XX__=(e) ;                                       \
        if (X_hr_XX__ != ERROR_SUCCESS) {                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == %d\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == %d\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
        }                                                           \
    }
#else
#define WARN_IF_ERROR(l,e)  (e)
#endif




//+-------------------------------------------------------------------------
//
//  Function:   StartAllProtSeqs
//
//  Synopsis:   Checks which protocols are running and then starts those
//              protocols for the three KDC interfaces: kdc, locator, privilege
//              server.  It will, if USE_SECURE_RPC is defined, establish
//              credentials for the KDC.. Does not register interfaces.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


HRESULT
StartAllProtSeqs()
{
    TRACE(KDC, StartAllProtSeqs, DEB_FUNCTION);

    ULONG i;



    // Use all but ncacn_np. We'd like not to use LRPC as well, but
    // first spmgr and the security packages would have to be
    // changed. So, we live with it.

    DWORD dwErr;


    dwErr = RpcServerUseProtseq(L"ncalrpc",
                MAX_CONCURRENT_CALLS,
                0);

    if(dwErr)
    {
        DebugLog((DEB_ERROR, "UseProtseq failed %ws %d\n",
                  L"ncalrpc", dwErr));
    }

    dwErr = RpcServerUseProtseq(L"ncacn_ip_tcp",
                MAX_CONCURRENT_CALLS,
                0);

    if(dwErr)
    {
        DebugLog((DEB_ERROR, "UseProtseq failed %ws %d\n",
                  L"ncalrpc", dwErr));
    }



    return(STATUS_SUCCESS);

}



//+-------------------------------------------------------------------------
//
//  Function:   RegsiterKdcEps
//
//  Synopsis:   Registers Eps for the KDC and locator interfaces
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
HRESULT
RegisterKdcEps()
{
    TRACE(KDC, RegisterKdcEps, DEB_FUNCTION);

    RPC_BINDING_VECTOR  *   ppvVector;

    RET_IF_ERROR(DEB_ERROR, RpcServerInqBindings(&ppvVector));

    RET_IF_ERROR(DEB_ERROR, RpcEpRegister(KdcDebug_ServerIfHandle, ppvVector, 0, L"")) ;
    RET_IF_ERROR(DEB_ERROR, RpcServerRegisterIf(KdcDebug_ServerIfHandle, 0, 0)) ;


    RpcBindingVectorFree(&ppvVector);
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   UnRegsiterKdcEps
//
//  Synopsis:   UnRegisters Eps for the KDC and locator interfaces
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
HRESULT
UnRegisterKdcEps()
{
    TRACE(KDC, RegisterKdcEps, DEB_FUNCTION);

    RPC_BINDING_VECTOR  *   ppvVector;

    RET_IF_ERROR(DEB_ERROR, RpcServerInqBindings(&ppvVector));

    WARN_IF_ERROR(DEB_ERROR, RpcServerUnregisterIf(KdcDebug_ServerIfHandle, 0, 0)) ;


    RpcBindingVectorFree(&ppvVector);
    return(STATUS_SUCCESS);
}




void *
MIDL_user_allocate(size_t size)
{
//    TRACE(KDC, MIDL_user_allocate, DEB_FUNCTION);

    PVOID pvMem;

    //
    // The ASN.1 marshalling code may allocate odd sizes that can't be
    // encrypted with a block cipher. By rounding up the size to 8 we can
    // handle block sizes up to 8 bytes.
    //

    pvMem = RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                ROUND_UP_COUNT(size,8)
                );

    if ( pvMem == NULL )
    {
        DebugLog((DEB_ERROR, "MIDL allocate failed\n"));
    }
    else
    {
        RtlZeroMemory(pvMem, ROUND_UP_COUNT(size,8));
    }

    return(pvMem);


}

void
MIDL_user_free(void * ptr)
{
//    TRACE(KDC, MIDL_user_free, DEB_FUNCTION);

    RtlFreeHeap(RtlProcessHeap(),0, ptr);

}

extern "C"
void
KdcFreeMemory(void * ptr)
{
    KdcFreeEncodedData(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\secdata.cxx ===
//+-----------------------------------------------------------------------
//
// File:        secdata.cxx
//
// Contents:    Global data and methods on it.
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <tostring.hxx>
#include <kpasswd.h>

///////////////////////////////////////////////////////////////
//
//
// Global data
//

// This is all the security information that gets cached.

CSecurityData SecData;

CAuthenticatorList * Authenticators;
CAuthenticatorList * FailedRequests;


///////////////////////////////////////////////////////////////
//
//
// Prototypes
//



fLsaPolicyChangeNotificationCallback KdcPolicyChangeCallback;




//+-------------------------------------------------------------------------
//
//  Function:   KdcPolicyChangeCallBack
//
//  Synopsis:   Function that gets called when policy changes
//
//  Effects:    Changes policy variables
//
//  Arguments:  MonitorInfoClass - class of data that changed
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcPolicyChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    WCHAR Class[10];

    TRACE(KDC, KdcPolicyChangeCallBack, DEB_FUNCTION);

    Status = SecData.ReloadPolicy(MonitorInfoClass);

    if (!NT_SUCCESS(Status))
    {
        _itow(MonitorInfoClass, Class, 10 );

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_POLICY_UPDATE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            1,                  // number of strings
            Class
            );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::ReloadPolicy
//
//  Synopsis:   Reloads a particular piece of policy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::ReloadPolicy(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_DOMAIN_INFORMATION DomainPolicy = NULL;
    PLSAPR_POLICY_INFORMATION LocalPolicy = NULL;
    WCHAR Class[10];

    TRACE(KDC, CSecurityData::ReloadPolicy, DEB_FUNCTION);

    //
    // Ignore changes to non-kerberos ticket information
    //

    switch(MonitorInfoClass) {
    case PolicyNotifyDomainKerberosTicketInformation:

        Status = LsarQueryDomainInformationPolicy(
                    GlobalPolicyHandle,
                    PolicyDomainKerberosTicketInformation,
                    &DomainPolicy
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        break;
    case PolicyNotifyAuditEventsInformation:
        Status = LsarQueryInformationPolicy(
                    GlobalPolicyHandle,
                    PolicyAuditEventsInformation,
                    &LocalPolicy
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        break;
    default:
        return(STATUS_SUCCESS);
    }

    //
    // Update the changed information in the KDCs global data structures.
    //
    //
    // Current policy defaults, see KirkSol/JBrezak
    // [Kerberos Policy]
    // MaxTicketAge=10 ;Maximum User Ticket Lifetime (hours)
    // MaxRenewAge=7   ;Maximum lifetime that a user tickeet can be renewed (days)
    // MaxServiceAge=60    ;Maximum Service Ticket Lifetime (minutes)
    // MaxClockSkew=5  ;Maximum tolerance for synchronization of computer clocks (minutes)
    // TicketValidateClient=1  ;Enforce user logon restrictions

    WriteLock();
    switch(MonitorInfoClass) {
    case PolicyNotifyDomainKerberosTicketInformation:

        // Validate parameters

        if ((DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge.QuadPart <= (LONGLONG) -1) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxClockSkew.QuadPart <= (LONGLONG) -1)  ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge.QuadPart == (LONGLONG) 0) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge.QuadPart == (LONGLONG) 0) ||
            (DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge.QuadPart == (LONGLONG) 0) )

        {
            _itow(MonitorInfoClass, Class, 10 );

            ReportServiceEvent(
                EVENTLOG_ERROR_TYPE,
                KDCEVENT_POLICY_UPDATE_FAILED,
                sizeof(NTSTATUS),
                &Status,
                1,                  // number of strings
                Class
                );
        }
        else
        {

            _KDC_TgsTicketLifespan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxServiceTicketAge;
            _KDC_TgtTicketLifespan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxTicketAge;
            _KDC_TicketRenewSpan = DomainPolicy->PolicyDomainKerbTicketInfo.MaxRenewAge;
            SkewTime = DomainPolicy->PolicyDomainKerbTicketInfo.MaxClockSkew;

        }
        // Update domain policy flags. Don't depend on the flags keeping in sync
        // with the kerberos internal flags

        if ( DomainPolicy->PolicyDomainKerbTicketInfo.AuthenticationOptions &
             POLICY_KERBEROS_VALIDATE_CLIENT)
        {
            _KDC_Flags |= AUTH_REQ_VALIDATE_CLIENT;
        }
        else
        {
            _KDC_Flags &= ~AUTH_REQ_VALIDATE_CLIENT;
        }

        break;
    case PolicyNotifyAuditEventsInformation:

        if ((LocalPolicy->PolicyAuditEventsInfo.AuditingMode) &&
            (LocalPolicy->PolicyAuditEventsInfo.MaximumAuditEventCount > AuditCategoryAccountLogon))
        {


            if (LocalPolicy->PolicyAuditEventsInfo.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS )
            {
                _KDC_AuditEvents |= KDC_AUDIT_AS_SUCCESS | KDC_AUDIT_TGS_SUCCESS | KDC_AUDIT_MAP_SUCCESS;
            }
            else
            {
                _KDC_AuditEvents &= ~(KDC_AUDIT_AS_SUCCESS | KDC_AUDIT_TGS_SUCCESS | KDC_AUDIT_MAP_SUCCESS);
            }

            if (LocalPolicy->PolicyAuditEventsInfo.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE )
            {
                _KDC_AuditEvents |= KDC_AUDIT_AS_FAILURE | KDC_AUDIT_TGS_FAILURE | KDC_AUDIT_MAP_FAILURE;
            }
            else
            {
                _KDC_AuditEvents &= ~(KDC_AUDIT_AS_FAILURE | KDC_AUDIT_TGS_FAILURE | KDC_AUDIT_MAP_FAILURE);
            }
        }

        break;
    }
    Release();

Cleanup:
    if (DomainPolicy != NULL)
    {
        LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
                    PolicyDomainKerberosTicketInformation,
                    DomainPolicy);
    }
    if (LocalPolicy != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyAuditEventsInformation,
                    LocalPolicy);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::SetForestRoot
//
//  Synopsis:   Sets the forest root
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::SetForestRoot(
    IN PUNICODE_STRING NewForestRoot
    )
{

    NTSTATUS Status;
    UNICODE_STRING Temp;

    WriteLock();

    RtlCopyMemory(
        &Temp,
        &_ForestRoot,
        sizeof(UNICODE_STRING)
        );
    

    Status = KerbDuplicateString(
                &_ForestRoot,
                NewForestRoot
                );        

    // on alloc failure, just keep old version as it will never change
    if (!NT_SUCCESS(Status))
    {
        RtlCopyMemory(
            &_ForestRoot,
            &Temp,
            sizeof(UNICODE_STRING)
            );
    }
    else
    {
        KerbFreeString(&Temp);
    } 

    _KDC_IsForestRoot = IsOurRealm(&_ForestRoot);


    Release();

    return Status; 

}




////////////////////////////////////////////////////////////////////
//
//  Name:       CSecurityData::CSecurityData
//
//  Synopsis:   Constructor.
//
//  Arguments:  <none>
//
//  Notes:      .
//
CSecurityData::CSecurityData()
{
    TRACE(KDC, CSecurityData::CSecurityData, DEB_FUNCTION);

    RtlInitUnicodeString(
        &_MachineName,
        NULL
        );
    RtlInitUnicodeString(
        &_MachineUpn,
        NULL
        );
    RtlInitUnicodeString(
        &_RealmName,
        NULL
        );
    RtlInitUnicodeString(
        &_KDC_Name,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullName,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullDnsName,
        NULL
        );

    RtlInitUnicodeString(
        &_KDC_FullKdcName,
        NULL
        );

    RtlInitUnicodeString(
         &_ForestRoot,
         NULL
         );


    _KerbRealmName = NULL;
    _KerbDnsRealmName = NULL;

    _KrbtgtServiceName = NULL;
    _KpasswdServiceName = NULL;

    RtlZeroMemory(
        &_KrbtgtTicketInfo,
        sizeof(KDC_TICKET_INFO)
        );
    _KrbtgtTicketInfoValid = FALSE;
    _KDC_CrossForestEnabled = FALSE;
    _KDC_IsForestRoot = FALSE;


    RtlInitializeCriticalSection(&_Monitor);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::Init
//
//  Synopsis:   Initializes the global data.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Returns:    STATUS_SUCCESS or error code
//
//  Signals:    May raise exception on out of memory.
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:      This must be called before any other method of
//              CSecurityData.  It gets data from the registry, the domain
//              object, and the kdc.ini file.
//
//----------------------------------------------------------------------------

NTSTATUS
CSecurityData::Init()
{
    TRACE(KDC, CSecurityData::Init, DEB_FUNCTION);

    NTSTATUS Status;
    UNICODE_STRING TempString;
    WCHAR TempMachineName[CNLEN+1];
    ULONG MachineNameLength = CNLEN+1;
    NET_API_STATUS NetStatus;
    LARGE_INTEGER MaxAuthenticatorAge;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    UNICODE_STRING KadminName;
    UNICODE_STRING ChangePwName;


    D_DebugLog(( DEB_TRACE, "Entered CSecurityData::Init()\n" ));

    //
    // Get the domain name and ID from the registry
    //

    Status = KerbDuplicateString(
                &_RealmName,
                &GlobalDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &_KerbRealmName,
                        &GlobalDomainName)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Construct the KDC Name from the realm and the suffix.
    //


    RtlInitUnicodeString(
        &TempString,
        KDC_PRINCIPAL_NAME
        );

    Status = KerbDuplicateString(
                &_KDC_Name,
                &TempString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }



    if (!GetComputerName(
            TempMachineName,
            &MachineNameLength
            ))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &TempString,
        TempMachineName
        );
    Status = KerbDuplicateString(
                &_MachineName,
                &TempString
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &PolicyInfo
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // WAS BUG: this DNS name may have a trailing '.' - if so, strip it off
    //

    if (PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length >= sizeof(WCHAR))
    {
        if (PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Buffer[ -1 + PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length / sizeof(WCHAR) ] == L'.')
        {
            PolicyInfo->PolicyDnsDomainInfo.DnsDomainName.Length -= sizeof(WCHAR);
        }
    }


    Status = KerbDuplicateString(
                &_DnsRealmName,
                (PUNICODE_STRING) &PolicyInfo->PolicyDnsDomainInfo.DnsDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlUpcaseUnicodeString(
                &_DnsRealmName,
                &_DnsRealmName,
                FALSE
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &_KerbDnsRealmName,
                        &_DnsRealmName)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Build the machine UPN: machinename$@dns.domain.name
    //

    _MachineUpn.Length = _MachineName.Length + 2 * sizeof(WCHAR) + _DnsRealmName.Length;
    _MachineUpn.MaximumLength = _MachineUpn.Length + sizeof(WCHAR);
    _MachineUpn.Buffer = (LPWSTR) MIDL_user_allocate(_MachineUpn.MaximumLength);
    if (_MachineUpn.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        _MachineUpn.Buffer,
        _MachineName.Buffer,
        _MachineName.Length
        );
    _MachineUpn.Buffer[_MachineName.Length / sizeof(WCHAR)] = L'$';
    _MachineUpn.Buffer[1+_MachineName.Length / sizeof(WCHAR)] = L'@';
    RtlCopyMemory(
        _MachineUpn.Buffer + _MachineName.Length / sizeof(WCHAR) + 2 ,
        _DnsRealmName.Buffer,
        _DnsRealmName.Length
        );
    _MachineUpn.Buffer[_MachineUpn.Length / sizeof(WCHAR)] = L'\0';

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &_RealmName,
                &_KDC_Name,
                &_KDC_FullName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &_DnsRealmName,
                &_KDC_Name,
                &_KDC_FullDnsName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Build the full kdc name - a kerberos style name
    //

    _KDC_FullKdcName.Length = _KDC_Name.Length + _DnsRealmName.Length + sizeof(WCHAR);
    _KDC_FullKdcName.MaximumLength = _KDC_FullKdcName.Length + sizeof(WCHAR);
    _KDC_FullKdcName.Buffer = (LPWSTR) MIDL_user_allocate(_KDC_FullDnsName.MaximumLength);
    if (_KDC_FullKdcName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    RtlCopyMemory(
        _KDC_FullKdcName.Buffer,
        _KDC_Name.Buffer,
        _KDC_Name.Length
        );
    _KDC_FullKdcName.Buffer[_KDC_Name.Length / sizeof(WCHAR)] = L'/';
    RtlCopyMemory(
        _KDC_FullKdcName.Buffer + 1 + _KDC_Name.Length / sizeof(WCHAR),
        _DnsRealmName.Buffer,
        _DnsRealmName.Length
        );
    _KDC_FullKdcName.Buffer[_KDC_FullKdcName.Length / sizeof(WCHAR)] = L'\0';


    D_DebugLog((DEB_TRACE, "_KDC_Name='%wZ', MachineName='%wZ'\n",
                &_KDC_Name,
                &_MachineName ));

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &_DnsRealmName,
                &_KDC_Name,
                KRB_NT_SRV_INST,
                &_KrbtgtServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // Build the kdc name for kadmin/changepw.
    //

    RtlInitUnicodeString(
        &KadminName,
        KERB_KPASSWD_NAME
        );
    RtlInitUnicodeString(
        &ChangePwName,
        L"changepw"
        );

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &ChangePwName,
                &KadminName,
                KRB_NT_SRV_INST,
                &_KpasswdServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LoadParameters(GlobalAccountDomainHandle);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load parameters: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Create the authenticators.
    //


    //
    // In reality, set skew time to 5 minutes and same for authenticators.
    //

    SkewTime.QuadPart = (LONGLONG) 10000000 * 60 * 5;
    MaxAuthenticatorAge = SkewTime;


    //
    // Create the authenticator list
    //

    Authenticators = new CAuthenticatorList( MaxAuthenticatorAge );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Setup a list to track failed requests - we don't fail the
    // same request twice for the timeout time
    //

    FailedRequests = new CAuthenticatorList( MaxAuthenticatorAge );
    if (FailedRequests == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Register for policy callbacks
    //

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                KdcPolicyChangeCallBack,
                PolicyNotifyDomainKerberosTicketInformation
                );

    if (NT_SUCCESS(Status))
    {
        Status = LsaIRegisterPolicyChangeNotificationCallback(
                    KdcPolicyChangeCallBack,
                    PolicyNotifyAuditEventsInformation
                    );

    }
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to register for policy changes: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = UpdateKrbtgtTicketInfo();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:
    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            PolicyInfo
            );
    }
    return(Status);

}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
CSecurityData::Cleanup()
{
    TRACE(KDC, CSecurityData::Cleanup, DEB_FUNCTION);

    KerbFreeString(&_RealmName);
    KerbFreeString(&_KDC_Name);
    KerbFreeString(&_KDC_FullName);
    KerbFreeString(&_KDC_FullDnsName);
    KerbFreeString(&_KDC_FullKdcName);
    KerbFreeString(&_MachineName);
    KerbFreeString(&_MachineUpn);
    KerbFreeString(&_DnsRealmName);
    KerbFreeRealm(&_KerbRealmName);
    KerbFreeRealm(&_KerbDnsRealmName);
    KerbFreeKdcName(&_KrbtgtServiceName);
    KerbFreeKdcName(&_KpasswdServiceName);

    if (Authenticators != NULL)
    {
        delete Authenticators;
        Authenticators = NULL;
    }
    if (FailedRequests != NULL)
    {
        delete FailedRequests;
        FailedRequests = NULL;
    }

    LsaIUnregisterAllPolicyChangeNotificationCallback(
        KdcPolicyChangeCallBack
        );

}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSecurityData::~CSecurityData()
{
    TRACE(KDC, CSecurityData::~CSecurityData, DEB_FUNCTION);

    Cleanup();

    //
    // This doesn't happen during Cleanup() because we want to
    // make sure it only happens once.
    //

    RtlDeleteCriticalSection(&_Monitor);
}

NTSTATUS
CSecurityData::LoadParameters(SAMPR_HANDLE DomainHandle)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER TempDeltaTime;
    LARGE_INTEGER OneHour, EightHours, TenHours;
    TRACE(KDC, CSecurityData::LoadParameters, DEB_FUNCTION);

    OneHour.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 1;
    EightHours.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 8;
    TenHours.QuadPart = (LONGLONG) 10000000 * 60 * 60 * 10;

    // New internal defaults according to JBrezak. 7/28/99
    //
    // Initialize Tgt lifetime to 10 hours.
    //

    _KDC_TgtTicketLifespan = TenHours;

    //
    // Initialize ticket max renew time to one hour.
    //

    _KDC_TicketRenewSpan = OneHour;

    //
    // Initialize Tgs lifetime to one hour.
    //

    _KDC_TgsTicketLifespan = OneHour;

    //
    // Initialize domain password replication skew tolerance to 60 minutes.
    //

    _KDC_DomainPasswordReplSkew.QuadPart = (LONGLONG) 60*60*10000000;

    //
    // Initialize restriciton lifetime to 20 minutes
    //

    _KDC_RestrictionLifetime.QuadPart = (LONGLONG) 20*60*10000000;

    //
    // Default authentication flags
    //

    _KDC_Flags = AUTH_REQ_ALLOW_FORWARDABLE |
                 AUTH_REQ_ALLOW_PROXIABLE |
                 AUTH_REQ_ALLOW_POSTDATE |
                 AUTH_REQ_ALLOW_RENEWABLE |
                 AUTH_REQ_ALLOW_NOADDRESS |
                 AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                 AUTH_REQ_ALLOW_VALIDATE |
                 AUTH_REQ_VALIDATE_CLIENT |
                 AUTH_REQ_OK_AS_DELEGATE;

    _KDC_AuditEvents = 0;

    //
    // Get kerberos policy information
    //

    Status = ReloadPolicy(
                PolicyNotifyDomainKerberosTicketInformation
                );
    if (!NT_SUCCESS(Status))
    {
        if ((Status != STATUS_NOT_FOUND) && (Status != STATUS_OBJECT_NAME_NOT_FOUND))
        {
            DebugLog((DEB_ERROR,"Failed to reload kerberos ticket policy: 0x%x\n",Status));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }

    //
    // Get audit information
    //

    Status = ReloadPolicy(
                PolicyNotifyAuditEventsInformation
                );

    if (!NT_SUCCESS(Status))
    {
        if (Status != STATUS_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Failed to query audit event info: 0x%x\n",Status));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }





Cleanup:

#if DBG
    DebugShowState();
#endif

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::GetKrbtgtTicketInfo
//
//  Synopsis:   Duplicates ticket info for krbtgt account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
CSecurityData::GetKrbtgtTicketInfo(
    OUT PKDC_TICKET_INFO TicketInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG CredentialSize;

    RtlZeroMemory(
        TicketInfo,
        sizeof(KDC_TICKET_INFO)
        );

    ReadLock();
    if (!_KrbtgtTicketInfoValid)
    {
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Duplicate the cached copy of the KRBTGT information
    //

    *TicketInfo = _KrbtgtTicketInfo;
    TicketInfo->Passwords = NULL;
    TicketInfo->OldPasswords = NULL;
    TicketInfo->TrustSid = NULL;
    TicketInfo->AccountName.Buffer = NULL;

    if (!NT_SUCCESS(KerbDuplicateString(
        &TicketInfo->AccountName,
        &_KrbtgtTicketInfo.AccountName
        )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KdcDuplicateCredentials(
                    &TicketInfo->Passwords,
                    &CredentialSize,
                    _KrbtgtTicketInfo.Passwords,
                    FALSE                               // don't marshall
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    KerbErr = KdcDuplicateCredentials(
                    &TicketInfo->OldPasswords,
                    &CredentialSize,
                    _KrbtgtTicketInfo.OldPasswords,
                    FALSE                               // don't marshall
                    );

Cleanup:
    Release();

    if (!KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(TicketInfo);
    }
    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   CSecurityData::UpdateKrbtgtTicketInfo
//
//  Synopsis:   Triggers an update of the krbtgt ticket info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CSecurityData::UpdateKrbtgtTicketInfo(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KDC_TICKET_INFO NewTicketInfo = {0};
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    KERB_EXT_ERROR ExtendedError; // dummy var

    ReadLock();
    _KrbtgtTicketInfoValid = FALSE;

    KerbErr = KdcGetTicketInfo(
                SecData.KdcServiceName(),
                0,              // no lookup flags
                NULL,           // no principal name
                NULL,           // no realm
                &NewTicketInfo,
                &ExtendedError, // dummy
                NULL,           // no user handle
                USER_ALL_PASSWORDLASTSET,
                0L,             // no extended fields
                &UserInfo,
                NULL            // no group membership
                );

    if (KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(
            &_KrbtgtTicketInfo
            );
        _KrbtgtTicketInfo = NewTicketInfo;
        _KrbtgtTicketInfoValid = TRUE;
        _KrbtgtPasswordLastSet = UserInfo->I1.PasswordLastSet;

        SamIFree_UserInternal6Information( UserInfo );    
    }
    else
    {
        Status = KerbMapKerbError(KerbErr);
    }
    Release();
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcAccountChangeNotificationRoutine
//
//  Synopsis:   Receives notification of changes to interesting accounts
//
//  Effects:    updatees cached krbtgt information
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // We are only interested in the krbtgt account
    //

    if (ObjectRid != DOMAIN_USER_RID_KRBTGT)
    {
        return(STATUS_SUCCESS);
    }

    Status = SecData.UpdateKrbtgtTicketInfo();
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to update krbtgt ticket info: 0x%x\n",Status));
    }
    return(Status);
}


#if DBG
////////////////////////////////////////////////////////////////////////////
//
//  Some debugging functions.
//
void
CSecurityData::DebugShowState(void)
{
    TRACE(KDC, CSecurityData::DebugShowState, DEB_FUNCTION);

    PrintTime(DEB_TRACE, "  TGT Ticket lifespan\t",  &_KDC_TgtTicketLifespan );
    PrintTime(DEB_TRACE, "  Ticket Renew Span\t",&_KDC_TicketRenewSpan );
    D_DebugLog((DEB_TRACE, "  Blank Addresses?\t%s\n",(_KDC_Flags & AUTH_REQ_ALLOW_NOADDRESS ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Proxies?       \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_PROXIABLE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Renewable?     \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_RENEWABLE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Postdated?     \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_POSTDATE ? "Yes" : "No")));
    D_DebugLog((DEB_TRACE, "  Forwardable?   \t%s\n", (_KDC_Flags & AUTH_REQ_ALLOW_FORWARDABLE ? "Yes" : "No")));

}

NTSTATUS
CSecurityData::DebugGetState(   DWORD     * KDCFlags,
                                TimeStamp * MaxLifespan,
                                TimeStamp * MaxRenewSpan)
{
    TRACE(KDC, CSecurityData::DebugGetState, DEB_FUNCTION);

    *KDCFlags = _KDC_Flags;
    *MaxLifespan = _KDC_TgtTicketLifespan;
    *MaxRenewSpan = _KDC_TicketRenewSpan;
    return(STATUS_SUCCESS);
}

NTSTATUS
CSecurityData::DebugSetState(   DWORD       KDCFlags,
                                TimeStamp   MaxLifespan,
                                TimeStamp   MaxRenewSpan)
{
    TRACE(KDC, CSecurityData::DebugSetState, DEB_FUNCTION);

    _KDC_Flags           = KDC_AUTH_STATE(KDCFlags);
    _KDC_AuditEvents     = KDC_AUDIT_STATE(KDCFlags);
    _KDC_TgtTicketLifespan  = MaxLifespan;
    _KDC_TicketRenewSpan = MaxRenewSpan;
    return(STATUS_SUCCESS);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\sockutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.h
//
// Contents:    Prototypes and types for KDC socket utility functions
//
//
// History:     12-July-1996    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SOCKUTIL_H__
#define __SOCKUTIL_H__

#include <winsock2.h>
typedef struct _KDC_ATQ_CONTEXT {
    LIST_ENTRY Next;
    ULONG References;
    PVOID AtqContext;
    PVOID EndpointContext;
    OVERLAPPED * lpo;
    SOCKADDR Address;
    SOCKADDR LocalAddress;
    PBYTE WriteBuffer;
    ULONG WriteBufferLength;
    ULONG Flags;
    ULONG UsedBufferLength;
    ULONG BufferLength;
    ULONG ExpectedMessageSize;
    PUCHAR Buffer;
} KDC_ATQ_CONTEXT, *PKDC_ATQ_CONTEXT;

#define KDC_ATQ_WRITE_CONTEXT   0x1
#define KDC_ATQ_READ_CONTEXT    0x2
#define KDC_ATQ_SOCKET_CLOSED   0x4
#define KDC_ATQ_SOCKET_USED     (KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT)
#define KDC_MAX_BUFFER_LENGTH 0x20000        // maximum size receive buffer = 128k





NTSTATUS
KdcInitializeSockets(
    VOID
    );

NTSTATUS
KdcShutdownSockets(
    VOID
    );

NTSTATUS
KdcInitializeDatagramReceiver(
    VOID
    );

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT * Context,
    IN PKERB_MESSAGE_BUFFER OldMessage
    );

#endif // __SOCKUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\transit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.cxx
//
// Contents:    Code for compressing transitive realm list
//
//
// History:
//
//------------------------------------------------------------------------
#include "kdcsvr.hxx"


//+-----------------------------------------------------------------------
//
// Function:    KerbAppendString
//
// Synopsis:    Appends to unicode strings together and allocates the output
//
// Effects:
//
// Parameters:  Output - Output appended String
//              InputTail - Trailing portion of input
//              InputHead - Head potion of input
//
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------
NTSTATUS
KerbAppendString(
    OUT PUNICODE_STRING Output,
    IN PUNICODE_STRING InputTail,
    IN PUNICODE_STRING InputHead
    )
{
    Output->Buffer = NULL;
    Output->Length = InputHead->Length + InputTail->Length;
    if ((InputHead->Buffer == NULL) && (InputTail->Buffer == NULL))
    {
        Output->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }
    else
    {
        Output->MaximumLength = Output->Length + sizeof(WCHAR);
    }

    Output->Buffer = (LPWSTR) MIDL_user_allocate(Output->MaximumLength);
    if (Output->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        Output->Buffer,
        InputHead->Buffer,
        InputHead->Length
        );
    RtlCopyMemory(
        Output->Buffer + InputHead->Length / sizeof(WCHAR),
        InputTail->Buffer,
        InputTail->Length
        );
    Output->Buffer[Output->Length/sizeof(WCHAR)] = L'\0';
    return(STATUS_SUCCESS);
}


typedef enum _KERB_DOMAIN_COMPARISON {
    Above,
    Below,
    Equal,
    NotEqual
} KERB_DOMAIN_COMPARISON, *PKERB_DOMAIN_COMPARISON;

//+-----------------------------------------------------------------------
//
// Function:    KerbCompareDomains
//
// Synopsis:    Compares two domain names and returns whether one is a
//              prefix of the other, and the offset of the prefix.
//
// Effects:
//
// Parameters:
//
// Return:      Above - domain1 is a postfix of domain2
//              Below - domain2 is a postfix of domain1
//              Equal - the domains are equal
//              NotEqual - the domains are not equal and not above or below
//
// Notes:       This does not work for x-500 realm names (/foo/bar)
//
//------------------------------------------------------------------------

KERB_DOMAIN_COMPARISON
KerbCompareDomains(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2,
    OUT PULONG PostfixOffset
    )
{
    ULONG Index;
    UNICODE_STRING TempString;

    if (Domain1->Length > Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain2->Length;
        TempString.Buffer = Domain1->Buffer + (Domain1->Length - Domain2->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain2,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain1->Length - Domain2->Length) / sizeof(WCHAR);
            return(Below);
        }
        else
        {
            return(NotEqual);
        }
    }
    else if (Domain1->Length < Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain1->Length;
        TempString.Buffer = Domain2->Buffer + (Domain2->Length - Domain1->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain1,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain2->Length - Domain1->Length) / sizeof(WCHAR);
            return(Above);
        }
        else
        {
            return(NotEqual);
        }

    }
    else if (RtlEqualUnicodeString(Domain1,Domain2, TRUE))
    {
        *PostfixOffset = 0;
        return(Equal);
    }
    else
    {
        return(NotEqual);
    }
}

//+-----------------------------------------------------------------------
//
// Function:    KdcExpandTranistedRealms
//
// Synopsis:    Expands the transited realm field into an array of realms
//
// Effects:     Allocates an array of realm names
//
// Parameters:  FullRealmList - receives the full list of realms
//              CountOfRealms - receveies the number of entries in the list
//              TranistedList - The transited field to expand
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG RealmCount;
    ULONG Index;
    ULONG RealmIndex;
    PUNICODE_STRING RealmList = NULL;
    UNICODE_STRING CurrentRealm;

    *FullRealmList = NULL;
    *CountOfRealms = 0;

    //
    // First count the number of realms in the tranisted list. We can do
    // this by counting the number of ',' in the list. Note: if the encoding
    // is compressed by using a null entry to include all domains in a path
    // up or down a hierarchy, this code will fail.
    //

    if (TransitedList->Length == 0)
    {
        return(KDC_ERR_NONE);
    }


    RealmCount = 1;
    for (Index = 0; Index < TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        if (TransitedList->Buffer[Index] == ',')
        {
            RealmCount++;

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
        }
    }

    //
    // We now have a the count of realms. Allocate an array of UNICODE_STRING
    // structures to hold the realms.
    //

    RealmList = (PUNICODE_STRING) MIDL_user_allocate(RealmCount * sizeof(UNICODE_STRING));
    if (RealmList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        RealmList,
        RealmCount * sizeof(UNICODE_STRING)
        );



    //
    // Now loop through and insert the full names of all the domains into
    // the list
    //

    RealmIndex = 0;
    CurrentRealm = *TransitedList;
    for (Index = 0; Index <= TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        //
        // If we hit the end of the string or found a ',', split off a
        // new realm.
        //

        if ((Index == TransitedList->Length / sizeof(WCHAR)) ||
            (TransitedList->Buffer[Index] == ',' ))
        {

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997:: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Length = CurrentRealm.MaximumLength =
                (USHORT)(&TransitedList->Buffer[Index] - CurrentRealm.Buffer) * sizeof(WCHAR);

            //
            // Check for a trailing '.' - if so, append it
            // to the parent
            //

            if (TransitedList->Buffer[Index-1] == '.')
            {
                //
                // This is a compressed name, so append it to the previous
                // name
                //
                if (RealmIndex == 0)
                {
                    DebugLog((DEB_ERROR,"First element in transited encoding has a trailing '.': %wZ\n",
                        TransitedList ));
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &RealmList[RealmIndex-1],
                        &CurrentRealm)))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if ((RealmIndex != 0) && (CurrentRealm.Buffer[0] == '/'))
            {
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &CurrentRealm,
                        &RealmList[RealmIndex-1]
                        )))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if (!NT_SUCCESS(KerbDuplicateString(
                    &RealmList[RealmIndex],
                    &CurrentRealm)))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Buffer =CurrentRealm.Buffer + 1 + CurrentRealm.Length/sizeof(WCHAR);
            RealmIndex++;
        }
    }
    DsysAssert(RealmIndex == RealmCount);

    *FullRealmList = RealmList;
    *CountOfRealms = RealmCount;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (RealmList != NULL)
        {
            for (RealmIndex = 0; RealmIndex < RealmCount ; RealmIndex++ )
            {
                KerbFreeString(&RealmList[RealmIndex]);
            }
            MIDL_user_free(RealmList);
        }
    }

    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcCompressTransitedRealms
//
// Synopsis:    Compresses an ordered list of realms by removing
//              redundant information.
//
// Effects:     Allocates an output string
//
// Parameters:  CompressedRealms - receives the compressed list of realms
//              RealmList - List of domains to compress
//              RealmCount - number of entries in realm list
//              NewRealm - new realm to add to the lsit
//              NewRealmIndex - Location before which to insert the new
//                      realm
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcCompressTransitedRealms(
    OUT PUNICODE_STRING CompressedRealms,
    IN PUNICODE_STRING RealmList,
    IN ULONG RealmCount,
    IN PUNICODE_STRING NewRealm,
    IN ULONG NewRealmIndex
    )
{
    UNICODE_STRING OutputRealms;
    WCHAR OutputRealmBuffer[1000];
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    ULONG InsertionIndex = NewRealmIndex;
    PWCHAR Where;
    PUNICODE_STRING PreviousName = NULL;
    PUNICODE_STRING CurrentName = NULL;
    ULONG PostfixOffset;
    KERB_DOMAIN_COMPARISON Comparison;
    UNICODE_STRING NameToAdd;

    RtlInitUnicodeString(
        CompressedRealms,
        NULL
        );

    OutputRealms.Buffer = OutputRealmBuffer;
    OutputRealms.MaximumLength = sizeof(OutputRealmBuffer);
    OutputRealms.Length = 0;
    Where = OutputRealms.Buffer;

    Index = 0;
    while (Index <= RealmCount)
    {
        PreviousName = CurrentName;

        //
        // If this is the index to insert, add the new realm
        //

        if (InsertionIndex == Index)
        {
            CurrentName = NewRealm;
        }
        else if (Index == RealmCount)
        {
            //
            // If we already added all the original realms, get out now
            //

            break;
        }
        else
        {
            CurrentName = &RealmList[Index];
        }

        NameToAdd = *CurrentName;

        //
        // If the previous name is above this one, lop off the postfix from
        // this name
        //

        if ((PreviousName != NULL) &&
            KerbCompareDomains(
                PreviousName,
                CurrentName,
                &PostfixOffset
                ) == Above)
        {
            NameToAdd.Length = (USHORT) PostfixOffset * sizeof(WCHAR);
        }


        DsysAssert(OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) < OutputRealms.MaximumLength);
        if (OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) > OutputRealms.MaximumLength)
        {
            //
            // BUG 453652: wrong error
            //

            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        if (OutputRealms.Length != 0)
        {
            *Where++ = L',';
            OutputRealms.Length += sizeof(WCHAR);

        }
        RtlCopyMemory(
            Where,
            NameToAdd.Buffer,
            NameToAdd.Length
            );
        Where += NameToAdd.Length/sizeof(WCHAR);
        OutputRealms.Length += NameToAdd.Length;

        //
        // If we inserted the transited realm here, run through the loop
        // again with the same index.
        //

        if (InsertionIndex == Index)
        {
            InsertionIndex = 0xffffffff;
        }
        else
        {
            Index++;
        }
    }

    *Where++ = L'\0';


    if (!NT_SUCCESS(KerbDuplicateString(
            CompressedRealms,
            &OutputRealms)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
Cleanup:
    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcInsertTransitedRealm
//
// Synopsis:    Inserts the referree's realm into the tranisted encoding
//              in a ticket. This uses domain-x500-compress which
//              eliminates redundant information when one domain is the
//              prefix or suffix of another.
//
// Effects:     Allocates output buffer
//
// Parameters:  NewTransitedField - receives the new tranisted field, to
//                      be freed with KerbFreeString
//              OldTransitedField - the existing transited frield.
//              ClientRealm - Realm of client (from ticket)
//              TransitedRealm - Realm of referring domain
//              OurRealm - Our realm name
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN PUNICODE_STRING OurRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING FullDomainList = NULL;
    ULONG CountOfDomains;
    ULONG NewEntryIndex = 0xffffffff;
    UNICODE_STRING NewDomain;
    ULONG PostfixOffset;
    ULONG Index;
    KERB_DOMAIN_COMPARISON Comparison = NotEqual;
    KERB_DOMAIN_COMPARISON LastComparison;

    //
    // The first thing to do is to expand the existing transited field. This
    // is because the compression scheme does not allow new domains to simply
    // append or insert information - the encoding of existing realms
    // can change. For example, going from a domain to its parent means
    // that the original domain can be encoded as a prefix of the parent
    // whereas originally it was a name unto itself.
    //

    D_DebugLog((DEB_T_TRANSIT, "Inserted realm %wZ into list %wZ for client fomr %wZ\n",
        TransitedRealm, OldTransitedField, ClientRealm ));

    KerbErr = KdcExpandTransitedRealms(
                &FullDomainList,
                &CountOfDomains,
                OldTransitedField
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now loop through the domains. Based on the compression, we know that
    // higher up domains come first.
    //

    for (Index = 0; Index < CountOfDomains ; Index++ )
    {
        LastComparison = Comparison;

        Comparison = KerbCompareDomains(
                        TransitedRealm,
                        &FullDomainList[Index],
                        &PostfixOffset
                        );
        if (Comparison == Above)
        {
            //
            // If the new domain is above an existing domain, it gets inserted
            // before the existing domain because all the existing domains
            // are ordered from top to bottom
            //
            NewEntryIndex = Index;
            break;
        }
        else if (Comparison == Below)
        {
            //
            // There may be other domains below which are closer, so
            // store the result and continue.
            //
            LastComparison = Comparison;
        }
        else if (Comparison == NotEqual)
        {
            //
            // The domains aren't above or below each other. If the last
            // comparison was below, stick the domain underneath it.
            //
            if (LastComparison == Below)
            {
                NewEntryIndex = Index;
                break;
            }
        }
    }

    //
    // If we didn't find a place for it, stick it in at the end.
    //

    if (NewEntryIndex == 0xffffffff)
    {
        NewEntryIndex = Index;
    }

    //
    // Now build the new encoding
    //

    KerbErr = KdcCompressTransitedRealms(
                NewTransitedField,
                FullDomainList,
                CountOfDomains,
                TransitedRealm,
                NewEntryIndex
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (FullDomainList != NULL)
    {
        for (Index = 0; Index < CountOfDomains ; Index++ )
        {
            KerbFreeString(&FullDomainList[Index]);
        }
        MIDL_user_free(FullDomainList);
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\utest\kdcdbg_c_stub.c ===
#include "kdcdbg_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\sockutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.cxx
//
// Contents:    Server support routines for sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "sockutil.h"
extern "C"
{
#include <atq.h>
}
#include <issched.hxx>

#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      5
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
#define KDC_CONTEXT_TIMEOUT             50

BOOLEAN KdcSocketsInitialized = FALSE;
PVOID KdcEndpoint = NULL;
PVOID KpasswdEndpoint = NULL;
RTL_CRITICAL_SECTION KdcAtqContextLock;
LIST_ENTRY KdcAtqContextList;


NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    );

NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    );











//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCloseSocket
//
//  Synopsis:   Wrapper to close socket to avoid socket leaks
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcAtqCloseSocket(
    IN PKDC_ATQ_CONTEXT Context
    )
{
    D_DebugLog ((DEB_T_SOCK, "Closing socket for 0x%x\n", Context));
    AtqCloseSocket((PATQ_CONTEXT) Context->AtqContext, TRUE);
    Context->Flags |= KDC_ATQ_SOCKET_CLOSED;
}                                           




//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqReferenceContext
//
//  Synopsis:   References a kdc ATQ context by one
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqReferenceContext(
    IN PKDC_ATQ_CONTEXT Context
    )
{
    D_DebugLog ((DEB_T_SOCK, "Referencing KdcContext 0x%x\n", Context));
    RtlEnterCriticalSection(&KdcAtqContextLock);
    Context->References++;
    RtlLeaveCriticalSection(&KdcAtqContextLock);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDereferenceContext
//
//  Synopsis:   Dereferences a context & unlinks & frees it when the
//              ref count goes to zero
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KdcAtqDereferenceContext(
    IN PKDC_ATQ_CONTEXT * KdcContext
    )
{
    PKDC_ATQ_CONTEXT Context = *KdcContext;
    BOOLEAN Deleted = FALSE;

    D_DebugLog ((DEB_T_SOCK, "Dereferencing KdcContext 0x%x\n", Context));

    if (Context == NULL)
    {
        goto Cleanup;
    }

    RtlEnterCriticalSection(&KdcAtqContextLock);
    Context->References--;

    if (Context->References == 0)
    {
        Deleted = TRUE;
        RemoveEntryList(
            &Context->Next
            );
    }
    RtlLeaveCriticalSection(&KdcAtqContextLock);

    if (Deleted)
    {
        
        if (((Context->Flags &  KDC_ATQ_SOCKET_USED) != 0) &&
            ((Context->Flags & KDC_ATQ_SOCKET_CLOSED) == 0))
        {   
            KdcAtqCloseSocket( Context );
        }                                
        
        
        D_DebugLog ((DEB_T_SOCK, "Deleting KdcContext 0x%x\n", Context));
        AtqFreeContext( (PATQ_CONTEXT) Context->AtqContext, TRUE );

        if (Context->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(Context->WriteBuffer);
        }
        if (Context->Buffer != NULL)
        {
            MIDL_user_free(Context->Buffer);
        }
        MIDL_user_free(Context);
        *KdcContext = NULL;

    }
   
Cleanup:
    return(Deleted);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCreateContext
//
//  Synopsis:   Creates & links an ATQ context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



PKDC_ATQ_CONTEXT
KdcAtqCreateContext(
    IN PATQ_CONTEXT AtqContext,
    IN PVOID EndpointContext,
    IN LPOVERLAPPED lpo,
    IN PSOCKADDR ClientAddress,
    IN PSOCKADDR ServerAddress
    )
{
    PKDC_ATQ_CONTEXT KdcContext;

    if (!KdcSocketsInitialized)
    {
        return(NULL);
    }

    KdcContext = (PKDC_ATQ_CONTEXT) MIDL_user_allocate(sizeof(KDC_ATQ_CONTEXT));
    if (KdcContext != NULL)
    {
        RtlZeroMemory(
            KdcContext,
            sizeof(KDC_ATQ_CONTEXT)
            );
        KdcContext->AtqContext = AtqContext;
        KdcContext->Flags = KDC_ATQ_WRITE_CONTEXT;
        KdcContext->BufferLength = KERB_MAX_KDC_REQUEST_SIZE;
        KdcContext->UsedBufferLength = 0;
        KdcContext->lpo = lpo;
        KdcContext->EndpointContext = EndpointContext;
        KdcContext->ExpectedMessageSize = 0;
        KdcContext->WriteBuffer = NULL;
        KdcContext->References = 2;             // one for the list, one for this copy

        RtlCopyMemory(
            &KdcContext->Address,
            ClientAddress,
            sizeof(SOCKADDR)
            );
        RtlCopyMemory(
            &KdcContext->LocalAddress,
            ServerAddress,
            sizeof(SOCKADDR)
            );

        KdcContext->Buffer = (PUCHAR) MIDL_user_allocate(KERB_MAX_KDC_REQUEST_SIZE);
        if (KdcContext->Buffer == NULL)
        {
            MIDL_user_free(KdcContext);
            KdcContext = NULL;
        }
        else
        {
            RtlEnterCriticalSection( &KdcAtqContextLock );
            InsertHeadList(&KdcAtqContextList, &KdcContext->Next);
            RtlLeaveCriticalSection( &KdcAtqContextLock );
        }
    }
    D_DebugLog ((DEB_T_SOCK, "Creating KdcContext 0x%x\n", KdcContext));
    return(KdcContext);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqConnectEx
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqConnectEx(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    KERBERR KerbErr;
    PKDC_ATQ_CONTEXT KdcContext = NULL;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKADDR * LocalAddress = NULL;
    SOCKADDR * RemoteAddress = NULL;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PVOID Buffer;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;
    ULONG TotalBytes;



    TRACE(KDC,KdcAtqConnectEx, DEB_FUNCTION);

    if ((CompletionStatus != NO_ERROR) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK," ConnectEx: CompletionStatus = 0x%x\n",CompletionStatus));
        AtqCloseSocket( AtqContext, TRUE );
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",AtqContext));
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    //
    // Get the address information including the first write buffer
    //

    AtqGetAcceptExAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &EndpointFunction,
        &LocalAddress,
        &RemoteAddress
        );

    //
    // Verify that the size is something OK before continuing on
    //

    //
    // Read the number of bytes off the front of the message
    //
    if (BytesWritten >= sizeof(ULONG))
    {
        TotalBytes = ntohl(*(PULONG)Buffer);
        if (TotalBytes >= KDC_MAX_BUFFER_LENGTH)
        {
            D_DebugLog((DEB_T_SOCK, "Received huge buffer - %x, bailing out now\n", TotalBytes));
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( AtqContext, TRUE );
            return;
        }

    }
    else
    {   
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }
    
    

    //
    // If the remote address is port 88 or 464, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KPASSWD_PORT))
    {
        //
        // Just free up the context so it can be reused.
        //
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }


    //
    // Set the timeout for future IOs on this context
    //

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_TIMEOUT,
        KDC_CONTEXT_TIMEOUT
        );

    //
    // Create a context
    //

    KdcContext = KdcAtqCreateContext(
                    AtqContext,
                    EndpointFunction,
                    lpo,
                    RemoteAddress,
                    LocalAddress
                    );

    if (KdcContext == NULL)
    {
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_COMPLETION_CONTEXT,
        (ULONG_PTR) KdcContext
        );  

    
    //
    // If we didn't receive all the data, go ahead and read more
    //
    
    KdcContext->ExpectedMessageSize = TotalBytes + sizeof(ULONG);

    if (KdcContext->ExpectedMessageSize > BytesWritten)
    {
        InputMessage.BufferSize = BytesWritten;
        InputMessage.Buffer = (PUCHAR) Buffer;


        KerbErr = KdcAtqRetrySocketRead(
            &KdcContext,
            &InputMessage
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
            DsysAssert(KdcContext->References == 1);
        }

        KdcAtqDereferenceContext(&KdcContext);
        return;
    }
    InputMessage.BufferSize = BytesWritten - sizeof(ULONG);
    InputMessage.Buffer = (PUCHAR) Buffer + sizeof(ULONG);
    OutputMessage.Buffer = NULL;


    //
    // Call either the KdcGetTicket or KdcChangePassword function, based
    // on which endpoint was used
    //

    KerbErr = EndpointFunction(
                    &KdcContext,
                    &KdcContext->Address,
                    &KdcContext->LocalAddress,
                    &InputMessage,
                    &OutputMessage
                    );

    if ((KerbErr != KDC_ERR_NONE) || (OutputMessage.BufferSize != 0))
    {
        
        //
        // We expect at least some level of message validity before 
        // we'll return anything.
        //
        if (KerbErr == KDC_ERR_NO_RESPONSE)
        {
            // TBD:  Log an "attack" event here.
            DebugLog((DEB_ERROR, "Bad buffer recieved, closing socket\n"));
            KdcAtqCloseSocket(KdcContext);
            KdcAtqDereferenceContext(&KdcContext);                         
        }
        else
        {
            ULONG NetworkSize;
            WSABUF Buffers[2];

            NetworkSize = htonl(OutputMessage.BufferSize);

            Buffers[0].len = sizeof(DWORD);
            Buffers[0].buf = (PCHAR) &NetworkSize;

            Buffers[1].len = OutputMessage.BufferSize;
            Buffers[1].buf = (PCHAR) OutputMessage.Buffer;
            KdcContext->WriteBufferLength = OutputMessage.BufferSize;
            KdcContext->WriteBuffer = OutputMessage.Buffer;

            OutputMessage.Buffer = NULL;

            //      
            // Reference the context for the read
            //              

            KdcAtqReferenceContext(KdcContext);

            if (!AtqWriteSocket(
                    (PATQ_CONTEXT) KdcContext->AtqContext,
                    Buffers,
                    2,
                    lpo
                    ))
            {
                DebugLog((DEB_ERROR,"Failed to write kdc reply to atq: %0x%x\n",GetLastError()));
                KdcAtqDereferenceContext(&KdcContext);
            }
        }

    }
    if (OutputMessage.Buffer != NULL)
    {
        MIDL_user_free(OutputMessage.Buffer);
    }

    KdcAtqDereferenceContext(&KdcContext);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqIoCompletion
//
//  Synopsis:   Callback routine for an io completion on a TCP socket
//              for the KDC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{

    PVOID Buffer;
    PKDC_ATQ_CONTEXT KdcContext;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    TRACE(KDC,KdcAtqIoCompletion, DEB_FUNCTION);

    if (Context == NULL)
    {
        return;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }


    KdcContext = (PKDC_ATQ_CONTEXT) Context;


    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK,"IoCompletion: CompletionStatus = 0x%x\n",CompletionStatus));
        D_DebugLog((DEB_T_SOCK,"IoCompletion: lpo = %p\n",lpo));



        KdcAtqCloseSocket(  KdcContext );

        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",KdcContext->AtqContext));

        //
        // If the overlapped structure is not null, then there is an
        // outstanding IO that just completed, so dereference the context
        // to remove that i/o. Otherwise leave the reference there, as we will
        // probably be called back when the io terminates.
        //

        if (lpo != NULL)
        {
            KdcAtqDereferenceContext(&KdcContext);
        }

        goto Cleanup;
    }


    //
    // NOTE: after reading or writing to a context, the context should
    // not be touched because a completion may have occurred on another
    // thread that may delete the context.
    //

    if ((KdcContext->Flags & KDC_ATQ_READ_CONTEXT) != 0)
    {
        KERBERR KerbErr;
        ULONG TotalBytes = 0;

        //
        // Read the number of bytes off the front of the message
        //

        if (KdcContext->UsedBufferLength == 0)
        {
            if (BytesWritten >= sizeof(ULONG))
            {
                KdcContext->ExpectedMessageSize = ntohl(*(PULONG)KdcContext->Buffer);
            }
            else
            {
                DebugLog((DEB_ERROR,"Read completion with no data!\n"));
                goto Cleanup;
            }
        }

        //
        // Figure out if we've already read all the data we need
        //

        TotalBytes = KdcContext->UsedBufferLength + BytesWritten;
        if (TotalBytes < KdcContext->ExpectedMessageSize)
        {
            InputMessage.BufferSize = BytesWritten ;
            InputMessage.Buffer = (PUCHAR) KdcContext->Buffer;

            KerbErr = KdcAtqRetrySocketRead(
                            &KdcContext,
                            &InputMessage
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                //fester
                DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
                DsysAssert(KdcContext->References == 1);

            }

            goto Cleanup;
        }
        TotalBytes = ntohl(*(PULONG)KdcContext->Buffer);
        KdcContext->ExpectedMessageSize = TotalBytes + sizeof(ULONG);

        if (KdcContext->UsedBufferLength + BytesWritten < KdcContext->ExpectedMessageSize)
        {
            InputMessage.BufferSize = BytesWritten ;
            InputMessage.Buffer = (PUCHAR) KdcContext->Buffer;

            KerbErr = KdcAtqRetrySocketRead(
                            &KdcContext,
                            &InputMessage
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                //fester
                DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
                DsysAssert(KdcContext->References == 1);
            }

            goto Cleanup;
        }

        //
        // There is a buffer, so use it to do the KDC thang.
        //

        KdcContext->lpo = lpo;
        InputMessage.BufferSize = (KdcContext->UsedBufferLength + BytesWritten) - sizeof(ULONG);
        InputMessage.Buffer = KdcContext->Buffer + sizeof(ULONG);
        OutputMessage.Buffer = NULL;

        EndpointFunction = (PKDC_GET_TICKET_ROUTINE) KdcContext->EndpointContext;

        KerbErr = EndpointFunction(
                        &KdcContext,
                        &KdcContext->Address,
                        &KdcContext->LocalAddress,
                        &InputMessage,
                        &OutputMessage
                        );

        if ((KerbErr != KDC_ERR_NONE) || (OutputMessage.BufferSize != 0))
        {
            //
            // We expect at least some level of message validity before 
            // we'll return anything.
            //
            if (KerbErr == KDC_ERR_NO_RESPONSE)
            {
                // TBD:  Log an "attack" event here.
                KdcAtqCloseSocket(KdcContext);
                KdcAtqDereferenceContext(&KdcContext);                         
            }
            else
            {
                ULONG NetworkSize;
                WSABUF Buffers[2];

                NetworkSize = htonl(OutputMessage.BufferSize);

                Buffers[0].len = sizeof(DWORD);
                Buffers[0].buf = (PCHAR) &NetworkSize;

                Buffers[1].len = OutputMessage.BufferSize;
                Buffers[1].buf = (PCHAR) OutputMessage.Buffer;
                KdcContext->WriteBufferLength = OutputMessage.BufferSize;
                KdcContext->WriteBuffer = OutputMessage.Buffer;

                OutputMessage.Buffer = NULL;

                //      
                // If there was no output message, don't send one.
                //              

                KdcContext->Flags |= KDC_ATQ_WRITE_CONTEXT;
                KdcContext->Flags &= ~KDC_ATQ_READ_CONTEXT;
                //              
                // Refernce the context for the write.
                //                      

                KdcAtqReferenceContext(KdcContext);

                if (!AtqWriteSocket(
                    (PATQ_CONTEXT) KdcContext->AtqContext,
                    Buffers,
                    2,
                    lpo
                    ))
                {
                    DebugLog((DEB_ERROR,"Failed to write KDC reply: 0x%x\n",GetLastError()));
                    KdcAtqCloseSocket(  KdcContext );
                    KdcAtqDereferenceContext(&KdcContext);
                }   

            }


            if (OutputMessage.Buffer != NULL)
            {
                KdcFreeEncodedData(OutputMessage.Buffer);
            }
        }
    }
    else
    {
        KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
        KdcContext->Flags &= ~KDC_ATQ_WRITE_CONTEXT;

        //
        // Ignore the true size of the buffer
        //

        KdcContext->BufferLength = KERB_MAX_KDC_REQUEST_SIZE;
        KdcContext->UsedBufferLength = 0;
        KdcContext->ExpectedMessageSize = 0;
        if (KdcContext->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(KdcContext->WriteBuffer);

            KdcContext->WriteBuffer = NULL;
        }

        //
        // Reference the context for the read
        //

        KdcAtqReferenceContext(KdcContext);

        if (!AtqReadFile(
                (PATQ_CONTEXT) KdcContext->AtqContext,
                KdcContext->Buffer,
                KERB_MAX_KDC_REQUEST_SIZE,
                lpo
                ))
        {
            DebugLog((DEB_ERROR,"Failed to read file for %d bytes: 0x%x\n",KERB_MAX_KDC_REQUEST_SIZE,GetLastError()));
            KdcAtqCloseSocket(  KdcContext );

            //
            // Dereference the reference we just added
            //

            KdcAtqDereferenceContext(&KdcContext);

            //
            // Derefernece the reference on the list
            //

            KdcAtqDereferenceContext(&KdcContext);

        }

    }

Cleanup:
    if (KdcContext != NULL)
    {
        KdcAtqDereferenceContext(&KdcContext);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqRetrySocketRead
//
//  Synopsis:   Retries a read if not all the data was read
//
//  Effects:    posts an AtqReadSocket
//
//  Arguments:  Context - The KDC context to retry the read on
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT * Context,
    IN PKERB_MESSAGE_BUFFER OldMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKDC_ATQ_CONTEXT KdcContext = *Context;
    PBYTE NewBuffer = NULL;
    ULONG NewBufferLength;

    D_DebugLog(( DEB_T_SOCK, "RetrySocketRead:  Expected size = %#x, current size %#x\n",
                KdcContext->ExpectedMessageSize,
                KdcContext->UsedBufferLength));

    if (KdcContext->ExpectedMessageSize != 0)
    {
        NewBufferLength = KdcContext->ExpectedMessageSize;
    }
    else
    {
        //
        // Set max buffer length at 128k
        //
        if (KdcContext->BufferLength < KDC_MAX_BUFFER_LENGTH)
        {
            NewBufferLength = KdcContext->BufferLength + KERB_MAX_KDC_REQUEST_SIZE;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
            goto cleanup;
        }
    }

    if (NewBufferLength > KDC_MAX_BUFFER_LENGTH)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto cleanup;
    }

    //
    // If the expected message size doesn't fit in the current buffer,
    // allocate a new one.
    //

    if (NewBufferLength > KdcContext->BufferLength)
    {
        D_DebugLog(( DEB_T_SOCK, "Allocating a new buffer for context %x\n",
                    Context ));

        NewBuffer = (PBYTE) MIDL_user_allocate( NewBufferLength );

        if (NewBuffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto cleanup;
        }

        if ( KdcContext->Buffer == OldMessage->Buffer )
        {
            //
            // we resized while the buffer was in use.  Copy the data and touch up
            // the pointers below
            //

            RtlCopyMemory(
                    NewBuffer,
                    OldMessage->Buffer,         // same as KdcContext->Buffer
                    OldMessage->BufferSize );

            OldMessage->Buffer = NewBuffer ;
        }

        MIDL_user_free(KdcContext->Buffer);

        KdcContext->Buffer = NewBuffer;
        KdcContext->BufferLength = NewBufferLength;
        NewBuffer = NULL;
    }

    if (KdcContext->Buffer != OldMessage->Buffer)
    {
        RtlMoveMemory(
            KdcContext->Buffer,
            OldMessage->Buffer,
            OldMessage->BufferSize
            );

    }

    KdcContext->UsedBufferLength = KdcContext->UsedBufferLength + OldMessage->BufferSize;
    KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
    KdcContext->Flags &= ~(KDC_ATQ_WRITE_CONTEXT);

    //
    // Reference the context for the read
    //

    KdcAtqReferenceContext(KdcContext);

    if (!AtqReadFile(
            (PATQ_CONTEXT) KdcContext->AtqContext,
            (PUCHAR) KdcContext->Buffer + KdcContext->UsedBufferLength,
            KdcContext->BufferLength - KdcContext->UsedBufferLength,
            KdcContext->lpo
            ))
    {
        DebugLog((DEB_ERROR,"Failed to read file for %d bytes: 0x%x\n",KdcContext->BufferLength - KdcContext->UsedBufferLength, GetLastError));
        
        //
        // Dereference the reference we just added
        //

        KdcAtqDereferenceContext(&KdcContext);  
        KerbErr = KRB_ERR_GENERIC;
        goto cleanup;                           
    }

cleanup:
    
    if (!KERB_SUCCESS(KerbErr))
    {
        KdcAtqCloseSocket( KdcContext );
        KdcAtqDereferenceContext(&KdcContext);
    }                                           

    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqConnection
//
//  Synopsis:   Connection handling routine for KDC ATQ code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqConnect(
    IN SOCKET sNew,
    IN LPSOCKADDR_IN pSockAddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    )
{
    TRACE(KDC,KdcAtqConnect, DEB_FUNCTION);
    DebugLog((DEB_T_SOCK,"KdcAtqConnect called\n"));
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInitializeSockets(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    PATQ_CONTEXT EndpointContext = NULL;
    BOOLEAN AtqInitCalled = FALSE;

    TRACE(KDC,KdcInitializeSockets, DEB_FUNCTION);



    //
    // Initialize the asynchronous thread queue.
    //

    if (!AtqInitialize(0)) 
    {
        DebugLog((DEB_ERROR,"Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    AtqInitCalled = TRUE;

    Status = RtlInitializeCriticalSection(&KdcAtqContextLock);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    InitializeListHead(&KdcAtqContextList);


    //
    // Create the KDC endpoint
    //

    EndpointConfig.ListenPort = KERB_KDC_PORT;
    EndpointConfig.IpAddress = INADDR_ANY;
    EndpointConfig.cbAcceptExRecvBuffer = KDC_MAX_ACCEPT_BUFFER;
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = KDC_ACCEPT_TIMEOUT;

    EndpointConfig.pfnConnect = KdcAtqConnect;
    EndpointConfig.pfnConnectEx = KdcAtqConnectEx;
    EndpointConfig.pfnIoCompletion = KdcAtqIoCompletion;

    EndpointConfig.fDatagram = FALSE;
    EndpointConfig.fLockDownPort = TRUE;

    KdcEndpoint = AtqCreateEndpoint(
                    &EndpointConfig,
                    KdcGetTicket
                    );
    if (KdcEndpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KdcEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    //
    // Create the KPASSWD endpoint
    //

    EndpointConfig.ListenPort = KERB_KPASSWD_PORT;

    KpasswdEndpoint = AtqCreateEndpoint(
                        &EndpointConfig,
                        KdcChangePassword
                        );
    if (KpasswdEndpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint for kpasswd\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KpasswdEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening for kpasswd\n"));

    Status = KdcInitializeDatagramSockets( );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KdcSocketsInitialized = TRUE;


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (KdcEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KdcEndpoint );
            (VOID) AtqCloseEndpoint( KdcEndpoint );
            KdcEndpoint = NULL;
        }

        if (KpasswdEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KpasswdEndpoint );
            (VOID) AtqCloseEndpoint( KpasswdEndpoint );
            KpasswdEndpoint = NULL;
        }

        if (AtqInitCalled)
        {
            AtqTerminate();
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcShutdownSockets(
    VOID
    )
{
    PKDC_ATQ_CONTEXT Context;
    PLIST_ENTRY ListEntry;

    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);

    if (!KdcSocketsInitialized)
    {
        return(STATUS_SUCCESS);
    }


    //
    // Go through the list of contexts and close them all.
    //

    RtlEnterCriticalSection( &KdcAtqContextLock );

    KdcSocketsInitialized = FALSE;

    for (ListEntry = KdcAtqContextList.Flink;
        (ListEntry != &KdcAtqContextList) && (ListEntry != NULL) ;
        ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KDC_ATQ_CONTEXT, Next);

        //
        // If this is a read or write context, free close the associated
        // socket. (Endpoint contexts don't have sockets).
        //

        if (Context->Flags & ( KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT))
        {
            KdcAtqCloseSocket( Context );
        }


    }

    RtlLeaveCriticalSection( &KdcAtqContextLock );

    if (KdcEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KdcEndpoint );
        (VOID) AtqCloseEndpoint( KdcEndpoint );
        KdcEndpoint = NULL;
    }
    if (KpasswdEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KpasswdEndpoint );
        (VOID) AtqCloseEndpoint( KpasswdEndpoint );
        KpasswdEndpoint = NULL;
    }

    KdcShutdownDatagramSockets();
    if (KdcSocketsInitialized)
    {
        if (!AtqTerminate())
        {
            DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
        }
        RtlDeleteCriticalSection(&KdcAtqContextLock);
        
    }
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\tktutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tktutil.cxx
//
//  Contents:   x//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------


// Place any local #includes files here.

#include "kdcsvr.hxx"
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
}
#if DBG
#include <perftimr.hxx>
#endif

#include <userall.h>

#define FILENO FILENO_TKTUTIL
#define KDC_WSZ_GC              L"gc"
#define KDC_GC_NAMEPARTS        3

//#define DONT_SUPPORT_OLD_TYPES_KDC 1

//
// Static data
//



//
// Fudge factor for comparing timestamps, because network clocks may
// be out of sync.
// Note: The lowpart is first!
//

LARGE_INTEGER SkewTime;



KERBERR
KdcGetTicketInfo(
    IN PUNICODE_STRING UserName,
    IN ULONG LookupFlags,
    IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * RetUserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    );


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildNt4Name
//
//  Synopsis:   Construct an NT4 style name for an account by separating
//              the name into a principal & domain name, converting the
//              domain name to netbios, and then creating "domain\user" name.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildNt4Name(
    OUT LPWSTR * Nt4Name,
    OUT PUNICODE_STRING OutputRealm,
    IN PUNICODE_STRING Upn
    )
{
    ULONG Index;
    KERBERR KerbErr = KDC_ERR_NONE;
    LPWSTR OutputName = NULL;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    UNICODE_STRING RealmName;
    UNICODE_STRING PrincipalName;

    //
    // Find the first backslash or '@', or '.' in the name
    //


    RtlInitUnicodeString(
        OutputRealm,
        NULL
        );
    *Nt4Name = NULL;

    for (Index = Upn->Length/sizeof(WCHAR) - 1; Index > 0 ; Index-- )
    {
        if (Upn->Buffer[Index] == L'@')
        {
            break;
        }
    }

    if (Index == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Pull out the realm name and look it up in the list of domains
    //

    PrincipalName = *Upn;
    PrincipalName.Length = (USHORT) Index * sizeof(WCHAR);
    PrincipalName.MaximumLength = (USHORT) Index * sizeof(WCHAR);


    RealmName.Buffer = &Upn->Buffer[Index+1];
    RealmName.Length = (USHORT) (Upn->Length - (Index + 1) * sizeof(WCHAR));
    RealmName.MaximumLength = RealmName.Length;


    KerbErr = KdcLookupDomainName(
                &DomainInfo,
                &RealmName,
                &KdcDomainList
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // We need a netbios name
    //

    if (DomainInfo->NetbiosName.Length == 0)
    {
        //
        // Copy out the realm name so we can return a non-authoritative referral
        //

        if (!NT_SUCCESS(KerbDuplicateString(
                OutputRealm,
                &DomainInfo->DnsName
                )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }

    //
    // now build the output name
    //

    OutputName = (LPWSTR) MIDL_user_allocate(DomainInfo->NetbiosName.Length + PrincipalName.Length + 2 * sizeof(WCHAR));
    if (OutputName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        OutputName,
        DomainInfo->NetbiosName.Buffer,
        DomainInfo->NetbiosName.Length
        );
    OutputName[DomainInfo->NetbiosName.Length/sizeof(WCHAR)] = L'\\';
    RtlCopyMemory(
        OutputName + DomainInfo->NetbiosName.Length/sizeof(WCHAR) + 1,
        PrincipalName.Buffer,
        PrincipalName.Length
        );
    OutputName[1 + (PrincipalName.Length + DomainInfo->NetbiosName.Length)/sizeof(WCHAR)] = L'\0';

    *Nt4Name = OutputName;
    OutputName = NULL;
Cleanup:

    if (DomainInfo != NULL)
    {
        KdcDereferenceDomainInfo( DomainInfo );
    }
    if (OutputName != NULL)
    {
        MIDL_user_free( OutputName );
    }
    return(KerbErr);

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcMatchCrossForestName
//
//  Synopsis:   Builds a list of the supplemental credentials and then
//              encrypts it with the supplied key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcMatchCrossForestName(
    IN PKERB_INTERNAL_NAME Principal,
    OUT PUNICODE_STRING RealmName
    )
{


    NTSTATUS                Status = STATUS_SUCCESS;
    LSA_ROUTING_MATCH_TYPE  MatchType;
    KERBERR                 KerbErr = KDC_ERR_NONE;
    UNICODE_STRING          UnicodePrincipal = {0};

    switch (Principal->NameType)
    {
    case KRB_NT_ENTERPRISE_PRINCIPAL:
        MatchType = RoutingMatchUpn;
        break;
    case KRB_NT_SRV_INST:
        MatchType = RoutingMatchSpn;
        break;
    default:
        
        return KRB_ERR_GENERIC;
    }

    KerbErr = KerbConvertKdcNameToString(
                    &UnicodePrincipal,
                    Principal,
                    NULL
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }                

    //
    // Can we match the SPN / UPN to external name space (realm)
    //
    Status = LsaIForestTrustFindMatch(
                    MatchType,
                    &UnicodePrincipal,
                    RealmName
                    );


    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "LsaIForestTrustFindMatch failed - %x\n",Status));
        goto Cleanup;
    }
      

Cleanup:
    
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    KerbFreeString(&UnicodePrincipal);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCrackNameAtGC
//
//  Synopsis:   Cracks a name at a GC by first looking it up for
//              UPN/SPN and then constructing an NT4-style name to lookup
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCrackNameAtGC(
    IN PUNICODE_STRING Upn,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN DS_NAME_FORMAT NameType,
    OUT PUNICODE_STRING RealmName,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN Referral,
    OUT PBOOLEAN CrossForest,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * UserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    LPWSTR NullTerminatedName = NULL;
    UNICODE_STRING CrackedDomain = {0};
    UNICODE_STRING LocalCrackedString = {0};
    LPWSTR CrackedDnsDomain = NULL;
    ULONG CrackedDomainLength = (DNS_MAX_NAME_LENGTH+1) * sizeof(WCHAR);
    LPWSTR CrackedName = NULL;
    ULONG CrackedNameLength = (UNLEN+DNS_MAX_NAME_LENGTH + 2) * sizeof(WCHAR);
    ULONG CrackError = 0;
    BOOLEAN Retry = TRUE;
    BOOLEAN ReferToRoot = FALSE, UsedHack = FALSE;
    ULONG NameFlags = DS_NAME_FLAG_TRUST_REFERRAL | DS_NAME_FLAG_GCVERIFY; 
            
    SECPKG_CALL_INFO CallInfo ;

    *Authoritative = TRUE;
    

#ifdef notyet
    //
    // Check to see if the name is the machine name, and if so, don't try to
    // go to the GC.
    //

    if ((NameType == DS_USER_PRINCIPAL_NAME) &&
        RtlEqualUnicodeString(
            SecData.MachineUpn(),
            Upn,
            TRUE                        // case insensitive
            ))
    {
        DebugLog((DEB_ERROR,"Trying to lookup machine upn %wZ on GC - failing early\n",
            Upn));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }
#endif

    CrackedDnsDomain = (LPWSTR) MIDL_user_allocate(CrackedDomainLength);
    if (CrackedDnsDomain == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    CrackedName = (LPWSTR) MIDL_user_allocate(CrackedNameLength);
    if (CrackedName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // We can only retry for user principal names, which have a simple
    // structure.
    //

    if (NameType != DS_USER_PRINCIPAL_NAME)
    {
        Retry = FALSE;
    }
    
    //
    // So we didn't find the account locally. Now try the GC.
    //
    NullTerminatedName = KerbBuildNullTerminatedString(
                            Upn
                            );
    if (NullTerminatedName == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we are in a recursive state, then we need to *not* go to
    // the GC, and try the crack locally.  This is because we'll go in
    // to a recursive tailspin and die.  this is a hack to escape this
    // situation until we work out a better soln. with DS folks.
    //

    if ( LsaIGetCallInfo( &CallInfo ) )
    {
        if ( CallInfo.Attributes & SECPKG_CALL_RECURSIVE )
        {
            UNICODE_STRING GCString;
            
            //
            // This problem occurs when trying to crack a name of type:
            // gc/dc.domain/domain.  We're recursive, & trying to contact
            // a gc, so make some assumptions about the name.
            //
            RtlInitUnicodeString(
                    &GCString,
                    KDC_WSZ_GC
                    );

            if ((PrincipalName->NameCount == KDC_GC_NAMEPARTS) &&
                 RtlEqualUnicodeString(
                        &GCString,
                        &PrincipalName->Names[0],
                        TRUE
                        ))
            {
                if (CrackedDnsDomain != NULL)
                {
                    MIDL_user_free(CrackedDnsDomain);
                }
                if (CrackedName !=NULL)
                {
                    MIDL_user_free(CrackedName);
                }                    

                // note : these are gaurenteed to be '\0' terminated.
                CrackedDnsDomain = PrincipalName->Names[2].Buffer;
                CrackedName = PrincipalName->Names[1].Buffer;
                UsedHack = TRUE;

                DebugLog(( DEB_WARN, "Special case hack of %ws to '%ws' at domain '%ws'\n",
                            NullTerminatedName, CrackedName, CrackedDnsDomain ));

                Status = STATUS_SUCCESS ;
                CrackError = DS_NAME_NO_ERROR ;
                goto LocalHack ;
            }

        }
    }

    //
    // If we're in the root domain, we could be getting asked for a 
    // name outside our forest.  Look now, and attempt to 
    // create the ticket info for that external target realm
    // 
    if (SecData.IsForestRoot() && SecData.IsCrossForestEnabled())
    {
        KerbErr = KdcMatchCrossForestName(
                        PrincipalName,
                        &CrackedDomain               
                        );

        if (KERB_SUCCESS(KerbErr))
        {
            *CrossForest = TRUE;

        }
        else
        {   
            DebugLog((DEB_WARN, "Did not match UPN %wZ to cross forest\n", &Upn));
        }

    }

Retry:

    if (!(*CrossForest))
    {   

            Status = CrackSingleName(
                            NameType,
                            NameFlags,
                            NullTerminatedName,
                            DS_UNIQUE_ID_NAME,
                            &CrackedDomainLength,
                            CrackedDnsDomain,
                            &CrackedNameLength,
                            CrackedName,
                            &CrackError
                            );
LocalHack:


            if ((Status != STATUS_SUCCESS) ||
                ( ( CrackError != DS_NAME_NO_ERROR ) &&
                  ( CrackError != DS_NAME_ERROR_DOMAIN_ONLY ) &&
                  ( CrackError != DS_NAME_ERROR_TRUST_REFERRAL)) )
            {
                //                                                  
                // If the name is a duplicate, log an event             
                //                                                          

                if (CrackError == DS_NAME_ERROR_NOT_UNIQUE)
                {
                    WCHAR LookupType[10];

                    swprintf(LookupType,L"%d",(ULONG) NameType);

                    ReportServiceEvent(
                        EVENTLOG_ERROR_TYPE,
                        KDCEVENT_NAME_NOT_UNIQUE,
                        0,
                        NULL,
                        2,
                        NullTerminatedName,
                        LookupType
                        );


                 }

                DebugLog((DEB_WARN,"Failed to resolve name %ws: 0x%x, %d\n",
                          NullTerminatedName,  Status ,CrackError ));

                if (Retry)
                {
                    MIDL_user_free(NullTerminatedName);
                    NullTerminatedName = NULL;

                    KerbErr = KdcBuildNt4Name(
                        &NullTerminatedName,
                        &CrackedDomain,
                        Upn
                        );
                    if (!KERB_SUCCESS(KerbErr))
                    {
                        //                                  
                        // If we got a wrong realm error, then we can return
                        // a non-authorititive answer               
                        //                                              

                        if (KerbErr == KDC_ERR_WRONG_REALM)
                        {
                            *Authoritative = FALSE;
                            KerbErr = KDC_ERR_NONE;
                        }
                        else
                        {
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        NameType = DS_NT4_ACCOUNT_NAME;
                        Retry = FALSE;

                        //          
                        // Reset lengths
                        //                  

                        CrackedDomainLength = (DNS_MAX_NAME_LENGTH+1) * sizeof(WCHAR);
                        CrackedNameLength = (UNLEN+DNS_MAX_NAME_LENGTH + 2) * sizeof(WCHAR);
                        goto Retry;
                    }
                }
                else
                {
                    KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
                    goto Cleanup;
                }
            }
            //                                                  
            //  We got a Xforest referral, go to Root domain        
            //                                                          
            else if (CrackError == DS_NAME_ERROR_TRUST_REFERRAL)
            {    

                RtlInitUnicodeString(
                    &CrackedDomain,
                    CrackedDnsDomain
                    );

                *CrossForest = TRUE;
            }   
            else
            {  
                RtlInitUnicodeString(
                    &CrackedDomain,
                    CrackedDnsDomain
                    ); 
            }
    }

    //
    // Decide whether we can open the account locally.
    //

    if (SecData.IsOurRealm(
        &CrackedDomain
        ))

    {
        RtlInitUnicodeString(
            &LocalCrackedString,
            CrackedName
            );

        KerbErr = KdcGetTicketInfo(
                      &LocalCrackedString,
                      SAM_OPEN_BY_GUID,
                      NULL,
                      NULL,
                      TicketInfo,
                      pExtendedError,
                      UserHandle,
                      WhichFields,
                      ExtendedFields,
                      UserInfo,
                      GroupMembership
                      );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        //
        // Now get a referral for the cracked domain name
        //
        UNICODE_STRING ForestRoot = {0};

        Status = SecData.GetKdcForestRoot(&ForestRoot);

        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }                


        ReferToRoot = (((NameType == DS_SERVICE_PRINCIPAL_NAME) &&
                       (!SecData.IsForestRoot()) &&
                       (*CrossForest)));






        KerbErr = KdcFindReferralTarget(
                    TicketInfo,
                    RealmName, 
                    pExtendedError,
                    (ReferToRoot ? &ForestRoot : &CrackedDomain),
                    FALSE,                          // not need ExactMatch
                    FALSE                           // not inbound
                    );

        KerbFreeString(&ForestRoot);


        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        *Referral = TRUE;

        // Mark our referral realm as the cracked domain
        if (ReferToRoot) 
        {
            KerbFreeString(RealmName);
    
            KerbDuplicateString(
                RealmName,
                &CrackedDomain
                );
        }
    }

Cleanup:
    
    if (!UsedHack)
    {
        if (CrackedDnsDomain != NULL)
        {
            MIDL_user_free(CrackedDnsDomain);
        }
        if (CrackedName !=NULL)
        {
            MIDL_user_free(CrackedName);
        }
    }

    if (!*Authoritative)
    {
        KerbFreeString(&CrackedDomain);
    }

    if (NullTerminatedName != NULL)
    {
        MIDL_user_free(NullTerminatedName);
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcNormalize
//
//  Synopsis:   Takes an input name and returns the appropriate ticket
//              information or referral information for that name
//
//  Effects:    If the name is not local, it may call the GC
//
//  Arguments:  PrincipalName - name to normalize
//              PrincipalRealm - Realm that issued principal name
//              RequestRealm - Realm field of a KDC request
//              NameFlags - flags about name, may be:
//                      KDC_NAME_CLIENT or KDC_NAME_SERVER
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcNormalize(
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PUNICODE_STRING PrincipalRealm,
    IN OPTIONAL PUNICODE_STRING RequestRealm,
    IN ULONG NameFlags,
    OUT PBOOLEAN Referral,
    OUT PUNICODE_STRING RealmName,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR  pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * UserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    BOOLEAN BuildUpn = FALSE;
    BOOLEAN CheckUpn = FALSE;
    BOOLEAN CheckSam = FALSE;
    BOOLEAN CheckGC = FALSE;
    BOOLEAN Reparse = FALSE;
    BOOLEAN Authoritative = TRUE;
    BOOLEAN CheckForInterDomain = FALSE;
    BOOLEAN ExactMatch = FALSE;
    BOOLEAN AddTrailingDollar = FALSE;
    BOOLEAN CrossForest = FALSE;
    UNICODE_STRING OutputPrincipal = {0};
    UNICODE_STRING OutputRealm = {0};
    UNICODE_STRING InputName = {0};
    ULONG Index;
    UNICODE_STRING LocalPrincipalName = {0};
    UNICODE_STRING Upn = {0};
    LPWSTR NullTerminatedName = NULL;
    WCHAR CrackedDnsDomain[DNS_MAX_NAME_LENGTH+1];
    ULONG CrackedDomainLength = sizeof(CrackedDnsDomain);
    PSID Sid = NULL;
    UNICODE_STRING SidName = {0};

    TRACE(KDC, KdcNormalize, DEB_FUNCTION);

    *Referral = FALSE;

    if (!ARGUMENT_PRESENT(PrincipalName))
    {
        DebugLog((DEB_ERROR,"KdcNormalize: Null PrincipalName. Failing\n"));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Make sure the name is not zero length
    //

    if ((PrincipalName->NameCount == 0) ||
        (PrincipalName->Names[0].Length == 0))
    {
        DebugLog((DEB_ERROR,"KdcNormalize: trying to crack zero length name. Failing\n"));
        Status = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    D_DebugLog((DEB_T_TICKETS,"Normalizing name:"));
    D_KerbPrintKdcName(DEB_T_TICKETS, PrincipalName);

    //
    // Check if we should look at the GC
    //

    if ((NameFlags & KDC_NAME_CHECK_GC) != 0)
    {
         CheckGC = TRUE;
    }


    switch(PrincipalName->NameType)
    {
    default:
    case KRB_NT_UNKNOWN:
        //
        // Drop through to more interesting name types
        //

    case KRB_NT_SRV_HST:
    case KRB_NT_SRV_INST:
    case KRB_NT_PRINCIPAL_AND_ID:
    case KRB_NT_SRV_INST_AND_ID:

        //
        // Get the sid from the name
        //

        KerbErr = KerbExtractSidFromKdcName(
                    PrincipalName,
                    &Sid
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to extract sid from name : "));
            KerbPrintKdcName(DEB_ERROR,PrincipalName);
            goto Cleanup;
        }
        if (Sid != NULL)
        {
            SidName.MaximumLength = SidName.Length = (USHORT) RtlLengthSid(Sid);
            SidName.Buffer = (LPWSTR) Sid;
        }


    case KRB_NT_PRINCIPAL:
        //
        // Principal names are just sam names
        //
        if (PrincipalName->NameCount == 1)
        {

            //
            // If the client supplied our realm name, check SAM - otherwise just
            // check for a UPN
            //

            if (SecData.IsOurRealm(RequestRealm))
            {
                CheckSam = TRUE;
            }

            //
            // If we don't find it in SAM, build a UPN and look it up.
            //
            CheckUpn = TRUE;
            BuildUpn = TRUE;
            OutputPrincipal = PrincipalName->Names[0];
            if (ARGUMENT_PRESENT(RequestRealm))
            {
                OutputRealm = *RequestRealm;
            }
            else
            {
                OutputRealm = *SecData.KdcDnsRealmName();
            }
            break;
        }

        //
        // Drop through
        //

        //
        // Check to see if these are the 'krbtgt' account
        //

        if ((PrincipalName->NameCount == 2) &&
            RtlEqualUnicodeString(
                &PrincipalName->Names[0],
                SecData.KdcServiceName(),
                TRUE))                          // case insensitive
        {
            //
            // Check if this is for a different domain - if it is for our
            // domain but the principal domain is different, swap the
            // domain name.
            //

            if (ARGUMENT_PRESENT(PrincipalRealm) &&
                SecData.IsOurRealm(
                    &PrincipalName->Names[1]))
            {
                OutputRealm = *PrincipalRealm;
            }
            else
            {
                OutputRealm = PrincipalName->Names[1];
            }

            //
            // Strip trailing "."
            //

            if ((OutputRealm.Length > 0)  &&
                (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
            {
                OutputRealm.Length -= sizeof(WCHAR);
            }

            if (!SecData.IsOurRealm(
                    &OutputRealm
                    ))
            {
                CheckForInterDomain = TRUE;
            }
            else
            {
                CheckSam = TRUE;
            }

            OutputPrincipal = PrincipalName->Names[0];
            break;
        }

        //
        // Drop through
        //


    case KRB_NT_SRV_XHST:

        //
        // These names can't be SAM names ( SAM doesn't support this name
        // type) and can't be interdomain (or it would have be caught up
        // above).
        //
        // Check this name as a upn/spn.
        //

        CheckUpn = TRUE;
        BuildUpn = TRUE;

        break;
    case KRB_NT_ENT_PRINCIPAL_AND_ID:

        //
        // Get the sid from the name
        //

        KerbErr = KerbExtractSidFromKdcName(
                    PrincipalName,
                    &Sid
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to extract sid from name : "));
            KerbPrintKdcName(DEB_ERROR,PrincipalName);
            goto Cleanup;
        }
        if (Sid != NULL)
        {
            SidName.MaximumLength = SidName.Length = (USHORT) RtlLengthSid(Sid);
            SidName.Buffer = (LPWSTR) Sid;
        }


    case KRB_NT_ENTERPRISE_PRINCIPAL:
        if (PrincipalName->NameCount != 1)
        {
            DebugLog((DEB_ERROR,"Enterprise name with more than one name part!\n"));
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            break;
        }
        OutputPrincipal = PrincipalName->Names[0];

        CheckUpn = TRUE;

        //
        // If the name wasn't found as a UPN/SPN, reparse and try
        // in SAM
        //

        InputName = PrincipalName->Names[0];
        Reparse = TRUE;
        CheckSam = TRUE;


        //
        // Check for these on the GC
        //

        OutputRealm = *SecData.KdcDnsRealmName();
        break;

    case KRB_NT_MS_PRINCIPAL_AND_ID:

        //
        // Get the sid from the name
        //

        KerbErr = KerbExtractSidFromKdcName(
                    PrincipalName,
                    &Sid
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to extract sid from name : "));
            KerbPrintKdcName(DEB_ERROR,PrincipalName);
            goto Cleanup;
        }
        if (Sid != NULL)
        {
            SidName.MaximumLength = SidName.Length = (USHORT) RtlLengthSid(Sid);
            SidName.Buffer = (LPWSTR) Sid;
        }

    case KRB_NT_MS_PRINCIPAL:
        //
        // These are domainname \ username names
        //
        if (PrincipalName->NameCount > 2)
        {
            DebugLog((DEB_ERROR,"MS principal has more than two name parts:"));
            KerbPrintKdcName(DEB_ERROR, PrincipalName);


            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }

        //
        // Never check the GC for these names
        //

        CheckGC = FALSE;

        //
        // If there are two names, the first one is the principal, the second
        // is the realm
        //

        if (PrincipalName->NameCount == 2)
        {
            DebugLog((DEB_WARN,"Client sent 2-part MS principalname!\n"));
            OutputPrincipal = PrincipalName->Names[0];
            OutputRealm = PrincipalName->Names[1];

            //
            // Strip trailing "."
            //

            if ((OutputRealm.Length > 0)  &&
                (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
            {
                OutputRealm.Length -= sizeof(WCHAR);
            }

        }
        else
        {
            InputName = PrincipalName->Names[0];
            Reparse = TRUE;
        }
        break;


    case KRB_NT_UID:
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        DebugLog((DEB_WARN,"Unsupported name type: %d\n",PrincipalName->NameType));
        goto Cleanup;
    }

    //
    // If we have a sid name, try that first, as it is the fastest.
    //

    if (SidName.Buffer != NULL)
    {
        D_DebugLog((DEB_T_TICKETS,"Checking sid name\n"));
        KerbErr = KdcGetTicketInfo(
                    &SidName,
                    SAM_OPEN_BY_SID,
                    NULL,               // no principal name
                    NULL,               // no realm name,
                    TicketInfo,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Some errors aren't recoverable
        //

        if ((KerbErr == KDC_ERR_MUST_USE_USER2USER) ||
            (KerbErr == KDC_ERR_SVC_UNAVAILABLE))
        {
            goto Cleanup;
        }

    }

    //
    // If we are supposed to reparse, then the name contains a name that we
    // have to process. Look for '@' and '\' separators.
    //

    if (Reparse)
    {

        DsysAssert(InputName.Length > 0);

        //
        // Find the first backslash or '@', or '.' in the name
        //


        for (Index = InputName.Length/sizeof(WCHAR) - 1; Index > 0 ; Index-- )
        {
            if ((InputName.Buffer[Index] == L'\\') ||
                (InputName.Buffer[Index] == L'@'))
            {
                break;
            }
        }


        //
        // If the name did not have one of those two separators, it
        // must have been of the form "name"
        //

        if (Index == 0)
        {


            OutputRealm = *SecData.KdcDnsRealmName();
            OutputPrincipal = InputName;

            //
            // Lookup this name in SAM.
            //

            CheckSam = TRUE;
        }
        else
        {
            //
            // The name had a '\' or an '@', so pick appart the two
            // pieces.
            //

            //
            // If the separator was an '@' then the second part of the name
            // is the realm. If it was an '\' then the first part is the
            // realm.
            //

            if (InputName.Buffer[Index] == L'@')
            {


                OutputPrincipal = InputName;
                OutputPrincipal.Length = (USHORT) Index * sizeof(WCHAR);
                OutputPrincipal.MaximumLength = (USHORT) Index * sizeof(WCHAR);


                OutputRealm.Buffer = &InputName.Buffer[Index+1];
                OutputRealm.Length = (USHORT) (InputName.Length - (Index + 1) * sizeof(WCHAR));
                OutputRealm.MaximumLength = OutputRealm.Length;


                //
                // Strip off a trailing '.'
                //

                if ((OutputRealm.Length > 0)  &&
                    (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
                {
                    OutputRealm.Length -= sizeof(WCHAR);
                }


            }
            else
            {
                DsysAssert(InputName.Buffer[Index] == L'\\');

                OutputRealm = InputName;
                OutputRealm.Length = (USHORT) Index * sizeof(WCHAR);
                OutputRealm.MaximumLength = (USHORT) Index * sizeof(WCHAR);

                OutputPrincipal.Buffer = &InputName.Buffer[Index+1];
                OutputPrincipal.Length = (USHORT) (InputName.Length - (Index + 1) * sizeof(WCHAR));
                OutputPrincipal.MaximumLength = OutputPrincipal.Length;

            }

        }

        if ((OutputRealm.Length > 0)  &&
            (OutputRealm.Buffer[-1 + OutputRealm.Length/sizeof(WCHAR)] == L'.'))
        {
            OutputRealm.Length -= sizeof(WCHAR);
        }

        //
        // If the domain portion is not for our domain, don't check sam
        //

        if (!SecData.IsOurRealm(
                &OutputRealm
                ))

        {
            CheckForInterDomain = TRUE;
            CheckSam = FALSE;
        }
        else
        {
            //
            // If we don't have a separate realm for the name,
            // check for interdomain. This is because cross-realm
            // requests have our own realm name in the name but
            // another realm name in the domain.
            //

            if (RtlEqualUnicodeString(
                    &OutputPrincipal,
                    SecData.KdcServiceName(),
                    TRUE
                    ))
            {

                if (ARGUMENT_PRESENT(PrincipalRealm))
                {
                    //
                    // Try the supplied realm. If it is present, and points
                    // to a different domain, lookup up interdomain
                    //

                    OutputRealm = *PrincipalRealm;
                    if (!SecData.IsOurRealm(
                            &OutputRealm
                            ))
                    {
                        CheckForInterDomain = TRUE;
                        CheckSam = FALSE;
                    }
                    else
                    {
                        CheckSam = TRUE;
                    }
                }
                else
                {
                    CheckSam = TRUE;
                }
            }
            else
            {
                CheckSam = TRUE;
            }

        }


    }

    // We could end up with CheckUpn and BuildUpn with both client names
    // and spns. We need to allow spns of the type
    // service/hostname to be looked up in sam (without appending an @realm
    // to it). If KDC_NAME_SERVER is passed, it must be an spn, so, we
    // don't add the @realm

    if (CheckUpn)
    {
        if (BuildUpn && ((NameFlags & KDC_NAME_SERVER) == 0))
        {
            D_DebugLog((DEB_T_TICKETS,"Building UPN\n"));
            KerbErr = KerbConvertKdcNameToString(
                        &Upn,
                        PrincipalName,
                        ARGUMENT_PRESENT(RequestRealm) ? RequestRealm : SecData.KdcDnsRealmName()
                        );
        }
        else
        {
            KerbErr = KerbConvertKdcNameToString(
                        &Upn,
                        PrincipalName,
                        NULL            // no realm name
                        );
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        D_DebugLog((DEB_T_TICKETS,"Lookup up upn/spn %wZ\n",&Upn));

        KerbErr = KdcGetTicketInfo(
                    &Upn,
                    (NameFlags & KDC_NAME_SERVER) ? SAM_OPEN_BY_SPN : SAM_OPEN_BY_UPN,
                    NULL,               // no principal name
                    NULL,               // no realm name,
                    TicketInfo,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        //
        // Some errors aren't recoverable
        //

        if ((KerbErr == KDC_ERR_MUST_USE_USER2USER) ||
            (KerbErr == KDC_ERR_SVC_UNAVAILABLE))
        {
            goto Cleanup;
        }

    }
    //
    // Next check for sam account names, as some of these may later be looked
    // up as UPNs
    //

    if (CheckSam)
    {

        D_DebugLog((DEB_T_TICKETS,"Checking name in SAM\n"));
        KerbErr = KdcGetTicketInfo(
                    &OutputPrincipal,
                    0,                  // no lookup flags means sam name
                    NULL,               // no principal name
                    NULL,               // no realm name,
                    TicketInfo,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        //
        // Some errors aren't recoverable
        //

        if ((KerbErr == KDC_ERR_MUST_USE_USER2USER) ||
            (KerbErr == KDC_ERR_SVC_UNAVAILABLE))
        {
            goto Cleanup;
        }


    } 

                           

    //
    // Now, depending on which flags are set, try to do different things.
    //

    if (CheckForInterDomain)
    {
        D_DebugLog((DEB_T_TICKETS,"Checking name interdomain\n"));
        //
        // If the target name is not KRBTGT, this must be a referral.
        //

        if (!RtlEqualUnicodeString(
                &OutputPrincipal,
                SecData.KdcServiceName(),
                TRUE))                          // case insensitive
        {
            *Referral = TRUE;

        }
        if ((NameFlags & KDC_NAME_FOLLOW_REFERRALS) == 0)
        {
            //
            // We need an exact match on the domain name
            //

            if (*Referral)
            {
                DebugLog((DEB_ERROR,"Client asked for principal in another realm but no referrals!\n"));
                KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
                goto Cleanup;
            }

            //
            // We also only accept the krbtgt account name
            //

            ExactMatch = TRUE;

        }

        KerbErr = KdcFindReferralTarget(
                    TicketInfo,
                    RealmName,
                    pExtendedError,
                    &OutputRealm,
                    ExactMatch,
                    (NameFlags & KDC_NAME_INBOUND) != 0
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            //
            // If the output realm & the realm we asked for is different,
            // this is a referral (meaning an we don't have a password
            // for the principal name on this machine)
            //

            if (!KerbCompareUnicodeRealmNames(
                    RealmName,
                    &OutputRealm
                    ))
            {
                *Referral = TRUE;
            }
            goto Cleanup;
        }

        //
        // This is an interdomain TGT, potentialy w/ a target outside of our 
        // forest.  Use the crackname call to determine whether or not to 
        // allow the call to proceed.  If so, go to our root domain.
        //
        if (!SecData.IsForestRoot())
        {

            // FESTER: 
            DebugLog((DEB_T_TICKETS, "Calling KdcCheckForCrossForestReferral %wZ:\n", &OutputRealm));

            KerbErr = KdcCheckForCrossForestReferral(
                            TicketInfo,
                            RealmName,
                            pExtendedError,
                            &OutputRealm,
                            NameFlags
                            );                      

            if (KERB_SUCCESS(KerbErr))        
            {
                DebugLog((DEB_T_TICKETS, "Got referral (%wZ) destined for x forest - %wZ\n", RealmName,&OutputRealm));
                *Referral = TRUE;
                goto Cleanup;

            }

            //              
            // Where did this come from???  
            // Unless we have knowledge of the DNS domain, we're hosed.
            //                          
            else
            {  
                DebugLog((DEB_T_TICKETS, 
                          "Recieved interdomain referral with unknown targetname : %wZ\n",
                          &OutputRealm));

                KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN; // fake error, see below 
                goto Cleanup;
            }
        }

    }




    if (CheckGC)
    {
        if (Upn.Buffer == NULL)
        {
            //
            // Build the UPN here.
            //
            D_DebugLog((DEB_T_TICKETS,"Building UPN\n"));
            KerbErr = KerbConvertKdcNameToString(
                        &Upn,
                        PrincipalName,
                        ARGUMENT_PRESENT(RequestRealm) ? RequestRealm : SecData.KdcDnsRealmName()
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

        }
        DsysAssert(Upn.Buffer != NULL);
        D_DebugLog((DEB_T_TICKETS,"Checking name %wZ in GC\n", &Upn));

        //
        // If the caller doesn't want us to follow referrals, fail here.
        //

        if ((NameFlags & KDC_NAME_FOLLOW_REFERRALS) == 0)
        {
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }




        //
        // This will allow us to open sam locally as well
        //

        KerbErr = KdcCrackNameAtGC(
                    &Upn,
                    PrincipalName,
                    ((NameFlags & KDC_NAME_CLIENT) != 0) ? DS_USER_PRINCIPAL_NAME : DS_SERVICE_PRINCIPAL_NAME,
                    RealmName,
                    TicketInfo,
                    &Authoritative,
                    Referral,
                    &CrossForest,
                    pExtendedError,
                    UserHandle,
                    WhichFields,
                    ExtendedFields,
                    UserInfo,
                    GroupMembership
                    );

        goto Cleanup;
    }

    KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;

Cleanup:
    KerbFreeString(
        &Upn
        );
    KerbFreeString(
        &LocalPrincipalName
        );
    if (Sid != NULL)
    {
        MIDL_user_free(Sid);
    }

    if (KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN)
    {
        if ((NameFlags & KDC_NAME_SERVER) != 0)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        }
    }
    return(KerbErr);
}






//+---------------------------------------------------------------------------
//
//  Function:   GetTimeStamps
//
//  Synopsis:   Gets the current time and clock skew envelope.
//
//  Arguments:  [ptsFudge]    -- (in) amount of clock skew to allow.
//              [ptsNow]      -- (out) the current time
//              [ptsNowPlus]  -- (out) the current time plus the skew.
//              [ptsNowMinus] -- (out) the current time less the skew
//
//  History:    4-23-93   WadeR   Created
//
//----------------------------------------------------------------------------
void
GetTimeStamps(  IN  PLARGE_INTEGER ptsFudge,
                OUT PLARGE_INTEGER ptsNow,
                OUT PLARGE_INTEGER ptsNowPlus,
                OUT PLARGE_INTEGER ptsNowMinus )
{
    TRACE(KDC, GetTimeStamps, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME) ptsNow );
    ptsNowPlus->QuadPart = ptsNow->QuadPart + ptsFudge->QuadPart;
    ptsNowMinus->QuadPart = ptsNow->QuadPart - ptsFudge->QuadPart;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildTicketTimesAndFlags
//
//  Synopsis:   Computes the times and flags for a new ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcBuildTicketTimesAndFlags(
    IN ULONG ClientPolicyFlags,
    IN ULONG ServerPolicyFlags,
    IN PLARGE_INTEGER DomainTicketLifespan,
    IN PLARGE_INTEGER DomainTicketRenewspan,
    IN OPTIONAL PLARGE_INTEGER LogoffTime,
    IN OPTIONAL PLARGE_INTEGER AccountExpiry,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OUT PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT OPTIONAL PKERB_EXT_ERROR ExtendedError
    )                                                                   
{
    KERBERR KerbErr = KDC_ERR_NONE;
    LARGE_INTEGER RequestEndTime;
    LARGE_INTEGER RequestStartTime;
    LARGE_INTEGER RequestRenewTime;

    LARGE_INTEGER SourceEndTime;
    LARGE_INTEGER SourceRenewTime;
    LARGE_INTEGER SourceStartTime;
    ULONG SourceTicketFlags = 0;
    ULONG FinalTicketFlags = 0;
    ULONG KdcOptions = 0;

    LARGE_INTEGER FinalEndTime;
    LARGE_INTEGER FinalStartTime;
    LARGE_INTEGER FinalRenewTime;
    LARGE_INTEGER LocalLogoffTime;
    BOOLEAN Renewable = FALSE;

    LARGE_INTEGER CurrentTime;


    TRACE(KDC, KdcBuildTicketTimesAndFlags, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    FinalEndTime.QuadPart = 0;
    FinalStartTime.QuadPart = 0;
    FinalRenewTime.QuadPart = 0;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Get the force logoff time
    //

    if (ARGUMENT_PRESENT(LogoffTime))
    {
        LocalLogoffTime = *LogoffTime;
    }
    else
    {
        LocalLogoffTime = tsInfinity;
    }

    //
    // Get the request times out of the request
    //

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_starttime_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestStartTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
            NULL
            );
    }
    else
    {
        RequestStartTime.QuadPart = 0;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &RequestEndTime,
        &RequestBody->endtime,
        NULL
        );

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestRenewTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
            NULL
            );
    }
    else
    {
        RequestRenewTime.QuadPart = 0;
    }

    //
    // Get the times out of the source ticket (if present)
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceStartTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_starttime,
                NULL
                );

        }
        else
        {
            SourceStartTime.QuadPart = 0;
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &SourceEndTime,
            &SourceTicket->endtime,
            NULL
            );

        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceRenewTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_renew_until,
                NULL
                );

        }
        else
        {
            SourceRenewTime.QuadPart = 0;
        }
        SourceTicketFlags = KerbConvertFlagsToUlong(&SourceTicket->flags);
    }
    else
    {
        //
        // Set the maximums in this case, which is probably an AS request.
        //

        SourceStartTime = CurrentTime;
        SourceEndTime = tsInfinity;
        SourceRenewTime = tsInfinity;
        SourceTicketFlags = 0;

        //
        // Fill in the source flags from what the client policy & domain policy
        // allow
        //

        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_POSTDATE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        if ((ClientPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE) != 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_renewable;
        }

    }

    //
    // Start computing the flags, from algorithm in RFC1510 appendix A.6
    //

    //
    // Delegation flags
    //

    if ((ServerPolicyFlags & AUTH_REQ_OK_AS_DELEGATE) != 0)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_ok_as_delegate;
    }

    //
    // Forward flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_forwardable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwardable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_forwarded)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_FORWARDABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwarded but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (SourceTicketFlags & KERB_TICKET_FLAGS_forwarded)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    //
    // preauth flags
    //

    if (SourceTicketFlags & KERB_TICKET_FLAGS_pre_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_pre_authent;
    }

    //
    // Proxy flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_proxiable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxiable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_proxy)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_PROXIABLE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxy;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxy but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    //
    // Postdate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_allow_postdate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_POSTDATE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for postdate but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_postdated)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_POSTDATE))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_postdated | KERB_TICKET_FLAGS_invalid;

            //
            // Start time is required here
            //

            if (RequestStartTime.QuadPart == 0)
            {
                DebugLog((DEB_ERROR, "Asked for postdate but start time not present\n"));
                KerbErr = KDC_ERR_CANNOT_POSTDATE;
                goto Cleanup;
            }

        }
    }

    //
    // Validate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_invalid) == 0)
        {
            DebugLog((DEB_ERROR,"Trying to validate a valid ticket\n"));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
        if ((SourceStartTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart < CurrentTime.QuadPart - SkewTime.QuadPart))
        {
            DebugLog((DEB_ERROR,"Trying to validate a ticket before it is valid\n"));
            KerbErr = KRB_AP_ERR_TKT_NYV;
            goto Cleanup;
        }
    }

    //
    // Start filling in time fields
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        Ticket->authtime = SourceTicket->authtime;
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->authtime,
            NULL,
            &CurrentTime
            );

    }

    //
    // The times are computed differently for renewing a ticket and for
    // getting a new ticket.
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_renew) != 0)
    {
        if ((SourceRenewTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart == 0) ||
            ((SourceTicketFlags & KERB_TICKET_FLAGS_renewable) == 0) ||
            ((ServerPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE) == 0))
        {
            DebugLog((DEB_ERROR,"Trying to renew a non-renewable ticket or against policy\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Make sure the renew time is in the future
        //

        if (SourceRenewTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew a ticket past its renew time\n"));
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }

        //
        // Make sure the end time is in the past
        //

        if (SourceEndTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew an expired ticket\n"));
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }
        FinalStartTime = CurrentTime;

        //
        // The end time is the minimum of the current time plus lifespan
        // of the old ticket and the renew until time of the old ticket
        //

        FinalEndTime.QuadPart = CurrentTime.QuadPart + (SourceEndTime.QuadPart - SourceStartTime.QuadPart);
        if (FinalEndTime.QuadPart > SourceRenewTime.QuadPart)
        {
            FinalEndTime = SourceRenewTime;
        }
        FinalRenewTime = SourceRenewTime;
        FinalTicketFlags = SourceTicketFlags;

        Renewable = TRUE;
    }
    else
    {
        //
        // Compute start and end times for normal tickets
        //

        //
        // Set the start time
        //

        if (RequestStartTime.QuadPart == 0)
        {
            FinalStartTime = CurrentTime;
        }
        else
        {
            FinalStartTime = RequestStartTime;
        }

        //
        // Set the end time
        //

        if (RequestEndTime.QuadPart == 0)
        {
            FinalEndTime = tsInfinity;
        }
        else
        {
            FinalEndTime = RequestEndTime;
        }

        if (FinalEndTime.QuadPart > SourceEndTime.QuadPart)
        {
            FinalEndTime = SourceEndTime;
        }

        if (FinalEndTime.QuadPart > CurrentTime.QuadPart + DomainTicketLifespan->QuadPart)
        {
            FinalEndTime.QuadPart = CurrentTime.QuadPart + DomainTicketLifespan->QuadPart;
        }

        //
        // Check for renewable-ok
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable_ok) &&
            (FinalEndTime.QuadPart < RequestEndTime.QuadPart) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable))
        {
            KdcOptions |= KERB_KDC_OPTIONS_renewable;
            RequestRenewTime = RequestEndTime;

            //
            // Make sure that the source ticket had a renewtime (it
            // should because it is renewable)
            //

            DsysAssert(SourceRenewTime.QuadPart != 0);
            if (RequestRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                RequestRenewTime = SourceRenewTime;
            }
        }
    }

    if (!Renewable)
    {
        //
        // Compute renew times
        //

        if (RequestRenewTime.QuadPart == 0)
        {
            RequestRenewTime = tsInfinity;
        }

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable) &&
            (ServerPolicyFlags & AUTH_REQ_ALLOW_RENEWABLE))
        {
            FinalRenewTime = RequestRenewTime;
            if (FinalRenewTime.QuadPart > FinalStartTime.QuadPart + DomainTicketRenewspan->QuadPart)
            {
                FinalRenewTime.QuadPart = FinalStartTime.QuadPart + DomainTicketRenewspan->QuadPart;
            }

            DsysAssert(SourceRenewTime.QuadPart != 0);

            if (FinalRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                FinalRenewTime = SourceRenewTime;
            }
            FinalTicketFlags |= KERB_TICKET_FLAGS_renewable;

        }
        else
        {
            FinalRenewTime.QuadPart = 0;
        }
    }

    //
    // Make sure the final ticket is valid
    //

    if (FinalStartTime.QuadPart > FinalEndTime.QuadPart)
    {
        DebugLog((DEB_ERROR,"Client asked for endtime before starttime\n"));
        KerbErr = KDC_ERR_BADOPTION;

        FILL_EXT_ERROR_EX(ExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Don't bother with this check - it doesn't really hurt to have a
    // renew time less than an end time
    //
//
//    if ((FinalRenewTime.QuadPart != 0) &&
//        (FinalRenewTime.QuadPart < FinalEndTime.QuadPart))
//    {
//        DebugLog((DEB_ERROR,"Client asked for renew time before endtime\n"));
//        KerbErr = KDC_ERR_BADOPTION;
//        goto Cleanup;
//    }
//

    //
    // Incorporate the logoff time (according to logon hours) by reseting
    // both the final end time and final renew time
    //

    if (FinalEndTime.QuadPart > LocalLogoffTime.QuadPart)
    {
        FinalEndTime.QuadPart = LocalLogoffTime.QuadPart;
    }

    if (FinalRenewTime.QuadPart > LocalLogoffTime.QuadPart)
    {
        FinalRenewTime.QuadPart = LocalLogoffTime.QuadPart;
    }

    //
    //  Tickets good only until acct expires.
    //  We make the assumption that the sam has
    //  already checked this against the current time
    //  when we're checking the logon restrictions.
    //  
    if ((ARGUMENT_PRESENT(AccountExpiry) &&
         (AccountExpiry->QuadPart != 0 )))
    {
        if (FinalEndTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalEndTime.QuadPart = AccountExpiry->QuadPart;
        }


        if (FinalRenewTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalRenewTime.QuadPart = AccountExpiry->QuadPart;
        }

    }                     


    //
    // Fill in the times in the ticket
    //

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->KERB_ENCRYPTED_TICKET_starttime,
        NULL,
        &FinalStartTime
        );
    Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->endtime,
        NULL,
        &FinalEndTime
        );

    if (FinalRenewTime.QuadPart != 0)
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->KERB_ENCRYPTED_TICKET_renew_until,
            NULL,
            &FinalRenewTime
            );
        Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_renew_until_present;


    }

    //
    // Copy in the flags
    //

    DsysAssert(Ticket->flags.length == sizeof(ULONG) * 8);
    *((PULONG) Ticket->flags.value) = KerbConvertUlongToFlagUlong(FinalTicketFlags);
Cleanup:
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcGetUserKeys
//
//  Synopsis:   retrieves user keys
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcGetUserKeys(
    IN SAMPR_HANDLE UserHandle,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    OUT PKERB_STORED_CREDENTIAL * Passwords,
    OUT PKERB_STORED_CREDENTIAL * OldPasswords,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PKERB_STORED_CREDENTIAL Keys = NULL;
    PKERB_STORED_CREDENTIAL StoredCreds = NULL;
    PKERB_STORED_CREDENTIAL Cred64 = NULL;
    ULONG CredentialSize = 0;
    ULONG NewCredentialCount = 0;
    ULONG NewCredentialSize = 0;
    ULONG Index, CredentialIndex = 0, Offset;
    USHORT Flags = 0;
    PUCHAR Base;
    BOOLEAN UseStoredCreds = FALSE, UnMarshalledCreds = FALSE;
    PCRYPTO_SYSTEM NullCryptoSystem = NULL;
    BOOLEAN UseBuiltins = TRUE;
    PNT_OWF_PASSWORD OldNtPassword = NULL;
    NT_OWF_PASSWORD OldPasswordData = {0};
    PUSER_ALL_INFORMATION UserAll = &UserInfo->I1;

    TRACE(KDC, KdcGetUserKeys, DEB_FUNCTION);

    //
    // First get any primary credentials
    //

    Status = SamIRetrievePrimaryCredentials(
                UserHandle,
                &GlobalKerberosName,
                (PVOID *) &StoredCreds,
                &CredentialSize
                );

    //
    // if there is not value, it's O.K we will default to using
    // Builtin credentials
    //

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==Status)
    {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to retrieve primary credentials: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // We need to unmarshall these creds from the DS
    // They'll be stored in 32 bit format, but we've
    // got to put them into 64 bit format.
    // KerbUnpack32BitStoredCredential()
    //
#ifdef _WIN64

    Status = KdcUnpack32BitStoredCredential(
                  (PKERB_STORED_CREDENTIAL32) StoredCreds,
                  &Cred64,
                  &CredentialSize
                  );

    if (!NT_SUCCESS(Status))
    {
       DebugLog((DEB_ERROR, "Failed to unpack 32bit stored credential, contact Todds - %x\n", Status));
       DsysAssert(FALSE); // FATAL - If we ever fail above, contact Todds
       goto Cleanup;
    }

    if (NULL != StoredCreds)
    {
       LocalFree(StoredCreds);
       StoredCreds = Cred64;
       UnMarshalledCreds = TRUE; // diff't allocator
    }

#endif

    //
    // First compute the current passwords
    //

    //
    // Figure out the size of the stored credentials
    //


    if ((StoredCreds != NULL) &&
        (CredentialSize > sizeof(KERB_STORED_CREDENTIAL) &&
        (StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
        (CredentialSize > (sizeof(KERB_STORED_CREDENTIAL)
                            - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA))
                            + StoredCreds->CredentialCount * sizeof(KERB_KEY_DATA)
                            ))) &&
        (StoredCreds->DefaultSalt.Length + (ULONG_PTR) StoredCreds->DefaultSalt.Buffer <= CredentialSize ))
    {
        UseStoredCreds = TRUE;
        Flags = StoredCreds->Flags;
        if ((UserAll->UserAccountControl & USER_USE_DES_KEY_ONLY) != 0)
        {
            UseBuiltins = FALSE;
        }

        NewCredentialSize += StoredCreds->DefaultSalt.Length;

        for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
        {
            //
            // Validat the offsets
            //

            if ((StoredCreds->Credentials[Index].Key.keyvalue.length +
                  (ULONG_PTR) StoredCreds->Credentials[Index].Key.keyvalue.value <= CredentialSize )
                  &&
                (StoredCreds->Credentials[Index].Salt.Length +
                (ULONG_PTR) StoredCreds->Credentials[Index].Salt.Buffer <= CredentialSize ))

            {
                NewCredentialCount++;
                NewCredentialSize += sizeof(KERB_KEY_DATA) +
                    StoredCreds->Credentials[Index].Key.keyvalue.length +
                    StoredCreds->Credentials[Index].Salt.Length;
            }
            else
            {
                LPWSTR Buff = NULL;

                DebugLog((DEB_ERROR,"Corrupt credentials for user %wZ\n",
                    &UserAll->UserName ));

                DsysAssert(FALSE);

                Buff = KerbBuildNullTerminatedString(&UserAll->UserName);
                if (NULL == Buff)
                {
                   break;
                }

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_CORRUPT_CREDENTIALS,
                    0,                              // no raw data
                    NULL,                   // no raw data
                    1,                              // number of strings
                    Buff
                    );

                UseStoredCreds = FALSE;
                NewCredentialCount = 0;
                NewCredentialSize = 0;

                if (NULL != Buff)
                {
                   MIDL_user_free(Buff);
                }

                break;
            }

        }

    }

    //
    // If the password length is the size of the OWF password, use it as the
    // key. Otherwise hash it. This is for the case where not password is
    // set.
    //


    if (UseBuiltins)
    {
        //
        // Add a key for RC4_HMAC_NT
        //

        if (UserAll->NtPasswordPresent)
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC

        //
        // Add a key for RC4_HMAC_OLD & MD4_RC4
        if (UserAll->NtPasswordPresent)
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

        }
#endif

        //
        // if there is no password, treat it as blank
        //

        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;
        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;
        }
#endif
    }

    //
    // Add a key for the null crypto system
    //

    Status = CDLocateCSystem(
                KERB_ETYPE_NULL,
                &NullCryptoSystem
                );
    if (NT_SUCCESS(Status))
    {
        NewCredentialSize += sizeof(KERB_KEY_DATA) + NullCryptoSystem->KeySize;
        NewCredentialCount++;
    }

    //
    // Add the space for the base structure
    //

    NewCredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));

    //
    // Allocate space for the credentials and start filling them in
    //

    Keys = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(NewCredentialSize);
    if (Keys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        Keys,
        NewCredentialSize
        );

    Offset = sizeof(KERB_STORED_CREDENTIAL) -
             (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
             NewCredentialCount * sizeof(KERB_KEY_DATA);

    Base = (PUCHAR) Keys;

    Keys->CredentialCount = (USHORT) NewCredentialCount;
    Keys->OldCredentialCount = 0;
    Keys->Revision = KERB_PRIMARY_CRED_REVISION;
    Keys->Flags = Flags;

    //
    // Add the credentials built from the OWF passwords first.
    //


    if (UseBuiltins)
    {
        //
        // Create the key for RC4_HMAC_NT
        //

        if (UserAll->NtPasswordPresent)
        {
            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_NT
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Offset += UserAll->NtPassword.Length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);
            CredentialIndex++;
        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        //
        // Create the key for RC4_HMAC_OLD
        //

        if (UserAll->NtPasswordPresent)
        {
            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_OLD
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            Offset += UserAll->NtPassword.Length;
            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;

            RtlCopyMemory(
                Base+Offset,
                UserAll->NtPassword.Buffer,
                UserAll->NtPassword.Length
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_MD4
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
            Offset += UserAll->NtPassword.Length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);
            CredentialIndex++;

        }
#endif

        //
        // If no passwords were present, add the null password
        //

        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            KERB_ENCRYPTION_KEY TempKey;
            UNICODE_STRING NullString;
            RtlInitUnicodeString(
                &NullString,
                NULL
                );
            KerbErr = KerbHashPassword(
                        &NullString,
                        KERB_ETYPE_RC4_HMAC_NT,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;
            KerbFreeKey(&TempKey);

        }
#ifndef DONT_SUPPORT_OLD_TYPES_KDC
        if (!(UserAll->LmPasswordPresent || UserAll->NtPasswordPresent))
        {
            KERB_ENCRYPTION_KEY TempKey;
            UNICODE_STRING NullString;
            RtlInitUnicodeString(
                &NullString,
                NULL
                );
            KerbErr = KerbHashPassword(
                        &NullString,
                        KERB_ETYPE_RC4_HMAC_OLD,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            CredentialIndex++;
            KerbFreeKey(&TempKey);

            KerbErr = KerbHashPassword(
                        &NullString,
                        KERB_ETYPE_RC4_MD4,
                        &TempKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            Keys->Credentials[CredentialIndex].Key = TempKey;
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;
            RtlCopyMemory(
                Base+Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;
            CredentialIndex++;
            KerbFreeKey(&TempKey);
        }

#endif
    }
    //
    // Add the null crypto system
    //

    if (NullCryptoSystem != NULL)
    {
        UNICODE_STRING NullString;
        RtlInitUnicodeString(
            &NullString,
            NULL
            );

        Status = NullCryptoSystem->HashString(
                    &NullString,
                    Base+Offset
                    );
        DsysAssert(NT_SUCCESS(Status));

        Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
        Keys->Credentials[CredentialIndex].Key.keyvalue.length = NullCryptoSystem->KeySize;
        Keys->Credentials[CredentialIndex].Key.keytype = KERB_ETYPE_NULL;

        Offset += NullCryptoSystem->KeySize;

        CredentialIndex++;


    }

    //
    // Now add the stored passwords
    //

    if (UseStoredCreds)
    {
        //
        // Copy the default salt
        //

        if (StoredCreds->DefaultSalt.Buffer != NULL)
        {
            Keys->DefaultSalt.Buffer = (LPWSTR) (Base+Offset);

            RtlCopyMemory(
                Base + Offset,
                (PBYTE) StoredCreds->DefaultSalt.Buffer + (ULONG_PTR) StoredCreds,
                StoredCreds->DefaultSalt.Length
                );
            Offset += StoredCreds->DefaultSalt.Length;
            Keys->DefaultSalt.Length = Keys->DefaultSalt.MaximumLength = StoredCreds->DefaultSalt.Length;
        }

        for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
        {
            //
            // Copy the key
            //

            Keys->Credentials[CredentialIndex] = StoredCreds->Credentials[Index];
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
            RtlCopyMemory(
                Keys->Credentials[CredentialIndex].Key.keyvalue.value,
                StoredCreds->Credentials[Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[Index].Key.keyvalue.length;

            //
            // Copy the salt
            //

            if (StoredCreds->Credentials[Index].Salt.Buffer != NULL)
            {
                Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base+Offset);

                RtlCopyMemory(
                    Base + Offset,
                    (PBYTE) StoredCreds->Credentials[Index].Salt.Buffer + (ULONG_PTR) StoredCreds,
                    StoredCreds->Credentials[Index].Salt.Length
                    );
                Offset += StoredCreds->Credentials[Index].Salt.Length;
                Keys->Credentials[CredentialIndex].Salt.Length =
                    Keys->Credentials[CredentialIndex].Salt.MaximumLength =
                        StoredCreds->Credentials[Index].Salt.Length;
            }

            CredentialIndex++;
        }
    }

    DsysAssert(CredentialIndex == NewCredentialCount);
    DsysAssert(Offset == NewCredentialSize);
    *Passwords = Keys;
    Keys = NULL;


    //
    // Now compute the old passwords
    //


    //
    // Figure out the size of the stored credentials
    //

    NewCredentialCount = 0;
    NewCredentialSize = 0;
    CredentialIndex = 0;

    if ((StoredCreds != NULL) &&
        (CredentialSize > sizeof(KERB_STORED_CREDENTIAL) &&
        (StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
        (CredentialSize > (sizeof(KERB_STORED_CREDENTIAL)
                            - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA))
                            + (StoredCreds->OldCredentialCount + StoredCreds->CredentialCount) * sizeof(KERB_KEY_DATA)
                            ))))
    {
        UseStoredCreds = TRUE;
        Flags = StoredCreds->Flags;
        if ((UserAll->UserAccountControl & USER_USE_DES_KEY_ONLY) != 0)
        {
            UseBuiltins = FALSE;
        }

        for (Index = 0; Index < StoredCreds->OldCredentialCount ; Index++ )
        {
            if (StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length +
                (ULONG_PTR) StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.value <=
                 CredentialSize )
            {
                NewCredentialCount++;
                NewCredentialSize += sizeof(KERB_KEY_DATA) +
                    StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length;
            }
            else
            {
                LPWSTR Buff = NULL;

                DebugLog((DEB_ERROR,"Corrupt credentials for user %wZ\n",
                    &UserAll->UserName ));

                DsysAssert(FALSE);

                Buff = KerbBuildNullTerminatedString(&UserAll->UserName);
                if (NULL == Buff)
                {
                   break;
                }

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_CORRUPT_CREDENTIALS,
                    0,                              // no raw data
                    NULL,                   // no raw data
                    1,                              // number of strings
                    Buff
                    );

                if (NULL != Buff)
                {
                   MIDL_user_free(Buff);
                }


                UseStoredCreds = FALSE;
                NewCredentialCount = 0;
                NewCredentialSize = 0;
                break;
            }

        }

    }

    //
    // If the password length is the size of the OWF password, use it as the
    // key. Otherwise hash it. This is for the case where not password is
    // set.
    //


    if (UseBuiltins)
    {
        PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PrivateData;


        if (UserAll->PrivateData.Length >= sizeof(SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE))
        {
            PrivateData= (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE) UserAll->PrivateData.Buffer;
            if (PrivateData->DataType == SamPrivateDataPassword)
            {
                //
                // The old password is the 2nd entry
                //

                if (PrivateData->NtPasswordHistory.Length >= 2* sizeof(ENCRYPTED_NT_OWF_PASSWORD))
                {
                    //
                    // Decrypt the old password with the RID. The history starts
                    // at the first byte after the structure.
                    //

                    Status = RtlDecryptNtOwfPwdWithIndex(
                                (PENCRYPTED_NT_OWF_PASSWORD) (PrivateData + 1) + 1,
                                (PLONG)&UserAll->UserId,
                                &OldPasswordData
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_ERROR,"Failed to decrypt old password: 0x%x\n",Status));
                        KerbErr = KRB_ERR_GENERIC;
                        goto Cleanup;
                    }
                    OldNtPassword = &OldPasswordData ;
                }
            }
        }
        if (OldNtPassword != NULL)
        {
            //
            // Add an RC4_HMAC_NT key
            //

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);
            NewCredentialCount++;


#ifndef DONT_SUPPORT_OLD_TYPES_KDC

            //
            // Add a key for RC4_HMAC_OLD & RC4_MD4
            //

            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);

            NewCredentialCount++;
            NewCredentialSize += sizeof(KERB_KEY_DATA) + sizeof(NT_OWF_PASSWORD);

            NewCredentialCount++;
#endif

        }

    }

    //
    // Add the space for the base structure
    //

    NewCredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));

    //
    // Allocate space for the credentials and start filling them in
    //

    Keys = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(NewCredentialSize);
    if (Keys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        Keys,
        NewCredentialSize
        );

    Offset = sizeof(KERB_STORED_CREDENTIAL) -
             (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
             NewCredentialCount * sizeof(KERB_KEY_DATA);

    Base = (PUCHAR) Keys;

    Keys->CredentialCount = (USHORT) NewCredentialCount;
    Keys->OldCredentialCount = 0;
    Keys->Revision = KERB_PRIMARY_CRED_REVISION;
    Keys->Flags = Flags;

    //
    // Add the credentials built from the OWF passwords first. We don't
    // include a blank password or the null crypt system because they
    // were present in the normal password
    //


    if (UseBuiltins)
    {
        //
        // Create the key for RC4_HMAC_NT
        //

        if (OldNtPassword != NULL)
        {

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );



            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_NT
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);


#ifndef DONT_SUPPORT_OLD_TYPES_KDC
            //
            // Create the key for RC4_HMAC_OLD
            //

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_HMAC_OLD
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);

            //
            // Create the key for RC4_HMAC_OLD
            //

            //
            // Set an empty salt for this key
            //

            Keys->Credentials[CredentialIndex].Salt.Length = 0;
            Keys->Credentials[CredentialIndex].Salt.MaximumLength = 0;
            Keys->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) (Base + Offset);

            RtlCopyMemory(
                Base+Offset,
                OldNtPassword,
                NT_OWF_PASSWORD_LENGTH
                );

            KerbErr = KerbCreateKeyFromBuffer(
                        &Keys->Credentials[CredentialIndex++].Key,
                        Base+Offset,
                        UserAll->NtPassword.Length,
                        KERB_ETYPE_RC4_MD4
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            // We don't know any other way to get the old password length. If
            // it was present, it must be sizeof(NT_OWF_PASSWORD)

            Offset += sizeof(NT_OWF_PASSWORD);

#endif

        }
    }
    //
    // Now add the stored passwords
    //

    if (UseStoredCreds)
    {
        for (Index = 0; Index < StoredCreds->OldCredentialCount ; Index++ )
        {
            Keys->Credentials[CredentialIndex] = StoredCreds->Credentials[StoredCreds->CredentialCount + Index];
            Keys->Credentials[CredentialIndex].Key.keyvalue.value = Base+Offset;
            RtlCopyMemory(
                Keys->Credentials[CredentialIndex].Key.keyvalue.value,
                StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[StoredCreds->CredentialCount + Index].Key.keyvalue.length;

            //
            // Note - don't use salt here.
            //

            CredentialIndex++;
        }
    }

    DsysAssert(CredentialIndex == NewCredentialCount);
    DsysAssert(Offset == NewCredentialSize);
    *OldPasswords = Keys;
    Keys = NULL;

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (StoredCreds != NULL)
    {
        if (!UnMarshalledCreds)
        {
           LocalFree(StoredCreds);
        }
        else
        {
           MIDL_user_free(Cred64);
        }
    }
    if (Keys != NULL)
    {
        MIDL_user_free(Keys);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateCredentials
//
//  Synopsis:   Copies a set of credentials (passwords)
//
//  Effects:    allocates output with MIDL_user_allocate
//
//  Arguments:  NewCredentials - recevies new set of credentials
//              OldCredentials - contains credentials to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcDuplicateCredentials(
    OUT PKERB_STORED_CREDENTIAL * NewCredentials,
    OUT PULONG ReturnCredentialSize,
    IN PKERB_STORED_CREDENTIAL OldCredentials,
    IN BOOLEAN MarshallKeys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_STORED_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;
    USHORT Index;
    PBYTE Where;
    LONG_PTR Offset;

    TRACE(KDC, KdcDuplicateCredentials, DEB_FUNCTION);

    //
    // If there were no credentials, so be it. We can live with that.
    //

    if (OldCredentials == NULL)
    {
        *NewCredentials = NULL;
        goto Cleanup;
    }

    //
    // Calculate the size of the new credentials by summing the size of
    // the base structure plus the keys
    //

    CredentialSize = sizeof(KERB_STORED_CREDENTIAL)
                        - ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)
                        + OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
                        + OldCredentials->DefaultSalt.Length;
    for ( Index = 0;
          Index < OldCredentials->CredentialCount + OldCredentials->OldCredentialCount  ;
          Index++ )
    {
        CredentialSize += OldCredentials->Credentials[Index].Key.keyvalue.length +
                          OldCredentials->Credentials[Index].Salt.Length;
    }

    //
    // Allocate the new credential and copy over the old credentials
    //


    Credential = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credential == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Credential->Revision = OldCredentials->Revision;
    Credential->Flags = OldCredentials->Flags;
    Credential->CredentialCount = OldCredentials->CredentialCount;
    Credential->OldCredentialCount = OldCredentials->OldCredentialCount;

    //
    // Set the offset for data to be after the last array element
    //

    RtlCopyMemory(
        &Credential->Credentials[0],
        &OldCredentials->Credentials[0],
        OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
        );

    Where = (PBYTE) &Credential->Credentials[Credential->CredentialCount];

    if (MarshallKeys)
    {
        Offset = (LONG_PTR) Credential;
    }
    else
    {
        Offset = 0;
    }

    Credential->DefaultSalt = OldCredentials->DefaultSalt;
    if (Credential->DefaultSalt.Buffer != NULL)
    {
        Credential->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
        RtlCopyMemory(
            Where,
            OldCredentials->DefaultSalt.Buffer,
            Credential->DefaultSalt.Length
            );
        Where +=  Credential->DefaultSalt.Length;
    }

    for ( Index = 0;
          Index < OldCredentials->CredentialCount + OldCredentials->OldCredentialCount  ;
          Index++ )
    {
        Credential->Credentials[Index] = OldCredentials->Credentials[Index];
        Credential->Credentials[Index].Key.keyvalue.value = (Where - Offset);
        RtlCopyMemory(
            Where,
            OldCredentials->Credentials[Index].Key.keyvalue.value,
            OldCredentials->Credentials[Index].Key.keyvalue.length
            );
        Where += OldCredentials->Credentials[Index].Key.keyvalue.length;

        if (Credential->Credentials[Index].Salt.Buffer != NULL)
        {
            Credential->Credentials[Index].Salt.Buffer = (LPWSTR) (Where - Offset);

            RtlCopyMemory(
                Where,
                OldCredentials->Credentials[Index].Salt.Buffer,
                OldCredentials->Credentials[Index].Salt.Length
                );
            Where += OldCredentials->Credentials[Index].Salt.Length;
        }
    }
    DsysAssert(Where - (PUCHAR) Credential == (LONG) CredentialSize);

    *NewCredentials = Credential;
    Credential = NULL;
    *ReturnCredentialSize = CredentialSize;

Cleanup:
    if (Credential != NULL)
    {
        MIDL_user_free(Credential);
    }
    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KdcGetTicketInfo
//
//  Synopsis:   Gets the info needed to build a ticket for a principal
//              using name of the principal.
//
//
//  Effects:
//
//  Arguments:  Name --  (in)  Normalized of principal
//              LookupFlags - Flags for SamIGetUserLogonInformation
//              PrincipalName - (in) non-normalized principal name
//              Realm - (in) client realm, to be used when mapping principals
//                      from another domain onto accounts in this one.
//              TicketInfo --  (out) Ticket info.
//              pExtendedError -- (out) Extended error
//              UserHandle - receives handle to the user
//              WhichFields - optionally specifies additional fields to fetch for RetUserInfo
//              ExtendedFields - optionally specifies extended fields to fetch for RetUserInfo
//              RetUserInfo - Optionally receives the user all info structure
//              GroupMembership - Optionally receives the user's group membership
//
//  Returns:    KerbErr
//
//  Algorithm:
//
//  History:    10-Nov-93   WadeR          Created
//              22-Mar-95   SuChang        Modified to use RIDs
//
//
//----------------------------------------------------------------------------

KERBERR
KdcGetTicketInfo(
    IN PUNICODE_STRING GenericUserName,
    IN ULONG LookupFlags,
    IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle,
    IN OPTIONAL ULONG WhichFields,
    IN OPTIONAL ULONG ExtendedFields,
    OUT OPTIONAL PUSER_INTERNAL6_INFORMATION * RetUserInfo,
    OUT OPTIONAL PSID_AND_ATTRIBUTES_LIST GroupMembership
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    KERBERR KerbErr = KDC_ERR_NONE;
    SID_AND_ATTRIBUTES_LIST LocalMembership;
    SAMPR_HANDLE LocalUserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    PUSER_ALL_INFORMATION UserAll;
    GUID testGuid;
    UNICODE_STRING TUserName = {0};
    PUNICODE_STRING UserName = NULL;
    UNICODE_STRING AlternateName = {0};
    UNICODE_STRING TempString = {0};
    BOOL IsValidGuid = FALSE;

    //
    // Add the fields we are going to require locally to the WhichFields parameter
    //

    WhichFields |=
        USER_ALL_KDC_GET_USER_KEYS |
        USER_ALL_PASSWORDMUSTCHANGE |
        USER_ALL_USERACCOUNTCONTROL |
        USER_ALL_USERID |
        USER_ALL_USERNAME;

    TUserName = *GenericUserName;
    UserName = &TUserName;

    TRACE(KDC, GetTicketInfo, DEB_FUNCTION);

    RtlZeroMemory(TicketInfo, sizeof(KDC_TICKET_INFO));
    RtlZeroMemory(&LocalMembership, sizeof(SID_AND_ATTRIBUTES_LIST));

    if (ARGUMENT_PRESENT( RetUserInfo ))
    {
        *RetUserInfo = NULL;
    }

    if (!ARGUMENT_PRESENT(GroupMembership))
    {
        LookupFlags |= SAM_NO_MEMBERSHIPS;
    }

    //
    // If this is the krbtgt account, use the cached version
    //

    if (!ARGUMENT_PRESENT(UserHandle) &&
        !ARGUMENT_PRESENT(RetUserInfo) &&
        !ARGUMENT_PRESENT(GroupMembership) &&
        (KdcState == Running) &&
        RtlEqualUnicodeString(
            SecData.KdcServiceName(),
            UserName,
            TRUE        // case insensitive
            ))
    {
        //
        // Duplicate the cached copy of the KRBTGT information
        //

        D_DebugLog((DEB_T_TICKETS, "Using cached ticket info for krbtgt account\n"));

        KerbErr = SecData.GetKrbtgtTicketInfo(
                        TicketInfo
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    //
    // If we cracked this name at a dc, and it's the same domain, we will
    // not be able to generate a referral ticket. So, we need to be able
    // to open the sam locally. Further more, crack name and sam lookups
    // are much faster with guids (even though we have to do the string
    // to guid operation.
    //

    if (LookupFlags & SAM_OPEN_BY_GUID)
    {
        if (IsValidGuid = IsStringGuid(UserName->Buffer, &testGuid))
        {
            UserName->Buffer = (LPWSTR)&testGuid;
        }
    }

    //
    // The caller may provide an empty user name so as to force the lookup
    // using the AltSecId. This is used when mapping names from an MIT realm
    //

    if (UserName->Length > 0)
    {
        //
        // Open the user account
        //

        if (IsValidGuid)
        {
            D_DebugLog(( DEB_TRACE, "Looking for account %wZ\n",
                                              UserName ));
        }
        else
        {
            D_DebugLog(( DEB_TRACE, "Looking for account %wZ mapped to Guid\n",
                                              GenericUserName ));
            KerbPrintGuid (DEB_TRACE, "", &testGuid);
        }

        Status = SamIGetUserLogonInformation2(
                    GlobalAccountDomainHandle,
                    LookupFlags,
                    UserName,
                    WhichFields,
                    ExtendedFields,
                    &UserInfo,
                    &LocalMembership,
                    &LocalUserHandle
                    );

        //
        // WASBUG: For now, if we couldn't find the account try again
        // with a '$' at the end (if there wasn't one already)
        //

        if (((Status == STATUS_NOT_FOUND) ||
            (Status == STATUS_NO_SUCH_USER)) &&
            (!IsValidGuid) &&
            ((LookupFlags & ~SAM_NO_MEMBERSHIPS) == 0) &&
            (UserName->Length >= sizeof(WCHAR)) &&
            (UserName->Buffer[UserName->Length/sizeof(WCHAR)-1] != L'$'))
        {
            Status = KerbDuplicateString(
                        &TempString,
                        UserName
                        );
            if (!NT_SUCCESS(Status))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
            DsysAssert(TempString.MaximumLength >= TempString.Length + sizeof(WCHAR));
            TempString.Buffer[TempString.Length/sizeof(WCHAR)] = L'$';
            TempString.Length += sizeof(WCHAR);

            D_DebugLog((DEB_TRACE, "Account not found ,trying machine account %wZ\n",
                &TempString ));

            Status = SamIGetUserLogonInformation2(
                        GlobalAccountDomainHandle,
                        LookupFlags,
                        &TempString,
                        WhichFields,
                        ExtendedFields,
                        &UserInfo,
                        &LocalMembership,
                        &LocalUserHandle
                        );


        }

    }

    //
    // If we still can't find the account, try the altsecid using
    // the supplied principal name.
    //

    if (((Status == STATUS_NOT_FOUND) || (Status == STATUS_NO_SUCH_USER)) &&
        ARGUMENT_PRESENT(PrincipalName) )
    {
        KerbErr = KerbBuildAltSecId(
                    &AlternateName,
                    PrincipalName,
                    Realm,
                    NULL                // no unicode realm name
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_TRACE,"User account not found, trying alternate id: %wZ\n",&AlternateName ));
            LookupFlags |= SAM_OPEN_BY_ALTERNATE_ID,

            Status = SamIGetUserLogonInformation2(
                        GlobalAccountDomainHandle,
                        LookupFlags,
                        &AlternateName,
                        WhichFields,
                        ExtendedFields,
                        &UserInfo,
                        &LocalMembership,
                        &LocalUserHandle
                        );

        }
    }


    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Could not open User %wZ: 0x%x\n",
            UserName,
            Status
            ));

        if ((Status == STATUS_NO_SUCH_USER) || (Status == STATUS_NOT_FOUND) ||
            (Status == STATUS_OBJECT_NAME_NOT_FOUND))
        {
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        }
        else if (Status == STATUS_NO_LOGON_SERVERS)
        {
            //If there's no GC, this sam call returns STATUS_NO_LOGON_SERVERS
            //and we should return this to the client. see bug 226073
            FILL_EXT_ERROR(pExtendedError, Status,FILENO, __LINE__);
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        }
        else if (Status != STATUS_INVALID_SERVER_STATE)
        {
            WCHAR LookupType[10];
            WCHAR AccountName[MAX_PATH+1];
            PUNICODE_STRING LookupName = NULL;


            if (AlternateName.Buffer != NULL)
            {
                LookupName = &AlternateName;
            }
            else if (TempString.Buffer != NULL)
            {
                LookupName = &TempString;
            }
            else
            {
                LookupName = UserName;
            }
            if (LookupName->Length < MAX_PATH * sizeof(WCHAR))
            {
                RtlCopyMemory(
                    AccountName,
                    LookupName->Buffer,
                    LookupName->Length
                    );
                AccountName[LookupName->Length/sizeof(WCHAR)] = L'\0';
            }
            else
            {
                RtlCopyMemory(
                    AccountName,
                    LookupName->Buffer,
                    MAX_PATH * sizeof(WCHAR)
                    );
                AccountName[MAX_PATH] = L'\0';
            }

            //
            // Log name collisions separately to provide
            // more information
            //

            if (Status == STATUS_OBJECT_NAME_COLLISION)
            {
                DS_NAME_FORMAT NameFormat = DS_UNKNOWN_NAME;
                if ((LookupFlags & SAM_OPEN_BY_UPN) != 0)
                {
                    NameFormat = DS_USER_PRINCIPAL_NAME;
                }
                else if ((LookupFlags & SAM_OPEN_BY_SPN) != 0)
                {
                    NameFormat = DS_SERVICE_PRINCIPAL_NAME;
                }

                // Potentially deadly error, pass back to caller.
                FILL_EXT_ERROR(pExtendedError, Status,FILENO, __LINE__);
                swprintf(LookupType,L"%d",(ULONG) NameFormat);

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_NAME_NOT_UNIQUE,
                    0,
                    NULL,
                    2,
                    AccountName,
                    LookupType
                    );

                KerbErr = KDC_ERR_PRINCIPAL_NOT_UNIQUE;
            }
            else
            {
                swprintf(LookupType,L"0x%x",LookupFlags);

                ReportServiceEvent(
                    EVENTLOG_ERROR_TYPE,
                    KDCEVENT_SAM_CALL_FAILED,
                    sizeof(NTSTATUS),
                    &Status,
                    2,
                    AccountName,
                    LookupType
                    );

                KerbErr = KRB_ERR_GENERIC;
            }
        }
        else
        {
           // Potentially deadly error, pass back to caller.
           FILL_EXT_ERROR(pExtendedError, Status,FILENO, __LINE__);
           KerbErr = KRB_ERR_GENERIC;
        }
        goto Cleanup;
    }

    UserAll = &UserInfo->I1;

    KerbErr = KdcGetUserKeys(
                LocalUserHandle,
                UserInfo,
                &TicketInfo->Passwords,
                &TicketInfo->OldPasswords,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to get user keys: 0x%x\n",KerbErr));
        goto Cleanup;
    }


    if (!NT_SUCCESS(KerbDuplicateString(
                        &TicketInfo->AccountName,
                        &UserAll->UserName )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    if ((UserAll->UserAccountControl & USER_TRUSTED_FOR_DELEGATION) != 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_OK_AS_DELEGATE;
    }


    //
    // TBD:  S4U(3)
    // Check user account control flag here for s4u2self restrictions
    //
    //
    // TBD: S4UProxy (A)
    // Add forwardable flag when you find T2A4D flag (trusted to authenticate
    // for delegation).
    //


    if ((UserAll->UserAccountControl & USER_NOT_DELEGATED) == 0)
    {
        TicketInfo->fTicketOpts |= AUTH_REQ_ALLOW_FORWARDABLE | AUTH_REQ_ALLOW_PROXIABLE;
    }

    TicketInfo->fTicketOpts |= AUTH_REQ_ALLOW_POSTDATE |
                                AUTH_REQ_ALLOW_RENEWABLE |
                                AUTH_REQ_ALLOW_NOADDRESS |
                                AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                                AUTH_REQ_ALLOW_VALIDATE;
    //
    // These flags aren't turned on by default:
    //      AUTH_REQ_VALIDATE_CLIENT
    //

    //
    // Mask with the domain policy flags
    //

    TicketInfo->fTicketOpts &= SecData.KdcFlags();

    TicketInfo->PasswordExpires = UserAll->PasswordMustChange;

    TicketInfo->UserAccountControl = UserAll->UserAccountControl;
    TicketInfo->UserId = UserAll->UserId;

    if (ARGUMENT_PRESENT(RetUserInfo))
    {
        *RetUserInfo = UserInfo;
        UserInfo = NULL;
    }
    if (ARGUMENT_PRESENT(GroupMembership))
    {
        *GroupMembership = LocalMembership;
        RtlZeroMemory(
            &LocalMembership,
            sizeof(SID_AND_ATTRIBUTES_LIST)
            );
    }

    if (ARGUMENT_PRESENT(UserHandle))
    {
        *UserHandle = LocalUserHandle;
        LocalUserHandle = NULL;
    }

Cleanup:

    KerbFreeString( &TempString );
    KerbFreeString( &AlternateName );

    SamIFree_UserInternal6Information( UserInfo );

    if (LocalUserHandle != NULL)
    {
        SamrCloseHandle(&LocalUserHandle);
    }

    SamIFreeSidAndAttributesList( &LocalMembership );

    return KerbErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeTicketInfo
//
//  Synopsis:   Frees a KDC_TICKET_INFO structure
//
//  Effects:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:
//
//  History:    22-Mar-95       SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
FreeTicketInfo(
    IN  PKDC_TICKET_INFO TicketInfo
    )
{
    TRACE(KDC, FreeTicketInfo, DEB_FUNCTION);

    if (ARGUMENT_PRESENT(TicketInfo))
    {
        KerbFreeString(
            &TicketInfo->AccountName
            );
        
        KerbFreeString(
            &TicketInfo->TrustedForest
            );

        if (TicketInfo->Passwords != NULL)
        {
            MIDL_user_free(TicketInfo->Passwords);
            TicketInfo->Passwords = NULL;
        }
        if (TicketInfo->OldPasswords != NULL)
        {
            MIDL_user_free(TicketInfo->OldPasswords);
            TicketInfo->OldPasswords = NULL;
        }
        if (TicketInfo->TrustSid != NULL)
        {
            MIDL_user_free(TicketInfo->TrustSid);
            TicketInfo->TrustSid = NULL;
        }
    }
}




//--------------------------------------------------------------------
//
//  Name:       BuildReply
//
//  Synopsis:   Extracts reply information from an internal ticket
//
//  Arguments:  pkitTicket  - (in) ticket data comes from
//              dwNonce     - (in) goes into the reply
//              pkrReply    - (out) reply that is built
//
//  Notes:      BUG 456265: Need to set tsKeyExpiry properly.
//              See 3.1.3, 3.3.3 of the Kerberos V5 R5.2 spec
//              tsKeyExpiry is zero for GetTGSTicket, and the
//              expiry time of the client's key for GetASTicket.
//
//--------------------------------------------------------------------

KERBERR
BuildReply(
    IN OPTIONAL PKDC_TICKET_INFO ClientInfo,
    IN ULONG Nonce,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN KERB_REALM ServerRealm,
    IN PKERB_HOST_ADDRESSES HostAddresses,
    IN PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY ReplyMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;
    KERB_ENCRYPTED_KDC_REPLY ReplyBody;
    LARGE_INTEGER CurrentTime;

    TRACE(KDC, BuildReply, DEB_FUNCTION);

    RtlZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_KDC_REPLY)
        );

    //
    // Use the same flags field
    //

    ReplyBody.flags = ReplyMessage->flags;



    ReplyBody.session_key = EncryptedTicket->key;


    ReplyBody.last_request = (PKERB_LAST_REQUEST) MIDL_user_allocate(sizeof(KERB_LAST_REQUEST));
    if (ReplyBody.last_request == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        ReplyBody.last_request,
        sizeof(KERB_LAST_REQUEST)
        );

    ReplyBody.last_request->next = NULL;
    ReplyBody.last_request->value.last_request_type = 0;
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyBody.last_request->value.last_request_value,
        NULL,           // no usec
        &CurrentTime
        );

    ReplyBody.nonce = Nonce;

    DsysAssert((ReplyBody.flags.length == EncryptedTicket->flags.length) &&
               (ReplyBody.flags.length== 8 * sizeof(ULONG)));

    //
    // Assign the flags over
    //

    *((PULONG)ReplyBody.flags.value) = *((PULONG)EncryptedTicket->flags.value);

    if (ARGUMENT_PRESENT(ClientInfo))
    {

        KerbConvertLargeIntToGeneralizedTime(
            &ReplyBody.key_expiration,
            NULL,
            &ClientInfo->PasswordExpires
            );
        ReplyBody.bit_mask |= key_expiration_present;
    }


    //
    // Fill in the times
    //


    ReplyBody.authtime = EncryptedTicket->authtime;
    ReplyBody.endtime = EncryptedTicket->endtime;

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_starttime;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;

    }

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_renew_until;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
    }

    ReplyBody.server_realm = ServerRealm;

    ReplyBody.server_name = *ServerName;

    //
    // Fill in the host addresses
    //


    if (HostAddresses != NULL)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_client_addresses = HostAddresses;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_client_addresses_present;
    }

    *ReplyMessage = ReplyBody;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (ReplyBody.last_request != NULL)
        {
            MIDL_user_free(ReplyBody.last_request);
            ReplyBody.last_request = NULL;
        }

    }

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildSupplementalCredentials
//
//  Synopsis:   Builds a list of the supplemental credentials and then
//              encrypts it with the supplied key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcBuildSupplementalCredentials(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER * EncryptedCreds
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PBYTE Credentials = NULL;
    ULONG CredentialSize = 0;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PPAC_CREDENTIAL_INFO CredInfo = NULL;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    PPAC_INFO_BUFFER ReturnCreds = NULL;
    ULONG ReturnCredSize;

    Status = PAC_BuildCredentials(
                (PSAMPR_USER_ALL_INFORMATION)&UserInfo->I1,
                &Credentials,
                &CredentialSize
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                CredentialKey->keytype,
                CredentialSize,
                &EncryptedData.cipher_text.length,
                &EncryptedData.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                &EncryptedData,
                CredentialSize,
                Credentials,
                CredentialKey->keytype,
                KERB_NON_KERB_SALT,
                CredentialKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Compute the size of the blob returned
    //

    ReturnCredSize = sizeof(PAC_INFO_BUFFER) +
                        FIELD_OFFSET(PAC_CREDENTIAL_INFO, Data) +
                        EncryptedData.cipher_text.length ;

    ReturnCreds = (PPAC_INFO_BUFFER) MIDL_user_allocate(ReturnCredSize);
    if (ReturnCreds == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    //
    // Fill in the outer structure
    //

    ReturnCreds->ulType = PAC_CREDENTIAL_TYPE;
    ReturnCreds->cbBufferSize = ReturnCredSize - sizeof(PAC_INFO_BUFFER);
    ReturnCreds->Data = (PBYTE) (ReturnCreds + 1);
    CredInfo = (PPAC_CREDENTIAL_INFO) ReturnCreds->Data;

    //
    // Fill in the inner structure
    //

    CredInfo->EncryptionType = EncryptedData.encryption_type;
    if (EncryptedData.bit_mask & version_present)
    {
        CredInfo->Version = EncryptedData.version;
    }
    else
    {
        CredInfo->Version = 0;
    }

    RtlCopyMemory(
        CredInfo->Data,
        EncryptedData.cipher_text.value,
        EncryptedData.cipher_text.length
        );

    *EncryptedCreds = ReturnCreds;
    ReturnCreds = NULL;
Cleanup:
    if (Credentials != NULL)
    {
        MIDL_user_free(Credentials);
    }
    if (ReturnCreds != NULL)
    {
        MIDL_user_free(ReturnCreds);
    }
    if (EncryptedData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncryptedData.cipher_text.value);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPacVerifier
//
//  Synopsis:   Builds a verifier for the PAC. This structure ties the
//              PAC to the ticket by including the client name and
//              ticket authime in the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildPacVerifier(
    IN PTimeStamp ClientId,
    IN PUNICODE_STRING ClientName,
    OUT PPAC_INFO_BUFFER * Verifier
    )
{
    ULONG ReturnVerifierSize = 0;
    PPAC_CLIENT_INFO ClientInfo = NULL;
    PPAC_INFO_BUFFER ReturnVerifier = NULL;

    //
    // Compute the size of the blob returned
    //
    ReturnVerifierSize = sizeof(PAC_INFO_BUFFER) + sizeof(PAC_CLIENT_INFO) +
                        ClientName->Length - sizeof(WCHAR) * ANYSIZE_ARRAY;

    ReturnVerifier = (PPAC_INFO_BUFFER) MIDL_user_allocate(ReturnVerifierSize);
    if (ReturnVerifier == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    //
    // Fill in the outer structure
    //

    ReturnVerifier->ulType = PAC_CLIENT_INFO_TYPE;
    ReturnVerifier->cbBufferSize = ReturnVerifierSize - sizeof(PAC_INFO_BUFFER);
    ReturnVerifier->Data = (PBYTE) (ReturnVerifier + 1);
    ClientInfo = (PPAC_CLIENT_INFO) ReturnVerifier->Data;
    ClientInfo->ClientId = *ClientId;
    ClientInfo->NameLength = ClientName->Length;
    RtlCopyMemory(
        ClientInfo->Name,
        ClientName->Buffer,
        ClientName->Length
        );
    *Verifier = ReturnVerifier;

    return(KDC_ERR_NONE);
}

//+---------------------------------------------------------------------------
//
//  Name:       GetPacAndSuppCred
//
//  Synopsis:
//
//  Arguments:
//
//  Notes:      ppPac is allocated using CoTaskMemAlloc and
//              ppadlSuppCreds is allocated using operator 'new'.
//
//+---------------------------------------------------------------------------

KERBERR
GetPacAndSuppCred(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PSID_AND_ATTRIBUTES_LIST GroupMembership,
    IN ULONG SignatureSize,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    IN OPTIONAL PTimeStamp ClientId,
    IN OPTIONAL PUNICODE_STRING ClientName,
    OUT PPACTYPE * Pac,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PPACTYPE NewPac = NULL;
    PPAC_INFO_BUFFER Credentials[2];
    ULONG AdditionalDataCount = 0;

    TRACE(KDC, GetPACandSuppCred, DEB_FUNCTION);

    RtlZeroMemory(
        Credentials,
        sizeof(Credentials)
        );

    *Pac = NULL;


    if (ARGUMENT_PRESENT(CredentialKey) &&
        (CredentialKey->keyvalue.value != NULL) )
    {
        KerbErr = KdcBuildSupplementalCredentials(
                    UserInfo,
                    CredentialKey,
                    &Credentials[AdditionalDataCount]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        AdditionalDataCount++;
    }

    if (ARGUMENT_PRESENT(ClientId))
    {
        KerbErr = KdcBuildPacVerifier(
                    ClientId,
                    ClientName,
                    &Credentials[AdditionalDataCount]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }



        AdditionalDataCount++;
    }

    //
    // NOTE: this is o.k. because we don't lock the secdata while acecssing
    // the machine name
    //


    Status = PAC_Init(
                (PSAMPR_USER_ALL_INFORMATION)&UserInfo->I1,
                NULL,
                GroupMembership,
                GlobalDomainSid,
                &GlobalDomainName,
                SecData.MachineName(),
                SignatureSize,
                AdditionalDataCount,
                Credentials,
                &NewPac
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to init pac: 0x%x\n",Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    *Pac = NewPac;
    NewPac = NULL;


Cleanup:


    while (AdditionalDataCount > 0)
    {
        if (Credentials[--AdditionalDataCount] != NULL)
        {
            MIDL_user_free(Credentials[AdditionalDataCount]);
        }
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }


    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeInternalTicket
//
//  Synopsis:   frees a constructed ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeInternalTicket(
    IN PKERB_TICKET Ticket
    )
{
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    TRACE(KDC, KdcFreeInternalTicket, DEB_FUNCTION);

    if (EncryptedTicket != NULL)
    {
        KerbFreeKey(
            &EncryptedTicket->key
            );
        KerbFreePrincipalName(&EncryptedTicket->client_name);
        if (EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL)
        {
            KerbFreeAuthData(EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data);
        }
        if (EncryptedTicket->transited.contents.value != NULL)
        {
            MIDL_user_free(EncryptedTicket->transited.contents.value);
        }
    }


    KerbFreePrincipalName(
        &Ticket->server_name
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReply
//
//  Synopsis:   frees a kdc reply
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeKdcReply(
    IN PKERB_KDC_REPLY Reply
    )
{
    TRACE(KDC, KdcFreeKdcReply, DEB_FUNCTION);

    KerbFreePrincipalName(&Reply->ticket.server_name);

    if (Reply->ticket.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->ticket.encrypted_part.cipher_text.value);
    }

    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
    }
    if (Reply->KERB_KDC_REPLY_preauth_data != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST) Reply->KERB_KDC_REPLY_preauth_data);
    }


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReplyBody
//
//  Synopsis:   frees a constructed KDC reply body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody
    )
{

    TRACE(KDC, KdcFreeKdcReplyBody, DEB_FUNCTION);

    //
    // The names & the session key are just pointers into the ticket,
    // so they don't need to be freed.
    //

    if (ReplyBody->last_request != NULL)
    {
        MIDL_user_free(ReplyBody->last_request);
        ReplyBody->last_request = NULL;
    }
    ReplyBody->KERB_ENCRYPTED_KDC_REPLY_client_addresses = NULL;

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientAddress
//
//  Synopsis:   Verifies that the client address is an allowed sender of
//              the KDC request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES TempAddress = Addresses;

    //
    // ISSUE-2001/03/05-markpu
    // This routine is wholly inadequate in that it only deals with IPv4
    // addresses.  Address matching has to be more elaborate than that
    //

    while (TempAddress != NULL)
    {
        if ( TempAddress->value.address_type == KERB_ADDRTYPE_INET &&
             ClientAddress->sa_family == AF_INET )
        {
            struct sockaddr_in * InetAddress = (struct sockaddr_in *) ClientAddress;

            //
            // Check that the addresses match
            //

            if (TempAddress->value.address.length == sizeof(ULONG))
            {
                if (RtlEqualMemory(
                        TempAddress->value.address.value,
                        &InetAddress->sin_addr.S_un.S_addr,
                        sizeof(ULONG)
                        ))
                {
                    return(KDC_ERR_NONE);
                }
            }

        }

        TempAddress = TempAddress->next;
    }

    D_DebugLog((DEB_WARN,"Client address not in address list\n"));

    //
    // Need to return KRB_AP_ERR_BADADDR but a couple of things must
    // be fixed first (client code notified of changes to the machine's IP
    // address, copying addresses from the TGT into the TGS request)
    //

    return(KDC_ERR_NONE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsChecksum
//
//  Synopsis:   Verify the checksum on a TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_CHECKSUM OldChecksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CHECKSUM Checksum = {0};


    Status = CDLocateCheckSum(
                OldChecksum->checksum_type,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum.checksum.value = (PUCHAR) MIDL_user_allocate(ChecksumFunction->CheckSumSize);
    if (Checksum.checksum.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Checksum.checksum.length = ChecksumFunction->CheckSumSize;

    //
    // Initialize the checksum
    //

    if ((OldChecksum->checksum_type == KERB_CHECKSUM_REAL_CRC32) ||
        (OldChecksum->checksum_type == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                        0,
                        &CheckBuffer
                        );
            }
        else
        {

            KerbErr = KRB_ERR_GENERIC;
        }
    }
    else
    {
        if (NULL != ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        OldChecksum->checksum.value,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum.checksum.value
        );

    //
    // Now compare
    //

    if ((OldChecksum->checksum.length != Checksum.checksum.length) ||
        !RtlEqualMemory(
            OldChecksum->checksum.value,
            Checksum.checksum.value,
            Checksum.checksum.length
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on TGS request body did not match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (Checksum.checksum.value != NULL)
    {
        MIDL_user_free(Checksum.checksum.value);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcRequest
//
//  Synopsis:   Verifies that the AP request accompanying a TGS or PAC request
//              is valid.
//
//  Effects:
//
//  Arguments:  ApRequest - The AP request to verify
//              UnmarshalledRequest - The unmarshalled request,
//                      returned to avoid needing to
//              EncryptedTicket - Receives the ticket granting  ticket
//              SessionKey - receives the key to use in the reply
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcVerifyKdcRequest(
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN BOOLEAN IsKdcRequest,
    OUT OPTIONAL PKERB_AP_REQUEST * UnmarshalledRequest,
    OUT OPTIONAL PKERB_AUTHENTICATOR * UnmarshalledAuthenticator,
    OUT PKERB_ENCRYPTED_TICKET *EncryptedTicket,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY ServerKey,
    OUT PKDC_TICKET_INFO ServerTicketInfo,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AP_REQUEST Request = NULL;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;
    UNICODE_STRING LocalServerName = {0};
    UNICODE_STRING LocalServerRealm = {0};
    UNICODE_STRING LocalServerPrincipal = {0};
    UNICODE_STRING ServerRealm;
    PKERB_ENCRYPTION_KEY KeyToUse;
    BOOLEAN Referral = FALSE;
    BOOLEAN Retry = TRUE;

    TRACE(KDC, KdcVerifyKdcRequest, DEB_FUNCTION);


    ServerRealm.Buffer = NULL;



    //
    // First unpack the KDC request.
    //

    KerbErr = KerbUnpackApRequest(
                RequestMessage,
                RequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack KDC request: 0x%x\n",KerbErr));
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &Request->ticket.server_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                &ServerRealm,
                &Request->ticket.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Get ticket info for the server
    //

    KerbErr = KdcNormalize(
                ServerName,
                &ServerRealm,
                &ServerRealm,
                KDC_NAME_SERVER | KDC_NAME_INBOUND,
                &Referral,
                &LocalServerRealm,
                ServerTicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no group membership
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "Trying to get TGS ticket to service in another realm: "));
        KerbPrintKdcName(DEB_WARN, ServerName);
        goto Cleanup;
    }


    //
    // Now Check the ticket
    //
Retry:

    KeyToUse = KerbGetKeyFromList(
                    ServerTicketInfo->Passwords,
                    Request->ticket.encrypted_part.encryption_type
                    );

    if (KeyToUse == NULL)
    {
        DebugLog((DEB_ERROR,"Server does not have proper key to decrypt ticket: 0x%x\n",
            Request->ticket.encrypted_part.encryption_type ));

        //
        // If this is our second attempt, do not overwrite the error code we had
        //

        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        }

        goto Cleanup;
    }

    //
    // We don't need to supply a service name or service because we've looked up
    // the account locally.
    //

    KerbErr = KerbCheckTicket(
                &Request->ticket,
                &Request->authenticator,
                KeyToUse,
                Authenticators,
                &SkewTime,
                0,                      // zero service names
                NULL,                   // any service
                NULL,
                FALSE,                  // don't check for replay
                IsKdcRequest,
                &EncryptPart,
                &Authenticator,
                NULL,
                SessionKey,
                UseSubKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to check ticket : 0x%x for",KerbErr));
        KerbPrintKdcName(DEB_ERROR,ServerName );


        //
        // If an old password is available, give it a try. We remove the
        // current password & put the old password in here.
        //

        if (ServerTicketInfo->OldPasswords && (KerbErr == KRB_AP_ERR_MODIFIED))
        {
            MIDL_user_free(ServerTicketInfo->Passwords);
            ServerTicketInfo->Passwords = ServerTicketInfo->OldPasswords;
            ServerTicketInfo->OldPasswords = NULL;
            goto Retry;
        }


        //
        //  Here's the case where we're trying to use an expired TGT.  Have 
        // the client retry using a new TGT
        //
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
        {
            FILL_EXT_ERROR_EX(pExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        }

        goto Cleanup;          
    }

    //
    // Verify the address from the ticket
    //

    if ((EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) &&
        ARGUMENT_PRESENT(ClientAddress))

    {
        ULONG TicketFlags = KerbConvertFlagsToUlong(&EncryptPart->flags);

        //
        // Only check initial tickets
        //

        if ((TicketFlags & (KERB_TICKET_FLAGS_forwarded | KERB_TICKET_FLAGS_proxy)) == 0)
        {
            KerbErr = KdcVerifyClientAddress(
                        ClientAddress,
                        EncryptPart->KERB_ENCRYPTED_TICKET_client_addresses
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"Client sent request with wrong address\n"));
                goto Cleanup;
            }
        }
    }

    //
    // Verify that if the server is a trusted domain account, that it is an
    // acceptable ticket (transitively). Verify that for non transitive
    // trust the client realm is the same as the requesting ticket realm
    //


    if (((ServerTicketInfo->fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0) &&
         (ServerTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT))
    {
        if (!KerbCompareRealmNames(
                &EncryptPart->client_realm,
                &Request->ticket.realm
                ))
        {
            DebugLog((DEB_WARN,"Client from realm %s attempted to access non transitve trust via %s : illegal\n",
                &EncryptPart->client_realm,
                &Request->ticket.realm
                ));


            KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
            goto Cleanup;
        }
    }

    //
    // If the caller wanted the server key, return it here.
    //

    if (ServerKey != NULL)
    {
        KerbErr = KerbDuplicateKey(
                    ServerKey,
                    KeyToUse
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }


    *EncryptedTicket = EncryptPart;
    EncryptPart = NULL;
    if (ARGUMENT_PRESENT(UnmarshalledRequest))
    {
        *UnmarshalledRequest = Request;
        Request = NULL;
    }
    if (ARGUMENT_PRESENT(UnmarshalledAuthenticator))
    {
        *UnmarshalledAuthenticator = Authenticator;
        Authenticator = NULL;
    }

Cleanup:
    KerbFreeApRequest(Request);
    KerbFreeString(&LocalServerRealm);
    KerbFreeKdcName(&ServerName);
    KerbFreeString(&ServerRealm);
    KerbFreeAuthenticator(Authenticator);
    KerbFreeTicket(EncryptPart);

    return(KerbErr);
}



#if DBG

void
PrintRequest( ULONG ulDebLevel, PKERB_KDC_REQUEST_BODY Request )
{
    TRACE(KDC, PrintRequest, DEB_FUNCTION);
}

void
PrintTicket( ULONG ulDebLevel,
             char * pszMessage,
             PKERB_TICKET pkitTicket)
{
    TRACE(KDC, PrintTicket, DEB_FUNCTION);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\transit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.h
//
// Contents:    Prototypes for transited realm encoding
//
//
// History:     2-April-1997    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TRANSIT_H__
#define __TRANSIT_H__

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN PUNICODE_STRING OurRealm
    );

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    );


#endif // __TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\utest\kdctest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ticktest.cxx
//
//  Contents:   KDC Ticket granting service test code.
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
#include <stdio.h>
#include <stdlib.h>
#include <kerbcomm.h>
#include <kerbcred.h>
extern "C"
{
#include <dsgetdc.h>
#include <kdcdbg.h>
}

UNICODE_STRING ClientName;
UNICODE_STRING ServiceName;
UNICODE_STRING ClientRealm;
UNICODE_STRING ServiceRealm;
UNICODE_STRING ClientPassword;
UNICODE_STRING ServicePassword;
UNICODE_STRING KdcName;
WCHAR KdcNameString[100];
ULONG AddressType = DS_NETBIOS_ADDRESS;
ULONG CryptType = KERB_ETYPE_RC4_MD4;
PVOID KdcBinding;

BOOLEAN
BindToKdc()
{
    ULONG NetStatus;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;

    if (KdcName.Buffer == NULL)
    {
        //
        // No kdc specified, use DSGetDCName
        //

        NetStatus = DsGetDcName(
                        NULL,
                        ClientRealm.Buffer,
                        NULL,
                        NULL,
                        DS_KDC_REQUIRED,
                        &DcInfo
                        );
        if (NetStatus != NO_ERROR)
        {
            printf("DsGetDcName returned %d\n",NetStatus);
            return(FALSE);
        }

        RtlInitUnicodeString(
            &KdcName,
            DcInfo->DomainControllerAddress+2
            );

        AddressType = DcInfo->DomainControllerAddressType;


    }
        return(TRUE);

}


BOOLEAN
GetAnAsTicket(
    IN PUNICODE_STRING ServerName,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_ENCRYPTION_KEY UserKey;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize;
    UNICODE_STRING FullServiceName;
    UNICODE_STRING FullClientName;
    PKERB_ERROR ErrorMessage = NULL;
    LARGE_INTEGER TempTime;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;
    BOOLEAN DoingSomething = FALSE;


    RtlZeroMemory(
        &OutputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );

    RtlZeroMemory(
        &InputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );



    //
    // Build the request
    //

    RtlZeroMemory(
        &Request,
        sizeof( KERB_KDC_REQUEST )
        );
    RequestBody = &Request.request_body;

    KdcOptions =
                            KERB_KDC_OPTIONS_forwardable |
                            KERB_KDC_OPTIONS_proxiable |
                            KERB_KDC_OPTIONS_renewable |
                            KERB_KDC_OPTIONS_renewable_ok;

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    RequestBody->nonce = 3;

    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );


    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    TempTime.QuadPart = 0;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    //
    // Build crypt vector.
    //

    CryptArraySize = KERB_MAX_CRYPTO_SYSTEMS;
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // BUGBUG: don't build pre-auth data
    //


    KerbBuildFullServiceName(
        &ClientRealm,
        ServerName,
        &FullServiceName
        );

    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                    &FullServiceName,
                    KRB_NT_MS_PRINCIPAL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;

    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;
    KerbBuildFullServiceName(
        &ClientRealm,
        &ClientName,
        &FullClientName
        );
    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &FullClientName,
                KRB_NT_MS_PRINCIPAL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert unicde string to realm: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_AS_REQ;


    KerbErr = KerbPackAsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    Status = KerbCallKdc(
                &KdcName,
                AddressType,
                10,
                TRUE,
                &InputMessage,
                &OutputMessage
                );


    if (!NT_SUCCESS(Status))
    {
        printf("KerbCallKdc failed: 0x%x\n",Status);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbUnpackAsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);

        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get AS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }
        goto Cleanup;
    }

    KerbErr = KerbHashPassword(
                &ClientPassword,
                (*Reply)->encrypted_part.encryption_type,
                &UserKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to hash password with 0x%x alg\n",(*Reply)->encrypted_part.encryption_type);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                &UserKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    *Ticket = (*Reply)->ticket;

Cleanup:

    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOLEAN
GetATgsTicket(
    IN PKERB_TICKET TicketGrantingTicket,
    IN PKERB_ENCRYPTED_KDC_REPLY TgtReplyBody,
    IN PKERB_KDC_REPLY TgtReply,
    IN BOOLEAN Renew,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply
    )
{
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    UNICODE_STRING FullServiceName;
    PKERB_INTERNAL_NAME FullClientName;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST  PaData;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKERB_ERROR ErrorMessage = NULL;
    ULONG NameType;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;




    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );

    KdcOptions = KERB_KDC_OPTIONS_forwardable |
                          KERB_KDC_OPTIONS_proxiable |
                          KERB_KDC_OPTIONS_renewable |
                          KERB_KDC_OPTIONS_renewable_ok;
    if (Renew)
    {
        KdcOptions |= KERB_KDC_OPTIONS_renew;
    }


    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;



    RequestBody->nonce = 4;

    //
    // Build an AP request inside an encrypted data structure.
    //

    KerbConvertPrincipalNameToKdcName(
        &FullClientName,
        &TgtReply->client_name
        );

    PaData.next = NULL;
    PaData.value.preauth_data_type = KRB5_PADATA_TGS_REQ;

    KerbErr = KerbCreateApRequest(
                FullClientName,
                &ClientRealm,
                &TgtReplyBody->session_key,
                NULL,                           // no sub session key
                5,                              // nonce
                TicketGrantingTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                NULL,                           // server time
                TRUE,                           // KDC request
                (PULONG) &PaData.value.preauth_data.length,
                &PaData.value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.KERB_KDC_REQUEST_preauth_data = &PaData;
    Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    KerbErr = KerbDuplicatePrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    &TgtReply->client_name
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                &ServiceName,
                KRB_NT_MS_PRINCIPAL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;


    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );

    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;


    TempTime.LowPart  = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );



    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGS_REQ;


    KerbErr = KerbPackTgsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Get the ticket.
    //

    OutputMessage.Buffer = NULL;
    OutputMessage.BufferSize = 0;
    KerbErr = (KERBERR) KerbCallKdc(
                            &KdcName,
                            AddressType,
                            10,
                            TRUE,
                            &InputMessage,
                            &OutputMessage
                            );


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackTgsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get TGS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }

        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                &TgtReplyBody->session_key,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    *Ticket = (*Reply)->ticket;

Cleanup:
    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOLEAN
UStringFromAnsi(
    OUT PUNICODE_STRING UnicodeString,
    IN LPSTR String
    )
{
    STRING AnsiString;

    RtlInitString(
        &AnsiString,
        String
        );
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(
                        UnicodeString,
                        &AnsiString,
                        TRUE
                        )))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

void
SetDefaultOpts()
{
    UNICODE_STRING TempString;
    STRING AnsiString;
    LPSTR String;

    KerbInitializeSockets(0x0101,5);

    //
    // Username
    //

    String = getenv( "USERNAME" );
    if (String == NULL)
    {
        String = "mikesw";
    }

    UStringFromAnsi(
        &ClientName,
        String
        );


    String = getenv( "USERDOMAIN" );
    if (String == NULL)
    {
        String = "NTDS";
    }

    UStringFromAnsi(
        &ClientRealm,
        String
        );

    UStringFromAnsi(
        &ServiceRealm,
        String
        );


}


VOID
SetPassword(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN UnixOnly
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_SetPassword(
                hBinding,
                UserName,
                PrincipalName,
                Password,
                UnixOnly ? KERB_PRIMARY_CRED_RFC1510_ONLY : 0
                );
    RpcBindingFree(&hBinding);
    printf("SetPassword returned 0x%x\n",Status);

}


BOOLEAN
BindToKdcRpc(
    handle_t * hBinding
    )
{
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    if (KdcName.Buffer == NULL)
    {
        sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    }
    else
    {
        sc = RpcStringBindingCompose(0, L"ncacn_ip_tcp",KdcNameString,NULL,
                0, &pszBinding);
    }
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return FALSE;
    }
    sc = RpcBindingFromStringBinding(pszBinding, hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return FALSE;
    }
    sc = RpcEpResolveBinding(*hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return FALSE;
    }
    return TRUE;

}

VOID
DumpKdc(
    VOID
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_Dump(
                hBinding
                );
    RpcBindingFree(&hBinding);

}


VOID
DumpKdcDomains( VOID )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_GetDomainList(
                hBinding,
                &DomainList
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
         for (Index = 0; Index < DomainList->Count ; Index++ )
         {
             printf("Domain %d:\n",Index);
             printf("\tDnsName = %wZ\n",&DomainList->Domains[Index].DnsName);
             printf("\tNetbiosName = %wZ\n",&DomainList->Domains[Index].NetbiosName);
             printf("\tClosestRoute = %wZ\n",&DomainList->Domains[Index].ClosestRoute);
             printf("\tType = 0x%x, Attributes = 0x%x\n",DomainList->Domains[Index].Type, DomainList->Domains[Index].Attributes);
         }
    }

}

VOID
KdcNormalize(
    ULONG Flags,
    PKERB_DBG_INTERNAL_NAME Name
    )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_Normalize(
                hBinding,
                Name,
                Flags
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}


VOID
KdcSetState(
    ULONG Lifetime,
    ULONG RenewTime
    )
{
    NTSTATUS Status;
    LARGE_INTEGER FudgeFactor = {0};

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_SetState(
                hBinding,
                0,              // no flags
                Lifetime,
                RenewTime,
                FudgeFactor
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set kdc options: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}

void
Usage(char * Name)
{
    printf("%s\n",Name);
    printf("-cname, -sname : set client & service names\n");
    printf("-crealm, -srealm : set client & service realms\n");
    printf("-cpass, -spass : set client & service passwords\n");
    printf("-crypt : set encryption type\n");
    printf("-gettgt : get a TGT in client's realm, incompat. with -getas\n");
    printf("-getas : get an AS ticket to a service, incompat. with -gettgt\n");
    printf("-gettgs : get a TGS ticket to a service, requires a TGT\n");
    printf("-renew : renew last ticket acquired\n");
    printf("-dump : dump kdc heap trace\n");
    printf("-kdc : set kdc name\n");
    printf("-norm 0xFlags type name1 name2 name3 ... : normalize a name\n");
    printf("-domains : dump domain list\n");
    printf("-setstate lifespan renewspan : set ticket lifetime\n");
    printf("\n");
    printf("-setpass username principalname password  : sets KRB5 password\n");
}



void
__cdecl main(int argc, char *argv[])
{
    int Index;
    BOOLEAN GetAsTicket = FALSE;
    BOOLEAN GetTgsTicket = FALSE;
    BOOLEAN GetTgt = FALSE;
    BOOLEAN RenewTicket = FALSE;
    BOOLEAN SetPass = FALSE;
    BOOLEAN Dump = FALSE;
    BOOLEAN Normalize= FALSE;
    BOOLEAN DumpDomains = FALSE;
    BOOLEAN SetState = FALSE;
    ULONG Lifespan = 0;
    ULONG RenewSpan = 0;
    UNICODE_STRING UserName;
    UNICODE_STRING PrincipalName;
    UNICODE_STRING Password;
    STRING AnsiString;
    UNICODE_STRING AsServerName;
    PKERB_ENCRYPTED_KDC_REPLY AsReplyBody = NULL;
    PKERB_KDC_REPLY AsReply = NULL;
    KERB_TICKET AsTicket;

    PKERB_ENCRYPTED_KDC_REPLY TgsReplyBody = NULL;
    PKERB_KDC_REPLY TgsReply = NULL;
    KERB_TICKET TgsTicket;
    BOOLEAN UnixOnly = FALSE;
    KERB_DBG_INTERNAL_NAME Name = {0};
    ULONG Flags;
    UNICODE_STRING NameParts[20];
    WCHAR NameBuffers[20][100];
    ULONG Index2;


    SetDefaultOpts();

    for (Index = 1; Index < argc ; Index++ )
    {
        //
        // First the principal name features
        //

        if (!_stricmp(argv[Index],"-crealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-srealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }

            UStringFromAnsi(
                &ServiceRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-sname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServiceName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cpass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientPassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-spass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServicePassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-crypt"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&CryptType);

        } else
        if (!_stricmp(argv[Index],"-gettgt"))
        {
            GetTgt = TRUE;
        } else
        if (!_stricmp(argv[Index],"-getas"))
        {
            GetAsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-gettgs"))
        {
            GetTgsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-renew"))
        {
            RenewTicket = TRUE;
        }
        else if (!_stricmp(argv[Index],"-setpass"))
        {
            if (Index+4 > argc)
            {
                printf("Not enough args: %d instead of %d\n", argc, Index+3);
                goto Usage;
            }
            SetPass = TRUE;
            UStringFromAnsi(
                &UserName,
                argv[++Index]
                );
            UStringFromAnsi(
                &PrincipalName,
                argv[++Index]
                );
            UStringFromAnsi(
                &Password,
                argv[++Index]
                );
        }
        else if (!_stricmp(argv[Index],"-dump"))
        {
            Dump = TRUE;
        }
        else if (!_stricmp(argv[Index],"-unix"))
        {
            UnixOnly = TRUE;
        }
        else if (!_stricmp(argv[Index],"-kdc"))
        {
            if (Index+2 > argc)
            {
                goto Usage;
            }
            mbstowcs(KdcNameString,argv[++Index],100);
            RtlInitUnicodeString(
                &KdcName,
                KdcNameString
                );
        }
        else if (!_stricmp(argv[Index],"-norm"))
        {
            Normalize = TRUE;
            if (Index+4 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"0x%x",&Flags);
            sscanf(argv[++Index],"%d",&Name.NameType);
            Name.NameCount = 0;
            Name.References = 0;
            Name.Names = NameParts;
            Index2 = 0;
            while (Index < argc-1)
            {
                mbstowcs(NameBuffers[Index2],argv[++Index],100);
                RtlInitUnicodeString(
                    &NameParts[Index2],
                    NameBuffers[Index2]
                    );
                Index2++;
                Name.NameCount++;
            }


        }
        else if (!_stricmp(argv[Index],"-domains"))
        {
            DumpDomains = TRUE;
        }
        else if (!_stricmp(argv[Index],"-setstate"))
        {
            if (Index+3 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&Lifespan);
            sscanf(argv[++Index],"%d",&RenewSpan);
            SetState = TRUE;
        }
        else {
            goto Usage;
        }


    }

    if (GetTgsTicket && !GetTgt)
    {
        printf("ERROR: Can't get a TGS ticket without a TGT\n");
        goto Usage;
    }

    if (GetAsTicket && GetTgt)
    {
        printf("ERROR: Can't get both an AS ticket and a TGT\n");
        goto Usage;
    }


    if (SetPass)
    {
        SetPassword( &UserName, &PrincipalName, &Password, UnixOnly );
        goto Cleanup;
    }
    if (Dump)
    {
        DumpKdc();
        goto Cleanup;
    }
    if (DumpDomains)
    {
        DumpKdcDomains();
        goto Cleanup;
    }

    if (SetState)
    {
        KdcSetState(
            Lifespan,
            RenewSpan
            );
        goto Cleanup;
    }
    if (Normalize)
    {
        KdcNormalize(
            Flags,
            &Name
            );
        goto Cleanup;
    }
    //
    // Bind to the KDC
    //

    if (!BindToKdc())
    {
        printf("ERROR: Failed to bind to KDC\n");
        goto Cleanup;
    }
    //
    // Now try to get the AS ticket
    //

    if (GetAsTicket)
    {
        AsServerName = ServiceName;
    }
    else if (GetTgt)
    {
        RtlInitUnicodeString(
            &AsServerName,
            KDC_PRINCIPAL_NAME
            );
    }

    if (!GetAnAsTicket(
            &AsServerName,
            &AsTicket,
            &AsReplyBody,
            &AsReply
            ))
    {
        printf("ERROR: Failed to get AS ticket\n");
        goto Cleanup;
    }
    else
    {
        printf("SUCCESS: got an AS ticket\n");
    }

    if (GetTgsTicket)
    {
        if (!GetATgsTicket(
                &AsTicket,
                AsReplyBody,
                AsReply,
                FALSE,          // don't renew
                &TgsTicket,
                &TgsReplyBody,
                &TgsReply))
        {
            printf("ERROR: Failed to get TGS ticket\n");
            goto Cleanup;
        }
        else
        {
            printf("SUCCESS: got a TGS ticket\n");
        }
    }
    if (Dump)
    {
        DumpKdc();
    }

    goto Cleanup;

Usage:
    Usage(argv[0]);

Cleanup:

    KerbCleanupTickets();

    return;
}



void *
MIDL_user_allocate( size_t cb )
{
    return LocalAlloc( 0, ROUND_UP_COUNT(cb,8) );
}

void
MIDL_user_free( void * pv )
{
    LocalFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\utest\prcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       prcache.cxx
//
//  Contents:   Principal cache handling code
//
//  Classes:    CPrincipalHandler
//
//  History:    4-02-93   WadeR   Created
//              04-Nov-93   WadeR   Updated to hold CLogonAccounts
//              08-Nov-93   WadeR   Removed altogether in favour of Account.dll caching.  Sigh.
//
//  Notes:      This is the principal cache code.
//
// When you first call GetASTicket, it passes in a flag indicating a logon is
// in progress.  This flag migrates to the created cache entry, and is passed
// out in the TicketInfo when you call GetTicketInfo().
//
// When you call TGSTicket with a PAC, it checks the flag.  If it's set, it
// calls LogonComplete(success).
//
// LogonComplete will clear the flag, and delete the entry from the cache.
//
// When the cache is full and another entry is needed the first pass looks for
// an entry that is not in the middle of a login.  If it finds one, then that
// is released, and used.  If it can't find one, it finds the oldest logon
// pending, and calls LogonComplete(fail) on it, and uses it.
//
// If ClearCache() attempts to remove an entry with a non-zero use count
// (indicating that someone has called GetLogonInfo and not ReleaseLogonInfo),
// that entry is tagged as invalid and left alone.  Once the use count goes
// down to zero, it will be discarded.
//
//  BUGBUG:     Need some form of notification from the Account code to
//              tell me that an account changed.  Also, need to defer
//              re-loading it if it's in use.
//
//  BUGBUG:    Should change Win4Assert to SafeAssert or ASSERT().
//
//  BUGBUG:    Should remove PrintSizes();
//
//----------------------------------------------------------------------------



// Get the common, global header files.
#include <secpch2.hxx>
#pragma hdrstop

// Place any local #includes files here.

#include "secdata.hxx"
#include <princpl.hxx>
#include <prcache.hxx>


///////////////////////////////////////////////////////////////
//
//
// Global data
//

CPrincipalHandler PrincipalCache;

const PWCHAR pwcKdcPrincipal = L"\\KDC";
const PWCHAR pwcPSPrincipal = L"\\PrivSvr";


// Constants to control cache size.  The cache will start out being
// CACHE_INITIALSIZE bytes (rounded down to a multiple of sizeof(CacheEntry)).
//
// When the cache needs to grow, it will grow by CACHE_GROW bytes (also
// rounded down).  When it is CACHE_SHRINK_THRESHOLD bytes larger than needed,
// it will shrink to become the minumum size needed plus CACHE_SHRINK bytes.
//
// Caveats:
//
// If CACHE_GROW > CACHE_SHRINK_THRESHOLD, every time the cache grows it will
// shrink again.  If CACHE_SHRINK >= CACHE_SHRINK_THRESHOLD, the cache will
// shrink over and over again, without changing size.  Finally, If
// CACHE_SHRINK_THRESHOLD < CACHE_INITIALSIZE then the cache will shrink on
// startup (which is not a smart thing to do).
//
// I suggest that CACHE_SHRINK_THRESHOLD >= 2 * CACHE_SHRINK
//                CACHE_SHRINK_THRESHOLD >= 2 * CACHE_GROW
//                CACHE_SHRINK_THRESHOLD >  CACHE_INITIALSIZE
//                          CACHE_SHRINK ~= CACHE_GROW
//
// Currently, sizeof( CacheEntry ) == 24 bytes.


#if 0
#define CACHE_INITIALSIZE       1024
#define CACHE_GROW               512
#define CACHE_SHRINK_THRESHOLD  1536
#define CACHE_SHRINK             512
#else
#pragma MEMO( Really tiny cache sizes for testing )
#define CACHE_INITIALSIZE       50
#define CACHE_GROW              25
#define CACHE_SHRINK_THRESHOLD  75
#define CACHE_SHRINK            25
#endif

//
// Flags for fCacheFlags.
//
// Note that CACHE_DOING_LOGON (flag for fCacheFlags) has the same value as
// DOING_LOGON (flag for TicketInfo::LogonSteps).
//
#define CACHE_DOING_LOGON       DOING_LOGON
#define CACHE_STICKY            0x00010000
#define CACHE_INVALID           0x00080000


//
// Helper functinons (only used by this file).
//


#define PrintSizes()  KdcDebug(( DEB_T_CACHE, "Line %d: cCache=%d, cMaxCacheSize=%d\n", \
                                            __LINE__, _cCache, _cCacheMaxSize ))


//+---------------------------------------------------------------------------
//
//  Function:   MapNameDRN
//
//  Synopsis:   Maps a name to a domain relative name
//
//  Effects:    may orphan memory (indicated by an error message)
//
//  Arguments:  [pwzInName] -- Name to map
//
//  Returns:    pointer into string passed in, or new memory.
//
//  History:    14-Sep-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     The client should be fixed to NEVER pass in a bogus name,
//              so this should be able to map in place or return an error.
//
//----------------------------------------------------------------------------

static PWCHAR
MapNameDRN( PWCHAR pwzInName )
{
    if (*pwzInName == L'\\')
        return(pwzInName);

    if (wcsnicmp(pwzInName,
                 SecData.KdcRealm()->Buffer,
                 SecData.KdcRealm()->Length / sizeof(WCHAR) ) == 0 )
    {
        // Starts with this domain.
        return(pwzInName + SecData.KdcRealm()->Length / sizeof(WCHAR) );
    }
    ULONG cch = wcslen( awcDOMAIN ) - 1;    // - 1 because don't want the '\'
    if (wcsnicmp( pwzInName, awcDOMAIN, cch ) == 0)
    {
        // Starts with "domain:"
        return(pwzInName + cch);
    }

    KdcDebug(( DEB_WARN, "MapNameDRN(%ws): Don't understand (prepending '\\').\n",
                        pwzInName ));
    KdcDebug(( DEB_WARN, "MapNameDRN: Memory leak.\n" ));

    PWCHAR pwNew = new WCHAR [wcslen(pwzInName) + 2];
    pwNew[0] = '\\';
    pwNew[1] = '\0';
    wcscat( pwNew, pwzInName );

    return(pwNew);
}



//
// Private member functions.
//


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ReleaseCacheEntry
//
//  Synopsis:   Removes a cache slot, releasing if needed.
//
//  Effects:    May call CLogonAccount::Release()
//
//  Arguments:  [i] -- Slot to release
//
//  Requires:   Caller must have write access to _Monitor
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This moves the empty slot to the end.
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::ReleaseCacheEntry( ULONG i )
{
    KdcDebug(( DEB_T_CACHE, "Releasing slot %d.\n", i ));

    if (_Cache[i].plga != NULL)
    {
        _Cache[i].plga->Release();
    }
    if (_Cache[i].pwzName)
    {
        delete _Cache[i].pwzName;
    }

    // Move the empty spot to the end of the array.

    _cCache--;
    Win4Assert( _cCache >= 0 );
    _Cache[i] = _Cache[_cCache];

    // Zero out the new empty spot
    _Cache[_cCache].plga = 0;
    _Cache[_cCache].pwzName = 0;

    PrintSizes();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::Discard
//
//  Synopsis:   Removes a cache entry, completing it's logon if needed.
//
//  Effects:    may call CLogonAccount::LogonComplete()
//
//  Arguments:  [i] -- Slot to discard
//
//  Requires:   Caller must have write access to _Monitor
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::Discard( int i )
{
    KdcDebug(( DEB_T_CACHE, "Discarding %ws from cache slot %d%s.\n",
                            _Cache[i].pwzName, i,
                            (_Cache[i].fCacheFlags & CACHE_DOING_LOGON)?
                                " (logon interupted)":
                                "" ));

    // If it's a logon, then mark it as failed.
    // ReleaseCacheEntry will remove the entry, and move the
    // empty spot to the end.

    if (_Cache[i].fCacheFlags & CACHE_DOING_LOGON)
    {
        _Cache[i].plga->LogonComplete( FALSE, (FILETIME*)&tsZero );    // failed logon, no lockout
        _Cache[i].plga->Save(NULL, FALSE);
    }
    ReleaseCacheEntry( i );

    PrintSizes();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GrowCache
//
//  Synopsis:   Grows the principal cache.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Requires:   Caller must have a write lock on the cache.
//
//  Returns:    HRESULT (S_OK or E_OUTOFMEMORY)
//
//  Signals:    none
//
//  Algorithm:  Adds GROW_SIZE bytes to the cache, rounded down to
//              sizeof(CacheElement).
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GrowCache()
{
    SafeAssert( _cCacheMaxSize >= _cCache );

    ULONG cNewSize = (_cCacheMaxSize * sizeof( CacheEntry ) + CACHE_GROW)
                        / sizeof( CacheEntry );

    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GrowCache() %d -> %d\n",
                             _cCacheMaxSize, cNewSize ));

    PrintSizes();

    SafeAssert( cNewSize > _cCache );

    CacheEntry * pNew = new (NullOnFail) CacheEntry [cNewSize];
    if (pNew == NULL)
    {
        KdcDebug(( DEB_ERROR, "Out of memory.\n" ));
        return(E_OUTOFMEMORY);
    }
    RtlCopyMemory( (PBYTE) pNew, (PBYTE) _Cache, _cCache * sizeof( CacheEntry ) );
    delete _Cache;
    _Cache = pNew;
    _cCacheMaxSize = cNewSize;

    PrintSizes();
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ShrinkCache
//
//  Synopsis:   Shrinks the principal cache, if needed.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Requires:   Caller must have a write lock on the cache.
//
//  Returns:    HRESULT (S_OK or E_OUTOFMEMORY)
//
//  Signals:    none
//
//  Algorithm:  If the cache is SHRINK_THRESHOLD bytes too large, resizes
//              it to be just SHRINK_SIZE bytes bigger than needed, rounded
//              down to sizeof(CacheElement).
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::ShrinkCache()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ShrinkCache(%d)\n", _cCacheMaxSize ));


    PrintSizes();
    SafeAssert( _cCacheMaxSize >= _cCache );

    if ( (_cCacheMaxSize - _cCache) >
                CACHE_SHRINK_THRESHOLD / sizeof( CacheEntry ) )
    {
        // Need to shrink the cache.
        ULONG cNewSize = (_cCache * sizeof( CacheEntry ) + CACHE_SHRINK)
                            / sizeof( CacheEntry );

        KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ShrinkCache() %d -> %d\n",
                                 _cCacheMaxSize, cNewSize ));

        SafeAssert( cNewSize > _cCache );

        CacheEntry * pNew = new (NullOnFail) CacheEntry [cNewSize];
        if (pNew == NULL)
        {
            KdcDebug(( DEB_ERROR, "Out of memory.\n" ));
            return(E_OUTOFMEMORY);
        }
        RtlCopyMemory( (PBYTE) pNew, (PBYTE) _Cache, _cCache * sizeof( CacheEntry ) );
        delete _Cache;
        _Cache = pNew;
        _cCacheMaxSize = cNewSize;
    }

    PrintSizes();
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::PurgeSomething
//
//  Synopsis:   Makes at least one entry in the cache free.
//
//  Effects:    May release some cache entries, may grow the cache.
//
//  Arguments:  (none)
//
//  Requires:   _Monitor to be acquired for writing.
//
//  Algorithm:  Deletes the oldest cache element.
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This function guarentees that on return, there is at least
//              one empty cache entry for the caller to use.  To do this,
//              the caller must know that no other thread will think it can
//              use that slot.  Therefore the caller must have write access
//              to the cache.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::PurgeSomething()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::PurgeSomething()\n" ));

    PrintSizes();

    ULONG i;
    TimeStamp tsOldest = tsInfinity;
    ULONG iOldest = 0;

    //
    // First pass, only consider entries that are not part of
    // a logon in progress.
    //

    for (i=0; i<_cCache; i++)
    {
        if (!(_Cache[i].fCacheFlags &
                 (CACHE_DOING_LOGON | CACHE_STICKY)) &&
            (_Cache[i].cUseCount == 0) &&
            (_Cache[i].tsLastUsed < tsOldest))
        {
            iOldest = i;
            tsOldest = _Cache[i].tsLastUsed;
        }
    }

    if (tsOldest == tsInfinity)
    {
        //
        // Didn't find anything that could be removed.
        //

        return GrowCache();
    }

    //
    // We have found the one to boot out.
    //
    // Convert the lock to write before discarding it.  Since we like to leave
    // things the way we found them, convert it back when we're done.
    //

    Discard( iOldest );
    PrintSizes();
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetCacheEntry
//
//  Synopsis:   Finds something in the cache, adding it if needed and if
//              requested.
//
//  Effects:    May call GetLogonAccount to insert in the cache.
//              May remove something from the cache to make room.
//
//  Arguments:  [pwzName]     -- [in] name of principal
//              [piIndex]     -- [out] cache index
//              [fCacheFlags] -- [in] Flags to put in created cache entry
//              [fLoad]       -- [in] if true, load missing entry.
//
//  Signals:    nothing (unless GetLogonAccount throws something).
//
//  Requires:   Caller must have read access to _Monitor
//
//  Returns:    S_OK if in cache, else result of GetLogonAccount()
//              KDC_E_C_PRINCIPAL_UNKNOWN if it isn't in the cache and
//              fLoad == FALSE
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This code is not exception-safe.  If GetLogonAccount throws
//              an exception, it will leak resources.
//
// This routine returns an index into the cache.  This index must remain
// valid, so you can't allow anyone to change the cache while it's in use.
// Therefore the caller must hold a read lock on the cache, and release it
// once the caller is done with the index returned.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetCacheEntry( PWCHAR pwzName,
                                  PULONG piIndex,
                                  ULONG  fCacheFlags,
                                  BOOL   fLoad )
{
    KdcDebug(( DEB_TRACE, "Looking for account %ws (DRN)\n", pwzName ));

    // Scan through the cache entries looking for this name.

    for (ULONG i=0; i<_cCache; i++ )
    {
        if (!wcsicmp(_Cache[i].pwzName, pwzName ))
        {
            //
            // We found the cache entry we are interested in.
            //

            *piIndex = i;

            //
            // Convert the monitor to write access, so we can modify
            // the last access time.
            //

            _Monitor.ReadToWrite();

            GetCurrentTimeStamp( &_Cache[i].tsLastUsed );

            // Return the monitor and leave.

            _Monitor.WriteToRead();
            return(S_OK);
        }
    }

    // Didn't find it in the cache.

    KdcDebug(( DEB_T_CACHE, "Didn't find %ws in the cache.\n", pwzName ));

    if (!fLoad)
    {
        return(KDC_E_C_PRINCIPAL_UNKNOWN);
    }

    //
    // Build the information that we are going to write to the
    // Cache now, before upgrading to a write lock on the monitor.
    // This way, we keep an exclusive lock for as little time as
    // possible.
    //

    //
    // Copy the name, so it stays valid regardless of what the caller
    // does with it.
    //

    PWCHAR pwzNameCopy = new (NullOnFail) WCHAR [wcslen( pwzName ) + 1];
    if (pwzNameCopy == 0)
    {
        return(E_OUTOFMEMORY);
    }
    wcscpy( pwzNameCopy, pwzName );

    CLogonAccount* plga;

    //
    // Get the account object
    //

    HRESULT hr = GetLogonAccount( pwzName,
                                  TRUE,     // Domain namespace
                                  &plga );
    if (FAILED(hr))
    {
        KdcDebug(( DEB_WARN, "Error finding principal '%ws' (0x%X)\n",
                    pwzName, hr ));
        delete pwzNameCopy;
        return(hr);
    }

    TimeStamp tsNow;
    GetCurrentTimeStamp( &tsNow );

    _Monitor.ReadToWrite();

    if (_cCache == _cCacheMaxSize)
    {
        // Cache is full, so must purge something.
        PurgeSomething();
    }

    //
    // The last entry is free now.
    //
    //
    //  BUGBUG:    PurgeSomething could run out of memory.
    //

    SafeAssert( _cCache < _cCacheMaxSize );

    //
    // Insert the data we constructed before.
    //

    _Cache[_cCache].pwzName = pwzNameCopy;
    _Cache[_cCache].plga = plga;
    _Cache[_cCache].tsLastUsed = tsNow;
    _Cache[_cCache].fCacheFlags = fCacheFlags;

    *piIndex = _cCache;
    _cCache++;

    _Monitor.WriteToRead();

    // Subtract 1 because we've already incremented the count (inside the
    // monitor).

    KdcDebug(( DEB_T_CACHE, "Added %ws in slot %d (flags:%x)\n",
                             _Cache[_cCache-1].pwzName, _cCache-1,
                             _Cache[_cCache-1].fCacheFlags ));

    PrintSizes();
    return(S_OK);
}



//
//
// Public methods
//
//



//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetTicketInfo
//
//  Synopsis:   Gets the ticket-granting info for a principal
//
//  Effects:    Cache lookup.
//
//  Arguments:  [pwzName] -- [in]  Name of principal
//              [pti]     -- [out] ticket info
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This routine is exception-safe.  If any of the routines it
//              calls (GetCacheEntry, CLogonAccount::GetTicketInfo) throw,
//              it will pass the exception up and not leak resources.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetTicketInfo(  PWCHAR pwzName, TicketInfo* pti )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetTicketInfo(%ws)\n",
                                pwzName ));

    SafeAssert( _fInitialized );

    ULONG iIndex;
    PWCHAR pwzDRName = MapNameDRN( pwzName );

    CReadLock lock( _Monitor );

    RET_IF_ERROR( DEB_WARN, GetCacheEntry(pwzDRName, &iIndex, 0) );

    RET_IF_ERROR( DEB_TRACE, _Cache[iIndex].plga->GetTicketInfo(
                                        &(pti->gGuid),
                                        &(pti->kKey),
                                        &(pti->fTicketOpts) ));

    pti->fLogonSteps = _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetLogonInfo
//
//  Synopsis:   Gets the logon info (and ticket info) for a principal
//
//  Effects:    Cache lookup, increments the use count of returned principal
//
//  Arguments:  [pwzName] -- [in] name of principal
//              [pli]     -- [out] logon info
//              [pti]     -- [out] ticket info
//              [phHandle]-- [out] hint for Release, below.
//              [fLogon]  -- [in] true if it's a logon attempt
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This probes the memory returned from
//              CLogonAccount::GetLogonInfo().
//
// This routine will catch any exceptions thrown by it's callees, and return
// and error code without leaking resources.
//
// The caller MUST call ReleaseLogonInfo with the handle returned from this
// call when the logon info is no longer needed.  The cache will not delete
// the logon hours or the valid workstations until ReleaseLogonInfo is called.
//
//----------------------------------------------------------------------------

#define PROBE_R_DWORD( _x_ )      ((void) (*((volatile long *)(_x_))))
#define PROBE_R_CHAR( _x_ )      ((void) (*((volatile char *)(_x_))))

HRESULT
CPrincipalHandler::GetLogonInfo(PWCHAR pwzName,
                                LogonInfo * pli,
                                TicketInfo* pti,
                                PULONG phHandle,
                                BOOL fLogon )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetLogonInfo(%ws)\n",
                                pwzName ));
    SafeAssert( _fInitialized );
    HRESULT hr;
    TRY
    {
        CReadLock lock (_Monitor);

        RtlZeroMemory( pli, sizeof( LogonInfo ) );
        RtlZeroMemory( pti, sizeof( TicketInfo ) );

        PWCHAR pwzDRName = MapNameDRN( pwzName );
        ULONG iIndex;

        hr = GetCacheEntry( pwzDRName,
                            &iIndex,
                            fLogon? CACHE_DOING_LOGON : 0);
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetCacheEntry(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }

        *phHandle = iIndex;

        hr = _Cache[iIndex].plga->GetTicketInfo( &(pti->gGuid),
                                                 &(pti->kKey),
                                                 &(pti->fTicketOpts) );
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetTicketInfo(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }
        pti->fLogonSteps = _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON;

        hr = _Cache[iIndex].plga->GetLogonInfo(  &(pli->pbValidLogonHours),
                                                 &(pli->prpwszValidWorkstations),
                                                 &(pli->fInteractive),
                                                 &(pli->fAttributes),
                                                 &(pli->ftAccountExpiry),
                                                 &(pli->ftPasswordChange),
                                                 &(pli->ftLockoutTime) );
        if (FAILED(hr))
        {
            KdcDebug(( DEB_TRACE, "GetLogonInfo(%ws)==%x\n",
                                    pwzDRName, hr ));
            goto Error;
        }

        //
        // Check that the pointers, etc, returned are valid.
        //
        if (pli->pbValidLogonHours)
        {
            PROBE_R_DWORD( pli->pbValidLogonHours );
            PROBE_R_DWORD( pli->pbValidLogonHours->pBlobData );
            PROBE_R_DWORD( pli->pbValidLogonHours->pBlobData +
                                        pli->pbValidLogonHours->cbSize );
#if DBG
            if (KDCInfoLevel & DEB_T_CACHE)
            {
                SECURITY_STRING ss;
                ss = FormatBytes(pli->pbValidLogonHours->pBlobData,
                                 (BYTE) pli->pbValidLogonHours->cbSize );
                KdcDebug(( DEB_T_CACHE, "Valid logon hours (%d): %wZ\n",
                                        pli->pbValidLogonHours->cbSize, &ss ));
                SRtlFreeString( &ss );
            }
#endif
        }

        if (pli->prpwszValidWorkstations)
        {
            PROBE_R_DWORD( pli->prpwszValidWorkstations );
            KdcDebug(( DEB_T_CACHE, "There are %d valid workstations\n",
                                    pli->prpwszValidWorkstations->cElems ));
            for (ULONG i=0; i<pli->prpwszValidWorkstations->cElems; i++ )
            {
                (void) wcslen( pli->prpwszValidWorkstations->pElems[i] );
                KdcDebug(( DEB_T_CACHE, "Valid workstation[%d] = %ws\n",
                        i, pli->prpwszValidWorkstations->pElems[i] ));
            }
        }

        //
        // Bump my read lock up to a write lock, then increment the count.
        // Note that the lock is released at the end of this scope
        // automatically.
        //

        _Monitor.ReadToWrite();
        _Cache[iIndex].cUseCount++;
        _Monitor.WriteToRead();

        hr = S_OK;
Error:
        // Fall out of the TRY/CATCH block.
        ;
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();
        KdcDebug(( DEB_ERROR, "Exception 0x%X getting and checking logon info for %ws\n",
                             hr, pwzName ));
    }
    END_CATCH
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseLogonInfo
//
//  Synopsis:   Allows the cache entry to be deleted.
//
//  Effects:    Decrements the use count
//
//  Arguments:  [pwzName] -- Name of principal
//              [iHandle] -- handle returned from GetLogonInfo
//
//  Returns:    void
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      iHandle is just a hint.  If it has been moved,
//              this will look through the cache for it.
//
//----------------------------------------------------------------------------

void
CPrincipalHandler::ReleaseLogonInfo( PWCHAR pwzName, ULONG iHandle )
{
    SafeAssert( _fInitialized );

    _Monitor.GetRead();

    if ( (iHandle >= _cCache) ||
          wcsicmp( _Cache[iHandle].pwzName, pwzName ) != 0)
    {
        //
        // The cache entry must have been moved.
        //
        // It still has to be in the cache, because it's tagged as in-use.
        // This will be fast, and it must succeed, because it won't have to
        // hit the disk.
        //
#if DBG
        HRESULT hr =
#else
        (void)
#endif
        GetCacheEntry( pwzName, &iHandle, 0, FALSE );   // No flags, don't load
#if DBG
        Win4Assert( SUCCEEDED( hr ) );
#endif
    }

    Win4Assert( _Cache[iHandle].cUseCount > 0 );


    _Monitor.ReadToWrite();
    _Cache[iHandle].cUseCount--;

    // If the CACHE_INVALID bit is set, and the CACHE_DOING_LOGON bit is NOT
    // set, and the use count is zero, then discard it.
    if (((_Cache[iHandle].fCacheFlags & (CACHE_INVALID | CACHE_DOING_LOGON))
            == CACHE_INVALID ) &&
        (_Cache[iHandle].cUseCount == 0) )
    {
        Discard( iHandle );
    }

    _Monitor.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::GetPAC
//
//  Synopsis:   Gets the PAC for a principal.
//
//  Effects:    Allocates memory, creates a CPAC
//
//  Arguments:  [pwzName] -- [in] principal to get pac for
//              [ppPAC]   -- [out] pac
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     Need to merge MikeSe's changes, comment better.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::GetPAC( PWCHAR pwzName, CPAC ** ppPAC )
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::GetPAC(%ws)\n",
                                pwzName ));
    SafeAssert( _fInitialized );
    PWCHAR pwzDRName = MapNameDRN( pwzName );
    SECID           gSID;
    KerbKey         kGarbage;
    ULONG           dwGarbage;
    ULONG           iIndex;

    CReadLock lock(_Monitor);

    RET_IF_ERROR( DEB_WARN, GetCacheEntry(pwzDRName, &iIndex, 0) );     // 0 -> no flags
    RET_IF_ERROR( DEB_WARN, _Cache[iIndex].plga->GetTicketInfo(
                                                    &gSID,
                                                    &kGarbage,
                                                    &dwGarbage ) );
    *ppPAC = new CPAC;
    (*ppPAC)->Init( _Cache[iIndex].plga->GetGroupInfo(),
                    gSID,
                    pwzName,
                    NULL );       // NT Sid.

#if DBG
    // Why would anyone want to get thier PAC if they aren't doing
    // a login?
    if ((_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON) == 0)
    {
        KdcDebug(( DEB_WARN, "Strange, \"%ws\" fetching a PAC outside login.\n",
                             pwzName ));
    }
#endif
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::LogonComplete
//
//  Synopsis:   Calls LogonComplete on the CLogonAccount, saves it, releases it.
//
//  Effects:    releases memory.
//
//  Arguments:  [pwzName] -- [in] Name of principal who's finished logging on.
//              [fGood]   -- [in] True if it's a successful logon.
//              [ftLock]  -- [in] Account locked out until this time.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:      This catches any exceptions, and passes back error codes.
//              This should check the CACHE_INVALID bit and, if set, discard
//              the entry.  But, since this always discards the entry it can
//              safely ignore the bit.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::LogonComplete(   PWCHAR pwzName,
                                    BOOL fGood,
                                    FILETIME ftLock )
{
    SafeAssert( _fInitialized );
    HRESULT hr;
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::LogonComplete(%ws)\n",
                                pwzName ));
    TRY
    {
        ULONG iIndex;
        PWCHAR pwzDRName = MapNameDRN( pwzName );

        CReadLock lock(_Monitor);

        hr = GetCacheEntry(pwzDRName, &iIndex, 0);  // no special flags
        if (SUCCEEDED(hr))
        {
            _Monitor.ReadToWrite();

            if ((_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON) == 0)
            {
                // Oops!  We aged this principal out of the cache already.
                // This means that the principal took so long to log on, we
                // decided that it was a failed logon attempt and we've
                // already marked it as such.  So we'll just ignore this call
                // to LogonComplete.

                KdcDebug(( DEB_ERROR, "Someone called LogonComplete when "
                                      "they weren't logging on!\n" ));
            }
            else
            {
                _Cache[iIndex].plga->LogonComplete( fGood, &ftLock );
                _Cache[iIndex].plga->Save(NULL, FALSE);
            }
            ReleaseCacheEntry( iIndex );
            hr = ShrinkCache();
        }
        else
        {
            KdcDebug(( DEB_WARN, "GetCacheEntry(%ws) failed 0x%x.\n",
                                  pwzDRName, hr ));
        }
    }
    CATCH( CException, e )
    {
        hr = e.GetErrorCode();
        KdcDebug(( DEB_ERROR, "Exception 0x%X in LogonComplete( %ws )\n",
                             hr, pwzName ));
    }
    END_CATCH
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::ClearCache
//
//  Synopsis:   Removes one or more cache entries
//
//  Effects:    May call LogonComplete on some entries.
//
//  Arguments:  [pwzName] -- Name of principal.  If null, clears everything.
//              [fForce]  -- If true, remove everything, even pending logons.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    05-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::ClearCache(PWCHAR pwzName, BOOL fForce)
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::ClearCache(%ws)\n", pwzName ));

    SafeAssert( _fInitialized );

    // Flag to indicate the principal should be reloaded, because it was
    // in the middle of a logon.
    BOOL fReload = FALSE;

    if (pwzName)
    {
        ULONG iIndex;

        // Get a read lock so we can call GetCacheEntry
        _Monitor.GetRead();

        // Get the cache entry, but don't load it if it isn't there.
        if (GetCacheEntry(pwzName, &iIndex, 0, FALSE) == S_OK)
        {
            // It was found in the cache.
            // We are going to change it, either to mark it as invalid or to
            // delete it, so upgrade our lock.
            _Monitor.ReadToWrite();

            // If fForce is true, or the cache entry is in use, we can discard
            // it.  If it's in use, and fForce isn't set, simply mark it as
            // invalid.
            if (fForce || (_Cache[iIndex].cUseCount == 0 ))
            {
                if (_Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON)
                {
                    // This principal was in the process of logging on, so
                    // reload the account (so LogonComplete can succeed),
                    // unless fForce is true (because we don't want it to
                    // reappear).
                    fReload = !fForce;
                }
                ReleaseCacheEntry( iIndex );
            }
            else
            {
                _Cache[iIndex].fCacheFlags |= CACHE_INVALID;
            }

            //
            // If we flushed an account that was in the process of logging on,
            // we should re-load it.
            //
            if (fReload)
            {
                ULONG iFoo;
                _Monitor.WriteToRead();
                (void) GetCacheEntry( pwzName, &iFoo, CACHE_DOING_LOGON );
            }
        }
        _Monitor.Release();
    }
    else
    {
        // Some of the cache entries will be in the middle of a logon.  We
        // must save the names away, so they can be re-loaded later.
        //
        // Since the cache is fixed size, we know the maximim number of names.
        PWCHAR *    apwzNames = new PWCHAR [_cCacheMaxSize];
        ULONG       cNamesUsed = 0;

        // Going to delete everything, so get the lock once up front.

        _Monitor.GetWrite();

        //
        // This loop is a little strange in that both ends move.  The
        // Discard() method will move the empty slot to the end of the cache,
        // and decrement _cCache.  Since it moves a new cache entry to the
        // vacated spot, we don't want to increment the index if we discard
        // something.
        //
        // On the other hand, if we don't discard the entry, we must increment
        // the index to look at the next entry.
        //
        // Every iteration of the loop gets one step closer to finishing,
        // either by raising the index or lowering the max.

        ULONG iIndex = 0;
        while (iIndex < _cCache)
        {
            if (fForce || (_Cache[iIndex].cUseCount == 0 ))
            {
                if (!fForce && _Cache[iIndex].fCacheFlags & CACHE_DOING_LOGON)
                {
                    apwzNames[cNamesUsed++] = _Cache[iIndex].pwzName;
                    _Cache[iIndex].pwzName = 0;     // so it isn't deleted by Discard.
                }
                // This will decrement _cCache
                ReleaseCacheEntry( iIndex );
            }
            else
            {
                _Cache[iIndex].fCacheFlags |= CACHE_INVALID;
                iIndex++;
            }
        }

        //
        // Finished clearing the cache, so re-load the principals that were in
        // the middle of a logon.
        //

        _Monitor.WriteToRead();
        for (iIndex=0; iIndex < cNamesUsed; iIndex++)
        {
            ULONG iFoo;
            (void) GetCacheEntry( apwzNames[iIndex], &iFoo, CACHE_DOING_LOGON);
            delete apwzNames[iIndex];
        }
        delete apwzNames;
        _Monitor.Release();
    }


    if ( !((pwzName == NULL) && fForce) )
    {
        //
        // If we are forcing everything out of the cache, we shouldn't be
        // loading new stuff again.  Otherwise we can count on these being
        // useful.
        //
        // Load the frequently used accounts.
        //
        //

        ULONG iFoo;
        _Monitor.GetRead();
        RET_IF_ERROR( DEB_ERROR, GetCacheEntry( pwcKdcPrincipal, &iFoo, CACHE_STICKY ));
        RET_IF_ERROR( DEB_ERROR, GetCacheEntry( pwcPSPrincipal, &iFoo, CACHE_STICKY ));
        _Monitor.Release();

        //
        // Load the ticket info for the KDC and PS
        //

        TicketInfo tiKDC;
        TicketInfo tiPS;

        RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcKdcPrincipal, &tiKDC ) );
        RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcPSPrincipal, &tiPS ) );

        _Monitor.GetWrite();
        _tiKdc = tiKDC;
        _tiPS = tiPS;
        _Monitor.Release();
    }

    _Monitor.GetWrite();
    HRESULT hr = ShrinkCache();
    _Monitor.Release();
#if DBG
    if (FAILED(hr))
    {
        KdcDebug(( DEB_ERROR, "ShrinkCache() == 0x%x\n", hr ));
    }
#endif
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::AgeCache
//
//  Synopsis:   Removes old entries from the cache.
//
//  Effects:    May release lots of cache slots.
//
//  Arguments:  (none)
//
//  Returns:    S_OK
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::AgeCache()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::AgeCache()\n" ));
    SafeAssert( _fInitialized );

    ULONG i;
    int cRemoved = 0;
    TimeStamp tsCutoff;

    GetCurrentTimeStamp( &tsCutoff );
    tsCutoff = tsCutoff - _tsMaxAge;

    CWriteLock lock( _Monitor );

    for (i=0; i<_cCache; i++)
    {
        if (!(_Cache[i].fCacheFlags & CACHE_STICKY) &&
            (_Cache[i].cUseCount == 0) &&
            (_Cache[i].tsLastUsed < tsCutoff))
        {
            Discard(i);
            cRemoved++;
        }
    }

    HRESULT hr = ShrinkCache();

    KdcDebug(( DEB_T_CACHE, "AgeCache() removed %d\n", cRemoved ));

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPrincipalHandler::Init
//
//  Synopsis:   Initializes the principal handler
//
//  Effects:    Calls CoInitialize, loads PS and KDC info.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  History:    04-Nov-93   WadeR   Created
//
//  Notes:
//
//  BUGBUG:     If this fails, it could leak resources.
//
//----------------------------------------------------------------------------

HRESULT
CPrincipalHandler::Init()
{
    KdcDebug(( DEB_T_CACHE, "CPrincipalHandler::Init()\n" ));

    if (_fInitialized)
    {
        Win4Assert( !"CPrincipalHandler::Init() called twice!" );
        return(E_UNEXPECTED);
    }
    RET_IF_ERROR(DEB_ERROR, _sci.Init() );

    _tsMaxAge = tsZero;
    AddSecondsToTimeStamp( &_tsMaxAge, 60 * 60 );       // BUGBUG: magic numbers.

    //
    // Initialize the cache
    //
    _cCache = 0;
    _cCacheMaxSize = CACHE_INITIALSIZE / sizeof( CacheEntry );
    _Cache = new (NullOnFail) CacheEntry [ _cCacheMaxSize ];
    if (_Cache == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    _fInitialized = TRUE;

    // This will load the KDC and PS info.
    RET_IF_ERROR( DEB_ERROR, ClearCache() );

    //
    // Load the ticket info for the KDC and PS
    //

    TicketInfo tiKDC;
    TicketInfo tiPS;

    RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcKdcPrincipal, &tiKDC ) );
    RET_IF_ERROR( DEB_ERROR, GetTicketInfo( pwcPSPrincipal, &tiPS ) );

    _Monitor.GetWrite();
    _tiKdc = tiKDC;
    _tiPS = tiPS;
    _Monitor.Release();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\utest\ticktest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ticktest.cxx
//
//  Contents:   KDC Ticket granting service test code.
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------


#include <secpch2.hxx>
#pragma hdrstop
#include <stdio.h>
#include <authdata.hxx>
#include <kerbcomm.h>
#include <tostring.hxx>
extern "C" {
#include <winsock.h>
#include <kdc.h>
}


#include <kdcsvr.hxx>
#include <tktutil.hxx>


extern PWCHAR pwzKdcPasswd;
extern PWCHAR pwzPSPasswd;
extern PWCHAR pwzRealm;
extern PWCHAR pwzUserName;
extern PWCHAR pwzUserPasswd;
extern PWCHAR pwzTransport;
extern PWCHAR pwzEndPoint;
extern PWCHAR pwzAddress;
extern PWCHAR pwzClientAddress;
extern PWCHAR pwzKDC;
extern PWCHAR pwzPrivSvr;
extern PWCHAR pwzServiceName;

extern DWORD dwUserRID;
extern DWORD dwServiceRID;
extern DWORD dwKdcRID;
extern DWORD dwPrivSvrRID;

extern BOOL fGetAS;
extern BOOL fGetTGS;
extern BOOL fGetPAC;
extern BOOL fGetCTGT;
extern BOOL fGetServiceTkt;
extern BOOL fRenewSvc;
extern BOOL fTestTransitComp;
extern BOOL fTestReferal;
extern BOOL fPrintPACs;
extern BOOL fPrintTickets;
extern BOOL fVerbose;


enum BindTarget {KDC, KDCDBG};
enum CallType {GETTGS, GETAS};

handle_t
BindTo( BindTarget target,
        LPTSTR pszTransport,
        LPTSTR pszEndpoint,
        LPTSTR pszServer );


NTSTATUS
CheckPAData( const KERB_ENCRYPTION_KEY& kSessionKey, PKERB_PA_DATA pkdReply, enum CallType type );


//////////////////////////////////////////////////////////////////////////
//
// Socket client functions
//
//////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSockets
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#define KERB_KDC_CALL_TIMEOUT           10


void
PrintFlags( const KERB_TICKET_FLAGS fFlags )
{
#define KerbFlagDef(x)      {#x, KERB_TICKET_FLAGS_ ## x}
    const static struct {
        char * FlagName;
        KERB_TICKET_FLAGS  Flag;
        } Flags[] = {
            KerbFlagDef( forwardable ),
            KerbFlagDef( forwarded ),
            KerbFlagDef( proxiable ),
            KerbFlagDef( proxy ),
            KerbFlagDef( may_postdate ),
            KerbFlagDef( postdated ),
            KerbFlagDef( invalid ),
            KerbFlagDef( renewable ),
            KerbFlagDef( initial ),
            KerbFlagDef( pre_authent ),
            KerbFlagDef( hw_authent ),
            KerbFlagDef( reserved )
        };
    const int cFlags = sizeof( Flags ) / sizeof( Flags[0] );

    for (int i=0; i<cFlags; i++)
    {
        if (fFlags & Flags[i].Flag)
        {
            printf("%s,", Flags[i].FlagName );
        }
    }
    printf("\b \n");
#undef KerbFlagDef
}


inline void
Print( const UNICODE_STRING& ssFoo )
{
    printf("%wZ", &ssFoo );
}

void
Print( const LARGE_INTEGER& tsFoo )
{
    UNICODE_STRING ssTime = TimeStampToString( tsFoo );
    printf("%wZ", &ssTime );
    KerbFreeString(&ssTime);
}

void
Print( const KERB_ENCRYPTION_KEY& kKey )
{
    printf("%d,%d,{",kKey.keytype, kKey.keyvalue.length);
    for (ULONG i=0; i<kKey.keyvalue.length; i++ )
    {
        printf("%02x ", kKey.keyvalue.value[i] );
    }
    printf("\b}");
}


void
Print( const PISID psid )
{
    WCHAR Buffer[512];
    UNICODE_STRING usFoo = {0, sizeof(Buffer), Buffer};
    RtlConvertSidToUnicodeString( &usFoo, psid, FALSE );
    printf("%wZ", &usFoo );
}


void
PrintTicket( PKERB_TICKET pktTicket,
             PWCHAR      pwzPasswd )
{
#ifdef notdef
    NTSTATUS               sc;
    PKERB_ENCRYPTED_TICKET pkitTicket;
    PKERB_TICKET pktTicketCopy;
    KERB_ENCRYPTION_KEY             kKey;

    UNICODE_STRING ssFoo;

    RtlInitUnicodeString( &ssFoo, pwzPasswd );

    KerbHashPassword(
        &ssFoo,
        KERB_ETYPE_RC4_MD4,
        &kKey
        );

    pktTicketCopy = (PKerbTicket) new BYTE [sizeof(SizeOfTicket( pktTicket )];
    RtlCopyMemory( pktTicketCopy, pktTicket, SizeOfTicket( pktTicket ) );

    sc = KerbUnpackTicket( pktTicketCopy, &kKey, &kitTicket );
    if (FAILED(sc))
    {
        printf("Couldn't decrypt ticket with password '%ws' (0x%X)\n",
                pwzPasswd, sc );
        return;
    }

    if (kitTicket.dwVersion != 5) {
        printf("\t*** dwVersion: 0x%lX\t\t*** not 5\n", kitTicket.dwVersion );
    } else {
        printf("\tdwVersion:\t%d",kitTicket.dwVersion );
    }
    printf("\n\tFlags: (0x%x):\t",kitTicket.kitEncryptPart.fTicketFlags );
    PrintFlags( kitTicket.kitEncryptPart.fTicketFlags );

    printf("\tInitialTicket:\t" );
    ::Print( kitTicket.gInitialTicket );
    printf("\n\tThisTicket:\t" );
    ::Print( kitTicket.gThisTicket );
    printf("\n\tIssuingRealm: \t" );
    ::Print( kitTicket.dsIssuingRealm );
    printf("\n\tServerName: \t" );
    ::Print( kitTicket.ServerName.accsid );

    printf("\n\tSessionKey: \t" );
    ::Print(kitTicket.kitEncryptPart.kSessionKey);

    printf("\n\tInitialRealm: \t" );
    ::Print( kitTicket.kitEncryptPart.dsInitialRealm );
    printf("\n\tPrincipal: \t" );
    ::Print( kitTicket.kitEncryptPart.Principal.accsid );

    printf("\n\ttsAuthentication:" );
    ::Print( kitTicket.kitEncryptPart.tsAuthentication );
    printf("\n\ttsStartTime:\t" );
    ::Print( kitTicket.kitEncryptPart.tsStartTime );
    printf("\n\ttsEndTime:\t" );
    ::Print( kitTicket.kitEncryptPart.tsEndTime );
    printf("\n\ttsRenewUntil:\t" );
    ::Print( kitTicket.kitEncryptPart.tsRenewUntil );

    printf("\n\tTransited: \t%ws", kitTicket.kitEncryptPart.tdTransited.pwzTransited );
    // printf("\n\tHostAddresses:\t%ws", kitTicket.kitEncryptPart.pkdHostAddresses );
    printf("\n");

    if (kitTicket.kitEncryptPart.pkdAuthorizationData)
    {
        ULONG j;
        BOOL fFoundSomething = FALSE;
        CAuthDataList* padlList = (CAuthDataList*)kitTicket.kitEncryptPart.pkdAuthorizationData->bPAData;
        CAuthData* padData;
        for (padData = padlList->FindFirst(Any);
             padData != NULL;
             padData = padlList->FindNext(padData, Any))
        {
            switch (padData->adtDataType)
            {
#if 0
            case Pac:
                {
                    printf("\tAuthorizationData (PAC):\n");

                    CPAC Pac;
                    ULONG cb = Pac.UnMarshal( (PBYTE) padData->abData );
                    if (cb <= padData->cbData )
                    {
                        if (fPrintPACs)
                            ::Print( Pac );
                        fFoundSomething = TRUE;
                        break;
                    }
                    else
                    {
                        printf("PAC didn't unmarshal correctly");
                    }
                }
#endif
            default:
                printf("\tAuthorizationData (Unknown: %d bytes):",
                       padData->cbData );
                for (j=0; j < padData->cbData; j++ ) {
                    printf("%x ", padData->abData[j] );
                }
                printf("\n" );
            }
        }

        if (!fFoundSomething)
        {
            printf("\tAuthorizationData (%d) : 0x", kitTicket.kitEncryptPart.pkdAuthorizationData->cbPAData );
            for (j=0; j < kitTicket.kitEncryptPart.pkdAuthorizationData->cbPAData; j++ ) {
                printf("%x ", ((PBYTE)kitTicket.kitEncryptPart.pkdAuthorizationData->bPAData)[j] );
            }
            printf("\n" );
        }
    }
#endif
}

int
PrintPAC( PEncryptedData pedPAC,
          PWCHAR         pwzKdcPasswd )
{
#ifdef notdef
    // Decrypt it again to print it out.
    PEncryptedData pedPacCopy =
        (PEncryptedData) new BYTE [ SizeOfEncryptedData( pedPAC ) ];
    memcpy( pedPacCopy, pedPAC, SizeOfEncryptedData( pedPAC ) );

    //
    // Find the PAC in the mess of credentials
    //

    CAuthData * pad = ((CAuthDataList*)pedPacCopy->ctCipher.bMessage)->FindFirst(Pac_2);
    if (pad == NULL)
    {
        printf("GetPAC's return didn't have a PAC in it.");
        return 1;
    }

    PEncryptedData pedRealPac = (PEncryptedData) pad->abData;

    //
    // Get the KDC's key, use it to decrypt pedNewPac
    //
    // Print out the resulting new pac.
    //
    // delete pedNewPac
    //


    NTSTATUS sc;
    UNICODE_STRING ssFoo;
    KERB_ENCRYPTION_KEY kKey;
    SRtlInitString( &ssFoo, pwzKdcPasswd );
    KerbHashPassword(
        &ssFoo,
        KERB_ETYPE_RC4_MD4,
        &kKey
        );

    sc = KIDecryptData(pedRealPac, &kKey );

    if (!NT_SUCCESS(sc))
    {
        printf("Couldn't decrypt PAC second time 0x%X\n", sc );
        return(1);
    }
#endif
    return(0);
}


NTSTATUS
CheckPAData( const KERB_ENCRYPTION_KEY& kSessionKey, PKERB_PA_DATA pkdReply, enum CallType type )
{
#ifdef notdef
    NTSTATUS err = 0;
    TimeStamp tsKdcTime, tsLocalTime, tsDiff;
    CAuthData * pad;
    CAuthDataList * padlList;

    if (pkdReply == 0)
    {
        printf("Nothing in the padata returned.\n");
        return(1);
    }

    //
    // This PAData should contain: Time
    // May contain: address info
    // May contain: old passwords
    //

    padlList = (CAuthDataList*) &pkdReply->bPAData[0];
    if (padlList->GetMaxSize() != pkdReply->cbPAData )
    {
        printf("Sizes are wrong for padata.\n");
        err = -1;
    }

    pad = padlList->FindFirst( Time );
    if (pad == NULL)
    {
        printf("Time not included in padata.");
        err = -1;
    }

    //sc = KIDecryptData( (PEncryptedData) pad->bData, &(KERB_ENCRYPTION_KEY&)kSessionKey );
    //if (FAILED(sc))
    //{
    //    printf("error 0x%X decrypting time.\n", sc );
    //    err = -1;
    //}
    //tsKdcTime = * (PTimeStamp) ((PEncryptedData) pad->abData)->ctCipherText.bMessage;
    tsKdcTime = * (PTimeStamp) pad->abData;
    GetCurrentTimeStamp( &tsLocalTime );
    if (tsKdcTime > tsLocalTime)
        tsDiff = tsKdcTime - tsLocalTime;
    else
        tsDiff = tsLocalTime - tsKdcTime;

    if (tsDiff.QuadPart > UInt32x32To64( 10000000ul, 15 ) )    // 15 seconds.
    {
        printf("Warning: the time at the KDC is " );
        Print( tsDiff );
        printf(" different.\n" );
    }

    //
    // Address info
    //

    //
    // Passwords
    //
#endif
    return(S_OK);
}


KERBERR
FooGetASTicket( IN  PVOID           hBinding,
                IN  PWCHAR          pwzUserName,
                IN  PWCHAR          pwzUserRealm,
                IN  PWCHAR          pwzServiceName,
                IN  PWCHAR          pwzUserPassword,
                IN  PWCHAR          pwzThisWorkstation,
                OUT PKERB_TICKET    pktTicket,
                OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody )

{
    NTSTATUS Status;
    KERBERR KerbErr;
    KERB_ENCRYPTION_KEY kUserKey;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    PKERB_ENCRYPTED_DATA pedReply = 0;
    PULONG CryptArray = NULL;
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    UNICODE_STRING ssPass;
    UNICODE_STRING ssService;
    UNICODE_STRING ssRealm;
    UNICODE_STRING ssName;
    PKERB_KDC_REPLY Reply = NULL;

    RtlInitUnicodeString( &ssPass, pwzUserPasswd );
    KerbHashPassword(
        &ssPass,
        KERB_ETYPE_RC4_MD4,
        &kUserKey
        );


    RtlZeroMemory(
        &OutputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );

    RtlZeroMemory(
        &InputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );


    RtlInitUnicodeString(
        &ssService,
        pwzServiceName
        );
    RtlInitUnicodeString(
        &ssRealm,
        pwzUserRealm
        );
    RtlInitUnicodeString(
        &ssName,
        pwzUserName
        );

    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );

    RequestBody->kdc_options =
                            KERB_KDC_OPTIONS_forwardable |
                            KERB_KDC_OPTIONS_proxiable |
                            KERB_KDC_OPTIONS_renewable |
                            KERB_KDC_OPTIONS_renewable_ok;
    RequestBody->nonce = 3;

    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );


    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    TempTime.QuadPart = 0;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );
    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, NULL );
    CryptArray =  new ULONG [ CryptArraySize ];
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Faield to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // BUGBUG: don't build pre-auth data
    //


    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->server_name,
                    &ssService
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;

    }

    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &ssName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ssRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert unicde string to realm: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_AS_REQ;


    KerbErr = KerbPackKdcRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    Status = KerbCallKdc(
                hBinding,
                &InputMessage,
                &OutputMessage
                );

    KerbErr = (KERBERR) Status;

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",Status);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                &Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &Reply->encrypted_part,
                &kUserKey,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    sc = CheckPAData( pkrReply->kSessionKey, pkdReply, GETAS );
    if (FAILED(sc))
    {
        printf("Problem with PAData returned: 0x%X\n", sc );
        return(1);
    }
#endif

    *pktTicket = Reply->ticket;

Cleanup:
    //
    // BUGBUG: memory leak here
    //

    return(KerbErr);
}

KERBERR
FooGetTGSTicket(
    IN  PVOID hBinding,
    IN  PWCHAR pwzUserName,
    IN  PWCHAR pwzUserRealm,
    IN  PWCHAR pwzServiceName,
    IN  PKERB_TICKET pktTGTicket,
    IN  PKERB_ENCRYPTED_KDC_REPLY pkrTGTReply,
    IN  ULONG AuthDataSize,
    IN  PUCHAR AuthData,
    IN BOOLEAN Renew,
    OUT PKERB_TICKET pktTicket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    UNICODE_STRING ssService;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST  PaData;
    PULONG CryptArray = NULL;
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKERB_KDC_REPLY Reply = NULL;
    KERB_ENCRYPTED_DATA EncAuthData;

    RtlZeroMemory(
        &EncAuthData,
        sizeof(KERB_ENCRYPTED_DATA)
        );

    RtlInitUnicodeString(
        &ssService,
        pwzServiceName
        );

    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    //
    // Build the request
    //

    RtlZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );
    RequestBody->kdc_options = KERB_KDC_OPTIONS_forwardable |
                          KERB_KDC_OPTIONS_proxiable |
                          KERB_KDC_OPTIONS_renewable |
                          KERB_KDC_OPTIONS_renewable_ok;

    if (Renew)
    {
        RequestBody->kdc_options |= KERB_KDC_OPTIONS_renew;
    }
    RequestBody->nonce = 4;

    //
    // Build an AP request inside an encrypted data structure.
    //

    PaData.next = NULL;
    PaData.value.preauth_data_type = PA_TGS_REQ;

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &pkrTGTReply->session_key,
                5,                              // nonce
                pktTGTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                (PULONG) &PaData.value.preauth_data.length,
                &PaData.value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.KERB_KDC_REQUEST_preauth_data = &PaData;
    Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, NULL );
    CryptArray =  new ULONG [ CryptArraySize ];
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Faield to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    &UserName
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &UserRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->server_name,
                &ssService
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );

    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;


    TempTime.LowPart  = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    if (ARGUMENT_PRESENT(AuthData))
    {
        ULONG EncryptionOverhead;

        KerbErr = KerbGetEncryptionOverhead(
                    pktTGTicket->encrypted_part.encryption_type,
                    &EncryptionOverhead,
                    NULL // BUGBUG
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get encryption overhead: 0x%x\n",KerbErr);
            goto Cleanup;
        }
        EncAuthData.cipher_text.length = AuthDataSize + EncryptionOverhead;
        EncAuthData.cipher_text.value = (PUCHAR) MIDL_user_allocate(EncAuthData.cipher_text.length);
        if (EncAuthData.cipher_text.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        KerbErr = KerbEncryptData(
                    &EncAuthData,
                    AuthDataSize,
                    AuthData,
                    pktTGTicket->encrypted_part.encryption_type,
                    &pkrTGTReply->session_key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to encrypt pac auth data: 0x%x\n",KerbErr);
            goto Cleanup;
        }


        RequestBody->enc_authorization_data = EncAuthData;
        RequestBody->bit_mask |= enc_authorization_data_present;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGS_REQ;


    KerbErr = KerbPackKdcRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Get the ticket.
    //

    OutputMessage.Buffer = NULL;
    OutputMessage.BufferSize = 0;
    KerbErr = (KERBERR) KerbCallKdc(
                            hBinding,
                            &InputMessage,
                            &OutputMessage
                            );


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                &Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &Reply->encrypted_part,
                &pkrTGTReply->session_key,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    sc = CheckPAData( pkrReply->kSessionKey, pkdReply, GETAS );
    if (FAILED(sc))
    {
        printf("Problem with PAData returned: 0x%X\n", sc );
        return(1);
    }
#endif

    *pktTicket = Reply->ticket;

Cleanup:

    if (EncAuthData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncAuthData.cipher_text.value);
    }
    return(KerbErr);
}


KERBERR
FooGetPAC(
    PVOID hBinding,
    LPWSTR pwzUserName,
    LPWSTR pwzUserRealm,
    PKERB_TICKET PrivSvrTicket,
    PKERB_ENCRYPTED_KDC_REPLY PrivSvrReply,
    PULONG AuthDataSize,
    PUCHAR * PackedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    KERB_MESSAGE_BUFFER RequestMessage;
    KERB_MESSAGE_BUFFER ReplyMessage;
    PKERB_ENCRYPTED_DATA EncryptedPacMessage = NULL;

    ReplyMessage.Buffer = NULL;
    ReplyMessage.BufferSize = 0;

    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &PrivSvrReply->session_key,
                6,                              // nonce
                PrivSvrTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request for PAC: 0x%x\n",KerbErr);
        goto Cleanup;
    }

#ifdef notdef
    KerbErr = (KERBERR) GetPAC(
                hBinding,
                &RequestMessage,
                &ReplyMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to get pac : 0x%x\n",KerbErr);
        goto Cleanup;
    }
#endif
    //
    // Now decode pac
    //

    //
    // First unpack message into an encrypted data structure
    //

    KerbErr = KerbUnpackEncryptedData(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                &EncryptedPacMessage
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack enc pac data: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Now decrypt into a packed authorization data
    //

    *PackedAuthData = (PUCHAR) MIDL_user_allocate(EncryptedPacMessage->cipher_text.length);
    if (*PackedAuthData == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbDecryptData(
                EncryptedPacMessage,
                &PrivSvrReply->session_key,
                AuthDataSize,
                *PackedAuthData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to decrypt pac auth data: 0x%x\n",KerbErr);
        goto Cleanup;
    }


Cleanup:
    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
    }
    if (EncryptedPacMessage != NULL)
    {
        MIDL_user_free(EncryptedPacMessage);
    }
    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
    }
    return(KerbErr);

}


KERBERR
FooCheckTicket(
    LPWSTR pwzUserName,
    LPWSTR pwzUserRealm,
    LPWSTR pwzServiceName,
    LPWSTR pwzServicePassword,
    PKERB_TICKET ServiceTicket,
    PKERB_ENCRYPTED_KDC_REPLY ServiceReply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING UserName;
    UNICODE_STRING UserRealm;
    UNICODE_STRING ServiceName;
    UNICODE_STRING ServicePassword;
    ULONG AuthDataSize;
    ULONG ApRequestSize;
    PUCHAR ApRequestMessage = NULL;
    PKERB_AP_REQUEST ApRequest = NULL;
    KERB_ENCRYPTION_KEY  ServiceKey;
    LARGE_INTEGER tsFudgeFactor;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    BOOLEAN UseSubKey;

    tsFudgeFactor.QuadPart = 300 * (LONGLONG) 10000000;
    CAuthenticatorList Authenticators( tsFudgeFactor );


    RtlInitUnicodeString(
        &UserName,
        pwzUserName
        );
    RtlInitUnicodeString(
        &UserRealm,
        pwzUserRealm
        );

    RtlInitUnicodeString(
        &ServiceName,
        pwzServiceName
        );

    RtlInitUnicodeString(
        &ServicePassword,
        pwzServicePassword
        );

    KerbErr = KerbHashPassword(
                &ServicePassword,
                KERB_ETYPE_RC4_MD4,
                &ServiceKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbCreateApRequest(
                &UserName,
                &UserRealm,
                &ServiceReply->session_key,
                7,                              // nonce
                ServiceTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                &ApRequestSize,
                &ApRequestMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request for PAC: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackApRequest(
                ApRequestMessage,
                ApRequestSize,
                &ApRequest
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack ap request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbCheckTicket(
                &ApRequest->ticket,
                &ApRequest->authenticator,
                &ServiceKey,
                Authenticators,
                &tsFudgeFactor,
                &ServiceName,
                &EncryptPart,
                &Authenticator,
                &SessionKey,
                &UseSubKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to check ticket: 0x%x\n",KerbErr);
        goto Cleanup;
    }

Cleanup:
    if (ApRequest != NULL)
    {
        MIDL_user_free(ApRequest);
    }
    KerbFreeTicket(EncryptPart);
    KerbFreeAuthenticator(Authenticator);
    if (ApRequestMessage != NULL)
    {
        MIDL_user_free(ApRequestMessage);
    }
    return(KerbErr);

}

int
TicketTests()
{
    int ret = 0;

    ULONG cbAuthen = 0;
    NTSTATUS   sc;
    WCHAR ServiceName[100];
    UNICODE_STRING KdcName;
    PVOID SocketHandle = NULL;

    wcscpy(
        ServiceName,
        pwzRealm
        );
    wcscat(ServiceName,L"\\");
    wcscat(ServiceName,pwzUserName);

    sc = KerbInitializeSockets(
            0x0101,
            5
            );
    if (!NT_SUCCESS(sc))
    {
        printf("Failed to initialize sockets: 0x%x\n",sc);
        return((int) sc);
    }

    RtlInitUnicodeString(
        &KdcName,
        pwzAddress
        );

    sc = KerbBindSocket(
            &KdcName,
            &SocketHandle
            );

    if (!NT_SUCCESS(sc))
    {
        printf("KerbSocketBind failed: %0x%x\n",sc);
        return((int) sc);
    }
    __try
    {
        KERB_TICKET         ktASTicket;
        KERB_TICKET         ktPSTicket;
        KERB_TICKET         ktCTGTicket;
        KERB_TICKET         ktServTicket;
        KERB_TICKET         ktRenewServTicket;
        PKERB_ENCRYPTED_KDC_REPLY        pkrASReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrPSReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrCTGTReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrServReply = NULL;
        PKERB_ENCRYPTED_KDC_REPLY        pkrRenewServReply = NULL;
        ULONG AuthDataSize = 0;
        PUCHAR AuthData = NULL;
        LARGE_INTEGER tsPing;
        KERBERR KerbErr;
        ULONG               PingFlags = 0;

        handle_t hKDC = BindTo( KDC, pwzTransport, pwzEndPoint, pwzAddress );
        if (hKDC == 0 || hKDC == (handle_t)-1 )
        {
            printf("Error binding, quitting.\n" );
            ret = (1);
            goto Done;
        }

        sc = KDCPing( hKDC, &PingFlags, &tsPing );
        if (sc != 0)
        {
            printf("Error %d (0x%X) from KdcPing()\n", sc );
            ret = (1);
            goto Done;
        }

        if (fGetAS)
        {
            KerbErr = FooGetASTicket(
                            SocketHandle,
                            pwzUserName,
                            pwzRealm,
                            pwzKDC,
                            pwzUserPasswd,
                            pwzClientAddress,
                            &ktASTicket,
                            &pkrASReply );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Done;
            }

            if (fPrintTickets)
            {
                printf("Initial TGT:\n" );
                PrintTicket( &ktASTicket, pwzKdcPasswd );
            }
        }

        if (fGetTGS)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   pwzPrivSvr,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   0,
                                   NULL,              // no authorization
                                   FALSE,               // don't renew
                                   &ktPSTicket,      // ppktTicket
                                   &pkrPSReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Done;
            }

            if (fPrintTickets)
            {
                printf("Ticket to PS:\n" );
                PrintTicket( &ktPSTicket, pwzPSPasswd );
            }
        }
#ifdef notdef
        if (fGetPAC)
        {

            //
            // Get the PAC.
            //

            KerbErr = FooGetPAC(
                        SocketHandle,
                        pwzUserName,
                        pwzRealm,
                        &ktPSTicket,
                        pkrPSReply,
                        &AuthDataSize,
                        &AuthData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("FooGetPAC() == 0x%X\n", KerbErr );
                goto Done;
            }
        }


        if (fGetCTGT)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   pwzKDC,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   AuthDataSize,
                                   AuthData,
                                   FALSE,               // don't renew
                                   &ktCTGTicket,      // ppktTicket
                                   &pkrCTGTReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to get TGT: 0x%x\n",KerbErr);
                goto Done;
            }

        }
#endif // notdef

        if (fGetServiceTkt)  {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   ServiceName,        // pwzServiceName
                                   &ktASTicket,       // ktTGTicket
                                   pkrASReply,        // krTGTReply
                                   0,
                                   NULL,                // no auth data
                                   FALSE,               // don't renew
                                   &ktServTicket,      // ppktTicket
                                   &pkrServReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Faield to get ticket to service: 0x%x\n",KerbErr);
                goto Done;
            }

            //
            // Now check the ticket.
            //

            KerbErr = FooCheckTicket(
                        pwzUserName,
                        pwzRealm,
                        ServiceName,            // service name
                        pwzUserPasswd,  /// service password
                        &ktServTicket,
                        pkrServReply
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed tocheck service ticket: 0x%x\n",KerbErr);
                goto Done;
            }

        }
        if (fRenewSvc)
        {
            KerbErr = FooGetTGSTicket( SocketHandle,              // hBinding
                                   pwzUserName,       // pwzUserName
                                   pwzRealm,          // pwzUserRealm
                                   ServiceName,        // pwzServiceName
                                   &ktServTicket,       // ktTGTicket
                                   pkrServReply,        // krTGTReply
                                   0,
                                   NULL,                // no auth data
                                   TRUE,
                                   &ktRenewServTicket,      // ppktTicket
                                   &pkrRenewServReply );      // pkrReply
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Faield to get ticket to service: 0x%x\n",KerbErr);
                goto Done;
            }

            //
            // Now check the ticket.
            //

            KerbErr = FooCheckTicket(
                        pwzUserName,
                        pwzRealm,
                        ServiceName,            // service name
                        pwzUserPasswd,  /// service password
                        &ktServTicket,
                        pkrServReply
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed tocheck service ticket: 0x%x\n",KerbErr);
                goto Done;
            }
        }

Done:
        ;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        printf("Exception 0x%x (%d) in ticktest.\n", GetExceptionCode(), GetExceptionCode() );
        ret = 5;
    }

    if (SocketHandle != NULL)
    {
        closesocket((SOCKET) SocketHandle);
    }
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\server\utest\trantest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transtest.cxx
//
//  Contents:   KDC transit field compression testing code
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------


#include <secpch2.hxx>
#pragma hdrstop

#include "transit.hxx"


void
AddRealm(   PSECURITY_STRING  pssTransit,
            PWCHAR            pwzPrinRealm,
            PWCHAR            pwzThisRealm,
            PWCHAR          pwzNewRealm )
{
    printf("Starting tr field:\t%wZ\nAuth. Realm:\t%ws\n"
           "ThisRealm:\t%ws\nNew Realm:\t%ws\n", pssTransit, pwzPrinRealm,
           pwzThisRealm, pwzNewRealm );

    //CTransitData    tdFoo;
    CNodeList       nlRealms;
    SECURITY_STRING ssTemp;

    //ExpandTransitedField( *pssTransit, pwzPrinRealm, pwzNewRealm, &tdFoo );
    //tdFoo.AddRealm( pwzNewRealm );
    //ssTemp = CompressTransitedField( tdFoo );

    ssTemp = AddToTransitedField( *pssTransit, pwzPrinRealm,
                                  pwzNewRealm, pwzThisRealm, &nlRealms );

    printf("New tr field: %wZ\n\n", &ssTemp );
    SRtlFreeString( pssTransit );
    *pssTransit = ssTemp;
}


int
TransitTest()
{
    printf("Testing transit field compression...\n");
    SECURITY_STRING ssTransit;
    PWCHAR pwAuth;
    PWCHAR pwNew;
    PWCHAR pwThis;

#if 0
    // test 1.
    // No links.

    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\wpg";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg";
    pwThis = L"org:";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
        " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ' (should be ',')\n\n\n",
            &ssTransit);
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 2
    // Link between org:\wpg\sys and org:\fin
    //
    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );


    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
           " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ'\n", &ssTransit );
    printf("Should be ',org:\\wpg\\sys,org:\\fin,'");
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 2b -- reverse
    // Link between org:\fin and org:\fin\apps\word
    //
    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg\\sys\\cairo\\sphinx\\dev";
    pwNew  = L"org:\\wpg\\sys\\cairo\\sphinx";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg\\sys";
    pwThis = L"org:\\wpg";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\wpg";
    pwThis = L"org:";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:";
    pwThis = L"org:\\fin";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    pwNew  = L"org:\\fin";
    pwThis = L"org:\\fin\\apps\\word";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word";
    pwThis = L"org:\\fin\\apps\\word\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    pwNew  = L"org:\\fin\\apps\\word\\dev";
    pwThis = L"org:\\fin\\apps\\word\\dev\\foo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );
    printf("Resut of going from 'org:\\wpg\\sys\\cairo\\sphinx\\dev'"
        " to 'org:\\fin\\apps\\word\\dev\\foo' is: '%wZ' (should be ',')\n\n\n",
            &ssTransit);
    SRtlFreeString( &ssTransit );
#endif

#if 1
    // test 3.
    // Link outside the normal path.
    // org:\wpg -> org:\fin\apps -> org:\wpg\sys\cairo -> org:\wpg\sys\cairo\dev

    SRtlNewString( &ssTransit, L"" );
    pwAuth = L"org:\\wpg";
    pwNew  = L"org:\\fin\\apps";
    pwThis = L"org:\\wpg\\sys\\cairo";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    pwNew  = L"org:\\wpg\\sys\\cairo";
    pwThis = L"org:\\wpg\\sys\\cairo\\dev";
    AddRealm( &ssTransit, pwAuth, pwThis, pwNew );

    printf("Resut of traversing "
            "'org:\\wpg,org:\\fin\\apps,org:\\wpg\\sys\\cairo,org:\\wpg\\sys\\cairo\\dev'"
            "is: '%wZ'\n", &ssTransit);
    printf("Should be 'org:\\fin\\apps,org:wpg\\sys\\cairo,'" );
    SRtlFreeString( &ssTransit );
#endif

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\kernel\kerbktst.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#include <ntos.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_KERBEROS
#include <security.h>
#include <zwapi.h>

BOOLEAN QuietMode = FALSE;
ULONG DoTests = FALSE;


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    DbgPrint("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            DbgPrint("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            DbgPrint("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            DbgPrint("  %s\n", TextBuffer);
        }

    }

    DbgPrint("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    DbgPrint( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        DbgPrint( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DbgPrint( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    ULONG NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    DbgPrint( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {

    case SEC_E_NO_SPM:
        DbgPrint( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        DbgPrint( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        DbgPrint( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        DbgPrint( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        DbgPrint( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        DbgPrint( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        DbgPrint( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        DbgPrint( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        DbgPrint( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        DbgPrint( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        DbgPrint( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        DbgPrint( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        DbgPrint( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        DbgPrint( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        DbgPrint( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        DbgPrint( " SEC_E_NOT_SUPPORTED" ); break;


    }

    DbgPrint( "\n" );
}

//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SspAlloc(ULONG Flags, ULONG cbMemory)
{
    NTSTATUS scRet;
    PVOID  Buffer = NULL;
    scRet = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &Buffer,
                0L,
                &cbMemory,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(scRet))
    {
        return(NULL);
    }
    return(Buffer);
    UNREFERENCED_PARAMETER(Flags);
}



//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SspFree(PVOID pvMemory)
{
    ULONG Length = 0;

    (VOID) ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &pvMemory,
                 &Length,
                 MEM_RELEASE
                 );
}




VOID
TestSspRoutine(
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ServerCredHandle;
    CredHandle ClientCredentialHandle;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR TargetName = NULL;
    UNICODE_STRING TargetString;
    UNICODE_STRING PackageName;


    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Names ContextNames;
    SecPkgContext_Lifespan ContextLifespan;
    PSecPkgCredentials_Names CredNames;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    UCHAR    bDataBuffer[20];
    UCHAR    bSigBuffer[100];

    //
    // Allow tests to be disabled
    //


    if (!DoTests)
    {
        return;
    }

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    DomainName = L"makalu";
    UserName = L"mikesw";


    PackageName.Buffer = (LPWSTR) SspAlloc(0,100);
    if (PackageName.Buffer == NULL)
    {
        return;
    }

    wcscpy(
        PackageName.Buffer,
        L"Kerberos"
        );
    RtlInitUnicodeString(
        &PackageName,
        PackageName.Buffer
        );
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    DbgPrint( "PackageCount: %ld\n", PackageCount );
    for (Index = 0; Index < PackageCount ; Index++ )
    {
        DbgPrint( "Package %d:\n",Index);
        DbgPrint( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
        DbgPrint( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
            PackageInfo[Index].fCapabilities,
            PackageInfo[Index].wVersion,
            PackageInfo[Index].wRPCID,
            PackageInfo[Index].cbMaxToken );


    }


#ifdef notdef
    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( &PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        DbgPrint( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        DbgPrint( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }

    FreeContextBuffer(PackageInfo);
#endif

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    &PackageName,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        DbgPrint( "ServerCredHandle: 0x%lx 0x%lx   ",
                ServerCredHandle.dwLower, ServerCredHandle.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Acquire a credential handle for the client side
    //



    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    &PackageName,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ClientCredentialHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        DbgPrint( "ClientCredentialHandle: 0x%lx 0x%lx   ",
                ClientCredentialHandle.dwLower, ClientCredentialHandle.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Query some cred attributes
    //

    CredNames = SspAlloc(0, sizeof(*CredNames));
    if (CredNames == NULL)
    {
        DbgPrint("Failed to allocate CredNames\n");
        return;
    }

    SecStatus = QueryCredentialsAttributes(
                    &ClientCredentialHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryCredentialsAttributes (Client) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Client credential names: %ws\n",CredNames->sUserName);
    FreeContextBuffer(CredNames->sUserName);

    //
    // Do the same for the client
    //

    SecStatus = QueryCredentialsAttributes(
                    &ServerCredHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryCredentialsAttributes (Server) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Server credential names: %ws\n",CredNames->sUserName);
    FreeContextBuffer(CredNames->sUserName);

    SspFree(CredNames);

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = SspAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        DbgPrint( "Allocate NegotiateMessage failed\n" );
        return;
    }

    ClientFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_MUTUAL_AUTH; //  | ISC_REQ_USE_DCE_STYLE  | ISC_REQ_DATAGRAM; // | ISC_REQ_DELEGATE;

    TargetName = (LPWSTR) SspAlloc(0,100);
    if (TargetName == NULL)
    {
        return;
    }

    wcscpy(
        TargetName,
        DomainName
        );
    wcscat(
        TargetName,
        L"\\"
        );
    wcscat(
        TargetName,
        UserName
        );

    RtlInitUnicodeString(
        &TargetString,
        TargetName
        );

    InitStatus = InitializeSecurityContext(
                    &ClientCredentialHandle,
                    NULL,               // No Client context yet
                    &TargetString,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            DbgPrint( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        DbgPrint( "\n\nNegotiate Message:\n" );

        DbgPrint( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

//        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = SspAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        DbgPrint( "Allocate ChallengeMessage failed\n");
        return;
    }
    ServerFlags = 0;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            DbgPrint( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        DbgPrint( "\n\nChallenge Message:\n" );

        DbgPrint( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

//        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }




    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = SspAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            DbgPrint( "Allocate AuthenticateMessage failed: \n" );
            return;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        NULL,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            DbgPrint( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            DbgPrint( "\n\nAuthenticate Message:\n" );

            DbgPrint( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );

//            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            0,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( SecStatus != STATUS_SUCCESS ) {
                DbgPrint( "AcceptSecurityContext (Challenge): " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                DbgPrint( "\n\nFinal Authentication:\n" );

                DbgPrint( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                DbgPrint(" \n" );
            }
        }

    }



    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    &ContextNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "QueryContextAttributes (Server) (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    DbgPrint("Server Context names: %ws\n",ContextNames.sUserName);
    FreeContextBuffer(ContextNames.sUserName);


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );
    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    NtClose(Token);

#endif
#ifdef notdef
    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        DbgPrint("\n Signature: \n");
//        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        DbgPrint("\n Signature: \n");
//        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        DbgPrint( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &ServerCredHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &ClientCredentialHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        DbgPrint( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if (PackageInfo != NULL)
    {
        FreeContextBuffer(PackageInfo);
    }

    if (PackageName.Buffer != NULL)
    {
        SspFree(PackageName.Buffer);
    }
    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) SspFree( AuthenticateBuffer.pvBuffer );
    }

    if (TargetName != NULL)
    {
        SspFree(TargetName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\klin\klin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsid.c
//
//--------------------------------------------------------------------------

#pragma hdrstop

				   

#include <stdlib.h>
#include <stdio.h>				   
#include <fileno.h>



struct namepair {
    int key;
    char * name;
};

struct namepair dirtbl [] = {
    {DIRNO_CLIENT2, "client2"},
	{DIRNO_COMMON2, "common2"},
    {DIRNO_KERNEL, "kernel"},
    {DIRNO_RTL, "rtl"},
    {DIRNO_SERVER, "server"},
    {0,0}
};

// Please add constants to this table alphabetically by constant, or
// we'll never find the ones we've missed.

struct namepair filetbl [] = {
    {FILENO_BNDCACHE,"bndcache.cxx"},
    {FILENO_CREDAPI,"credapi.cxx"},
    {FILENO_CREDMGR,"credmgr.cxx"},
    {FILENO_CTXTAPI,"ctxtapi.cxx"},
    {FILENO_CTXTMGR,"ctxtmgr.cxx"},
    {FILENO_GSSUTIL,"gssutil.cxx"},
    {FILENO_KERBEROS,"kerberos.cxx"},
    {FILENO_KERBLIST,"kerblist.cxx"},
    {FILENO_KERBPASS,"kerbpass.cxx"},
    {FILENO_KERBTICK,"kerbtick.cxx"},
    {FILENO_KERBWOW,"kerbwow.cxx"},
    {FILENO_KRBEVENT,"krbevent.cxx"},
    {FILENO_KRBTOKEN,"krbtoken.cxx"},
    {FILENO_LOGONAPI,"logonapi.cxx"},
    {FILENO_MISCAPI,"miscapi.cxx"},
    {FILENO_MITUTIL,"mitutil.cxx"},
    {FILENO_PKAUTH,"pkauth.cxx"},
    {FILENO_PROXYAPI,"proxyapi.cxx"},
    {FILENO_RPCUTIL,"rpcutil.cxx"},
    {FILENO_SIDCACHE,"sidcache.cxx"},
    {FILENO_TIMESYNC,"timesync.cxx"},
    {FILENO_TKTCACHE,"tktcache.cxx"},
    {FILENO_TKTLOGON,"tktlogon.cxx"},
    {FILENO_USERAPI,"userapi.cxx"},
    {FILENO_USERLIST,"userlist.cxx"}, // Common2
    {FILENO_AUTHEN,"authen.cxx"},
    {FILENO_CRYPT,"crypt.c"},
    {FILENO_KEYGEN,"keygen.c"},
    {FILENO_KRB5,"krb5.c"},
    {FILENO_NAMES,"names.c"},
    {FILENO_PASSWD,"passwd.c"},
    {FILENO_RESTRICT,"restrict.c"},
    {FILENO_SOCKETS,"sockets.cxx"},
    {FILENO_TICKETS,"tickets.cxx"}, // Kernel
    {FILENO_CPGSSUTL,"cpgssutl.cxx"},
    {FILENO_CTXTMGR2,"ctxtmgr.cxx"},
    {FILENO_KERBLIST2,"kerblist.cxx"},
    {FILENO_KRNLAPI,"krnlapi.cxx"}, // RTL
    {FILENO_AUTHDATA,"authdata.cxx"}, 
    {FILENO_CRACKPAC,"crackpac.cxx"},
    {FILENO_CRED,"cred.cxx"},
    {FILENO_CREDLIST,"credlist.cxx"},
    {FILENO_CREDLOCK,"credlock.cxx"},
    {FILENO_DBUTIL,"dbutil.cxx"},
    {FILENO_DBOPEN,"dbopen.cxx"},
    {FILENO_DOMCACHE,"domcache.cxx"},
    {FILENO_FILTER,"filter.cxx"},
    {FILENO_MAPERR,"maperr.cxx"},
    {FILENO_MAPSECER,"mapsecer.cxx"},
    {FILENO_MISCID,"miscid.cxx"},
    {FILENO_PAC,"pac.cxx"},
    {FILENO_PAC2, "pac2.cxx"},
    {FILENO_PARMCHK, "parmchk.cxx"},
    {FILENO_REG, "reg.cxx"},
    {FILENO_SECSTR,"secstr.cxx"},
    {FILENO_SERVICES,"services.cxx"},
    {FILENO_STRING,"string.cxx"},
    {FILENO_TIMESERV,"timeserv.cxx"},
    {FILENO_TOKENUTL,"tokenutl.cxx"},
    {FILENO_TRNSPORT,"trnsport.cxx"}, // Server
    {FILENO_DEBUG,"debug.cxx"},
    {FILENO_DGUTIL,"dgutil.cxx"},
    {FILENO_EVENTS,"events.cxx"},
    {FILENO_GETAS,"getas.cxx"},
    {FILENO_GETTGS,"gettgs.cxx"},
    {FILENO_KDC,"kdc.cxx"},
    {FILENO_KDCTRACE,"kdctrace.cxx"},
    {FILENO_KPASSWD,"kpasswd.cxx"},
    {FILENO_NOTIFY2,"notify2.cxx"},
    {FILENO_SRVPAC,"srvpac.cxx"},
    {FILENO_PKSERV,"pkserv.cxx"},
    {FILENO_REFER,"refer.cxx"},
    {FILENO_RPCIF,"rpcif.cxx"},
    {FILENO_SECDATA,"secdata.cxx"},
    {FILENO_SOCKUTIL,"sockutil.cxx"},
    {FILENO_TKTUTIL,"tktutil.cxx"},
    {FILENO_TRANSIT,"transit.cxx"},
	{0, 0}
};




void __cdecl main(int argc, char ** argv)
{
    int line;
    int fileno;
    int dirno;
    int dirfile;
    int i;
    char * stopstring;
    char * dirname;
    char * filename;

    dirname = filename = "huh?";

    if (argc != 2) {
        printf("usage: %s id\n", argv[0]);
        exit(1);
    }

    dirfile = strtol(argv[1], &stopstring, 16);
    if (dirfile == 0) {
        printf("I can't make sense of %s\n", argv[1]);
        exit(1);
    }

    line = dirfile & 0x0000ffff;
    dirno = (dirfile & 0xff000000) >> 24;
    fileno = (dirfile & 0x00ff0000) >> 16;
    dirfile >>= 16;

    for (i=0; dirtbl[i].name; i++) {
        if (dirtbl[i].key == dirno << 8) {
            dirname = dirtbl[i].name;
            break;
        }
    }
    for (i=0; filetbl[i].name; i++) {
        if (filetbl[i].key == dirfile) {
            filename = filetbl[i].name;
            break;
        }
    }

    printf("dir %u, file %u (%s\\%s), line %u\n", dirno, fileno, dirname,
           filename, line);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\logon\sclogon.cxx ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
}
#include <wchar.h>
extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>



BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
#define MAX_RECURSION_DEPTH 1


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = (PBYTE) Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

VOID
TestGetKdcCert(
    IN LPWSTR ServiceName,
    IN LPWSTR ContainerName,
    IN LPWSTR CaLocation,
    IN LPWSTR CaName
    )
{
    PCCERT_CONTEXT CertContext = NULL;
    DWORD Status = 0;
    WCHAR UsageOid[100];
    WCHAR ComputerName[100];
    ULONG ComputerNameLength = 100;
    LPSTR UsageString;
    CERT_ENHKEY_USAGE KeyUsage;
    CRYPTUI_WIZ_CERT_REQUEST_INFO CertInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW PvkNew;

    RtlZeroMemory(
        &CertInfo,
        sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
        );

    RtlZeroMemory(
        &PvkNew,
        sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
        );

    GetComputerName(
        ComputerName,
        &ComputerNameLength
        );

    CertInfo.dwSize = sizeof(CertInfo);
    CertInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
    CertInfo.pwszMachineName = ComputerName;            // local computer
    CertInfo.pwszAccountName = NULL;            // ServiceName;
    CertInfo.pAuthentication = NULL;            // MBZ
    CertInfo.pCertRequestString = NULL;         // ??
    CertInfo.pwszDesStore = ContainerName;
    CertInfo.dwCertOpenStoreFlag = CERT_SYSTEM_STORE_SERVICES;
    CertInfo.pRenewCertContext = NULL;          // we aren't renewing
    CertInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
                                                // generate new key
    CertInfo.pPvkNew = &PvkNew;
    PvkNew.dwSize = sizeof(PvkNew);
    PvkNew.pKeyProvInfo = NULL;                 // use default provider
    PvkNew.dwGenKeyFlags = 0; // CRYPT_MACHINE_KEYSET;                   // no flags
    CertInfo.pwszCALocation = CaLocation;           // ignore for no-ui enrollment
    CertInfo.pwszCAName = CaName;
    CertInfo.dwPostOption = 0; // CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP;
    KeyUsage.cUsageIdentifier = 1;
    UsageString = szOID_PKIX_KP_SERVER_AUTH;
    KeyUsage.rgpszUsageIdentifier = &UsageString;
    CertInfo.pKeyUsage = &KeyUsage;

    CertInfo.pwszFriendlyName = NULL;           // friendly name is optional
    CertInfo.pwszDescription = NULL;            // description is optional

    //
    // Request a certificate
    //

    if (!CryptUIWizCertRequest(
            CRYPTUI_WIZ_NO_UI,
            NULL,                       // no window
            NULL,                       // no title
            &CertInfo,
            &CertContext,
            &Status
            ))
    {
        printf("CryptUIWizCertRequest failed: 0x%x\n",GetLastError());
        return;
    }
    //
    // Check the real status
    //

    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED)
    {
        printf("Cert request succeeded!\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR)
    {
        printf("Cert request failed: request error\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED)
    {
        printf("Cert request denied\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY)
    {
        printf("Cert request issued seperately\n");
    }
    if (Status == CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION)
    {
        printf("Cert request under submission\n");
    }

    return;
}

VOID
TestScLogonRoutine(
    IN ULONG Count,
    IN LPSTR Pin
    )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_SMART_CARD_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    PCCERT_CONTEXT CertContext = NULL;

    printf("Waiting for smart card insertion\n");

    //
    // First register for insertion notification
    //

    Status = ScHelperInitialize();
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to initialize schelper: 0x%x\n",Status);
        return;
    }

    ScHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ScHandle == NULL)
    {
        printf("Failed to create event: %d\n",GetLastError());
        return;
    }

    Status = ScHelperWatchForSas(
                ScHandle,
                &ScLogonInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to watch for SAS: 0x%x\n",Status);
        return;
    }

    WaitResult = WaitForSingleObject(ScHandle,INFINITE);
    if (WaitResult != WAIT_OBJECT_0)
    {
        printf("Failed to wait for single object: %d\n",GetLastError());
        return;
    }

    //
    // We should now have logon info.
    //

    if (ScLogonInfo == NULL)
    {
        printf("Failed to get logon info!\n");
        return;
    }

    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;

    Status = ScHelperInitializeContext(
                ScLogonInfo,
                ScLogonInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to initialize context: 0x%x\n",Status);
        return;
    }

    ScHelperRelease(ScLogonInfo);

    RtlInitString(
        &PinString,
        Pin
        );


    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;

    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = KerbSmartCardLogon;


    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);

    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    for (Index = 0; Index < Count ; Index++ )
    {
        printf("Logging on with PIN  %s\n",Pin);

        Status = LsaLogonUser(
                    LogonHandle,
                    &Name,
                    Interactive,
                    PackageId,
                    LogonInfo,
                    LogonInfoSize,
                    NULL,           // no token groups
                    &SourceContext,
                    (PVOID *) &Profile,
                    &ProfileSize,
                    &LogonId,
                    &TokenHandle,
                    &Quotas,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("lsalogonuser failed: 0x%x\n",Status);
            return;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            return;
        }

        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        printf("Username = %ws\n",UserNameString);
        RevertToSelf();
        NtClose(TokenHandle);

        if (Profile->Profile.MessageType = MsV1_0SmartCardProfile)
        {
            CertContext = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            Profile->CertificateData,
                            Profile->CertificateSize
                            );
            if (CertContext == NULL)
            {
                printf("Failed to create cert context: 0x%x\n",GetLastError());
            }
            else
            {
                printf("Built certificate context\n");
                CertFreeCertificateContext( CertContext );
                CertContext = NULL;
            }
        }
        else
        {
            printf("No certificate in profile\n");
        }

        

        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

    }

}


VOID
PrintKdcName(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

VOID
TestCallPackageRoutine(
    IN LPWSTR Function
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    KERB_DEBUG_REQUEST DebugRequest;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    ULONG Index;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    if (_wcsicmp(Function,L"bp") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_BREAKPOINT;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsicmp(Function,L"tickets")  == 0)
    {
        CacheRequest.MessageType = KerbQueryTicketCacheMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheResponse,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached Tickets:\n");
            for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ )
            {
                printf("\tServer: %wZ\n",&CacheResponse->Tickets[Index].ServerName);
                PrintTime("\t\tEnd Time: ",CacheResponse->Tickets[Index].EndTime);
                PrintTime("\t\tRenew Time: ",CacheResponse->Tickets[Index].RenewTime);

            }
        }


    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL)
    {
        LsaFreeReturnBuffer(CacheResponse);
    }
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;
    LPSTR Pin;
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];




    enum {
        NoAction,
#define LOGON_PARAM "/Logon"
#define LOGON_PARAM2 "/Logon:"
        TestLogon,
#define PACKAGE_PARAM "/callpackage:"
        TestPackage,
#define CERT_PARAM "/getcert"
        GetCert,
    } Action = NoAction;





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //

        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Iterations = 1;
            if ( _strnicmp( argument, LOGON_PARAM2, sizeof(LOGON_PARAM2)-1 ) == 0 ) {
                sscanf(&argument[sizeof(LOGON_PARAM2)-1], "%d",&Iterations);
            }


            Action = TestLogon;

            if (argc < i + 1)
            {
                goto Usage;
            }
            Pin = argv[++i];
        } else if ( _strnicmp( argument, PACKAGE_PARAM, sizeof(PACKAGE_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(PACKAGE_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestPackage;
        } else if ( _stricmp( argument, CERT_PARAM) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            if (argc < i + 4)
            {
                goto Usage;
            }

            mbstowcs(ServiceName,argv[++i],100);
            mbstowcs(ContainerName,argv[++i],100);
            mbstowcs(CaLocation,argv[++i],100);
            mbstowcs(CaName,argv[++i],100);

            Action = GetCert;
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }


    }

    //
    // Perform the action requested
    //

    switch ( Action ) {

    case TestPackage:
        TestCallPackageRoutine(PackageFunction);
        break;

    case TestLogon :
        TestScLogonRoutine(
            Iterations,
            Pin
            );
        break;
    case GetCert:
        TestGetKdcCert(
            ServiceName,
            ContainerName,
            CaLocation,
            CaName
            );

    }
    return 0;
Usage:
    printf("%s /logon username password [domainname]\n",argv[0]);
    printf("%s /testssp [/package:pacakgename] [/target:targetname] [/user:username] [/serveruser:username]\n",
        argv[0]);
    printf("%s /getcert service-name container-name ca-location ca-name\n",
        argv[0]);
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\kdcdiag\godmode.cxx ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}



BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
//  RevertToSelf() must be called to restore original token  
//
//
DWORD
RunAsLocalSystem()
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbrgPIDs / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed! ", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
                hPToken,
                DACL_SECURITY_INFORMATION,
                pSD
                )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

    if (!ImpersonateLoggedOnUser(hDupToken))  {              
        dwErr = GetLastError();
        TERRORVAL(L"ImpersonateLoggedOnUser failed!", dwErr);
        goto ret;
    }   

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}



                    


//
//  LogoffAndRevert()
//
//  This function simply RevertsToSelf(), and then closes the logon token
//
//  Params:
//
//  hToken      -   Logon token from LogonUserW
//
//  Returns:
//  
//  dwErr from last failure, S_OK otherwise.
//
DWORD
LogoffAndRevert(HANDLE                  hToken,
                PSECURITY_DESCRIPTOR    pSD)
{
    
    HANDLE  hThread = INVALID_HANDLE_VALUE;
    DWORD   dwErr = 0;

    //
    //  Verify impersonation, and revert
    //
    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hThread
            )) {

        CloseHandle(hThread);
        RevertToSelf();
    }

    /*if (!SetKernelObjectSecurity(
        hToken,
        DACL_SECURITY_INFORMATION,
        pSD
        )) {
        dwErr = GetLastError();
        TCOMMENT(L"Security was not reset on kernel object!");
    }*/

    return dwErr;
}




 









extern "C"
int __cdecl wmain(int carg, WCHAR* rgwszarg[])
{

    LPWSTR          wszUPN = NULL;
    LPWSTR          wszOldPwd = NULL;
    LPWSTR          wszNewPwd = NULL;

    DATA_BLOB*      arData = NULL;
    DATA_BLOB*      arCipherData = NULL;

    INT             i = 1;
    DWORD           dwErr = S_OK;
    DWORD           dwCleanupErrors = S_OK;
    HANDLE          hToken = INVALID_HANDLE_VALUE;
    HANDLE          hLocalSystem = NULL;
    HANDLE          hProfile = INVALID_HANDLE_VALUE;
    BOOL            fTest = TRUE;

    PSECURITY_DESCRIPTOR    pSD = NULL;

    while (i < carg)  {

        if (!_wcsicmp(rgwszarg[i], L"-?")) {

            Usage();
            return 0;
        }

        if (!_wcsicmp(rgwszarg[i], L"-reset")) {

            ResetTestUser();
            return 0;

        }

        if (!_wcsicmp(rgwszarg[i], L"-create")) {

            CreateTestUser();
            return 0;

        }


        if (!_wcsicmp(rgwszarg[i], L"-user")) {

            if (carg < 4) {
                Usage();
            }

            fTest = TRUE;
        }

       
        i++;

    }

    //
    //  Allocate raw data storage, and fill values
    //
    arData = (DATA_BLOB*) MyAlloc(MAX_BLOBS * sizeof(DATA_BLOB));
    if (arData == NULL) {

        TERRORVAL(L"Alloc Failed!", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
 
    //
    //  Enable debug privilege
    //
    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (TCB) failed!");
        return E_FAIL;
    }


    //
    //  Run as local system
    //
    dwErr = GetLocalSystemToken(&hLocalSystem);
    if (NULL == hLocalSystem || dwErr != S_OK) {
        goto Ret;
    }

  
    dwErr = LogoffAndRevert(hToken, pSD);

    if (NULL != pSD) {
        MyFree(pSD);
        pSD = NULL;
    }
    
    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
        hToken = INVALID_HANDLE_VALUE;
    }


Ret:

    

    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }

    if (NULL != hLocalSystem) {
        RevertToSelf();
        CloseHandle(hLocalSystem);
    }

    if (arData != NULL)
        DataFree(arData, FALSE);

       return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\scbvt\log.cpp ===
//
//  log.cpp
//
//  Copyright (c) Microsoft Corp, 1997
//
//  This file contains the code necessary to log error messages to the event 
//  log of a remote machine (or a local machine, depending on the #defines
//  below).
//
//  Revision History:
//
//  Todds		11/13/97    Created
//  LarryWin	12/19/97	Modified to provide more error reporting
//

#include <windows.h>
#include <stdio.h>
#include <winnetwk.h>
#include "log.h"

#pragma warning( disable : 4244) // signed/unsigned mismatch

static BOOL g_IPCInit = FALSE;

// can be defined by calling program; if not defaults to #define in log.h
LPWSTR wszIPC_SHARE     = NULL;
LPWSTR wszTARGETMACHINE = NULL;

void SetEventMachine(LPWSTR* pSZ_IPC_SHARE)
{
    LPWSTR wszTemp = new wchar_t[80];

    wszIPC_SHARE = new wchar_t[100];
    wszTARGETMACHINE = new wchar_t[100];
    memset(wszTemp, 0, sizeof(wszTemp));
    memset(wszIPC_SHARE, 0, sizeof(wszIPC_SHARE));
    memset(wszTARGETMACHINE, 0, sizeof(wszTARGETMACHINE));

    wszIPC_SHARE     = *pSZ_IPC_SHARE;
    wcscpy(wszTARGETMACHINE, wszIPC_SHARE);
    
    wcscpy(wszTemp, L"\\\\");
    wcscat(wszTemp, wszTARGETMACHINE);

    wcscpy(wszTARGETMACHINE, wszTemp);
    wcscpy(wszIPC_SHARE, wszTemp);
    wcscat(wszIPC_SHARE, L"\\ipc$");

}

void Event(DWORD dwEventType,
		   LPWSTR wszErr,
		   DWORD dwErr)
{
	wprintf(L"%s", wszErr);

	if (!g_IPCInit)
		g_IPCInit = OpenIPCConnection();

    if (!g_IPCInit) return; // return if IPC connection not established

	ErrorToEventLog(
		    dwEventType,
			wszErr,
			dwErr
			);

}


//
//  OpenIPCConnection()
//
//  This function opens a \\larrywin1\ipc$ virtual connection to allow logging
//  to the event log of the remote machine.
//
//  Returns:
//  
//  True | False, depending on whether or not IPC connection established.
//
BOOL OpenIPCConnection()
{
	NETRESOURCE IPCConnection;
	DWORD	    dwRet;

    //
    // Set up Net Connection to \\todds7\ipc$
    //
    ZeroMemory(&IPCConnection, sizeof(NETRESOURCE));
    IPCConnection.dwType = RESOURCETYPE_ANY;
    IPCConnection.lpLocalName = NULL; // virtual connection
    if (wszIPC_SHARE != NULL) {
        IPCConnection.lpRemoteName = wszIPC_SHARE;
    } else {
        // get local machine name for share
        IPCConnection.lpRemoteName = SZ_IPC_SHARE;
    }
    IPCConnection.lpProvider = NULL; // use ntlm provider

	//
	//	Try 3 times to establish connection, otherwise  fail
    //
	for (DWORD dwTry = 0;((dwRet != NO_ERROR) && (dwTry < 3)) ; dwTry++)
	{
		dwRet = WNetAddConnection2(
					&IPCConnection,
					NULL,
					NULL,
					0
					);

    }

    if (dwRet != NO_ERROR)  {

        dwRet = GetLastError(); // For debugging
        return FALSE;
    }

    return TRUE;

}



BOOL ErrorToEventLog(DWORD dwEventType,
					 LPWSTR lpszMsg,
					 DWORD	dwErr)
{

	    WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];
        LPWSTR  lpszCRLF = L"\n";

        if (wszTARGETMACHINE != NULL) {
            hEventSource = RegisterEventSourceW(
                wszTARGETMACHINE, 
                SZ_TEST
                );
        } else {
            // get local machine name
            hEventSource = RegisterEventSourceW(
                SZ_TARGETMACHINE, 
                SZ_TEST
                );
        }

        if(hEventSource == NULL)
            return FALSE;

//        wsprintfW(szMsg, L"%s error: %lu", SZ_TEST, dwErr);        
        wsprintfW(szMsg, L": 0x%08x", dwErr);        
        lpszStrings[0] = lpszMsg;
        lpszStrings[1] = szMsg;

        ReportEventW(hEventSource,			// handle of event source
                     dwEventType,			// event type
                     0,			            // event category
                     dwErr,                 // event ID
                     NULL,					// current user's SID
                     2,						// strings in lpszStrings
                     0,						// no bytes of raw data
                     (LPCWSTR*)lpszStrings,	// array of error strings
                     NULL					// no raw data
                     );               

        (VOID) DeregisterEventSource(hEventSource);


        OutputDebugStringW(lpszMsg);
        OutputDebugStringW(szMsg);
        OutputDebugStringW(lpszCRLF);

		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\scbvt\log.h ===
//
//  log.h
//
//  Copyright (c) Microsoft Corp, 1997
//
//  This file contains the code necessary to log error messages to the event 
//  log of a remote machine (or a local machine, depending on the #defines
//  below).
//
//  Revision History:
//
//  LarryWin	Created		12/15/1997
//

// defines

// target machine
#define SZ_IPC_SHARE        L"\\\\larrywin2\\ipc$"
#define SZ_TARGETMACHINE    L"\\\\larrywin2"
#define SZ_TEST             L"SCLogon"

// event levels
#define PERF_ERROR			EVENTLOG_ERROR_TYPE
#define PERF_WARNING		EVENTLOG_WARNING_TYPE
#define PERF_INFORMATION	EVENTLOG_INFORMATION_TYPE

// function prototypes
void SetEventMachine(LPWSTR*);

void Event(DWORD, LPWSTR, DWORD);

BOOL OpenIPCConnection();

BOOL ErrorToEventLog(DWORD, LPWSTR, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\rpc\server\kerbserv.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "kerbtest.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -s authn service\n");
    exit(1);
}

HANDLE TerminateEvent;
ULONG AuthnService = RPC_C_AUTHN_GSS_KERBEROS;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszEndpoint         = "30760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned char * PrincipalName       = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 's':
                    sscanf(argv[++i],"%d",&AuthnService);
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    printf("Server using protseq %s endpoint %s\n",pszProtocolSequence, pszEndpoint );
    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   3, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(srv_kerbtest_ServerIfHandle, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerInqDefaultPrincName(
                AuthnService,
                &PrincipalName
                );
    if (status)
    {
        printf("RpcServerInqDefaultPrincName returned %d\n",status);
        exit(2);
    }
    status = RpcServerRegisterAuthInfo(
                PrincipalName,
                AuthnService,
                NULL,
                NULL
                );

    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API
MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API
MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

ULONG
RecurseRemoteCall(
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{

    unsigned char * pszStringBinding;
    RPC_STATUS status;
    handle_t BindingHandle;

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
                                     RemoteProtocol,
                                     RemoteAddress,
                                     RemoteEndpoint,
                                     NULL,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned %d\n", status);
        return(status);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &BindingHandle);

    RpcStringFree(&pszStringBinding);

    if (status) {

        printf("RpcBindingFromStringBinding returned %d\n", status);
        return(status);
    }


    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, Principal );
    status = RpcBindingSetAuthInfo(
                    BindingHandle,
                    Principal,
                    AuthnLevel,
                    AuthnService,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        return( status );
    }


    //
    // Do the actual RPC calls to the server.
    //


    RpcTryExcept {
        status = RemoteCall(
                    BindingHandle,
                    Options,
                    Address,
                    RemoteProtocol,
                    RemoteEndpoint,
                    Principal,
                    RemoteAddress,
                    AuthnLevel,
                    AuthnService,
                    RecursionLevel
                    );
        if (status != 0)
        {
            printf("RemoteCall failed: 0x%x\n",status);
        }

    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        printf("Runtime library reported an exception %d\n",
               RpcExceptionCode());

    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the binding handle


    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }


}


ULONG
srv_RemoteCall(
    handle_t BindingHandle,
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{
    RPC_STATUS RpcStatus;
    CHAR ClientName[100];
    ULONG NameLen = sizeof(ClientName);

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
        goto Cleanup;
    }
    GetUserName(ClientName,&NameLen);
    printf("Recursion %d: Client called: name = %s\n",RecursionLevel, ClientName);

    if (RecursionLevel != 0)
    {
        RpcStatus = RecurseRemoteCall(
                        Options,
                        RemoteAddress,
                        RemoteProtocol,
                        RemoteEndpoint,
                        Principal,
                        Address,
                        AuthnLevel,
                        AuthnSvc,
                        RecursionLevel - 1
                        );
    }
    RpcRevertToSelf();


Cleanup:


    return(RpcStatus);
}

void
srv_Shutdown(
    handle_t BindingHandle
    )
{
    RPC_STATUS status;

    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\scperfrm\scperf.cpp ===
/*--

  Copyright (c) 1987-1998  Microsoft Corporation
  
    Module Name:
    
      sclogon.cxx
      
        Abstract:
        
          Test program for Smart Card Logon
          
            Author:
            
              28-Jun-1993 (cliffv)
              
                Environment:
                
                  User mode only.
                  Contains NT-specific code.
                  Requires ANSI C extensions: slash-slash comments, long external names.
                  
                    Revision History:
                    
                      29-Oct-1998 (larrywin)
                      
--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <stddef.h>		// 'offset' macro

#include <windows.h>
#include <winnls.h>
#include <iostream.h>
#include <winioctl.h>
#include <tchar.h>
#include <string.h>

}
#include <wchar.h>
#include <conio.h>
#include <ctype.h>

extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>
#include <winscard.h>
//#include <log.h>

#define MAX_RECURSION_DEPTH 1
#define BUFFERSIZE 200

BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
LPWSTR g_wszReaderName = new wchar_t[BUFFERSIZE];
// file handle for output file
//FILE            *outstream;

/*++

PrintMessage:

    Simple function to dump text to standard output.
	
    Arguments:

    lpszFormat - String to dump to standard output
	
--*/

void _cdecl 
PrintMessage(
    IN LPSTR lpszFormat, ...)
{
    //
    // Helper to do print traces...
    //

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    char szBuffer[512];
    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vstprintf(szBuffer, lpszFormat, args);

    _tprintf(szBuffer);
//    fprintf(outstream, "%s", szBuffer);

//    OutputDebugStringA(szBuffer);
    va_end(args);
}


/*++

  BuildLogonInfo:
  GetReaderName:
  GetCardName:
  GetContainerName:
  GetCSPName:
  
    : Intended for accessing the LogonInformation glob
    
      Author:
      
        Amanda Matlosz
        
          Note:
          
            Some of these are made available to outside callers; see sclogon.h
            
--*/
PBYTE
BuildSCLogonInfo(
                 LPCTSTR szCard,
                 LPCTSTR szReader,
                 LPCTSTR szContainer,
                 LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.
    
    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");
    
    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }
    
    //
    // Build the LogonInfo glob using strings (or empty strings)
    //
    
    DWORD cbLi = offsetof(LogonInfo, bBuffer)
        + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
        + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
        + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
        + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);
    
    if (NULL == pLI)
    {
        return NULL;
    }
    
    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;
    
    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);
    
    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);
    
    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);
    
    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);
    
    //    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}

LPTSTR ErrorString( IN DWORD dwError ) 
{
    DWORD dwLen = 0;
    LPTSTR szErrorString = NULL;

    dwLen = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)dwError,
        LANG_NEUTRAL,
        (LPTSTR)&szErrorString,
        0,
        NULL);

    return szErrorString;
}


HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = (PSYSTEM_PROCESS_INFORMATION)LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

NTSTATUS
TestScLogonRoutine(
                   IN ULONG Count,
                   IN LPSTR Pin
                   )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    SCARDCONTEXT hContext = NULL;
    LONG lCallReturn = -1;
    LPTSTR szReaders = NULL;
    LPTSTR pchReader = NULL;
    LPTSTR mszCards = NULL;
    LPTSTR szLogonCard = NULL;
    LPTSTR szCSPName = NULL;
    BYTE bSLBAtr[] = {0x3b,0xe2,0x00,0x00,0x40,0x20,0x49,0x06};
    BYTE bGEMAtr[] = {0x3b,0x27,0x00,0x80,0x65,0xa2,0x00,0x01,0x01,0x37};
    DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    DWORD dwCardsLen = SCARD_AUTOALLOCATE;
    DWORD dwCSPLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS]; // not necessarily max for pnp readers
    LONG nIndex;
    LONG nCnReaders;
    BOOL fFound = FALSE;
	SYSTEMTIME StartTime, DoneTime;
	SYSTEMTIME		stElapsed;
	FILETIME		ftStart, ftDone,
		*pftStart = &ftStart,
		*pftDone  = &ftDone;
	LARGE_INTEGER	liStart, liDone,
		*pliStart = &liStart,
		*pliDone  = &liDone;
	LARGE_INTEGER liAccumulatedTime, liSplitTime,
		*pliAccumulatedTime = &liAccumulatedTime,
		*pliSplitTime = &liSplitTime;
	FILETIME ftAccumulatedTime,
		*pftAccumulatedTime   = &ftAccumulatedTime;
	SYSTEMTIME stAccumulatedTime;
	LPWSTR buffer = new wchar_t[BUFFERSIZE];
	int j;
	memset(buffer, 0, BUFFERSIZE);
		
	liAccumulatedTime.QuadPart = 0;
    
    // get a ResMgr context
    lCallReturn = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hContext);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to initialize context: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // list all readers
    lCallReturn = SCardListReaders(hContext, SCARD_ALL_READERS, (LPTSTR)&szReaders, &dwReadersLen);
    if (SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to list readers on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else if ((0 == dwReadersLen)
        || (NULL == szReaders)
        || (0 == *szReaders))
    {
        lCallReturn = SCARD_E_UNKNOWN_READER;   // Or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
		swprintf(buffer, L"Failed to identify a reader on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // list cards
    lCallReturn = SCardListCards(hContext, NULL, NULL, 0, (LPTSTR)&mszCards, &dwCardsLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        printf("Failed to list cards in the system: 0x%x\n", lCallReturn);
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to identify a card on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // use the list of readers to build a readerstate array
    nIndex = 0;
    if (0 != wcslen(g_wszReaderName)) {
        // use the reader specified in the command line
        rgReaderStates[nIndex].szReader = (const unsigned short *)g_wszReaderName;
        rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
        nCnReaders = 1;
    } else {
        pchReader = szReaders;
        while (0 != *pchReader)
        {
            rgReaderStates[nIndex].szReader = pchReader;
            rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
            pchReader += lstrlen(pchReader)+1;
            nIndex++;
            if (MAXIMUM_SMARTCARD_READERS == nIndex)
                break;
        }
        nCnReaders = nIndex;
    }
    
    // find a reader with one of the listed cards, or the specified card, present
    lCallReturn = SCardLocateCards(hContext, mszCards, rgReaderStates, nCnReaders);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to locate a smart card for logon: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // find the reader containing the requested card
    for (nIndex=0; nIndex<nCnReaders && FALSE == fFound; nIndex++) {
        if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_ATRMATCH) {
            // reader found
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound) {
        lCallReturn = SCARD_E_NO_SMARTCARD; // or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"No smart card in any reader: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else { // get the name of the card found
        dwCardsLen = SCARD_AUTOALLOCATE;
        lCallReturn = SCardListCards(hContext, rgReaderStates[nIndex].rgbAtr, NULL, 0, (LPTSTR)&szLogonCard, &dwCardsLen);
        if ( SCARD_S_SUCCESS != lCallReturn ) {
            if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
            if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
            if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
			swprintf(buffer, L"Failed to get name of card in reader: 0x%x\n", lCallReturn);
            PrintMessage("%S",buffer);
			memset(buffer, 0, sizeof(buffer));
            return (NTSTATUS)lCallReturn;
        }
    }
    
    // get the csp provider name for the card
    lCallReturn = SCardGetCardTypeProviderName(hContext, szLogonCard, SCARD_PROVIDER_CSP, (LPTSTR)&szCSPName, &dwCSPLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
        if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
        if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
		swprintf(buffer, L"Failed to locate smart card crypto service provider: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    ScLogonInfo = BuildSCLogonInfo(szLogonCard,
        rgReaderStates[nIndex].szReader,
        TEXT(""), // use default container
        szCSPName
        );
    
    //
    // We should now have logon info.
    //
    if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
    if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
    if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
    if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
    
//    j =  swprintf(buffer, L"Reader : %s\n", GetReaderName(ScLogonInfo));
//    j += swprintf(buffer + j, L"Card   : %s\n", GetCardName(ScLogonInfo));
//    j += swprintf(buffer + j, L"CSP    : %s\n", GetCSPName(ScLogonInfo));
//    PrintMessage("%S",buffer);
//	memset(buffer, 0, sizeof(buffer));

	// perform sclogon
    if (ScLogonInfo == NULL)
    {
        swprintf(buffer, L"Failed to get logon info!\n");
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS) -1;
    }
    
    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;
    
    Status = ScHelperInitializeContext(
        ScLogonInfo,
        ScLogonInfoSize
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to initialize helper context: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    ScHelperRelease(ScLogonInfo);
    
    RtlInitString(
        &PinString,
        Pin
        );
    
    
    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;
    
    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    
    LogonInfo->MessageType = KerbSmartCardLogon;
    
    
    Where = (PUCHAR) (LogonInfo + 1);
    
    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);
    
    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;
    
    //
    // Turn on the TCB privilege
    //
    
    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to adjust privilege: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }

    RtlInitString(
        &Name,
        "SmartCardLogon"
        );
    Status = LsaRegisterLogonProcess(
        &Name,
        &LogonHandle,
        &Dummy
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to register as a logon process: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    strncpy(
        SourceContext.SourceName,
        "SmartCardLogon        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );
    
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
        LogonHandle,
        &Name,
        &PackageId
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to lookup package %Z: 0x%x\n",&Name, Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    //
    // Now call LsaLogonUser
    //
    
    RtlInitString(
        &Name,
        "SmartCardLogon"
        );

    for (Index = 1; Index <= Count ; Index++ )
    {
        swprintf(buffer, L" %.6d : ", Index);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

		// get start time
		GetSystemTime(&StartTime);
        
        Status = LsaLogonUser(
            LogonHandle,
            &Name,
            Interactive,
            PackageId,
            LogonInfo,
            LogonInfoSize,
            NULL,           // no token groups
            &SourceContext,
            (PVOID *) &Profile,
            &ProfileSize,
            &LogonId,
            &TokenHandle,
            &Quotas,
            &SubStatus
            );

		// get done time
		GetSystemTime(&DoneTime);

		// convert systemtime to filetime
		SystemTimeToFileTime(&StartTime, &ftStart);
		SystemTimeToFileTime(&DoneTime, &ftDone);
		
		// copy filetime to large int
		CopyMemory(pliStart, pftStart, 8);
		CopyMemory(pliDone, pftDone, 8);
		
		// diff the large ints and accumulate result
		liDone.QuadPart = liDone.QuadPart - liStart.QuadPart;
		liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart + liDone.QuadPart;
		
		// copy result back to filetime
		CopyMemory(pftDone, pliDone, 8);
		
		// convert result back to systemtime
		FileTimeToSystemTime( (CONST FILETIME *)&ftDone, &stElapsed);
		
		// output the result
		swprintf(buffer, L" %2.2ld m %2.2ld s %3.3ld ms ",
			stElapsed.wMinute,
			stElapsed.wSecond,
			stElapsed.wMilliseconds);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

        if (!NT_SUCCESS(Status))
        {
            j = swprintf(buffer, L" : lsalogonuser failed 0x%x\n",Status);
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            goto fail;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            j = swprintf(buffer, L" : lsalogonUser failed substatus = 0x%x\n",SubStatus);
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            goto fail;
        }
        
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        j = swprintf(buffer, L": %ws logon success\n",UserNameString);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        RevertToSelf();
        NtClose(TokenHandle);
        
        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

fail :
        // report average every 10th logon
		if (0 == Index % 10) {
			liSplitTime.QuadPart = liAccumulatedTime.QuadPart / Index;
			CopyMemory(pftAccumulatedTime, pliSplitTime, 8);
			FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
			swprintf(buffer, L"Average Time after %d Logons: %2.2ldm:%2.2lds:%3.3ldms\n",
				Index,
				stAccumulatedTime.wMinute,
				stAccumulatedTime.wSecond,
				stAccumulatedTime.wMilliseconds);
            PrintMessage("%S",buffer);
		}

        Sleep(2000); // let card stack unwind
    
    }

	// ouput average results
	if ( 1 != Count ) {
        liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart / Count;
        CopyMemory(pftAccumulatedTime, pliAccumulatedTime, 8);
        FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
        swprintf(buffer, L"\nAverage Logon Time: %2.2ldm:%2.2lds:%3.3ldms\n",
            stAccumulatedTime.wMinute,
            stAccumulatedTime.wSecond,
            stAccumulatedTime.wMilliseconds);
        PrintMessage("%S", buffer);
	}
    return (NTSTATUS)Status;
    
}


VOID
PrintKdcName(
             IN PKERB_INTERNAL_NAME Name
             )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

int __cdecl
main(
     IN int argc,
     IN char ** argv
     )
     /*++
     
       Routine Description:
       
         Drive the NtLmSsp service
         
           Arguments:
           
             argc - the number of command-line arguments.
             
               argv - an array of pointers to the arguments.
               
                 Return Value:
                 
                   Exit status
                   
                     --*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR PinBuffer = new char [81];
    LPSTR szReaderBuffer = new char[BUFFERSIZE];
	LPSTR EventMachineBuffer = new char [81];
    LPWSTR wEventMachineBuffer = new wchar_t[81];
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];
    NTSTATUS Status = -1;
    
    
    enum {
        NoAction,
#define LOGON_PARAM "/p"
            TestLogon,
#define ITERATION_PARAM "/i"
#define HELP_PARAM "/?"
//#define EVENT_PARAM "/s"
#define READER_PARAM "/r"
    } Action = NoAction;

    memset(g_wszReaderName, 0, BUFFERSIZE);
    memset(szReaderBuffer, 0, BUFFERSIZE);

    // open output file
//    outstream = fopen( "scperf.out", "w" );
    
    //
    // Loop through the arguments handle each in turn
    //
    
    if ( 1 == argc ) {// silent mode
        Iterations = 1;
        Action = TestLogon;
        printf("Enter your pin number: ");
        int ch;
        int j = 0;

        ch = _getch();

        while (ch != 0x0d) {
            j += sprintf(PinBuffer + j,"%c", ch);
            printf("*");
            ch = _getch();
        }

        printf("\n");

    }
    
    for ( i=1; i<argc; i++ ) {
        
        argument = argv[i];
        
        //
        // Handle /ConfigureService
        //
        
        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Iterations = 1;
            Action = TestLogon;
            
            if (argc <= i + 1) {
                goto Usage;
            }

            PinBuffer = argv[++i];

        } else if ( _strnicmp( argument, ITERATION_PARAM, sizeof(ITERATION_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
            
            Iterations = atoi(argv[++i]);

        } /*else if ( _strnicmp( argument, EVENT_PARAM, sizeof(EVENT_PARAM) - 1 ) == 0 ) {
			if (argc <= i + 1) {
                goto Usage;
            }
			// save name of machine to which events will be posted
            EventMachineBuffer = argv[++i];
			wsprintfW(wEventMachineBuffer, L"%S", EventMachineBuffer);
            SetEventMachine(&wEventMachineBuffer);
            //Event(PERF_INFORMATION, L"Trying to set machine name\n", 1);

		} */
        
          else if ( _strnicmp( argument, HELP_PARAM, sizeof(HELP_PARAM) - 1 ) == 0 ) {
            goto Usage;
		} else if ( _strnicmp( argument, READER_PARAM, sizeof(READER_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
			// get the name of a specified reader
            szReaderBuffer = argv[++i];
            wsprintfW(g_wszReaderName, L"%S", szReaderBuffer);
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }
        
        
    }

    //
    // Perform the action requested
    //
    
    switch ( Action ) {
        
    case TestLogon :
        Status = TestScLogonRoutine(
            Iterations,
            PinBuffer
            );
        break;

    case NoAction :
        goto Usage;
        break;
        
    }
    return Status;
Usage:
    PrintMessage("%s - no parameters, manually enter pin\n", argv[0]);
    PrintMessage("   optional parameters (if any used, must have /p)\n");
    PrintMessage("   /p Pin\n");
    PrintMessage("   /i Iterations\n");
//    printf("   /s EventMachineName (post events to this machine)\n");
    PrintMessage("   /r %cReader Name X%c (registry device name in quotes)\n", '"', '"');
    return -1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\rpc\client\kerbcli.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   kerbcli.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "kerbtest.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -d delegation address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -a authn level\n");
    fprintf(stderr, " -s authn service\n");
    fprintf(stderr, " -r recursiion level\n");
    fprintf(stderr, " -x shutdown server\n");
    fprintf(stderr, " -# number of times to call\n");
    fprintf(stderr, " -t target principal\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "30760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszDelegationAddress = NULL;
    unsigned char * pszPrincipal = NULL;
    unsigned char PrincipalBuffer[100];
    ULONG PrincipalLength;
    ULONG AuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    ULONG AuthnService = RPC_C_AUTHN_DCE_PRIVATE;
    ULONG RecursionLevel = 0;
    ULONG LoopCount = 1;
    BOOLEAN ShutdownService = FALSE;
    ULONG i;
    handle_t BindingHandle = NULL;

    // allow the user to override settings with command line switches
    for (i = 1; i < (ULONG) argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'd':  // network address
                pszDelegationAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 't':
                pszPrincipal = argv[++i];
                break;
            case 'a':
                sscanf(argv[++i],"%d",&AuthnLevel);
                break;
            case 's':
                sscanf(argv[++i],"%d",&AuthnService);
                break;
            case 'r':
                sscanf(argv[++i],"%d",&RecursionLevel);
                break;
            case '#':
                sscanf(argv[++i],"%d",&LoopCount);
                break;
            case 'x':
                ShutdownService = TRUE;
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    //
    // If the principal is NULL, get it from the environment
    //

    if (pszPrincipal == NULL)
    {
        LPSTR pszUserRealm;
        LPSTR pszUserName;

        PrincipalBuffer[0] = '\0';

        pszUserRealm = getenv( "USERDOMAIN" );
        pszUserName  = getenv( "USERNAME" );
        if (pszUserRealm != NULL)
        {
            strcpy(PrincipalBuffer, pszUserRealm);
        }
        if ((pszUserRealm != NULL) &&
            (pszUserName != NULL))
        {
            strcat(PrincipalBuffer,"\\");
        }
        if (pszUserName != NULL)
        {
            strcat(PrincipalBuffer,pszUserName);
        }
        pszPrincipal = PrincipalBuffer;

    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned %d\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &BindingHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned %d\n", status);
        exit(2);
    }


    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned %d\n", status);
        exit(2);
    }

    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, pszPrincipal );
    status = RpcBindingSetAuthInfo(
                    BindingHandle,
                    pszPrincipal,
                    AuthnLevel,
                    AuthnService,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //


    RpcTryExcept {
        for (i = 0; i < LoopCount ; i++ )
        {

            status = RemoteCall(
                        BindingHandle,
                        0,                      // no options for now
                        pszDelegationAddress,
                        pszProtocolSequence,
                        pszEndpoint,
                        pszPrincipal,
                        pszNetworkAddress,
                        AuthnLevel,
                        AuthnService,
                        RecursionLevel
                        );
            if (status != 0)
            {
                printf("RemoteCall failed: 0x%x\n",status);
                break;
            }

        }

        if (ShutdownService)
        {
            Shutdown( BindingHandle );
        }
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        printf("Runtime library reported an exception %d\n",
               RpcExceptionCode());

    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the binding handle


    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\scbvt\sclogon.cxx ===
/*--

  Copyright (c) 1987-1998  Microsoft Corporation
  
    Module Name:
    
      sclogon.cxx
      
        Abstract:
        
          Test program for Smart Card Logon
          
            Author:
            
              28-Jun-1993 (cliffv)
              
                Environment:
                
                  User mode only.
                  Contains NT-specific code.
                  Requires ANSI C extensions: slash-slash comments, long external names.
                  
                    Revision History:
                    
                      29-Oct-1998 (larrywin)
                      
--*/


//
// Common include files.
//

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <stddef.h>		// 'offset' macro

#include <windows.h>
#include <winnls.h>
#include <iostream.h>
#include <winioctl.h>
#include <tchar.h>
#include <string.h>

}
#include <wchar.h>
#include <conio.h>
#include <ctype.h>

extern "C" {
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <negossp.h>
#include <wincrypt.h>
#include <cryptui.h>
}
#include <sclogon.h>
#include <winscard.h>
#include <log.h>

#define MAX_RECURSION_DEPTH 1
#define BUFFERSIZE 200

BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
LPWSTR g_wszReaderName = new wchar_t[BUFFERSIZE];
// file handle for output file
FILE            *outstream;

/*++

PrintMessage:

    Simple function to dump text to standard output.
	
    Arguments:

    lpszFormat - String to dump to standard output
	
--*/

void _cdecl 
PrintMessage(
    IN LPSTR lpszFormat, ...)
{
    //
    // Helper to do print traces...
    //

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    char szBuffer[512];
    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vstprintf(szBuffer, lpszFormat, args);

    _tprintf(szBuffer);
    fprintf(outstream, "%s", szBuffer);

    OutputDebugStringA(szBuffer);
    va_end(args);
}


/*++

  BuildLogonInfo:
  GetReaderName:
  GetCardName:
  GetContainerName:
  GetCSPName:
  
    : Intended for accessing the LogonInformation glob
    
      Author:
      
        Amanda Matlosz
        
          Note:
          
            Some of these are made available to outside callers; see sclogon.h
            
--*/
PBYTE
BuildSCLogonInfo(
                 LPCTSTR szCard,
                 LPCTSTR szReader,
                 LPCTSTR szContainer,
                 LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.
    
    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");
    
    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }
    
    //
    // Build the LogonInfo glob using strings (or empty strings)
    //
    
    DWORD cbLi = offsetof(LogonInfo, bBuffer)
        + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
        + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
        + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
        + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);
    
    if (NULL == pLI)
    {
        return NULL;
    }
    
    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;
    
    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);
    
    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);
    
    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);
    
    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);
    
    //    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}

LPTSTR ErrorString( IN DWORD dwError ) 
{
    DWORD dwLen = 0;
    LPTSTR szErrorString = NULL;

    dwLen = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)dwError,
        LANG_NEUTRAL,
        (LPTSTR)&szErrorString,
        0,
        NULL);

    return szErrorString;
}


HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = (PSYSTEM_PROCESS_INFORMATION)LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

NTSTATUS
TestScLogonRoutine(
                   IN ULONG Count,
                   IN LPSTR Pin
                   )
{
    NTSTATUS Status;
    PKERB_SMART_CARD_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_SMART_CARD_LOGON);
    BOOLEAN WasEnabled;
    STRING PinString;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ScHandle = NULL;
    PBYTE ScLogonInfo = NULL;
    ULONG ScLogonInfoSize;
    ULONG WaitResult = 0;
    SCARDCONTEXT hContext = NULL;
    LONG lCallReturn = -1;
    LPTSTR szReaders = NULL;
    LPTSTR pchReader = NULL;
    LPTSTR mszCards = NULL;
    LPTSTR szLogonCard = NULL;
    LPTSTR szCSPName = NULL;
    BYTE bSLBAtr[] = {0x3b,0xe2,0x00,0x00,0x40,0x20,0x49,0x06};
    BYTE bGEMAtr[] = {0x3b,0x27,0x00,0x80,0x65,0xa2,0x00,0x01,0x01,0x37};
    DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    DWORD dwCardsLen = SCARD_AUTOALLOCATE;
    DWORD dwCSPLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS]; // not necessarily max for pnp readers
    LONG nIndex;
    LONG nCnReaders;
    BOOL fFound = FALSE;
	SYSTEMTIME StartTime, DoneTime;
	SYSTEMTIME		stElapsed;
	FILETIME		ftStart, ftDone,
		*pftStart = &ftStart,
		*pftDone  = &ftDone;
	LARGE_INTEGER	liStart, liDone,
		*pliStart = &liStart,
		*pliDone  = &liDone;
	LARGE_INTEGER liAccumulatedTime, liSplitTime,
		*pliAccumulatedTime = &liAccumulatedTime,
		*pliSplitTime = &liSplitTime;
	FILETIME ftAccumulatedTime,
		*pftAccumulatedTime   = &ftAccumulatedTime;
	SYSTEMTIME stAccumulatedTime;
	LPWSTR buffer = new wchar_t[BUFFERSIZE];
	int j;
	memset(buffer, 0, BUFFERSIZE);
		
	liAccumulatedTime.QuadPart = 0;
    
    // get a ResMgr context
    lCallReturn = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hContext);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to initialize context: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // list all readers
    lCallReturn = SCardListReaders(hContext, SCARD_ALL_READERS, (LPTSTR)&szReaders, &dwReadersLen);
    if (SCARD_S_SUCCESS != lCallReturn) {
        swprintf(buffer, L"Failed to list readers on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else if ((0 == dwReadersLen)
        || (NULL == szReaders)
        || (0 == *szReaders))
    {
        lCallReturn = SCARD_E_UNKNOWN_READER;   // Or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
		swprintf(buffer, L"Failed to identify a reader on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // list cards
    lCallReturn = SCardListCards(hContext, NULL, NULL, 0, (LPTSTR)&mszCards, &dwCardsLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        printf("Failed to list cards in the system: 0x%x\n", lCallReturn);
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to identify a card on the system: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    // use the list of readers to build a readerstate array
    nIndex = 0;
    if (0 != wcslen(g_wszReaderName)) {
        // use the reader specified in the command line
        rgReaderStates[nIndex].szReader = (const unsigned short *)g_wszReaderName;
        rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
        nCnReaders = 1;
    } else {
        pchReader = szReaders;
        while (0 != *pchReader)
        {
            rgReaderStates[nIndex].szReader = pchReader;
            rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
            pchReader += lstrlen(pchReader)+1;
            nIndex++;
            if (MAXIMUM_SMARTCARD_READERS == nIndex)
                break;
        }
        nCnReaders = nIndex;
    }
    
    // find a reader with one of the listed cards, or the specified card, present
    lCallReturn = SCardLocateCards(hContext, mszCards, rgReaderStates, nCnReaders);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"Failed to locate a smart card for logon: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    }
    
    // find the reader containing the requested card
    for (nIndex=0; nIndex<nCnReaders && FALSE == fFound; nIndex++) {
        if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_ATRMATCH) {
            // reader found
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound) {
        lCallReturn = SCARD_E_NO_SMARTCARD; // or some such error
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
		swprintf(buffer, L"No smart card in any reader: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } else { // get the name of the card found
        dwCardsLen = SCARD_AUTOALLOCATE;
        lCallReturn = SCardListCards(hContext, rgReaderStates[nIndex].rgbAtr, NULL, 0, (LPTSTR)&szLogonCard, &dwCardsLen);
        if ( SCARD_S_SUCCESS != lCallReturn ) {
            if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
            if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
            if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
			swprintf(buffer, L"Failed to get name of card in reader: 0x%x\n", lCallReturn);
            PrintMessage("%S",buffer);
			memset(buffer, 0, sizeof(buffer));
            return (NTSTATUS)lCallReturn;
        }
    }
    
    // get the csp provider name for the card
    lCallReturn = SCardGetCardTypeProviderName(hContext, szLogonCard, SCARD_PROVIDER_CSP, (LPTSTR)&szCSPName, &dwCSPLen);
    if ( SCARD_S_SUCCESS != lCallReturn) {
        if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
        if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
        if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
        if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
		swprintf(buffer, L"Failed to locate smart card crypto service provider: 0x%x\n", lCallReturn);
        PrintMessage("%S",buffer);
		memset(buffer, 0, sizeof(buffer));
        return (NTSTATUS)lCallReturn;
    } 
    
    ScLogonInfo = BuildSCLogonInfo(szLogonCard,
        rgReaderStates[nIndex].szReader,
        TEXT(""), // use default container
        szCSPName
        );
    
    //
    // We should now have logon info.
    //
    if (NULL != szReaders) SCardFreeMemory(hContext, (LPVOID)szReaders);
    if (NULL != mszCards ) SCardFreeMemory(hContext, (LPVOID)mszCards);
    if (NULL != szCSPName) SCardFreeMemory(hContext, (LPVOID)szCSPName);
    if (NULL != szLogonCard ) SCardFreeMemory(hContext, (LPVOID)szLogonCard);
    
    j =  swprintf(buffer, L"Reader : %s\n", GetReaderName(ScLogonInfo));
    j += swprintf(buffer + j, L"Card   : %s\n", GetCardName(ScLogonInfo));
    j += swprintf(buffer + j, L"CSP    : %s\n", GetCSPName(ScLogonInfo));
    PrintMessage("%S",buffer);
	memset(buffer, 0, sizeof(buffer));

	// perform sclogon
    if (ScLogonInfo == NULL)
    {
        swprintf(buffer, L"Failed to get logon info!\n");
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS) -1;
    }
    
    ScLogonInfoSize = ((struct LogonInfo *) ScLogonInfo)->dwLogonInfoLen;
    
    Status = ScHelperInitializeContext(
        ScLogonInfo,
        ScLogonInfoSize
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to initialize helper context: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    ScHelperRelease(ScLogonInfo);
    
    RtlInitString(
        &PinString,
        Pin
        );
    
    
    LogonInfoSize += (PinString.Length+1 ) * sizeof(WCHAR) + ScLogonInfoSize;
    
    LogonInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    
    LogonInfo->MessageType = KerbSmartCardLogon;
    
    
    Where = (PUCHAR) (LogonInfo + 1);
    
    LogonInfo->Pin.Buffer = (LPWSTR) Where;
    LogonInfo->Pin.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Pin,
        &PinString,
        FALSE
        );
    Where += LogonInfo->Pin.Length + sizeof(WCHAR);
    
    LogonInfo->CspDataLength = ScLogonInfoSize;
    LogonInfo->CspData = Where;
    RtlCopyMemory(
        LogonInfo->CspData,
        ScLogonInfo,
        ScLogonInfoSize
        );
    Where += ScLogonInfoSize;
    
    //
    // Turn on the TCB privilege
    //
    
    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to adjust privilege: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }

    RtlInitString(
        &Name,
        "SmartCardLogon"
        );
    Status = LsaRegisterLogonProcess(
        &Name,
        &LogonHandle,
        &Dummy
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to register as a logon process: 0x%x\n",Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    strncpy(
        SourceContext.SourceName,
        "SmartCardLogon        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );
    
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
        LogonHandle,
        &Name,
        &PackageId
        );
    if (!NT_SUCCESS(Status))
    {
        swprintf(buffer, L"Failed to lookup package %Z: 0x%x\n",&Name, Status);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        return (NTSTATUS)Status;
    }
    
    //
    // Now call LsaLogonUser
    //
    
    RtlInitString(
        &Name,
        "SmartCardLogon"
        );

    for (Index = 1; Index <= Count ; Index++ )
    {
        swprintf(buffer, L"\nLogon %.6d\n", Index);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

		// get start time
		GetSystemTime(&StartTime);
        
        Status = LsaLogonUser(
            LogonHandle,
            &Name,
            Interactive,
            PackageId,
            LogonInfo,
            LogonInfoSize,
            NULL,           // no token groups
            &SourceContext,
            (PVOID *) &Profile,
            &ProfileSize,
            &LogonId,
            &TokenHandle,
            &Quotas,
            &SubStatus
            );

		// get done time
		GetSystemTime(&DoneTime);

		// convert systemtime to filetime
		SystemTimeToFileTime(&StartTime, &ftStart);
		SystemTimeToFileTime(&DoneTime, &ftDone);
		
		// copy filetime to large int
		CopyMemory(pliStart, pftStart, 8);
		CopyMemory(pliDone, pftDone, 8);
		
		// diff the large ints and accumulate result
		liDone.QuadPart = liDone.QuadPart - liStart.QuadPart;
		liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart + liDone.QuadPart;
		
		// copy result back to filetime
		CopyMemory(pftDone, pliDone, 8);
		
		// convert result back to systemtime
		FileTimeToSystemTime( (CONST FILETIME *)&ftDone, &stElapsed);
		
		// output the result
		swprintf(buffer, L"RunTime:  %2.2ldm:%2.2lds:%3.3ldms\n",
			stElapsed.wMinute,
			stElapsed.wSecond,
			stElapsed.wMilliseconds);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);

        if (!NT_SUCCESS(Status))
        {
            j = swprintf(buffer, L"lsalogonuser failed: 0x%x\n",Status);
            LPTSTR szErrorMessage = ErrorString((DWORD)Status);
            if (NULL == szErrorMessage) {
                j += swprintf(buffer + j, L"   ErrorMessage: error message not found, check ntstatus.h\n");
            } else {
                j += swprintf(buffer + j, L"   ErrorMessage: %S\n", szErrorMessage);
            }
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            return (NTSTATUS)Status;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            j = swprintf(buffer, L"LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            LPTSTR szErrorMessage = ErrorString((DWORD)Status);
            if (NULL == szErrorMessage) {
                j += swprintf(buffer + j, L"   ErrorMessage: error message not found, check ntstatus.h\n");
            } else {
                j += swprintf(buffer + j, L"   ErrorMessage: %S", szErrorMessage);
            }
            PrintMessage("%S",buffer);
			memset(buffer, 0, BUFFERSIZE);
            return (NTSTATUS)SubStatus;
        }
        
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        j = swprintf(buffer, L"Result:   %S", ErrorString((DWORD)Status));
        j += swprintf(buffer, L"Username: %ws\n",UserNameString);
        PrintMessage("%S",buffer);
		memset(buffer, 0, BUFFERSIZE);
        RevertToSelf();
        NtClose(TokenHandle);
        
        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

		// report average every 10th logon
		if (0 == Index % 10) {
			liSplitTime.QuadPart = liAccumulatedTime.QuadPart / Index;
			CopyMemory(pftAccumulatedTime, pliSplitTime, 8);
			FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
			swprintf(buffer, L"\nAverage Time after %d Logons: %2.2ldm:%2.2lds:%3.3ldms\n",
				Index,
				stAccumulatedTime.wMinute,
				stAccumulatedTime.wSecond,
				stAccumulatedTime.wMilliseconds);
            PrintMessage("%S",buffer);
		}

        Sleep(2000); // let card stack unwind
    
    }

	// ouput average results
	if ( 1 != Count ) {
        liAccumulatedTime.QuadPart = liAccumulatedTime.QuadPart / Count;
        CopyMemory(pftAccumulatedTime, pliAccumulatedTime, 8);
        FileTimeToSystemTime( (CONST FILETIME *)&ftAccumulatedTime, &stAccumulatedTime);
        swprintf(buffer, L"\nAverage Logon Time: %2.2ldm:%2.2lds:%3.3ldms\n",
            stAccumulatedTime.wMinute,
            stAccumulatedTime.wSecond,
            stAccumulatedTime.wMilliseconds);
        PrintMessage("%S", buffer);
	}
    return (NTSTATUS)Status;
    
}


VOID
PrintKdcName(
             IN PKERB_INTERNAL_NAME Name
             )
{
    ULONG Index;
    for (Index = 0; Index < Name->NameCount ; Index++ )
    {
        printf(" %wZ ",&Name->Names[Index]);
    }
    printf("\n");
}

int __cdecl
main(
     IN int argc,
     IN char ** argv
     )
     /*++
     
       Routine Description:
       
         Drive the NtLmSsp service
         
           Arguments:
           
             argc - the number of command-line arguments.
             
               argv - an array of pointers to the arguments.
               
                 Return Value:
                 
                   Exit status
                   
                     --*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR PinBuffer = new char [81];
    LPSTR szReaderBuffer = new char[BUFFERSIZE];
	LPSTR EventMachineBuffer = new char [81];
    LPWSTR wEventMachineBuffer = new wchar_t[81];
    LPWSTR PackageFunction;
    ULONG ContextReq = 0;
    WCHAR ContainerName[100];
    WCHAR CaName[100];
    WCHAR CaLocation[100];
    WCHAR ServiceName[100];
    NTSTATUS Status = -1;
    
    
    enum {
        NoAction,
#define LOGON_PARAM "/p"
            TestLogon,
#define ITERATION_PARAM "/i"
#define HELP_PARAM "/?"
//#define EVENT_PARAM "/s"
#define READER_PARAM "/r"
    } Action = NoAction;

    memset(g_wszReaderName, 0, BUFFERSIZE);
    memset(szReaderBuffer, 0, BUFFERSIZE);

    // open output file
    outstream = fopen( "scardbvt.out", "w" );
    
    //
    // Loop through the arguments handle each in turn
    //
    
    if ( 1 == argc ) {// silent mode
        Iterations = 1;
        Action = TestLogon;
        printf("Enter your pin number: ");
        int ch;
        int j = 0;

        ch = _getch();

        while (ch != 0x0d) {
            j += sprintf(PinBuffer + j,"%c", ch);
            printf("*");
            ch = _getch();
        }

        printf("\n");

    }
    
    for ( i=1; i<argc; i++ ) {
        
        argument = argv[i];
        
        //
        // Handle /ConfigureService
        //
        
        if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Iterations = 1;
            Action = TestLogon;
            
            if (argc <= i + 1) {
                goto Usage;
            }

            PinBuffer = argv[++i];

        } else if ( _strnicmp( argument, ITERATION_PARAM, sizeof(ITERATION_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
            
            Iterations = atoi(argv[++i]);

        } /*else if ( _strnicmp( argument, EVENT_PARAM, sizeof(EVENT_PARAM) - 1 ) == 0 ) {
			if (argc <= i + 1) {
                goto Usage;
            }
			// save name of machine to which events will be posted
            EventMachineBuffer = argv[++i];
			wsprintfW(wEventMachineBuffer, L"%S", EventMachineBuffer);
            SetEventMachine(&wEventMachineBuffer);
            //Event(PERF_INFORMATION, L"Trying to set machine name\n", 1);

		} */
        
          else if ( _strnicmp( argument, HELP_PARAM, sizeof(HELP_PARAM) - 1 ) == 0 ) {
            goto Usage;
		} else if ( _strnicmp( argument, READER_PARAM, sizeof(READER_PARAM) - 1 ) == 0 ) {
            if (argc <= i + 1) {
                goto Usage;
            }
			// get the name of a specified reader
            szReaderBuffer = argv[++i];
            wsprintfW(g_wszReaderName, L"%S", szReaderBuffer);
        } else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }
        
        
    }

    //
    // Perform the action requested
    //
    
    switch ( Action ) {
        
    case TestLogon :
        Status = TestScLogonRoutine(
            Iterations,
            PinBuffer
            );
        break;

    case NoAction :
        goto Usage;
        break;
        
    }
    return Status;
Usage:
    PrintMessage("%s - no parameters, manually enter pin\n", argv[0]);
    PrintMessage("   optional parameters (if any used, must have /p)\n");
    PrintMessage("   /p Pin\n");
    PrintMessage("   /i Iterations\n");
//    printf("   /s EventMachineName (post events to this machine)\n");
    PrintMessage("   /r %cReader Name X%c (registry device name in quotes)\n", '"', '"');
    return -1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\utest\ssp\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <netlib.h>     // NetpGetLocalDomainId
#include <tstring.h>    // NetpAllocWStrFromWStr
#define SECURITY_KERBEROS
#define SECURITY_PACKAGE
#include <security.h>   // General definition of a Security Support Provider
#include <secint.h>
#include <kerbcomm.h>
#include <wincrypt.h>
#include <kerbdefs.h>
#include <kerblist.h>
#include <negossp.h>
#include <kerbcli.h>


BOOLEAN QuietMode = FALSE; // Don't be verbose
BOOLEAN DoAnsi = FALSE;
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
ULONG MaxRecursionDepth = 1;

#define STRING_OR_NULL(_x_) (((_x_) != NULL) ? (_x_) : L"<null>")
#define STRING_OR_NULLA(_x_) (((_x_) != NULL) ? (_x_) : "<null>")


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't convert time from GMT to Local time\n" );
        LocalTime = ConvertTime;
    }

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

HANDLE
FindAndOpenWinlogon(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    NTSTATUS Status ;
    UNICODE_STRING Winlogon ;
    HANDLE Process ;

    SystemInfo = LocalAlloc( LMEM_FIXED, sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024 );

    if ( !SystemInfo )
    {
        return NULL ;
    }

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                SystemInfo,
                sizeof( SYSTEM_PROCESS_INFORMATION ) * 1024,
                NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    RtlInitUnicodeString( &Winlogon, L"winlogon.exe" );

    Walk = SystemInfo ;

    while ( RtlCompareUnicodeString( &Walk->ImageName, &Winlogon, TRUE ) != 0 )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        LocalFree( SystemInfo );
        return NULL ;
    }

    Process = OpenProcess( PROCESS_QUERY_INFORMATION,
                           FALSE,
                           HandleToUlong(Walk->UniqueProcessId) );

    LocalFree( SystemInfo );

    return Process ;


}

VOID
ConfigureServiceRoutine(
    VOID
    )
/*++

Routine Description:

    Configure the NtLmSsp Service

Arguments:

    None

Return Value:

    None

--*/
{
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    WCHAR ServiceName[MAX_PATH];
    DWORD WinStatus,NetStatus;
    HKEY LsaKey = NULL;
    USER_INFO_1 UserInfo;
    PSID PrimaryDomain = NULL;
    PSID AccountDomain = NULL;

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_ACCOUNTS, &AccountDomain) != NERR_Success)
    {
        printf("Failed to get account domain ID\n");
        return;
    }

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_PRIMARY, &PrimaryDomain) != NERR_Success)
    {
        printf("Failed to get primary domain ID\n");
        return;
    }


    //
    // First set REDMOND as the preferred domain
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa\\MSV1_0",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"PreferredDomain",
                    0,
                    REG_SZ,
                    (PBYTE) L"REDMOND",
                    sizeof(L"REDMOND")
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        RegCloseKey(LsaKey);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"MappedDomain",
                    0,
                    REG_SZ,
                    (PBYTE) L"NTDEV",
                    sizeof(L"NTDEV")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegSetValue failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    //
    // Then add Kerberos as a security package
    //

#ifdef notdef

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }
    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"Security Packages",
                    0,
                    REG_MULTI_SZ,
                    (PBYTE) L"Kerberos\0Msv1_0\0",
                    sizeof(L"Kerberos\0") + sizeof(L"Msv1_0\0")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegSetValueEx failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }


    //
    // First add Kerberos as a security package for RPC
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Rpc\\SecurityService",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"1",
                    0,
                    REG_SZ,
                    (PBYTE) L"secur32.dll",
                    sizeof(L"secur32.dll")
                    );
    if (WinStatus != 0)
    {
        printf("RegSetvalueEx failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"10",
                    0,
                    REG_SZ,
                    (PBYTE) L"secur32.dll",
                    sizeof(L"secur32.dll")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegSetValueEx failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }

#endif
    //
    // If we are on a DC (and the primary domain sid == account domain sid)
    // setup the KDC service
    //

    if ((PrimaryDomain) != NULL && RtlEqualSid(PrimaryDomain, AccountDomain))
    {
        //
        // Build the name of the Kerberos service.
        //

        wcscpy( ServiceName, L"%SystemRoot%\\System32\\lsass.exe ");

        //
        // Open a handle to the Service Controller
        //

        ScManagerHandle = OpenSCManager(
                              NULL,
                              NULL,
                              SC_MANAGER_CREATE_SERVICE );

        if (ScManagerHandle == NULL) {
            printf( "OpenSCManager failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        //
        // If the does notservice already exists,
        //  install it
        //

        ServiceHandle = OpenService(
                            ScManagerHandle,
                            L"KDC",
                            DELETE );

        if ( ServiceHandle == NULL ) {
            WinStatus = GetLastError();
            if ( WinStatus != ERROR_SERVICE_DOES_NOT_EXIST ) {
                printf( "OpenService failed:" );
                PrintStatus( WinStatus );
                goto Cleanup;
            }

            //
            // Create the service
            //

            ServiceHandle = CreateService(
                                ScManagerHandle,
                                L"KDC",
                                L"Key Distribution Center",
                                SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG,
                                SERVICE_WIN32_SHARE_PROCESS,
                                SERVICE_AUTO_START,
                                SERVICE_ERROR_NORMAL,
                                ServiceName,
                                NULL,       // No load order group
                                NULL,       // No Tag Id required
                                L"rpcss\0afd\0",
                                NULL,       // Run as LocalSystem
                                NULL );     // No password



            if ( ServiceHandle == NULL ) {
                printf( "CreateService failed:" );
                PrintStatus( GetLastError() );
                goto Cleanup;
            }


        }

        (VOID) CloseServiceHandle(ServiceHandle);


        //
        // Create the krbtgs user account
        //

        UserInfo.usri1_name = L"krbtgt";
        UserInfo.usri1_password = L"krbtgt";
        UserInfo.usri1_password_age = 0;
        UserInfo.usri1_priv = USER_PRIV_USER;
        UserInfo.usri1_home_dir = NULL;
        UserInfo.usri1_comment = L"Key Distribution Center Service Account";
        UserInfo.usri1_script_path = NULL;
        UserInfo.usri1_flags = UF_SCRIPT;

        NetStatus = NetUserAdd(
                        NULL,
                        1,
                        (LPBYTE) &UserInfo,
                        NULL
                        );
        if ((NetStatus != NERR_Success) && (NetStatus != NERR_UserExists))
        {
            printf("Failed to create KDC account: %d\n",NetStatus);
        }


    }

Cleanup:
    if (PrimaryDomain != NULL)
    {
        LocalFree(PrimaryDomain);
    }
    if (AccountDomain != NULL)
    {
        LocalFree(AccountDomain);
    }

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    return;

}

BOOLEAN
GetCredentialsHandle(
    OUT PCredHandle CredentialsHandle,
    IN LPWSTR PackageName,
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR Password,
    IN ULONG Flags
    )
{
    TimeStamp Lifetime;
    NTSTATUS SecStatus;
    SEC_WINNT_AUTH_IDENTITY_W Identity = {0};
    PSEC_WINNT_AUTH_IDENTITY_W AuthIdentity = NULL;

    if ((UserName != NULL) ||
        (DomainName != NULL) ||
        (Password != NULL))
    {
        Identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        if (UserName != NULL)
        {
            Identity.UserLength = wcslen(UserName);
            Identity.User = UserName;
        }
        if (DomainName != NULL)
        {
            Identity.DomainLength = wcslen(DomainName);
            Identity.Domain = DomainName;
        }
        if (Password != NULL)
        {
            Identity.PasswordLength = wcslen(Password);
            Identity.Password = Password;
        }
        AuthIdentity = &Identity;
    }

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    PackageName,
                    Flags,
                    NULL,
                    AuthIdentity,
                    NULL,
                    NULL,
                    CredentialsHandle,
                    &Lifetime );

    if (!NT_SUCCESS(SecStatus))
    {
        printf("Failed to acquire credentials: 0x%x\n",SecStatus);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}
VOID
TestQuickISC(
    IN LPWSTR TargetNameU
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    TimeStamp CurrentTime;
    TimeStamp stLocal;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    
    
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    WCHAR TargetName[100];
    PSEC_WINNT_AUTH_IDENTITY_EXW AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W ServerAuthIdentity = NULL;
    PUCHAR Where;
    HANDLE TokenHandle = NULL;
    ULONG CredSize;
    PVOID SuppliedCreds = NULL;
    SecBuffer MarshalledContext;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;


    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Flags ContextFlags;
    SecPkgContext_Lifespan ContextLifespan;
    SecPkgContext_DceInfo ContextDceInfo;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;
    SecPkgContext_NativeNames NativeNames;
    SecPkgContext_NativeNamesA NativeNamesA;
    SecPkgCredentials_Names CredNames;
    SecPkgContext_PackageInfo ContextPackageInfo;
    SecPkgContext_KeyInfo KeyInfo = {0};

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[4];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];
    PBYTE pbSealBuffer;
    PBYTE pbWholeBuffer;
    ULONG cbWholeBuffer;
    CHAR UserNameA[100];
    CHAR DomainNameA[100];
    CHAR PasswordA[100];
    CHAR PackageListA[100];


    LPWSTR PackageName = MICROSOFT_KERBEROS_NAME_W;
    

    

    CredNames.sUserName = NULL;
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;


    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        PackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );
    

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    


    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY; // USE_DCE_STYLE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_SESSION_KEY; //  | ISC_REQ_DATAGRAM;
    
   InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetNameU,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }




    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    

}

VOID
TestSspRoutine(
    IN LPWSTR PackageName,
    IN LPWSTR UserNameU,
    IN LPWSTR DomainNameU,
    IN LPWSTR PasswordU,
    IN LPWSTR ServerUserNameU,
    IN LPWSTR ServerDomainNameU,
    IN LPWSTR ServerPasswordU,
    IN LPWSTR TargetNameU,
    IN LPWSTR PackageListU,
    IN ULONG ContextReq,
    IN ULONG CredFlags
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    TimeStamp CurrentTime;
    TimeStamp stLocal;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    BOOLEAN AcquiredServerCred = FALSE;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    WCHAR TargetName[100];
    PSEC_WINNT_AUTH_IDENTITY_EXW AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W ServerAuthIdentity = NULL;
    PUCHAR Where;
    HANDLE TokenHandle = NULL;
    ULONG CredSize;
    PVOID SuppliedCreds = NULL;
    SecBuffer MarshalledContext;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;


    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Flags ContextFlags;
    SecPkgContext_Lifespan ContextLifespan;
    SecPkgContext_DceInfo ContextDceInfo;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;
    SecPkgContext_NativeNames NativeNames;
    SecPkgContext_NativeNamesA NativeNamesA;
    SecPkgCredentials_Names CredNames;
    SecPkgContext_PackageInfo ContextPackageInfo;
    SecPkgContext_KeyInfo KeyInfo = {0};

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[4];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];
    PBYTE pbSealBuffer;
    PBYTE pbWholeBuffer;
    ULONG cbWholeBuffer;
    CHAR UserNameA[100];
    CHAR DomainNameA[100];
    CHAR PasswordA[100];
    CHAR PackageListA[100];



    if (PackageName == NULL)
    {
        PackageName = MICROSOFT_KERBEROS_NAME_W;
    }

    if (!DoAnsi)
    {
        if ((UserNameU != NULL) || (DomainNameU != NULL) || (PasswordU != NULL) || (PackageListU != NULL) || (CredFlags != 0))
        {
            CredSize = (((UserNameU != NULL) ? wcslen(UserNameU) + 1 : 0) +
                        ((DomainNameU != NULL) ? wcslen(DomainNameU) + 1 : 0 ) +
                        ((PackageListU != NULL) ? wcslen(PackageListU) + 1 : 0 ) +
                        ((PasswordU != NULL) ? wcslen(PasswordU) + 1 : 0) ) * sizeof(WCHAR) +
                        sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
            AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) LocalAlloc(LMEM_ZEROINIT,CredSize);
            if (NULL == AuthIdentity)
            {
                printf( "Failed : Allocation of AuthIdentity\n" );
                return;
            }

            AuthIdentity->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
            Where = (PUCHAR) (AuthIdentity + 1);

            if (UserNameU != NULL)
            {
                AuthIdentity->UserLength = wcslen(UserNameU);
                AuthIdentity->User = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    UserNameU
                    );
                Where += (wcslen(UserNameU) + 1) * sizeof(WCHAR);
            }

            if (DomainNameU != NULL)
            {
                AuthIdentity->DomainLength = wcslen(DomainNameU);
                AuthIdentity->Domain = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    DomainNameU
                    );
                Where += (wcslen(DomainNameU) + 1) * sizeof(WCHAR);
            }

            if (PasswordU != NULL)
            {
                AuthIdentity->PasswordLength = wcslen(PasswordU);
                AuthIdentity->Password = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    PasswordU
                    );
                Where += (wcslen(PasswordU) + 1) * sizeof(WCHAR);
            }
            AuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | CredFlags;
            if (PackageListU != NULL)
            {
                AuthIdentity->PackageListLength = wcslen(PackageListU);
                AuthIdentity->PackageList = (LPWSTR) Where;
                wcscpy(
                    (LPWSTR) Where,
                    PackageListU
                    );
                Where += (wcslen(PackageListU) + 1) * sizeof(WCHAR);
                AuthIdentity->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
            }

        }
    }
    else
    {
        if ((UserNameU != NULL) || (DomainNameU != NULL) || (PasswordU != NULL) || (PackageListU != NULL))
        {
            PSEC_WINNT_AUTH_IDENTITY_A Identity;
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_A);
            Identity = (PSEC_WINNT_AUTH_IDENTITY_A) LocalAlloc(LMEM_ZEROINIT,CredSize);
            if (NULL == Identity)
            {
                printf( "Failed : Allocation of Identity\n" );
                return;
            }

            if (UserNameU != NULL)
            {
                Identity->UserLength = wcslen(UserNameU);
                Identity->User = (LPSTR) UserNameA;
                wcstombs(UserNameA,UserNameU,100);
            }

            if (DomainNameU != NULL)
            {
                Identity->DomainLength = wcslen(DomainNameU);
                Identity->Domain = (LPSTR) DomainNameA;
                wcstombs(DomainNameA,DomainNameU,100);
            }

            if (PasswordU != NULL)
            {
                Identity->PasswordLength = wcslen(PasswordU);
                Identity->Password = (LPSTR) PasswordA;
                wcstombs(PasswordA,PasswordU,100);
            }
            Identity->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) Identity;
        }
    }


    if ((ServerUserNameU != NULL) || (ServerDomainNameU != NULL) || (ServerPasswordU != NULL))
    {
        CredSize = (((ServerUserNameU != NULL) ? wcslen(ServerUserNameU) + 1 : 0) +
                    ((ServerDomainNameU != NULL) ? wcslen(ServerDomainNameU) + 1 : 0 ) +
                    ((ServerPasswordU != NULL) ? wcslen(ServerPasswordU) + 1 : 0) ) * sizeof(WCHAR) +
                    sizeof(SEC_WINNT_AUTH_IDENTITY);
        ServerAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) LocalAlloc(LMEM_ZEROINIT,CredSize);
        if (NULL == ServerAuthIdentity)
        {
            printf( "Failed : Allocation of ServerAuthIdentity\n" );
            return;
        }

        Where = (PUCHAR) (ServerAuthIdentity + 1);

        if (ServerUserNameU != NULL)
        {
            ServerAuthIdentity->UserLength = wcslen(ServerUserNameU);
            ServerAuthIdentity->User = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerUserNameU
                );
            Where += (wcslen(ServerUserNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerDomainNameU != NULL)
        {
            ServerAuthIdentity->DomainLength = wcslen(ServerDomainNameU);
            ServerAuthIdentity->Domain = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerDomainNameU
                );
            Where += (wcslen(ServerDomainNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerPasswordU != NULL)
        {
            ServerAuthIdentity->PasswordLength = wcslen(ServerPasswordU);
            ServerAuthIdentity->Password = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerPasswordU
                );
            Where += (wcslen(ServerPasswordU) + 1) * sizeof(WCHAR);
        }
        ServerAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | SEC_WINNT_AUTH_IDENTITY_MARSHALLED;

    }

    CredNames.sUserName = NULL;
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;


    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //
    if (ServerCredHandle == NULL)
    {

        ServerCredHandle = &ServerCredHandleStorage;
        AcquiredServerCred = TRUE;

        SecStatus = AcquireCredentialsHandle(
                        NULL,
                        PackageName,
                        SECPKG_CRED_INBOUND,
                        NULL,
                        ServerAuthIdentity,
                        NULL,
                        NULL,
                        ServerCredHandle,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "AcquireCredentialsHandle failed: ");
            PrintStatus( SecStatus );
            return;
        }

        if ( !QuietMode ) {
            printf( "ServerCredHandle: 0x%lx 0x%lx   ",
                    ServerCredHandle->dwLower, ServerCredHandle->dwUpper );
            PrintTime( "Lifetime: ", Lifetime );
            GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
            FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
            PrintTime( "Current Time: ", stLocal);
        }

    }

    //
    // Acquire a credential handle for the client side
    //



    if (!DoAnsi)
    {
        SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        PackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        AuthIdentity,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );
    }
    else
    {
        CHAR AnsiPackageName[100];
        wcstombs(AnsiPackageName, PackageName, 100);
        SecStatus = AcquireCredentialsHandleA(
                        NULL,           // New principal
                        AnsiPackageName,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        AuthIdentity,
                        NULL,
                        NULL,
                        &CredentialHandle2,
                        &Lifetime );

    }

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    //
    // Query some cred attributes
    //

    SecStatus = QueryCredentialsAttributes(
                    &CredentialHandle2,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryCredentialsAttributes (Client) (names): " );
        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
    }
    else
    {
        printf("Client credential names: %ws\n",CredNames.sUserName);
        FreeContextBuffer(CredNames.sUserName);

    }

    //
    // Do the same for the client
    //

    SecStatus = QueryCredentialsAttributes(
                    ServerCredHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryCredentialsAttributes (Server) (names): " );
        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
    } else {
        printf("Server credential names: %ws\n",CredNames.sUserName);
        FreeContextBuffer(CredNames.sUserName);

    }


    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    if (ContextReq == 0)
    {
        ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY; // USE_DCE_STYLE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_SESSION_KEY; //  | ISC_REQ_DATAGRAM;
    }
    else
    {
        ClientFlags = ContextReq;
    }

    Calls++;

    if (ARGUMENT_PRESENT(TargetNameU))
    {
        wcscpy(TargetName, TargetNameU);
    }
    else if (ARGUMENT_PRESENT(ServerUserNameU) && ARGUMENT_PRESENT(ServerDomainNameU))
    {
        wcscpy(
            TargetName,
            ServerDomainNameU
            );
        wcscat(
            TargetName,
            L"\\"
            );
        wcscat(
            TargetName,
            ServerUserNameU
            );
    }
    else
    {
        wcscpy(
            TargetName,
            DomainName
            );
        wcscat(
            TargetName,
            L"\\"
            );
        wcscat(
            TargetName,
            UserName
            );
    }

    InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetName,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);

        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


Redo:

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        if (AuthenticateBuffer.pvBuffer == NULL) {
            AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
            if ( AuthenticateBuffer.pvBuffer == NULL ) {
                printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
                return;
            }
        }

        InitStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        ClientFlags,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( InitStatus != STATUS_SUCCESS ) {
            printf( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( InitStatus );
            if ( !NT_SUCCESS(InitStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "\n\nAuthenticate Message:\n" );

            printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );
            GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
            FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
            PrintTime( "Current Time: ", stLocal);

            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
            ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;

            AcceptStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            &ChallengeDesc,
                            &ContextAttributes,
                            &Lifetime );

            if ( AcceptStatus != STATUS_SUCCESS ) {
                printf( "AcceptSecurityContext (Challenge): " );
                PrintStatus( AcceptStatus );
                if ( !NT_SUCCESS(AcceptStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                printf( "\n\nFinal Authentication:\n" );

                printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
                FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
                PrintTime( "Current Time: ", stLocal);
                printf(" \n" );
                DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
            }

            if (InitStatus != STATUS_SUCCESS)
            {
                goto Redo;
            }
        }

    }

#ifdef notdef
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif





    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_FLAGS,
                    &ContextFlags );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (flags): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryFlags: 0x%x\n",
                    ContextFlags.Flags );
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_KEY_INFO,
                    &KeyInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (KeyInfo): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryKeyInfo:\n");

        printf("Signature algorithm = %ws\n",KeyInfo.sSignatureAlgorithmName);
        printf("Encrypt algorithm = %ws\n",KeyInfo.sEncryptAlgorithmName);
        printf("KeySize = %d\n",KeyInfo.KeySize);
        printf("Signature Algorithm = %d\n",KeyInfo.SignatureAlgorithm);
        printf("Encrypt Algorithm = %d\n",KeyInfo.EncryptAlgorithm);

        FreeContextBuffer(
            KeyInfo.sSignatureAlgorithmName
            );
        FreeContextBuffer(
            KeyInfo.sEncryptAlgorithmName
            );
    }



    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames for ServerContextHandle: %ws\n", ContextNames->sUserName );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes for client context (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames for ClientContextHandle: %ws\n", ContextNames->sUserName );
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_NATIVE_NAMES,
                    &NativeNames );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (Nativenames): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    if ( !QuietMode ) {
        printf( "QueryNativeNames for ServerContextHandle: %ws, %ws\n",
            STRING_OR_NULL(NativeNames.sClientName),
            STRING_OR_NULL(NativeNames.sServerName) );

    }
    if (NativeNames.sClientName != NULL)
    {
        FreeContextBuffer(NativeNames.sClientName);
    }
    if (NativeNames.sServerName != NULL)
    {
        FreeContextBuffer(NativeNames.sServerName);
    }
    if (!DoAnsi)
    {
        SecStatus = QueryContextAttributes(
                        &ClientContextHandle,
                        SECPKG_ATTR_NATIVE_NAMES,
                        &NativeNames );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "QueryContextAttributes (Nativenames): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "QueryNativeNames for ClientContextHandle: %ws, %ws\n",
                STRING_OR_NULL(NativeNames.sClientName),
                STRING_OR_NULL(NativeNames.sServerName) );

        }
    }
    else
    {
        SecStatus = QueryContextAttributesA(
                        &ClientContextHandle,
                        SECPKG_ATTR_NATIVE_NAMES,
                        &NativeNamesA );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "QueryContextAttributes (Nativenames): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        NativeNames = *(PSecPkgContext_NativeNames) &NativeNamesA;

        if ( !QuietMode ) {
            printf( "QueryNativeNames for ClientContextHandle: %s, %s\n",
                STRING_OR_NULLA(NativeNamesA.sClientName),
                STRING_OR_NULLA(NativeNamesA.sServerName) );
        }


    }

    if (NativeNames.sClientName != NULL)
    {
        FreeContextBuffer(NativeNames.sClientName);
    }
    if (NativeNames.sServerName != NULL)
    {
        FreeContextBuffer(NativeNames.sServerName);
    }


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_DCE_INFO,
                    &ContextDceInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryDceInfo: %ws\n", ContextDceInfo.pPac );
    }


    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PrintTime("   Start:", ContextLifespan.tsStart );
        PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
        FileTimeToLocalFileTime ((PFILETIME)&CurrentTime, (PFILETIME)&stLocal );
        PrintTime( "Current Time: ", stLocal);
    }

    SecStatus = QueryContextAttributes(
                    &ServerContextHandle,
                    SECPKG_ATTR_PACKAGE_INFO,
                    &ContextPackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (PackageInfo): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "PackageInfo: %ws %ws %d\n",
                    ContextPackageInfo.PackageInfo->Name,
                    ContextPackageInfo.PackageInfo->Comment,
                    ContextPackageInfo.PackageInfo->wRPCID
                    );
    }
    FreeContextBuffer(ContextPackageInfo.PackageInfo);

    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Get the UserName
    //

    {
        PUNICODE_STRING UserNameLsa;
        PUNICODE_STRING DomainNameLsa;
        NTSTATUS Status;

        Status = LsaGetUserName( &UserNameLsa, &DomainNameLsa );
        if (NT_SUCCESS(Status))
        {
            printf("Lsa username = %wZ\\%wZ\n",DomainNameLsa, UserNameLsa );
            LsaFreeMemory(
                UserNameLsa->Buffer);
            LsaFreeMemory(UserNameLsa);
            LsaFreeMemory(DomainNameLsa->Buffer);
            LsaFreeMemory(DomainNameLsa);
        }
        else
        {
            printf("Failed LsaGetUserName: 0x%x\n",Status);
        }
    }


    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }

    }

    //
    // If delegation is enabled and we are below our recursion depth, try
    // this again.
    //
    if ((ClientFlags & ISC_REQ_DELEGATE) && (++RecursionDepth < MaxRecursionDepth))
    {
        TestSspRoutine(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, ClientFlags, CredFlags);
    }

    //
    // RevertToSelf (ServerSide)
    //

//    SecStatus = RevertSecurityContext( &ServerContextHandle );
//
//    if ( SecStatus != STATUS_SUCCESS ) {
//        printf( "RevertSecurityContext: " );
//        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
//    }


#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

//    if (!RevertToSelf())
//    {
//        printf( "RevertToSelf failed: %d\n ",GetLastError() );
//        return;
//    }
    CloseHandle(Token);
#endif

    //
    // Sign a message
    //

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Encrypt a message
    //

    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, 60);
    memset(
        pbSealBuffer,
        0xeb,
        60
        );

    SigBuffers[1].cbBuffer = 60;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = EncryptMessage(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Encrypt Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Decrypt the message
    //

    for (Index = 1; Index < 4 ; Index++ )
    {
        SigBuffers[Index].cbBuffer = 20;
        SigBuffers[Index].pvBuffer = pbSealBuffer + (Index - 1) * 20;
        SigBuffers[Index].BufferType = SECBUFFER_DATA;
    }
    SignMessage.cBuffers = 4;
    SecStatus = DecryptMessage(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Now try the opposite.
    //

    //
    // Encrypt a message
    //

    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, 60);
    memset(
        pbSealBuffer,
        0xeb,
        60
        );

    SigBuffers[1].cbBuffer = 60;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = EncryptMessage(
                        &ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Encrypt Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Decrypt the message
    //

    for (Index = 1; Index < 4 ; Index++ )
    {
        SigBuffers[Index].cbBuffer = 20;
        SigBuffers[Index].pvBuffer = pbSealBuffer + (Index - 1) * 20;
        SigBuffers[Index].BufferType = SECBUFFER_DATA;
    }
    SignMessage.cBuffers = 4;
    SecStatus = DecryptMessage(
                        &ClientContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


#if 1
#define BIG_BUFFER_SIZE 144770
    SigBuffers[0].pvBuffer = bSigBuffer;
    SigBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
    SigBuffers[0].BufferType = SECBUFFER_TOKEN;

    pbSealBuffer = (PBYTE) LocalAlloc(0, BIG_BUFFER_SIZE);
    memset(
        pbSealBuffer,
        0xeb,
        BIG_BUFFER_SIZE
        );

    SigBuffers[1].cbBuffer = BIG_BUFFER_SIZE;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = pbSealBuffer;

    SigBuffers[2].cbBuffer = ContextSizes.cbBlockSize;
    SigBuffers[2].BufferType = SECBUFFER_PADDING;
    SigBuffers[2].pvBuffer = LocalAlloc(LMEM_ZEROINIT, ContextSizes.cbBlockSize);

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 3;
    SignMessage.ulVersion = 0;

    SecStatus = EncryptMessage(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "Big EncryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Decrypt the message
    //

    cbWholeBuffer = SigBuffers[0].cbBuffer +
                    SigBuffers[1].cbBuffer +
                    SigBuffers[2].cbBuffer;

    pbWholeBuffer = (PBYTE) LocalAlloc(LMEM_ZEROINIT, cbWholeBuffer);
    RtlCopyMemory(
        pbWholeBuffer,
        SigBuffers[0].pvBuffer,
        SigBuffers[0].cbBuffer
        );
    RtlCopyMemory(
        pbWholeBuffer + SigBuffers[0].cbBuffer,
        SigBuffers[1].pvBuffer,
        SigBuffers[1].cbBuffer
        );
    RtlCopyMemory(
        pbWholeBuffer + SigBuffers[0].cbBuffer + SigBuffers[1].cbBuffer,
        SigBuffers[2].pvBuffer,
        SigBuffers[2].cbBuffer
        );


    SigBuffers[0].pvBuffer = pbWholeBuffer;
    SigBuffers[0].cbBuffer = cbWholeBuffer;
    SigBuffers[0].BufferType = SECBUFFER_STREAM;


    SigBuffers[1].cbBuffer = 0;
    SigBuffers[1].BufferType = SECBUFFER_DATA;
    SigBuffers[1].pvBuffer = NULL;
    SignMessage.cBuffers = 2;
    SignMessage.pBuffers = SigBuffers;

    SecStatus = DecryptMessage(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "Big DecryptMessage: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


#endif

    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Export & Import contexts
    //

    for (Index = 0; Index < 3 ; Index++ )
    {
        SecStatus = ExportSecurityContext(
                        &ClientContextHandle,
                        SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                        &MarshalledContext,
                        &TokenHandle
                        );
        if (!NT_SUCCESS(SecStatus))
        {
            printf("Failed to export context: ");
            PrintStatus(SecStatus);
        }
        else
        {
            SecStatus = ImportSecurityContext(
                            PackageName,
                            &MarshalledContext,
                            TokenHandle,
                            &ClientContextHandle
                            );
            if (!NT_SUCCESS(SecStatus))
            {
                printf("Failed to import context: ");
                PrintStatus(SecStatus);
                return;
            }

            //
            // Sign a message again, using the imported context
            //

            SigBuffers[1].pvBuffer = bSigBuffer;
            SigBuffers[1].cbBuffer = ContextSizes.cbMaxSignature;
            SigBuffers[1].BufferType = SECBUFFER_TOKEN;

            SigBuffers[0].pvBuffer = bDataBuffer;
            SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
            SigBuffers[0].BufferType = SECBUFFER_DATA;
            memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

            SignMessage.pBuffers = SigBuffers;
            SignMessage.cBuffers = 2;
            SignMessage.ulVersion = 0;

            SecStatus = MakeSignature(
                                &ClientContextHandle,
                                0,
                                &SignMessage,
                                0 );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "MakeSignature: " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {

                printf("\n Signature: \n");
                DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

            }


            //
            // Verify the signature
            //

            SecStatus = VerifySignature(
                                &ServerContextHandle,
                                &SignMessage,
                                0,
                                0 );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "VerifySignature: " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }



        }
    }


    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext( ClientContext %x : %x ) failed: ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext( ServerContext %x : %x ) failed: ",
                    ServerContextHandle.dwLower, ServerContextHandle.dwUpper );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    if (AcquiredServerCred)
    {
        SecStatus = FreeCredentialsHandle( ServerCredHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "FreeCredentialsHandle failed: " );
            PrintStatus( SecStatus );
            return;
        }
        ServerCredHandle = NULL;

    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN ULONG Count,
    IN BOOLEAN Relogon,
    IN SECURITY_LOGON_TYPE LogonType,
    IN LPSTR PackageName,
    IN LPSTR UserName,
    IN LPSTR DomainName,
    IN LPSTR Password
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_LOGON LogonInfo;
    PKERB_INTERACTIVE_UNLOCK_LOGON UnlockLogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;
    ULONG Index;
    HANDLE ThreadTokenHandle = NULL;
    LARGE_INTEGER StartTime, EndTime;

    printf("Logging On %s\\%s %s\n",DomainName, UserName, Password);
    if (Relogon)
    {
        LogonInfoSize = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    LogonInfoSize += (strlen(UserName) + ((DomainName == NULL)? 0 : strlen(DomainName)) + strlen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PKERB_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (NULL == LogonInfo)
    {
        printf("Failed to allocate LogonInfo\n");
        return;
    }

    LogonInfo->MessageType = KerbInteractiveLogon;

    RtlInitString(
        &Name,
        UserName
        );

    if (Relogon)
    {
        Where = ((PUCHAR) LogonInfo) + sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    else
    {
        Where = (PUCHAR) (LogonInfo + 1);
    }

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->UserName,
        &Name,
        FALSE
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->LogonDomainName,
        &Name,
        FALSE
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Password,
        &Name,
        FALSE
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = KerbInteractiveLogon;

    if (Relogon)
    {
        HANDLE ProcessToken = NULL;
        TOKEN_STATISTICS Stats;
        ULONG StatsSize = sizeof(TOKEN_STATISTICS);

        if (OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken))
        {
            if (GetTokenInformation(
                    ProcessToken,
                    TokenStatistics,
                    &Stats,
                    StatsSize,
                    &StatsSize
                    ))
            {
                PKERB_INTERACTIVE_UNLOCK_LOGON UnlockLogonInfo = (PKERB_INTERACTIVE_UNLOCK_LOGON) LogonInfo;

                UnlockLogonInfo->LogonId = Stats.AuthenticationId;
                LogonInfo->MessageType = KerbWorkstationUnlockLogon;
            }
            else
            {
                printf("Failed to get token info: %d\n",GetLastError());
            }
        }
        else
        {
            printf("Failed to open process token info: %d\n",GetLastError());
        }
    }
    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, (BOOLEAN) OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&ThreadTokenHandle) , &WasEnabled);
    if (ThreadTokenHandle != NULL)
    {
        CloseHandle(ThreadTokenHandle);
        ThreadTokenHandle = NULL;
    }
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        PackageName
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    for (Index = 0; Index < Count ; Index++ )
    {
        NtQuerySystemTime(&StartTime);
        Status = LsaLogonUser(
                    LogonHandle,
                    &Name,
                    LogonType,
                    PackageId,
                    LogonInfo,
                    LogonInfoSize,
                    NULL,           // no token groups
                    &SourceContext,
                    (PVOID *) &Profile,
                    &ProfileSize,
                    &LogonId,
                    &TokenHandle,
                    &Quotas,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("lsalogonuser failed: 0x%x\n",Status);
            return;
        }
        if (!NT_SUCCESS(SubStatus))
        {
            printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
            return;
        }

        NtQuerySystemTime(&EndTime);
        printf("logon took %d ms\t\t",(EndTime.QuadPart-StartTime.QuadPart) / 10000);
        PrintTime("", EndTime);
        ImpersonateLoggedOnUser( TokenHandle );
        GetUserName(UserNameString,&NameLength);
        printf("Username = %ws\n",UserNameString);
        RevertToSelf();
        NtClose(TokenHandle);

        LsaFreeReturnBuffer(Profile);
        Profile = NULL;

    }

}



VOID
TestS4ULogonRoutine(
    IN LPSTR UserName,
    IN LPSTR DomainName
    )
{
    NTSTATUS Status;
    PKERB_S4U_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_S4U_LOGON);
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    printf("S4U LogOn %s\\%s\n",((DomainName == NULL)? "<NULL>" : DomainName), UserName);
    LogonInfoSize += (strlen(UserName)+1) * sizeof(WCHAR);
    LogonInfoSize += ((DomainName == NULL) ? 0 : ((strlen(DomainName) +1) * sizeof(WCHAR)));
    
    LogonInfo = (PKERB_S4U_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (NULL == LogonInfo)
    {
        return;
    }


    LogonInfo->MessageType = KerbS4ULogon;

    RtlInitString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->ClientUpn.Buffer = (LPWSTR) Where;
    LogonInfo->ClientUpn.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->ClientUpn,
        &Name,
        FALSE
        );
    Where += LogonInfo->ClientUpn.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->ClientRealm.Buffer = (LPWSTR) Where;
    LogonInfo->ClientRealm.MaximumLength = (USHORT) LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->ClientRealm,
        &Name,
        FALSE
        );
    Where += LogonInfo->ClientRealm.Length + sizeof(WCHAR);

    
    //
    // Turn on the TCB privilege
    //

    /*Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    } */
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &Name,
                Network,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        return;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
        return;
    }

    ImpersonateLoggedOnUser( TokenHandle );
    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();
    NtClose(TokenHandle);



}


VOID
PrintKdcName(
    IN PKERB_EXTERNAL_NAME Name
    )
{
    ULONG Index;
    if (Name == NULL)
    {
        printf("(null)");
    }
    else
    {
        for (Index = 0; Index < Name->NameCount ; Index++ )
        {
            printf(" %wZ ",&Name->Names[Index]);
        }
    }
    printf("\n");
}


#ifdef notdef
//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbCredFromExternalTickets
//
//  Synopsis:   Builds a marshalled KERB_CRED structure
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  Ticket - The ticket of the session key to seal the
//                      encrypted portion
//              DelegationTicket - The ticket to marshall into the cred message
//              MarshalledKerbCred - Receives a marshalled KERB_CRED structure
//              KerbCredSizes - Receives size, in bytes, of marshalled
//                      KERB_CRED.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildKerbCredFromExternalTickets(
    IN PKERB_EXTERNAL_TICKET Ticket,
    IN PKERB_EXTERNAL_TICKET DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_CRED KerbCred;
    KERB_CRED_INFO_LIST CredInfo;
    KERB_ENCRYPTED_CRED EncryptedCred;
    KERB_CRED_TICKET_LIST TicketList;
    ULONG EncryptionOverhead;
    ULONG BlockSize;
    PUCHAR MarshalledEncryptPart = NULL;
    ULONG MarshalledEncryptSize;
    ULONG ConvertedFlags;
    PKERB_TICKET DecodedTicket = NULL;


    //
    // Initialize the structures so they can be freed later.
    //

    *MarshalledKerbCred = NULL;
    *KerbCredSize = 0;

    RtlZeroMemory(
        &KerbCred,
        sizeof(KERB_CRED)
        );

    RtlZeroMemory(
        &EncryptedCred,
        sizeof(KERB_ENCRYPTED_CRED)
        );
    RtlZeroMemory(
        &CredInfo,
        sizeof(KERB_CRED_INFO_LIST)
        );
    RtlZeroMemory(
        &TicketList,
        sizeof(KERB_CRED_TICKET_LIST)
        );

    KerbCred.version = KERBEROS_VERSION;
    KerbCred.message_type = KRB_CRED;


    //
    // Decode the ticket so we can put it in the structure (to re-encode it)
    //

    KerbErr = KerbUnpackData(
                DelegationTicket->EncodedTicket,
                DelegationTicket->EncodedTicketSize,
                KERB_TICKET_PDU,
                (PVOID *) &DecodedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack encoded ticket: 0x%x\n",KerbErr);
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // First stick the ticket into the ticket list.
    //


    TicketList.next= NULL;
    TicketList.value = *DecodedTicket;
    KerbCred.tickets = &TicketList;

    //
    // Now build the KERB_CRED_INFO for this ticket
    //

    CredInfo.value.key = * (PKERB_ENCRYPTION_KEY) &DelegationTicket->SessionKey;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.endtime,
        NULL,
        &DelegationTicket->EndTime
        );
    CredInfo.value.bit_mask |= endtime_present;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.KERB_CRED_INFO_renew_until,
        NULL,
        &DelegationTicket->RenewUntil
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_renew_until_present;
    ConvertedFlags = KerbConvertUlongToFlagUlong(DelegationTicket->TicketFlags);
    CredInfo.value.flags.value = (PUCHAR) &ConvertedFlags;
    CredInfo.value.flags.length = 8 * sizeof(ULONG);
    CredInfo.value.bit_mask |= flags_present;

    //
    // The following fields are marked as optional but treated
    // as mandatory by the MIT implementation of Kerberos.
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.sender_name,
                (PKERB_INTERNAL_NAME) DelegationTicket->ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= sender_name_present;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.principal_name,
                (PKERB_INTERNAL_NAME) DelegationTicket->ServiceName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= principal_name_present;

    //
    // NOTE: we are assuming that because we are sending a TGT the
    // client realm is the same as the serve realm. If we ever
    // send non-tgt or cross-realm tgt, this needs to be fixed.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &CredInfo.value.principal_realm,
                &DelegationTicket->DomainName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // The realms are the same, so don't allocate both
    //

    CredInfo.value.sender_realm = CredInfo.value.principal_realm;
    CredInfo.value.bit_mask |= principal_realm_present | sender_realm_present;

    EncryptedCred.ticket_info = &CredInfo;


    //
    // Now encrypted the encrypted cred into the cred
    //

    if (!KERB_SUCCESS(KerbPackEncryptedCred(
            &EncryptedCred,
            &MarshalledEncryptSize,
            &MarshalledEncryptPart
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we are doing DES encryption, then we are talking with an non-NT
    // server. Hence, don't encrypt the kerb-cred.
    //

    if ((Ticket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_CRC) ||
        (Ticket->SessionKey.KeyType == KERB_ETYPE_DES_CBC_MD5))
    {
        KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
        KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
        KerbCred.encrypted_part.encryption_type = 0;
        MarshalledEncryptPart = NULL;

    }
    else
    {
        //
        // Now get the encryption overhead
        //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    Ticket->SessionKey.KeyType,
                    MarshalledEncryptSize,
                    &KerbCred.encrypted_part.cipher_text.length,
                    &KerbCred.encrypted_part.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }



        //
        // Encrypt the data.
        //

        KerbErr = KerbEncryptDataEx(
                    &KerbCred.encrypted_part,
                    MarshalledEncryptSize,
                    MarshalledEncryptPart,
                    Ticket->SessionKey.KeyType,
                    KERB_CRED_SALT,
                    (PKERB_ENCRYPTION_KEY) &Ticket->SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Now we have to marshall the whole KERB_CRED
    //

    if (!KERB_SUCCESS(KerbPackKerbCred(
            &KerbCred,
            KerbCredSize,
            MarshalledKerbCred
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:

    if (DecodedTicket != NULL)
    {
        KerbFreeData(
            KERB_TICKET_PDU,
            DecodedTicket
            );
    }
    KerbFreePrincipalName(&CredInfo.value.sender_name);

    KerbFreePrincipalName(&CredInfo.value.principal_name);

    KerbFreeRealm(&CredInfo.value.principal_realm);

    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }
    if (KerbCred.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(KerbCred.encrypted_part.cipher_text.value);
    }
    return(Status);
}

#endif

VOID
TestCallPackageRoutine(
    IN LPWSTR Function
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    KERB_DEBUG_REQUEST DebugRequest;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    PKERB_EXTERNAL_TICKET CacheEntry = NULL;
    ULONG Index;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    if (_wcsicmp(Function,L"bp") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_BREAKPOINT;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsicmp(Function,L"tickets")  == 0)
    {
        CacheRequest.MessageType = KerbQueryTicketCacheMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheResponse,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("bp failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached Tickets:\n");
            for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ )
            {
                printf("\tServer: %wZ@%wZ\n",
                    &CacheResponse->Tickets[Index].ServerName,
                    &CacheResponse->Tickets[Index].RealmName);
                PrintTime("\t\tStart Time: ",CacheResponse->Tickets[Index].StartTime);
                PrintTime("\t\tEnd Time: ",CacheResponse->Tickets[Index].EndTime);
                PrintTime("\t\tRenew Time: ",CacheResponse->Tickets[Index].RenewTime);
                printf("\t\tEncryptionType: %d\n",CacheResponse->Tickets[Index].EncryptionType);
                printf("\t\tTicketFlags: 0x%x\n",CacheResponse->Tickets[Index].TicketFlags);

            }
        }


    }
    else if (_wcsicmp(Function,L"tgt") == 0)
    {
        CacheRequest.MessageType = KerbRetrieveTicketMessage;
        CacheRequest.LogonId.LowPart = 0;
        CacheRequest.LogonId.HighPart = 0;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    (PVOID *) &CacheEntry,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("query tgt failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            printf("Cached TGT:\n");
            printf("ServiceName: "); PrintKdcName(CacheEntry->ServiceName);
            printf("TargetName: "); PrintKdcName(CacheEntry->TargetName);
            printf("DomainName: %wZ\n",&CacheEntry->DomainName);
            printf("TargetDomainName: %wZ\n",&CacheEntry->TargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheEntry->ClientName);
            printf("TicketFlags: 0x%x\n",CacheEntry->TicketFlags);
            PrintTime("KeyExpirationTime: ",CacheEntry->KeyExpirationTime);
            PrintTime("StartTime: ",CacheEntry->StartTime);
            PrintTime("StartTime: ",CacheEntry->StartTime);
            PrintTime("EndTime: ",CacheEntry->EndTime);
            PrintTime("RenewUntil: ",CacheEntry->RenewUntil);
            PrintTime("TimeSkew: ",CacheEntry->TimeSkew);
            LsaFreeReturnBuffer(CacheEntry);
        }

    }
    else if (_wcsicmp(Function,L"stats")  == 0)
    {
        PKERB_DEBUG_REPLY DbgReply;
        PKERB_DEBUG_STATS DbgStats;
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_REQ_STATISTICS;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("stats failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            DbgReply = (PKERB_DEBUG_REPLY) Response;
            if (DbgReply->MessageType != KerbDebugRequestMessage)
            {
                printf("Wrong return message type: %d\n",DbgReply->MessageType);
                return;
            }
            DbgStats = (PKERB_DEBUG_STATS) DbgReply->Data;
            printf("Cache hits = %d\n",DbgStats->CacheHits);
            printf("Cache Misses = %d\n",DbgStats->CacheMisses);
            printf("Skewed Requets = %d\n",DbgStats->SkewedRequests);
            printf("Success Requets = %d\n",DbgStats->SuccessRequests);
            PrintTime("Last Sync = ",DbgStats->LastSync);
        }
        LsaFreeReturnBuffer(Response);
    }
    else if (_wcsicmp(Function,L"token") == 0)
    {
        DebugRequest.MessageType = KerbDebugRequestMessage;
        DebugRequest.DebugRequest = KERB_DEBUG_CREATE_TOKEN;

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    &DebugRequest,
                    sizeof(DebugRequest),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }

    }
    else if (_wcsnicmp(Function,L"purge:", wcslen(L"purge:")) == 0)
    {
        PKERB_PURGE_TKT_CACHE_REQUEST CacheRequest = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"purge:")
            );




        CacheRequest = (PKERB_PURGE_TKT_CACHE_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_PURGE_TKT_CACHE_REQUEST));

        CacheRequest->MessageType = KerbPurgeTicketCacheMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        for (Index = 0; Index < Target.Length / sizeof(WCHAR);  Index++ )
        {
            if (Target.Buffer[Index] == L'@')
            {
                CacheRequest->ServerName.Buffer = Target.Buffer;
                CacheRequest->ServerName.Length = 2*Index;
                CacheRequest->ServerName.MaximumLength = CacheRequest->ServerName.Length;
                CacheRequest->RealmName.Buffer = Target.Buffer+Index+1;
                CacheRequest->RealmName.Length = Target.Length - 2*(Index+1);
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                break;
            }
            else if (Target.Buffer[Index] == L'\\')
            {
                CacheRequest->RealmName.Buffer = Target.Buffer;
                CacheRequest->RealmName.Length = 2*Index;
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                CacheRequest->ServerName.Buffer = Target.Buffer+Index+1;
                CacheRequest->ServerName.Length = Target.Length - 2*(Index+1);
                CacheRequest->ServerName.MaximumLength = CacheRequest->ServerName.Length;
                break;
            }
        }

        printf("Deleting tickets: %wZ\\%wZ\n",
            &CacheRequest->RealmName, &CacheRequest->ServerName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_PURGE_TKT_CACHE_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }


    }
    else if (_wcsnicmp(Function,L"retrieve:", wcslen(L"retrieve:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"retrieve:")
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            printf("Cached Ticket:\n");
            printf("ServiceName: "); PrintKdcName(CacheResponse->Ticket.ServiceName);
            printf("TargetName: "); PrintKdcName(CacheResponse->Ticket.TargetName);
            printf("DomainName: %wZ\n",&CacheResponse->Ticket.DomainName);
            printf("TargetDomainName: %wZ\n",&CacheResponse->Ticket.TargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheResponse->Ticket.ClientName);
            printf("TicketFlags: 0x%x\n",CacheResponse->Ticket.TicketFlags);
            PrintTime("KeyExpirationTime: ",CacheResponse->Ticket.KeyExpirationTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("EndTime: ",CacheResponse->Ticket.EndTime);
            PrintTime("RenewUntil: ",CacheResponse->Ticket.RenewUntil);
            PrintTime("TimeSkew: ",CacheResponse->Ticket.TimeSkew);
            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"decode:", wcslen(L"decode:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Realm = {0};
        UNICODE_STRING Server = {0};
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"decode:")
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            PKERB_DECRYPT_REQUEST DecryptRequest = NULL;
            PKERB_DECRYPT_RESPONSE DecryptResponse = NULL;
            ULONG DecryptRequestSize = 0;
            ULONG DecryptResponseSize = 0;
            PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
            PKERB_TICKET DecodedTicket = NULL;
            KERBERR KerbErr;

            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            KerbErr = KerbUnpackData(
                        CacheResponse->Ticket.EncodedTicket,
                        CacheResponse->Ticket.EncodedTicketSize,
                        KERB_TICKET_PDU,
                        (PVOID *) &DecodedTicket
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to decode ticket: 0x%x\n",KerbErr);
                return;
            }


            //
            // Now try to decrypt the ticket with our default key
            //

            DecryptRequestSize = sizeof(KERB_DECRYPT_REQUEST) +
                                    DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest = (PKERB_DECRYPT_REQUEST) LocalAlloc(LMEM_ZEROINIT, DecryptRequestSize);

            DecryptRequest->MessageType = KerbDecryptDataMessage;
            DecryptRequest->Flags = KERB_DECRYPT_FLAG_DEFAULT_KEY;
            DecryptRequest->InitialVectorSize = 0;
            DecryptRequest->InitialVector = NULL;
            DecryptRequest->KeyUsage = KERB_TICKET_SALT;
            DecryptRequest->CryptoType = DecodedTicket->encrypted_part.encryption_type;
            DecryptRequest->EncryptedDataSize = DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest->EncryptedData = (PUCHAR) (DecryptRequest + 1);
            RtlCopyMemory(
                DecryptRequest->EncryptedData,
                DecodedTicket->encrypted_part.cipher_text.value,
                DecryptRequest->EncryptedDataSize
                );


            Status = LsaCallAuthenticationPackage(
                        LogonHandle,
                        PackageId,
                        DecryptRequest,
                        DecryptRequestSize,
                        (PVOID *) &DecryptResponse,
                        &DecryptResponseSize,
                        &SubStatus
                        );
            if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
            {
                printf("Failed to decrypt message: 0x%x or 0x%x\n",Status,SubStatus);
                return;
            }

            //
            // Now decode the encrypted ticket
            //

            KerbErr = KerbUnpackData(
                            DecryptResponse->DecryptedData,
                            DecryptResponseSize,
                            KERB_ENCRYPTED_TICKET_PDU,
                            (PVOID *) &EncryptedTicket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to unpack encrypted ticket: 0x%x\n",KerbErr);
                return;
            }

            //
            // Now print some fields
            //

            printf("Enc.Ticket client_realm = %s\n",EncryptedTicket->client_realm);
            printf("Enc.Ticket. client_name = %s\n",EncryptedTicket->client_name.name_string->value);

            LsaFreeReturnBuffer(DecryptResponse);


            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"decrypt:", wcslen(L"decrypt:")) == 0)
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        UNICODE_STRING Password = {0};
        UNICODE_STRING EmptyString = {0};
        KERB_ENCRYPTION_KEY Key = {0};
        USHORT Index;
        KERBERR KerbErr;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"decrypt:")
            );

        for (Index = 0; Index < Target2.Length / sizeof(WCHAR) ; Index ++ )
        {
            if (Target2.Buffer[Index] == L':')
            {
                Password = Target2;
                Password.Length = Index*2;
                Target2.Buffer = Target2.Buffer+Index+1;
                Target2.Length -= (Index+1)*2;
            }
        }


        printf("Decrypting with key %wZ\n",&Password);


        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            PKERB_DECRYPT_REQUEST DecryptRequest = NULL;
            PKERB_DECRYPT_RESPONSE DecryptResponse = NULL;
            ULONG DecryptRequestSize = 0;
            ULONG DecryptResponseSize = 0;
            PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
            PKERB_TICKET DecodedTicket = NULL;

            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            KerbErr = KerbUnpackData(
                        CacheResponse->Ticket.EncodedTicket,
                        CacheResponse->Ticket.EncodedTicketSize,
                        KERB_TICKET_PDU,
                        (PVOID *) &DecodedTicket
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to decode ticket: 0x%x\n",KerbErr);
                return;
            }

            KerbErr = KerbHashPasswordEx(
                        &Password,
                        &EmptyString,
                        DecodedTicket->encrypted_part.encryption_type,
                        &Key
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to hash key %wZ with type %d\n",
                    &Password,
                    DecodedTicket->encrypted_part.encryption_type
                    );
                return;
            }


            //
            // Now try to decrypt the ticket with our default key
            //

            DecryptRequestSize = sizeof(KERB_DECRYPT_REQUEST) +
                                    DecodedTicket->encrypted_part.cipher_text.length +
                                    Key.keyvalue.length;
            DecryptRequest = (PKERB_DECRYPT_REQUEST) LocalAlloc(LMEM_ZEROINIT, DecryptRequestSize);

            DecryptRequest->MessageType = KerbDecryptDataMessage;
            DecryptRequest->Flags = 0;
            DecryptRequest->InitialVectorSize = 0;
            DecryptRequest->InitialVector = NULL;
            DecryptRequest->KeyUsage = KERB_TICKET_SALT;
            DecryptRequest->CryptoType = DecodedTicket->encrypted_part.encryption_type;
            DecryptRequest->EncryptedDataSize = DecodedTicket->encrypted_part.cipher_text.length;
            DecryptRequest->EncryptedData = (PUCHAR) (DecryptRequest + 1);
            RtlCopyMemory(
                DecryptRequest->EncryptedData,
                DecodedTicket->encrypted_part.cipher_text.value,
                DecryptRequest->EncryptedDataSize
                );
            DecryptRequest->Key.KeyType = Key.keytype;
            DecryptRequest->Key.Length = Key.keyvalue.length;
            DecryptRequest->Key.Value = DecryptRequest->EncryptedData + DecryptRequest->EncryptedDataSize;
            RtlCopyMemory(
                DecryptRequest->Key.Value,
                Key.keyvalue.value,
                Key.keyvalue.length
                );


            Status = LsaCallAuthenticationPackage(
                        LogonHandle,
                        PackageId,
                        DecryptRequest,
                        DecryptRequestSize,
                        (PVOID *) &DecryptResponse,
                        &DecryptResponseSize,
                        &SubStatus
                        );
            if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
            {
                printf("Failed to decrypt message: 0x%x or 0x%x\n",Status,SubStatus);
                return;
            }

            //
            // Now decode the encrypted ticket
            //

            KerbErr = KerbUnpackData(
                            DecryptResponse->DecryptedData,
                            DecryptResponseSize,
                            KERB_ENCRYPTED_TICKET_PDU,
                            (PVOID *) &EncryptedTicket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                printf("Failed to unpack encrypted ticket: 0x%x\n",KerbErr);
                return;
            }

            //
            // Now print some fields
            //

            printf("Enc.Ticket client_realm = %s\n",EncryptedTicket->client_realm);
            printf("Enc.Ticket. client_name = %s\n",EncryptedTicket->client_name.name_string->value);

            LsaFreeReturnBuffer(DecryptResponse);


            LsaFreeReturnBuffer(CacheResponse);

        }


    }
    else if (_wcsnicmp(Function,L"binding:", wcslen(L"binding:")) == 0)
    {
        PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST CacheRequest = NULL;
        UNICODE_STRING Realm = {0};
        UNICODE_STRING Server = {0};
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            Function+wcslen(L"binding:")
            );




        CacheRequest = (PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_ADD_BINDING_CACHE_ENTRY_REQUEST));

        CacheRequest->MessageType = KerbAddBindingCacheEntryMessage;

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        Server = Target;
        for (Index = 0; Index < Target.Length / sizeof(WCHAR);  Index++ )
        {
            if (Target.Buffer[Index] == L'@')
            {
                CacheRequest->KdcAddress.Buffer = Target.Buffer;
                CacheRequest->KdcAddress.Length = 2*Index;
                CacheRequest->KdcAddress.MaximumLength = CacheRequest->KdcAddress.Length;
                CacheRequest->RealmName.Buffer = Target.Buffer+Index+1;
                CacheRequest->RealmName.Length = Target.Length - 2*(Index+1);
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                break;
            }
            else if (Target.Buffer[Index] == L'\\')
            {
                CacheRequest->RealmName.Buffer = Target.Buffer;
                CacheRequest->RealmName.Length = 2*Index;
                CacheRequest->RealmName.MaximumLength = CacheRequest->RealmName.Length;
                CacheRequest->KdcAddress.Buffer = Target.Buffer+Index+1;
                CacheRequest->KdcAddress.Length = Target.Length - 2*(Index+1);
                CacheRequest->KdcAddress.MaximumLength = CacheRequest->KdcAddress.Length;
                break;
            }
        }

        CacheRequest->AddressType = 0;
        printf("Updating binding cache: realm %wZ,kdc %wZ\n",
            &CacheRequest->RealmName, &CacheRequest->KdcAddress );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_ADD_BINDING_CACHE_ENTRY_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }


    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL)
    {
        LsaFreeReturnBuffer(CacheResponse);
    }
}

VOID
TestGetTicketRoutine(
    IN LPWSTR TargetName,
    IN LPWSTR OPTIONAL UserName,
    IN LPWSTR OPTIONAL DomainName,
    IN LPWSTR OPTIONAL Password,
    IN ULONG Flags
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PKERB_EXTERNAL_TICKET CacheEntry = NULL;
    ULONG Index;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    CredHandle Credentials = {0};
    BOOLEAN UseCreds = FALSE;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }


    //
    // Get a cred handle if we need one
    //

    if ((UserName != NULL) ||
        (DomainName != NULL) ||
        (Password != NULL))
    {
        if (!GetCredentialsHandle(
                &Credentials,
                MICROSOFT_KERBEROS_NAME_W,
                UserName,
                DomainName,
                Password,
                SECPKG_CRED_OUTBOUND
                ))
        {
            printf("Failed to get creds\n");
            return;
        }
        UseCreds = TRUE;
    }
    {
        PKERB_RETRIEVE_TKT_REQUEST CacheRequest = NULL;
        PKERB_RETRIEVE_TKT_RESPONSE CacheResponse = NULL;
        UNICODE_STRING Target = {0};
        UNICODE_STRING Target2 = {0};
        USHORT Index;

        RtlInitUnicodeString(
            &Target2,
            TargetName
            );




        CacheRequest = (PKERB_RETRIEVE_TKT_REQUEST)
            LocalAlloc(LMEM_ZEROINIT, Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST));

        CacheRequest->MessageType = KerbRetrieveEncodedTicketMessage;
        CacheRequest->CacheOptions = Flags;
        if (UseCreds)
        {
            CacheRequest->CacheOptions |= KERB_RETRIEVE_TICKET_USE_CREDHANDLE;
            CacheRequest->CredentialsHandle = Credentials;
        }

        Target.Buffer = (LPWSTR) (CacheRequest + 1);
        Target.Length = Target2.Length;
        Target.MaximumLength = Target2.MaximumLength;

        RtlCopyMemory(
            Target.Buffer,
            Target2.Buffer,
            Target2.Length
            );

        CacheRequest->TargetName = Target;

        printf("Retrieving tickets: %wZ\n",
            &CacheRequest->TargetName );

        Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    Target2.Length + sizeof(KERB_RETRIEVE_TKT_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
        {
            printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
        }
        else
        {
            CacheResponse = (PKERB_RETRIEVE_TKT_RESPONSE) Response;

            printf("Cached Ticket:\n");
            printf("ServiceName: "); PrintKdcName(CacheResponse->Ticket.ServiceName);
            printf("TargetName: "); PrintKdcName(CacheResponse->Ticket.TargetName);
            printf("DomainName: %wZ\n",&CacheResponse->Ticket.DomainName);
            printf("TargetDomainName: %wZ\n",&CacheResponse->Ticket.TargetDomainName);
            printf("ClientName: "); PrintKdcName(CacheResponse->Ticket.ClientName);
            printf("TicketFlags: 0x%x\n",CacheResponse->Ticket.TicketFlags);
            PrintTime("KeyExpirationTime: ",CacheResponse->Ticket.KeyExpirationTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("StartTime: ",CacheResponse->Ticket.StartTime);
            PrintTime("EndTime: ",CacheResponse->Ticket.EndTime);
            PrintTime("RenewUntil: ",CacheResponse->Ticket.RenewUntil);
            PrintTime("TimeSkew: ",CacheResponse->Ticket.TimeSkew);
            LsaFreeReturnBuffer(CacheResponse);

        }

    }
    if (UseCreds)
    {
        FreeCredentialsHandle(&Credentials);
    }
}

#include <ntmsv1_0.h>
VOID
TestChangeCachedPassword(
    IN LPWSTR AccountName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    )
{
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    HANDLE LogonHandle = NULL;
    ULONG Dummy;
    ULONG RequestSize = 0;
    ULONG PackageId = 0;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    PBYTE Where;
    STRING Name;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }




    RtlInitString(
        &Name,
        MSV1_0_PACKAGE_NAME
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }


    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                (wcslen(AccountName) +
                 wcslen(DomainName) +
                 wcslen(NewPassword) + 3) * sizeof(WCHAR);

    Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT,RequestSize);

    Where = (PBYTE) (Request + 1);
    Request->MessageType = MsV1_0ChangeCachedPassword;
    wcscpy(
        (LPWSTR) Where,
        DomainName
        );
    RtlInitUnicodeString(
        &Request->DomainName,
        (LPWSTR) Where
        );
    Where += Request->DomainName.MaximumLength;

    wcscpy(
        (LPWSTR) Where,
        AccountName
        );
    RtlInitUnicodeString(
        &Request->AccountName,
        (LPWSTR) Where
        );
    Where += Request->AccountName.MaximumLength;

    wcscpy(
        (LPWSTR) Where,
        NewPassword
        );
    RtlInitUnicodeString(
        &Request->NewPassword,
        (LPWSTR) Where
        );
    Where += Request->NewPassword.MaximumLength;

    //
    // Make the call
    //

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                Request,
                RequestSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );

    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("changepass failed: 0x%x, 0x%x\n",Status, SubStatus);
    }

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }
}

VOID
TestChangePasswordRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    )
{
#if 1

    NTSTATUS Status;

    Status = KerbChangePasswordUser(
                DomainName,
                UserName,
                OldPassword,
                NewPassword
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to change password: 0x%x\n",Status);
    }
    else
    {
        printf("Change password succeeded\n");
    }
#else
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    printf("Changing password for %wZ@%wZ from %wZ to %wZ\n",
        &ChangeRequest->AccountName,
        &ChangeRequest->DomainName,
        &ChangeRequest->OldPassword,
        &ChangeRequest->NewPassword
        );
    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }
#endif
}

VOID
TestSetPasswordRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    )
{
#if 1

    NTSTATUS Status;

    Status = KerbSetPasswordUser(
                DomainName,
                UserName,
                NewPassword,
                NULL
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set password: 0x%x\n",Status);
    }
    else
    {
        printf("Set password succeeded\n");
    }
#else

    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    BOOLEAN Trusted = TRUE;
    PKERB_SETPASSWORD_REQUEST SetRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );

    if (Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LogonHandle,
                    &Dummy
                    );

    }
    else
    {
        Status = LsaConnectUntrusted(
                    &LogonHandle
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }



    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_SETPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    NewPass.Length ;
    SetRequest = (PKERB_SETPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    SetRequest->MessageType = KerbSetPasswordMessage;

    SetRequest->AccountName = User;
    SetRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_SETPASSWORD_REQUEST) + (PBYTE) SetRequest,4);

    RtlCopyMemory(
        SetRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    SetRequest->DomainName = Domain;
    SetRequest->DomainName.Buffer = SetRequest->AccountName.Buffer + SetRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );


    SetRequest->Password = NewPass;
    SetRequest->Password.Buffer = SetRequest->DomainName.Buffer + SetRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->Password.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    printf("Setting password for %wZ@%wZ to %wZ\n",
        &SetRequest->AccountName,
        &SetRequest->DomainName,
        &SetRequest->Password
        );

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                SetRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        printf("token failed: 0x%x, 0x %x\n",Status, SubStatus);
    }


    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }
#endif
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;
    LPSTR UserName = NULL,DomainName = NULL,Password = NULL, Package = MICROSOFT_KERBEROS_NAME_A;
    LPWSTR DomainNameW = NULL;
    LPWSTR UserNameW = NULL;
    LPWSTR PasswordW = NULL;
    LPWSTR OldPasswordW = NULL;
    LPWSTR TargetNameW = NULL;
    LPWSTR ServerDomainName = NULL;
    LPWSTR ServerUserName = NULL;
    LPWSTR ServerPassword = NULL;
    LPWSTR TargetName = NULL;
    LPWSTR PackageName = NULL;
    LPWSTR PackageFunction = NULL;
    LPWSTR PackageList = NULL;
    ULONG ContextReq = 0;
    ULONG CredFlags = 0;
    BOOLEAN Relogon = FALSE;
    SECURITY_LOGON_TYPE LogonType = Interactive;





    enum {
        NoAction,
#define USER_PARAM "/user:"
#define DOMAIN_PARAM "/domain:"
#define PASSWORD_PARAM "/password:"
#define CHANGE_PASSWORD_PARAM "/changepass:"
        ChangePassword,
#define SET_PASSWORD_PARAM "/setpass"
        SetPassword,
#define CHANGE_CACHED_PASSWORD_PARAM "/cache"
        ChangeCachedPassword,
#define SERVER_USER_PARAM "/serveruser:"
#define SERVER_DOMAIN_PARAM "/serverdomain:"
#define SERVER_PASSWORD_PARAM "/serverpassword:"
#define TARGET_PARAM "/target:"
#define PACKAGENAME_PARAM "/package:"
#define PACKAGELIST_PARAM "/packagelist:"
#define ANSI_PARAM "/ansi"
#define FLAG_PARAM "/flags:"
#define RECURSE_PARAM "/recurse:"
#define SYSTEM_PARAM "/system"
#define TESTSSP_PARAM "/TestSsp"
        TestSsp,
#define CONFIG_PARAM "/ConfigureService"
        ConfigureService,
#define LOGON_PARAM2 "/Logon:"
#define LOGON_PARAM "/Logon"
        TestLogon,
#define PACKAGE_PARAM "/callpackage:"
        TestPackage,
#define BATCH_PARAM "/batch"
#define RELOGON_PARAM "/relogon"
#define NOPAC_PARAM "/nopac"
#define GETTICKET_PARAM "/ticket:"
        TestGetTicket,
#define TIME_PARAM "/time:"
#define S4ULOGON_PARAM "/S4U:"
        TestS4ULogon,
#define ISC_PARAM "/ISC:"
        QuickISCTest

    } Action = NoAction;





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //

        if ( _stricmp( argument, CONFIG_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = ConfigureService;


        } else if ( _stricmp( argument, ANSI_PARAM ) == 0 ) {
            DoAnsi = TRUE;
        } else if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;

        } else if ( _strnicmp( argument,
                              USER_PARAM,
                              sizeof(USER_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(USER_PARAM)-1];
            UserNameW = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              DOMAIN_PARAM,
                              sizeof(DOMAIN_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(DOMAIN_PARAM)-1];
            DomainNameW = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              PASSWORD_PARAM,
                              sizeof(PASSWORD_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(PASSWORD_PARAM)-1];
            PasswordW = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              SERVER_USER_PARAM,
                              sizeof(SERVER_USER_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_USER_PARAM)-1];
            ServerUserName = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              SERVER_DOMAIN_PARAM,
                              sizeof(SERVER_DOMAIN_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_DOMAIN_PARAM)-1];
            ServerDomainName = NetpAllocWStrFromStr( argument );

        } else if ( _strnicmp( argument,
                              SERVER_PASSWORD_PARAM,
                              sizeof(SERVER_PASSWORD_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(SERVER_PASSWORD_PARAM)-1];
            ServerPassword = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              TARGET_PARAM,
                              sizeof(TARGET_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(TARGET_PARAM)-1];
            TargetName = NetpAllocWStrFromStr( argument );


        } else if ( _strnicmp( argument,
                              PACKAGENAME_PARAM,
                              sizeof(PACKAGENAME_PARAM)-1 ) == 0 ){

            Package = &argument[sizeof(PACKAGENAME_PARAM)-1];
            PackageName = NetpAllocWStrFromStr( Package );


        } else if (_strnicmp(argument,
                            TIME_PARAM,
                            sizeof(TIME_PARAM)-1 ) == 0 ){
            char *end;
            LARGE_INTEGER ConvertTime;
            LONGLONG Time;


            ConvertTime.LowPart = strtoul( &argument[sizeof(TIME_PARAM)-1], &end, 16 );
            i++;
            argument = argv[i];

            ConvertTime.HighPart = strtoul( argument, &end, 16 );

            Time = ConvertTime.QuadPart / 10000000;
            if (Time < 60)
            {
                printf("time : %d seconds\n", (LONG) Time);
            }
            else
            {
                Time = Time / 60;
                if (Time < 60)
                {
                    printf("time : %d minutes\n", (LONG) Time);
                }
                else
                {
                    Time = Time / 60;
                    if (Time < 24)
                    {
                        printf("time: %d hours\n", (LONG) Time);
                    }
                    else
                    {
                        Time = Time / 24;
                        printf("time: %d days\n",(LONG) Time);
                    }
                }
            }

        } else if ( _strnicmp( argument,
                              FLAG_PARAM,
                              sizeof(FLAG_PARAM)-1 ) == 0 ){

            sscanf(&argument[sizeof(FLAG_PARAM)-1], "%x",&ContextReq);

        } else if ( _strnicmp( argument,
                              RECURSE_PARAM,
                              sizeof(RECURSE_PARAM)-1 ) == 0 ){

            sscanf(&argument[sizeof(RECURSE_PARAM)-1], "%d",&MaxRecursionDepth);

        } else if ( _strnicmp( argument,
                              PACKAGELIST_PARAM,
                              sizeof(PACKAGELIST_PARAM)-1 ) == 0 ){

            argument = &argument[sizeof(PACKAGELIST_PARAM)-1];
            PackageList = NetpAllocWStrFromStr( argument );


        } else if (_strnicmp( argument,
                              BATCH_PARAM,
                              sizeof(BATCH_PARAM) - 1) == 0) {
            LogonType = Batch;
        } else if (_strnicmp( argument,
                              RELOGON_PARAM,
                              sizeof(RELOGON_PARAM) - 1) == 0) {
            Relogon = TRUE;
        } else if (_strnicmp( argument,
                              NOPAC_PARAM,
                              sizeof(NOPAC_PARAM) - 1) == 0) {
            CredFlags |= SEC_WINNT_AUTH_IDENTITY_ONLY;
        } else if (_strnicmp( argument,
                              SYSTEM_PARAM,
                              sizeof(SYSTEM_PARAM) - 1) == 0) {
            HANDLE hWinlogon = NULL;
            HANDLE SystemToken = NULL;
            hWinlogon = FindAndOpenWinlogon();

            if ( OpenProcessToken(
                        hWinlogon,
                        WRITE_DAC,
                        &SystemToken ) )
            {
                SECURITY_DESCRIPTOR EmptyDacl;
                RtlZeroMemory(
                    &EmptyDacl,
                    sizeof(SECURITY_DESCRIPTOR)
                    );
                InitializeSecurityDescriptor(
                    &EmptyDacl,
                    SECURITY_DESCRIPTOR_REVISION
                    );
                SetSecurityDescriptorDacl(
                    &EmptyDacl,
                    FALSE,
                    NULL,
                    FALSE
                    );
                if (!SetKernelObjectSecurity(
                        SystemToken,
                        DACL_SECURITY_INFORMATION,
                        &EmptyDacl))
                {
                    printf("Failed to set token dacl: %d\n",GetLastError());
                    return(0);
                }
                CloseHandle(SystemToken);
            }
            if ( OpenProcessToken(
                        hWinlogon,
                        TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                        &SystemToken ) )
            {
                ImpersonateLoggedOnUser(SystemToken);
                CloseHandle(SystemToken);
            }
            else
            {
                printf("Failed to get system token: %d\n",GetLastError());
                return(0);
            }
            CloseHandle(hWinlogon);

        } else if ( _strnicmp( argument, LOGON_PARAM, sizeof(LOGON_PARAM)-1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;
            if ( _strnicmp( argument, LOGON_PARAM2, sizeof(LOGON_PARAM2)-1 ) == 0 ) {
                sscanf(&argument[sizeof(LOGON_PARAM2)-1], "%x",&Iterations);

            }

            if (argc < i + 2)
            {
                goto Usage;
            }

            UserName = argv[++i];
            Password = argv[++i];
            if (i < argc)
            {
                DomainName = argv[++i];
            }
            else
            {
                DomainName = NULL;
            }
        } else if ( _strnicmp( argument, PACKAGE_PARAM, sizeof(PACKAGE_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(PACKAGE_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestPackage;
        } else if ( _strnicmp( argument, GETTICKET_PARAM, sizeof(GETTICKET_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(GETTICKET_PARAM)-1];
            PackageFunction = NetpAllocWStrFromStr( argument );

            Action = TestGetTicket;
        } else if ( _strnicmp( argument, CHANGE_PASSWORD_PARAM, sizeof(CHANGE_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            argument = &argument[sizeof(CHANGE_PASSWORD_PARAM)-1];
            OldPasswordW = NetpAllocWStrFromStr( argument );

            Action = ChangePassword;
        } else if ( _strnicmp( argument, SET_PASSWORD_PARAM, sizeof(SET_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Action = SetPassword;
        } else if ( _strnicmp( argument, CHANGE_CACHED_PASSWORD_PARAM, sizeof(CHANGE_CACHED_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }
            Action = ChangeCachedPassword;
        } else if (_stricmp( argument, S4ULOGON_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }


            Action = TestS4ULogon;
            Iterations = 1;
            UserName = argv[++i];

            if (i < argc)
                {
                DomainName = argv[++i];
            }
            else
                {
                DomainName = NULL;
            }
        } else if (_strnicmp( argument, ISC_PARAM,sizeof(ISC_PARAM)-1 ) == 0 )
        {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = QuickISCTest; 

            argument = &argument[sizeof(ISC_PARAM)-1];
            TargetName = NetpAllocWStrFromStr( argument );
            

        }   
        else {
            printf("Invalid parameter : %s\n",argument);
            goto Usage;
        }


    }

    //
    // Perform the action requested
    //

    switch ( Action ) {

    case ConfigureService:
        ConfigureServiceRoutine();
        break;

    case TestSsp:
        for ( j=0; j<Iterations ; j++ ) {
            TestSspRoutine(
                PackageName,
                UserNameW,
                DomainNameW,
                PasswordW,
                ServerUserName,
                ServerDomainName,
                ServerPassword,
                TargetName,
                PackageList,
                ContextReq,
                CredFlags
                );
        }
        break;
    case TestPackage:
        TestCallPackageRoutine(PackageFunction);
        break;

    case TestLogon :
        TestLogonRoutine(
            Iterations,
            Relogon,
            LogonType,
            Package,
            UserName,
            DomainName,
            Password
            );
        break;

    case TestS4ULogon :
        TestS4ULogonRoutine(
            UserName,
            DomainName
            );
        break;

    case ChangePassword :
        TestChangePasswordRoutine(
            UserNameW,
            DomainNameW,
            OldPasswordW,
            PasswordW
            );
        break;

    case ChangeCachedPassword :
        TestChangeCachedPassword(
            UserNameW,
            DomainNameW,
            PasswordW
            );
        break;

    case SetPassword :
        TestSetPasswordRoutine(
            UserNameW,
            DomainNameW,
            PasswordW
            );
        break;
    case TestGetTicket :
        TestGetTicketRoutine(
            PackageFunction,
            UserNameW,
            DomainNameW,
            PasswordW,
            ContextReq
            );
        break;


    case QuickISCTest:
        TestQuickISC(
            TargetName
            );
        break;
    }
    return 0;
Usage:
    printf("%s /logon username password [domainname]\n",argv[0]);
    printf("%s /testssp [/package:pacakgename] [/target:targetname] [/user:username] [/serveruser:username]\n", argv[0]);
    printf("/t/t [/domain:client domain] [/password: client password] [/serverdomain:server domain] [/serverpassword:server password]\n");
    printf("%s /callpackage:purge:[servername]\n", argv[0]);
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created
    25-Jul-96       ChandanS    Copied from net\svcdlls\ntlmssp\client\crc32.c
    27-Jan-07       MikeSw      Incorporated x86 ASM code for performance

--*/

#include "crc32.h"

#ifdef KMODE_NTLM
#ifdef ALLOC_PRAGMA
#pragma alloc_text("PAGEMSG", Crc32)
#endif  // ALLOC_PRAGMA
#endif  // KMODE

//
// This code comes from Dr. Dobbs Journal, May 1992
//


unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


void
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc)
{
  unsigned char * pbBuffer;

#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pvBuffer

  mov     edx, DWORD PTR dwCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR dwCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#else // _X86_
    pbBuffer = (unsigned char *) pvBuffer;
#endif
    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\credderi.c ===
/*++

Copyright (c) 1987-1998  Microsoft Corporation

Module Name:

    credderi.c

Abstract:

    Interface to credential derivation facility.

Author:

    Scott Field (sfield)    14-Jan-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "msp.h"
#include "nlp.h"

#include <sha.h>

#define HMAC_K_PADSIZE      (64)


//
// Prototype for credential derivation routines.
//

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    );



NTSTATUS
MspNtDeriveCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0DeriveCredential.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_DERIVECRED_REQUEST DeriveCredRequest;
    PMSV1_0_DERIVECRED_RESPONSE DeriveCredResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;

    PBYTE pbOwf;
    ULONG cbOwf;

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_DERIVECRED_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DeriveCredRequest = (PMSV1_0_DERIVECRED_REQUEST) ProtocolSubmitBuffer;

    //
    // validate supported derive types.
    //


    if( DeriveCredRequest->DeriveCredType != MSV1_0_DERIVECRED_TYPE_SHA1 &&
        DeriveCredRequest->DeriveCredType != MSV1_0_DERIVECRED_TYPE_SHA1_V2 )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // caller must pass in mixing bits into submit buffer.
    //

    if( DeriveCredRequest->DeriveCredInfoLength == 0 ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Make sure the buffer fits in the supplied size
    //

    if ( (DeriveCredRequest->DeriveCredInfoLength + sizeof(MSV1_0_DERIVECRED_REQUEST))
            > SubmitBufferSize )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Get the OWF password for this session.
    //

    Status = NlpGetPrimaryCredential( &DeriveCredRequest->LogonId, &Credential, NULL );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_DERIVECRED_RESPONSE) +
                        A_SHA_DIGEST_LEN;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      *ReturnBufferSize,
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ZeroMemory( ClientBufferDesc.MsvBuffer, *ReturnBufferSize );
    DeriveCredResponse = (PMSV1_0_DERIVECRED_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    DeriveCredResponse->MessageType = MsV1_0DeriveCredential;
    DeriveCredResponse->DeriveCredInfoLength = A_SHA_DIGEST_LEN;

    pbOwf = NULL;


    if( DeriveCredRequest->DeriveCredType == MSV1_0_DERIVECRED_TYPE_SHA1_V2 )
    {
        //
        // explicitly requested derivation based on ShaOwfPassword.
        //

        if( Credential->ShaPasswordPresent )
        {
            pbOwf = (PBYTE) &(Credential->ShaOwfPassword);  // key material is SHA OWF
            cbOwf = sizeof( SHA_OWF_PASSWORD );
        }
    } else if( DeriveCredRequest->DeriveCredType == MSV1_0_DERIVECRED_TYPE_SHA1 )
    {
        //
        // explicitly requested derivation based on NtOwfPassword.
        //

        if( Credential->NtPasswordPresent )
        {
            pbOwf = (PBYTE) &(Credential->NtOwfPassword);   // key material is NT OWF
            cbOwf = sizeof( NT_OWF_PASSWORD );
        }
    }

    if( pbOwf == NULL )
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // derive credential from HMAC_SHA1 crypto primitive
    // (the only supported crypto primitive at the moment)
    //

    DeriveWithHMAC_SHA1(
                pbOwf,
                cbOwf,
                DeriveCredRequest->DeriveCredSubmitBuffer,
                DeriveCredRequest->DeriveCredInfoLength,
                DeriveCredResponse->DeriveCredReturnBuffer
                );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if ( Credential != NULL ) {
        ZeroMemory( Credential, sizeof(*Credential) );
        (*Lsa.FreeLsaHeap)( Credential );
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return(Status);
}

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    )
{
    unsigned __int64 rgbKipad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    unsigned __int64 rgbKopad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    A_SHA_CTX sSHAHash;
    DWORD dwBlock;

    // truncate
    if( cbKeyMaterial > HMAC_K_PADSIZE )
    {
        cbKeyMaterial = HMAC_K_PADSIZE;
    }

    ZeroMemory(rgbKipad, sizeof(rgbKipad));
    ZeroMemory(rgbKopad, sizeof(rgbKopad));

    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for( dwBlock = 0; dwBlock < (HMAC_K_PADSIZE/sizeof(unsigned __int64)) ; dwBlock++ )
    {
        rgbKipad[dwBlock] ^= 0x3636363636363636;
        rgbKopad[dwBlock] ^= 0x5C5C5C5C5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKipad, sizeof(rgbKipad));
    A_SHAUpdate(&sSHAHash, pbData, cbData);


    // Finish off the hash
    A_SHAFinal(&sSHAHash, rgbHMAC);

    // prepend Kopad to H1, hash to get HMAC
    // note: done in place to avoid buffer copies

    // final hash: output value into passed-in buffer
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKopad, sizeof(rgbKopad));
    A_SHAUpdate(&sSHAHash, rgbHMAC, A_SHA_DIGEST_LEN);
    A_SHAFinal(&sSHAHash, rgbHMAC);


    ZeroMemory( rgbKipad, sizeof(rgbKipad) );
    ZeroMemory( rgbKopad, sizeof(rgbKopad) );
    ZeroMemory( &sSHAHash, sizeof(sSHAHash) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\context.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    context.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc

#include <lm.h>
#include <dsgetdc.h>



SECURITY_STATUS
SspContextReferenceContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PSSP_CONTEXT *ContextResult
    )

/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    RemoveContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.

    ContextResult set to result context handle if successful.


Return Value:

    SEC_E_OK returns a pointer to the referenced Context.

    SEC_E_INVALID_HANDLE - invalid handle supplied
    SEC_E_CONTEXT_EXPIRED - handle was valid, but expired

--*/

{
    PLIST_ENTRY ListEntry;
    PSSP_CONTEXT Context;

    SspPrint(( SSP_API_MORE, "Entering SspContextReferenceContext\n" ));

    *ContextResult = NULL;

#if DBG


    //
    // check for leaky client applications.
    //

    SECPKG_CALL_INFO CallInfo;

    if( LsaFunctions->GetCallInfo(&CallInfo) )
    {
        if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
        {
            SspPrint(( SSP_LEAK_TRACK, "SspContextReferenceContext: pid: 0x%lx handle: %p refcount: %lu\n",
                    CallInfo.ProcessId, ContextHandle, CallInfo.CallCount));
        }
    }

#endif



    Context = (PSSP_CONTEXT)ContextHandle;

    __try {

        if( (Context->ContextTag != SSP_CONTEXT_TAG_ACTIVE) )
        {
            SspPrint(( SSP_CRITICAL, "Tried to reference unknown Context %p\n",
                   Context ));
            return SEC_E_INVALID_HANDLE;
        }

#if 0
        ASSERT( (KernelCaller == Context->KernelClient) );
#endif

        if (!RemoveContext)
        {
            if (SspTimeHasElapsed( Context->StartTime, Context->Interval))
            {
                if ((Context->State != AuthenticatedState) &&
                    (Context->State != AuthenticateSentState) &&
                    (Context->State != PassedToServiceState))
                {

                    SspPrint(( SSP_CRITICAL, "Context %p has timed out.\n",
                                ContextHandle ));

                    return SEC_E_CONTEXT_EXPIRED;
                }
            }

            InterlockedIncrement( (PLONG)&Context->References );
        }
        else
        {
            Context->ContextTag = SSP_CONTEXT_TAG_DELETE;

            SspPrint(( SSP_API_MORE, "Delinked Context %p\n", Context ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SspPrint(( SSP_CRITICAL, "Tried to reference invalid Context %p\n",
                       Context ));
        return SEC_E_INVALID_HANDLE;
    }

    *ContextResult = Context;
    return SEC_E_OK;
}

VOID
SspContextDereferenceContext(
    PSSP_CONTEXT Context
    )

/*++

Routine Description:

    This routine decrements the specified Context's reference count.
    If the reference count drops to zero, then the Context is deleted

Arguments:

    Context - Points to the Context to be dereferenced.


Return Value:

    None.

--*/

{

    LONG References;

    SspPrint(( SSP_API_MORE, "Entering SspContextDereferenceContext\n" ));

    //
    // Decrement the reference count
    //

    References = InterlockedDecrement( (PLONG)&Context->References );
    ASSERT( References >= 0 );


    //
    // If the count dropped to zero, then run-down the Context
    //

    if (References != 0)
    {
        return;
    }

    SspPrint(( SSP_API_MORE, "Deleting Context 0x%lx\n",
               Context ));

    Context->ContextTag = SSP_CONTEXT_TAG_DELETE;

    if ( Context->Password.Buffer != NULL ) {
        // note: Password.Length may contain run-encoding hint, so size may be illegal.
        ZeroMemory( Context->Password.Buffer, Context->Password.MaximumLength );
        (VOID) NtLmFree( Context->Password.Buffer );
    }
    if ( Context->DomainName.Buffer != NULL ) {
        (VOID) NtLmFree( Context->DomainName.Buffer );
    }
    if ( Context->UserName.Buffer != NULL ) {
        (VOID) NtLmFree( Context->UserName.Buffer );
    }
    if( Context->TargetInfo != NULL )
    {
        //
        // CredUnmarshallTargetInfo uses LocalAlloc()
        //

        LocalFree( Context->TargetInfo );
    }

    if ( Context->TokenHandle != NULL ) {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose( Context->TokenHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
    }

    if( Context->pbMarshalledTargetInfo )
    {
        LocalFree( Context->pbMarshalledTargetInfo );
    }

    if (Context->Credential != NULL) {
        SspCredentialDereferenceCredential( Context->Credential );
    }

    ZeroMemory( Context, sizeof(SSP_CONTEXT) );
    (VOID) NtLmFree( Context );


    return;

}

PSSP_CONTEXT
SspContextAllocateContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates the security context block, initializes it and
    links it onto the specified credential.

Arguments: None

Return Value:

    NULL -- Not enough memory to allocate context.

    otherwise -- pointer to allocated and referenced context.

--*/

{

    SspPrint(( SSP_API_MORE, "Entering SspContextAllocateContext\n" ));
    PSSP_CONTEXT Context;
    SECPKG_CALL_INFO CallInfo;


    //
    // Allocate a Context block and initialize it.
    //

    Context = (PSSP_CONTEXT)NtLmAllocate(sizeof(SSP_CONTEXT) );

    if ( Context == NULL ) {
        SspPrint(( SSP_CRITICAL, "SspContextAllocateContext: Error allocating Context.\n" ));
        return NULL;
    }

    ZeroMemory( Context, sizeof(SSP_CONTEXT) );



    if( LsaFunctions->GetCallInfo(&CallInfo) ) {
        Context->ClientProcessID = CallInfo.ProcessId;
        Context->KernelClient = ((CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE) != 0);
    }

    //
    // The reference count is set to 2.  1 to indicate it is on the
    // valid Context list, and one for the our own reference.
    //

    Context->References = 2;
    Context->State = IdleState;

    //
    // Timeout this context.
    //

    (VOID) NtQuerySystemTime( &Context->StartTime );
    Context->Interval = NTLMSSP_MAX_LIFETIME;

    //
    // Add it to the list of valid Context handles.
    //

    Context->ContextTag = SSP_CONTEXT_TAG_ACTIVE;

    SspPrint(( SSP_API_MORE, "Added Context 0x%lx\n", Context ));

    SspPrint(( SSP_API_MORE, "Leaving SspContextAllocateContext\n" ));
    return Context;

}

NTSTATUS
SspContextGetMessage(
    IN PVOID InputMessage,
    IN ULONG InputMessageSize,
    IN NTLM_MESSAGE_TYPE ExpectedMessageType,
    OUT PVOID* OutputMessage
    )

/*++

Routine Description:

    This routine copies the InputMessage into the local address space.
    This routine then validates the message header.

Arguments:

    InputMessage - Address of the message in the client process.

    InputMessageSize - Size of the message (in bytes).

    ExpectedMessageType - The type of message the should be in the message
        header.

    OutputMessage - Returns a pointer to an allocated buffer that contains
        the message.  The buffer should be freed using NtLmFree.


Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_INVALID_TOKEN -- Message improperly formatted
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory to allocate message

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PNEGOTIATE_MESSAGE TypicalMessage = NULL;

    //
    // Allocate a local buffer for the message.
    //

    ASSERT( NTLMSP_MAX_TOKEN_SIZE >= NTLMSSP_MAX_MESSAGE_SIZE );
    if ( InputMessageSize > NTLMSSP_MAX_MESSAGE_SIZE ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage, invalid input message size.\n" ));
        goto Cleanup;
    }

    TypicalMessage = (PNEGOTIATE_MESSAGE)NtLmAllocate(InputMessageSize );

    if ( TypicalMessage == NULL ) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage: Error allocating TypicalMessage.\n" ));
        goto Cleanup;
    }

    //
    // Copy the message into the buffer
    //

    RtlCopyMemory( TypicalMessage,
                   InputMessage,
                   InputMessageSize );

    //
    // Validate the message header.
    //

    if ( strncmp( (const char *)TypicalMessage->Signature,
                  NTLMSSP_SIGNATURE,
                  sizeof(NTLMSSP_SIGNATURE)) != 0 ||
         TypicalMessage->MessageType != ExpectedMessageType ) {

        (VOID) NtLmFree( TypicalMessage );
        TypicalMessage = NULL;
        Status = SEC_E_INVALID_TOKEN;
        SspPrint(( SSP_CRITICAL, "SspContextGetMessage, Bogus Message.\n" ));
        goto Cleanup;

    }

Cleanup:

    *OutputMessage = TypicalMessage;

    return Status;

}

VOID
SspContextCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING32 OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.  The
    descriptor 'address' is an offset from the MessageBuffer.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer.

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString->Buffer != NULL ) {
        RtlCopyMemory( *Where, InString->Buffer, InString->Length );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = InString->Length;
    OutString->Buffer = (ULONG)(*Where - ((PCHAR)MessageBuffer));


    //
    // Update Where to point past the copied data.
    //

    *Where += InString->Length;

}

VOID
SspContextCopyStringAbsolute(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString into the MessageBuffer at Where.
    It then updates OutString to be a descriptor for the copied string.

    Where is updated to point to the next available space in the MessageBuffer.

    The caller is responsible for any alignment requirements and for ensuring
    there is room in the buffer for the string.

Arguments:

    MessageBuffer - Specifies the base address of the buffer being copied into.

    OutString - Returns a descriptor for the copied string.  The descriptor
        is relative to the begining of the buffer.

    InString - Specifies the string to copy.

    Where - On input, points to where the string is to be copied.
        On output, points to the first byte after the string.

Return Value:

    None.

--*/

{
    //
    // Copy the data to the Buffer.
    //

    if ( InString->Buffer != NULL ) {
        RtlCopyMemory( *Where, InString->Buffer, InString->Length );
    }

    //
    // Build a descriptor to the newly copied data.
    //

    OutString->Length = OutString->MaximumLength = InString->Length;
    OutString->Buffer = *Where;

    //
    // Update Where to point past the copied data.
    //

    *Where += InString->Length;

}

BOOLEAN
SspConvertRelativeToAbsolute (
    IN PVOID MessageBase,
    IN ULONG MessageSize,
    IN PSTRING32 StringToRelocate,
    IN PSTRING OutputString,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString
    )

/*++

Routine Description:

    Convert a Relative string desriptor to be absolute.
    Perform all boudary condition testing.

Arguments:

    MessageBase - a pointer to the base of the buffer that the string
        is relative to.  The MaximumLength field of the descriptor is
        forced to be the same as the Length field.

    MessageSize - Size of the message buffer (in bytes).

    StringToRelocate - A pointer to the string descriptor to make absolute.

    AlignToWchar - If TRUE the passed in StringToRelocate must describe
        a buffer that is WCHAR aligned.  If not, an error is returned.

    AllowNullString - If TRUE, the passed in StringToRelocate may be
        a zero length string.

Return Value:

    TRUE - The string descriptor is valid and was properly relocated.

--*/

{
    ULONG_PTR Offset;

    //
    // If the buffer is allowed to be null,
    //  check that special case.
    //

    if ( AllowNullString ) {
        if ( StringToRelocate->Length == 0 ) {
            OutputString->MaximumLength = OutputString->Length = StringToRelocate->Length;
            OutputString->Buffer = NULL;
            return TRUE;
        }
    }

    //
    // Ensure the string in entirely within the message.
    //

    Offset = (ULONG_PTR) StringToRelocate->Buffer;

    if ( Offset >= MessageSize ||
         Offset + StringToRelocate->Length > MessageSize ) {
        return FALSE;
    }

    //
    // Ensure the buffer is properly aligned.
    //

    if ( AlignToWchar ) {
        if ( !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ||
             !COUNT_IS_ALIGNED( StringToRelocate->Length, ALIGN_WCHAR) ) {
            return FALSE;
        }
    }

    //
    // Finally make the pointer absolute.
    //

    OutputString->Buffer = (((PCHAR)MessageBase) + Offset);
    OutputString->MaximumLength = OutputString->Length = StringToRelocate->Length ;

    return TRUE;

}


TimeStamp
SspContextGetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN BOOLEAN GetExpirationTime
    )
/*++

Routine Description:

    Get the Start time or Expiration time for the specified context.

Arguments:

    Context - Pointer to the context to query

    GetExpirationTime - If TRUE return the expiration time.
        Otherwise, return the start time for the context.

Return Value:

    Returns the requested time as a local time.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TimeStamp LocalTimeStamp;

    //
    // Get the requested time in NT system time format.
    //

    SystemTime = Context->StartTime;

    if ( GetExpirationTime ) {
        LARGE_INTEGER Interval;

        //
        // If the time is infinite, return that
        //

        if ( Context->Interval == INFINITE ) {
            return NtLmGlobalForever;
        }

        //
        // Compute the ending time in NT System Time.
        //

        Interval.QuadPart = Int32x32To64( (LONG) Context->Interval, 10000 );
        SystemTime.QuadPart = Interval.QuadPart + SystemTime.QuadPart;
    }

    //
    // Convert the time to local time
    //

    Status = RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );

    if ( !NT_SUCCESS(Status) ) {
        return NtLmGlobalForever;
    }

    LocalTimeStamp.HighPart = LocalTime.HighPart;
    LocalTimeStamp.LowPart = LocalTime.LowPart;

    return LocalTimeStamp;

}

VOID
SspContextSetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN LARGE_INTEGER ExpirationTime
    )
/*++

Routine Description:

    Set the Expiration time for the specified context.

Arguments:

    Context - Pointer to the context to change

    ExpirationTime - Expiration time to set

Return Value:

    NONE.

--*/

{

    LARGE_INTEGER BaseGetTickMagicDivisor = { 0xe219652c, 0xd1b71758 };
    CCHAR BaseGetTickMagicShiftCount = 13;

    LARGE_INTEGER TimeRemaining;
    LARGE_INTEGER MillisecondsRemaining;

    //
    // If the expiration time is infinite,
    //  so is the interval
    //

    if ( ExpirationTime.HighPart == 0x7FFFFFFF &&
         ExpirationTime.LowPart == 0xFFFFFFFF ) {
        Context->Interval = INFINITE;

    //
    // Handle non-infinite expiration times
    //

    } else {

        //
        // Compute the time remaining before the expiration time
        //

        TimeRemaining.QuadPart = ExpirationTime.QuadPart -
                                 Context->StartTime.QuadPart;

        //
        // If the time has already expired,
        //  indicate so.
        //

        if ( TimeRemaining.QuadPart < 0 ) {

            Context->Interval = 0;

        //
        // If the time hasn't expired, compute the number of milliseconds
        //  remaining.
        //

        } else {

            MillisecondsRemaining = RtlExtendedMagicDivide(
                                        TimeRemaining,
                                        BaseGetTickMagicDivisor,
                                        BaseGetTickMagicShiftCount );

            if ( MillisecondsRemaining.HighPart == 0 &&
                 MillisecondsRemaining.LowPart < 0x7fffffff ) {

                Context->Interval = MillisecondsRemaining.LowPart;

            } else {

                Context->Interval = INFINITE;
            }
        }

    }

}


NTSTATUS
SsprDeleteSecurityContext (
    IN OUT ULONG_PTR ContextHandle
    )

/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context and generates a token which is passed to a remote peer
    so it too can remove the corresponding security context.

    This API terminates a context on the local machine, and optionally
    provides a token to be sent to the other machine.  The OutputToken
    generated by this call is to be sent to the remote peer (initiator or
    acceptor).  If the context was created with the I _REQ_ALLOCATE_MEMORY
    flag, then the package will allocate a buffer for the output token.
    Otherwise, it is the responsibility of the caller.

Arguments:

    ContextHandle - Handle to the context to delete

Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;

    //
    // Initialization
    //

    SspPrint(( SSP_API_MORE, "SspDeleteSecurityContext Entered\n" ));

    //
    // Find the currently existing context (and delink it).
    //

    Status = SspContextReferenceContext( ContextHandle, TRUE, &Context );

    if ( NT_SUCCESS(Status) )
    {
        SspContextDereferenceContext( Context );
    }

    SspPrint(( SSP_API_MORE, "SspDeleteSecurityContext returns 0x%lx\n", Status));
    return Status;
}

NTSTATUS
SspContextInitialize(
    VOID
    )

/*++

Routine Description:

    This function initializes this module.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{

    return STATUS_SUCCESS;

}


VOID
SspContextTerminate(
    VOID
    )

/*++

Routine Description:

    This function cleans up any dangling Contexts.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/
{
    //
    // don't forcibly try to delete contexts during shutdown, as, the
    // state of the machine is in flux during shutdown.
    //

    return;
}

BOOL
SsprCheckMinimumSecurity(
    IN ULONG NegotiateFlags,
    IN ULONG MinimumSecurityFlags
    )
/*++
Routine Description:

    Check that minimum security requirements have been met.

Arguments:

    NegotiateFlags: requested security features
    MinimumSecurityFlags: minimum required features

Return Value:
    TRUE    if minimum requirements met
    FALSE   otherwise

Notes:
    The MinimumSecurityFlags can contain features that only apply if
    a key is needed when doing signing or sealing. These have to be removed
    if SIGN or SEAL is not in the NegotiateFlags.

--*/
{
    ULONG EffFlags;     // flags in effect

    EffFlags = MinimumSecurityFlags;


    if( (NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) == 0 )
        EffFlags &= ~(NTLMSSP_NEGOTIATE_SIGN);


    if( (NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0 )
        EffFlags &= ~(NTLMSSP_NEGOTIATE_SEAL);


    //
    // if SIGN or SEAL is not negotiated, then remove all key related
    //  requirements, since they're not relevant when a key isn't needed
    //

    if ((NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL)) == 0)
    {
        EffFlags &= ~(
                NTLMSSP_NEGOTIATE_128 |
                NTLMSSP_NEGOTIATE_56 |
                NTLMSSP_NEGOTIATE_KEY_EXCH
                );
    } else if ((NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0) {

        //
        // If SIGN is negotiated, but SEAL isn't, then remove flags
        //  that aren't relevant to encryption
        //

        EffFlags &= ~( NTLMSSP_NEGOTIATE_KEY_EXCH );
    }

    //
    // FYI: flags that can be usefully spec'd even without SIGN or SEAL:
    //      NTLM2 -- forces stronger authentication
    //  All other flags should never be set.... and are nuked in initcomn
    //

    return ((NegotiateFlags & EffFlags) == EffFlags);
}


SECURITY_STATUS
SsprMakeSessionKey(
    IN  PSSP_CONTEXT Context,
    IN  PSTRING LmChallengeResponse,
    IN  UCHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH], // from the DC or GetChalResp
    IN  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH],     // from the DC of GetChalResp
    IN  PSTRING DatagramSessionKey
    )

/*++
// SsprMakeSessionKey
//  on entry:
//      if KEY_EXCH has been negotiated, then
//          either Context->SessionKey has a random number to be encrypted
//          to be sent to the server, or it has the encrypted session key
//          received from the client
//          if client, DatagramSessionKey must point to STRING set up to hold 16 byte key,
//              but with 0 length.
//      else Context->SessionKey and DatagramSessionKey are irrelevant on entry
//  on exit:
//      Context->SessionKey has the session key to be used for the rest of the session
//      if (DatagramSessionKey != NULL) then if KEY_EXCH then it has the encrypted session key
//      to send to the server, else it is zero length
//
--*/

{
    NTSTATUS Status;
    UCHAR LocalSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    // if we don't need to make any keys, just return
// RDR/SRV expect session key but don't ask for it! work-around this...
//    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN| NTLMSSP_NEGOTIATE_SEAL)) == 0)
//        return(SEC_E_OK);

    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN| NTLMSSP_NEGOTIATE_SEAL)) == 0)
    {

        RtlCopyMemory(
            Context->SessionKey,
            NtUserSessionKey,
            sizeof(LocalSessionKey)
            );

        return SEC_E_OK;
    }

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
        //
        // when using NTLM2, LSA gets passed flags that cause
        //  it to make good session keys -- nothing for us to do
        //

        RtlCopyMemory(
            LocalSessionKey,
            NtUserSessionKey,
            sizeof(LocalSessionKey)
            );
    }
    else if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY )
    {
        LM_OWF_PASSWORD LmKey;
        LM_RESPONSE LmResponseKey;

        BYTE TemporaryResponse[ LM_RESPONSE_LENGTH ];

        RtlZeroMemory(
            LocalSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        if (LmChallengeResponse->Length > LM_RESPONSE_LENGTH)
            return(SEC_E_UNSUPPORTED_FUNCTION);

        ZeroMemory( TemporaryResponse, sizeof(TemporaryResponse) );
        CopyMemory( TemporaryResponse, LmChallengeResponse->Buffer, LmChallengeResponse->Length );

        //
        // The LM session key is made by taking the LM sesion key
        // given to us by the LSA, extending it to LM_OWF_LENGTH
        // with our salt, and then producing a new challenge-response
        // with it and the original challenge response.  The key is
        // made from the first 8 bytes of the key.
        //

        RtlCopyMemory(  &LmKey,
                        LanmanSessionKey,
                        MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        memset( (PUCHAR)(&LmKey) + MSV1_0_LANMAN_SESSION_KEY_LENGTH,
                NTLMSSP_KEY_SALT,
                LM_OWF_PASSWORD_LENGTH - MSV1_0_LANMAN_SESSION_KEY_LENGTH );

        Status = RtlCalculateLmResponse(
                    (PLM_CHALLENGE) TemporaryResponse,
                    &LmKey,
                    &LmResponseKey
                    );

        ZeroMemory( TemporaryResponse, sizeof(TemporaryResponse) );
        if (!NT_SUCCESS(Status))
            return(SspNtStatusToSecStatus(Status, SEC_E_NO_CREDENTIALS));

        RtlCopyMemory(
            LocalSessionKey,
            &LmResponseKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    } else {

        RtlCopyMemory(
            LocalSessionKey,
            NtUserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    }


    //
    // If we aren't doing key exchange, store the session key in the
    // context.  Otherwise encrypt the session key to send to the
    // server.
    //

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) {

        struct RC4_KEYSTRUCT Rc4Key;

        //
        // make a key schedule from the temp key to form key exchange key
        //

        rc4_key(
            &Rc4Key,
            MSV1_0_USER_SESSION_KEY_LENGTH,
            LocalSessionKey
            );

        if (DatagramSessionKey == NULL)
        {
            //
            // decrypt what's in Context->SessionKey, leave it there
            //

            rc4(
                &Rc4Key,
                MSV1_0_USER_SESSION_KEY_LENGTH,
                Context->SessionKey
                );
        } else {

            //
            // set the proper length so client will send something (length was 0)
            //

            DatagramSessionKey->Length =
                DatagramSessionKey->MaximumLength =
                    MSV1_0_USER_SESSION_KEY_LENGTH;

            //
            // copy randomly generated key to buffer to send to server
            //

            RtlCopyMemory(
                DatagramSessionKey->Buffer,
                Context->SessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );

            //
            // encrypt it with the key exchange key
            //

            rc4(
                &Rc4Key,
                MSV1_0_USER_SESSION_KEY_LENGTH,
                (unsigned char*)DatagramSessionKey->Buffer
                );
        }


    } else {

        //
        // just make the temp key into the real one
        //

        RtlCopyMemory(
            Context->SessionKey,
            LocalSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

    }
    return(SEC_E_OK);
}

NTSTATUS
SsprQueryTreeName(
    OUT PUNICODE_STRING TreeName
    )
{

    PDS_DOMAIN_TRUSTSW Trusts = NULL;
    ULONG TrustCount ;
    ULONG Index;
    LPWSTR DnsTreeName = NULL;

    DWORD NetStatus;

    ZeroMemory( TreeName, sizeof(*TreeName) );

    NetStatus = DsEnumerateDomainTrustsW(
                    NULL,
                    DS_DOMAIN_PRIMARY | DS_DOMAIN_IN_FOREST,
                    &Trusts,
                    &TrustCount
                    );

    if( NetStatus != NO_ERROR )
    {
        // TODO: Talk to CliffV about failure causes.
        // in any event, the failure is not catastrophic.
        //

        return STATUS_SUCCESS;
    }

    for(Index = 0 ; Index < TrustCount; Index++)
    {
        ULONG Attempts; // bound the attempts in the event bogus data comes back.

        if( (Trusts[Index].Flags & DS_DOMAIN_PRIMARY) == 0)
        {
            continue;
        }

        for( Attempts = 0 ; Index < TrustCount; Attempts++ )
        {
            if( Attempts > TrustCount )
            {
                break;
            }

            if( (Trusts[Index].Flags & DS_DOMAIN_TREE_ROOT) == 0 )
            {
                Index = Trusts[Index].ParentIndex;
                continue;
            }

            DnsTreeName = Trusts[Index].DnsDomainName;
            break;
        }

        break;
    }

    if( DnsTreeName )
    {
        DWORD cchTreeName = lstrlenW( DnsTreeName );

        TreeName->Buffer = (PWSTR)NtLmAllocate( cchTreeName*sizeof(WCHAR) );
        if( TreeName->Buffer == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TreeName->Length = (USHORT)(cchTreeName*sizeof(WCHAR));
        TreeName->MaximumLength = TreeName->Length;

        RtlCopyMemory( TreeName->Buffer, DnsTreeName, TreeName->Length );
    }

    NetApiBufferFree( Trusts );

    return STATUS_SUCCESS;
}


NTSTATUS
SsprUpdateTargetInfo(
    VOID
    )
/*++

    Update the NtLmGlobalNtLm3TargetInfo buffer based on the current values
    of the various global variables.

    NOTE: the global lock must be held for exclusive access prior to making
    this call!

--*/
{
    PMSV1_0_AV_PAIR pAV;
    PUNICODE_STRING pDnsTargetName;
    PUNICODE_STRING pDnsComputerName;
    PUNICODE_STRING pDnsTreeName;
    ULONG cbAV;

    ULONG AvFlags = 0;

    if( NtLmGlobalNtLm3TargetInfo.Buffer != NULL )
    {
        NtLmFree(NtLmGlobalNtLm3TargetInfo.Buffer);
    }

    if( NtLmGlobalTargetFlags == NTLMSSP_TARGET_TYPE_DOMAIN ) {
        pDnsTargetName = &NtLmGlobalUnicodeDnsDomainNameString;
    } else {
        pDnsTargetName = &NtLmGlobalUnicodeDnsComputerNameString;
    }

    pDnsComputerName = &NtLmGlobalUnicodeDnsComputerNameString;

    pDnsTreeName = &NtLmGlobalUnicodeDnsTreeName;

    cbAV = NtLmGlobalUnicodeTargetName.Length +
           NtLmGlobalUnicodeComputerNameString.Length +
           pDnsComputerName->Length +
           pDnsTargetName->Length +
           pDnsTreeName->Length +
           sizeof( AvFlags ) +
           (sizeof( MSV1_0_AV_PAIR ) * 6) +
           sizeof( MSV1_0_AV_PAIR );

    NtLmGlobalNtLm3TargetInfo.Buffer = (PWSTR)NtLmAllocate( cbAV );

    if( NtLmGlobalNtLm3TargetInfo.Buffer == NULL )
    {
        SspPrint((SSP_CRITICAL, "SsprUpdateTargetInfo, Error from NtLmAllocate\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory( NtLmGlobalNtLm3TargetInfo.Buffer, cbAV );

    pAV = MsvpAvlInit( NtLmGlobalNtLm3TargetInfo.Buffer );
    MsvpAvlAdd( pAV, MsvAvNbDomainName, &NtLmGlobalUnicodeTargetName, cbAV );
    MsvpAvlAdd( pAV, MsvAvNbComputerName, &NtLmGlobalUnicodeComputerNameString, cbAV );

    if( pDnsTargetName->Length != 0 && pDnsTargetName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsDomainName, pDnsTargetName, cbAV );
    }

    if( pDnsComputerName->Length != 0 && pDnsComputerName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsComputerName, pDnsComputerName, cbAV );
    }

    if( pDnsTreeName->Length != 0 && pDnsTreeName->Buffer != NULL )
    {
        MsvpAvlAdd( pAV, MsvAvDnsTreeName, pDnsTreeName, cbAV );
    }

    //
    // add in AvFlags into TargetInfo, if applicable.
    //

    if( NtLmGlobalForceGuest )
    {
        AvFlags |= MSV1_0_AV_FLAG_FORCE_GUEST;
    }

    if( AvFlags )
    {
        UNICODE_STRING AvString;

        AvString.Buffer = (PWSTR)&AvFlags;
        AvString.Length = sizeof( AvFlags );
        AvString.MaximumLength = AvString.Length;

        MsvpAvlAdd( pAV, MsvAvFlags, &AvString, cbAV );
    }


    NtLmGlobalNtLm3TargetInfo.Length = (USHORT)MsvpAvlLen( pAV, cbAV );
    NtLmGlobalNtLm3TargetInfo.MaximumLength = NtLmGlobalNtLm3TargetInfo.Length;


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\credhand.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    credhand.cxx

Abstract:

    API and support routines for handling credential handles.

Author:


    Cliff Van Dyke (CliffV) 26-Jun-1993
Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\credhand.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR

extern "C"
{

#include <nlp.h>

}

//
// Crit Sect to protect various globals in this module.
//

RTL_RESOURCE    SspCredentialCritSect;
LIST_ENTRY      SspCredentialList;

// This is the definition of a null session string.
// Change this if the definition changes

#define IsNullSessionString(x) (((x)->Length == 0) &&    \
                          ((x)->Buffer != NULL))


BOOLEAN
AlterRtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )
/*++
    This is here to catch cases that RtlEqualUnicodeString does not.
    For e.g, if String1 is (NULL,0,0) and String2 is ("",0,2),
    RtlEqualUnicodeString returned TRUE but we really want it to return FALSE
--*/
{
    BOOL fRet = RtlEqualUnicodeString(String1, String2, CaseInSensitive);

    if (fRet && (IsNullSessionString(String1) != IsNullSessionString(String2)))
    {
        fRet = FALSE;
    }
    return (fRet != 0);
}



NTSTATUS
SspCredentialReferenceCredential(
    IN ULONG_PTR CredentialHandle,
    IN BOOLEAN DereferenceCredential,
    OUT PSSP_CREDENTIAL * UserCredential
    )

/*++

Routine Description:

    This routine checks to see if the Credential is from a currently
    active client, and references the Credential if it is valid.

    The caller may optionally request that the client's Credential be
    removed from the list of valid Credentials - preventing future
    requests from finding this Credential.

    For a client's Credential to be valid, the Credential value
    must be on our list of active Credentials.


Arguments:

    CredentialHandle - Points to the CredentialHandle of the Credential
        to be referenced.

    DereferenceCredential - This boolean value indicates that that a call
        a single instance of this credential handle should be freed. If there
        are multiple instances, they should still continue to work.


Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

{
    PSSP_CREDENTIAL Credential = NULL;
    SECPKG_CALL_INFO CallInfo;
    ULONG DereferenceCount;

    *UserCredential = NULL ;


    if (LsaFunctions->GetCallInfo(&CallInfo))
    {
        DereferenceCount = CallInfo.CallCount;
    } else {
        ASSERT( (STATUS_INTERNAL_ERROR == STATUS_SUCCESS) );
        return STATUS_INTERNAL_ERROR;
    }


    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        CallInfo.Attributes |= SECPKG_CALL_IS_TCB;

        SspPrint(( SSP_LEAK_TRACK, "SspCredentialReferenceCredential: pid: 0x%lx handle: %p refcount: %lu\n",
                    CallInfo.ProcessId, CredentialHandle, DereferenceCount));
    }


    //
    // Acquire exclusive access to the Credential list
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );


    __try {

        Credential = (PSSP_CREDENTIAL)CredentialHandle;

        while( Credential->CredentialTag == SSP_CREDENTIAL_TAG_ACTIVE )
        {

            // Make sure we have the privilege of accessing
            // this handle

            if (((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0) &&
                 (Credential->ClientProcessID != CallInfo.ProcessId)
               )
            {
                break;
            }

            if (!DereferenceCredential) {
                InterlockedIncrement( (PLONG)&Credential->References );
            } else {

                LONG References;

                //
                // Decremenent the credential references, indicating
                // that a call to free

                ASSERT((DereferenceCount > 0));

                //
                // NOTE: subtract one off the deref count,
                // avoids an extra interlocked operation, since DerefCred will
                // decrement and check for refcnt == 0.
                //

                DereferenceCount--;

                if( DereferenceCount == 1 )
                {
                    References = InterlockedDecrement( (PLONG)&Credential->References );

                    ASSERT( (References > 0) );
                } else if( DereferenceCount > 1 )
                {

                    //
                    // there is no equivalent to InterlockedSubtract.
                    // so, turn it into an Add with some signed magic.
                    //

                    LONG DecrementToIncrement = 0 - DereferenceCount;

                    References = InterlockedExchangeAdd( (PLONG)&Credential->References, DecrementToIncrement );

                    ASSERT( ((References+DecrementToIncrement) > 0) );
                }
            }

            *UserCredential = Credential ;

            RtlReleaseResource( &SspCredentialCritSect );

            return STATUS_SUCCESS ;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SspPrint(( SSP_CRITICAL, "Tried to reference invalid Credential %p\n",
                       Credential ));

    }


    RtlReleaseResource( &SspCredentialCritSect );

    //
    // No match found
    //
    SspPrint(( SSP_API_MORE, "Tried to reference unknown Credential %p\n",
               CredentialHandle ));


    return STATUS_INVALID_HANDLE ;
}



NTSTATUS
SspCredentialGetPassword(
    IN PSSP_CREDENTIAL Credential,
    OUT PUNICODE_STRING Password
    )
/*++

Routine Description:

    This routine copies the password out of credential.

    NOTE: Locking is no longer required, because the caller is expected
    to NtLmDuplicateUnicodeString() the cipher text Password prior to
    passing it to this routine.  This change allows the following advantages:

    1. Avoid taking Credential list lock.
    2. Avoid having to avoid having to Re-hide the password after reveal.
    3. Avoid having to take locks elsewhere associated with hiding/revealing.


Arguments:

    Credential - Credential record to retrieve the password from.

    Password - UNICODE_STRING to store the password in.


Return Value:

    STATUS_NO_MEMORY - there was not enough memory to copy
        the password.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Credential->Password.Buffer != NULL ) {
        Status = NtLmDuplicatePassword(
                        Password,
                        &Credential->Password
                        );
    } else {
        RtlInitUnicodeString(
            Password,
            NULL
            );
    }

    return(Status);
}


PSSP_CREDENTIAL
SspCredentialLookupCredential(
    IN PLUID LogonId,
    IN ULONG CredentialUseFlags,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password
    )

/*++

Routine Description:

    This routine walks the list of credentials for this client looking
    for one that has the same supplemental credentials as those passed
    in.  If it is found, its reference count is increased and a pointer
    to it is returned.


Arguments:

    UserName - User name to match.

    DomainName - Domain name to match.

    Password - Password to match.


Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

{
    SspPrint((SSP_API_MORE, "Entering SspCredentialLookupCredential\n"));
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PSSP_CREDENTIAL Credential = NULL;
    PSSP_CREDENTIAL CredentialResult = NULL;
    PLIST_ENTRY ListHead;
    SECPKG_CALL_INFO CallInfo ;

    UNICODE_STRING EncryptedPassword;

    if ( !LsaFunctions->GetCallInfo( &CallInfo ) )
    {
        SspPrint(( SSP_CRITICAL, "SspCredentialLookupCredential: GetCallInfo returned FALSE\n" ));
        return NULL ;
    }

    ZeroMemory(&EncryptedPassword, sizeof(EncryptedPassword));

    Status = NtLmDuplicatePassword(&EncryptedPassword, Password);
    if(!NT_SUCCESS( Status ))
    {
        SspPrint(( SSP_CRITICAL, "SspCredentialLookupCredential: DuplicatePassword failed\n" ));
        return NULL;
    }

    SspHidePassword( &EncryptedPassword );

    //
    // Acquire exclusive access to the Credential list
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );

    ListHead = &SspCredentialList;

    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, SSP_CREDENTIAL, Next );

        //
        // we now allow matching and pooling of INBOUND creds, too.
        //


        //
        // We only want credentials from the same caller
        //
        if (Credential->ClientProcessID != CallInfo.ProcessId) {
            continue;
        }

        //
        // don't share creds across impersonation levels.
        //

        if (Credential->ImpersonationLevel != ImpersonationLevel)
        {
            continue;
        }

        //
        // if the caller is from kernel mode, only return creds
        // granted to kernel mode
        //

        if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
        {
            if ( !Credential->KernelClient )
            {
                continue;
            }
        }

        //
        // Check for a match
        //

        // The credential use check was added because null session
        // credentials were being returned when default credentials
        // were being asked. This happened becuase RtlEqualUnicodeString
        // for NULL,0,0 and "",0,2 is TRUE

        if ( (CredentialUseFlags != Credential->CredentialUseFlags) )
        {
            continue;
        }

        if(!RtlEqualLuid(
                LogonId,
                &Credential->LogonId
                ))
        {
            continue;
        }

        if(!AlterRtlEqualUnicodeString(
                UserName,
                &Credential->UserName,
                FALSE
                ))
        {
            continue;
        }

        if(!AlterRtlEqualUnicodeString(
                DomainName,
                &Credential->DomainName,
                FALSE
                ))
        {
            continue;
        }

        //
        // password is stored encrypted in list -- we're comparing
        // a one-time encrypted version of candidate.  advantages:
        // 1. passwords not revealed in memory.
        // 2. only need encrypt candidate single time.
        //

        if(!AlterRtlEqualUnicodeString(
                &Credential->Password,
                &EncryptedPassword,
                FALSE
                ))
        {
            continue;
        }

        //
        // Found a match - reference the credential
        //


        //
        // Reference the credential and indicate that
        // it is in use as two different handles to the caller
        // (who may call FreeCredentialsHandle twice)
        //

        InterlockedIncrement( (PLONG)&Credential->References );

        CredentialResult = Credential;
        break;
    }


    RtlReleaseResource( &SspCredentialCritSect );

    if( EncryptedPassword.Buffer != NULL ) {
        ZeroMemory( EncryptedPassword.Buffer, EncryptedPassword.Length );
        NtLmFree( EncryptedPassword.Buffer );
    }


    if( CredentialResult == NULL )
    {
        SspPrint(( SSP_API_MORE, "Tried to reference unknown Credential\n" ));
    }

    SspPrint((SSP_API_MORE, "Leaving SspCredentialLookupCredential\n"));

    return CredentialResult;
}


VOID
SspCredentialDereferenceCredential(
    IN PSSP_CREDENTIAL Credential
    )

/*++

Routine Description:

    This routine decrements the specified Credential's reference count.
    If the reference count drops to zero, then the Credential is deleted

Arguments:

    Credential - Points to the Credential to be dereferenced.


Return Value:

    None.

--*/

{
    LONG References;

    //
    // Decrement the reference count
    //

    References = InterlockedDecrement( (PLONG)&Credential->References );

    ASSERT( References >= 0 );

    //
    // If the count dropped to zero, then run-down the Credential
    //

    if ( References == 0 )
    {

        if (!Credential->Unlinked) {

            RtlAcquireResourceExclusive(&SspCredentialCritSect, TRUE);

            if( Credential->References != 0 )
            {
                RtlReleaseResource( &SspCredentialCritSect );
                return;
            }

            RemoveEntryList( &Credential->Next );
            Credential->Unlinked = TRUE;
            Credential->CredentialTag = SSP_CREDENTIAL_TAG_DELETE;

            RtlReleaseResource( &SspCredentialCritSect );
        }

        SspPrint(( SSP_API_MORE, "Deleting Credential 0x%lx\n",
                   Credential ));

        if ( Credential->Password.Buffer ) {
            ZeroMemory( Credential->Password.Buffer, Credential->Password.MaximumLength );
            (VOID) NtLmFree( Credential->Password.Buffer );
        }

        if ( Credential->DomainName.Buffer ) {
            (VOID) NtLmFree( Credential->DomainName.Buffer );
        }

        if ( Credential->UserName.Buffer ) {
            (VOID) NtLmFree( Credential->UserName.Buffer );
        }


        ZeroMemory( Credential, sizeof(SSP_CREDENTIAL) );
        (VOID) NtLmFree( Credential );
    }

    return;
}

BOOLEAN
SsprCheckMachineLogon(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password,
    IN OUT PLUID pLogonId,
    IN OUT ULONG *pCredFlags
    )
/*++

Routine Description:

    This routine determines if the input credential matches a special
    machine account logon over-ride.

    This routine also checks if the caller is the NetworkService account,
    specifying default credentials, in a downlevel domain.  This will cause
    a credential over-ride to LocalSystem, for backwards compatibility.
    NT4 did not understand machine account authentication, so outbound authentication
    from networkservice as machine account cannot succeed -- downgrade to the old
    LocalSystem default.


Return Value:

    TRUE - the intput credential was the special machine account logon over-ride.
           the pLogonId is updated to utilize the machine credential.

--*/
{
    UNICODE_STRING MachineAccountName;
    static LUID LogonIdAnonymous = ANONYMOUS_LOGON_LUID;
    static LUID LogonIdSystem = SYSTEM_LUID;
    static LUID LogonIdNetworkService = NETWORKSERVICE_LUID;
    BOOLEAN fMachineLogon = FALSE;

    MachineAccountName.Buffer = NULL;

    //
    // if caller is NetworkService with default cred, for downlevel domains
    // use anonymous
    //

    if (RtlEqualLuid( pLogonId, &LogonIdNetworkService ))
    {
        if ( UserName->Buffer == NULL &&
            DomainName->Buffer == NULL &&
            Password->Buffer == NULL )
        {
            BOOL MixedMode = FALSE;
            NTSTATUS Status;

            if ( !NlpNetlogonInitialized )
            {
                Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

                if ( NT_SUCCESS(Status) )
                {
                    NlpNetlogonInitialized = TRUE;
                }
            }

            if (NlpNetlogonInitialized)
            {
                ASSERT(NlpNetLogonMixedDomain && L"NlpNetLogonMixedDomain must be non null");

                Status = (*NlpNetLogonMixedDomain)(&MixedMode);
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SsprCheckMachineLogon call to I_NetLogonMixedDomain failed %#x\n", Status));
                    MixedMode = FALSE;
                }
            }

            if (MixedMode)
            {
                SspPrint((SSP_WARNING, "SsprCheckMachineLogon using anonymous connection for networkservices\n"));
                *pLogonId = LogonIdAnonymous; // use anonymous
                *pCredFlags |= SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE;

                // return FALSE;
            }
            else
            {
                return TRUE;
            }
        }

        return FALSE;
    }

    //
    // check if caller was system, and requested machine credential
    // eg: user=computername$, domain=NULL, password=NULL
    //

    if ( !RtlEqualLuid( pLogonId, &LogonIdSystem ) )
    {
        return FALSE;
    }

    if( UserName->Buffer == NULL )
    {
        return FALSE;
    }

    if( DomainName->Buffer != NULL )
    {
        return FALSE;
    }

    if( Password->Buffer != NULL )
    {
        return FALSE;
    }


    RtlAcquireResourceShared (&NtLmGlobalCritSect, TRUE);

    MachineAccountName.Length = NtLmGlobalUnicodeComputerNameString.Length + sizeof(WCHAR);

    if( MachineAccountName.Length == UserName->Length )
    {
        MachineAccountName.MaximumLength = MachineAccountName.Length;
        MachineAccountName.Buffer = (PWSTR)NtLmAllocate( MachineAccountName.Length );

        if( MachineAccountName.Buffer != NULL )
        {
            RtlCopyMemory(  MachineAccountName.Buffer,
                            NtLmGlobalUnicodeComputerNameString.Buffer,
                            NtLmGlobalUnicodeComputerNameString.Length
                            );

            MachineAccountName.Buffer[ (MachineAccountName.Length / sizeof(WCHAR)) - 1 ] = L'$';
        }
    }

    RtlReleaseResource (&NtLmGlobalCritSect);


    if( MachineAccountName.Buffer == NULL )
    {
        goto Cleanup;
    }

    if( RtlEqualUnicodeString( &MachineAccountName, UserName, TRUE ) )
    {
        //
        // yes, it's a machine account logon request, update the
        // requested LogonId to match our mapped logon session.
        //

        *pLogonId = NtLmGlobalLuidMachineLogon;
        fMachineLogon = TRUE;
    }

Cleanup:

    if( MachineAccountName.Buffer )
    {
        NtLmFree( MachineAccountName.Buffer );
    }

    return fMachineLogon;
}


NTSTATUS
SsprAcquireCredentialHandle(
    IN PLUID LogonId,
    IN PSECPKG_CLIENT_INFO ClientInfo,
    IN ULONG CredentialUseFlags,
    OUT PLSA_SEC_HANDLE CredentialHandle,
    OUT PTimeStamp Lifetime,
    IN OPTIONAL PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING UserName,
    IN OPTIONAL PUNICODE_STRING Password
    )

/*++

Routine Description:

    This API allows applications to acquire a handle to pre-existing
    credentials associated with the user on whose behalf the call is made
    i.e. under the identity this application is running.  These pre-existing
    credentials have been established through a system logon not described
    here.  Note that this is different from "login to the network" and does
    not imply gathering of credentials.


    This API returns a handle to the credentials of a principal (user, client)
    as used by a specific security package.  This handle can then be used
    in subsequent calls to the Context APIs.  This API will not let a
    process obtain a handle to credentials that are not related to the
    process; i.e. we won't allow a process to grab the credentials of
    another user logged into the same machine.  There is no way for us
    to determine if a process is a trojan horse or not, if it is executed
    by the user.

Arguments:

    CredentialUseFlags - Flags indicating the way with which these
        credentials will be used.

        #define     CRED_INBOUND        0x00000001
        #define     CRED_OUTBOUND       0x00000002
        #define     CRED_BOTH           0x00000003

        The credentials created with CRED_INBOUND option can only be used
        for (validating incoming calls and can not be used for making accesses.

    CredentialHandle - Returned credential handle.

    Lifetime - Time that these credentials expire. The value returned in
        this field depends on the security package.

    DomainName, DomainNameSize, UserName, UserNameSize, Password, PasswordSize -
        Optional credentials for this user.

Return Value:

    STATUS_SUCCESS -- Call completed successfully

    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
    SEC_E_NOT_OWNER -- caller does not own the specified credentials
    STATUS_NO_MEMORY -- Not enough memory

--*/

{
    SspPrint((SSP_API_MORE, "Entering SsprAcquireCredentialHandle\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential = NULL;
    ULONG CredFlags = 0; // ntlm specific cred use flags


    if ((CredentialUseFlags & SECPKG_CRED_OUTBOUND) != 0) {

        //
        // check if machine account logon over-ride.
        // this has the side-effect of updating LogonId if over-ride was
        // requsted.
        //

        SsprCheckMachineLogon(
            UserName,
            DomainName,
            Password,
            LogonId,
            &CredFlags
            );
    }

    //
    // Look to see if we have already created one with this set of credentials.
    // Note - this leaves the credential referenced, so if we fail further down
    // we need to dereference the credential.
    //

    Credential = SspCredentialLookupCredential(
        LogonId,
        CredentialUseFlags,
        ClientInfo->ImpersonationLevel,
        UserName,
        DomainName,
        Password
        );

    //
    // If we're using a common set of data, free the captured stuff
    //

    if ( Credential )
    {
        if ( (UserName) && (UserName->Buffer) )
        {
            NtLmFree( UserName->Buffer );
            UserName->Buffer = NULL ;
        }

        if ( ( DomainName ) && (DomainName->Buffer) )
        {
            NtLmFree( DomainName->Buffer );
            DomainName->Buffer = NULL ;
        }

        if ( ( Password ) && ( Password->Buffer ) )
        {
            ZeroMemory( Password->Buffer, Password->Length );
            NtLmFree( Password->Buffer );
            Password->Buffer = NULL ;
        }

        Credential->MutableCredFlags = CredFlags; // atomic
    }

    //
    // If we didn't just find a credential, create one now.
    //

    if (Credential == NULL) {

        SECPKG_CALL_INFO CallInfo ;

        if ( !LsaFunctions->GetCallInfo( &CallInfo ) )
        {
            SspPrint((SSP_CRITICAL, "SsprAcquireCredentialHandle failed to GetCallInfo\n"));
            Status = STATUS_UNSUCCESSFUL ;
            goto Cleanup;
        }

        //
        // Allocate a credential block and initialize it.
        //

        Credential = (PSSP_CREDENTIAL)NtLmAllocate(sizeof(SSP_CREDENTIAL) );

        if ( Credential == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "Error from NtLmAllocate 0x%lx\n", Status));
            goto Cleanup;
        }

        ZeroMemory( Credential, sizeof(*Credential) );

        Credential->References = 1;
        Credential->ClientProcessID = ClientInfo->ProcessID;
        Credential->CredentialUseFlags = CredentialUseFlags;
        Credential->MutableCredFlags = CredFlags;
        Credential->ImpersonationLevel = ClientInfo->ImpersonationLevel;
        Credential->Unlinked = TRUE;

        if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
        {
            Credential->KernelClient = TRUE ;
        }
        else
        {
            Credential->KernelClient = FALSE ;
        }


        //
        // Stick the logon ID in the credential
        //

        Credential->LogonId = *LogonId;

        //
        // Stick the supplemental credentials into the credential.
        //

        if (ARGUMENT_PRESENT(DomainName))
        {
            Credential->DomainName = *DomainName;
        }

        if (ARGUMENT_PRESENT(UserName))
        {
            Credential->UserName = *UserName;
        }

        if (ARGUMENT_PRESENT(Password))
        {
            SspHidePassword(Password);
            Credential->Password = *Password;
        }

        //
        // Add it to the list of valid credential handles.
        //

        Credential->Unlinked = FALSE;
        Credential->CredentialTag = SSP_CREDENTIAL_TAG_ACTIVE;

        RtlAcquireResourceExclusive( &SspCredentialCritSect, TRUE );
        InsertHeadList( &SspCredentialList, &Credential->Next );
        RtlReleaseResource( &SspCredentialCritSect );

        SspPrint((SSP_API_MORE, "Added Credential 0x%lx\n", Credential ));

        //
        // Don't bother dereferencing because we already set the
        // reference count to 1.
        //
    }

    //
    // Return output parameters to the caller.
    //

    *CredentialHandle = (LSA_SEC_HANDLE) Credential;

    *Lifetime = NtLmGlobalForever;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {

        if ( Credential != NULL ) {
            (VOID)NtLmFree( Credential );
        }

    }

    SspPrint((SSP_API_MORE, "Leaving SsprAcquireCredentialHandle\n"));

    return Status;
}


NTSTATUS
SsprFreeCredentialHandle(
    IN ULONG_PTR CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:


    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    STATUS_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential;

    SspPrint(( SSP_API_MORE, "SspFreeCredentialHandle Entered\n" ));

    //
    // Find the referenced credential and delink it.
    //

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            TRUE,       // remove the instance of the credential
                            &Credential );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    //
    // Dereferencing the Credential will remove the client's reference
    // to it, causing it to be rundown if nobody else is using it.
    //

    SspCredentialDereferenceCredential( Credential );

    //
    // Free and locally used resources.
    //
Cleanup:


    SspPrint(( SSP_API_MORE, "SspFreeCredentialHandle returns 0x%lx\n", Status ));
    return Status;
}

NTSTATUS
SspCredentialInitialize(
    VOID
    )

/*++

Routine Description:

    This function initializes this module.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{
    //
    // Initialize the Credential list to be empty.
    //

    RtlInitializeResource(&SspCredentialCritSect);
    InitializeListHead( &SspCredentialList );

    return STATUS_SUCCESS;

}


VOID
SspCredentialTerminate(
    VOID
    )

/*++

Routine Description:

    This function cleans up any dangling credentials.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/

{
#if 0
    NTSTATUS Status ;

    //
    // Drop any lingering Credentials
    //

    RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );
    while ( !IsListEmpty( &SspCredentialList ) ) {
        ULONG_PTR CredentialHandle;
        PSSP_CREDENTIAL Credential;

        CredentialHandle =
            (LSA_SEC_HANDLE) CONTAINING_RECORD( SspCredentialList.Flink,
                                      SSP_CREDENTIAL,
                                      Next );


        RtlReleaseResource( &SspCredentialCritSect );

        Status = SspCredentialReferenceCredential(
                                CredentialHandle,
                                TRUE,
                                TRUE,
                                &Credential );            // Remove Credential

        if ( Credential != NULL ) {
            SspCredentialDereferenceCredential(Credential);
        }

        RtlAcquireResourceShared( &SspCredentialCritSect, TRUE );
    }
    RtlReleaseResource( &SspCredentialCritSect );


    //
    // Delete the critical section
    //

    RtlDeleteResource(&SspCredentialCritSect);
#endif

    return;

}

BOOL
SspEnableAllPrivilegesToken(
    IN  HANDLE ClientTokenHandle
    )
{
    PTOKEN_PRIVILEGES pPrivileges;
    BYTE FastBuffer[ 512 ];
    PBYTE SlowBuffer = NULL;
    DWORD cbPrivileges;
    BOOL fSuccess;

    pPrivileges = (PTOKEN_PRIVILEGES)FastBuffer;
    cbPrivileges = sizeof( FastBuffer );

    fSuccess = GetTokenInformation(
                ClientTokenHandle,
                TokenPrivileges,
                pPrivileges,
                cbPrivileges,
                &cbPrivileges
                );

    if( !fSuccess ) {

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            return FALSE;

        SlowBuffer = (PBYTE)NtLmAllocate( cbPrivileges );
        if( SlowBuffer == NULL )
            return FALSE;

        pPrivileges = (PTOKEN_PRIVILEGES)SlowBuffer;

        fSuccess = GetTokenInformation(
                        ClientTokenHandle,
                        TokenPrivileges,
                        pPrivileges,
                        cbPrivileges,
                        &cbPrivileges
                        );
    }


    if( fSuccess && pPrivileges->PrivilegeCount != 0 ) {
        DWORD indexPrivilege;

        for( indexPrivilege = 0 ;
             indexPrivilege < pPrivileges->PrivilegeCount ;
             indexPrivilege ++ )
        {
            pPrivileges->Privileges[ indexPrivilege ].Attributes |=
                SE_PRIVILEGE_ENABLED;
        }

        fSuccess = AdjustTokenPrivileges(
                        ClientTokenHandle,
                        FALSE,
                        pPrivileges,
                        0,
                        NULL,
                        NULL
                        );

        if( fSuccess && GetLastError() != ERROR_SUCCESS )
            fSuccess = FALSE;
    }

    if( SlowBuffer )
        NtLmFree( SlowBuffer );

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for the NtLm security package
//              Main entry points into this dll:
//                SpDeleteContext
//                SpInitLsaModeContext
//                SpApplyControlToken
//                SpAcceptLsaModeContext
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\ctxtapi.cxx
//              JClark   28-Jun-2000   Added WMI Trace Logging Support
//
//------------------------------------------------------------------------
#define NTLM_CTXTAPI
#include <global.h>
#include "Trace.h"



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes an NtLm context
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteContext(
    IN ULONG_PTR ContextHandle
    )
/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context.

    This API terminates a context on the local machine.

Arguments:

    ContextHandle - Handle to the context to delete


Return Value:

    STATUS_SUCCESS - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG_PTR TempContextHandle = ContextHandle;
    SspPrint((SSP_API, "Entering SpDeleteContext for 0x%x\n", ContextHandle));

    Status = SsprDeleteSecurityContext(
                    TempContextHandle );

    SspPrint((SSP_API, "Leaving SpDeleteContext for 0x%x\n", ContextHandle));
    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   NtLm implementation of InitializeSecurityContext
//              while in Lsa mode. If we return TRUE in *MappedContext,
//              secur32 will call SpInitUserModeContext with
//              the returned context handle and ContextData
//              as input. Fill in whatever info needed for
//              the user mode apis
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: This function can be called in various ways:
//         1. Generic users of ntlm make the first call to
//            InitializeSecurityContext and we return a NEGOTIATE_MESSAGE
//         2. The rdr makes the first call to InitializeSecurityContext
//            with no contextHandle but info is passed in through a
//            CHALLENGE_MESSAGE (& possibly an NTLM_CHALLENGE_MESSAGE),
//            we return an AUTHENTICATE_MESSAGE and an
//            NTLM_INITIALIZE_RESPONSE
//         3. Generic users of NTLM make the second call to
//            InitializeSecurityContext, passing in a CHALLENGE_MESSAGE
//            and we return an AUTHENTICATE_MESSAGE
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitLsaModeContext(
    IN OPTIONAL ULONG_PTR CredentialHandle,
    IN OPTIONAL ULONG_PTR OldContextHandle,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputBuffers,
    OUT PULONG_PTR NewContextHandle,
    IN OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    SecBuffer TempTokens[4];
    PSecBuffer FirstInputToken;
    PSecBuffer SecondInputToken;
    PSecBuffer FirstOutputToken;
    PSecBuffer SecondOutputToken;

    ULONG_PTR OriginalContextHandle = NULL;
    ULONG_PTR TempContextHandle = NULL;
    ULONG NegotiateFlags = 0;
    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    UINT32          TraceHint = 0;


    SspPrint((SSP_API, "Entering SpInitLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));


    //Begin tracing an InitializeSecurityContext call for NTLM
    if (NtlmGlobalEventTraceFlag){           
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmInitializeGuid, 
                         EVENT_TRACE_TYPE_START, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         2);                                            

        TraceHint = (OldContextHandle == 0)?
            TRACE_INIT_FIRST:
            TRACE_INIT_CHALLENGE;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);
        
        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }



    RtlZeroMemory(
        TempTokens,
        sizeof(TempTokens)
        );

    FirstInputToken = &TempTokens[0];
    SecondInputToken = &TempTokens[1];
    FirstOutputToken = &TempTokens[2];
    SecondOutputToken = &TempTokens[3];


    *MappedContext = FALSE;

    ASSERT(ContextData);

    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;

    RtlZeroMemory(SessionKey,
                  MSV1_0_USER_SESSION_KEY_LENGTH);

    UNREFERENCED_PARAMETER( TargetDataRep );

    //
    // Extract tokens from the SecBuffers
    //

    if ( !SspGetTokenBuffer( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstInputToken,
                             TRUE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (FirstInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    //  If we are using supplied credentials, get the second SECBUFFER_TOKEN
    //

    if (ContextReqFlags & ISC_REQ_USE_SUPPLIED_CREDS)
    {
        if ( !SspGetTokenBuffer( InputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondInputToken,
                             TRUE
                             ) ) {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (SecondInputToken) returns %d\n", Status));
            goto Cleanup;
        }
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstOutputToken,
                             FALSE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (FirstOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondOutputToken,
                             FALSE
                             ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspGetTokenBuffer (SecondOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    // Save the old context handle, in case someone changes it
    //

    TempContextHandle = OldContextHandle;
    OriginalContextHandle = OldContextHandle;

    //
    // If no previous context was passed
    // and if no legitimate input token existed, this is the first call
    //

    if ((OriginalContextHandle == 0 ) &&
        (FirstInputToken->cbBuffer == 0))
    {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            Status = STATUS_INVALID_HANDLE;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, No CredentialHandle\n"));
            goto Cleanup;
        }

        *NewContextHandle = 0;

        Status = SsprHandleFirstCall(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        TargetName,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags );

        TempContextHandle = *NewContextHandle;
    //
    // If context was passed in, continue where we left off.
    // Or if the redir's passing in stuff in the InputBuffers,
    // skip the first call and get on with the second
    //

    } else {

        *NewContextHandle = OldContextHandle;

        Status = SsprHandleChallengeMessage(
                        CredentialHandle,
                        &TempContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        SecondInputToken->cbBuffer,
                        SecondInputToken->pvBuffer,
                        TargetName,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        &SecondOutputToken->cbBuffer,
                        &SecondOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags
                        );
    }

    //
    // If the original handle is zero, set it to be the TempContextHandle.
    // This is for the datagram case, where we map the context after the
    // first call to initialize.
    //

    if (OriginalContextHandle == 0) {

        OriginalContextHandle = TempContextHandle;
        *NewContextHandle = OriginalContextHandle;
    }
    //
    // Only map the context if this is the real authentication, not a re-auth
    // or if this was datagram.
    //

    if (((Status == SEC_I_CONTINUE_NEEDED) &&
         ((*ContextAttributes & ISC_RET_DATAGRAM) != 0)) ||
        ((Status == SEC_E_OK) &&
         ((*ContextAttributes & (SSP_RET_REAUTHENTICATION | ISC_RET_DATAGRAM)) == 0))) {

        NTSTATUS TempStatus;

        TempStatus = SspMapContext(
                        &OriginalContextHandle,
                        SessionKey,
                        NegotiateFlags,
                        NULL,               // no token handle for clients
                        NULL,               // no password expiry for clients
                        0,                  // no userflags
                        ContextData
                        );

        if (!NT_SUCCESS(TempStatus)) {
            Status = TempStatus;
            SspPrint((SSP_CRITICAL, "SpInitLsaModeContext, SspMapContext returns %d\n", Status));
            goto Cleanup;
        }

        SspPrint((SSP_SESSION_KEYS, "Init sessionkey %lx %lx %lx %lx\n",
                ((DWORD*)SessionKey)[0],
                ((DWORD*)SessionKey)[1],
                ((DWORD*)SessionKey)[2],
                ((DWORD*)SessionKey)[3]
                ));


        //
        // Yes, do load msv1_0.dll in the client's process
        // and ContextData will contain info to be passed on
        // to the InitializeSecurityContext counterpart that
        // runs in the client's process

        *MappedContext = TRUE;
    }

    //
    // Make sure this bit isn't sent to the caller
    //

    *ContextAttributes &= ~SSP_RET_REAUTHENTICATION;


Cleanup:

    // Send the output stuff
    // pvBuffer is reassigned in case ISC-REQ_ALLOCATE_MEMORY has ben defined

//    if (OutputBuffers != NULL && OutputBuffers->cBuffers > 0 && OutputBuffers->pBuffers != NULL)
//    {
//        OutputBuffers->pBuffers->cbBuffer =  FirstOutputToken.cbBuffer;
//        OutputBuffers->pBuffers->pvBuffer =  FirstOutputToken.pvBuffer;
//    }

    SspPrint((SSP_API, "Leaving  SpInitLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //
    // Convert and save, will be (perhaps traced then) returned
    //
    Status = (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

    //
    //Trace the end of this call
    //
    if (NtlmGlobalEventTraceFlag){

        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmInitializeGuid, 
                         EVENT_TRACE_TYPE_END, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         4);
                         
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        NewContextHandle);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Status);
        
        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }
    
    return Status;
}



NTSTATUS NTAPI
SpApplyControlToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc ControlToken
    )
{
    SspPrint((SSP_API, "Entering SpApplyControlToken\n"));
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(ControlToken);
    SspPrint((SSP_API, "Leaving  SpApplyControlToken\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   NtLm implementation of AcceptSecurityContext call.
//              This routine accepts an AP request message from a client
//              and verifies that it is a valid ticket. If mutual
//              authentication is desired an AP reply is generated to
//              send back to the client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------




NTSTATUS NTAPI
SpAcceptLsaModeContext(
    IN OPTIONAL ULONG_PTR CredentialHandle,
    IN OPTIONAL ULONG_PTR OldContextHandle,
    IN PSecBufferDesc InputBuffers,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    OUT PULONG_PTR NewContextHandle,
    OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
/*++

Routine Description:

    Allows a remotely initiated security context between the application
    and a remote peer to be established.  To complete the establishment of
    context one or more reply tokens may be required from remote peer.

    This function is the server counterpart to the
    InitializeSecurityContext API.  The ContextAttributes is a bit mask
    representing various context level functions viz.  delegation, mutual
    authentication, confidentiality, replay detection and sequence
    detection.  This API is used by the server side.  When a request comes
    in, the server uses the ContextReqFlags parameter to specify what
    it requires of the session.  In this fashion, a server can specify that
    clients must be capable of using a confidential or integrity checked
    session, and fail clients that can't meet that demand.  Alternatively,
    a server can require nothing, and whatever the client can provide or
    requires is returned in the pfContextAttributes parameter.  For a
    package that supports 3 leg mutual authentication, the calling sequence
    would be: Client provides a token, server calls Accept the first time,
    generating a reply token.  The client uses this in a second call to
    InitializeSecurityContext, and generates a final token.  This token is
    then used in the final call to Accept to complete the session.  Another
    example would be the LAN Manager/NT authentication style.  The client
    connects to negotiate a protocol.  The server calls Accept to set up a
    context and generate a challenge to the client.  The client calls
    InitializeSecurityContext and creates a response.  The server then
    calls Accept the final time to allow the package to verify the response
    is appropriate for the challenge.

Arguments:

   CredentialHandle - Handle to the credentials to be used to
       create the context.

   OldContextHandle - Handle to the partially formed context, if this is
       a second call (see above) or NULL if this is the first call.

   InputToken - Pointer to the input token.  In the first call this
       token can either be NULL or may contain security package specific
       information. 

   ContextReqFlags - Requirements of the context, package specific.

      #define ASC_REQ_DELEGATE         0x00000001
      #define ASC_REQ_MUTUAL_AUTH      0x00000002
      #define ASC_REQ_REPLAY_DETECT    0x00000004
      #define ASC_REQ_SEQUENCE_DETECT  0x00000008
      #define ASC_REQ_CONFIDENTIALITY  0x00000010
      #define ASC_REQ_ALLOCATE_MEMORY 0x00000100
      #define ASC_REQ_USE_DCE_STYLE    0x00000200

   TargetDataRep - Long indicating the data representation (byte ordering, etc)
        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
        by the transport indicating that the native format is in use.

   NewContextHandle - New context handle.  If this is a second call, this
       can be the same as OldContextHandle.

   OutputToken - Buffer to receive the output token.

   ContextAttributes -Attributes of the context established.

        #define ASC_RET_DELEGATE          0x00000001
        #define ASC_RET_MUTUAL_AUTH       0x00000002
        #define ASC_RET_REPLAY_DETECT     0x00000004
        #define ASC_RET_SEQUENCE_DETECT   0x00000008
        #define ASC_RET_CONFIDENTIALITY   0x00000010
        #define ASC_RET_ALLOCATED_BUFFERS 0x00000100
        #define ASC_RET_USED_DCE_STYLE    0x00000200

   ExpirationTime - Expiration time of the context.

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    SecBuffer TempTokens[3];
    PSecBuffer FirstInputToken;
    PSecBuffer SecondInputToken;
    PSecBuffer FirstOutputToken;

    ULONG NegotiateFlags = 0;
    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    HANDLE TokenHandle = NULL;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    TimeStamp PasswordExpiry;
    ULONG UserFlags;

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    UINT32          TraceHint = 0;
            
    SspPrint((SSP_API, "Entering SpAcceptLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //Begin tracing an AcceptSecurityContext call for NTLM
    if (NtlmGlobalEventTraceFlag){
        
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmAcceptGuid, 
                         EVENT_TRACE_TYPE_START, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         2);

        TraceHint = (OldContextHandle == 0)?
            TRACE_ACCEPT_NEGOTIATE:
            TRACE_ACCEPT_AUTHENTICATE;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);
        
        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    FirstInputToken = &TempTokens[0];
    SecondInputToken = &TempTokens[1];
    FirstOutputToken = &TempTokens[2];

    RtlZeroMemory(
        TempTokens,
        sizeof(TempTokens)
        );

    RtlZeroMemory(
        SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    *MappedContext = FALSE;

    //
    // Validate the arguments
    //

    UNREFERENCED_PARAMETER( TargetDataRep );


    if ( !SspGetTokenBuffer( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstInputToken,
                             TRUE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (FirstInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( InputBuffers,
                             1,   // get the second SECBUFFER_TOKEN
                             &SecondInputToken,
                             TRUE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (SecondInputToken) returns %d\n", Status));
        goto Cleanup;
    }

    if ( !SspGetTokenBuffer( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &FirstOutputToken,
                             FALSE ) ) {
        Status = SEC_E_INVALID_TOKEN;
        SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspGetTokenBuffer (FirstOutputToken) returns %d\n", Status));
        goto Cleanup;
    }

    //
    // If no previous context was passed in this is the first call.
    //

    if ( (OldContextHandle  == 0 ) &&
         (SecondInputToken->cbBuffer == 0)) {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            Status = SEC_E_INVALID_HANDLE;
            SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, No CredentialHandle\n"));
            goto Cleanup;
        }

        Status = SsprHandleNegotiateMessage(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime );

    //
    // If context was passed in, continue where we left off.
    //

    } else {

        *NewContextHandle = OldContextHandle;

        Status = SsprHandleAuthenticateMessage(
                        CredentialHandle,
                        NewContextHandle,
                        ContextReqFlags,
                        FirstInputToken->cbBuffer,
                        FirstInputToken->pvBuffer,
                        SecondInputToken->cbBuffer,
                        SecondInputToken->pvBuffer,
                        &FirstOutputToken->cbBuffer,
                        &FirstOutputToken->pvBuffer,
                        ContextAttributes,
                        ExpirationTime,
                        SessionKey,
                        &NegotiateFlags,
                        &TokenHandle,
                        &SubStatus,
                        &PasswordExpiry,
                        &UserFlags
                        );

        //
        // for errors such as PASSWORD_EXPIRED, return the SubStatus, which
        // is more descriptive than the generic error code.
        //

        if( Status == STATUS_ACCOUNT_RESTRICTION )
            Status = SubStatus;
    }

    if ((Status == SEC_E_OK) &&
        !(*ContextAttributes & SSP_RET_REAUTHENTICATION)) {
        Status = SspMapContext(
                        NewContextHandle,
                        SessionKey,
                        NegotiateFlags,
                        TokenHandle,
                        &PasswordExpiry,
                        UserFlags,
                        ContextData
                        );

        if (!NT_SUCCESS(Status)) {
            SspPrint((SSP_CRITICAL, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
            goto Cleanup;
        }

        SspPrint((SSP_SESSION_KEYS, "Accept sessionkey %lx %lx %lx %lx\n",
                ((DWORD*)SessionKey)[0],
                ((DWORD*)SessionKey)[1],
                ((DWORD*)SessionKey)[2],
                ((DWORD*)SessionKey)[3]
                ));

        *MappedContext = TRUE;


    } else {

        //
        // Make sure this bit isn't sent to the caller
        //

        *ContextAttributes &= ~SSP_RET_REAUTHENTICATION;
    }

Cleanup:

    if (TokenHandle != NULL) {
        NtClose(TokenHandle);
    }

    // TODO: this really necessary since we're in LSA mode???
    SetLastError(RtlNtStatusToDosError(SubStatus));


    SspPrint((SSP_API, "Leaving SpAcceptLsaModeContext for Old:0x%x, New:0x%x\n", OldContextHandle, *NewContextHandle));

    //Convert and save, will be (perhaps traced then) returned
    Status = (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

    //Trace the end of this call
    if (NtlmGlobalEventTraceFlag){
        
        //Header goo
        SET_TRACE_HEADER(TraceInfo, 
                         NtlmAcceptGuid, 
                         EVENT_TRACE_TYPE_END, 
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR, 
                         4);
                         
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);
        
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        OldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        NewContextHandle);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Status);
        
        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }

    // Converted to SecStatus before tracing
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ctxtcli.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    ctxtcli.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc
#include <credp.h>

#include "nlp.h"



NTSTATUS
SsprHandleFirstCall(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN PUNICODE_STRING TargetServerName OPTIONAL,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    )

/*++

Routine Description:

    Handle the First Call part of InitializeSecurityContext.

Arguments:

    All arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS -- All OK
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{

    SspPrint(( SSP_API_MORE, "Entering SsprHandleFirstCall\n" ));
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context      = NULL;
    PSSP_CREDENTIAL Credential = NULL;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;
    ULONG NegotiateMessageSize = 0;
    PCHAR Where = NULL;

    ULONG NegotiateFlagsKeyStrength;

    STRING NtLmLocalOemComputerNameString;
    STRING NtLmLocalOemPrimaryDomainNameString;


    //
    // Initialization
    //

    *ContextAttributes = 0;
    *NegotiateFlags = 0;

    RtlInitString( &NtLmLocalOemComputerNameString, NULL );
    RtlInitString( &NtLmLocalOemPrimaryDomainNameString, NULL );

    //
    // Get a pointer to the credential
    //

    Status = SspCredentialReferenceCredential(
                    CredentialHandle,
                    FALSE,
                    &Credential );

    if ( !NT_SUCCESS( Status ) )
    {
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: invalid credential handle.\n" ));
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_OUTBOUND) == 0 ) {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: invalid credential use.\n" ));
        goto Cleanup;
    }

    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext( );

    if ( Context == NULL) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: SspContextAllocateContext returned NULL\n"));
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    *ContextHandle = (LSA_SEC_HANDLE) Context;

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & ISC_REQ_PROMPT_FOR_CREDS) != 0 ) {

        Status = SEC_E_INVALID_CONTEXT_REQ;
        SspPrint(( SSP_CRITICAL,
                   "SsprHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        goto Cleanup;
    }

    //
    // Capture the default credentials from the credential structure.
    //

    if ( Credential->DomainName.Buffer != NULL ) {
        Status = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &Credential->DomainName
                        );
        if (!NT_SUCCESS(Status)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmDuplicateUnicodeString (DomainName) returned %d\n",Status));
            goto Cleanup;
        }
    }
    if ( Credential->UserName.Buffer != NULL ) {
        Status = NtLmDuplicateUnicodeString(
                        &Context->UserName,
                        &Credential->UserName
                        );
        if (!NT_SUCCESS(Status)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmDuplicateUnicodeString (UserName) returned %d\n", Status ));
            goto Cleanup;
        }
    }

    Status = SspCredentialGetPassword(
                    Credential,
                    &Context->Password
                    );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleFirstCall: SspCredentialGetPassword returned %d\n", Status ));
        goto Cleanup;
    }


    //
    // save away any marshalled credential info.
    //

    Status = CredpExtractMarshalledTargetInfo(
                    TargetServerName,
                    &Context->TargetInfo
                    );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleFirstCall: CredpExtractMarshalledTargetInfo returned %d\n", Status ));
        goto Cleanup;
    }

    //
    // Compute the negotiate flags
    //


    //
    // Supported key strength(s)
    //

    NegotiateFlagsKeyStrength = NTLMSSP_NEGOTIATE_56;

    if( NtLmSecPkg.MachineState & SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED )
    {
        NegotiateFlagsKeyStrength |= NTLMSSP_NEGOTIATE_128;
    }


    Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                              NTLMSSP_NEGOTIATE_OEM |
                              NTLMSSP_NEGOTIATE_NTLM |
//                              ((NtLmGlobalLmProtocolSupported != 0)
//                               ? NTLMSSP_NEGOTIATE_NTLM2 : 0 ) |
                              NTLMSSP_REQUEST_TARGET |
                              NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                              NegotiateFlagsKeyStrength;

    //
    // NTLM2 session security is now the default request!
    // allows us to support gss-style seal/unseal for LDAP.
    //

    Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM2;


    if ((ContextReqFlags & ISC_REQ_CONFIDENTIALITY) != 0) {
        if (NtLmGlobalEncryptionEnabled) {

            //
            // CONFIDENTIALITY implies INTEGRITY
            //

            ContextReqFlags |= ISC_REQ_INTEGRITY;

            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL |
                                       NTLMSSP_NEGOTIATE_LM_KEY |
                                       NTLMSSP_NEGOTIATE_KEY_EXCH ;

            *ContextAttributes |= ISC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ISC_RET_CONFIDENTIALITY;
        } else {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: NtLmGlobalEncryptionEnabled is FALSE\n"));
            goto Cleanup;
        }
    }

    //
    // If the caller specified INTEGRITY, SEQUENCE_DETECT or REPLAY_DETECT,
    // that means they want to use the MakeSignature/VerifySignature
    // calls.  Add this to the negotiate.
    //

    if (ContextReqFlags &
        (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT))
    {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN |
                                   NTLMSSP_NEGOTIATE_KEY_EXCH |
                                   NTLMSSP_NEGOTIATE_LM_KEY ;
    }


    if ((ContextReqFlags & ISC_REQ_INTEGRITY) != 0)
    {
        *ContextAttributes |= ISC_RET_INTEGRITY;
        Context->ContextFlags |= ISC_RET_INTEGRITY;
    }


    if ((ContextReqFlags & ISC_REQ_SEQUENCE_DETECT) != 0)
    {
        *ContextAttributes |= ISC_RET_SEQUENCE_DETECT;
        Context->ContextFlags |= ISC_RET_SEQUENCE_DETECT;
    }

    if ((ContextReqFlags & ISC_REQ_REPLAY_DETECT) != 0)
    {
        *ContextAttributes |= ISC_RET_REPLAY_DETECT;
        Context->ContextFlags |= ISC_RET_REPLAY_DETECT;
    }

    if ( (ContextReqFlags & ISC_REQ_NULL_SESSION ) != 0) {

        *ContextAttributes |= ISC_RET_NULL_SESSION;
        Context->ContextFlags |= ISC_RET_NULL_SESSION;
    }

    if ( (ContextReqFlags & ISC_REQ_CONNECTION ) != 0) {

        *ContextAttributes |= ISC_RET_CONNECTION;
        Context->ContextFlags |= ISC_RET_CONNECTION;
    }




    //
    // Check if the caller wants identify level
    //

    if ((ContextReqFlags & ISC_REQ_IDENTIFY)!= 0)  {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_IDENTIFY;
        *ContextAttributes |= ISC_RET_IDENTIFY;
        Context->ContextFlags |= ISC_RET_IDENTIFY;
    }

    IF_DEBUG( USE_OEM ) {
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_UNICODE;
    }

    if ( ((ContextReqFlags & ISC_REQ_MUTUAL_AUTH) != 0 ) &&
         (NtLmGlobalMutualAuthLevel < 2 ) ) {

        *ContextAttributes |= ISC_RET_MUTUAL_AUTH ;

        if ( NtLmGlobalMutualAuthLevel == 0 )
        {
            Context->ContextFlags |= ISC_RET_MUTUAL_AUTH ;
        }

    }

    //
    // It is important to remove LM_KEY for compat 2 on the first call to ISC
    // in the datagram case, but not harmful in the connection case
    //
    if (NtLmGlobalLmProtocolSupported == NoLm){
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
    }

    //
    // For connection oriented security, we send a negotiate message to
    // the server.  For datagram, we get back the server's
    // capabilities in the challenge message.
    //

    if ((ContextReqFlags & ISC_REQ_DATAGRAM) == 0) {

        BOOLEAN CheckForLocal;

        if ( (Credential->DomainName.Buffer == NULL &&
              Credential->UserName.Buffer == NULL &&
              Credential->Password.Buffer == NULL )
             )
        {
            CheckForLocal = TRUE;
        } else {
            CheckForLocal = FALSE;
        }


        if( CheckForLocal ) {

            //
            // snap up a copy of the globals so we can just take the critsect once.
            // the old way took the critsect twice, once to read sizes, second time
            // to grab buffers - bad news if the global got bigger in between.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if( NtLmGlobalOemComputerNameString.Buffer == NULL ||
                NtLmGlobalOemPrimaryDomainNameString.Buffer == NULL ) {

                //
                // user has picked a computer name or domain name
                // that failed to convert to OEM.  disable the loopback
                // detection.
                // Sometime beyond Win2k, Negotiate package should have
                // a general, robust scheme for detecting loopback.
                //

                CheckForLocal = FALSE;

            } else {

                Status = NtLmDuplicateString(
                                        &NtLmLocalOemComputerNameString,
                                        &NtLmGlobalOemComputerNameString
                                        );

                if( NT_SUCCESS(Status) ) {
                    Status = NtLmDuplicateString(
                                            &NtLmLocalOemPrimaryDomainNameString,
                                            &NtLmGlobalOemPrimaryDomainNameString
                                            );
                }

            }

            RtlReleaseResource(&NtLmGlobalCritSect);


            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: NtLmDuplicateUnicodeString (GlobalOemComputerName or GlobalOemPrimaryDomainName) returned %d\n", Status ));
                goto Cleanup;
            }
        }


        //
        // Allocate a Negotiate message
        //

        NegotiateMessageSize = sizeof(*NegotiateMessage) +
                               NtLmLocalOemComputerNameString.Length +
                               NtLmLocalOemPrimaryDomainNameString.Length;

        if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( NegotiateMessageSize > *OutputTokenSize ) {
                Status = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: OutputTokenSize is %d\n", *OutputTokenSize));
                goto Cleanup;
            }
        }

        NegotiateMessage = (PNEGOTIATE_MESSAGE)
                           NtLmAllocateLsaHeap( NegotiateMessageSize );

        if ( NegotiateMessage == NULL) {
            Status = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL, "SsprHandleFirstCall: Error allocating NegotiateMessage.\n"));
            goto Cleanup;
        }

        //
        // If this is the first call,
        //  build a Negotiate message.
        //

        strcpy( (char *) NegotiateMessage->Signature, NTLMSSP_SIGNATURE );
        NegotiateMessage->MessageType = NtLmNegotiate;
        NegotiateMessage->NegotiateFlags = Context->NegotiateFlags;

        IF_DEBUG( REQUEST_TARGET ) {
            NegotiateMessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;
        }

        //
        // Copy the DomainName and ComputerName into the negotiate message so
        // the other side can determine if this is a call from the local system.
        //
        // Pass the names in the OEM character set since the character set
        // hasn't been negotiated yet.
        //
        // Skip passing the workstation name if credentials were specified. This
        // ensures the other side doesn't fall into the case that this is the
        // local system.  We wan't to ensure the new credentials are
        // authenticated.
        //

        Where = (PCHAR)(NegotiateMessage+1);

        if ( CheckForLocal ) {

            SspContextCopyString( NegotiateMessage,
                                  &NegotiateMessage->OemWorkstationName,
                                  &NtLmLocalOemComputerNameString,
                                  &Where );

            NegotiateMessage->NegotiateFlags |=
                              NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED;


            //
            // OEM_DOMAIN_SUPPLIED used to always be supplied - but the
            // only case it is ever used is when NTLMSSP_NEGOTIATE_LOCAL_CALL
            // is set.
            //

            SspContextCopyString( NegotiateMessage,
                                  &NegotiateMessage->OemDomainName,
                                  &NtLmLocalOemPrimaryDomainNameString,
                                  &Where );

            NegotiateMessage->NegotiateFlags |=
                                  NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED;

        }

        if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            RtlCopyMemory( *OutputToken,
                       NegotiateMessage,
                       NegotiateMessageSize );

        }
        else
        {
            *OutputToken = NegotiateMessage;
            NegotiateMessage = NULL;
            *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
        }

        *OutputTokenSize = NegotiateMessageSize;

    }

    //
    // Save a reference to the credential in the context.
    //

    Context->Credential = Credential;
    Credential = NULL;

    //
    // Check for a caller requesting datagram security.
    //

    if ((ContextReqFlags & ISC_REQ_DATAGRAM) != 0) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_NT_ONLY;
        Context->ContextFlags |= ISC_RET_DATAGRAM;
        *ContextAttributes |= ISC_RET_DATAGRAM;

        // If datagram security is required, then we don't send back a token

        *OutputTokenSize = 0;



        //
        // Generate a session key for this context if sign or seal was
        // requested.
        //

        if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL)) != 0) {

            Status = SspGenerateRandomBits(
                                Context->SessionKey,
                                MSV1_0_USER_SESSION_KEY_LENGTH
                                );

            if( !NT_SUCCESS( Status ) ) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleFirstCall: SspGenerateRandomBits failed\n"));
                goto Cleanup;
            }
        }
        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );


        //
        // Unless client wants to force its use,
        // Turn off strong crypt, because we can't negotiate it.
        //

        if (!NtLmGlobalDatagramUse128BitEncryption) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_128;
        }

        //
        // likewise for 56bit.  note that package init handles turning
        // off 56bit if 128bit is configured for datagram.
        //

        if(!NtLmGlobalDatagramUse56BitEncryption) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_56;
        }

        //
        //  Unless client wants to require NTLM2, can't use its
        //  message processing features because we start using
        //  MD5 sigs, full duplex mode, and datagram rekey before
        //  we know if the server supports NTLM2.
        //

        if (!NtLmGlobalRequireNtlm2) {
            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_NTLM2;
        }

        //
        // done fiddling with the negotiate flags, output them.
        //

        *NegotiateFlags = Context->NegotiateFlags;

        //
        // send back the negotiate flags to control signing and sealing
        //

        *NegotiateFlags |= NTLMSSP_APP_SEQ;

    }

    if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH )
    {
        Status = SspGenerateRandomBits(
                            Context->SessionKey,
                            MSV1_0_USER_SESSION_KEY_LENGTH
                            );

        if( !NT_SUCCESS( Status ) ) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleFirstCall: SspGenerateRandomBits failed\n"));
            goto Cleanup;
        }

        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );
    }

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    Status = SEC_I_CONTINUE_NEEDED;
    Context->State = NegotiateSentState;


    SspPrint(( SSP_NEGOTIATE_FLAGS,
        "SsprHandleFirstCall: NegotiateFlags = %lx\n", Context->NegotiateFlags));


    //
    // Check that caller asked for minimum security required.
    //

    if (!SsprCheckMinimumSecurity(
                        Context->NegotiateFlags,
                        NtLmGlobalMinimumClientSecurity)) {

        Status = SEC_E_UNSUPPORTED_FUNCTION;

        SspPrint(( SSP_CRITICAL,
                  "SsprHandleFirstCall: "
                  "Caller didn't request minimum security requirements (caller=0x%lx wanted=0x%lx).\n",
                    Context->NegotiateFlags, NtLmGlobalMinimumClientSecurity ));
        goto Cleanup;
    }


    //
    // Free and locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {

        //
        // If we failed,
        //  deallocate the context we allocated above.
        //
        // Delinking is a side effect of referencing, so do that.
        //

        if ( !NT_SUCCESS(Status) ) {

            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext( *ContextHandle, TRUE, &LocalContext );

            ASSERT( LocalContext != NULL );
            if ( LocalContext != NULL ) {
                SspContextDereferenceContext( LocalContext );
            }
        }

        // Always dereference it.

        SspContextDereferenceContext( Context );
    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( NegotiateMessage );
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    if ( NtLmLocalOemComputerNameString.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemComputerNameString.Buffer );
    }

    if ( NtLmLocalOemPrimaryDomainNameString.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemPrimaryDomainNameString.Buffer );
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleFirstCall: 0x%lx\n", Status ));
    return Status;

    UNREFERENCED_PARAMETER( InputToken );
    UNREFERENCED_PARAMETER( InputTokenSize );

}




NTSTATUS
SsprHandleChallengeMessage(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN PUNICODE_STRING TargetServerName,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    IN OUT PULONG SecondOutputTokenSize,
    OUT PVOID *SecondOutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    )

/*++

Routine Description:

    Handle the Challenge message part of InitializeSecurityContext.

Arguments:

    DomainName,UserName,Password - Passed in credentials to be used for this
        context.

    DomainNameSize,userNameSize,PasswordSize - length in characters of the
        credentials to be used for this context.

    SessionKey - Session key to use for this context

    NegotiateFlags - Flags negotiated for this context

    TargetServerName - Target server name, used by CredMgr to associates NT4 servers with domains

    All other arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    PNTLM_CHALLENGE_MESSAGE NtLmChallengeMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    PNTLM_INITIALIZE_RESPONSE NtLmInitializeResponse = NULL;
    PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponseMessage = NULL;
    STRING UserName = {0};
    STRING DomainName = {0};
    STRING Workstation = {0};
    STRING LmChallengeResponse = {0};
    STRING NtChallengeResponse = {0};
    STRING DatagramSessionKey = {0};
    BOOLEAN DoUnicode = TRUE;

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS ProtocolStatus;

    MSV1_0_GETCHALLENRESP_REQUEST TempChallengeResponse;
    PMSV1_0_GETCHALLENRESP_REQUEST GetChallengeResponse;
    ULONG GetChallengeResponseSize;

    UNICODE_STRING RevealedPassword = {0};

    ULONG ChallengeResponseSize;
    ULONG AuthenticateMessageSize;
    PCHAR Where;
    UCHAR LocalSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR DatagramKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    PLUID ClientLogonId = NULL;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    BOOLEAN UseSuppliedCreds = FALSE;
    PSSP_CREDENTIAL Credential = NULL;
    BOOLEAN fCallFromRedir = FALSE;
    BOOLEAN fShareLevel = FALSE;    // is target down-level share based security (no username) ?
    BOOLEAN fCredmanCredentials = FALSE;    // used credman creds?

    UNICODE_STRING TargetName = {0};
    UNICODE_STRING DefectiveTargetName = {0}; // for broken servers.
    LPWSTR szCredTargetDomain = NULL;
    LPWSTR szCredTargetServer = NULL;
    LPWSTR szCredTargetDnsDomain = NULL;
    LPWSTR szCredTargetDnsServer = NULL;
    LPWSTR szCredTargetDnsTree = NULL;
    LPWSTR szCredTargetPreDFSServer = NULL;
    LUID LogonIdNetworkService = NETWORKSERVICE_LUID;

    PSSP_CONTEXT ServerContext = NULL;  // server context referenced during loopback
    HANDLE ClientTokenHandle = NULL;    // access token associated with client
                                        // which called AcquireCredentialsHandle (OUTBOUND)


    SspPrint((SSP_API_MORE, "Entering SsprHandleChallengeMessage\n"));


    //
    // Initialization
    //

    *ContextAttributes = 0;
    *NegotiateFlags = 0;

    GetChallengeResponse = &TempChallengeResponse;

    if (*ContextHandle == NULL)
    {
        // This is possibly an old style redir call (for 4.0 and before)
        // so, alloc the context and replace the creds if new ones exists

        fCallFromRedir = TRUE;

        SspPrint((SSP_API_MORE, "SsprHandleChallengeMessage: *ContextHandle is NULL (old-style RDR)\n"));

        if ((ContextReqFlags & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
        {
            UseSuppliedCreds = TRUE;
        }

        // This is a  superflous check since we alloc only if the caller
        // has asked us too. This is to make sure that the redir always asks us to alloc

        if (!(ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY))
        {
            SecStatus = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        SecStatus = SspCredentialReferenceCredential(
                                          CredentialHandle,
                                          FALSE,
                                          &Credential );

        if ( !NT_SUCCESS( SecStatus ) )
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: SspCredentialReferenceCredential returns %x.\n", SecStatus ));
            goto Cleanup;
        }

        //
        // Allocate a new context
        //

        Context = SspContextAllocateContext();

        if (Context == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: SspContextAllocateContext returns NULL.\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // We've just added a context, we don't nornally add and then
        // reference it.

        SspContextDereferenceContext( Context );

        *ContextHandle = (LSA_SEC_HANDLE) Context;

        //
        // Capture the default credentials from the credential structure.
        //

        if ( Credential->DomainName.Buffer != NULL ) {
            Status = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &Credential->DomainName
                        );
            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString (DomainName) returned %d\n",Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
        }
        if ( Credential->UserName.Buffer != NULL ) {
            Status = NtLmDuplicateUnicodeString(
                        &Context->UserName,
                        &Credential->UserName
                        );
            if (!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString (UserName) returned %d\n", Status ));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
        }

        SecStatus = SspCredentialGetPassword(
                    Credential,
                    &Context->Password
                    );

        if (!NT_SUCCESS(SecStatus)) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: SspCredentialGetPassword returned %d\n", SecStatus ));
            goto Cleanup;
        }

        // Assign the Credential

        Context->Credential = Credential;
        Credential = NULL;

        //
        // fake it
        //

        Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                  NTLMSSP_NEGOTIATE_OEM |
                                  NTLMSSP_REQUEST_TARGET |
                                  NTLMSSP_REQUEST_INIT_RESPONSE |
                                  ((NtLmGlobalLmProtocolSupported != 0)
                                  ? NTLMSSP_NEGOTIATE_NTLM2 : 0 ) |
                                  NTLMSSP_TARGET_TYPE_SERVER ;


        *ExpirationTime = SspContextGetTimeStamp(Context, TRUE);

        Context->State = NegotiateSentState;

        // If creds are passed in by the RDR, then replace the ones in the context
        if (UseSuppliedCreds)
        {
            if (SecondInputTokenSize < sizeof(NTLM_CHALLENGE_MESSAGE))
            {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Invalid SecondInputTokensize.\n" ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            NtLmChallengeMessage = (PNTLM_CHALLENGE_MESSAGE) NtLmAllocatePrivateHeap(SecondInputTokenSize);
            if (NtLmChallengeMessage == NULL)
            {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Error while allocating NtLmChallengeMessage\n" ));
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(NtLmChallengeMessage,
                          SecondInputToken,
                          SecondInputTokenSize);

            //
            // NULL session is only true if user, domain, and password are all
            // empty strings in stead of NULLs
            //

            if (((NtLmChallengeMessage->Password.Length == 0) && (NtLmChallengeMessage->Password.Buffer != NULL)) &&
                ((NtLmChallengeMessage->UserName.Length == 0) && (NtLmChallengeMessage->UserName.Buffer != NULL)) &&
                ((NtLmChallengeMessage->DomainName.Length == 0) && (NtLmChallengeMessage->DomainName.Buffer != NULL)))
            {
                // This could only be a null session request

                SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session NtLmChallengeMessage\n" ));

                if (Context->Password.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->Password.Buffer);
                }

                Context->Password.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->Password.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(Password) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->Password.Length = 0;
                Context->Password.MaximumLength = 0;
                *(Context->Password.Buffer) = L'\0';
                SspHidePassword(&Context->Password);

                if (Context->UserName.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->UserName.Buffer);
                }

                Context->UserName.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->UserName.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(UserName) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->UserName.Length = 0;
                Context->UserName.MaximumLength = sizeof(WCHAR);
                *(Context->UserName.Buffer) = L'\0';

                if (Context->DomainName.Buffer != NULL)
                {
                    // free it first
                    NtLmFreePrivateHeap (Context->DomainName.Buffer);
                }

                Context->DomainName.Buffer =  (LPWSTR) NtLmAllocatePrivateHeap(sizeof(WCHAR));
                if (Context->DomainName.Buffer == NULL)
                {
                    SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmAllocatePrivateHeap(DomainName) returns NULL.\n"));
                    SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
                Context->DomainName.Length = 0;
                Context->DomainName.MaximumLength = sizeof(WCHAR);
                *(Context->DomainName.Buffer) = L'\0';
            }
            else
            {
                ULONG_PTR BufferTail = (ULONG_PTR)NtLmChallengeMessage + SecondInputTokenSize;
                UNICODE_STRING AbsoluteString;


                if (NtLmChallengeMessage->Password.Buffer != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->Password.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->Password.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (Password).\n" ));
                        goto Cleanup;

                    }

                    if (Context->Password.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->Password.Buffer);
                        Context->Password.Buffer = NULL;
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->Password.Length;

                    SecStatus = NtLmDuplicatePassword(
                                                &Context->Password,
                                                &AbsoluteString
                                                );

                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicatePassword returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }

                    SspHidePassword(&Context->Password);
                }

                if (NtLmChallengeMessage->UserName.Length != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->UserName.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->UserName.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (UserName).\n" ));
                        goto Cleanup;

                    }

                    if (Context->UserName.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->UserName.Buffer);
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->UserName.Length;
                    SecStatus = NtLmDuplicateUnicodeString(&Context->UserName,
                                                       &AbsoluteString);
                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString(UserName) returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }
                }

                if (NtLmChallengeMessage->DomainName.Length != 0)
                {
                    AbsoluteString.Buffer = (LPWSTR)((PUCHAR)NtLmChallengeMessage + NtLmChallengeMessage->DomainName.Buffer);

                    //
                    // verify buffer not out of range.
                    //

                    if( ( (ULONG_PTR)AbsoluteString.Buffer > BufferTail ) ||
                        ( (ULONG_PTR)((PUCHAR)AbsoluteString.Buffer + NtLmChallengeMessage->DomainName.Length) > BufferTail ) ||
                        ( (ULONG_PTR)AbsoluteString.Buffer < (ULONG_PTR)NtLmChallengeMessage )
                        )
                    {
                        SecStatus = SEC_E_NO_CREDENTIALS;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Buffer overflow (DomainName).\n" ));
                        goto Cleanup;

                    }

                    if (Context->DomainName.Buffer != NULL)
                    {
                        // free it first
                        NtLmFreePrivateHeap (Context->DomainName.Buffer);
                    }

                    AbsoluteString.Length = AbsoluteString.MaximumLength = NtLmChallengeMessage->DomainName.Length;
                    SecStatus = NtLmDuplicateUnicodeString(&Context->DomainName,
                                                       &AbsoluteString);
                    if (!NT_SUCCESS(SecStatus))
                    {
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmDuplicateUnicodeString(DomainName) returns 0x%lx.\n",SecStatus ));
                        goto Cleanup;
                    }
                }
            }


            if (NtLmChallengeMessage)
            {
                NtLmFreePrivateHeap (NtLmChallengeMessage);
                NtLmChallengeMessage = NULL;
            }

        } // end of special casing if credentials are supplied in the first init call

    } // end of special casing for the old style redir


    //
    // Find the currently existing context.
    //

    SecStatus = SspContextReferenceContext( *ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(SecStatus) )
    {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid context handle.\n" ));
        goto Cleanup;

    }

    //
    // bug 321061: passing Accept handle to Init causes AV.
    //

    if( Context->Credential == NULL ) {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid context handle, missing credential.\n" ));

        SecStatus = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // If this is not reauthentication (or is datagram reauthentication)
    // pull the context out of the associated credential.
    //

    if ((Context->State != AuthenticateSentState) ||
       (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0)
    {
        ClientLogonId = &Context->Credential->LogonId;
        ImpersonationLevel = Context->Credential->ImpersonationLevel;
    }

    //
    // process the TargetServerName to see if marshalled target info was
    // passed in.  This can happen if the caller passes in marshalled target
    // info for each call to InitializeSecurityContext(), or, uses the downlevel
    // RDR path which happened previously in this routine.
    //

    Status = CredpExtractMarshalledTargetInfo(
                    TargetServerName,
                    &Context->TargetInfo
                    );

    if (!NT_SUCCESS(Status)) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleChallengeMessage: CredpExtractMarshalledTargetInfo returned %d\n", Status ));
        goto Cleanup;
    }

    //
    // If we have already sent the authenticate message, then this must be
    // RPC calling Initialize a third time to re-authenticate a connection.
    // This happens when a new interface is called over an existing
    // connection.  What we do here is build a NULL authenticate message
    // that the server will recognize and also ignore.
    //

    //
    // That being said, if we are doing datagram style authentication then
    // the story is different.  The server may have dropped this security
    // context and then the client sent another packet over.  The server
    // will then be trying to restore the context, so we need to build
    // another authenticate message.
    //

    if ( Context->State == AuthenticateSentState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        if (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) ==
                NTLMSSP_NEGOTIATE_DATAGRAM) &&
            (InputTokenSize != 0) &&
            (InputToken != NULL) ) {

            //
            // we are doing a reauthentication for datagram, so let this
            // through.  We don't want the security.dll remapping this
            // context.
            //

            *ContextAttributes |= SSP_RET_REAUTHENTICATION;

        } else {

            //
            // To make sure this is the intended meaning of the call, check
            // that the input token is NULL.
            //

            if ( (InputTokenSize != 0) || (InputToken != NULL) ) {

                SecStatus = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: (re-auth) invalid InputTokenSize.\n" ));
                goto Cleanup;
            }

            if ( (*OutputTokenSize < sizeof(NullMessage))  &&
                 ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0))
            {
                SecStatus = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: invalid OutputTokenSize.\n" ));
            }
            else {
                RtlZeroMemory( &NullMessage, sizeof(NullMessage) );

                strcpy( (char *)NullMessage.Signature, NTLMSSP_SIGNATURE );
                NullMessage.MessageType = NtLmAuthenticate;
                if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    RtlCopyMemory( *OutputToken,
                               &NullMessage,
                               sizeof(NullMessage));
                }
                else
                {
                    PAUTHENTICATE_MESSAGE NewNullMessage = (PAUTHENTICATE_MESSAGE)
                                            NtLmAllocateLsaHeap(sizeof(NullMessage));
                    if ( NewNullMessage == NULL)
                    {
                        SecStatus = STATUS_NO_MEMORY;
                        SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: Error allocating NewNullMessage.\n" ));
                        goto Cleanup;
                    }

                    *OutputToken = NewNullMessage;
                    NewNullMessage = NULL;
                    *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                }
                *OutputTokenSize = sizeof(NullMessage);
            }

            *ContextAttributes |= SSP_RET_REAUTHENTICATION;
            goto Cleanup;

        }

    } else if ( Context->State != NegotiateSentState ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "Context not in NegotiateSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // We don't support any options.
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & ISC_REQ_PROMPT_FOR_CREDS) != 0 ){

        SspPrint(( SSP_CRITICAL,
                 "SsprHandleChallengeMessage: invalid ContextReqFlags 0x%lx.\n",
                 ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    // the credential is implied by the Context.
    // We could double check that the Credential Handle is either NULL or
    // correct.  However, our implementation doesn't maintain a close
    // association between the two (actually no association) so checking
    // would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    //
    // Get the ChallengeMessage.
    //

    if ( InputTokenSize < sizeof(OLD_CHALLENGE_MESSAGE) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    SecStatus = SspContextGetMessage( InputToken,
                                      InputTokenSize,
                                      NtLmChallenge,
                                      (PVOID *)&ChallengeMessage );

    if ( !NT_SUCCESS(SecStatus) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage GetMessage returns 0x%lx\n",
                  SecStatus ));
        goto Cleanup;
    }

    //
    // for down-level RDR, EXPORTED_CONTEXT is a hint that we are talking to
    // share level target.
    //

    if( fCallFromRedir )
    {
        if( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT )
        {
            ChallengeMessage->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT);
            fShareLevel = TRUE;

            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "downlevel sharelevel security target\n"));
        }
    }


    if( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM ) {

        //
        // take out any flags we didn't ask for -- self defense from bogus combinations
        //

        ChallengeMessage->NegotiateFlags &=
            ( Context->NegotiateFlags |
                NTLMSSP_NEGOTIATE_TARGET_INFO |
                NTLMSSP_TARGET_TYPE_SERVER |
                NTLMSSP_TARGET_TYPE_DOMAIN |
                NTLMSSP_NEGOTIATE_LOCAL_CALL );
    }


    //
    // Determine if the caller wants OEM or UNICODE
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_OEM;
        DoUnicode = TRUE;
    } else if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM ){
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_UNICODE;
        DoUnicode = FALSE;
    } else {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Copy other interesting negotiate flags into the context
    //


    if( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;
    } else {
        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_TARGET_INFO);
    }


    //
    // if got NTLM2, or if LM_KEY specifically forbidden don't use LM_KEY
    //

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) ||
        (NtLmGlobalLmProtocolSupported == NoLm)) {

        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server support NTLM2 caused LM_KEY to be disabled.\n" ));
        }

        ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_LM_KEY);
    }

    //
    // if we did not get NTLM2 remove it from context negotiate flags
    //

    if(!(ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)){
        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support NTLM2 and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM2);
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) {
        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support NTLM and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM);
    }


    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) == 0) {
        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support KEY_EXCH and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_KEY_EXCH);
    }


    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) == 0) {
        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleChallengeMessage: "
                      "Server didn't support LM_KEY and client did.\n" ));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_LM_KEY);
    }


    //
    // make sure KEY_EXCH is always set if DATAGRAM negotiated and we need a key
    //  this is for local internal use; its now safe because we've got the bits
    //  to go on the wire copied...
    //

    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) &&
        (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |NTLMSSP_NEGOTIATE_SEAL)))
    {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;
    }


    //
    // allow negotiate of certain options such as sign/seal when server
    // asked for it, but client didn't.
    //

#if 0
////
    if( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL ) {
        if( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) == 0 ) {
            SspPrint(( SSP_SESSION_KEYS,
                  "SsprHandleChallengeMessage: client didn't request SEAL but server did, adding SEAL.\n"));
        }

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
    }


    if( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN ) {
        if( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) == 0 ) {
            SspPrint(( SSP_SESSION_KEYS,
                  "SsprHandleChallengeMessage: client didn't request SIGN but server did, adding SIGN.\n"));
        }

        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }
////
#endif


    //
    // if server didn't support certain crypto strengths, insure they
    // are disabled.
    //

    if( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56) == 0 ) {
        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                  "SsprHandleChallengeMessage: Client supported 56, but server didn't.\n"));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_56);
    }


    if( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) == 0 ) {

        if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            SspPrint(( SSP_NEGOTIATE_FLAGS,
                  "SsprHandleChallengeMessage: Client supported 128, but server didn't.\n"));
        }

        Context->NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_128);
    }



    //
    // Check that server gave minimum security required.
    // not done for legacy down-level case, as, NegotiateFlags are
    // constructed from incomplete information.
    //

    if( !fCallFromRedir )
    {
        if (!SsprCheckMinimumSecurity(
                    Context->NegotiateFlags,
                    NtLmGlobalMinimumClientSecurity)) {

            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage didn't support minimum security requirements.\n" ));
            goto Cleanup;
        }
    }





    if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    } else {
        Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    }

    //
    // Determine that the caller negotiated to NTLM or nothing, but not
    // NetWare.
    //

    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE) &&
        ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) &&
        ((ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0)
        ) {
        SecStatus = STATUS_NOT_SUPPORTED;
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage asked for Netware only.\n" ));
        goto Cleanup;
    }

    //
    // Check if we negotiated for identify level
    //

    if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {

            Context->ContextFlags |= ISC_REQ_IDENTIFY;
            *ContextAttributes |= ISC_RET_IDENTIFY;
        } else {
            SecStatus = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
            goto Cleanup;
        }

    }


    //
    // If the server is running on this same machine,
    //  just duplicate our caller's token and use it.
    //

    while ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL )
    {
        ULONG_PTR ServerContextHandle;
        static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                };


        SspPrint(( SSP_MISC,
                  "SsprHandleChallengeMessage: Local Call.\n"));

        //
        // Require the new challenge message if we are going to access the
        // server context handle
        //

        if ( InputTokenSize < sizeof(CHALLENGE_MESSAGE) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleChallengeMessage: invalid InputTokenSize.\n"));
            goto Cleanup;
        }

        //
        // Open the server's context here within this process.
        //

        ServerContextHandle = (ULONG_PTR)(ChallengeMessage->ServerContextHandle);

        SspContextReferenceContext(
                            ServerContextHandle,
                            FALSE,
                            &ServerContext
                            );

        if ( ServerContext == NULL )
        {
            //
            // This means the server has lied about this being a local call or
            //  the server process has exitted.
            // this can happen if the client and server have not had netbios
            // machine names set, so, allow this and continue processing
            // as if this were not loopback.
            //

            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage bad ServerContextHandle 0x%p\n",
                      ChallengeMessage->ServerContextHandle));

            ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LOCAL_CALL;
            break;
        }

        if(((ServerContext->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0) ||
            (ServerContext->State != ChallengeSentState)
            )
        {
            SspPrint(( SSP_WARNING,
                      "SsprHandleChallengeMessage: "
                      "ChallengeMessage claimed ServerContextHandle in bad state 0x%p\n",
                      ChallengeMessage->ServerContextHandle));

            ChallengeMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LOCAL_CALL;
            break;
        }


        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_LOCAL_CALL;

        //
        // Local loopback for network servcice
        //

        if ( (Context->Credential->MutableCredFlags & SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE) )
        {
            SspPrint((SSP_WARNING, "SsprHandleChallengeMessage using networkservice in local loopback\n"));

            ClientLogonId = &LogonIdNetworkService;
        }

        //
        // open the token associated with the caller at the time of the
        // AcquireCredentialsHandle() call.
        //

        SecStatus = LsaFunctions->OpenTokenByLogonId(
                                    ClientLogonId,
                                    &ClientTokenHandle
                                    );

        if(!NT_SUCCESS(SecStatus))
        {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not open client token 0x%lx\n",
                      SecStatus ));
            goto Cleanup;
        }


        if( ImpersonationLevel < SecurityImpersonation )
        {
            SspPrint(( SSP_WARNING, "Reducing impersonation level %lu to %lu\n",
                        SecurityImpersonation, ImpersonationLevel));
        }

        if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) != 0) {
            ImpersonationLevel = min(SecurityIdentification, ImpersonationLevel);
        }


        SecStatus = SspDuplicateToken(
                        ClientTokenHandle,
                        ImpersonationLevel,
                        &ServerContext->TokenHandle
                        );

        if (!NT_SUCCESS(SecStatus)) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not duplicate client token 0x%lx\n",
                      SecStatus ));
            goto Cleanup;
        }

        //
        // enable all privileges in the duplicated token, to be consistent
        // with what a network logon normally looks like
        // (all privileges held are enabled by default).
        //

        if(!SspEnableAllPrivilegesToken(ServerContext->TokenHandle))
        {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleChallengeMessage: "
                      "Could not enable all privileges for loopback.\n"));
        }

        //
        // give local call a hard-coded session key so calls into RDR
        // to fetch a session key succeed (eg: RtlGetUserSessionKeyClient)
        //

        RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);


        //
        // Don't pass any credentials in the authenticate message.
        //

        RtlInitString( &DomainName, NULL );
        RtlInitString( &UserName, NULL );
        RtlInitString( &Workstation, NULL );
        RtlInitString( &NtChallengeResponse, NULL );
        RtlInitString( &LmChallengeResponse, NULL );
        RtlInitString( &DatagramSessionKey, NULL );

        break;
    }

    //
    // If the server is running on a diffent machine,
    //  determine the caller's DomainName, UserName and ChallengeResponse
    //  to pass back in the AuthenicateMessage.
    //

    if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0 )
    {
        //
        // Build the GetChallengeResponse message to pass to the LSA.
        //

        PCHAR MarshalPtr;     // marshalling pointer
        ULONG MarshalBytes;
        UNICODE_STRING TargetInfo;

        CREDENTIAL_TARGET_INFORMATIONW CredTargetInfo;

        //
        // insure all fields NULL.
        //

        ZeroMemory( &CredTargetInfo, sizeof(CredTargetInfo) );

        ZeroMemory( GetChallengeResponse, sizeof(*GetChallengeResponse) );
        GetChallengeResponseSize = sizeof(*GetChallengeResponse);
        GetChallengeResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
        GetChallengeResponse->ParameterControl = 0;


        if( Context->Credential )
        {
            PUNICODE_STRING TmpDomainName = &(Context->Credential->DomainName);
            PUNICODE_STRING TmpUserName = &(Context->Credential->UserName);
            PUNICODE_STRING TmpPassword = &(Context->Credential->Password);

            if( (TmpDomainName->Buffer != NULL) ||
                (TmpUserName->Buffer != NULL) ||
                (TmpPassword->Buffer != NULL)
                )
            {
                UseSuppliedCreds = TRUE;
            }
        }

        //
        // if caller specifically asked for non nt session key, give it to them
        //

        if ( (ChallengeMessage->NegotiateFlags & NTLMSSP_REQUEST_NON_NT_SESSION_KEY ) ||
             (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY))
        {
            GetChallengeResponse->ParameterControl |= RETURN_NON_NT_USER_SESSION_KEY;
        }

        GetChallengeResponse->ParameterControl |= GCR_NTLM3_PARMS;

        //
        // if TargetInfo present, use it, otherwise construct it from target name
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)
        {
            if ( InputTokenSize < sizeof(CHALLENGE_MESSAGE) ) {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage size wrong when target info flag on %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // validate and relocate the target info
            //

            if (!SspConvertRelativeToAbsolute (
                                ChallengeMessage,
                                InputTokenSize,
                                &ChallengeMessage->TargetInfo,
                                (PSTRING)&TargetInfo,
                                DoUnicode,
                                TRUE    // NULL target info OK
                                ))
            {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetInfo size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Calculate mashal data size for the target info case
            //
            if( UseSuppliedCreds )
            {
                MarshalBytes =
                    TargetInfo.Length +
                    Context->DomainName.Length +
                    Context->UserName.Length +
                    Context->Password.Length +
                    (4*sizeof(WCHAR));
            } else {
                MarshalBytes =
                    TargetInfo.Length +
                    (DNLEN * sizeof(WCHAR)) +
                    (UNLEN * sizeof(WCHAR)) +
                    (PWLEN * sizeof(WCHAR)) +
                    (4*sizeof(WCHAR));
            }

            //
            // Sets a "reasonable" upper limit on the token size
            // to avoid unbounded stack allocations.  The limit is
            // NTLMSSP_MAX_MESSAGE_SIZE*4 for historical reasons.
            //

            if((NTLMSSP_MAX_MESSAGE_SIZE*4)<MarshalBytes){
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetInfo size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Allocate buffer for GetChallengeResponse + marshalled data
            //
            SafeAllocaAllocate(GetChallengeResponse, MarshalBytes +
                    sizeof(*GetChallengeResponse));

            if(!GetChallengeResponse){
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // Copy in the MSV1_0_GETCHALLENRESP_REQUEST structure so far
            //
            *GetChallengeResponse = TempChallengeResponse;

            MarshalPtr = (PCHAR)(GetChallengeResponse+1);


            // TargetInfo now contains the server's netbios domain name

            //
            // MSV needs the server name to be 'in' the passed in buffer.
            //

            SspContextCopyStringAbsolute(
                                GetChallengeResponse,
                                (PSTRING)&GetChallengeResponse->ServerName,
                                (PSTRING)&TargetInfo,
                                &MarshalPtr
                                );

            GetChallengeResponseSize += GetChallengeResponse->ServerName.Length;

            //
            // tell GCR that its an AV list.
            //

            GetChallengeResponse->ParameterControl |= GCR_TARGET_INFO;

            // get various target names
            if( !UseSuppliedCreds )
            {

                ULONG AvFlags = 0;

                //
                // Uplevel -- get the info from the comprehensive TARGET_INFO
                //
                //

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvNbDomainName,
                            &szCredTargetDomain
                            );
                if(!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvNbComputerName,
                            &szCredTargetServer
                            );
                if(!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsDomainName,
                            &szCredTargetDnsDomain
                            );
                if(!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsComputerName,
                            &szCredTargetDnsServer
                            );
                if(!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                Status = MsvpAvlToString(
                            &TargetInfo,
                            MsvAvDnsTreeName,
                            &szCredTargetDnsTree
                            );
                if(!NT_SUCCESS(Status))
                {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                if ( TargetServerName && TargetServerName->Length )
                {
                    //
                    // check TargetServerName against szTargetServer.  If they don't match, we have a DFS share.
                    // Add Pre-DFS ServerName
                    //


                    LPWSTR szTargetServerName = TargetServerName->Buffer;
                    DWORD cchTarget = TargetServerName->Length / sizeof(WCHAR);

                    DWORD IndexSlash;

                    for (IndexSlash = 0 ; IndexSlash < cchTarget; IndexSlash++)
                    {
                        if(TargetServerName->Buffer[IndexSlash] == L'/')
                        {
                            cchTarget -= IndexSlash;
                            szTargetServerName = &TargetServerName->Buffer[ IndexSlash+1 ];
                            break;
                        }
                    }

                    szCredTargetPreDFSServer = (LPWSTR)NtLmAllocatePrivateHeap( (cchTarget+1) * sizeof(WCHAR) );
                    if( szCredTargetPreDFSServer == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    CopyMemory( szCredTargetPreDFSServer, szTargetServerName, cchTarget*sizeof(WCHAR) );
                    szCredTargetPreDFSServer[ cchTarget ] = L'\0';

                    CredTargetInfo.TargetName = szCredTargetPreDFSServer;
                }


                //
                // see if server enabled the funky guest bit (tm)
                //

                Status = MsvpAvlToFlag(
                            &TargetInfo,
                            MsvAvFlags,
                            &AvFlags
                            );
                if( Status == STATUS_SUCCESS )
                {
                    if( AvFlags & MSV1_0_AV_FLAG_FORCE_GUEST )
                    {
                        CredTargetInfo.Flags |= CRED_TI_ONLY_PASSWORD_REQUIRED;
                    }
                }
            }

        } else {

            BOOLEAN DefectiveTarget = FALSE;

            // downlevel - first call may have been handled by redir


            //
            // validate and relocate the target name
            //

            if (!SspConvertRelativeToAbsolute (
                                ChallengeMessage,
                                InputTokenSize,
                                &ChallengeMessage->TargetName,
                                (PSTRING)&TargetName,
                                DoUnicode,
                                TRUE    // NULL targetname OK
                                ))
            {
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage.TargetName size wrong %ld\n",
                          InputTokenSize ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // certain flavors of Unix servers set UNICODE and OEM flags,
            // but supply an OEM buffer.  Try to resolve that here.
            //

            if ( (DoUnicode) &&
                 (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM)
                 )
            {
                if( IsTextUnicode( TargetName.Buffer, TargetName.Length, NULL ) == 0 )
                {
                    DefectiveTarget = TRUE;
                }
            }

            //
            // convert TargetName to Unicode if needed
            //

            if ( !DoUnicode || DefectiveTarget )
            {
                UNICODE_STRING TempString;

                Status = RtlOemStringToUnicodeString(
                            &TempString,
                            (PSTRING)&TargetName,
                            TRUE);

                if ( !NT_SUCCESS(Status) ) {
                    SecStatus = SspNtStatusToSecStatus( Status,
                                                        SEC_E_INSUFFICIENT_MEMORY );
                    goto Cleanup;
                }

                TargetName = TempString;

                if( DefectiveTarget )
                {
                    //
                    // save it so we can free it later.
                    //

                    DefectiveTargetName = TargetName;
                }
            }


            if ( !UseSuppliedCreds )
            {

                // ChallengeMessage->TargetName will be the server's netbios domain name
                if ( TargetName.Buffer && TargetName.Length )
                {
                    LPWSTR szTmpTargetName;

                    szTmpTargetName = (PWSTR)NtLmAllocatePrivateHeap( TargetName.Length + sizeof(WCHAR) );
                    if( szTmpTargetName == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( szTmpTargetName, TargetName.Buffer, TargetName.Length );
                    szTmpTargetName[ TargetName.Length/sizeof(WCHAR) ] = L'\0';

                    if( ChallengeMessage->NegotiateFlags & NTLMSSP_TARGET_TYPE_SERVER )
                    {
                        szCredTargetServer = szTmpTargetName;
                    } else if( ChallengeMessage->NegotiateFlags & NTLMSSP_TARGET_TYPE_DOMAIN )
                    {
                        szCredTargetDomain = szTmpTargetName;
                    }
                    // TODO: what if TARGET_TYPE not specified, or TARGET_TYPE_SHARE ?

                }

                if ( TargetServerName && TargetServerName->Length )
                {
                    //
                    // check TargetServerName against szTargetServer.  If they don't match, we have a DFS share.
                    // Add Pre-DFS ServerName
                    //


                    LPWSTR szTargetServerName = TargetServerName->Buffer;
                    DWORD cchTarget = TargetServerName->Length / sizeof(WCHAR);

                    DWORD IndexSlash;

                    for (IndexSlash = 0 ; IndexSlash < cchTarget; IndexSlash++)
                    {
                        if(TargetServerName->Buffer[IndexSlash] == L'/')
                        {
                            cchTarget -= IndexSlash;
                            szTargetServerName = &TargetServerName->Buffer[ IndexSlash+1 ];
                            break;
                        }
                    }

                    szCredTargetPreDFSServer = (LPWSTR)NtLmAllocatePrivateHeap( (cchTarget+1) * sizeof(WCHAR) );
                    if( szCredTargetPreDFSServer == NULL )
                    {
                        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                        goto Cleanup;
                    }

                    CopyMemory( szCredTargetPreDFSServer, szTargetServerName, cchTarget*sizeof(WCHAR) );
                    szCredTargetPreDFSServer[ cchTarget ] = L'\0';

                    CredTargetInfo.TargetName = szCredTargetPreDFSServer;
                }

                if( fShareLevel )
                {
                    CredTargetInfo.Flags |= CRED_TI_ONLY_PASSWORD_REQUIRED;
                }
            }

            //
            // Calculate mashal data size for the target name case
            //

            if( UseSuppliedCreds )
            {
                MarshalBytes =
                    TargetName.Length +
                    Context->DomainName.Length +
                    Context->UserName.Length +
                    Context->Password.Length +
                    (4*sizeof(WCHAR));
            } else {
                MarshalBytes =
                    TargetName.Length +
                    (DNLEN * sizeof(WCHAR)) +
                    (UNLEN * sizeof(WCHAR)) +
                    (PWLEN * sizeof(WCHAR)) +
                    (4*sizeof(WCHAR));
            }

            //
            // Set a "reasonable" upper limit on the token size
            // to avoid unbounded stack allocations.  The limit is
            // NTLMSSP_MAX_MESSAGE_SIZE*4 for historical reasons.
            //

            if((NTLMSSP_MAX_MESSAGE_SIZE*4)<MarshalBytes){
                SspPrint(( SSP_CRITICAL,
                          "SspHandleChallengeMessage: "
                          "ChallengeMessage size wrong \n"));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Allocate buffer for GetChallengeResponse + marshalled data
            //
            SafeAllocaAllocate(GetChallengeResponse, MarshalBytes +
                    sizeof(*GetChallengeResponse));

            if(!GetChallengeResponse){
                SecStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // Copy in the MSV1_0_GETCHALLENRESP_REQUEST structure so far
            //
            *GetChallengeResponse = TempChallengeResponse;

            MarshalPtr = (PCHAR)(GetChallengeResponse+1);

            //
            // MSV needs the server name to be 'in' the passed in buffer.
            //

            SspContextCopyStringAbsolute(
                                GetChallengeResponse,
                                (PSTRING)&GetChallengeResponse->ServerName,
                                (PSTRING)&TargetName,
                                &MarshalPtr
                                );

            GetChallengeResponseSize += GetChallengeResponse->ServerName.Length;

        }


        if ( !UseSuppliedCreds )
        {
            ULONG CredTypes = CRED_TYPE_DOMAIN_PASSWORD;

            CredTargetInfo.NetbiosDomainName = szCredTargetDomain;
            CredTargetInfo.NetbiosServerName = szCredTargetServer;
            CredTargetInfo.DnsDomainName = szCredTargetDnsDomain;
            CredTargetInfo.DnsServerName = szCredTargetDnsServer;
            CredTargetInfo.DnsTreeName = szCredTargetDnsTree;
            CredTargetInfo.PackageName = NTLMSP_NAME;
            CredTargetInfo.CredTypeCount = 1;
            CredTargetInfo.CredTypes = &CredTypes;


            //
            // if marshalled TargetInfo was supplied, we prefer those fields.
            //

            if( Context->TargetInfo )
            {
                CredTargetInfo.TargetName = Context->TargetInfo->TargetName;
                CredTargetInfo.NetbiosServerName = Context->TargetInfo->NetbiosServerName;
                CredTargetInfo.DnsServerName = Context->TargetInfo->DnsServerName;
                CredTargetInfo.NetbiosDomainName = Context->TargetInfo->NetbiosDomainName;
                CredTargetInfo.DnsDomainName = Context->TargetInfo->DnsDomainName;
                CredTargetInfo.DnsTreeName = Context->TargetInfo->DnsTreeName;

                CredTargetInfo.Flags |= Context->TargetInfo->Flags;
            }

            SecStatus = CopyCredManCredentials (
                                        ClientLogonId,
                                        &CredTargetInfo,
                                        Context,
                                        fShareLevel
                                        );

            if( NT_SUCCESS(SecStatus) )
            {
                fCredmanCredentials = TRUE;
            }

            if( SecStatus == STATUS_NOT_FOUND )
            {
                SecStatus = STATUS_SUCCESS;
            }

            if( !NT_SUCCESS(SecStatus) )
            {
                goto Cleanup;
            }

            //
            // for kernel callers, stow away a copy of the marshalled target info.
            //

            if( Context->KernelClient )
            {
                CredMarshalTargetInfo(
                                &CredTargetInfo,
                                (PUSHORT*)&(Context->pbMarshalledTargetInfo),
                                &Context->cbMarshalledTargetInfo
                                );
            }
        }


        SspContextCopyStringAbsolute(
                            GetChallengeResponse,
                            (PSTRING)&GetChallengeResponse->LogonDomainName,
                            (PSTRING)&Context->DomainName,
                            &MarshalPtr
                            );

        GetChallengeResponseSize += GetChallengeResponse->LogonDomainName.Length;

        SspContextCopyStringAbsolute(
                            GetChallengeResponse,
                            (PSTRING)&GetChallengeResponse->UserName,
                            (PSTRING)&Context->UserName,
                            &MarshalPtr
                            );

        GetChallengeResponseSize += GetChallengeResponse->UserName.Length;


        //
        // Check for null session. This is the case if the caller supplies
        // an empty username, domainname, and password.
        //

        //
        // duplicate the hidden password string, then reveal it into
        // new buffer.  This avoids thread race conditions during hide/reveal
        // and also allows us to avoid re-hiding the material.
        // TODO: add flag that indicates to LSA that provided password is encrypted.
        //

        SecStatus = NtLmDuplicatePassword( &RevealedPassword, &Context->Password );
        if(!NT_SUCCESS( SecStatus ) ) {
                SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: NtLmDuplicatePassword returned %d\n",Status));
            goto Cleanup;
        }

        SspRevealPassword(&RevealedPassword);

        if (((Context->ContextFlags & ISC_RET_NULL_SESSION) != 0) ||
            (((Context->DomainName.Length == 0) && (Context->DomainName.Buffer != NULL)) &&
            ((Context->UserName.Length == 0) && (Context->UserName.Buffer != NULL)) &&
            ((Context->Password.Length == 0) && (Context->Password.Buffer != NULL)))) {


#define NULL_SESSION_REQUESTED RETURN_RESERVED_PARAMETER

            SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session context\n" ));

            GetChallengeResponse->ParameterControl |= NULL_SESSION_REQUESTED |
                                                    USE_PRIMARY_PASSWORD;

        } else {

            //
            // We aren't doing a null session intentionally. MSV may choose
            // to do a null session if we have no credentials available.
            //

            if ( Context->DomainName.Buffer == NULL )
            {
                BOOLEAN FoundAt = FALSE;

                //
                // if  it's a UPN, don't fill in the domain field.
                //

                if( Context->UserName.Buffer != NULL )
                {
                    ULONG i;

                    for(i = 0 ; i < (Context->UserName.Length / sizeof(WCHAR)) ; i++)
                    {
                        if( Context->UserName.Buffer[i] == '@' )
                        {
                            FoundAt = TRUE;
                            break;
                        }
                    }
                }

                if( !FoundAt )
                {
                    GetChallengeResponse->ParameterControl |=
                                  RETURN_PRIMARY_LOGON_DOMAINNAME;
                }
            }

            if ( Context->UserName.Buffer == NULL )
            {
                GetChallengeResponse->ParameterControl |= RETURN_PRIMARY_USERNAME;
            }

            //
            // The password may be a zero length password
            //

            GetChallengeResponse->Password = RevealedPassword;
            if ( Context->Password.Buffer == NULL ) {

                GetChallengeResponse->ParameterControl |= USE_PRIMARY_PASSWORD;


            } else {
                //
                // MSV needs the password to be 'in' the passed in buffer.
                //

                RtlCopyMemory(MarshalPtr,
                              GetChallengeResponse->Password.Buffer,
                              GetChallengeResponse->Password.Length);

                GetChallengeResponse->Password.Buffer =
                                           (LPWSTR)(MarshalPtr);
                GetChallengeResponseSize += GetChallengeResponse->Password.Length +
                                            sizeof(WCHAR);

            }
        }

        //
        // scrub the cleartext password now to avoid pagefile exposure
        // during lengthy processing.
        //

        if( RevealedPassword.Buffer != NULL ) {
            ZeroMemory( RevealedPassword.Buffer, RevealedPassword.Length );
            NtLmFreePrivateHeap( RevealedPassword.Buffer );
            RevealedPassword.Buffer = NULL;
        }


        GetChallengeResponse->LogonId = *ClientLogonId;

        RtlCopyMemory( &GetChallengeResponse->ChallengeToClient,
                       ChallengeMessage->Challenge,
                       MSV1_0_CHALLENGE_LENGTH );

        //
        // if NTLM2 negotiated, then ask MSV1_0 to mix my challenge with the server's...
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
        {
            GetChallengeResponse->ParameterControl |= GENERATE_CLIENT_CHALLENGE;
        } else {

            //
            // if it's share level, and:
            // 1. User only supplied a password, or
            // 2. Credman returned the creds
            // allow downgrade to NTLMv1 from NTLMv2.
            //

            if( fShareLevel )
            {
                if( (GetChallengeResponse->UserName.Length == 0) &&
                    (GetChallengeResponse->LogonDomainName.Length == 0) &&
                    (GetChallengeResponse->Password.Buffer != NULL)
                    )
                {
                    GetChallengeResponse->ParameterControl |= GCR_ALLOW_NTLM;
                }

                if( fCredmanCredentials )
                {
                    GetChallengeResponse->ParameterControl |= GCR_ALLOW_NTLM;
                }
            }
        }

        //
        // Get the DomainName, UserName, and ChallengeResponse from the MSV
        //

        Status = LsaApCallPackage(
                    (PLSA_CLIENT_REQUEST)(-1),
                    GetChallengeResponse,
                    GetChallengeResponse,
                    GetChallengeResponseSize,
                    (PVOID *)&ChallengeResponseMessage,
                    &ChallengeResponseSize,
                    &ProtocolStatus );

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: "
            "ChallengeMessage LsaCall to get ChallengeResponse returns 0x%lx\n",
              Status ));
            SecStatus = SspNtStatusToSecStatus( Status, SEC_E_NO_CREDENTIALS);
            goto Cleanup;
        }

        if ( !NT_SUCCESS(ProtocolStatus) ) {
            Status = ProtocolStatus;
            SspPrint(( SSP_CRITICAL,
              "SsprHandleChallengeMessage: ChallengeMessage LsaCall "
              "to get ChallengeResponse returns ProtocolStatus 0x%lx\n",
              Status ));
            SecStatus = SspNtStatusToSecStatus( Status, SEC_E_NO_CREDENTIALS);
            goto Cleanup;
        }

        //
        // Check to see if we are doing a null session
        //

        if ((ChallengeResponseMessage->CaseSensitiveChallengeResponse.Length == 0) &&
            (ChallengeResponseMessage->CaseInsensitiveChallengeResponse.Length == 1)) {

            SspPrint(( SSP_WARNING, "SsprHandleChallengeMessage: null session\n" ));

            *ContextAttributes |= ISC_RET_NULL_SESSION;
            Context->ContextFlags |= ISC_RET_NULL_SESSION;
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NULL_SESSION;
        } else {

            //
            // Normalize things by copying the default domain name and user name
            // into the ChallengeResponseMessage structure.
            //

            if ( Context->DomainName.Buffer != NULL ) {
                ChallengeResponseMessage->LogonDomainName = Context->DomainName;
            }
            if ( Context->UserName.Buffer != NULL ) {
                ChallengeResponseMessage->UserName = Context->UserName;
            }
        }

        //
        // Convert the domainname/user name to the right character set.
        //

        if ( DoUnicode ) {
            DomainName = *(PSTRING)&ChallengeResponseMessage->LogonDomainName;
            UserName = *(PSTRING)&ChallengeResponseMessage->UserName;
            Workstation =  *(PSTRING)&NtLmGlobalUnicodeComputerNameString;
        } else {
            Status = RtlUpcaseUnicodeStringToOemString(
                        &DomainName,
                        &ChallengeResponseMessage->LogonDomainName,
                        TRUE);

            if ( !NT_SUCCESS(Status) ) {
                SspPrint(( SSP_CRITICAL,
                            "SsprHandleChallengeMessage: RtlUpcaseUnicodeToOemString (DomainName) returned 0x%lx.\n", Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }

            Status = RtlUpcaseUnicodeStringToOemString(
                        &UserName,
                        &ChallengeResponseMessage->UserName,
                        TRUE);

            if ( !NT_SUCCESS(Status) ) {
                SspPrint(( SSP_CRITICAL,
                            "SsprHandleChallengeMessage: RtlUpcaseUnicodeToOemString (UserName) returned 0x%lx.\n", Status));
                SecStatus = SspNtStatusToSecStatus( Status,
                                                    SEC_E_INSUFFICIENT_MEMORY);
                goto Cleanup;
            }
            Workstation =  NtLmGlobalOemComputerNameString;

        }

        //
        // Save the ChallengeResponses
        //

        LmChallengeResponse =
            ChallengeResponseMessage->CaseInsensitiveChallengeResponse;
        NtChallengeResponse =
            ChallengeResponseMessage->CaseSensitiveChallengeResponse;


        //
        // prepare to send encrypted randomly generated session key
        //

        DatagramSessionKey.Buffer = (CHAR*)DatagramKey;
        DatagramSessionKey.Length =
          DatagramSessionKey.MaximumLength = 0;

        //
        // Generate the session key, or encrypt the previosly generated random one,
        // from various bits of info. Fill in session key if needed.
        //

        SecStatus = SsprMakeSessionKey(
                            Context,
                            &LmChallengeResponse,
                            ChallengeResponseMessage->UserSessionKey,
                            ChallengeResponseMessage->LanmanSessionKey,
                            &DatagramSessionKey
                            );

        if (SecStatus != SEC_E_OK)
        {
            SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: SsprMakeSessionKey\n"));
            goto Cleanup;
        }

    }

    //
    // If the caller specified SEQUENCE_DETECT or REPLAY_DETECT,
    // that means they want to use the MakeSignature/VerifySignature
    // calls.  Add this to the returned attributes and the context
    // negotiate flags.
    //

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_REPLAY_DETECT)) {

        Context->ContextFlags |= ISC_RET_REPLAY_DETECT;
        *ContextAttributes |= ISC_RET_REPLAY_DETECT;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_SEQUENCE_DETECT)) {

        Context->ContextFlags |= ISC_RET_SEQUENCE_DETECT;
        *ContextAttributes |= ISC_RET_SEQUENCE_DETECT;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SIGN) ||
        (ContextReqFlags & ISC_REQ_INTEGRITY)) {

        Context->ContextFlags |= ISC_RET_INTEGRITY;
        *ContextAttributes |= ISC_RET_INTEGRITY;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_SEAL) ||
        (ContextReqFlags & ISC_REQ_CONFIDENTIALITY)) {
        if (NtLmGlobalEncryptionEnabled) {
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
            Context->ContextFlags |= ISC_REQ_CONFIDENTIALITY;
            *ContextAttributes |= ISC_REQ_CONFIDENTIALITY;
        } else {
            SecStatus = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                        "SsprHandleChallengeMessage: NtLmGlobalEncryption not enabled.\n"));
            goto Cleanup;
        }
    }

    if ((Context->NegotiateFlags &
         ChallengeMessage->NegotiateFlags &
         NTLMSSP_NEGOTIATE_DATAGRAM) ==
        NTLMSSP_NEGOTIATE_DATAGRAM ) {
        *ContextAttributes |= ISC_RET_DATAGRAM;
        Context->ContextFlags |= ISC_RET_DATAGRAM;
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
    }

    //
    // Slip in the hacky mutual auth override here:
    //

    if ( ((ContextReqFlags & ISC_REQ_MUTUAL_AUTH) != 0 ) &&
         (NtLmGlobalMutualAuthLevel < 2 ) ) {

        *ContextAttributes |= ISC_RET_MUTUAL_AUTH ;

        if ( NtLmGlobalMutualAuthLevel == 0 )
        {
            Context->ContextFlags |= ISC_RET_MUTUAL_AUTH ;
        }

    }

    if( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) &&
        (ContextReqFlags & ISC_REQ_DELEGATE)
        )
    {
        //
        // for loopback, we can indeed support another hop.
        //

        *ContextAttributes |= ISC_RET_DELEGATE;
        Context->ContextFlags |= ISC_RET_DELEGATE;
    }

    //
    // Allocate an authenticate message
    //

    AuthenticateMessageSize =
        sizeof(*AuthenticateMessage) +
        LmChallengeResponse.Length +
        NtChallengeResponse.Length +
        DomainName.Length +
        UserName.Length +
        Workstation.Length +
        DatagramSessionKey.Length;

    if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if ( AuthenticateMessageSize > *OutputTokenSize ) {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: OutputTokenSize is 0x%lx.\n", *OutputTokenSize));
            SecStatus = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
    }

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE)
                          NtLmAllocateLsaHeap(AuthenticateMessageSize );

    if ( AuthenticateMessage == NULL ) {
        SecStatus = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleChallengeMessage: Error allocating AuthenticateMessage.\n" ));
        goto Cleanup;
    }

    //
    // Build the authenticate message
    //

    strcpy( (char *)AuthenticateMessage->Signature, NTLMSSP_SIGNATURE );
    AuthenticateMessage->MessageType = NtLmAuthenticate;

    Where = (PCHAR)(AuthenticateMessage+1);

    //
    // Copy the strings needing 2 byte alignment.
    //

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->DomainName,
                          &DomainName,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->UserName,
                          &UserName,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->Workstation,
                          &Workstation,
                          &Where );

    //
    // Copy the strings not needing special alignment.
    //
    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->LmChallengeResponse,
                          &LmChallengeResponse,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->NtChallengeResponse,
                          &NtChallengeResponse,
                          &Where );

    SspContextCopyString( AuthenticateMessage,
                          &AuthenticateMessage->SessionKey,
                          &DatagramSessionKey,
                          &Where );

    AuthenticateMessage->NegotiateFlags = Context->NegotiateFlags;


    SspPrint(( SSP_NEGOTIATE_FLAGS,
          "SsprHandleChallengeMessage: ChallengeFlags: %lx AuthenticateFlags: %lx\n",
            ChallengeMessage->NegotiateFlags, AuthenticateMessage->NegotiateFlags ));


    //
    // Copy the AuthenticateMessage to the caller's address space.
    //

    if ((ContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        RtlCopyMemory( *OutputToken,
                   AuthenticateMessage,
                   AuthenticateMessageSize );
    }
    else
    {
        *OutputToken = AuthenticateMessage;
        AuthenticateMessage = NULL;
        *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
    }

    *OutputTokenSize = AuthenticateMessageSize;

    // we need to send a second token back for the rdr
    if (fCallFromRedir)
    {
        NtLmInitializeResponse = (PNTLM_INITIALIZE_RESPONSE)
                                 NtLmAllocateLsaHeap(sizeof(NTLM_INITIALIZE_RESPONSE));

        if ( NtLmInitializeResponse == NULL ) {
            SecStatus = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleChallengeMessage: Error allocating NtLmInitializeResponse.\n" ));
            goto Cleanup;
        }
        RtlCopyMemory(
            NtLmInitializeResponse->UserSessionKey,
            ChallengeResponseMessage->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            NtLmInitializeResponse->LanmanSessionKey,
            ChallengeResponseMessage->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );
        *SecondOutputToken = NtLmInitializeResponse;
        NtLmInitializeResponse = NULL;
        *SecondOutputTokenSize = sizeof(NTLM_INITIALIZE_RESPONSE);
    }

    SspPrint((SSP_API_MORE,"Client session key = %p\n",Context->SessionKey));

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    SecStatus = STATUS_SUCCESS;

    //
    // Free and locally used resources.
    //
Cleanup:

    if( RevealedPassword.Buffer != NULL ) {
        ZeroMemory( RevealedPassword.Buffer, RevealedPassword.Length );
        NtLmFreePrivateHeap( RevealedPassword.Buffer );
    }

    if( ServerContext != NULL )
    {
        SspContextDereferenceContext( ServerContext );
    }

    if ( Context != NULL ) {

        Context->LastStatus = SecStatus;
        Context->DownLevel = fCallFromRedir;

        //
        // Don't allow this context to be used again.
        //

        if ( NT_SUCCESS(SecStatus) ) {
            Context->State = AuthenticateSentState;
        } else if ( SecStatus == SEC_I_CALL_NTLMSSP_SERVICE ) {
            Context->State = PassedToServiceState;
        } else {
            Context->State = IdleState;
        }

        RtlCopyMemory(
            SessionKey,
            Context->SessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH );

        *NegotiateFlags = Context->NegotiateFlags;

        // If we just created the context (because rdr may be talking to
        // a pre NT 5.0 server,, we need to dereference it again.

        if (fCallFromRedir && !NT_SUCCESS(SecStatus))
        {
            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext( *ContextHandle, TRUE, &LocalContext );
            ASSERT(LocalContext != NULL);
            if (LocalContext != NULL)
            {
                SspContextDereferenceContext( LocalContext );
            }
        }

        SspContextDereferenceContext( Context );

    }

    if(szCredTargetPreDFSServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetPreDFSServer );
    }

    if(szCredTargetDomain != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDomain );
    }

    if(szCredTargetServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetServer );
    }

    if(szCredTargetDnsDomain != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsDomain );
    }

    if(szCredTargetDnsServer != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsServer );
    }

    if(szCredTargetDnsTree != NULL)
    {
        NtLmFreePrivateHeap( szCredTargetDnsTree );
    }

    if ( ChallengeMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( ChallengeMessage );
    }

    if ( AuthenticateMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( AuthenticateMessage );
    }

    if ( ChallengeResponseMessage != NULL ) {
        (VOID) LsaFunctions->FreeLsaHeap( ChallengeResponseMessage );
    }

    if ( !DoUnicode ) {
        RtlFreeUnicodeString( &TargetName );

        if ( DomainName.Buffer != NULL) {
            RtlFreeOemString( &DomainName );
        }
        if ( UserName.Buffer != NULL) {
            RtlFreeOemString( &UserName );
        }
    }

    RtlFreeUnicodeString( &DefectiveTargetName );

    if( ClientTokenHandle )
    {
        CloseHandle( ClientTokenHandle );
    }

    if(GetChallengeResponse && (GetChallengeResponse!=&TempChallengeResponse)){
        SafeAllocaFree(GetChallengeResponse);
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleChallengeMessage: 0x%lx\n", SecStatus ));
    return SecStatus;

}

NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT LPWSTR* pUserName,
    OUT LPWSTR* pDomainName
    )

/*++

Routine Description:

    This routine separates a passed in user name into domain and username.  A user name must have one
    of the following two syntaxes:

        <DomainName>\<UserName>
        <UserName>@<DnsDomainName>

    The name is considered to have the first syntax if the string contains an \.
    A string containing a @ is ambiguous since <UserName> may contain an @.

    For the second syntax, the last @ in the string is used since <UserName> may
    contain an @ but <DnsDomainName> cannot.

Arguments:

    ParseName - Name of user to validate - will be modified

    pUserName - Returned pointing to canonical name inside of ParseName

    pDomainName - Returned pointing to domain name inside of ParseName


Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{

    LPWSTR SlashPointer;

    *pUserName = NULL;
    *pDomainName = NULL;

    //
    // NULL is invalid
    //

    if ( ParseName == NULL ) {
        return STATUS_INVALID_ACCOUNT_NAME;
    }

    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( ParseName, L'\\' );

    if ( SlashPointer != NULL ) {

        //
        // point the output strings
        //

        *pDomainName = ParseName;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        SlashPointer ++;

        *pUserName = SlashPointer;

    } else {

        //
        // it's a UPN.
        // leave it intact in the UserName field.
        // set the DomainName to empty string, so the rest of the logon code
        // avoids filling in the default.
        //

        *pUserName = ParseName;
        *pDomainName = L"";
    }

    return STATUS_SUCCESS;
}


NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PSSP_CONTEXT Context,
    IN BOOLEAN fShareLevel
    )

/*++

Routine Description:

    Look for a keyring credential entry for the specified domain, and copy to Context handle if found

Arguments:

    LogonId -- LogonId of the calling process.

    pTargetInfo -- Information on target to search for creds.

    Context - Points to the ContextHandle of the Context
        to be referenced.

Return Value:

    STATUS_SUCCESS -- All OK

    STATUS_NOT_FOUND - Credential couldn't be found.

    All others are real failures and should be returned to the caller.
--*/

{
    NTSTATUS Status;
    PENCRYPTED_CREDENTIALW *EncryptedCredentials = NULL;
    PCREDENTIALW *Credentials = NULL;
    ULONG CredentialCount;
    WCHAR* UserName = NULL;
    WCHAR* DomainName = NULL;
    ULONG CredIndex;

    if (!Context) // validate context only after call to Lookup
    {
        return STATUS_NOT_FOUND;
    }

    Status = LsaFunctions->CrediReadDomainCredentials(
                            LogonId,
                            CREDP_FLAGS_IN_PROCESS, // Allow password to be returned
                            pTargetInfo,
                            0,  // no flags
                            &CredentialCount,
                            &EncryptedCredentials );

    Credentials = (PCREDENTIALW *)EncryptedCredentials;

    if(!NT_SUCCESS(Status))
    {
        //
        // Ideally, only STATUS_NO_SUCH_LOGON_SESSION should be converted to
        // STATUS_NOT_FOUND.  However, swallowing all failures and asserting
        // these specific two works around a bug in CrediReadDomainCredentials
        // which returns invalid parameter if the target is a user account name.
        // Eventually, CrediReadDomainCredentials should return a more appropriate
        // error in this case.
        //
        SspPrint(( SSP_API_MORE, "CopyCredManCredentials:  CrediReadDomainCredentials returned %x\n", Status ));
        ASSERT(
            (Status == STATUS_NO_SUCH_LOGON_SESSION)||
            (Status == STATUS_INVALID_PARAMETER)||
            (Status == STATUS_NOT_FOUND)
            );
        return STATUS_NOT_FOUND;
    }


    //
    // Loop through the list of credentials
    //

    for ( CredIndex=0; CredIndex<CredentialCount; CredIndex++ ) {

        UNICODE_STRING TempString;

        //
        // NTLM only supports password credentials
        //

        if ( Credentials[CredIndex]->Type != CRED_TYPE_DOMAIN_PASSWORD ) {
            continue;
        }

        if ( Credentials[CredIndex]->Flags & CRED_FLAGS_PROMPT_NOW ) {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        //
        // Sanity check the credential
        //

        if ( Credentials[CredIndex]->UserName == NULL ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // For Share level connects, don't allow matching against * creds.
        //

        if( fShareLevel )
        {
            if( (Credentials[CredIndex]->TargetName) &&
                (wcschr( Credentials[CredIndex]->TargetName, L'*' ) != NULL) )
            {
                continue;
            }
        }

        //
        // Convert the UserName to domain name and user name
        //

        Status = CredpParseUserName ( Credentials[CredIndex]->UserName, &UserName, &DomainName );

        if(!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Free the existing domain name and add the new one
        //


        if (Context->DomainName.Buffer) {
            NtLmFreePrivateHeap (Context->DomainName.Buffer);
            Context->DomainName.Buffer = NULL;
            Context->DomainName.Length = 0;
        }

        if( DomainName )
        {
            RtlInitUnicodeString( &TempString, DomainName );

            Status = NtLmDuplicateUnicodeString(&Context->DomainName, &TempString);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }


        //
        // Free the existing user name and add the new one
        //

        RtlInitUnicodeString( &TempString, UserName );

        if (Context->UserName.Buffer) {
            NtLmFreePrivateHeap (Context->UserName.Buffer);
            Context->UserName.Buffer = NULL;
        }

        Status = NtLmDuplicateUnicodeString(&Context->UserName, &TempString);
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }


        //
        // Free the existing password and add the new one
        //

        TempString.Buffer = (LPWSTR)Credentials[CredIndex]->CredentialBlob;
        TempString.MaximumLength = (USHORT) Credentials[CredIndex]->CredentialBlobSize;
        TempString.Length = (USHORT) EncryptedCredentials[CredIndex]->ClearCredentialBlobSize;

        if (Context->Password.Buffer) {
            NtLmFreePrivateHeap (Context->Password.Buffer);
            Context->Password.Buffer = NULL;
        }

        // zero length password must be treated as blank or NTLM will assume it should use the
        // password of the currently logged in user.

        if ( TempString.Length == 0 )
        {
            TempString.Buffer = L"";
        }

        Status = NtLmDuplicatePassword(&Context->Password, &TempString);
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }

        goto Cleanup;
    }

    Status = STATUS_NOT_FOUND;

Cleanup:

    //
    // Free the returned credentials
    //

    LsaFunctions->CrediFreeCredentials(
                            CredentialCount,
                            EncryptedCredentials );

    return Status;
}


NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    )
{
    PWSTR Candidate;
    ULONG CandidateSize;

    CREDENTIAL_TARGET_INFORMATIONW *OldTargetInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // LSA will set Length to include only the non-marshalled portion,
    // with MaximumLength trailing data to include marshalled portion.
    //

    if( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length >= TargetServerName->MaximumLength) ||
        ((TargetServerName->MaximumLength - TargetServerName->Length) <
            (sizeof( CREDENTIAL_TARGET_INFORMATIONW )/(sizeof(ULONG_PTR)/2)) )
        )
    {
        return STATUS_SUCCESS;
    }


    RtlCopyMemory(
            &CandidateSize,
            (PBYTE)TargetServerName->Buffer + TargetServerName->MaximumLength - sizeof(ULONG),
            sizeof( CandidateSize )
            );

    if( CandidateSize >= TargetServerName->MaximumLength )
    {
        return STATUS_SUCCESS;
    }

    Candidate = (PWSTR)(
            (PBYTE)TargetServerName->Buffer + TargetServerName->MaximumLength - CandidateSize
            );

    OldTargetInfo = *pTargetInfo;

    Status = CredUnmarshalTargetInfo (
                    Candidate,
                    CandidateSize,
                    pTargetInfo
                    );

    if( !NT_SUCCESS(Status) )
    {
        if( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    }

    if( OldTargetInfo != NULL )
    {
        LocalFree( OldTargetInfo );
    }

    return Status ;
}

NTSTATUS
CredpProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    )
{
    WCHAR FastUserName[ UNLEN+1 ];
    LPWSTR SlowUserName = NULL;
    LPWSTR TempUserName;
    CRED_MARSHAL_TYPE CredMarshalType;
    PUSERNAME_TARGET_CREDENTIAL_INFO pCredentialUserName = NULL;

    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
    ULONG CredTypes;

    SECPKG_CLIENT_INFO ClientInfo;
    SSP_CONTEXT SspContext;
    NTSTATUS Status = STATUS_NOT_FOUND;

    ZeroMemory( &SspContext, sizeof(SspContext) );

    if( (MarshalledUserName->Length+sizeof(WCHAR)) <= sizeof(FastUserName) )
    {
        TempUserName = FastUserName;
    } else {

        SlowUserName = (LPWSTR)NtLmAllocatePrivateHeap( MarshalledUserName->Length + sizeof(WCHAR) );
        if( SlowUserName == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TempUserName = SlowUserName;
    }


    //
    // copy the input to a NULL terminated string, then attempt to unmarshal it.
    //

    RtlCopyMemory(  TempUserName,
                    MarshalledUserName->Buffer,
                    MarshalledUserName->Length
                    );

    TempUserName[ MarshalledUserName->Length / sizeof(WCHAR) ] = L'\0';

    if(!CredUnmarshalCredentialW(
                        TempUserName,
                        &CredMarshalType,
                        (VOID**)&pCredentialUserName
                        ))
    {
        goto Cleanup;
    }

    if( (CredMarshalType != UsernameTargetCredential) )
    {
        goto Cleanup;
    }


    //
    // now query credential manager for a match.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ZeroMemory( &TargetInfo, sizeof(TargetInfo) );

    CredTypes = CRED_TYPE_DOMAIN_PASSWORD;

    TargetInfo.Flags = CRED_TI_USERNAME_TARGET;
    TargetInfo.TargetName = pCredentialUserName->UserName;
    TargetInfo.PackageName = NTLMSP_NAME;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;


    Status = CopyCredManCredentials(
                    &ClientInfo.LogonId,
                    &TargetInfo,
                    &SspContext,
                    FALSE
                    );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *UserName = SspContext.UserName;
    *DomainName = SspContext.DomainName;
    *Password = SspContext.Password;
    SspRevealPassword( Password );

    Status = STATUS_SUCCESS;

Cleanup:

    if(!NT_SUCCESS(Status))
    {
        NtLmFreePrivateHeap( SspContext.UserName.Buffer );
        NtLmFreePrivateHeap( SspContext.DomainName.Buffer );
        NtLmFreePrivateHeap( SspContext.Password.Buffer );
    }

    if( SlowUserName )
    {
        NtLmFreePrivateHeap( SlowUserName );
    }

    if( pCredentialUserName != NULL )
    {
        CredFree( pCredentialUserName );
    }

    return Status;
}

#if 0

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLsaModeContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG SavedUseValidated = 0xFF;
WCHAR SavedCredentialName[1024] = L"SaveMe";
ULONG SavedCredentialType = 0x22;


ULONG SavedCredTypes = CRED_TYPE_DOMAIN_PASSWORD;
CREDENTIAL_TARGET_INFORMATIONW SavedTargetInfo = {
    L"ntdsdc9",
    L"NTDSDC9",
    L"NTDSDC9.ntdev.microsoft.com",
    L"NTDEV",
    L"ntdev.microsoft.com",
    L"ntdev.microsoft.com",
    L"NTLM",
    0,
    1,
    &SavedCredTypes
};

NTSTATUS NTAPI
SpQueryLsaModeContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD WinStatus;
    PSSP_CONTEXT Context = NULL;
    SecPkgContext_CredentialNameW CredentialNameInfo;
    ULONG CredentialNameSize;
    LPWSTR UserCredentialName;

    PCREDENTIAL_TARGET_INFORMATIONW TempTargetInfo = NULL;
    ULONG TempTargetInfoSize;
    PCREDENTIAL_TARGET_INFORMATIONW UserTargetInfo;
    SecPkgContext_TargetInformationW TargetInfo;


    SspPrint((SSP_API, "Entering SpQueryLsaModeContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    //
    // Find the currently existing context.
    //

    Status = SspContextReferenceContext( ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(Status) )
    {
        SspPrint(( SSP_CRITICAL,
                "SpQueryLsaModeContextAttributes: invalid context handle.\n" ));
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute) {
    case SECPKG_ATTR_CREDENTIAL_NAME:

        CredentialNameSize = (wcslen(SavedCredentialName) + 1) * sizeof(WCHAR);

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    CredentialNameSize,
                    (PVOID *) &UserCredentialName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // Copy the name to the user's address space
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    CredentialNameSize,
                    UserCredentialName,
                    SavedCredentialName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // Copy the struct itself to the user's address space
        CredentialNameInfo.CredentialType = SavedCredentialType;
        CredentialNameInfo.sCredentialName = UserCredentialName;

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(CredentialNameInfo),
                    Buffer,
                    &CredentialNameInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:

        //
        // Marshall the target info into a single buffer.
        //


        WinStatus = CredpConvertTargetInfo ( DoWtoW,
                                             &SavedTargetInfo,
                                             &TempTargetInfo,
                                             &TempTargetInfoSize );

        if ( WinStatus != NO_ERROR ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Allocate a buffer the same size in the client's address space.
        //
        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    TempTargetInfoSize,
                    (PVOID *) &UserTargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Relocate all pointers to be user-buffer-specific
        //  YUCK!!
        //

        TempTargetInfo->TargetName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->TargetName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->NetbiosServerName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->NetbiosServerName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsServerName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsServerName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );

        TempTargetInfo->NetbiosDomainName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->NetbiosDomainName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsDomainName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsDomainName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->DnsTreeName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->DnsTreeName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->PackageName = (LPWSTR)( ((LPBYTE)(TempTargetInfo->PackageName)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );
        TempTargetInfo->CredTypes = (LPDWORD)( ((LPBYTE)(TempTargetInfo->CredTypes)) -
                                               ((LPBYTE)(TempTargetInfo)) +
                                               ((LPBYTE)UserTargetInfo) );

        //
        // Copy the target info to the user's address space
        //
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    TempTargetInfoSize,
                    UserTargetInfo,
                    TempTargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy the struct itself to the user's address space
        //
        TargetInfo.TargetInformation = UserTargetInfo;

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(TargetInfo),
                    Buffer,
                    &TargetInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }


        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL) {
        SspContextDereferenceContext( Context );
    }
    if ( TempTargetInfo != NULL ) {
        CredFree( TempTargetInfo );
    }

    SspPrint((SSP_API, "Leaving SpQueryLsaModeContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpSetContextAttributes
//
//  Synopsis:   Set attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpSetContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PSecPkgContext_CredentialNameW CredentialNameInfo;
    ULONG CredentialNameSize;
    LPBYTE LocalBuffer = NULL;


    SspPrint((SSP_API, "Entering SpSetContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    //
    // Find the currently existing context.
    //

    Status = SspContextReferenceContext( ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(Status) )
    {
        SspPrint(( SSP_CRITICAL,
                "SpSetContextAttributes: invalid context handle.\n" ));
        goto Cleanup;
    }


    //
    // Grab a local copy of the data
    //
    // Sanity check this size before allocating
    LocalBuffer = (LPBYTE) NtLmAllocatePrivateHeap( BufferSize );

    if ( LocalBuffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = LsaFunctions->CopyFromClientBuffer(
                NULL,
                BufferSize,
                LocalBuffer,
                Buffer );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute) {
    case SECPKG_ATTR_USE_VALIDATED:

        if ( BufferSize != sizeof(SavedUseValidated) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        SavedUseValidated = *(LPDWORD)LocalBuffer;
        break;

    case SECPKG_ATTR_CREDENTIAL_NAME:

        if ( BufferSize <= sizeof(SecPkgContext_CredentialNameW) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        // Sanity check the pointer and the contained string.
        CredentialNameInfo = (PSecPkgContext_CredentialNameW) LocalBuffer;
        SavedCredentialType = CredentialNameInfo->CredentialType;

        // I'm guessing at the offset of the string.
        wcscpy( SavedCredentialName, (LPWSTR)(CredentialNameInfo+1) );

        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL) {
        SspContextDereferenceContext( Context );
    }
    if ( LocalBuffer != NULL ) {
        NtLmFreePrivateHeap( LocalBuffer );
    }

    SspPrint((SSP_API, "Leaving SpSetContextAttributes for ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    return (SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the NtLm package
//              Main entry points into this dll:
//                SpAcceptCredentials
//                SpAcquireCredentialsHandle
//                SpFreeCredentialsHandle
//                SpQueryCredentialsAttributes
//                SpSaveCredentials
//                SpGetCredentials
//                SpDeleteCredentials
//
//              Helper functions:
//                CopyClientString
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\credapi.cxx
//
//------------------------------------------------------------------------
#define NTLM_CREDAPI
#include <global.h>

extern "C"
{
#include <nlp.h>
}



//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Oem or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    SspPrint((SSP_API_MORE,"Entering CopyClientString\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString;
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;
    TemporaryString.Buffer = NULL;


    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) NtLmAllocate(sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from NtLmAllocate is 0x%lx\n", Status));
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            *DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize > 0xFFFF) ||
                 ((SourceSize - CharacterSize) > 0xFFFF)
                 )
            {
                Status = STATUS_INVALID_PARAMETER;
                SspPrint((SSP_CRITICAL,"CopyClientString, SourceSize is too large\n"));
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) NtLmAllocate(SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = STATUS_NO_MEMORY;
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from NtLmAllocate is 0x%lx\n", Status));
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"CopyClientString, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;

                TemporaryString.Buffer = NULL;
            }
            else
            {
                //
                // allocate enough space based on the size of the original Unicode input.
                // required so that we can use our own allocation scheme.
                //

                DestinationString->Buffer = (LPWSTR)NtLmAllocate( SourceSize*sizeof(WCHAR) );
                if( DestinationString->Buffer == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    SspPrint((SSP_CRITICAL,"Error from NtLmAllocate\n"));
                    goto Cleanup;
                }

                DestinationString->Length = (USHORT)(SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT)SourceSize * sizeof(WCHAR);

                Status = RtlOemStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            FALSE
                            );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL,"CopyClientString, Error from RtlOemStringToUnicodeString is 0x%lx\n", Status));
                    // set to STATUS_NO_MEMORY, as it's unlikely that locale error code would be useful.
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer != NULL)
    {
        NtLmFree(TemporaryString.Buffer);
    }

    SspPrint((SSP_API_MORE,"Leaving CopyClientString\n"));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the NtLm package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - NtLm -Specific blob of
//                  supplemental credentials.
//
//  Returns:    None
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = S_OK;
    SspPrint((SSP_API,"Entering SpAcceptCredentials\n"));

    Status = SspAcceptCredentials(
                LogonType,
                PrimaryCredentials,
                SupplementalCredentials
                );

    SspPrint((SSP_API,"Leaving SpAcceptCredentials\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
    UNREFERENCED_PARAMETER( AccountName );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains NtLm Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a SSP_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Unused blob of NtLm-specific data
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Returns:
//    STATUS_SUCCESS -- Call completed successfully
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
//    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
//    SEC_E_NOT_OWNER -- caller does not own the specified credentials
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID LogonId,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PULONG_PTR CredentialHandle,
    OUT PTimeStamp ExpirationTime
    )
{
    SspPrint((SSP_API,"Entering SpAcquireCredentialsHandle\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING Password;
    ULONG NewCredentialUseFlags = CredentialUseFlags;
    PSEC_WINNT_AUTH_IDENTITY pAuthIdentity = NULL;
    BOOLEAN DoUnicode = TRUE;
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentityEx = NULL;

    PSEC_WINNT_AUTH_IDENTITY_W TmpCredentials = NULL;
    ULONG CredSize = 0;
    ULONG Offset = 0;

    //
    // Initialization
    //

    RtlInitUnicodeString(
        &UserName,
        NULL);

    RtlInitUnicodeString(
        &DomainName,
        NULL);

    RtlInitUnicodeString(
        &Password,
        NULL);

    //
    // Validate the arguments
    //

    if ( (CredentialUseFlags & (SECPKG_CRED_OUTBOUND |SECPKG_CRED_INBOUND)) == 0)
    {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint((SSP_CRITICAL,"Error from SpAquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

    // RDR2 passes in a 1 while talking to down level clients

    if ( ARGUMENT_PRESENT(GetKeyArgument) && (GetKeyArgument != (PVOID) 1)) {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint((SSP_CRITICAL,"Error from SpAquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // First get information about the caller.
    //

    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonIdToUse;

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->GetClientInfo is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // If the caller supplied a logon ID, and it doesn't match the caller,
    // they must have the TCB privilege
    //


    if (ARGUMENT_PRESENT(LogonId) &&
        ((LogonId->LowPart != 0) || (LogonId->HighPart != 0)) &&
        !RtlEqualLuid( LogonId, &ClientInfo.LogonId)
        )
    {
        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from ClientInfo.HasTcbPrivilege is 0x%lx\n", Status));
            goto Cleanup;
        }

        LogonIdToUse = LogonId;

        // note: there is a special case where the LogonIdToUse specifies
        // the SYSTEM token, and there may not be a credential (and access token)
        // for that Luid yet.  This special case is handled in SsprAcquireCredentialsHandle()

    }
    else
    {
        //
        // Use the callers logon id.
        //

        LogonIdToUse = &ClientInfo.LogonId;
    }

    //
    // Copy over the authorization data into out address
    // space and make a local copy of the strings.
    //


    if (AuthorizationData != NULL)
    {
        SECPKG_CALL_INFO CallInfo ;
        SEC_WINNT_AUTH_IDENTITY32 Cred32 ;
        SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 ;

        if(!LsaFunctions->GetCallInfo( &CallInfo ))
        {
            Status = STATUS_INTERNAL_ERROR;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->GetCallInfo is 0x%lx\n", Status));
            goto Cleanup;
        }

        pAuthIdentityEx = (PSEC_WINNT_AUTH_IDENTITY_EXW) NtLmAllocate(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));

        if (pAuthIdentityEx != NULL)
        {
            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {

                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( Cred32 ),
                            pAuthIdentityEx,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    RtlCopyMemory( &Cred32, pAuthIdentityEx, sizeof( Cred32 ) );
                }

            }
            else 
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY),
                            pAuthIdentityEx,
                            AuthorizationData);
            }


            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from NtLmAllocate is 0x%lx\n", Status));
            goto Cleanup;
        }

        //
        // Check for the ex version
        //

        if (pAuthIdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
        {
            //
            // It's an EX structure.
            //

            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( CredEx32 ),
                            &CredEx32,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    pAuthIdentityEx->Version = CredEx32.Version ;
                    pAuthIdentityEx->Length = (CredEx32.Length < sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ? 
                                               sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) : CredEx32.Length );

                    pAuthIdentityEx->User = (PWSTR) UlongToPtr( CredEx32.User );
                    pAuthIdentityEx->UserLength = CredEx32.UserLength ;
                    pAuthIdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                    pAuthIdentityEx->DomainLength = CredEx32.DomainLength ;
                    pAuthIdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                    pAuthIdentityEx->PasswordLength = CredEx32.PasswordLength ;
                    pAuthIdentityEx->Flags = CredEx32.Flags ;
                    pAuthIdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
                    pAuthIdentityEx->PackageListLength = CredEx32.PackageListLength ;

                }

            }
            else
            {
                Status = LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                            pAuthIdentityEx,
                            AuthorizationData);

            }


            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &pAuthIdentityEx->User;
            CredSize = pAuthIdentityEx->Length;
            Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
        }
        else
        {
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentityEx;

            if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
            {
                pAuthIdentity->User = (PWSTR) UlongToPtr( Cred32.User );
                pAuthIdentity->UserLength = Cred32.UserLength ;
                pAuthIdentity->Domain = (PWSTR) UlongToPtr( Cred32.Domain );
                pAuthIdentity->DomainLength = Cred32.DomainLength ;
                pAuthIdentity->Password = (PWSTR) UlongToPtr( Cred32.Password );
                pAuthIdentity->PasswordLength = Cred32.PasswordLength ;
                pAuthIdentity->Flags = Cred32.Flags ;
            }
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
        }

        if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
        {
            DoUnicode = FALSE;
            //
            // Turn off the marshalled flag because we don't support marshalling
            // with ansi.
            //

            pAuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
        }
        else if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from pAuthIdentity->Flags is 0x%lx\n", pAuthIdentity->Flags));
            goto Cleanup;
        }
        

        // This is the only place where we can figure out whether null
        // session was requested

        if ((pAuthIdentity->UserLength == 0) &&
            (pAuthIdentity->DomainLength == 0) &&
            (pAuthIdentity->PasswordLength == 0) &&
            (pAuthIdentity->User != NULL) &&
            (pAuthIdentity->Domain != NULL) &&
            (pAuthIdentity->Password != NULL))
        {
            NewCredentialUseFlags |= NTLM_CRED_NULLSESSION;
        }

        //
        // Copy over the strings
        //
        if( (pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0 ) {
            ULONG TmpCredentialSize;
            ULONG_PTR EndOfCreds;
            ULONG_PTR TmpUser;
            ULONG_PTR TmpDomain;
            ULONG_PTR TmpPassword;

            if( pAuthIdentity->UserLength > UNLEN ||
                pAuthIdentity->PasswordLength > PWLEN ||
                pAuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH ) {

                SspPrint((SSP_CRITICAL,"Supplied credentials illegal length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // The callers can set the length of field to n chars, but they
            // will really occupy n+1 chars (null-terminator).
            //

            TmpCredentialSize = CredSize +
                             (  pAuthIdentity->UserLength +
                                pAuthIdentity->DomainLength +
                                pAuthIdentity->PasswordLength +
                             (((pAuthIdentity->User != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Domain != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Password != NULL) ? 1 : 0)) ) * sizeof(WCHAR);

            EndOfCreds = (ULONG_PTR) AuthorizationData + TmpCredentialSize;

            //
            // Verify that all the offsets are valid and no overflow will happen
            //

            TmpUser = (ULONG_PTR) pAuthIdentity->User;

            if ((TmpUser != NULL) &&
                ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                  (TmpUser > EndOfCreds) ||
                  ((TmpUser + (pAuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpUser + (pAuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
            {
                SspPrint((SSP_CRITICAL,"Username in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            TmpDomain = (ULONG_PTR) pAuthIdentity->Domain;

            if ((TmpDomain != NULL) &&
                ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                  (TmpDomain > EndOfCreds) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
            {
                SspPrint((SSP_CRITICAL,"Domainname in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            TmpPassword = (ULONG_PTR) pAuthIdentity->Password;

            if ((TmpPassword != NULL) &&
                ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                  (TmpPassword > EndOfCreds) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
            {
                SspPrint((SSP_CRITICAL,"Password in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Allocate a chunk of memory for the credentials
            //

            TmpCredentials = (PSEC_WINNT_AUTH_IDENTITY_W) NtLmAllocate(TmpCredentialSize - Offset);
            if (TmpCredentials == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Copy the credentials from the client
            //

            Status = LsaFunctions->CopyFromClientBuffer(
                        NULL,
                        TmpCredentialSize - Offset,
                        TmpCredentials,
                        (PUCHAR) AuthorizationData + Offset
                        );
            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL,"Failed to copy whole auth identity\n"));
                goto Cleanup;
            }

            //
            // Now convert all the offsets to pointers.
            //

            if (TmpCredentials->User != NULL)
            {
                USHORT cbUser;

                TmpCredentials->User = (LPWSTR) RtlOffsetToPointer(
                                                TmpCredentials->User,
                                                (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                );

                ASSERT( (TmpCredentials->UserLength*sizeof(WCHAR)) <= 0xFFFF );

                cbUser = (USHORT)(TmpCredentials->UserLength * sizeof(WCHAR));
                UserName.Buffer = (PWSTR)NtLmAllocate( cbUser );

                if (UserName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( UserName.Buffer, TmpCredentials->User, cbUser );
                UserName.Length = cbUser;
                UserName.MaximumLength = cbUser;
            }

            if (TmpCredentials->Domain != NULL)
            {
                USHORT cbDomain;

                TmpCredentials->Domain = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Domain,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );

                ASSERT( (TmpCredentials->DomainLength*sizeof(WCHAR)) <= 0xFFFF );
                cbDomain = (USHORT)(TmpCredentials->DomainLength * sizeof(WCHAR));
                DomainName.Buffer = (PWSTR)NtLmAllocate( cbDomain );

                if (DomainName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( DomainName.Buffer, TmpCredentials->Domain, cbDomain );
                DomainName.Length = cbDomain;
                DomainName.MaximumLength = cbDomain;
            }

            if (TmpCredentials->Password != NULL)
            {
                USHORT cbPassword;

                TmpCredentials->Password = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Password,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );


                ASSERT( (TmpCredentials->PasswordLength*sizeof(WCHAR)) <= 0xFFFF );
                cbPassword = (USHORT)(TmpCredentials->PasswordLength * sizeof(WCHAR));
                Password.Buffer = (PWSTR)NtLmAllocate( cbPassword );

                if (Password.Buffer == NULL ) {
                    ZeroMemory( TmpCredentials->Password, cbPassword );
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                CopyMemory( Password.Buffer, TmpCredentials->Password, cbPassword );
                Password.Length = cbPassword;
                Password.MaximumLength = cbPassword;

                ZeroMemory( TmpCredentials->Password, cbPassword );
            }
            
        } else {

            if (pAuthIdentity->Password != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Password,
                                pAuthIdentity->PasswordLength,
                                DoUnicode,
                                &Password
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

            }

            if (pAuthIdentity->User != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->User,
                                pAuthIdentity->UserLength,
                                DoUnicode,
                                &UserName
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

            }

            if (pAuthIdentity->Domain != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Domain,
                                pAuthIdentity->DomainLength,
                                DoUnicode,
                                &DomainName
                                );
                if (!NT_SUCCESS(Status))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
                    goto Cleanup;
                }

                //
                // Make sure that the domain name length is not greater
                // than the allowed dns domain name
                //

                if (DomainName.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR))
                {
                    SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle: Invalid supplied domain name %wZ\n",
                        &DomainName ));
                    Status = SEC_E_UNKNOWN_CREDENTIALS;
                    goto Cleanup;
                }

            }
        }
    }   // AuthorizationData != NULL

#if 0
    //
    // Handle UPN and composite NETBIOS syntax
    //          
    {
        UNICODE_STRING User = UserName;
        UNICODE_STRING Domain = DomainName;
        
        Status = 
            NtLmParseName(
                &User,
                &Domain,
                TRUE); // If successful, this will allocate and free buffers
        if(NT_SUCCESS(Status)){            
                
                UserName = User;
                DomainName = Domain;
            
        }
    }    
#endif

    if( Password.Length != 0 )
    {
        UNICODE_STRING OldPassword = Password;
        
        Status = NtLmDuplicatePassword( &Password, &OldPassword );
        if(!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        
        ZeroMemory( OldPassword.Buffer, OldPassword.Length );
        NtLmFree( OldPassword.Buffer );
    }

    Status = SsprAcquireCredentialHandle(
                                LogonIdToUse,
                                &ClientInfo,
                                NewCredentialUseFlags,
                                CredentialHandle,
                                ExpirationTime,
                                &DomainName,
                                &UserName,
                                &Password );

    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL, "SpAcquireCredentialsHandle, Error from SsprAcquireCredentialsHandle is 0x%lx\n", Status));
        goto Cleanup;
    }

//  These will be kept in the Credential structure and freed
//  when the Credential structure is freed

    if (DomainName.Buffer != NULL)
    {
        DomainName.Buffer = NULL;
    }

    if (UserName.Buffer != NULL)
    {
        UserName.Buffer = NULL;
    }

    if (Password.Buffer != NULL)
    {
        Password.Buffer = NULL;
    }

Cleanup:

    if (TmpCredentials != NULL)
    {
        NtLmFree(TmpCredentials);
    }

    if (DomainName.Buffer != NULL)
    {
        NtLmFree(DomainName.Buffer);
    }

    if (UserName.Buffer != NULL)
    {
        NtLmFree(UserName.Buffer);
    }

    if (Password.Buffer != NULL)
    {
        ZeroMemory(Password.Buffer, Password.Length);
        NtLmFree(Password.Buffer);
    }

    if (pAuthIdentityEx != NULL)
    {
        NtLmFree(pAuthIdentityEx);
    }

    SspPrint((SSP_API, "Leaving SpAcquireCredentialsHandle, Status is %d\n", Status));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Unlinks the credential from the global list and the list
//              for this client.
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//              (acquired through AcquireCredentialsHandle)
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN ULONG_PTR CredentialHandle
    )
{
    SspPrint((SSP_API, "Entering SpFreeCredentialsHandle\n"));
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CREDENTIAL Credential;

    //
    // Find the referenced credential and delink it.
    //

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            TRUE,       // remove the instance of the credential
                            &Credential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint((SSP_CRITICAL, "SpFreeCredentialsHandle, Error from SspCredentialReferenceCredential is 0x%lx\n", Status));
        goto Cleanup;
    }

    //
    // Dereferencing the Credential will remove the client's reference
    // to it, causing it to be rundown if nobody else is using it.
    //

    SspCredentialDereferenceCredential( Credential );

Cleanup:

    //
    // Catch spurious INVALID_HANDLE being returned to RPC.
    //

    ASSERT( NT_SUCCESS(Status) );

    SspPrint((SSP_API, "Leaving SpFreeCredentialsHandle\n"));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


NTSTATUS
NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    PSSP_CREDENTIAL Credential = NULL;
    SecPkgCredentials_NamesW Names;
    LUID LogonId;
    BOOLEAN ActiveLogonsAreLocked = FALSE;

    LPWSTR ContextNames = NULL;
    LPWSTR Where;

    LPWSTR UserName = NULL;
    LPWSTR DomainName = NULL;
    DWORD cchUserName;
    DWORD cchDomainName;
    ULONG Length;

    BOOLEAN CalledLsaLookup = FALSE;
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomain = NULL;
    LSAPR_TRANSLATED_NAMES ReferencedUser;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    NTSTATUS Status = STATUS_SUCCESS;

    SspPrint((SSP_API,"In SpQueryCredentialsAttributes\n"));


    Names.sUserName = NULL;

    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        SspPrint((SSP_MISC, "Asked for illegal info level in QueryCredAttr: %d\n",
                CredentialAttribute));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = SspCredentialReferenceCredential(
                            CredentialHandle,
                            FALSE,
                            &Credential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint((SSP_CRITICAL, "SpQueryCredentialsAttributes, Error from SspCredentialReferenceCredential is 0x%lx\n", Status));
        goto Cleanup;
    }

#if _WIN64
    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        SspPrint((SSP_CRITICAL, "SpQueryCredentialsAttributes, failed to get callinfo 0x%lx\n", Status));
        goto Cleanup;
    }
#endif



    //
    // The logon id of the credential is constant, so it is o.k.
    // to use it without locking the credential
    //

    LogonId = Credential->LogonId;


    //
    // credentials were either specified when cred built, or, they were defaulted.
    //

    if( Credential->UserName.Buffer == NULL &&
        Credential->DomainName.Buffer == NULL )
    {
        PACTIVE_LOGON *ActiveLogon, Logon = NULL;

        //
        // defaulted creds: pickup info from active logon table.
        //

        NlpLockActiveLogonsRead();
        ActiveLogonsAreLocked = TRUE;

        if (NlpFindActiveLogon (
                 &LogonId,
                 &ActiveLogon))
        {

            //
            // found an active logon entry.
            //

            Logon = *ActiveLogon;

            UserName = Logon->UserName.Buffer;
            cchUserName = Logon->UserName.Length / sizeof(WCHAR);
            DomainName = Logon->LogonDomainName.Buffer;
            cchDomainName = Logon->LogonDomainName.Length / sizeof(WCHAR);

        } else {

            PTOKEN_USER pTokenInfo;
            BYTE FastBuffer[ 256 ];
            DWORD cbTokenInfo;
            SID_NAME_USE snu;
            HANDLE ClientTokenHandle;

            BOOL fSuccess = FALSE;

            NlpUnlockActiveLogons();
            ActiveLogonsAreLocked = FALSE;


            //
            // get a token associated with the logon session.
            //

            Status = LsaFunctions->OpenTokenByLogonId(
                                        &LogonId,
                                        &ClientTokenHandle
                                        );

            if(!NT_SUCCESS(Status))
            {
                SspPrint(( SSP_CRITICAL,
                          "SpQueryCredentialsAttributes: "
                          "Could not open client token 0x%lx\n",
                          Status ));
                goto Cleanup;
            }

            //
            // get Sid associated with credential.
            //

            cbTokenInfo = sizeof(FastBuffer);
            pTokenInfo = (PTOKEN_USER)FastBuffer;

 
            fSuccess = GetTokenInformation(
                            ClientTokenHandle,
                            TokenUser,
                            pTokenInfo,
                            cbTokenInfo,
                            &cbTokenInfo
                            );


            CloseHandle( ClientTokenHandle );

            if( fSuccess ) {

                LSAPR_SID_ENUM_BUFFER SidEnumBuffer;
                LSAPR_SID_INFORMATION SidInfo;
                ULONG MappedCount;

                SidEnumBuffer.Entries = 1;
                SidEnumBuffer.SidInfo = &SidInfo;

                SidInfo.Sid = (LSAPR_SID*)pTokenInfo->User.Sid;


                ZeroMemory( &ReferencedUser, sizeof(ReferencedUser) );
                CalledLsaLookup = TRUE;

                Status = LsarLookupSids(
                            NtLmGlobalPolicyHandle,
                            &SidEnumBuffer,
                            &ReferencedDomain,
                            &ReferencedUser,
                            LsapLookupWksta,
                            &MappedCount
                            );

                if( !NT_SUCCESS( Status ) ||
                    (MappedCount == 0) ||
                    (ReferencedUser.Entries == 0) ||
                    (ReferencedDomain == NULL) ||
                    (ReferencedDomain->Entries == 0)
                    ) {

                    fSuccess = FALSE;

                } else {

                    LONG Index = ReferencedUser.Names->DomainIndex;

                    UserName = ReferencedUser.Names->Name.Buffer;
                    cchUserName = ReferencedUser.Names->Name.Length / sizeof(WCHAR);

                    DomainName = ReferencedDomain->Domains[Index].Name.Buffer;
                    cchDomainName = ReferencedDomain->Domains[Index].Name.Length / sizeof(WCHAR);
                }

            }


            if( !fSuccess )
            {

                Status = STATUS_NO_SUCH_LOGON_SESSION;
                SspPrint(( SSP_CRITICAL, "SpQueryCredentialsAtributes, NlpFindActiveLogon returns FALSE\n"));
                goto Cleanup;

            }
        }

    } else {

        //
        // specified creds.
        //

        UserName = Credential->UserName.Buffer;
        cchUserName = Credential->UserName.Length / sizeof(WCHAR);
        DomainName = Credential->DomainName.Buffer;
        cchDomainName = Credential->DomainName.Length / sizeof(WCHAR);
    }

    Length = (cchUserName + 1 + cchDomainName + 1) * sizeof(WCHAR);

    ContextNames = (LPWSTR)NtLmAllocate( Length );
    if( ContextNames == NULL ) {
        goto Cleanup;
    }

    Where = ContextNames;

    if( DomainName) {
        RtlCopyMemory( ContextNames, DomainName, cchDomainName * sizeof(WCHAR) );
        ContextNames[ cchDomainName ] = L'\\';
        Where += (cchDomainName+1);
    }


    if( UserName ) {
        RtlCopyMemory( Where, UserName, cchUserName * sizeof(WCHAR) );
    }

    Where[ cchUserName ] = L'\0';


    if (ActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
        ActiveLogonsAreLocked = FALSE;
    }


    //
    // Allocate memory in the client's address space
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                Length,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the string there
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                Length,
                Names.sUserName,
                ContextNames
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now copy the address of the string there
    //

#if _WIN64

    if( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    } else {

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }

#else

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                sizeof(Names),
                Buffer,
                &Names
                );
#endif

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    if (ActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
    }

    if( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    if( CalledLsaLookup ) {

        if( ReferencedDomain ) {
            LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST( ReferencedDomain );
        }

        LsaIFree_LSAPR_TRANSLATED_NAMES( &ReferencedUser );
    }

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
    }

    if( ContextNames ) {
        NtLmFree( ContextNames );
    }


    SspPrint((SSP_API, "Leaving SpQueryCredentialsAttributes\n"));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    SspPrint((SSP_API,"In SpSaveCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpGetCredentials(
    IN ULONG_PTR CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    SspPrint((SSP_API,"In SpGetCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpDeleteCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Key
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Key);
    SspPrint((SSP_API,"In SpDeleteCredentials\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ctxtsrv.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    ctxtsrv.cxx

Abstract:

    API and support routines for handling security contexts.

Author:

    Cliff Van Dyke (CliffV) 13-Jul-1993

Revision History:
    ChandanS 03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\context.c
    JClark   28-Jun-2000  Added WMI Trace Logging Support

--*/


//
// Common include files.
//

#include <global.h>
#include <align.h>      // ALIGN_WCHAR, etc
#include "Trace.h"


NTSTATUS
SsprHandleNegotiateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the Negotiate message part of AcceptSecurityContext.

Arguments:

    All arguments same as for AcceptSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CONTINUE_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;
    STRING TargetName;
    ULONG TargetFlags = 0;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;

    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    ULONG ChallengeMessageSize = 0;
    PCHAR Where = NULL;

    ULONG NegotiateFlagsKeyStrength;

    UNICODE_STRING NtLmLocalUnicodeTargetName;
    UNICODE_STRING TargetInfo;
    STRING NtLmLocalOemTargetName;
    STRING OemWorkstationName;
    STRING OemDomainName;

    SspPrint(( SSP_API_MORE, "Entering SsprNegotiateMessage\n" ));
    //
    // Initialization
    //

    *ContextAttributes = 0;

    RtlInitString( &TargetName, NULL );

    RtlInitUnicodeString( &NtLmLocalUnicodeTargetName, NULL );
    RtlInitString( &NtLmLocalOemTargetName, NULL );

    RtlInitUnicodeString( &TargetInfo, NULL );

    //
    // Get a pointer to the credential
    //

    Status = SspCredentialReferenceCredential(
                    CredentialHandle,
                    FALSE,
                    &Credential );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: invalid credential handle.\n" ));
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_INBOUND) == 0 ) {
        Status = SEC_E_INVALID_CREDENTIAL_USE;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleNegotiateMessage: invalid credential use.\n" ));
        goto Cleanup;
    }

    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext( );

    if ( Context == NULL ) {
        Status = STATUS_NO_MEMORY;
        SspPrint(( SSP_CRITICAL,
            "SsprHandleNegotiateMessage: SspContextAllocateContext() returned NULL.\n" ));
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    *ContextHandle = (ULONG_PTR) Context;


    if ( (ContextReqFlags & ASC_REQ_IDENTIFY) != 0 ) {

        *ContextAttributes |= ASC_RET_IDENTIFY;
        Context->ContextFlags |= ASC_RET_IDENTIFY;
    }

    if ( (ContextReqFlags & ASC_REQ_DATAGRAM) != 0 ) {

        *ContextAttributes |= ASC_RET_DATAGRAM;
        Context->ContextFlags |= ASC_RET_DATAGRAM;
    }

    if ( (ContextReqFlags & ASC_REQ_CONNECTION) != 0 ) {

        *ContextAttributes |= ASC_RET_CONNECTION;
        Context->ContextFlags |= ASC_RET_CONNECTION;
    }

    if ( (ContextReqFlags & ASC_REQ_INTEGRITY) != 0 ) {

        *ContextAttributes |= ASC_RET_INTEGRITY;
        Context->ContextFlags |= ASC_RET_INTEGRITY;
    }

    if ( (ContextReqFlags & ASC_REQ_REPLAY_DETECT) != 0){

        *ContextAttributes |= ASC_RET_REPLAY_DETECT;
        Context->ContextFlags |= ASC_RET_REPLAY_DETECT;
    }

    if ( (ContextReqFlags & ASC_REQ_SEQUENCE_DETECT ) != 0) {

        *ContextAttributes |= ASC_RET_SEQUENCE_DETECT;
        Context->ContextFlags |= ASC_RET_SEQUENCE_DETECT;
    }

    // Nothing to return, we might need this on the next server side call.
    if ( (ContextReqFlags & ASC_REQ_ALLOW_NULL_SESSION ) != 0) {

        Context->ContextFlags |= ASC_REQ_ALLOW_NULL_SESSION;
    }

    if ( (ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) != 0) {

        *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
        Context->ContextFlags |= ASC_RET_ALLOW_NON_USER_LOGONS;
    }

    if ( ContextReqFlags & ASC_REQ_CONFIDENTIALITY ) {

        if (NtLmGlobalEncryptionEnabled) {
            *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ASC_RET_CONFIDENTIALITY;
        } else {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: invalid ContextReqFlags 0x%lx\n", ContextReqFlags ));
            goto Cleanup;
        }
    }



    //
    // Supported key strength(s)
    //

    NegotiateFlagsKeyStrength = NTLMSSP_NEGOTIATE_56;

    if( NtLmSecPkg.MachineState & SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED )
    {
        NegotiateFlagsKeyStrength |= NTLMSSP_NEGOTIATE_128;
    }


    //
    // Get the NegotiateMessage.  If we are re-establishing a datagram
    // context then there may not be one.
    //

    if ( InputTokenSize >= sizeof(OLD_NEGOTIATE_MESSAGE) ) {

        Status = SspContextGetMessage( InputToken,
                                          InputTokenSize,
                                          NtLmNegotiate,
                                          (PVOID *)&NegotiateMessage );

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage GetMessage returns 0x%lx\n",
                      Status ));
            goto Cleanup;
        }

        //
        // Compute the TargetName to return in the ChallengeMessage.
        //

        if ( NegotiateMessage->NegotiateFlags & NTLMSSP_REQUEST_TARGET ||
             NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE) {
                Status = NtLmDuplicateUnicodeString( &NtLmLocalUnicodeTargetName, &NtLmGlobalUnicodeTargetName );
                TargetName = *((PSTRING)&NtLmLocalUnicodeTargetName);
            } else {
                Status = NtLmDuplicateString( &NtLmLocalOemTargetName, &NtLmGlobalOemTargetName );
                TargetName = NtLmLocalOemTargetName;
            }

            //
            // if client is NTLM2-aware, send it target info AV pairs
            //

            if(NT_SUCCESS(Status))
            {
                Status = NtLmDuplicateUnicodeString( &TargetInfo, &NtLmGlobalNtLm3TargetInfo );
            }

            TargetFlags = NtLmGlobalTargetFlags;
            RtlReleaseResource (&NtLmGlobalCritSect);

            TargetFlags |= NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO;

            if(!NT_SUCCESS(Status)) {
                SspPrint(( SSP_CRITICAL,
                          "SsprHandleNegotiateMessage: "
                          "failed to duplicate UnicodeTargetName or OemTargetName error 0x%lx\n",
                          Status ));

                goto Cleanup;
            }

        } else {
            TargetFlags = 0;
        }


        //
        // Allocate a Challenge message
        //

        ChallengeMessageSize = sizeof(*ChallengeMessage) +
                                TargetName.Length +
                                TargetInfo.Length ;

        if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( ChallengeMessageSize > *OutputTokenSize ) {
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid ChallengeMessageSize\n"));
                Status = SEC_E_BUFFER_TOO_SMALL;
                goto Cleanup;
            }
        }

        ChallengeMessage = (PCHALLENGE_MESSAGE)
                           NtLmAllocateLsaHeap( ChallengeMessageSize );

        if ( ChallengeMessage == NULL ) {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: Error allocating ChallengeMessage.\n" ));
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        ChallengeMessage->NegotiateFlags = 0;

        //
        // Check that both sides can use the same authentication model.  For
        // compatibility with beta 1 and 2 (builds 612 and 683), no requested
        // authentication type is assumed to be NTLM.  If NetWare is explicitly
        // asked for, it is assumed that NTLM would have been also, so if it
        // wasn't, return an error.
        //

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE) &&
             ((NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) == 0) &&
             ((NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0)
            ) {
            Status = STATUS_NOT_SUPPORTED;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage asked for Netware only.\n" ));
            goto Cleanup;
        } else {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;
        }




        //
        // if client can do NTLM2, nuke LM_KEY
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {
            NegotiateMessage->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;

            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM2;
        } else if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;
        }


        //
        // If the client wants to always sign messages, so be it.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
        }

        //
        // If the caller wants identify level, so be it.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_IDENTIFY;

            *ContextAttributes |= ASC_RET_IDENTIFY;
            Context->ContextFlags |= ASC_RET_IDENTIFY;

        }


        //
        // Determine if the caller wants OEM or UNICODE
        //
        // Prefer UNICODE if caller allows both.
        //

        if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
        } else if ( NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM ){
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
        } else {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage bad NegotiateFlags 0x%lx\n",
                      NegotiateMessage->NegotiateFlags ));
            goto Cleanup;
        }

        //
        // Client wants Sign capability, OK.
        //
        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;

            *ContextAttributes |= (ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT);
            Context->ContextFlags |= (ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT);

        }

        //
        // Client wants Seal, OK.
        //

        if (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;

            *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
            Context->ContextFlags |= ASC_RET_CONFIDENTIALITY;
        }

        if(NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;

        }

        if( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56) &&
            (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_56) )
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;
        }

        if( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) &&
            (NegotiateFlagsKeyStrength & NTLMSSP_NEGOTIATE_128) )
        {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;
        }


        //
        // If the client supplied the Domain Name and User Name,
        //  and did not request datagram, see if the client is running
        //  on this local machine.
        //

        if ( ( (NegotiateMessage->NegotiateFlags &
                NTLMSSP_NEGOTIATE_DATAGRAM) == 0) &&
             ( (NegotiateMessage->NegotiateFlags &
               (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED)) ==
               (NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED|
                NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) ) ) {

            //
            // The client must pass the new negotiate message if they pass
            // these flags
            //

            if (InputTokenSize < sizeof(NEGOTIATE_MESSAGE)) {
                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid InputTokenSize.\n" ));
                goto Cleanup;
            }

            //
            // Convert the names to absolute references so we
            // can compare them
            //

            if ( !SspConvertRelativeToAbsolute(
                NegotiateMessage,
                InputTokenSize,
                &NegotiateMessage->OemDomainName,
                &OemDomainName,
                FALSE,     // No special alignment
                FALSE ) ) { // NULL not OK

                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: Error from SspConvertRelativeToAbsolute.\n" ));
                goto Cleanup;
            }

            if ( !SspConvertRelativeToAbsolute(
                NegotiateMessage,
                InputTokenSize,
                &NegotiateMessage->OemWorkstationName,
                &OemWorkstationName,
                FALSE,     // No special alignment
                FALSE ) ) { // NULL not OK

                Status = SEC_E_INVALID_TOKEN;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: Error from SspConvertRelativeToAbsolute.\n" ));
                goto Cleanup;
            }

            //
            // If both strings match,
            // this is a local call.
            // The strings have already been uppercased.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if ( RtlEqualString( &OemWorkstationName,
                                 &NtLmGlobalOemComputerNameString,
                                 FALSE ) &&
                RtlEqualString( &OemDomainName,
                                 &NtLmGlobalOemPrimaryDomainNameString,
                                 FALSE )
                                 )
            {
#if DBG
                IF_DEBUG( NO_LOCAL ) {
                    // nothing.
                } else {
#endif
                    ChallengeMessage->NegotiateFlags |=
                        NTLMSSP_NEGOTIATE_LOCAL_CALL;
                    SspPrint(( SSP_MISC,
                        "SsprHandleNegotiateMessage: Local Call.\n" ));

                    ChallengeMessage->ServerContextHandle = (ULONG64)*ContextHandle;
#if DBG
                }
#endif
            }
            RtlReleaseResource (&NtLmGlobalCritSect);
        }

        //
        // Check if datagram is being negotiated
        //

        if ( (NegotiateMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) ==
                NTLMSSP_NEGOTIATE_DATAGRAM) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DATAGRAM;
        }

    } else {

        //
        // No negotiate message.  We need to check if the caller is asking
        // for datagram.
        //

        if ((ContextReqFlags & ASC_REQ_DATAGRAM) == 0 ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleNegotiateMessage: "
                      "NegotiateMessage size wrong %ld\n",
                      InputTokenSize ));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Allocate a Challenge message
        //


        //
        // always send target info -- new for NTLM3!
        //
        TargetFlags = NTLMSSP_NEGOTIATE_TARGET_INFO;

        ChallengeMessageSize = sizeof(*ChallengeMessage) + TargetInfo.Length;

        if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if ( ChallengeMessageSize > *OutputTokenSize ) {
                Status = SEC_E_BUFFER_TOO_SMALL;
                SspPrint(( SSP_CRITICAL,
                    "SsprHandleNegotiateMessage: invalid ChallengeMessageSize.\n" ));
                goto Cleanup;
            }
        }

        ChallengeMessage = (PCHALLENGE_MESSAGE)
                           NtLmAllocateLsaHeap(ChallengeMessageSize );

        if ( ChallengeMessage == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint(( SSP_CRITICAL,
                "SsprHandleNegotiateMessage: Error allocating ChallengeMessage.\n" ));
            goto Cleanup;
        }

        //
        // Record in the context that we are doing datagram.  We will tell
        // the client everything we can negotiate and let it decide what
        // to negotiate.
        //

        ChallengeMessage->NegotiateFlags = NTLMSSP_NEGOTIATE_DATAGRAM |
                                            NTLMSSP_NEGOTIATE_UNICODE |
                                            NTLMSSP_NEGOTIATE_OEM |
                                            NTLMSSP_NEGOTIATE_SIGN |
                                            NTLMSSP_NEGOTIATE_LM_KEY |
                                            NTLMSSP_NEGOTIATE_NTLM |
                                            NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                            NTLMSSP_NEGOTIATE_IDENTIFY |
                                            NTLMSSP_NEGOTIATE_NTLM2 |
                                            NTLMSSP_NEGOTIATE_KEY_EXCH |
                                            NegotiateFlagsKeyStrength
                                            ;

        if (NtLmGlobalEncryptionEnabled) {
            ChallengeMessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
        }

    }

    //
    // Build the Challenge Message
    //

    strcpy( (char *) ChallengeMessage->Signature, NTLMSSP_SIGNATURE );
    ChallengeMessage->MessageType = NtLmChallenge;
    Status = SspGenerateRandomBits( (UCHAR*)ChallengeMessage->Challenge,
                                    MSV1_0_CHALLENGE_LENGTH );
    if( !NT_SUCCESS( Status ) ) {
        SspPrint(( SSP_CRITICAL,
        "SsprHandleNegotiateMessage: SspGenerateRandomBits failed\n"));
        goto Cleanup;
    }

    Where = (PCHAR)(ChallengeMessage+1);

    SspContextCopyString( ChallengeMessage,
                          &ChallengeMessage->TargetName,
                          &TargetName,
                          &Where );

    SspContextCopyString( ChallengeMessage,
                          &ChallengeMessage->TargetInfo,
                          (PSTRING)&TargetInfo,
                          &Where );

    ChallengeMessage->NegotiateFlags |= TargetFlags;

    //
    // Save the Challenge and Negotiate Flags in the Context so it
    // is available when the authenticate message comes in.
    //

    RtlCopyMemory( Context->Challenge,
                   ChallengeMessage->Challenge,
                   sizeof( Context->Challenge ) );

    Context->NegotiateFlags = ChallengeMessage->NegotiateFlags;

    if (!SsprCheckMinimumSecurity(
                    Context->NegotiateFlags,
                    NtLmGlobalMinimumServerSecurity)) {

        Status = SEC_E_UNSUPPORTED_FUNCTION;
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleNegotiateMessage: "
                  "NegotiateMessage didn't support minimum security requirements. (caller=0x%lx wanted=0x%lx\n",
                   Context->NegotiateFlags, NtLmGlobalMinimumServerSecurity ));
        goto Cleanup;
    }


    if ((ContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        RtlCopyMemory( *OutputToken,
                   ChallengeMessage,
                   ChallengeMessageSize );

    }
    else
    {
        *OutputToken = ChallengeMessage;
        ChallengeMessage = NULL;
        *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
    }

    *OutputTokenSize = ChallengeMessageSize;

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );
    Context->State = ChallengeSentState;

    Status = SEC_I_CONTINUE_NEEDED;

    //
    // Free and locally used resources.
    //

Cleanup:

    if ( Context != NULL ) {

        //
        // If we failed, deallocate the context we allocated above.
        // Delinking is a side effect of referencing, so do that.
        //

        if ( !NT_SUCCESS(Status) ) {
            PSSP_CONTEXT LocalContext;

            SspContextReferenceContext( *ContextHandle,
                                        TRUE,
                                        &LocalContext
                                        );

            ASSERT( LocalContext != NULL );
            if ( LocalContext != NULL ) {
                SspContextDereferenceContext( LocalContext );
            }
        }

        // Always dereference it.

        SspContextDereferenceContext( Context );
    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( NegotiateMessage );
    }

    if ( ChallengeMessage != NULL ) {
        (VOID) NtLmFreeLsaHeap( ChallengeMessage );
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    if ( NtLmLocalUnicodeTargetName.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalUnicodeTargetName.Buffer );
    }

    if ( NtLmLocalOemTargetName.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( NtLmLocalOemTargetName.Buffer );
    }

    if (TargetInfo.Buffer != NULL ) {
        (VOID) NtLmFreePrivateHeap( TargetInfo.Buffer );
    }

    SspPrint(( SSP_API_MORE, "Leaving SsprHandleNegotiateMessage: 0x%lx\n", Status ));

    return Status;
}


NTSTATUS
SsprHandleAuthenticateMessage(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PLSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags,
    OUT PHANDLE TokenHandle,
    OUT PNTSTATUS ApiSubStatus,
    OUT PTimeStamp PasswordExpiry,
    OUT PULONG UserFlags
    )

/*++

Routine Description:

    Handle the authenticate message part of AcceptSecurityContext.

Arguments:

    SessionKey - The session key for the context, used for signing and sealing

    NegotiateFlags - The flags negotiated for the context, used for sign & seal

    ApiSubStatus - Returns the substatus for why the logon failed.

    PasswordExpiry - Contains the time that the authenticated user's password
        expires, or 0x7fffffff ffffffff for local callers.

    UserFlags - UserFlags returned in LogonProfile.

    All other arguments same as for AcceptSecurityContext


Return Value:

    STATUS_SUCCESS - Message handled

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PSSP_CONTEXT Context = NULL;

    PNEGOTIATE_MESSAGE NegotiateMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    PNTLM_AUTHENTICATE_MESSAGE NtLmAuthenticateMessage = NULL;
    PNTLM_ACCEPT_RESPONSE NtLmAcceptResponse = NULL;
    ULONG MsvLogonMessageSize = 0;
    PMSV1_0_LM20_LOGON MsvLogonMessage = NULL;
    ULONG MsvSubAuthLogonMessageSize = 0;
    PMSV1_0_SUBAUTH_LOGON MsvSubAuthLogonMessage = NULL;
    ULONG LogonProfileMessageSize;
    PMSV1_0_LM20_LOGON_PROFILE LogonProfileMessage = NULL;

    BOOLEAN DoUnicode = FALSE;
    STRING DomainName2;
    STRING UserName2;
    STRING Workstation2;
    STRING SessionKeyString;
    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    LARGE_INTEGER KickOffTime;

    LUID LogonId = {0};
    HANDLE LocalTokenHandle = NULL;
    BOOLEAN LocalTokenHandleOpenned = FALSE;
    TOKEN_SOURCE SourceContext;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    STRING OriginName;
    PCHAR Where;
    UCHAR LocalSessionKey[LM_RESPONSE_LENGTH];
    PSSP_CREDENTIAL Credential = NULL;
    BOOLEAN fCallFromSrv = FALSE;
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthenticatingAuthority = NULL;
    PUNICODE_STRING WorkstationName = NULL;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
    BOOL fSubAuth = FALSE;
    ULONG SubAuthPackageId = 0;
    PSID AllocatedAuditSid = NULL ;
    PSID AuditSid = NULL;
    BOOLEAN fAvoidGuestAudit = FALSE;
    SECPKG_PRIMARY_CRED PrimaryCredentials;

    //Tracing State
    NTLM_TRACE_INFO TraceInfo = {0};
    PLSA_SEC_HANDLE TraceOldContextHandle = ContextHandle;

    ASSERT(LM_RESPONSE_LENGTH >= MSV1_0_USER_SESSION_KEY_LENGTH);

    SspPrint(( SSP_API_MORE, "Entering SsprHandleAuthenticateMessage\n"));
    //
    // Initialization
    //

    *ContextAttributes = 0;
    RtlInitUnicodeString(
        &DomainName,
        NULL
        );
    RtlInitUnicodeString(
        &UserName,
        NULL
        );
    RtlInitUnicodeString(
        &Workstation,
        NULL
        );
    *ApiSubStatus = STATUS_SUCCESS;
    PasswordExpiry->LowPart = 0xffffffff;
    PasswordExpiry->HighPart = 0x7fffffff;
    *UserFlags = 0;


    RtlZeroMemory(&PrimaryCredentials, sizeof(SECPKG_PRIMARY_CRED));

    if (*ContextHandle == NULL)
    {
        // This is possibly an old style srv call (for 4.0 and before)
        // so, alloc the context and replace the creds if new ones exists

        fCallFromSrv = TRUE;

        SspPrint((SSP_API_MORE, "SsprHandleAuthenticateMessage: *ContextHandle is NULL (old style SRV)\n"));

        SECPKG_CALL_INFO CallInfo = {0};

        //
        // Client must have TCB, otherwise an un-trusted LSA-client could use a
        // stolen challenge/response pair to network logon any user
        //

        if ( !LsaFunctions->GetCallInfo( &CallInfo ) ||
            ((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0)
            )
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            SspPrint((SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: Client does not hold Tcb\n"));
            goto Cleanup;
        }

        SecStatus = SspCredentialReferenceCredential(
                                          CredentialHandle,
                                          FALSE,
                                          &Credential );

        if ( !NT_SUCCESS( SecStatus ) )
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: SspCredentialReferenceCredential returns %x.\n", SecStatus ));
            goto Cleanup;
        }

        // check the validity of the NtlmAuthenticateMessage

        if (SecondInputTokenSize < sizeof(NTLM_AUTHENTICATE_MESSAGE))
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: NtlmAuthenticateMessage size if bogus.\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;

        }

        // This is a  superflous check since we alloc only if the caller
        // has asked us too. This is to make sure that the srv always allocs

        if (ContextReqFlags  & ISC_REQ_ALLOCATE_MEMORY)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: ContextReqFlags has ISC_REQ_ALLOCATE_MEMORY.\n" ));
            SecStatus = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        if (*OutputTokenSize < sizeof(NTLM_ACCEPT_RESPONSE))
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: NtlmAcceptResponse size if bogus.\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Allocate a new context
        //

        Context = SspContextAllocateContext();

        if (Context == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: SspContextAllocateContext returns NULL.\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // We've just added a context, we don't nornally add and then
        // reference it.

        SspContextDereferenceContext( Context );

        *ContextHandle = (LSA_SEC_HANDLE) Context;

        // Assign the Credential

        Context->Credential = Credential;
        Credential = NULL;

        NtLmAuthenticateMessage = (PNTLM_AUTHENTICATE_MESSAGE) SecondInputToken;
        if (NtLmAuthenticateMessage == NULL)
        {
            SspPrint(( SSP_CRITICAL,
                "SsprHandleAuthenticateMessage: Error while assigning NtLmAuthenticateMessage\n" ));
            SecStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // copy challenge from NTLM_AUTHENTICATE_MESSAGE
        RtlCopyMemory(Context->Challenge,
                      NtLmAuthenticateMessage->ChallengeToClient,
                      MSV1_0_CHALLENGE_LENGTH);

        if (NtLmAuthenticateMessage->ParameterControl & MSV1_0_SUBAUTHENTICATION_FLAGS)
        {
            fSubAuth = TRUE;
            SubAuthPackageId = (NtLmAuthenticateMessage->ParameterControl >>
                                MSV1_0_SUBAUTHENTICATION_DLL_SHIFT)
                                ;
        }
        Context->State = ChallengeSentState;
        Context->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE ;

        //
        // The server may request this option with a <= 4.0 client, in
        // which case HandleNegotiateMessage, which normally sets
        // this flag, won't have been called.
        //

        if ( (ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) != 0) {

            *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
            Context->ContextFlags |= ASC_RET_ALLOW_NON_USER_LOGONS;
        }


    }

    //
    // Find the currently existing context.
    //

    SecStatus = SspContextReferenceContext( *ContextHandle, FALSE, &Context );

    if ( !NT_SUCCESS(SecStatus) )
    {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error from SspContextReferenceContext.\n" ));

        goto Cleanup;
    }


    if ( ( Context->State != ChallengeSentState) &&
         ( Context->State != AuthenticatedState) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "Context not in ChallengeSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    // the credential is implied by the Context.
    // We could double check that the Credential Handle is either NULL or
    // correct.  However, our implementation doesn't maintain a close
    // association between the two (actually no association) so checking
    // would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    //
    // Get the AuthenticateMessage.
    //

    if ( InputTokenSize < sizeof(OLD_AUTHENTICATE_MESSAGE) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    SecStatus = SspContextGetMessage( InputToken,
                                      InputTokenSize,
                                      NtLmAuthenticate,
                                      (PVOID *)&AuthenticateMessage );

    if ( !NT_SUCCESS(SecStatus) ) {
        SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage GetMessage returns 0x%lx\n",
                  SecStatus ));
        goto Cleanup;
    }

    if (fCallFromSrv)
    {
        // Copy the Context Negotiate Flags from what's sent in
        Context->NegotiateFlags |= AuthenticateMessage->NegotiateFlags;
    }
    //
    // If the call comes and we have already authenticated, then it is
    // probably RPC trying to reauthenticate, which happens when someone
    // calls two interfaces on the same connection.  In this case we don't
    // have to do anything - we just return success and let them get on
    // with it.  We do want to check that the input token is all zeros,
    // though.
    //

    if ( Context->State == AuthenticatedState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        *OutputTokenSize = 0;

        //
        // Check that all the fields are null.  There are 5 strings
        // in the Authenticate message that have to be set to zero.
        //

        RtlZeroMemory(&NullMessage.LmChallengeResponse,5*sizeof(STRING32));

        if (memcmp(&AuthenticateMessage->LmChallengeResponse,
                   &NullMessage.LmChallengeResponse,
                   sizeof(STRING32) * 5) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "AuthenticateMessage->LmChallengeResponse is not zeroed\n"));
        }
        else
        {
            *ContextAttributes = SSP_RET_REAUTHENTICATION;
            SecStatus = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // If we are re-establishing a datagram context, get the negotiate flags
    // out of this message.
    //

    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) {

        if ((InputTokenSize < sizeof(AUTHENTICATE_MESSAGE)) ||
            ((AuthenticateMessage->NegotiateFlags &
              NTLMSSP_NEGOTIATE_DATAGRAM) == 0) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        Context->NegotiateFlags = AuthenticateMessage->NegotiateFlags;

        //
        // always do key exchange with datagram if we need a key (for SIGN or SEAL)
        //

        if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL))
        {
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;
        }

        //
        // if got NTLM2, don't use LM_KEY
        //

        if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0 )
        {
            if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
                SspPrint(( SSP_NEGOTIATE_FLAGS,
                      "SsprHandleAuthenticateMessage: "
                      "AuthenticateMessage (datagram) NTLM2 caused LM_KEY to be disabled.\n" ));
            }

            Context->NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
        }

    }


    //
    // Check that client asked for minimum security required.
    // not done for legacy down-level case, as, NegotiateFlags are
    // constructed from incomplete information.
    //

    if( !fCallFromSrv )
    {
        if (!SsprCheckMinimumSecurity(
                    AuthenticateMessage->NegotiateFlags,
                    NtLmGlobalMinimumServerSecurity)) {

            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "client didn't support minimum security requirements.\n" ));
            goto Cleanup;
        }

    }

    //
    // Convert relative pointers to absolute.
    //

    DoUnicode = ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) != 0;

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->LmChallengeResponse,
                                      (PSTRING) &LmChallengeResponse,
                                      FALSE,     // No special alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->NtChallengeResponse,
                                      (PSTRING) &NtChallengeResponse,
                                      FALSE,     // No special alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!SspConvertRelativeToAbsolute(AuthenticateMessage,
                                      InputTokenSize,
                                      &AuthenticateMessage->DomainName,
                                      &DomainName2,
                                      DoUnicode, // Unicode alignment
                                      TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                        InputTokenSize,
                                        &AuthenticateMessage->UserName,
                                        &UserName2,
                                        DoUnicode, // Unicode alignment
#ifdef notdef

        //
        // Allow null sessions.  The server should guard against them if
        // it doesn't want them.
        //
                                        FALSE )) { // User name cannot be NULL

#endif // notdef
                                        TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                        InputTokenSize,
                                        &AuthenticateMessage->Workstation,
                                        &Workstation2,
                                        DoUnicode, // Unicode alignment
                                        TRUE ) ) { // NULL OK
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // If this is datagram, get the session key
    //

///    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) {
    if ((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) != 0) {

        if ( !SspConvertRelativeToAbsolute( AuthenticateMessage,
                                            InputTokenSize,
                                            &AuthenticateMessage->SessionKey,
                                            &SessionKeyString,
                                            FALSE, // No special alignment
                                            TRUE) ) { // NULL OK
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // It should be NULL if this is a local call
        //

        if (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL) == 0) &&
            (SessionKeyString.Buffer == NULL)) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if(Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL)
        {
            static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                        'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                        'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                        };

            RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        }

    }

    //
    // Convert the domainname/user name/workstation to the right character set.
    //

    if ( DoUnicode ) {

        DomainName = *((PUNICODE_STRING) &DomainName2);
        UserName = *((PUNICODE_STRING) &UserName2);
        Workstation = *((PUNICODE_STRING) &Workstation2);

    } else {

        SspPrint(( SSP_API_MORE, "SsprHandleAuthenticateMessage: Not doing Unicode\n"));
        Status = RtlOemStringToUnicodeString(
                    &DomainName,
                    &DomainName2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

        Status = RtlOemStringToUnicodeString(
                    &UserName,
                    &UserName2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

        Status = RtlOemStringToUnicodeString(
                    &Workstation,
                    &Workstation2,
                    TRUE);

        if ( !NT_SUCCESS(Status) ) {
            SecStatus = SspNtStatusToSecStatus( Status,
                                                SEC_E_INSUFFICIENT_MEMORY );
            goto Cleanup;
        }

    }

    //
    // Trace the username, domain name and workstation
    //
    if (NtlmGlobalEventTraceFlag){

        //Header goo
        SET_TRACE_HEADER(TraceInfo,
                         NtlmAcceptGuid,
                         EVENT_TRACE_TYPE_INFO,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         10);

        int TraceHint = TRACE_ACCEPT_INFO;
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STAGEHINT,
                        TraceHint);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_INCONTEXT,
                        TraceOldContextHandle);

        SET_TRACE_DATAPTR(TraceInfo,
                        TRACE_INITACC_OUTCONTEXT,
                        ContextHandle);

        // lets see the negotiate flags here
        SET_TRACE_DATA(TraceInfo,
                        TRACE_INITACC_STATUS,
                        Context->NegotiateFlags);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_CLIENTNAME,
                          UserName);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_CLIENTDOMAIN,
                          DomainName);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_INITACC_WORKSTATION,
                          Workstation);

        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }


    //
    // If the client is on the same machine as we are, just
    // use the token the client has already placed in our context structure,
    //

    if ( (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL ) &&
         Context->TokenHandle != NULL &&
         DomainName.Length == 0 &&
         UserName.Length == 0 &&
         Workstation.Length == 0 &&
         AuthenticateMessage->NtChallengeResponse.Length == 0 &&
         AuthenticateMessage->LmChallengeResponse.Length == 0 )
    {


        static const UCHAR FixedSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH] = {
                                    'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                    'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                    };

        LocalTokenHandle = Context->TokenHandle;
        Context->TokenHandle = NULL;

        KickOffTime.HighPart = 0x7FFFFFFF;
        KickOffTime.LowPart = 0xFFFFFFFF;

        RtlCopyMemory(Context->SessionKey, FixedSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        SspPrint(( SSP_MISC, "SsprHandleAuthenticateMessage: Local Call\n"));

        if( (ContextReqFlags & ASC_REQ_DELEGATE) )
        {
            //
            // can support another hop if loopback.
            //

            *ContextAttributes |= ASC_RET_DELEGATE;
            Context->ContextFlags |= ASC_RET_DELEGATE;
        }

    //
    // If the client is on a different machine than we are,
    //  use LsaLogonUser to create a token for the client.
    //

    } else {

        //
        //  Store user name and domain name
        //

        SecStatus = NtLmDuplicateUnicodeString(
                          &Context->UserName,
                          &UserName);
        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }

        SecStatus = NtLmDuplicateUnicodeString(
                          &Context->DomainName,
                          &DomainName);
        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }


        //
        // Allocate an MSV1_0 network logon message
        //

        if (!fSubAuth)
        {

            //
            // The string buffers may be used as structure pointers later on.
            // Align them to pointer boundaries to avoid alignment problems.
            //

            MsvLogonMessageSize =
                ROUND_UP_COUNT(sizeof(*MsvLogonMessage) +
                               DomainName.Length +
                               UserName.Length +
                               Workstation.Length, ALIGN_LPVOID) +
                ROUND_UP_COUNT(AuthenticateMessage->NtChallengeResponse.Length, ALIGN_LPVOID) +
                AuthenticateMessage->LmChallengeResponse.Length;

            MsvLogonMessage = (PMSV1_0_LM20_LOGON)
                          NtLmAllocatePrivateHeap(MsvLogonMessageSize );

            if ( MsvLogonMessage == NULL ) {
                SecStatus = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error allocating MsvLogonMessage"));
                goto Cleanup;
            }

            //
            // Build the MSV1_0 network logon message to pass to the LSA.
            //

            MsvLogonMessage->MessageType = MsV1_0NetworkLogon;

            Where = (PCHAR)(MsvLogonMessage+1);

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->LogonDomainName,
                              (PSTRING)&DomainName,
                              &Where );

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->UserName,
                              (PSTRING)&UserName,
                              &Where );

            SspContextCopyStringAbsolute( MsvLogonMessage,
                              (PSTRING)&MsvLogonMessage->Workstation,
                              (PSTRING)&Workstation,
                              &Where );

            RtlCopyMemory( MsvLogonMessage->ChallengeToClient,
                       Context->Challenge,
                       sizeof( MsvLogonMessage->ChallengeToClient ) );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute( MsvLogonMessage,
                              &MsvLogonMessage->CaseSensitiveChallengeResponse,
                              &NtChallengeResponse,
                              &Where );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute(MsvLogonMessage,
                             &MsvLogonMessage->CaseInsensitiveChallengeResponse,
                             &LmChallengeResponse,
                             &Where );

            MsvLogonMessage->ParameterControl = MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT;

            // This is required by the pre 4.0 server
            if (fCallFromSrv)
            {
                MsvLogonMessage->ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED | NtLmAuthenticateMessage->ParameterControl;

                if ( (Context->ContextFlags & ASC_RET_ALLOW_NON_USER_LOGONS ) != 0)
                {
                    MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
                }
            } else {
                MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
            }

            //
            // Get the profile path for EFS
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_RETURN_PROFILE_PATH;

            //
            // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
            // expiration time is returned in the logoff time
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_RETURN_PASSWORD_EXPIRY;

            //
            // for Personal easy file/print sharing, hint to LsaLogonUser
            // that Forced Guest may occur.
            //

            MsvLogonMessage->ParameterControl |= MSV1_0_ALLOW_FORCE_GUEST;
        }
        else
        {

            MsvSubAuthLogonMessageSize =
                ROUND_UP_COUNT(sizeof(*MsvSubAuthLogonMessage) +
                               DomainName.Length +
                               UserName.Length +
                               Workstation.Length, ALIGN_LPVOID) +
                ROUND_UP_COUNT(AuthenticateMessage->NtChallengeResponse.Length, ALIGN_LPVOID) +
                AuthenticateMessage->LmChallengeResponse.Length;

            MsvSubAuthLogonMessage = (PMSV1_0_SUBAUTH_LOGON)
                          NtLmAllocatePrivateHeap(MsvSubAuthLogonMessageSize );

            if ( MsvSubAuthLogonMessage == NULL ) {
                SecStatus = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: Error allocating MsvSubAuthLogonMessage"));
                goto Cleanup;
            }

            //
            // Build the MSV1_0 subauth logon message to pass to the LSA.
            //

            MsvSubAuthLogonMessage->MessageType = MsV1_0SubAuthLogon;

            Where = (PCHAR)(MsvSubAuthLogonMessage+1);

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->LogonDomainName,
                              (PSTRING)&DomainName,
                              &Where );

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->UserName,
                              (PSTRING)&UserName,
                              &Where );

            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              (PSTRING)&MsvSubAuthLogonMessage->Workstation,
                              (PSTRING)&Workstation,
                              &Where );

            RtlCopyMemory( MsvSubAuthLogonMessage->ChallengeToClient,
                       Context->Challenge,
                       sizeof( MsvSubAuthLogonMessage->ChallengeToClient ) );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute( MsvSubAuthLogonMessage,
                              &MsvSubAuthLogonMessage->AuthenticationInfo1,
                              &LmChallengeResponse,
                              &Where );

            Where = (PCHAR) ROUND_UP_POINTER(Where, ALIGN_LPVOID);
            SspContextCopyStringAbsolute(MsvSubAuthLogonMessage,
                             &MsvSubAuthLogonMessage->AuthenticationInfo2,
                             &NtChallengeResponse,
                             &Where );

            MsvSubAuthLogonMessage->ParameterControl = MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT;

            MsvSubAuthLogonMessage->SubAuthPackageId = SubAuthPackageId;

            // This is required by the pre 4.0 server
            if (fCallFromSrv)
            {
                MsvSubAuthLogonMessage->ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED | NtLmAuthenticateMessage->ParameterControl;
            }

            if ( (Context->ContextFlags & ASC_RET_ALLOW_NON_USER_LOGONS ) != 0) {
                MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;
            }

            //
            // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
            // expiration time is returned in the logoff time
            //

            MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_RETURN_PASSWORD_EXPIRY;

            //
            // for Personal easy file/print sharing, hint to LsaLogonUser
            // that Forced Guest may occur.
            //

            MsvSubAuthLogonMessage->ParameterControl |= MSV1_0_ALLOW_FORCE_GUEST;
        }


        //
        // if NTLM2 is negotiated, then mix my challenge with the client's...
        // But, special case for null sessions. since we already negotiated
        // NTLM2, but the LmChallengeResponse field is actually used
        // here. REVIEW -- maybe don't negotiate NTLM2 if NULL session
        //

        if((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)  &&
           (AuthenticateMessage->LmChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH))
        {
            MsvLogonMessage->ParameterControl |= MSV1_0_USE_CLIENT_CHALLENGE;
        }


        //
        // Log this user on.
        //

        // No origin (could use F(workstaion))

        RtlInitString( &OriginName, NULL );

        strncpy( SourceContext.SourceName,
                 "NtLmSsp ",
                 sizeof(SourceContext.SourceName) );

        RtlZeroMemory( &SourceContext.SourceIdentifier,
                       sizeof(SourceContext.SourceIdentifier) );

        {
            PVOID TokenInformation;
            LSA_TOKEN_INFORMATION_TYPE TokenInformationType;
            LSA_TOKEN_INFORMATION_TYPE OriginalTokenType;
            PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials = NULL;
            PPRIVILEGE_SET PrivilegesAssigned = NULL;

            if (!fSubAuth)
            {
                Status = LsaApLogonUserEx2(
                    (PLSA_CLIENT_REQUEST) (-1),
                    Network,
                    MsvLogonMessage,
                    MsvLogonMessage,
                    MsvLogonMessageSize,
                    (PVOID *) &LogonProfileMessage,
                    &LogonProfileMessageSize,
                    &LogonId,
                    &SubStatus,
                    &TokenInformationType,
                    &TokenInformation,
                    &AccountName,
                    &AuthenticatingAuthority,
                    &WorkstationName,
                    &PrimaryCredentials,
                    &Credentials
                    );
            }
            else
            {
                Status = LsaApLogonUserEx2(
                    (PLSA_CLIENT_REQUEST) (-1),
                    Network,
                    MsvSubAuthLogonMessage,
                    MsvSubAuthLogonMessage,
                    MsvSubAuthLogonMessageSize,
                    (PVOID *) &LogonProfileMessage,
                    &LogonProfileMessageSize,
                    &LogonId,
                    &SubStatus,
                    &TokenInformationType,
                    &TokenInformation,
                    &AccountName,
                    &AuthenticatingAuthority,
                    &WorkstationName,
                    &PrimaryCredentials,
                    &Credentials
                    );
            }

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "LsaApLogonUserEx2 returns 0x%lx for context 0x%x\n",
                      Status, Context ));
            SecStatus = SspNtStatusToSecStatus( Status, SEC_E_LOGON_DENIED );
            if (Status == STATUS_PASSWORD_MUST_CHANGE) {
                *ApiSubStatus = Status;
            }
            else if (Status == STATUS_ACCOUNT_RESTRICTION) {
                *ApiSubStatus = SubStatus;
            } else {
                *ApiSubStatus = Status;
            }

            goto Cleanup;
        }

        if ( !NT_SUCCESS(SubStatus) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "LsaApLogonUserEx2 returns SubStatus of 0x%lx\n",
                      SubStatus ));
            SecStatus = SspNtStatusToSecStatus( SubStatus, SEC_E_LOGON_DENIED );
            goto Cleanup;
        }

        //
        // Check if this was a null session. The TokenInformationType will
        // be LsaTokenInformationNull if it is. If so, we may need to fail
        // the logon.
        //

        if (TokenInformationType == LsaTokenInformationNull)
        {

//
// RESTRICT_NULL_SESSIONS deemed too risky because legacy behavior of package
// allows null sessions from SYSTEM.
//

#ifdef RESTRICT_NULL_SESSIONS
            if ((Context->ContextFlags & ASC_REQ_ALLOW_NULL_SESSION) == 0) {
                SspPrint(( SSP_CRITICAL,
                           "SsprHandleAuthenticateMessage: "
                           "Null session logon attempted but not allowed\n" ));
                SecStatus = SEC_E_LOGON_DENIED;
                goto Cleanup;
            }
#endif
            *ContextAttributes |= ASC_RET_NULL_SESSION;
            Context->ContextFlags |= ASC_RET_NULL_SESSION;
            Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_NULL_SESSION;

            AuditSid = NtLmGlobalAnonymousSid;
        }
        else
        {
            PLSA_TOKEN_INFORMATION_V2 TokenInfoV2 ;

            TokenInfoV2 = (PLSA_TOKEN_INFORMATION_V2) TokenInformation ;

            SafeAllocaAllocate( AllocatedAuditSid, RtlLengthSid( TokenInfoV2->User.User.Sid ) );

            if ( AllocatedAuditSid )
            {

                RtlCopyMemory( AllocatedAuditSid,
                               TokenInfoV2->User.User.Sid,
                               RtlLengthSid( TokenInfoV2->User.User.Sid ) );

            }

            AuditSid = AllocatedAuditSid;
        }


        Status = LsaFunctions->CreateTokenEx(
                    &LogonId,
                    &SourceContext,
                    Network,
                    (((Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) != 0) ?
                        SecurityIdentification : SecurityImpersonation),
                    TokenInformationType,
                    TokenInformation,
                    NULL,
                    WorkstationName,
                    ((LogonProfileMessage->UserFlags & LOGON_PROFILE_PATH_RETURNED) != 0) ? &LogonProfileMessage->UserParameters : NULL,
                    &PrimaryCredentials,
                    SecSessionPrimaryCred,
                    &LocalTokenHandle,
                    &SubStatus);


        }  // end of block for LsaLogonUser

        if ( !NT_SUCCESS(Status) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "CreateToken returns 0x%lx\n",
                      Status ));
            SecStatus = Status;
            goto Cleanup;
        }

        if ( !NT_SUCCESS(SubStatus) ) {
            SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "CreateToken returns SubStatus of 0x%lx\n",
                      SubStatus ));
            SecStatus = SubStatus;
            goto Cleanup;
        }

        LocalTokenHandleOpenned = TRUE;

        //
        // Don't allow cleartext password on the logon.
        // Except if called from Downlevel

        if (!fCallFromSrv)
        {
            if ( LogonProfileMessage->UserFlags & LOGON_NOENCRYPTION ) {
                SspPrint(( SSP_CRITICAL,
                      "SsprHandleAuthenticateMessage: "
                      "LsaLogonUser used cleartext password\n" ));
                SecStatus = SEC_E_LOGON_DENIED;
                goto Cleanup;

            }
        }

        //
        // If we did a guest logon, set the substatus to be STATUS_NO_SUCH_USER
        //

        if ( LogonProfileMessage->UserFlags & LOGON_GUEST ) {
            fAvoidGuestAudit = TRUE;
            *ApiSubStatus = STATUS_NO_SUCH_USER;

#if 0
            //
            // If caller required Sign/Seal, fail them here
            //
            if (
                (!NtLmGlobalForceGuest) &&
                (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
                )
            {
                SspPrint(( SSP_CRITICAL,
                     "SsprHandleAuthenticateMessage: "
                      "LsaLogonUser logged user as a guest but seal is requested\n" ));
                SecStatus = SEC_E_LOGON_DENIED;
                goto Cleanup;
            }
#endif


        }

        //
        // Save important information about the caller.
        //

        KickOffTime = LogonProfileMessage->KickOffTime;

        //
        // By passing in the RETURN_PASSWORD_EXPIRY flag, the password
        // expiration time is returned in the logoff time
        //

        *PasswordExpiry = LogonProfileMessage->LogoffTime;
        *UserFlags = LogonProfileMessage->UserFlags;

        //
        // set the session key to what the client sent us (if anything)
        //

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH &&
            AuthenticateMessage->SessionKey.Length == MSV1_0_USER_SESSION_KEY_LENGTH)
        {
            RtlCopyMemory(
                Context->SessionKey,
                SessionKeyString.Buffer,
                MSV1_0_USER_SESSION_KEY_LENGTH
                );
        }

        //
        // Generate the session key, or decrypt the generated random one sent to
        // us by the client, from various bits of info
        //

        SecStatus = SsprMakeSessionKey(
                            Context,
                            &LmChallengeResponse,
                            LogonProfileMessage->UserSessionKey,
                            LogonProfileMessage->LanmanSessionKey,
                            NULL
                            );

        if ( !NT_SUCCESS(SecStatus) ) {
            SspPrint(( SSP_CRITICAL,
                  "SsprHandleAuthenticateMessage: "
                  "SsprMakeSessionKey failed.\n" ));
            goto Cleanup;
        }

    }

    //
    // Copy the logon domain name returned by the LSA if it is different.
    // from the one the caller passed in. This may happen with temp duplicate
    // accounts and local account
    //

    if ((LogonProfileMessage != NULL) &&
        (LogonProfileMessage->LogonDomainName.Length != 0) &&
        !RtlEqualUnicodeString(
                    &Context->DomainName,
                    &LogonProfileMessage->LogonDomainName,
                    TRUE               // case insensitive
                    )) {
        //
        // erase the old domain name
        //

        if (Context->DomainName.Buffer != NULL) {
            NtLmFreePrivateHeap(Context->DomainName.Buffer);
            Context->DomainName.Buffer = NULL;
        }

        SecStatus = NtLmDuplicateUnicodeString(
                        &Context->DomainName,
                        &LogonProfileMessage->LogonDomainName
                        );

        if (!NT_SUCCESS(SecStatus)) {
            goto Cleanup;
        }

    }

    //
    // Allow the context to live until kickoff time.
    //

    SspContextSetTimeStamp( Context, KickOffTime );

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    //
    // Return output token
    //

    if (fCallFromSrv)
    {
        NtLmAcceptResponse = (PNTLM_ACCEPT_RESPONSE) *OutputToken;
        if (NtLmAcceptResponse == NULL)
        {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }

        LUID UNALIGNED * TempLogonId = (LUID UNALIGNED *) &NtLmAcceptResponse->LogonId;
        *TempLogonId = LogonId;
        NtLmAcceptResponse->UserFlags = LogonProfileMessage->UserFlags;

        RtlCopyMemory(
            NtLmAcceptResponse->UserSessionKey,
            LogonProfileMessage->UserSessionKey,
            MSV1_0_USER_SESSION_KEY_LENGTH
            );

        RtlCopyMemory(
            NtLmAcceptResponse->LanmanSessionKey,
            LogonProfileMessage->LanmanSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

        LARGE_INTEGER UNALIGNED *TempKickoffTime = (LARGE_INTEGER UNALIGNED *) &NtLmAcceptResponse->KickoffTime;
        *TempKickoffTime = LogonProfileMessage->KickOffTime;

    }
    else
    {
        *OutputTokenSize = 0;
    }


    //
    // We don't support sign/seal options if fallback to Guest
    // this is because the client and server won't have a matched session-key
    // AND even if they did match (ie: blank password), the session-key
    // would likely be well-known.
    //

    if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN ) {
        *ContextAttributes |= ASC_RET_REPLAY_DETECT |
                              ASC_RET_SEQUENCE_DETECT |
                              ASC_RET_INTEGRITY;
    }

    if( !fAvoidGuestAudit )
    {
        if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL ) {
            *ContextAttributes |= ASC_RET_CONFIDENTIALITY;
        }
    }

    if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY ) {
        *ContextAttributes |= ASC_RET_IDENTIFY;
    }

    if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM ) {
        *ContextAttributes |= ASC_RET_DATAGRAM;
    }

    if ( ContextReqFlags & ASC_REQ_REPLAY_DETECT ) {
        *ContextAttributes |= ASC_RET_REPLAY_DETECT;
    }

    if ( ContextReqFlags & ASC_REQ_SEQUENCE_DETECT ) {
        *ContextAttributes |= ASC_RET_SEQUENCE_DETECT;
    }

    if ( ContextReqFlags & ASC_REQ_ALLOW_NON_USER_LOGONS ) {
        *ContextAttributes |= ASC_RET_ALLOW_NON_USER_LOGONS;
    }


    SecStatus = STATUS_SUCCESS;

    //
    // Free and locally used resources.
    //

Cleanup:

    //
    // Audit this logon
    //

    if (NT_SUCCESS(SecStatus)) {

        //
        // If we don't have an account name, this was a local connection
        // and we didn't build a new token, so don't bother auditing.
        // also, don't bother auditing logons that fellback to guest.
        //

        if ( (AccountName != NULL) &&
             ((AccountName->Length != 0) || (*ContextAttributes & ASC_RET_NULL_SESSION)) &&
              !fAvoidGuestAudit ) {

            LsaFunctions->AuditLogon(
                STATUS_SUCCESS,
                STATUS_SUCCESS,
                AccountName,
                AuthenticatingAuthority,
                WorkstationName,
                AuditSid,
                Network,
                &SourceContext,
                &LogonId
                );
        }
    } else {
        LsaFunctions->AuditLogon(
            !NT_SUCCESS(Status) ? Status : SecStatus,
            SubStatus,
            &UserName,
            &DomainName,
            &Workstation,
            NULL,
            Network,
            &SourceContext,
            &LogonId
            );

    }

    if ( Context != NULL ) {

        Context->Server = TRUE;
        Context->LastStatus = SecStatus;
        Context->DownLevel = fCallFromSrv;


        //
        // Don't allow this context to be used again.
        //

        if ( NT_SUCCESS(SecStatus) ) {
            Context->State = AuthenticatedState;

            if ( LocalTokenHandle ) {
                *TokenHandle = LocalTokenHandle;
            }

            LocalTokenHandle = NULL;

            RtlCopyMemory(
                SessionKey,
                Context->SessionKey,
                MSV1_0_USER_SESSION_KEY_LENGTH );

            *NegotiateFlags = Context->NegotiateFlags;

            //
            // if caller wants only INTEGRITY, then wants application
            // supplied sequence numbers...
            //

            if ((Context->ContextFlags &
                (ASC_REQ_INTEGRITY | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT)) ==
                ASC_REQ_INTEGRITY)
            {
                *NegotiateFlags |= NTLMSSP_APP_SEQ;
            }

        } else {
            Context->State = IdleState;
        }

        // If we just created this context, then we need to dereference it
        // once more with feeling

        if (fCallFromSrv && !NT_SUCCESS(SecStatus))
        {
            PSSP_CONTEXT LocalContext;
            SspContextReferenceContext (*ContextHandle, TRUE, &LocalContext);
            ASSERT (LocalContext != NULL);
            if (LocalContext != NULL)
            {
                SspContextDereferenceContext( LocalContext );
            }

        }
        SspContextDereferenceContext( Context );

    }

    if ( NegotiateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( NegotiateMessage );
    }

    if ( AuthenticateMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( AuthenticateMessage );
    }

    if ( MsvLogonMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( MsvLogonMessage );
    }

    if ( MsvSubAuthLogonMessage != NULL ) {
        (VOID) NtLmFreePrivateHeap( MsvSubAuthLogonMessage );
    }


    if ( LogonProfileMessage != NULL ) {
        (VOID) LsaFunctions->FreeLsaHeap( LogonProfileMessage );
    }

    if ( LocalTokenHandle != NULL && LocalTokenHandleOpenned ) {
        (VOID) NtClose( LocalTokenHandle );
    }

    if ( !DoUnicode ) {
        if ( DomainName.Buffer != NULL) {
            RtlFreeUnicodeString( &DomainName );
        }
        if ( UserName.Buffer != NULL) {
            RtlFreeUnicodeString( &UserName );
        }
        if ( Workstation.Buffer != NULL) {
            RtlFreeUnicodeString( &Workstation );
        }
    }

    if (AccountName != NULL) {
        if (AccountName->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(AccountName->Buffer);
        }
        LsaFunctions->FreeLsaHeap(AccountName);
    }
    if (AuthenticatingAuthority != NULL) {
        if (AuthenticatingAuthority->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(AuthenticatingAuthority->Buffer);
        }
        LsaFunctions->FreeLsaHeap(AuthenticatingAuthority);
    }
    if (WorkstationName != NULL) {
        if (WorkstationName->Buffer != NULL) {
            LsaFunctions->FreeLsaHeap(WorkstationName->Buffer);
        }
        LsaFunctions->FreeLsaHeap(WorkstationName);
    }

    if ( AllocatedAuditSid )
    {
        SafeAllocaFree( AllocatedAuditSid );
    }

    //
    // need to free the PrimaryCredentials fields filled in by LsaApLogonUserEx2
    //

    if( PrimaryCredentials.DownlevelName.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
    }

    if( PrimaryCredentials.DomainName.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
    }

    if( PrimaryCredentials.UserSid )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    }

    if( PrimaryCredentials.LogonServer.Buffer )
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }


    //
    // Set a flag telling RPC not to destroy the connection yet
    //

    if (!NT_SUCCESS(SecStatus)) {
        *ContextAttributes |= ASC_RET_THIRD_LEG_FAILED;
    }


    SspPrint(( SSP_API_MORE, "Leaving SsprHandleAutheticateMessage: 0x%lx\n", SecStatus ));
    return SecStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

    03-Aug-1996 ChandanS
        Stolen from net\svcdlls\ntlmssp\debug.h
--*/

//
// init.c will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef DEBUG_ALLOCATE
#undef EXTERN
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT            0x00000001  // Initialization
#define SSP_MISC            0x00000002  // Misc debug
#define SSP_API             0x00000004  // API processing
#define SSP_LPC             0x00000008  // LPC
#define SSP_LOGON_SESS      0x00000010  // tracking logon sessions
#define SSP_CRITICAL        0x00000100  // Only real important errors
#define SSP_LEAK_TRACK      0x00000200  // calling PID etc
#define SSP_WARNING         0x00000400  // not fatal warnings of interest to developer
#define SSP_UPDATES         0x00000800  // updates to globals, passwords, etc.


#define SSP_SESSION_KEYS    0x00001000  // keying material
#define SSP_NEGOTIATE_FLAGS 0x00002000  // negotiate flags.
#define SSP_CRED            0x00004000  // tracking credentials
#define SSP_VERSION         0x00008000  // tracking versioning

//
// Very verbose bits
//

#define SSP_NTLM_V2         0x01000000  // verbose NTLMv2 info
#define SSP_API_MORE        0x04000000  // verbose API
#define SSP_LPC_MORE        0x08000000  // verbose LPC

//
// Control bits.
//

#define SSP_NO_LOCAL        0x10000000  // Force client to use OEM character set
#define SSP_TIMESTAMP       0x20000000  // TimeStamp each output line
#define SSP_REQUEST_TARGET  0x40000000  // Force client to ask for target name
#define SSP_USE_OEM         0x80000000  // Force client to use OEM character set


//
// Name and directory of log file
//

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\ntlmssp.log"
#define DEBUG_BAK_FILE      L"\\ntlmssp.bak"

#if DBG

EXTERN DWORD SspGlobalDbflag;

#define IF_DEBUG(Function) \
     if (SspGlobalDbflag & SSP_ ## Function)

#define SspPrint(_x_) SspPrintRoutine _x_

VOID
SspPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
SspDumpHexData(
    IN DWORD DebugFlag,
    IN LPDWORD Buffer,
    IN DWORD BufferSize
    );

VOID
SspDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid
    );

VOID
SspDumpBuffer(
    IN DWORD DebugFlag,
    IN PVOID Buffer,
    IN DWORD BufferSize
    );

VOID
SspOpenDebugFile(
    IN BOOL ReopenFlag
    );

//
// Debug log file
//

EXTERN HANDLE SspGlobalLogFile;
#define DEFAULT_MAXIMUM_LOGFILE_SIZE 20000000
EXTERN DWORD SspGlobalLogFileMaxSize;

//
// To serialize access to log file.
//

EXTERN CRITICAL_SECTION SspGlobalLogFileCritSect;
EXTERN LPWSTR SspGlobalDebugSharePath;

#else

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.
#define SspDumpHexData        /* no output; ignore arguments */
#define SspDumpBuffer
#define SspDumpSid
#define SspPrint(_x_)

#endif // DBG

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\miscapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        miscapi.cxx
//
// Contents:    Code for miscellaneous lsa mode NtLm entrypoints
//              Main entry points in the dll:
//                SpGetUserInfo
//
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\miscapi.cxx
//
//------------------------------------------------------------------------
#include <global.h>

NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    SspPrint((SSP_API, "Entering SpGetUserInfo\n"));

    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(UserData);

    SspPrint((SSP_API, "Leaving SpGetUserInfo\n"));
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\debug.cxx ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.cxx

Abstract:

    Support routines allowing the NtLmSsp DLL side use the common routines
    shared between the DLL and the SERVICE.

    These routines exist in the DLL side.  They are different implementations
    of the same routines that exist on the SERVICE side.  These implementations
    are significantly simpler because they run in the address space of the
    caller.

Author:

    Cliff Van Dyke (CliffV) 22-Sep-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\client\support.c

--*/

//
// Common include files.
//

#include <global.h>


#if DBG
#include <stdio.h>
#define MAX_PRINTF_LEN 1024        // Arbitrary.


VOID
SspPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    int cbUsed = 0;
    static BeginningOfLine = TRUE;
    static LineCount = 0;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (SspGlobalDbflag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &SspGlobalLogFileCritSect );
    length = 0;

    //
    // make sure it is null terminated
    //

    OutputBuffer[sizeof(OutputBuffer) - 1] = '\0';

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine )
    {
        //
        // If we're writing to the debug terminal,
        //  indicate this is an NtLmSsp message.
        //

        cbUsed = _snprintf(&OutputBuffer[length], sizeof(OutputBuffer) - 1 - length, "[MSV1_0.dll] ");

        if (cbUsed <= 0)
        {
            goto Done;
        }

        length += cbUsed;

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP )
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            cbUsed = _snprintf( &OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                "%02u/%02u %02u:%02u:%02u ",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );
            if (cbUsed <= 0)
            {
                goto Done;
            }

            length += cbUsed;
        }

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag)
            {
            case SSP_INIT:
                Text = "INIT"; break;
            case SSP_MISC:
                Text = "MISC"; break;
            case SSP_LOGON_SESS:
                Text = "LOGON_SESS"; break;
            case SSP_CRITICAL:
                Text = "CRITICAL"; break;
            case SSP_LEAK_TRACK:
                Text = "LEAK_TRACK"; break;
            case SSP_WARNING:
                Text = "WARNING"; break;
            case SSP_LPC:
            case SSP_LPC_MORE:
                Text = "LPC"; break;
            case SSP_API:
                Text = "API"; break;
            case SSP_API_MORE:
                Text = "APIMORE"; break;
            case SSP_SESSION_KEYS:
                Text = "SESSION_KEYS"; break;
            case SSP_NEGOTIATE_FLAGS:
                Text = "NEGOTIATE_FLAGS"; break;
            case SSP_UPDATES:
                Text = "UPDATES"; break;
            case SSP_NTLM_V2:
                Text = "NTLM_V2"; break;
            case SSP_CRED:
                Text = "CRED"; break;
            case SSP_VERSION:
                Text = "VER"; break;
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }

            if ( Text != NULL )
            {
                cbUsed = _snprintf( &OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                                   "[%s] ", Text );
                if (cbUsed <= 0)
                {
                    goto Done;
                }

                length += cbUsed;
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    cbUsed = _vsnprintf(&OutputBuffer[length], sizeof(OutputBuffer) - 1 - length,
                        Format, arglist);
    va_end(arglist);

    if (cbUsed <= 0)
    {
        goto Done;
    }

    length += cbUsed;

Done:

    BeginningOfLine = (length > 0 && OutputBuffer[length - 1] == '\n' );

    //
    //  just output to the debug terminal
    //

    (void) DbgPrint( (PCH) OutputBuffer);

    LeaveCriticalSection( &SspGlobalLogFileCritSect );

} // SspPrintRoutine

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\global.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NtLm security package
//
//
// History:     ChandanS  25-Jul-1996 Stolen from kerberos\client2\kerbp.h
//
//------------------------------------------------------------------------

#ifndef __GLOBAL_H__
#define __GLOBAL_H__


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#include <wincred.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
#include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <alloca.h>

#include <rc4.h>
#include <des.h>
#include <md5.h>
#include <sha.h>
#include <hmac.h>

#include "ntlmfunc.h"
#include "ntlmutil.h"
#include "ntlmsspi.h"
#include "ntlmcomn.h"

//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTLM_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTLM_GLOBAL

typedef enum _NTLM_STATE {
    NtLmLsaMode = 1,
    NtLmUserMode
} NTLM_STATE, *PNTLM_STATE;

EXTERN NTLM_STATE NtLmState;

EXTERN ULONG_PTR NtLmPackageId;

EXTERN SECPKG_FUNCTION_TABLE NtLmFunctionTable;

// Helper routines for use by a Security package handed over by Lsa

EXTERN SECPKG_USER_FUNCTION_TABLE NtLmUserFunctionTable;
EXTERN PSECPKG_DLL_FUNCTIONS UserFunctions;
EXTERN PLSA_SECPKG_FUNCTION_TABLE LsaFunctions;

EXTERN LSA_SECPKG_FUNCTION_TABLE Lsa;

// This one guards all globals
EXTERN RTL_RESOURCE NtLmGlobalCritSect;

// Save the PSECPKG_PARAMETERS sent in by SpInitialize
EXTERN SECPKG_PARAMETERS NtLmSecPkg;

EXTERN BOOLEAN NtLmGlobalEncryptionEnabled;

EXTERN ULONG NtLmGlobalLmProtocolSupported;
EXTERN UNICODE_STRING NtLmGlobalNtLm3TargetInfo;
EXTERN BOOLEAN NtLmGlobalRequireNtlm2;
EXTERN BOOLEAN NtLmGlobalDatagramUse128BitEncryption;
EXTERN BOOLEAN NtLmGlobalDatagramUse56BitEncryption;


EXTERN ULONG NtLmGlobalMinimumClientSecurity;
EXTERN ULONG NtLmGlobalMinimumServerSecurity;

//
// Useful constants
//

EXTERN TimeStamp NtLmGlobalForever;

// Local system is NtProductWinNt or NtProductLanmanNt

EXTERN NT_PRODUCT_TYPE NtLmGlobalNtProductType;

//
// The computername of the local system.
//

EXTERN WCHAR NtLmGlobalUnicodeComputerName[CNLEN + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeComputerNameString;
EXTERN STRING NtLmGlobalOemComputerNameString;

EXTERN WCHAR NtLmGlobalUnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsComputerNameString;

//
// The domain name of the local system
//

EXTERN WCHAR NtLmGlobalUnicodePrimaryDomainName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodePrimaryDomainNameString;
EXTERN STRING NtLmGlobalOemPrimaryDomainNameString;

EXTERN WCHAR NtLmGlobalUnicodeDnsDomainName[DNS_MAX_NAME_LENGTH + 1];
EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsDomainNameString;


//
// The TargetName of the local system
//

EXTERN UNICODE_STRING NtLmGlobalUnicodeTargetName;
EXTERN STRING NtLmGlobalOemTargetName;
EXTERN ULONG NtLmGlobalTargetFlags;
EXTERN PSID NtLmGlobalLocalSystemSid;
EXTERN PSID NtLmGlobalAliasAdminsSid;
EXTERN PSID NtLmGlobalProcessUserSid;
EXTERN PSID NtLmGlobalAnonymousSid;

EXTERN UNICODE_STRING NtLmGlobalUnicodeDnsTreeName;

//
// mapped and preferred domain names
// NOTE: these require a reboot to be re-read during package startup
// it is not necessary to hold the global lock as a side-effect of this
// requirement
//

EXTERN UNICODE_STRING NtLmLocklessGlobalMappedDomainString;
EXTERN UNICODE_STRING NtLmLocklessGlobalPreferredDomainString;


EXTERN HKEY NtLmGlobalLsaKey;
EXTERN HKEY NtLmGlobalLsaMsv1_0Key;

EXTERN HANDLE NtLmGlobalRegChangeNotifyEvent;
EXTERN HANDLE NtLmGlobalRegWaitObject;

//
// Access token associated with SYSTEM account.
//

EXTERN HANDLE NtLmGlobalAccessTokenSystem;

//
// System wide fudge for mutual auth in mixed environments
//

EXTERN ULONG NtLmGlobalMutualAuthLevel ;

//
// LogonID of machine credential.
//

EXTERN LUID NtLmGlobalLuidMachineLogon;

//
// LSA policy handle to local machine.
//

EXTERN LSA_HANDLE NtLmGlobalPolicyHandle;


//
// force guest account usage for all network logons?
//

EXTERN BOOLEAN NtLmGlobalForceGuest;

//
// indicates if we are running on the Personal product SKU
//

EXTERN BOOLEAN NtLmGlobalPersonalSKU;


EXTERN BOOLEAN NtLmGlobalSafeBoot;

//
// Allow blank password logons?
//

EXTERN BOOLEAN NtLmGlobalAllowBlankPassword;

//
// Joined to a domain?
//

EXTERN BOOLEAN NtLmGlobalDomainJoined;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\encrypt.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.cxx

Abstract:

    Contains routine to check whether encryption is supported on this
    system or not.

Author:

    Mike Swift (MikeSw) 2-Aug-1994

Revision History:

    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\common\encrypt.c
--*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>

extern "C"
BOOLEAN
IsEncryptionPermitted(VOID)
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{

//
// sfield: permission to remove FRANCE check obtained 08-21-1999
//

#if 0
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfo(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }
    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
#endif

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msp.h

Abstract:

    MSV1_0 authentication package private definitions.




Author:

    Jim Kelly 11-Apr-1991

Revision History:
    Scott Field (sfield)    05-Oct-98   Add NTLM3
    Scott Field (sfield)    15-Jan-98   Add MspNtDeriveCredential
    Chandana Surlu          21-Jul-96   Stolen from \\kernel\razzle3\src\security\msv1_0\msv1_0.c

--*/

#ifndef _MSP_
#define _MSP_

#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>
#include <ntmsv1_0.h>

#include <windows.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            SspPrint((SSP_CRITICAL, "Failed RELOCATE_ONE\n"));              \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                SspPrint((SSP_CRITICAL, "Failed NULL_RELOCATE_ONE\n"));     \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }


//
// RELOCATE_ONE_ENCODED - Relocate a unicode string pointer in a client
//   buffer.  The upper byte of the length field may be an encryption seed
//   and should not be used for error checking.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length & 0x00ff.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE_ENCODED( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + ((_q)->Length & 0x00ff) > SubmitBufferSize ||         \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            SspPrint((SSP_CRITICAL, "Failed RELOCATE_ONE_ENCODED\n"));      \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length & 0x00ff;                                \
    }


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routine definitions               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );

NTSTATUS
LsaApLogonUser(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority
    );

NTSTATUS
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    );


///////////////////////////////////////////////////////////////////////
//                                                                   //
// LsaApCallPackage function dispatch routines                       //
//                                                                   //
///////////////////////////////////////////////////////////////////////


NTSTATUS
MspLm20Challenge(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GetChallengeResponse(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20EnumUsers(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GetUserInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20ReLogonUsers(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20ChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20GenericPassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20CacheLogon(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspLm20CacheLookup(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspNtSubAuth(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspNtDeriveCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
MspSetProcessOption(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// NETLOGON routines visible to main msv1_0 code                     //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
NlInitialize(
    VOID
    );

NTSTATUS
MspLm20LogonUser (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation
    );

VOID
MsvLm20LogonTerminated (
    IN PLUID LogonId
    );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

//
// Variables defined in msvars.c
//

extern ULONG MspAuthenticationPackageId;
extern LSA_SECPKG_FUNCTION_TABLE Lsa;


//
// Change password log support routines
//


#ifndef DONT_LOG_PASSWORD_CHANGES

ULONG
MsvPaswdInitializeLog(
    VOID
    );

ULONG
MsvPaswdSetAndClearLog(
    VOID
    );

ULONG
MsvPaswdCloseLog(
    VOID
    );

VOID
MsvPaswdLogPrintRoutine(
    IN LPSTR Format,
    ...
    );

#define MsvPaswdLogPrint( x )  MsvPaswdLogPrintRoutine x


#else

#define MsvPaswdInitializeLog()
#define MsvPaswdCloseLog()
#define MsvPaswdLogPrint( x )
#define MsvPaswdSetAndClearLog()
#endif

#endif // _MSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msvars.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msvars.c

Abstract:

   This module contains variables used within the msv1_0 authentication
   package.

Author:

    Jim Kelly (JimK) 11-Apr-1991

Environment:

    User mode - msv1_0 authentication package DLL

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvars.c

--*/

#include "msp.h"



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////



//
// msv1_0 private heap.
//

PVOID MspHeap;


//
// package ID assigned to msv1_0 by the LSA.
//

ULONG MspAuthenticationPackageId;


//
// dispatch table of (public) LSA service routines.
//

LSA_SECPKG_FUNCTION_TABLE Lsa;





////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msvpaswd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msvpaswd.c

Abstract:

    This file contains the MSV1_0 Authentication Package password routines.

Author:

    Dave Hart    (davehart)   12-Mar-1992

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvpaswd.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"

#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmremutl.h>
#include <lmwksta.h>

#include "msvwow.h"  // MsvConvertWOWChangePasswordBuffer()


NTSTATUS
MspImpersonateAnonymous(
    VOID
    )

/*++

Routine Description:

    Remove the current thread from the Administrators alias.  This
    is accomplished by impersonating our own thread, then removing
    the Administrators alias membership from the impersonation
    token.  Use RevertToSelf() to stop impersonating and
    thereby restore the thread to the Administrators alias.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{

    RevertToSelf();

    if(!ImpersonateAnonymousToken( GetCurrentThread() ))
    {
        return STATUS_CANNOT_IMPERSONATE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MspAddBackslashesComputerName(
    IN PUNICODE_STRING ComputerName,
    OUT PUNICODE_STRING UncComputerName
    )

/*++

Routine Description:

    This function makes a copy of a Computer Name, prepending backslashes
    if they are not already present.

Arguments:

    ComputerName - Pointer to Computer Name without backslashes.

    UncComputerName - Pointer to Unicode String structure that will be
        initialized to reference the computerName with backslashes
        prepended if not already present.  The Unicode Buffer will be
        terminated with a Unicode NULL, so that it can be passed as
        a parameter to routines expecting a null terminated Wide String.
        When this string is finished with, the caller must free its
        memory via RtlFreeHeap.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN HasBackslashes = FALSE;
    BOOLEAN IsNullTerminated = FALSE;
    USHORT OutputNameLength;
    USHORT OutputNameMaximumLength;
    PWSTR StartBuffer = NULL;

    //
    // If the computername is NULL, a zero length string, or the name already begins with
    // backslashes and is wide char null terminated, just use it unmodified.
    //

    if( (!ARGUMENT_PRESENT(ComputerName)) || ComputerName->Length == 0 ) {
        UncComputerName->Buffer = NULL;
        UncComputerName->Length = 0;
        UncComputerName->MaximumLength = 0;
        goto AddBackslashesComputerNameFinish;
    }

    //
    // Name is not NULL or zero length.  Check if name already has
    // backslashes and a trailing Unicode Null
    //

    OutputNameLength = ComputerName->Length + (2 * sizeof(WCHAR));
    OutputNameMaximumLength = OutputNameLength + sizeof(WCHAR);

    if ((ComputerName && ComputerName->Length >= 2 * sizeof(WCHAR)) &&
        (ComputerName->Buffer[0] == L'\\') &&
        (ComputerName->Buffer[1] == L'\\')) {

        HasBackslashes = TRUE;
        OutputNameLength -= (2 * sizeof(WCHAR));
        OutputNameMaximumLength -= (2 * sizeof(WCHAR));
    }

    if ((ComputerName->Length + (USHORT) sizeof(WCHAR) <= ComputerName->MaximumLength) &&
        (ComputerName->Buffer[ComputerName->Length/sizeof(WCHAR)] == UNICODE_NULL)) {

        IsNullTerminated = TRUE;
    }

    if (HasBackslashes && IsNullTerminated) {

        *UncComputerName = *ComputerName;
        goto AddBackslashesComputerNameFinish;
    }

    //
    // Name either does not have backslashes or is not NULL terminated.
    // Make a copy with leading backslashes and a wide NULL terminator.
    //

    UncComputerName->Length = OutputNameLength;
    UncComputerName->MaximumLength = OutputNameMaximumLength;

    UncComputerName->Buffer = I_NtLmAllocate(
                                 OutputNameMaximumLength
                                 );

    if (UncComputerName->Buffer == NULL) {

        KdPrint(("MspAddBackslashes...: Out of memory copying ComputerName.\n"));
        Status = STATUS_NO_MEMORY;
        goto AddBackslashesComputerNameError;
    }

    StartBuffer = UncComputerName->Buffer;

    if (!HasBackslashes) {

        UncComputerName->Buffer[0] = UncComputerName->Buffer[1] = L'\\';
        StartBuffer +=2;
    }

    RtlCopyMemory(
        StartBuffer,
        ComputerName->Buffer,
        ComputerName->Length
        );

    UncComputerName->Buffer[UncComputerName->Length / sizeof(WCHAR)] = UNICODE_NULL;

AddBackslashesComputerNameFinish:

    return(Status);

AddBackslashesComputerNameError:

    goto AddBackslashesComputerNameFinish;
}

#ifndef DONT_LOG_PASSWORD_CHANGES
#include <stdio.h>
HANDLE MsvPaswdLogFile = NULL;
#define MSVPASWD_LOGNAME L"\\debug\\PASSWD.LOG"
#define MSVPASWD_BAKNAME L"\\debug\\PASSWD.BAK"

ULONG
MsvPaswdInitializeLog(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;
    WCHAR LogFileName[ MAX_PATH + 1 ], BakFileName[ MAX_PATH + 1 ];


    if ( !GetWindowsDirectoryW( LogFileName,
                                sizeof( LogFileName )/sizeof( WCHAR ) ) ) {

        dwErr = GetLastError();
    } else {

        wcscpy( BakFileName, LogFileName );
        wcscat( LogFileName, MSVPASWD_LOGNAME );
        wcscat( BakFileName, MSVPASWD_BAKNAME );

        //
        // Copy the existing (maybe) log file to a backup
        //
    //if ( CopyFile( LogFileName, BakFileName, FALSE ) == FALSE ) {
    //
    // }


        MsvPaswdLogFile = CreateFileW( LogFileName,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL );

        if ( MsvPaswdLogFile == INVALID_HANDLE_VALUE ) {

            dwErr = GetLastError();

            MsvPaswdLogFile = NULL;

        } else {

            if( SetFilePointer( MsvPaswdLogFile,
                                0, 0,
                                FILE_END ) == 0xFFFFFFFF ) {

                dwErr = GetLastError();

                CloseHandle( MsvPaswdLogFile );
                MsvPaswdLogFile = NULL;
            }
        }
    }

    return( dwErr );
}

ULONG
MsvPaswdCloseLog(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;

    if ( MsvPaswdLogFile != NULL ) {

        CloseHandle( MsvPaswdLogFile );
        MsvPaswdLogFile = NULL;
    }

    return( dwErr );
}

//
// Stolen and hacked up from netlogon code
//

VOID
MsvPaswdDebugDumpRoutine(
    IN LPSTR Format,
    va_list arglist
    )
{
    char OutputBuffer[2049];
    ULONG length;
    ULONG BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;
    int cbUsed = 0;

    //
    // If we don't have an open log file, just bail
    //
    if ( MsvPaswdLogFile == NULL ) {

        return;
    }

    length = 0;
    OutputBuffer[sizeof(OutputBuffer) - 1] = '\0';

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If we're writing to the debug terminal,
        //  indicate this is a Netlogon message.
        //

        //
        // Put the timestamp at the begining of the line.
        //

        GetLocalTime( &SystemTime );
        length += (ULONG) sprintf( &OutputBuffer[length],
                                   "%02u/%02u %02u:%02u:%02u ",
                                   SystemTime.wMonth,
                                   SystemTime.wDay,
                                   SystemTime.wHour,
                                   SystemTime.wMinute,
                                   SystemTime.wSecond );
    }

    //
    // Put a the information requested by the caller onto the line
    //
    // save two chars of spaces for the EOLs
    //
    cbUsed = (ULONG) _vsnprintf(&OutputBuffer[length], sizeof(OutputBuffer) - length - 1 - 2, Format, arglist);

    if (cbUsed >= 0)
    {
        length += cbUsed;
    }

    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = '\r';
        OutputBuffer[length] = '\n';
        OutputBuffer[length+1] = '\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( CHAR ) );


    //
    // Write the debug info to the log file.
    //
    if ( !WriteFile( MsvPaswdLogFile,
                     OutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {
    }
}

VOID
MsvPaswdLogPrintRoutine(
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    va_start(arglist, Format);

    MsvPaswdDebugDumpRoutine( Format, arglist );

    va_end(arglist);
}

ULONG
MsvPaswdSetAndClearLog(
    VOID
    )
/*++

Routine Description:

    Flushes the log and seeks to the end of the file

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG dwErr = ERROR_SUCCESS;
    if ( MsvPaswdLogFile != NULL ) {

        if( FlushFileBuffers( MsvPaswdLogFile ) == FALSE ) {

            dwErr = GetLastError();
        }
    }

    return( dwErr );

}

#endif // DONT_LOG_PASSWORD_CHANGES


NTSTATUS
MspChangePasswordSam(
    IN PUNICODE_STRING UncComputerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN BOOLEAN Impersonating,
    OUT PDOMAIN_PASSWORD_INFORMATION *DomainPasswordInfo,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO *PrimaryDomainInfo OPTIONAL,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspChangePassword to change the password
    on a Windows NT machine.

Arguments:

    UncComputerName - Name of the target machine.  This name must begin with
        two backslashes.

    UserName - Name of the user to change password for.

    OldPassword - Plaintext current password.

    NewPassword - Plaintext replacement password.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    DomainPasswordInfo - Password restriction information (returned only if
        status is STATUS_PASSWORD_RESTRICTION).

    PrimaryDomainInfo - DomainNameInformation (returned only if status is
        STATUS_BACKUP_CONTROLLER).

    Authoritative - The failure was authoritative and no retries should be
        made.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    ...

--*/

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    LSA_HANDLE                  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES           LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    BOOLEAN                     ImpersonatingAnonymous = FALSE;

    UNREFERENCED_PARAMETER(ClientRequest);

    //
    // Assume all failures are authoritative
    //

    *Authoritative = TRUE;

    //
    // If we're impersonating (ie, winlogon impersonated its caller before calling us),
    // impersonate again.  This allows us to get the name of the caller for auditing.
    //

    if ( Impersonating ) {

        Status = Lsa.ImpersonateClient();

    } else {

        BOOLEAN AvoidAnonymous = FALSE;

        //
        // Since the System context is a member of the Administrators alias,
        // when we connect with the local SAM we come in as an Administrator.
        // (When it's remote, we go over the null session and so have very
        // low access).  We don't want to be an Administrator because that
        // would allow the user to change the password on an account whose
        // ACL prohibits the user from changing the password.  So we'll
        // temporarily impersonate ourself and disable the Administrators
        // alias in the impersonation token.
        //

        //
        // Don't impersonateAnonymous if BLANKPWD flag is set
        // AND the change is for the local machine.
        //

        AvoidAnonymous = ((NtLmCheckProcessOption( MSV1_0_OPTION_ALLOW_BLANK_PASSWORD ) & MSV1_0_OPTION_ALLOW_BLANK_PASSWORD) != 0);

        if( AvoidAnonymous )
        {
            UNICODE_STRING ComputerName;

            AvoidAnonymous = FALSE;

            ComputerName = *UncComputerName;

            if( ComputerName.Length > 4 &&
                ComputerName.Buffer[0] == L'\\' &&
                ComputerName.Buffer[1] == L'\\' )
            {
                ComputerName.Buffer += 2;
                ComputerName.Length -= 2 * sizeof(WCHAR);
            }

            if( NlpSamDomainName.Buffer )
            {
                AvoidAnonymous = RtlEqualUnicodeString(
                                            &ComputerName,
                                            &NlpSamDomainName,
                                            TRUE
                                            );
            }

            if( !AvoidAnonymous )
            {
                RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

                AvoidAnonymous = RtlEqualUnicodeString(
                                            &ComputerName,
                                            &NtLmGlobalUnicodeComputerNameString,
                                            TRUE
                                            );

                RtlReleaseResource(&NtLmGlobalCritSect);
            }
        }

        if( AvoidAnonymous )
        {
            Status = STATUS_SUCCESS;
            ImpersonatingAnonymous = FALSE;
        } else {

            Status = MspImpersonateAnonymous();

            ImpersonatingAnonymous = TRUE;
        }
    }

    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    try
    {
        Status = SamChangePasswordUser2(
                    UncComputerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    MsvPaswdLogPrint(("SamChangePasswordUser2 on machine %wZ for user %wZ returned 0x%x\n",
        UncComputerName,
        UserName,
        Status
        ));

    if ( !NT_SUCCESS(Status) ) {

#ifdef COMPILED_BY_DEVELOPER
        KdPrint(("MspChangePasswordSam: SamChangePasswordUser2(%wZ) failed, status %x\n",
                 UncComputerName, Status));
#endif // COMPILED_BY_DEVELOPER

        //
        // If we failed to connect and we were impersonating a client
        // then we may want to try again using the NULL session.
        // Only try this if we found a server last try.  Otherwise,
        // we'll subject our user to another long timeout.
        //

        if (( Impersonating ) &&
            ( Status != STATUS_WRONG_PASSWORD ) &&
            ( Status != STATUS_PASSWORD_RESTRICTION ) &&
            ( Status != STATUS_ACCOUNT_RESTRICTION ) &&
            ( Status != RPC_NT_SERVER_UNAVAILABLE) &&
            ( Status != STATUS_INVALID_DOMAIN_ROLE) ) {

            Status = MspImpersonateAnonymous();

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            ImpersonatingAnonymous = TRUE;

            Status = SamChangePasswordUser2(
                        UncComputerName,
                        UserName,
                        OldPassword,
                        NewPassword
                        );

            MsvPaswdLogPrint(("SamChangePasswordUser2 retry on machine %wZ for user %wZ returned 0x%x\n",
                UncComputerName,
                UserName,
                Status
                ));

#ifdef COMPILED_BY_DEVELOPER
            if ( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: SamChangePasswordUser2(%wZ) (2nd attempt) failed, status %x\n",
                 UncComputerName, Status));
                }
#endif // COMPILED_BY_DEVELOPER
        }
    }

    //
    // if we are impersonating Anonymous, RevertToSelf, so the password policy
    // fetch attempt occurs using machine/system creds.
    //

    if( ImpersonatingAnonymous )
    {
        RevertToSelf();
    }

    if ( !NT_SUCCESS(Status) ) {

#ifdef COMPILED_BY_DEVELOPER
        KdPrint(("MspChangePasswordSam: Cannot change password for %wZ, status %x\n",
                 UserName, Status));
#endif // COMPILED_BY_DEVELOPER
        if (Status == RPC_NT_SERVER_UNAVAILABLE ||
            Status == RPC_S_SERVER_UNAVAILABLE ) {

            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        } else if (Status == STATUS_PASSWORD_RESTRICTION) {

            //
            // Get the password restrictions for this domain and return them
            //

            //
            // Get the SID of the account domain from LSA
            //

            InitializeObjectAttributes( &LSAObjectAttributes,
                                          NULL,             // Name
                                          0,                // Attributes
                                          NULL,             // Root
                                          NULL );           // Security Descriptor

            Status = LsaOpenPolicy( UncComputerName,
                                    &LSAObjectAttributes,
                                    POLICY_VIEW_LOCAL_INFORMATION,
                                    &LSAPolicyHandle );

            if( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                         UncComputerName, Status));
                LSAPolicyHandle = NULL;
                goto Cleanup;
            }

            Status = LsaQueryInformationPolicy(
                            LSAPolicyHandle,
                            PolicyAccountDomainInformation,
                            (PVOID *) &AccountDomainInfo );

            if( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                         UncComputerName, Status));
                AccountDomainInfo = NULL;
                goto Cleanup;
            }

            //
            // Setup ObjectAttributes for SamConnect call.
            //

            InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
            ObjectAttributes.SecurityQualityOfService = &SecurityQos;

            SecurityQos.Length = sizeof(SecurityQos);
            SecurityQos.ImpersonationLevel = SecurityIdentification;
            SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
            SecurityQos.EffectiveOnly = FALSE;

            Status = SamConnect(
                         UncComputerName,
                         &SamHandle,
                         SAM_SERVER_LOOKUP_DOMAIN,
                         &ObjectAttributes
                         );

            if ( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: Cannot open sam on %wZ, status %x\n",
                         UncComputerName, Status));
                DomainHandle = NULL;
                goto Cleanup;
            }

            //
            // Open the Account domain in SAM.
            //

            Status = SamOpenDomain(
                         SamHandle,
                         GENERIC_EXECUTE,
                         AccountDomainInfo->DomainSid,
                         &DomainHandle
                         );

            if ( !NT_SUCCESS(Status) ) {
                KdPrint(("MspChangePasswordSam: Cannot open domain on %wZ, status %x\n",
                         UncComputerName, Status));
                DomainHandle = NULL;
                goto Cleanup;
            }

            Status = SamQueryInformationDomain(
                            DomainHandle,
                            DomainPasswordInformation,
                            (PVOID *)DomainPasswordInfo );

            if (!NT_SUCCESS(Status)) {
                *DomainPasswordInfo = NULL;
            } else {
                Status = STATUS_PASSWORD_RESTRICTION;
            }
        }

        goto Cleanup;
    }

Cleanup:

    //
    // If the only problem is that this is a BDC,
    //  Return the domain name back to the caller.
    //

    if ( (Status == STATUS_BACKUP_CONTROLLER ||
         Status == STATUS_INVALID_DOMAIN_ROLE) &&
         PrimaryDomainInfo != NULL ) {

        NTSTATUS TempStatus;

        //
        // Open the LSA if we haven't already.
        //

        if (LSAPolicyHandle == NULL) {

            InitializeObjectAttributes( &LSAObjectAttributes,
                                        NULL,             // Name
                                        0,                // Attributes
                                        NULL,             // Root
                                        NULL );           // Security Descriptor

            TempStatus = LsaOpenPolicy( UncComputerName,
                                        &LSAObjectAttributes,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &LSAPolicyHandle );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                     UncComputerName, TempStatus));
                LSAPolicyHandle = NULL;
            }
        }

        if (LSAPolicyHandle != NULL) {
            TempStatus = LsaQueryInformationPolicy(
                            LSAPolicyHandle,
                            PolicyPrimaryDomainInformation,
                            (PVOID *) PrimaryDomainInfo );

            if( !NT_SUCCESS(TempStatus) ) {
                KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                         UncComputerName, TempStatus));
                *PrimaryDomainInfo = NULL;
    #ifdef COMPILED_BY_DEVELOPER
            } else {
                KdPrint(("MspChangePasswordSam: %wZ is really a BDC in domain %wZ\n",
                         UncComputerName, &(*PrimaryDomainInfo)->Name));
    #endif // COMPILED_BY_DEVELOPER
            }
        }

        Status = STATUS_BACKUP_CONTROLLER;
    }

    //
    // Check for non-authoritative failures
    //

    if (( Status != STATUS_ACCESS_DENIED) &&
        ( Status != STATUS_WRONG_PASSWORD ) &&
        ( Status != STATUS_NO_SUCH_USER ) &&
        ( Status != STATUS_PASSWORD_RESTRICTION ) &&
        ( Status != STATUS_ACCOUNT_RESTRICTION ) &&
        ( Status != STATUS_INVALID_DOMAIN_ROLE )) {
        *Authoritative = FALSE;
    }

    //
    // Stop impersonating.
    //

    RevertToSelf();

    //
    // Free Locally used resources
    //

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( AccountDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( AccountDomainInfo );
    }

    return Status;
}


NTSTATUS
MspChangePasswordDownlevel(
    IN PUNICODE_STRING UncComputerName,
    IN PUNICODE_STRING UserNameU,
    IN PUNICODE_STRING OldPasswordU,
    IN PUNICODE_STRING NewPasswordU,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspChangePassword to change the password
    on an OS/2 User-level server.  First we try sending an encrypted
    request to the server, failing that we fall back on plaintext.

Arguments:

    UncComputerName - Pointer to Unicode String containing the Name of the
        target machine.  This name must begin with two backslashes and
        must be null terminated.

    UserNameU    - Name of the user to change password for.

    OldPasswordU - Plaintext current password.

    NewPasswordU - Plaintext replacement password.

    Authoritative - If the attempt failed with an error that would
        otherwise cause the password attempt to fail, this flag, if false,
        indicates that the error was not authoritative and the attempt
        should proceed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS         Status;
    NET_API_STATUS   NetStatus;
    DWORD            Length;
    LPWSTR           UserName = NULL;
    LPWSTR           OldPassword = NULL;
    LPWSTR           NewPassword = NULL;

    *Authoritative = TRUE;

    //
    // Convert UserName from UNICODE_STRING to null-terminated wide string
    // for use by RxNetUserPasswordSet.
    //

    Length = UserNameU->Length;

    UserName = I_NtLmAllocate(
                   Length + sizeof(TCHAR)
                   );

    if ( NULL == UserName ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( UserName, UserNameU->Buffer, Length );

    UserName[ Length / sizeof(TCHAR) ] = 0;

    //
    // Convert OldPassword from UNICODE_STRING to null-terminated wide string.
    //

    Length = OldPasswordU->Length;

    OldPassword = I_NtLmAllocate( Length + sizeof(TCHAR) );

    if ( NULL == OldPassword ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( OldPassword, OldPasswordU->Buffer, Length );

    OldPassword[ Length / sizeof(TCHAR) ] = 0;

    //
    // Convert NewPassword from UNICODE_STRING to null-terminated wide string.
    //

    Length = NewPasswordU->Length;

    NewPassword = I_NtLmAllocate( Length + sizeof(TCHAR) );

    if ( NULL == NewPassword ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( NewPassword, NewPasswordU->Buffer, Length );

    NewPassword[ Length / sizeof(TCHAR) ] = 0;

#ifdef COMPILED_BY_DEVELOPER

    KdPrint(("MSV1_0: Changing password on downlevel server:\n"
        "\tUncComputerName: %wZ\n"
        "\tUserName:     %ws\n"
        "\tOldPassword:  %ws\n"
        "\tNewPassword:  %ws\n",
        UncComputerName,
        UserName,
        OldPassword,
        NewPassword
        ));

#endif // COMPILED_BY_DEVELOPER

    //
    // Attempt to change password on downlevel server.
    //

    NetStatus = RxNetUserPasswordSet(
                    UncComputerName->Buffer,
                    UserName,
                    OldPassword,
                    NewPassword);

    MsvPaswdLogPrint(("RxNetUserPasswordSet on machine %ws for user %ws returned 0x%x\n",
        UncComputerName->Buffer,
        UserName,
        NetStatus
        ));

#ifdef COMPILED_BY_DEVELOPER
    KdPrint(("MSV1_0: RxNUserPasswordSet returns %d.\n", NetStatus));
#endif // COMPILED_BY_DEVELOPER

    // Since we overload the computername as the domain name,
    // map NERR_InvalidComputer to STATUS_NO_SUCH_DOMAIN, since
    // that will give the user a nice error message.
    //
    // ERROR_PATH_NOT_FOUND is returned on a standalone workstation that
    //  doesn't have the network installed.
    //

    if (NetStatus == NERR_InvalidComputer ||
        NetStatus == ERROR_PATH_NOT_FOUND) {

        Status = STATUS_NO_SUCH_DOMAIN;

    // ERROR_SEM_TIMEOUT can be returned when the computer name doesn't
    //  exist.
    //
    // ERROR_REM_NOT_LIST can also be returned when the computer name
    //  doesn't exist.
    //

    } else if ( NetStatus == ERROR_SEM_TIMEOUT ||
                NetStatus == ERROR_REM_NOT_LIST) {

        Status = STATUS_BAD_NETWORK_PATH;

    } else if ( (NetStatus == ERROR_INVALID_PARAMETER) &&
                ((wcslen(NewPassword) > LM20_PWLEN) ||
                 (wcslen(OldPassword) > LM20_PWLEN)) ) {

        //
        // The net api returns ERROR_INVALID_PARAMETER if the password
        // could not be converted to the LM OWF password.  Return
        // STATUS_PASSWORD_RESTRICTION for this.
        //

        Status = STATUS_PASSWORD_RESTRICTION;

        //
        // We never made it to the other machine, so we should continue
        // trying to change the password.
        //

        *Authoritative = FALSE;
    } else {
        Status = NetpApiStatusToNtStatus( NetStatus );
    }

Cleanup:

    //
    // Free UserName if used.
    //

    if (UserName) {

        I_NtLmFree(UserName);
    }

    //
    // Free OldPassword if used. (Don't let password make it to page file)
    //

    if (OldPassword) {
        RtlZeroMemory( OldPassword, wcslen(OldPassword) * sizeof(WCHAR) );
        I_NtLmFree(OldPassword);
    }

    //
    // Free NewPassword if used. (Don't let password make it to page file)
    //

    if (NewPassword) {
        RtlZeroMemory( NewPassword, wcslen(NewPassword) * sizeof(WCHAR) );
        I_NtLmFree(NewPassword);
    }

    return Status;
}

NTSTATUS
MspChangePassword(
    IN OUT PUNICODE_STRING ComputerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN BOOLEAN Impersonating,
    OUT PDOMAIN_PASSWORD_INFORMATION *DomainPasswordInfo,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO *PrimaryDomainInfo OPTIONAL,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This routine is called by MspLM20ChangePassword to change the password
    on the specified server.  The server may be either NT or Downlevel.

Arguments:

    ComputerName - Name of the target machine.  This name may or may not
        begin with two backslashes.

    UserName - Name of the user to change password for.

    OldPassword - Plaintext current password.

    NewPassword - Plaintext replacement password.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    DomainPasswordInfo - Password restriction information (returned only if
        status is STATUS_PASSWORD_RESTRICTION).

    PrimaryDomainInfo - DomainNameInformation (returned only if status is
        STATUS_BACKUP_CONTROLLER).

    Authoritative - Indicates that the error code is authoritative
        and it indicates that password changing should stop. If false,
        password changing should continue.


Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_PASSWORD_RESTRICTION - Password changing is restricted.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UncComputerName;

    *Authoritative = TRUE;

    //
    // Ensure the server name is a UNC server name.
    //

    Status = MspAddBackslashesComputerName( ComputerName, &UncComputerName );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("MspChangePassword: MspAddBackslashes..(%wZ) failed, status %x\n",
                 ComputerName, Status));
        return(Status);
    }

    //
    // Assume the Server is an NT server and try to change the password.
    //

    Status = MspChangePasswordSam(
                 &UncComputerName,
                 UserName,
                 OldPassword,
                 NewPassword,
                 ClientRequest,
                 Impersonating,
                 DomainPasswordInfo,
                 PrimaryDomainInfo,
                 Authoritative );

    //
    // If MspChangePasswordSam returns anything other than
    // STATUS_CANT_ACCESS_DOMAIN_INFO, it was able to connect
    // to the remote computer so we won't try downlevel.
    //

    if (Status == STATUS_CANT_ACCESS_DOMAIN_INFO) {
        NET_API_STATUS NetStatus;
        DWORD OptionsSupported;

        //
        // only if target machine doesn't support SAM protocol do we attempt
        // downlevel.
        // MspAddBackslashesComputerName() NULL terminates the buffer.
        //

        NetStatus = NetRemoteComputerSupports(
                     (LPWSTR)UncComputerName.Buffer,
                     SUPPORTS_RPC | SUPPORTS_LOCAL | SUPPORTS_SAM_PROTOCOL,
                     &OptionsSupported
                     );

        if( NetStatus == NERR_Success && !(OptionsSupported & SUPPORTS_SAM_PROTOCOL) ) {

            Status = MspChangePasswordDownlevel(
                        &UncComputerName,
                        UserName,
                        OldPassword,
                        NewPassword,
                        Authoritative );
        }
    }

    //
    // Free UncComputerName.Buffer if different from ComputerName.
    //

    if ( UncComputerName.Buffer != ComputerName->Buffer ) {
        I_NtLmFree(UncComputerName.Buffer);
    }

    return(Status);
}

NTSTATUS
MspLm20ChangePassword (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0ChangePassword.  This routine changes an
    account's password by either calling SamXxxPassword (for NT domains) or
    RxNetUserPasswordSet (for downlevel domains and standalone servers).

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_PASSWORD_RESTRICTION - The password change failed because the
        - password doesn't meet one or more domain restrictions.  The
        - response buffer is allocated.  If the PasswordInfoValid flag is
        - set it contains valid information otherwise it contains no
        - information because this was a down-level change.

    STATUS_BACKUP_CONTROLLER - The named machine is a Backup Domain Controller.
        Changing password is only allowed on the Primary Domain Controller.

--*/

{
    PMSV1_0_CHANGEPASSWORD_REQUEST ChangePasswordRequest = NULL;
    PMSV1_0_CHANGEPASSWORD_RESPONSE ChangePasswordResponse;
    NTSTATUS        Status = STATUS_SUCCESS;
    NTSTATUS        SavedStatus = STATUS_SUCCESS;
    LPWSTR          DomainName = NULL;
    PDOMAIN_CONTROLLER_INFO DCInfo = NULL;
    UNICODE_STRING  DCNameString;
    UNICODE_STRING  ClientNetbiosDomain = {0};
    PUNICODE_STRING  ClientDsGetDcDomain;
    UNICODE_STRING  ClientDnsDomain = {0};
    UNICODE_STRING  ClientUpn = {0};
    UNICODE_STRING  ClientName = {0};
    UNICODE_STRING  ValidatedAccountName;
    UNICODE_STRING  ValidatedDomainName;
    LPWSTR          ValidatedOldPasswordBuffer;
    LPWSTR          ValidatedNewPasswordBuffer;
    NET_API_STATUS  NetStatus;
    PPOLICY_LSA_SERVER_ROLE_INFO PolicyLsaServerRoleInfo = NULL;
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;
    PWKSTA_INFO_100 WkstaInfo100 = NULL;
    BOOLEAN PasswordBufferValidated = FALSE;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    PDS_NAME_RESULTW NameResult = NULL;
    HANDLE DsHandle = NULL;
    UCHAR Seed;
    BOOLEAN Authoritative = TRUE;
    BOOLEAN AttemptRediscovery = FALSE;

#if _WIN64
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    SECPKG_CALL_INFO  CallInfo;
    BOOL  fAllocatedSubmitBuffer = FALSE;
#endif

    RtlInitUnicodeString(
        &DCNameString,
        NULL
        );
    //
    // Sanity checks.
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

#if _WIN64

    //
    // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
    // call came from a WOW client.
    //

    Status = LsaFunctions->GetCallInfo(&CallInfo);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = MsvConvertWOWChangePasswordBuffer(ProtocolSubmitBuffer,
                                                   ClientBufferBase,
                                                   &SubmitBufferSize,
                                                   &pTempSubmitBuffer);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        fAllocatedSubmitBuffer = TRUE;

        //
        // Some macros below expand out to use ProtocolSubmitBuffer directly.
        // We've secretly replaced their usual ProtocolSubmitBuffer with
        // pTempSubmitBuffer -- let's see if they can tell the difference.
        //

        ProtocolSubmitBuffer = pTempSubmitBuffer;
    }

#endif  // _WIN64

    if ( SubmitBufferSize < sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChangePasswordRequest = (PMSV1_0_CHANGEPASSWORD_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChangePasswordRequest->MessageType == MsV1_0ChangePassword ||
            ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword );

    RELOCATE_ONE( &ChangePasswordRequest->DomainName );

    RELOCATE_ONE( &ChangePasswordRequest->AccountName );

    if ( ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ) {
        NULL_RELOCATE_ONE( &ChangePasswordRequest->OldPassword );
    } else {
        RELOCATE_ONE_ENCODED( &ChangePasswordRequest->OldPassword );
    }

    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->NewPassword );

    //
    // save away copies of validated buffers to check later.
    //

    RtlCopyMemory( &ValidatedDomainName, &ChangePasswordRequest->DomainName, sizeof(ValidatedDomainName) );
    RtlCopyMemory( &ValidatedAccountName, &ChangePasswordRequest->AccountName, sizeof(ValidatedAccountName) );

    ValidatedOldPasswordBuffer = ChangePasswordRequest->OldPassword.Buffer;
    ValidatedNewPasswordBuffer = ChangePasswordRequest->NewPassword.Buffer;


    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->OldPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->OldPassword
                );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->NewPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        if ( ChangePasswordRequest->NewPassword.Buffer !=
            ValidatedNewPasswordBuffer ) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->NewPassword
                );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    //
    // sanity check that we didn't whack over buffers.
    //

    if( !RtlCompareMemory(
                        &ValidatedDomainName,
                        &ChangePasswordRequest->DomainName,
                        sizeof(ValidatedDomainName)
                        )
                        ||
        !RtlCompareMemory(
                        &ValidatedAccountName,
                        &ChangePasswordRequest->AccountName,
                        sizeof(ValidatedAccountName)
                        )
                        ||
        (ValidatedOldPasswordBuffer != ChangePasswordRequest->OldPassword.Buffer)
                        ||
        (ValidatedNewPasswordBuffer != ChangePasswordRequest->NewPassword.Buffer)
                        ) {

            Status= STATUS_INVALID_PARAMETER;
            goto Cleanup;
    }


    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;
    PasswordBufferValidated = TRUE;

    MsvPaswdLogPrint(("Attempting password change server/domain %wZ for user %wZ\n",
        &ChangePasswordRequest->DomainName,
        &ChangePasswordRequest->AccountName
        ));

#ifdef COMPILED_BY_DEVELOPER

    KdPrint(("MSV1_0:\n"
             "\tDomain:\t%wZ\n"
             "\tAccount:\t%wZ\n"
             "\tOldPassword(%d)\n"
             "\tNewPassword(%d)\n",
             &ChangePasswordRequest->DomainName,
             &ChangePasswordRequest->AccountName,
             (int) ChangePasswordRequest->OldPassword.Length,
             (int) ChangePasswordRequest->NewPassword.Length
             ));

#endif // COMPILED_BY_DEVELOPER

    SspPrint((SSP_UPDATES, "MspLm20ChangePassword %wZ\\%wZ, message type %#x%s, impersonating ? %s\n",
        &ChangePasswordRequest->DomainName,
        &ChangePasswordRequest->AccountName,
        ChangePasswordRequest->MessageType,
        (MsV1_0ChangeCachedPassword == ChangePasswordRequest->MessageType) ? " (cached)" : "",
        ChangePasswordRequest->Impersonating ? "true" : "false"));

    //
    // If we're just changing the cached password,
    //  skip changing the password on the domain.
    //

    if ( ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ) {
        ClientName = ChangePasswordRequest->AccountName;
        ClientNetbiosDomain = ChangePasswordRequest->DomainName;
        Status = STATUS_SUCCESS;
        goto PasswordChangeSuccessfull;
    }

    //
    // If the client supplied a non-nt4 name, go ahead and convert it here.
    //

    if (ChangePasswordRequest->DomainName.Length == 0) {
        DWORD DsStatus;
        WCHAR NameBuffer[UNLEN+1];
        LPWSTR NameString = NameBuffer;
        ULONG Index;
        BOOLEAN fWorkstation = FALSE;

        if (ChangePasswordRequest->AccountName.Length / sizeof(WCHAR) > UNLEN)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        RtlCopyMemory(
            NameBuffer,
            ChangePasswordRequest->AccountName.Buffer,
            ChangePasswordRequest->AccountName.Length
            );
        NameBuffer[ChangePasswordRequest->AccountName.Length/sizeof(WCHAR)] = L'\0';
        RtlInitUnicodeString( &ClientUpn, NameBuffer );


        DsStatus = DsBindW(
                        NULL,
                        NULL,
                        &DsHandle
                        );

        //
        // we allow the bind to fail on a member workstation, which allows
        // us to attempt a 'manual' crack.
        //

        if (DsStatus != ERROR_SUCCESS) {

            fWorkstation = NlpWorkstation;

            if( !fWorkstation ) {
                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsBindW returned 0x%lx.\n",
                        DsStatus ));
                Status = NetpApiStatusToNtStatus( DsStatus );
                goto Cleanup;
            }
        }

        if( !fWorkstation ) {
            DsStatus = DsCrackNamesW(
                        DsHandle,
                        0,                          // no flags
                        DS_UNKNOWN_NAME,
                        DS_NT4_ACCOUNT_NAME,
                        1,
                        &NameString,
                        &NameResult
                        );

            if (DsStatus != ERROR_SUCCESS) {
                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW returned 0x%lx.\n",
                            DsStatus ));
                Status = NetpApiStatusToNtStatus( DsStatus );
                goto Cleanup;
            }

            //
            // Look for the name in the result
            //

            if (NameResult->cItems < 1) {
                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsCrackNamesW returned zero items.\n"));
                Status = STATUS_INTERNAL_ERROR;
                goto Cleanup;
            }
        }

        //
        // Check if the crack succeeded
        //

        if ( (fWorkstation) ||
             (NameResult->rItems[0].status != DS_NAME_NO_ERROR)
             ) {

            //
            // The name wasn't mapped. Try converting it manually by
            // splitting it at the '@'
            //

            RtlInitUnicodeString(
                &ClientName,
                NameBuffer
                );

            // shortest possible is 3 Unicode chars (eg: a@a)
            if (ClientName.Length < (sizeof(WCHAR) * 3)) {
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            for (Index = (ClientName.Length / sizeof(WCHAR)) - 1; Index != 0 ; Index-- ) {
                if (ClientName.Buffer[Index] == L'@') {

                    RtlInitUnicodeString(
                        &ClientDnsDomain,
                        &ClientName.Buffer[Index+1]
                        );

                    ClientName.Buffer[Index] = L'\0';
                    ClientName.Length = (USHORT) Index * sizeof(WCHAR);

                    break;
                }
            }

            //
            // If the name couldn't be parsed, give up and go home
            //

            if (ClientDnsDomain.Length == 0) {
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            //
            // This isn't really the Netbios Domain name, but it is the best we have.
            //

            ClientNetbiosDomain = ClientDnsDomain;

            for (Index = 0; Index < (ClientNetbiosDomain.Length / sizeof(WCHAR)) ; Index++ ) {

                //
                // truncate the netbios domain to the first DOT
                //

                if( ClientNetbiosDomain.Buffer[Index] == L'.' ) {
                    ClientNetbiosDomain.Length = (USHORT)(Index * sizeof(WCHAR));
                    ClientNetbiosDomain.MaximumLength = ClientNetbiosDomain.Length;
                    break;
                }
            }
        }
        else
        {

            RtlInitUnicodeString(
                &ClientDnsDomain,
                NameResult->rItems[0].pDomain
                );
            RtlInitUnicodeString(
                &ClientName,
                NameResult->rItems[0].pName
                );
            RtlInitUnicodeString(
                &ClientNetbiosDomain,
                NameResult->rItems[0].pName
                );
            //
            // Move the pointer for the name up to the first "\" in the name
            //

            for (Index = 0; Index < ClientName.Length / sizeof(WCHAR) ; Index++ ) {
                if (ClientName.Buffer[Index] == L'\\') {
                    RtlInitUnicodeString(
                        &ClientName,
                        &ClientName.Buffer[Index+1]
                        );

                    // Set the Netbios Domain Name to the string to the left of the backslash
                    ClientNetbiosDomain.Length = (USHORT)(Index * sizeof(WCHAR));
                    break;
                }
            }
        }

    } else {

        ClientName = ChangePasswordRequest->AccountName;
        ClientNetbiosDomain = ChangePasswordRequest->DomainName;
    }

    // Make sure that NlpSamInitialized is TRUE. If we logon using
    // Kerberos, this may not be true.

    if ( !NlpSamInitialized)
    {
        Status = NlSamInitialize( SAM_STARTUP_TIME );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Check to see if the name provided is a domain name. If it has no
    // leading "\\" and does not match the name of the computer, it may be.
    //

    if ((( ClientNetbiosDomain.Length < 3 * sizeof(WCHAR)) ||
        ( ClientNetbiosDomain.Buffer[0] != L'\\' &&
          ClientNetbiosDomain.Buffer[1] != L'\\' ) ) &&
          !RtlEqualDomainName(
                   &NlpComputerName,
                   &ClientNetbiosDomain )) {

        //
        // Check if we are a DC in this domain.
        //  If so, use this DC.
        //

        if ( !NlpWorkstation &&
                   RtlEqualDomainName(
                       &NlpSamDomainName,
                       &ClientNetbiosDomain )) {

            DCNameString = NlpComputerName;
        }

        if (DCNameString.Buffer == NULL) {

            if ( ClientDnsDomain.Length != 0 ) {
                ClientDsGetDcDomain = &ClientDnsDomain;
            } else {
                ClientDsGetDcDomain = &ClientNetbiosDomain;
            }

            //
            // Build a zero terminated domain name.
            //

            DomainName = I_NtLmAllocate(
                            ClientDsGetDcDomain->Length + sizeof(WCHAR)
                            );

            if ( DomainName == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory( DomainName,
                           ClientDsGetDcDomain->Buffer,
                           ClientDsGetDcDomain->Length );
            DomainName[ClientDsGetDcDomain->Length / sizeof(WCHAR)] = 0;

            NetStatus = DsGetDcNameW(
                                NULL,
                                DomainName,
                                NULL,           // no domain guid
                                NULL,           // no site name
                                DS_WRITABLE_REQUIRED,
                                &DCInfo );

            if ( NetStatus != NERR_Success ) {
                SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW returned 0x%lx.\n",
                    NetStatus));

                Status = NetpApiStatusToNtStatus( NetStatus );
                if( Status == STATUS_INTERNAL_ERROR )
                    Status = STATUS_NO_SUCH_DOMAIN;
            } else {
                RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );
            }

            AttemptRediscovery = TRUE;
        }

        if (NT_SUCCESS(Status)) {

            Status = MspChangePassword(
                         &DCNameString,
                         &ClientName,
                         &ChangePasswordRequest->OldPassword,
                         &ChangePasswordRequest->NewPassword,
                         ClientRequest,
                         ChangePasswordRequest->Impersonating,
                         &DomainPasswordInfo,
                         NULL,
                         &Authoritative );

            //
            // If we succeeded or got back an authoritative answer
            if ( NT_SUCCESS(Status) || Authoritative) {
                goto PasswordChangeSuccessfull;
            }
        }
    }

    //
    // Free the DC info so we can call DsGetDcName again.
    //

    if ( DCInfo != NULL ) {
        NetApiBufferFree(DCInfo);
        DCInfo = NULL;
    }

    //
    // attempt re-discovery.
    //

    if( AttemptRediscovery ) {

        NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain guid
                            NULL,           // no site name
                            DS_FORCE_REDISCOVERY | DS_WRITABLE_REQUIRED,
                            &DCInfo );

        if ( NetStatus != NERR_Success ) {

            SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW (re-discover) returned 0x%lx.\n",
                NetStatus));

            DCInfo = NULL;
            Status = NetpApiStatusToNtStatus( NetStatus );
            if( Status == STATUS_INTERNAL_ERROR )
                Status = STATUS_NO_SUCH_DOMAIN;
        } else {
            RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );

            Status = MspChangePassword(
                         &DCNameString,
                         &ClientName,
                         &ChangePasswordRequest->OldPassword,
                         &ChangePasswordRequest->NewPassword,
                         ClientRequest,
                         ChangePasswordRequest->Impersonating,
                         &DomainPasswordInfo,
                         NULL,
                         &Authoritative );

            //
            // If we succeeded or got back an authoritative answer
            if ( NT_SUCCESS(Status) || Authoritative) {
                goto PasswordChangeSuccessfull;
            }

            //
            // Free the DC info so we can call DsGetDcName again.
            //

            if ( DCInfo != NULL ) {
                NetApiBufferFree(DCInfo);
                DCInfo = NULL;
            }
        }
    }

    if (Status != STATUS_BACKUP_CONTROLLER) {
        //
        // Change the password assuming the DomainName is really a server name
        //
        // The domain name is overloaded to be either a domain name or a server
        // name.  The server name is useful when changing the password on a LM2.x
        // standalone server, which is a "member" of a domain but uses a private
        // account database.
        //

        Status = MspChangePassword(
                     &ClientNetbiosDomain,
                     &ClientName,
                     &ChangePasswordRequest->OldPassword,
                     &ChangePasswordRequest->NewPassword,
                     ClientRequest,
                     ChangePasswordRequest->Impersonating,
                     &DomainPasswordInfo,
                     &PrimaryDomainInfo,
                     &Authoritative );

        //
        // If DomainName is actually a server name,
        //  just return the status to the caller.
        //

        if ( Authoritative &&
             ( Status != STATUS_BAD_NETWORK_PATH ||
               ( ClientNetbiosDomain.Length >= 3 * sizeof(WCHAR) &&
                 ClientNetbiosDomain.Buffer[0] == L'\\' &&
                 ClientNetbiosDomain.Buffer[1] == L'\\' ) ) ) {

            //
            // If \\xxx was specified, but xxx doesn't exist,
            //  return the status code that the DomainName field is bad.
            //

            if ( Status == STATUS_BAD_NETWORK_PATH ) {
                Status = STATUS_NO_SUCH_DOMAIN;
            }
        }

        //
        // If we didn't get an error that this was a backup controller,
        // we are out of here.
        //

        if (Status != STATUS_BACKUP_CONTROLLER) {
            goto PasswordChangeSuccessfull;
        }
    }

    //
    // If the specified machine was a BDC in a domain,
    //    Pretend the caller passed us the domain name in the first place.
    //

    if ( Status == STATUS_BACKUP_CONTROLLER && PrimaryDomainInfo != NULL ) {

        ClientNetbiosDomain = PrimaryDomainInfo->Name;
        Status = STATUS_BAD_NETWORK_PATH;
    } else {
        goto PasswordChangeSuccessfull;
    }

    //
    // Build a zero terminated domain name.
    //

    // BUGBUG: Should really pass both names to internal version of DsGetDcName
    if ( ClientDnsDomain.Length != 0 ) {
        ClientDsGetDcDomain = &ClientDnsDomain;
    } else {
        ClientDsGetDcDomain = &ClientNetbiosDomain;
    }

    if( DomainName )
    {
        I_NtLmFree( DomainName );
    }

    DomainName = I_NtLmAllocate(
                    ClientDsGetDcDomain->Length + sizeof(WCHAR)
                    );

    if ( DomainName == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory( DomainName,
                   ClientDsGetDcDomain->Buffer,
                   ClientDsGetDcDomain->Length );
    DomainName[ClientDsGetDcDomain->Length / sizeof(WCHAR)] = 0;

    AttemptRediscovery = FALSE;

retry:
    {
        DWORD dwGetDcFlags = 0;

        if( AttemptRediscovery )
            dwGetDcFlags |= DS_FORCE_REDISCOVERY;

        //
        // Determine the PDC of the named domain so we can change the password there.
        //

        NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain guid
                            NULL,           // no site name
                            dwGetDcFlags | DS_WRITABLE_REQUIRED,
                            &DCInfo );

        if ( NetStatus != NERR_Success ) {

            SspPrint(( SSP_CRITICAL, "MspLm20ChangePassword: DsGetDcNameW returned 0x%lx.\n",
                NetStatus));

            Status = NetpApiStatusToNtStatus( NetStatus );
            if( Status == STATUS_INTERNAL_ERROR )
                Status = STATUS_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        RtlInitUnicodeString( &DCNameString, DCInfo->DomainControllerName );

        Status = MspChangePassword(
                     &DCNameString,
                     &ClientName,
                     &ChangePasswordRequest->OldPassword,
                     &ChangePasswordRequest->NewPassword,
                     ClientRequest,
                     ChangePasswordRequest->Impersonating,
                     &DomainPasswordInfo,
                     NULL,
                     &Authoritative );

        if( !NT_SUCCESS(Status) && !Authoritative && !AttemptRediscovery ) {
            AttemptRediscovery = TRUE;
            goto retry;
        }
    }

PasswordChangeSuccessfull:

    //
    // Allocate and initialize the response buffer.
    //

    SavedStatus = Status;

    *ReturnBufferSize = sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE),
                                      *ReturnBufferSize );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(("MSV1_0: MspLm20ChangePassword: cannot alloc client buffer\n"));
        *ReturnBufferSize = 0;
        goto Cleanup;
    }

    ChangePasswordResponse = (PMSV1_0_CHANGEPASSWORD_RESPONSE) ClientBufferDesc.MsvBuffer;

    ChangePasswordResponse->MessageType = MsV1_0ChangePassword;


    //
    // Copy the DomainPassword restrictions out to the caller depending on
    //  whether it was passed to us.
    //
    // Mark the buffer as valid or invalid to let the caller know.
    //
    // if STATUS_PASSWORD_RESTRICTION is returned.  This status can be
    // returned by either SAM or a down-level change.  Only SAM will return
    // valid data so we have a flag in the buffer that says whether the data
    // is valid or not.
    //

    if ( DomainPasswordInfo == NULL ) {
        ChangePasswordResponse->PasswordInfoValid = FALSE;
    } else {
        ChangePasswordResponse->DomainPasswordInfo = *DomainPasswordInfo;
        ChangePasswordResponse->PasswordInfoValid = TRUE;
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

    //
    // Update cached credentials with the new password.
    //
    // This is done by calling NlpChangePassword,
    // which takes encrypted passwords, so encrypt 'em.
    //

    if ( NT_SUCCESS(SavedStatus) ) {
        BOOLEAN Impersonating;
        NTSTATUS TempStatus;

        //
        // Failure of NlpChangePassword is OK, that means that the
        // account we've been working with isn't the one we're
        // caching credentials for.
        //

        TempStatus = NlpChangePassword(
                        &ClientNetbiosDomain,
                        &ClientName,
                        &ChangePasswordRequest->NewPassword
                        );

        //
        // for ChangeCachedPassword, set the ProtocolStatus if an error
        // occured updating.
        //

        if ( !NT_SUCCESS(TempStatus) &&
            (ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword)
            )
        {
            SavedStatus = TempStatus;
        }

        //
        // Notify the LSA itself of the password change
        //

        Impersonating = FALSE;

        if ( ChangePasswordRequest->Impersonating ) {
            TempStatus = Lsa.ImpersonateClient();

            if ( NT_SUCCESS(TempStatus)) {
                Impersonating = TRUE;
            }
        }

        LsaINotifyPasswordChanged(
                    &ClientNetbiosDomain,
                    &ClientName,
                    ClientDnsDomain.Length == 0 ? NULL : &ClientDnsDomain,
                    ClientUpn.Length == 0 ? NULL : &ClientUpn,
                    ChangePasswordRequest->MessageType == MsV1_0ChangeCachedPassword ?
                        NULL :
                        &ChangePasswordRequest->OldPassword,
                    &ChangePasswordRequest->NewPassword,
                    Impersonating );

        if ( Impersonating ) {
            RevertToSelf();
        }
    }

    Status = SavedStatus;

Cleanup:


    //
    // Free Locally allocated resources
    //

    if (DomainName != NULL) {
        I_NtLmFree(DomainName);
    }

    if ( DCInfo != NULL ) {
        NetApiBufferFree(DCInfo);
    }

    if ( WkstaInfo100 != NULL ) {
        NetApiBufferFree(WkstaInfo100);
    }

    if ( DomainPasswordInfo != NULL ) {
        SamFreeMemory(DomainPasswordInfo);
    }

    if ( PrimaryDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( PrimaryDomainInfo );
    }


    if ( DsHandle != NULL) {
        DsUnBindW(
            &DsHandle
            );
    }

    //
    // Free Policy Server Role Information if used.
    //

    if (PolicyLsaServerRoleInfo != NULL) {

        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyLsaServerRoleInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyLsaServerRoleInfo
            );
    }

    //
    // Free the return buffer.
    //

    NlpFreeClientBuffer( &ClientBufferDesc );

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated ) {
        RtlEraseUnicodeString( &ChangePasswordRequest->OldPassword );
        RtlEraseUnicodeString( &ChangePasswordRequest->NewPassword );
    }

    //
    // Flush the log to disk
    //

    MsvPaswdSetAndClearLog();

#if _WIN64

    //
    // Do this last since some of the cleanup code above may refer to addresses
    // inside the pTempSubmitBuffer/ProtocolSubmitBuffer (e.g., erasing the old
    // and new passwords, etc).
    //

    if (fAllocatedSubmitBuffer)
    {
        NtLmFreePrivateHeap( pTempSubmitBuffer );
    }

#endif  // _WIN64

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msvsam.c ===
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    msvsam.c

Abstract:

    Sam account validation interface.

    These routines are shared by the MSV authentication package and
    the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 15-Jan-1992

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\msvsam.c
    JClark                 28-Jun-2000    Added WMI Trace Logging Support
                                          Fixed bug 73583 - Password Expiration and Subauth DLLs

--*/

#include <global.h>
#undef EXTERN

#include "msp.h"
#include "nlp.h"
#include <stddef.h>     // offsetof()
#include <msaudite.h>   // SE_AUDITID_xxx
#include "trace.h"        // WMI Tracing goo



///////////////////////////////////////////////////////////////////////
//                                                                   //
// SubAuth package zero helper routine                               //
//                                                                   //
///////////////////////////////////////////////////////////////////////


NTSTATUS
Msv1_0SubAuthenticationRoutineZero(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );


BOOLEAN
MsvpLm3ValidateResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response
    )
{
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
    ULONG i;

    // compute the response again

    MsvpLm3Response (
                pNtOwfPassword,
                pUserName,
                pLogonDomainName,
                ChallengeToClient,
                pLm3Response,
                Response
                );

    // compare with what we were passed
    i = (ULONG)RtlCompareMemory(
                pLm3Response->Response,
                Response,
                MSV1_0_NTLM3_RESPONSE_LENGTH);

    return (i == MSV1_0_NTLM3_RESPONSE_LENGTH);
}


BOOLEAN
MsvpNtlm3ValidateResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    IN ULONG Ntlm3ResponseLength,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
    ULONG i;
    LARGE_INTEGER Time;
    NTSTATUS Status;
    const LONGLONG TicksPerSecond = 10*1000*1000;    // 100 ns ticks per second

    // check version numbers

    if (pNtlm3Response->RespType > 1 ||
        pNtlm3Response->HiRespType < 1)
        return FALSE;

    // check that the timestamp isn't too old
    Status = NtQuerySystemTime ( &Time );
    ASSERT( NT_SUCCESS(Status) );

#ifndef USE_CONSTANT_CHALLENGE
    // make sure time hasn't expired
    // don't forget that client's clock could be behind ours
    if (Time.QuadPart > (LONGLONG)pNtlm3Response->TimeStamp) {
        if (Time.QuadPart - (LONGLONG)pNtlm3Response->TimeStamp >
            (MSV1_0_MAX_NTLM3_LIFE*TicksPerSecond))
            return FALSE;
    } else if ((LONGLONG)pNtlm3Response->TimeStamp - Time.QuadPart >
        (MSV1_0_MAX_NTLM3_LIFE*TicksPerSecond)) {
        return FALSE;
    }
#endif

    // compute the response itself

    MsvpNtlm3Response (
                pNtOwfPassword,
                pUserName,
                pLogonDomainName,
                (Ntlm3ResponseLength-sizeof(MSV1_0_NTLM3_RESPONSE)),
                ChallengeToClient,
                pNtlm3Response,
                Response,
                UserSessionKey,
                LmSessionKey
                );

    // compare with what we were passed
    i = (ULONG)RtlCompareMemory(
                pNtlm3Response->Response,
                Response,
                (size_t)MSV1_0_NTLM3_RESPONSE_LENGTH);

    return (i == MSV1_0_NTLM3_RESPONSE_LENGTH);
}



BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called directly from the MSV Authentication package
    on any system where LanMan is not installed.  This routine is called
    from the Netlogon Service otherwise.

Arguments:

    UasCompatibilityRequired -- True, if UAS compatibility is required.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    Passwords -- Specifies the passwords for the user account.

    UserFlags -- Returns flags identifying how the password was validated.
        Returns LOGON_NOENCRYPTION if the password wasn't encrypted
        Returns LOGON_USED_LM_PASSWORD if the LM password from SAM was used.

    UserSessionKey -- Returns the NT User session key for this network logon
        session.

    LmSessionKey -- Returns the LM compatible session key for this network
        logon session.

Return Value:

    TRUE -- Password validation is successful
    FALSE -- Password validation failed

--*/
{
    NTSTATUS Status;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PNETLOGON_INTERACTIVE_INFO LogonInteractiveInfo;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    BOOLEAN AlreadyValidated = FALSE;
    BOOLEAN TryLmResponse = TRUE;
    UNICODE_STRING NullUnicodeString;

    ULONG NtLmProtocolSupported;

    //
    // Initialization.
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;
    *UserFlags = LOGON_NTLMV2_ENABLED;
    RtlZeroMemory( UserSessionKey, sizeof(*UserSessionKey) );
    RtlZeroMemory( LmSessionKey, sizeof(*LmSessionKey) );
    RtlInitUnicodeString( &NullUnicodeString, NULL );

    //
    // Ensure the OWF password is always defined
    //

    if ( !Passwords->NtPasswordPresent ){
        RtlCopyMemory( &Passwords->NtOwfPassword,
                       &NlpNullNtOwfPassword,
                       sizeof(Passwords->NtOwfPassword) );
    }

    if ( !Passwords->LmPasswordPresent ){
        RtlCopyMemory( &Passwords->LmOwfPassword,
                       &NlpNullLmOwfPassword,
                       sizeof(Passwords->LmOwfPassword) );
    }

    //
    // Handle interactive/service validation.
    //
    // Simply compare the OWF password passed in with the one from the
    // SAM database.
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        ASSERT( offsetof( NETLOGON_INTERACTIVE_INFO, LmOwfPassword)
            ==  offsetof( NETLOGON_SERVICE_INFO, LmOwfPassword) );
        ASSERT( offsetof( NETLOGON_INTERACTIVE_INFO, NtOwfPassword)
            ==  offsetof( NETLOGON_SERVICE_INFO, NtOwfPassword) );

        LogonInteractiveInfo =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        //
        // If we're in UasCompatibilityMode,
        //  and we don't have the NT password in SAM (but do have LM password),
        //  validate against the LM version of the password.
        //

        if ( UasCompatibilityRequired &&
             !Passwords->NtPasswordPresent &&
             Passwords->LmPasswordPresent ) {

            if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                   &LogonInteractiveInfo->LmOwfPassword,
                                   LM_OWF_PASSWORD_LENGTH ) !=
                                   LM_OWF_PASSWORD_LENGTH ) {

                return FALSE;
            }
            *UserFlags |= LOGON_USED_LM_PASSWORD;

        //
        // In all other circumstances, use the NT version of the password.
        //  This enforces case sensitivity.
        //

        } else {

            if ( RtlCompareMemory( &Passwords->NtOwfPassword,
                                   &LogonInteractiveInfo->NtOwfPassword,
                                   NT_OWF_PASSWORD_LENGTH ) !=
                                   NT_OWF_PASSWORD_LENGTH ) {

                return FALSE;
            }
        }

        break;


    //
    // Handle network logon validation.
    //

    case NetlogonNetworkInformation:


        //
        // First, assume the passed password information is a challenge
        // response.
        //


        LogonNetworkInfo =
            (PNETLOGON_NETWORK_INFO) LogonInformation;

        // If the NT response is an NTLM3 response, do NTLM3 or NTLM3 with LM OWF
        //  if the length is > NT_RESPONSE_LENGTH, then it's an NTLM3 response

        if (LogonNetworkInfo->NtChallengeResponse.Length > NT_RESPONSE_LENGTH) {

            AlreadyValidated =  MsvpNtlm3ValidateResponse (
                &Passwords->NtOwfPassword,
                &LogonNetworkInfo->Identity.UserName,
                &LogonNetworkInfo->Identity.LogonDomainName,
                (PUCHAR)&LogonNetworkInfo->LmChallenge,
                (PMSV1_0_NTLM3_RESPONSE) LogonNetworkInfo->NtChallengeResponse.Buffer,
                LogonNetworkInfo->NtChallengeResponse.Length,
                UserSessionKey,
                LmSessionKey
                );

            //
            // because a Subauth may have been used, we will only return failure
            // here if we know the request was NTLMv2.
            //

            if( AlreadyValidated ||
                (LogonNetworkInfo->Identity.ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) ) {
                return AlreadyValidated;
            }
        }

        //
        // check the LM3 response based on NT OWF hash next
        //  this will be recieved from Win9x server with NTLMv2 client
        //

        if (LogonNetworkInfo->LmChallengeResponse.Length == NT_RESPONSE_LENGTH) {

            AlreadyValidated = MsvpLm3ValidateResponse (
                &Passwords->NtOwfPassword,
                &LogonNetworkInfo->Identity.UserName,
                &LogonNetworkInfo->Identity.LogonDomainName,
                (PUCHAR)&LogonNetworkInfo->LmChallenge,
                (PMSV1_0_LM3_RESPONSE) LogonNetworkInfo->LmChallengeResponse.Buffer
                );

            if (AlreadyValidated)
                return TRUE;
        }

        NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;

        // if we're requiring all clients (Win9x and NT) to have been upgraded, fail out now
        //if (NtLmProtocolSupported >= RefuseNtlm)
            //return FALSE;

        // if that fails, check the NTLM response if there is one of the
        //  appropriate size in either NT response or LM response
        if (!AlreadyValidated &&
            (NtLmProtocolSupported < RefuseNtlm) &&
            (Passwords->NtPasswordPresent || (!Passwords->NtPasswordPresent && !Passwords->LmPasswordPresent)) &&
            (LogonNetworkInfo->NtChallengeResponse.Length == NT_RESPONSE_LENGTH ||
            LogonNetworkInfo->LmChallengeResponse.Length == NT_RESPONSE_LENGTH)) {

            NT_RESPONSE NtResponse;

            //
            // NT response is present and hash exists, don't try the LM respnose.
            //

            if( LogonNetworkInfo->NtChallengeResponse.Length == NT_RESPONSE_LENGTH )
            {
                TryLmResponse = FALSE;
            }

            //
            // Compute what the response should be.
            //

            Status = RtlCalculateNtResponse(
                        &LogonNetworkInfo->LmChallenge,
                        &Passwords->NtOwfPassword,
                        &NtResponse );

            if ( NT_SUCCESS(Status) ) {

                //
                // If the responses match, the passwords are valid.
                //  Try the NT response first, then the LM response
                //

                if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        NtChallengeResponse.Buffer,
                      &NtResponse,
                      LogonNetworkInfo->NtChallengeResponse.Length ) ==
                      NT_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;

                } else if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        LmChallengeResponse.Buffer,
                      &NtResponse,
                      LogonNetworkInfo->LmChallengeResponse.Length ) ==
                      NT_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;
                }
            }
        }

        // if we're requiring all Win9x clients to have been upgraded, fail out now
        //if (!AlreadyValidated && NtLmProtocolSupported >= RefuseLm)
        //    return FALSE;

        //
        //  if the LM response is the right size
        //  validate against the LM version of the response
        //  this applies also when both NTOWF and LMOWF are not present in SAM.
        //

        if (!AlreadyValidated &&
            ( TryLmResponse ) &&
            ( NtLmProtocolSupported < RefuseLm ) &&
            ( LogonNetworkInfo->LmChallengeResponse.Length == LM_RESPONSE_LENGTH ) &&
            ( (Passwords->LmPasswordPresent) || (!Passwords->LmPasswordPresent && !Passwords->NtPasswordPresent) )
            ) {

            LM_RESPONSE LmResponse;

            //
            // Compute what the response should be.
            //

            Status = RtlCalculateLmResponse(
                        &LogonNetworkInfo->LmChallenge,
                        &Passwords->LmOwfPassword,
                        &LmResponse );

            if ( NT_SUCCESS(Status) ) {

                //
                // If the responses match, the passwords are valid.
                //

                if ( RtlCompareMemory(
                      LogonNetworkInfo->
                        LmChallengeResponse.Buffer,
                      &LmResponse,
                      LM_RESPONSE_LENGTH ) ==
                      LM_RESPONSE_LENGTH ) {

                    AlreadyValidated = TRUE;
                    *UserFlags |= LOGON_USED_LM_PASSWORD;
                }
            }
        }

        //
        // If we haven't already validated this user,
        //  Validate a Cleartext password on a Network logon request.
        //

        if ( !AlreadyValidated ) {

            // If Cleartext passwords are not allowed,
            //  indicate the password doesn't match.
            //

            if((LogonInfo->ParameterControl & CLEARTEXT_PASSWORD_ALLOWED) == 0){
                return FALSE;
            }


            //
            // Compute the OWF password for the specified Cleartext password and
            // compare that to the OWF password retrieved from SAM.
            //

            //
            // If we're in UasCompatibilityMode,
            //  and we don't have the NT password in SAM or
            //      we don't have the NT password supplied by the caller.
            //  validate against the LM version of the password.
            //
            // if neither password are present, we validate against
            // the empty computed LMOWF.
            //

            if ( UasCompatibilityRequired &&
                 (NtLmProtocolSupported < RefuseLm) &&
                 ((Passwords->LmPasswordPresent) || (!Passwords->LmPasswordPresent && !Passwords->NtPasswordPresent)) &&
                 (!Passwords->NtPasswordPresent ||
                 LogonNetworkInfo->NtChallengeResponse.Length == 0 ) ) {

                LM_OWF_PASSWORD LmOwfPassword;
                CHAR LmPassword[LM20_PWLEN+1];
                USHORT i;


                //
                // Compute the LmOwfPassword for the cleartext password passed in.
                //  (Enforce length restrictions on LanMan compatible passwords.)
                //

                if ( LogonNetworkInfo->LmChallengeResponse.Length >
                    sizeof(LmPassword) ) {
                    return FALSE;
                }

                RtlZeroMemory( &LmPassword, sizeof(LmPassword) );

                for (i = 0; i < LogonNetworkInfo->LmChallengeResponse.Length; i++) {
                    LmPassword[i] =
                      RtlUpperChar(LogonNetworkInfo->LmChallengeResponse.Buffer[i]);
                }

                (VOID) RtlCalculateLmOwfPassword( LmPassword, &LmOwfPassword );

                if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                       &LmOwfPassword,
                                       LM_OWF_PASSWORD_LENGTH ) !=
                                       LM_OWF_PASSWORD_LENGTH ) {

                    //
                    // Try the case preserved clear text password, too.
                    //  (I know of no client that does this,
                    //  but it is compatible with the LM 2.x server.)
                    //

                    RtlZeroMemory( &LmPassword, sizeof(LmPassword) );
                    RtlCopyMemory(
                        &LmPassword,
                        LogonNetworkInfo->LmChallengeResponse.Buffer,
                        LogonNetworkInfo->LmChallengeResponse.Length);

                    (VOID) RtlCalculateLmOwfPassword( LmPassword,
                                                      &LmOwfPassword );

                    if ( RtlCompareMemory( &Passwords->LmOwfPassword,
                                           &LmOwfPassword,
                                           LM_OWF_PASSWORD_LENGTH ) !=
                                           LM_OWF_PASSWORD_LENGTH ) {

                        return FALSE;
                    }

                }

                *UserFlags |= LOGON_USED_LM_PASSWORD;


            //
            // In all other circumstances, use the NT version of the password.
            //  This enforces case sensitivity.
            //

            } else {
                NT_OWF_PASSWORD NtOwfPassword;


                //
                // Compute the NtOwfPassword for the cleartext password passed in.
                //

                Status = RtlCalculateNtOwfPassword(
                             (PUNICODE_STRING)
                                &LogonNetworkInfo->NtChallengeResponse,
                             &NtOwfPassword );

                if ( RtlCompareMemory( &Passwords->NtOwfPassword,
                                       &NtOwfPassword,
                                       NT_OWF_PASSWORD_LENGTH ) !=
                                       NT_OWF_PASSWORD_LENGTH ) {

                    return FALSE;
                }
            }

            *UserFlags |= LOGON_NOENCRYPTION;
        }

        //
        // ASSERT: the network logon has been authenticated
        //
        //  Compute the session keys.

        //
        // If the client negotiated a non-NT protocol,
        //  use the lanman session key as the UserSessionKey.
        //

        if ( LogonNetworkInfo->NtChallengeResponse.Length == 0 ) {

            ASSERT( sizeof(*UserSessionKey) >= sizeof(*LmSessionKey) );

            RtlCopyMemory( UserSessionKey,
                           &Passwords->LmOwfPassword,
                           sizeof(*LmSessionKey) );

        } else {

            //
            // Return the NT UserSessionKey unless this is an account
            //  that doesn't have the NT version of the password.
            //  (A null password counts as a password).
            //

            if ( Passwords->NtPasswordPresent || !Passwords->LmPasswordPresent){

                Status = RtlCalculateUserSessionKeyNt(
                            (PNT_RESPONSE) NULL,    // Argument not used
                            &Passwords->NtOwfPassword,
                            UserSessionKey );

                ASSERT( NT_SUCCESS(Status) );
            }
        }

        //
        // Return the LM SessionKey unless this is an account
        //  that doesn't have the LM version of the password.
        //  (A null password counts as a password).
        //

        if ( Passwords->LmPasswordPresent || !Passwords->NtPasswordPresent ) {
            RtlCopyMemory( LmSessionKey,
                           &Passwords->LmOwfPassword,
                           sizeof(*LmSessionKey) );
        }

        break;

    //
    // Any other LogonLevel is an internal error.
    //
    default:
        return FALSE;

    }

    return TRUE;
}


BOOLEAN
MsvpEqualSidPrefix(
    IN PSID DomainSid,
    IN PSID GroupSid
    )
/*++

Routine Description:

    This routine checks to see if the specified group sid came from the
    specified domain by verifying that the domain portion of the group sid
    is equal to the domain sid.

Arguments:

    DomainSid - Sid of the domain for comparison.

    GroupSid - Sid of the group for comparison

Returns:

    TRUE - The group sid came from the specified domain.
    FALSE - The group sid did not come from the specified domain.

--*/
{
    PISID LocalGroupSid = (PISID) GroupSid;
    PISID LocalDomainSid = (PISID) DomainSid;
    if ((LocalGroupSid->SubAuthorityCount == LocalDomainSid->SubAuthorityCount + 1) &&
        RtlEqualMemory(
            RtlIdentifierAuthoritySid(LocalDomainSid),
            RtlIdentifierAuthoritySid(LocalGroupSid),
            RtlLengthRequiredSid(
                LocalDomainSid->SubAuthorityCount
                ) - FIELD_OFFSET(SID,IdentifierAuthority)
            )) {
        return(TRUE);
    }
    return(FALSE);
}

NTSTATUS
MsvpFilterGroupMembership(
    IN PSID_AND_ATTRIBUTES_LIST CompleteMembership,
    IN PSID LogonDomainId,
    OUT PSAMPR_GET_GROUPS_BUFFER LocalMembership,
    OUT PSID_AND_ATTRIBUTES_LIST GlobalMembership,
    OUT PULONG GlobalMembershipSize
    )
/*++

Routine Description:

    This routine separates the complete transitive group membership into
    portions from this domain and portions from others.

Arguments:

    CompleteMembership - The complete transitive membership.

    LogonDomainId - SID of the logon domain, used for compressing group
        membership.

    LocalMembership - Receives a list of rids corresponding to groups in this
        domain. The list should be freed with MIDL_user_free.

    GlobalMembership - Recevies a list of sids corresponding to groups in
        other domain. The list, but not the sids, should be free with
        MIDL_user_free.

    GlobalMembershipSize - Size, in bytes, of the sids in the global membership
        and the size of the SID_AND_ATTRIBUTES structures.

Returns:

    STATUS_SUCCESS on success
    STATUS_INSUFFICIENT_RESOURCES on for memory allocation failures.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LocalCount = 0;
    ULONG GlobalCount = 0;
    ULONG GlobalSize = 0;
    ULONG Index;

    LocalMembership->MembershipCount = 0;
    LocalMembership->Groups = NULL;
    GlobalMembership->Count = 0;
    GlobalMembership->SidAndAttributes = NULL;


    //
    // Define a flag so we don't have to do the comparison twice.
    //

#define MSVP_LOCAL_GROUP_ATTR 0x20000000

    for (Index = 0; Index < CompleteMembership->Count ; Index++ ) {
        ASSERT((CompleteMembership->SidAndAttributes[Index].Attributes & MSVP_LOCAL_GROUP_ATTR) == 0);

        if (MsvpEqualSidPrefix(
            LogonDomainId,
            CompleteMembership->SidAndAttributes[Index].Sid
            )) {

            CompleteMembership->SidAndAttributes[Index].Attributes |= MSVP_LOCAL_GROUP_ATTR;
            LocalCount++;
        } else {

            GlobalCount++;
            GlobalSize += sizeof(SID_AND_ATTRIBUTES) + RtlLengthSid(CompleteMembership->SidAndAttributes[Index].Sid);
        }
    }

    //
    // Allocate the arrays for the output
    //

    if (LocalCount != 0)
    {
        LocalMembership->Groups = (PGROUP_MEMBERSHIP) I_NtLmAllocate(LocalCount * sizeof(GROUP_MEMBERSHIP));
        if (LocalMembership->Groups == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        LocalMembership->MembershipCount = LocalCount;
    }
    if (GlobalCount != 0)
    {
        GlobalMembership->SidAndAttributes = (PSID_AND_ATTRIBUTES) I_NtLmAllocate(GlobalCount * sizeof(SID_AND_ATTRIBUTES));
        if (GlobalMembership->SidAndAttributes == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        GlobalMembership->Count = GlobalCount;
    }

    //
    // Loop through again copy the rid or sid into the respective array
    //

    LocalCount = 0;
    GlobalCount = 0;
    for (Index = 0; Index < CompleteMembership->Count ; Index++ ) {

        if ((CompleteMembership->SidAndAttributes[Index].Attributes & MSVP_LOCAL_GROUP_ATTR) != 0) {

            LocalMembership->Groups[LocalCount].Attributes = CompleteMembership->SidAndAttributes[Index].Attributes & ~MSVP_LOCAL_GROUP_ATTR;
            LocalMembership->Groups[LocalCount].RelativeId =
                        *RtlSubAuthoritySid(
                            CompleteMembership->SidAndAttributes[Index].Sid,
                            *RtlSubAuthorityCountSid(
                                CompleteMembership->SidAndAttributes[Index].Sid
                                ) - 1
                            );
            LocalCount++;
        } else {
            GlobalMembership->SidAndAttributes[GlobalCount] = CompleteMembership->SidAndAttributes[Index];
            GlobalCount++;
        }
    }
    *GlobalMembershipSize = GlobalSize;
Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (LocalMembership->Groups != NULL)
        {
            I_NtLmFree(LocalMembership->Groups);
            LocalMembership->Groups = NULL;
        }
        if (GlobalMembership->SidAndAttributes != NULL)
        {
            I_NtLmFree(GlobalMembership->SidAndAttributes);
            GlobalMembership->SidAndAttributes = NULL;
        }
    }
    return(Status);
}


NTSTATUS
MsvpSamValidate (
    IN SAMPR_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG GuestRelativeId,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called by MsvSamValidate.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain to use to
        validate the request.

    UasCompatibilityRequired -- TRUE iff UasCompatibilityMode is on.

    SecureChannelType -- The secure channel type this request was made on.

        When netlogon on the BDC is called, the user is actually
        already authenticated (via PDC) through a prior "net use"
        from the win9x client.  Netlogon merely returns the validation
        info to the win9x caller.  To do that Netlogon calls
        MsvSamValidate passing NullSecureChannel as the 3rd parameter
        indicating to skip the password check.


    LogonServer -- Specifies the server name of the caller.

    LogonDomainName -- Specifies the domain of the caller.

    LogonDomainId  -- Specifies the DomainId of the domain of the caller.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    GuestRelativeId - If non-zero, specifies the relative ID of the account
        to validate against.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4.

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed user MIDL_user_free.
        This information is only return on STATUS_SUCCESS.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    BadPasswordCountZeroed - Returns TRUE iff we zeroed the BadPasswordCount
        field of this user.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    NTSTATUS Status;
    NTSTATUS SubAuthExStatus = STATUS_SUCCESS;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    SAMPR_HANDLE UserHandle = NULL;
    ULONG RelativeId = GuestRelativeId;
    ULONG SamFlags;
    PSID LocalSidUser = NULL;

    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL;
    SAMPR_GET_GROUPS_BUFFER GroupsBuffer;
    ULONG UserFlags = 0;
    USER_SESSION_KEY UserSessionKey;
    LM_SESSION_KEY LmSessionKey;
    ULONG WhichFields = 0;
    UNICODE_STRING LocalUserName;

    UNICODE_STRING LocalWorkstation;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING Upn;

    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordMustChange;
    LARGE_INTEGER PasswordLastSet;


    PNETLOGON_VALIDATION_SAM_INFO4 ValidationSam = NULL;
    ULONG ValidationSamSize;
    PUCHAR Where;
    ULONG Index;

    SAMPR_RETURNED_USTRING_ARRAY NameArray;
    SAMPR_ULONG_ARRAY UseArray;
    SID_AND_ATTRIBUTES_LIST GroupMembership;
    SID_AND_ATTRIBUTES_LIST GlobalGroupMembership;
    ULONG GlobalMembershipSize = 0;

    MSV1_0_VALIDATION_INFO SubAuthValidationInformation;
    BOOLEAN fSubAuthEx = FALSE;

    BOOLEAN fMachineAccount;

    ULONG ActionsPerformed = 0;

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;


    //
    // check if caller requested that logon only target specified domain.
    //

    if( LogonInfo->ParameterControl & MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY &&
        LogonInfo->LogonDomainName.Length ) {

        //
        // common case is a match for LogonDomainName, so avoid taking locks
        // until mis-match occurs.
        //

        if(!RtlEqualDomainName( &LogonInfo->LogonDomainName, LogonDomainName )) {

            WCHAR LocalTarget[ DNS_MAX_NAME_LENGTH + 1 ];
            WCHAR SpecifiedTarget[ DNS_MAX_NAME_LENGTH + 1 ];
            ULONG cchLocalTarget = 0;
            ULONG cchSpecifiedTarget = 0;

            //
            // pickup the local target name, based on whether this computer is
            // a domain controller.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if( NlpWorkstation ) {

                if( (NtLmGlobalUnicodeDnsComputerNameString.Length + sizeof(WCHAR)) <=
                    sizeof( LocalTarget ) ) {

                    RtlCopyMemory(
                                LocalTarget,
                                NtLmGlobalUnicodeDnsComputerName,
                                NtLmGlobalUnicodeDnsComputerNameString.Length
                                );

                    cchLocalTarget = (NtLmGlobalUnicodeDnsComputerNameString.Length) /
                                    sizeof(WCHAR);
                }

            } else {
                if( (NtLmGlobalUnicodeDnsDomainNameString.Length + sizeof(WCHAR)) <=
                    sizeof( LocalTarget ) ) {

                    RtlCopyMemory(
                                LocalTarget,
                                NtLmGlobalUnicodeDnsDomainName,
                                NtLmGlobalUnicodeDnsDomainNameString.Length
                                );

                    cchLocalTarget = (NtLmGlobalUnicodeDnsDomainNameString.Length) /
                                    sizeof(WCHAR);
                }

            }

            RtlReleaseResource(&NtLmGlobalCritSect);

            //
            // pull out target name.
            //

            if( (LogonInfo->LogonDomainName.Length + sizeof(WCHAR)) <= sizeof( SpecifiedTarget ) ) {

                cchSpecifiedTarget = (LogonInfo->LogonDomainName.Length) / sizeof(WCHAR);

                RtlCopyMemory(
                                SpecifiedTarget,
                                LogonInfo->LogonDomainName.Buffer,
                                LogonInfo->LogonDomainName.Length
                                );
            }

            if ( cchLocalTarget && cchSpecifiedTarget ) {

                LocalTarget[ cchLocalTarget ] = L'\0';
                SpecifiedTarget[ cchSpecifiedTarget ] = L'\0';

                if(!DnsNameCompare_W( LocalTarget, SpecifiedTarget ) ) {
                    *Authoritative = FALSE;
                    return STATUS_NO_SUCH_USER;
                }
            }
        }
    }


    //
    // Initialization.
    //

    RtlZeroMemory(
        &SubAuthValidationInformation,
        sizeof(MSV1_0_VALIDATION_INFO));

    SubAuthValidationInformation.Authoritative = TRUE;
    SubAuthValidationInformation.WhichFields = 0;
    NameArray.Count = 0;
    NameArray.Element = NULL;
    UseArray.Count = 0;
    UseArray.Element = NULL;
    *BadPasswordCountZeroed = FALSE;
    GroupMembership.Count = 0;
    GroupMembership.SidAndAttributes = NULL;
    GlobalGroupMembership.Count = 0;
    GlobalGroupMembership.SidAndAttributes = NULL;
    GroupsBuffer.MembershipCount = 0;
    GroupsBuffer.Groups = NULL;

    RtlInitUnicodeString( &Upn, NULL );

    (VOID) NtQuerySystemTime( &LogonTime );


    //
    // Determine what account types are valid.
    //
    // Normal user accounts are always allowed.
    //

    UserAccountControl = USER_NORMAL_ACCOUNT;

    *Authoritative = TRUE;

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        break;

    case NetlogonNetworkInformation:
        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( SecureChannelType == MsvApSecureChannel ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        //
        // Machine accounts can be accessed on network connections.
        //

        UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT |
                              USER_WORKSTATION_TRUST_ACCOUNT |
                              USER_SERVER_TRUST_ACCOUNT;

        break;

    default:
        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }


    //
    // Check the ValidationLevel
    //

    switch (ValidationLevel) {
    case NetlogonValidationSamInfo:
    case NetlogonValidationSamInfo2:
    case NetlogonValidationSamInfo4:
        break;

    default:

        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }




    //
    // Convert the user name to a RelativeId.
    //

    if ( RelativeId != 0 ) {

        UCHAR cDomainSubAuthorities;
        UCHAR SubAuthIndex;
        ULONG cbLocalSidUser;
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;

        //
        // build a Sid out of the DomainId and the supplied Rid.
        //

        cDomainSubAuthorities = *RtlSubAuthorityCountSid( LogonDomainId );
        pIdentifierAuthority = RtlIdentifierAuthoritySid( LogonDomainId );

        cbLocalSidUser = RtlLengthRequiredSid( (ULONG)(cDomainSubAuthorities + 1) );
        LocalSidUser = I_NtLmAllocate( cbLocalSidUser );
        if (LocalSidUser == NULL) {
            *Authoritative = FALSE;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = RtlInitializeSid(LocalSidUser, pIdentifierAuthority, (UCHAR)((DWORD)cDomainSubAuthorities+1));
        if(!NT_SUCCESS(Status)) {
            *Authoritative = FALSE;
            goto Cleanup;
        }

        //
        // loop copying subauthorities.
        //

        for( SubAuthIndex = 0 ; SubAuthIndex < cDomainSubAuthorities ; SubAuthIndex++ )
        {
            *RtlSubAuthoritySid( LocalSidUser, (ULONG)SubAuthIndex ) =
            *RtlSubAuthoritySid( LogonDomainId, (ULONG)SubAuthIndex );
        }

        //
        // append relative ID.
        //

        *RtlSubAuthoritySid(LocalSidUser, cDomainSubAuthorities) = RelativeId;

        LocalUserName.Buffer = LocalSidUser;
        LocalUserName.Length = (USHORT)cbLocalSidUser;
        LocalUserName.MaximumLength = (USHORT)cbLocalSidUser;

        SamFlags = SAM_OPEN_BY_SID;
    } else {
        LocalUserName = LogonInfo->UserName;
        SamFlags = 0;
    }


    //
    // if this is a domain controller, and, we get a logon request that
    // looks like a possible UPN, set the flag...
    //

    if( (SamFlags == 0) &&
        (LogonInfo->LogonDomainName.Buffer == NULL) &&
        !NlpWorkstation
        )
    {
        SamFlags |= SAM_OPEN_BY_UPN_OR_ACCOUNTNAME;
    }


    //
    // Open the user account.
    //

    if (( LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL ) ||
        ( LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX ) ||
        NlpSubAuthZeroExists ) {

        //
        // Fetch all attributes in the presence of a subauthentication DLL
        //

        Status = I_SamIGetUserLogonInformation(
                    DomainHandle,
                    SamFlags,
                    &LocalUserName,
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );

    } else {
    
        //
        // Performance optimization:
        // Fetch only select attributes in the absence of a subauthentication DLL
        //

        Status = I_SamIGetUserLogonInformationEx(
                    DomainHandle,
                    SamFlags,
                    &LocalUserName,
                    USER_ALL_ACCOUNTEXPIRES |
                    USER_ALL_BADPASSWORDCOUNT |
                    USER_ALL_FULLNAME |
                    USER_ALL_HOMEDIRECTORY |
                    USER_ALL_HOMEDIRECTORYDRIVE |
                    USER_ALL_LASTLOGON |
                    USER_ALL_LMPASSWORDPRESENT |
                    USER_ALL_LOGONCOUNT |
                    USER_ALL_LOGONHOURS |
                    USER_ALL_NTPASSWORDPRESENT |
                    USER_ALL_OWFPASSWORD |
                    USER_ALL_PARAMETERS |
                    USER_ALL_PASSWORDCANCHANGE |
                    USER_ALL_PASSWORDLASTSET |
                    USER_ALL_PASSWORDMUSTCHANGE |
                    USER_ALL_PRIMARYGROUPID |
                    USER_ALL_PROFILEPATH |
                    USER_ALL_SCRIPTPATH |
                    USER_ALL_USERACCOUNTCONTROL |
                    USER_ALL_USERID |
                    USER_ALL_USERNAME |
                    USER_ALL_WORKSTATIONS,
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );
    }

    if ( !NT_SUCCESS(Status) ) {
        UserHandle = NULL;
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }


    if( !NlpWorkstation )
    {
        BOOLEAN UpnDefaulted;

        //
        // get the UPN.  Ignore the failure, as, there is existing logic
        // for dealing with the lack of Upn.
        //

        I_SamIUPNFromUserHandle(
                UserHandle,
                &UpnDefaulted,
                &Upn
                );
    }

    UserAll = &UserAllInfo->All;

    if ( RelativeId != 0 )
    {
        //
        // reset LocalUserName to be an actual username rather than a Sid
        // for Guest logon.  This allows proper audit later on.
        //

        RtlCopyMemory( &LocalUserName, &UserAll->UserName, sizeof(LocalUserName) );
    }


    //
    // pickup RelativeId from looked up information.
    //

    RelativeId = UserAll->UserId;

    //
    // If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //
    // SubAuthentication packages can be more specific than this test but
    // they can't become less restrictive.
    //

    if ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // determine if machine account, if so, certain failures are treated
    // as Authoritative, to prevent fallback to guest and returning incorrect
    // error codes.
    //

    if ( (UserAll->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) != 0 ) {
        fMachineAccount = TRUE;
    } else {
        fMachineAccount = FALSE;
    }


    //
    // If there is a SubAuthentication DLL,
    //  call it to do all the authentication work.
    //

    if ( (LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL) &&
         (!(LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX))) {

        ULONG LocalUserFlags = 0;
        ULONG Flags = 0;

        //
        // Ensure the account isn't locked out.
        // We did this regardless before NT 5.0. Now, we do it when either
        // No SubAuth package is specified or
        // New SubAuth package asks us to do account lockout test
        // But, for those who call with old SubAuth packages, they will expect
        // us to do the dirty work.
        //
          
          
        if ( (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) &&
             (SecureChannelType != NullSecureChannel) )
        {
            BOOL LockOut = TRUE;
            
            if (RelativeId == DOMAIN_USER_RID_ADMIN) {            
                if(LogonLevel != NetlogonInteractiveInformation) {
                    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
                
                    Status = I_SamrQueryInformationDomain(
                                NlpSamDomainHandle,
                                DomainPasswordInformation,
                                (PSAMPR_DOMAIN_INFO_BUFFER *)&DomainPasswordInfo ); 
                    if (!NT_SUCCESS(Status)) {
                        Status = STATUS_INTERNAL_ERROR;
                        *Authoritative = TRUE;
                        goto Cleanup;         
                    }
                    if(DomainPasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS) {
                        LockOut = TRUE;
                    } else {
                        LockOut = FALSE;
                    }
                    SamFreeMemory(DomainPasswordInfo);
                } else {

                    //
                    // if the process is configured to allow over-ride
                    // (true if physical console logon), then don't enforce lockout.
                    //

                    if( NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT ) & MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT )
                    {
                        LockOut = FALSE;
                    }
                }
            }

            if(LockOut){
                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //

                if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                    *Authoritative = fMachineAccount;
                } else {
                    *Authoritative = TRUE;
                }

                Status = STATUS_ACCOUNT_LOCKED_OUT;
                goto Cleanup;

            }
        }

        if ( SecureChannelType != MsvApSecureChannel ) {
            Flags |= MSV1_0_PASSTHRU;
        }
        if ( GuestRelativeId != 0 ) {
            Flags |= MSV1_0_GUEST_LOGON;
        }

        Status = Msv1_0SubAuthenticationRoutine(
                    LogonLevel,
                    LogonInformation,
                    Flags,
                    (PUSER_ALL_INFORMATION) UserAll,
                    &WhichFields,
                    &LocalUserFlags,
                    Authoritative,
                    &LogoffTime,
                    &KickoffTime );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Sanity check what the SubAuthentication package returned
        //
        if ( (WhichFields & ~USER_ALL_PARAMETERS) != 0 ) {
            Status = STATUS_INTERNAL_ERROR;
            *Authoritative = TRUE;
            goto Cleanup;
        }

        UserFlags |= LocalUserFlags;



    } else { // we may still have an NT 5.0 SubAuth dll

        //
        // If there is an NT 5.0 SubAuthentication DLL,
        // call it to do all the authentication work.
        //

        if ( (LogonInfo->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL_EX))
        {
            ULONG LocalUserFlags = 0;
            ULONG Flags = 0;

            if ( SecureChannelType != MsvApSecureChannel ) {
                Flags |= MSV1_0_PASSTHRU;
            }
            if ( GuestRelativeId != 0 ) {
                Flags |= MSV1_0_GUEST_LOGON;
            }

            Status = Msv1_0SubAuthenticationRoutineEx(
                        LogonLevel,
                        LogonInformation,
                        Flags,
                        (PUSER_ALL_INFORMATION) UserAll,
                        (SAM_HANDLE)UserHandle,
                        &SubAuthValidationInformation,
                        &ActionsPerformed );

            *Authoritative = SubAuthValidationInformation.Authoritative;

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            // We need to do this because even if any of the following checks
            // fail, ARAP stills wants the returned blobs from the subauth
            // package to be returned to the caller.

            fSubAuthEx = TRUE;

        }

        //
        // Ensure the account isn't locked out.
        //

        if ((ActionsPerformed & MSV1_0_SUBAUTH_LOCKOUT) == 0)
        {
            if ( (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) &&
                 (SecureChannelType != NullSecureChannel) )
            {
                BOOL LockOut = TRUE;
            
                if (RelativeId == DOMAIN_USER_RID_ADMIN) {
                    if(LogonLevel != NetlogonInteractiveInformation) {
                        PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo = NULL;
                    
                        Status = I_SamrQueryInformationDomain(
                                    NlpSamDomainHandle,
                                    DomainPasswordInformation,
                                    (PSAMPR_DOMAIN_INFO_BUFFER *)&DomainPasswordInfo ); 
                        if (!NT_SUCCESS(Status)) {
                            Status = STATUS_INTERNAL_ERROR;
                            *Authoritative = TRUE;
                            goto Cleanup;         
                        }
                        if(DomainPasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS) {
                            LockOut = TRUE;
                        } else {
                            LockOut = FALSE;
                        }
                        SamFreeMemory(DomainPasswordInfo);
                    } else {

                        //
                        // if the process is configured to allow over-ride
                        // (true if physical console logon), then don't enforce lockout.
                        //

                        if( NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT ) & MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT )
                        {
                            LockOut = FALSE;
                        }
                    }
                }
                
                if (LockOut) {

                     //
                     // Since the UI strongly encourages admins to disable user
                     // accounts rather than delete them.  Treat disabled acccount as
                     // non-authoritative allowing the search to continue for other
                     // accounts by the same name.
                     //

                     if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                         *Authoritative = fMachineAccount;
                     } else {
                         *Authoritative = TRUE;
                     }

                    Status = STATUS_ACCOUNT_LOCKED_OUT;
                    goto Cleanup;
                }
            }
        }

        //
        // Check the password if there's no subauth or if subauth did
        // not already check password.
        //

        if ((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD) == 0)
        {
            if ( SecureChannelType != NullSecureChannel ) {
                USER_INTERNAL1_INFORMATION Passwords;

                //
                // Copy the password info to the right structure.
                //

                Passwords.NtPasswordPresent = UserAll->NtPasswordPresent;
                if ( UserAll->NtPasswordPresent ) {
                    Passwords.NtOwfPassword =
                        *((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));
                }

                Passwords.LmPasswordPresent = UserAll->LmPasswordPresent;
                if ( UserAll->LmPasswordPresent ) {
                    Passwords.LmOwfPassword =
                        *((PLM_OWF_PASSWORD)(UserAll->LmOwfPassword.Buffer));
                }


                //
                // If the password specified doesn't match the SAM password,
                //    then we've got a password mismatch.
                //

                if ( ! MsvpPasswordValidate (
                            UasCompatibilityRequired,
                            LogonLevel,
                            LogonInformation,
                            &Passwords,
                            &UserFlags,
                            &UserSessionKey,
                            &LmSessionKey ) ) {

                    //
                    // If this is a guest logon and the guest account has no password,
                    //  let the user log on.
                    //
                    // This special case check is after the MsvpPasswordValidate to
                    // give MsvpPasswordValidate every opportunity to compute the
                    // correct values for UserSessionKey and LmSessionKey.
                    //

                    if ( GuestRelativeId != 0 &&
                         !UserAll->NtPasswordPresent &&
                         !UserAll->LmPasswordPresent ) {

                        RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
                        RtlZeroMemory( &LmSessionKey, sizeof(LmSessionKey) );


                    //
                    // The password mismatched.  We treat STATUS_WRONG_PASSWORD as
                    // an authoritative response.  Our caller may choose to do otherwise.
                    //

                    } else {

                        Status = STATUS_WRONG_PASSWORD;

                        //
                        // Since the UI strongly encourages admins to disable user
                        // accounts rather than delete them.  Treat disabled acccount as
                        // non-authoritative allowing the search to continue for other
                        // accounts by the same name.
                        //
                        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                            *Authoritative = fMachineAccount;
                        } else {
                            *Authoritative = TRUE;
                        }

                        goto Cleanup;
                    }
                }
            }

        //
        // If SubAuth DLL checked the password, then it implicitly
        // checked the password's expiration, and we don't have to.
        //
        } else { // end if((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD) == 0)
            ActionsPerformed |= MSV1_0_SUBAUTH_PASSWORD_EXPIRY;
        }


        //
        // Check if the account is disabled if there's no subauth or if
        // subauth has not already checked.
        //


        if ((ActionsPerformed & MSV1_0_SUBAUTH_ACCOUNT_DISABLED) == 0)
        {
            if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //

                *Authoritative = fMachineAccount;
                Status = STATUS_ACCOUNT_DISABLED;
                goto Cleanup;
            }
        }

        //
        // Prevent some things from effecting the Administrator user
        //

        if (RelativeId != DOMAIN_USER_RID_ADMIN) {

            //
            // Check if the account has expired if there's no subauth or if
            // subauth has not already checked.
            //

            if ((ActionsPerformed & MSV1_0_SUBAUTH_ACCOUNT_EXPIRY) == 0)
            {
                OLD_TO_NEW_LARGE_INTEGER( UserAll->AccountExpires, AccountExpires );

                if ( AccountExpires.QuadPart != 0 &&
                    LogonTime.QuadPart >= AccountExpires.QuadPart ) {
                    *Authoritative = TRUE;
                    Status = STATUS_ACCOUNT_EXPIRED;
                    goto Cleanup;
                }
            }


            //
            // The password is valid, check to see if the password is expired.
            //  (SAM will have appropriately set PasswordMustChange to reflect
            //  USER_DONT_EXPIRE_PASSWORD)
            //
            // We only check password expiration if we also checked the password.
            //

            if ((ActionsPerformed & MSV1_0_SUBAUTH_PASSWORD_EXPIRY) == 0)
            {

              OLD_TO_NEW_LARGE_INTEGER( UserAll->PasswordMustChange, PasswordMustChange );
              OLD_TO_NEW_LARGE_INTEGER( UserAll->PasswordLastSet, PasswordLastSet );

              if ( SecureChannelType != NullSecureChannel ) {
                if ( LogonTime.QuadPart >= PasswordMustChange.QuadPart ) {

                    if ( PasswordLastSet.QuadPart == 0 ) {
                        Status = STATUS_PASSWORD_MUST_CHANGE;
                    } else {
                        Status = STATUS_PASSWORD_EXPIRED;
                    }
                    *Authoritative = TRUE;
                    goto Cleanup;
                }
              }
            }
        }

        //
        // Validate the workstation the user logged on from.
        //
        // Ditch leading \\ on workstation name before passing it to SAM.
        //

        LocalWorkstation = LogonInfo->Workstation;
        if ( LocalWorkstation.Length > 0 &&
             LocalWorkstation.Buffer[0] == L'\\' &&
             LocalWorkstation.Buffer[1] == L'\\' ) {
            LocalWorkstation.Buffer += 2;
            LocalWorkstation.Length -= 2*sizeof(WCHAR);
            LocalWorkstation.MaximumLength -= 2*sizeof(WCHAR);
        }


        //
        // Check if SAM found some more specific reason to not allow logon.
        //

        Status = I_SamIAccountRestrictions(
                    UserHandle,
                    &LocalWorkstation,
                    (PUNICODE_STRING) &UserAll->WorkStations,
                    (PLOGON_HOURS) &UserAll->LogonHours,
                    &LogoffTime,
                    &KickoffTime );

        if ( !NT_SUCCESS(Status) ) {
            *Authoritative = TRUE;
            goto Cleanup;
        }


        //
        // If there is a SubAuthentication package zero, call it
        //

        if (NlpSubAuthZeroExists) {
            ULONG LocalUserFlags = 0;
            ULONG Flags = 0;

            if ( SecureChannelType != MsvApSecureChannel ) {
                Flags |= MSV1_0_PASSTHRU;
            }
            if ( GuestRelativeId != 0 ) {
                Flags |= MSV1_0_GUEST_LOGON;
            }


            Status = Msv1_0SubAuthenticationRoutineZero(
                        LogonLevel,
                        LogonInformation,
                        Flags,
                        (PUSER_ALL_INFORMATION) UserAll,
                        &WhichFields,
                        &LocalUserFlags,
                        Authoritative,
                        &LogoffTime,
                        &KickoffTime );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            //
            // Sanity check what the SubAuthentication package returned
            //

            if ( (WhichFields & ~USER_ALL_PARAMETERS) != 0 ) {
                Status = STATUS_INTERNAL_ERROR;
                *Authoritative = TRUE;
                goto Cleanup;
            }

            UserFlags |= LocalUserFlags;

        }


    }


    //
    // If the account is a machine account,
    //  let the caller know he got the password right.
    //  (But don't let him actually log on).
    //

    // But, for NT 5.0, we must allow accounts with account control
    // USER_WORKSTATION_TRUST_ACCOUNT for remote boot clients who
    // will logon with their machine accounts

    if ( (UserAll->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) != 0 ) {
        if (UserAll->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) {
            Status = STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT;
        } else if (UserAll->UserAccountControl &
                   USER_WORKSTATION_TRUST_ACCOUNT) {
            if ( (LogonInfo->ParameterControl & MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT) == 0) {
                Status = STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT;
            } else {

                UNICODE_STRING MachineAccountName;
                NTSTATUS TempStatus;


                //
                // if the password was correct, and it happened to match
                // the machine name, dis-allow it regardless.
                //


                //
                // Compute the lower case user name.
                //

                TempStatus = RtlDowncaseUnicodeString( &MachineAccountName,
                                                   (PUNICODE_STRING)&UserAll->UserName,
                                                   TRUE );


                if( NT_SUCCESS( TempStatus ) )
                {
                    USHORT LastChar = MachineAccountName.Length / sizeof(WCHAR);

                    if( LastChar )
                    {
                        if( MachineAccountName.Buffer[LastChar-1] == L'$' )
                        {
                            MachineAccountName.Length -= sizeof(WCHAR);
                        }

                        if( LastChar > LM20_PWLEN )
                        {
                            MachineAccountName.Length = LM20_PWLEN * sizeof(WCHAR);
                        }
                    }


                    if ( UserAll->NtPasswordPresent ) {

                        NT_OWF_PASSWORD NtOwfMachineName;
                        NT_OWF_PASSWORD *pOwf;

                        pOwf = ((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));

                        RtlCalculateNtOwfPassword(
                                     &MachineAccountName,
                                     &NtOwfMachineName );

                        if ( RtlCompareMemory( pOwf,
                                               &NtOwfMachineName,
                                               NT_OWF_PASSWORD_LENGTH ) ==
                                               NT_OWF_PASSWORD_LENGTH ) {

                            Status = STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT;
                        }
                    }


                    RtlFreeUnicodeString( &MachineAccountName );
                }

            }
        } else if (UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) {
            if ( (LogonInfo->ParameterControl & MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT) == 0) {
                Status = STATUS_NOLOGON_SERVER_TRUST_ACCOUNT;
            } else {

                //
                // it's a server trust account.
                // treat same way as workstation trust account.

                UNICODE_STRING MachineAccountName;
                NTSTATUS TempStatus;

                // NOTE: some code here is duplicated from above.
                // this will be merged when a new Rtl has been added for
                // computing initial machine password from machine acct name.
                //

                //
                // if the password was correct, and it happened to match
                // the machine name, dis-allow it regardless.
                //


                //
                // Compute the lower case user name.
                //

                TempStatus = RtlDowncaseUnicodeString( &MachineAccountName,
                                                   (PUNICODE_STRING)&UserAll->UserName,
                                                   TRUE );


                if( NT_SUCCESS( TempStatus ) )
                {
                    USHORT LastChar = MachineAccountName.Length / sizeof(WCHAR);

                    if( LastChar )
                    {
                        if( MachineAccountName.Buffer[LastChar-1] == L'$' )
                        {
                            MachineAccountName.Length -= sizeof(WCHAR);
                        }

                        if( LastChar > LM20_PWLEN )
                        {
                            MachineAccountName.Length = LM20_PWLEN * sizeof(WCHAR);
                        }
                    }


                    if ( UserAll->NtPasswordPresent ) {

                        NT_OWF_PASSWORD NtOwfMachineName;
                        NT_OWF_PASSWORD *pOwf;

                        pOwf = ((PNT_OWF_PASSWORD)(UserAll->NtOwfPassword.Buffer));

                        RtlCalculateNtOwfPassword(
                                     &MachineAccountName,
                                     &NtOwfMachineName );

                        if ( RtlCompareMemory( pOwf,
                                               &NtOwfMachineName,
                                               NT_OWF_PASSWORD_LENGTH ) ==
                                               NT_OWF_PASSWORD_LENGTH ) {

                            Status = STATUS_NOLOGON_SERVER_TRUST_ACCOUNT;
                        }
                    }


                    RtlFreeUnicodeString( &MachineAccountName );
                }

                //
                // Let the client know that this was
                // a server trust account
                //

                UserFlags |= LOGON_SERVER_TRUST_ACCOUNT;
            }

        } else {
            Status = STATUS_NO_SUCH_USER;
        }
        if (!NT_SUCCESS(Status)) {
            *Authoritative = TRUE;
            goto Cleanup;
        }
    }

    //
    // don't allow blank password logons.
    //

    if(
        (RelativeId != DOMAIN_USER_RID_GUEST)
            &&
        (!NtLmGlobalAllowBlankPassword)
            &&
        (!UserAll->NtPasswordPresent || (RtlCompareMemory(
                                            &NlpNullNtOwfPassword,
                                            UserAll->NtOwfPassword.Buffer,
                                            NT_OWF_PASSWORD_LENGTH
                                            ) == NT_OWF_PASSWORD_LENGTH))
            &&
        (!UserAll->LmPasswordPresent || (RtlCompareMemory(
                                            &NlpNullLmOwfPassword,
                                            UserAll->LmOwfPassword.Buffer,
                                            LM_OWF_PASSWORD_LENGTH
                                            ) == LM_OWF_PASSWORD_LENGTH))
            &&
        ( ((NtLmCheckProcessOption( MSV1_0_OPTION_ALLOW_BLANK_PASSWORD )) & MSV1_0_OPTION_ALLOW_BLANK_PASSWORD) == 0 )
        )
    {
        *Authoritative = FALSE;
        Status = STATUS_ACCOUNT_RESTRICTION;
        goto Cleanup;
    }

    //
    // Filter the groups into global groups (from other domains) and local
    // groups (from this domain).
    //

    Status = MsvpFilterGroupMembership(
                &GroupMembership,
                LogonDomainId,
                &GroupsBuffer,
                &GlobalGroupMembership,
                &GlobalMembershipSize
                );


    if ( !NT_SUCCESS(Status) ) {
        *Authoritative = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (NT_SUCCESS(Status) || fSubAuthEx)
    {
        UNICODE_STRING ReturnDnsDomainName;
        BOOLEAN UseDefaultUpn;

        //
        // Allocate a return buffer for validation information.
        //  (Return less information for a network logon)
        //  (Return UserParameters for a MNS logon)
        //

        ValidationSamSize = sizeof( NETLOGON_VALIDATION_SAM_INFO4 ) +
                GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP) +
                LogonDomainName->Length + sizeof(WCHAR) +
                LogonServer->Length + sizeof(WCHAR) +
                RtlLengthSid( LogonDomainId );

        //
        // all logon types get the username, as, this could be mapped
        // to guest account, for instance, and logon session needs correct
        // names.
        //

        ValidationSamSize +=
            UserAll->UserName.Length + sizeof(WCHAR) ;

        if ( LogonLevel != NetlogonNetworkInformation ) {
            ValidationSamSize +=
                UserAll->FullName.Length + sizeof(WCHAR) +
                UserAll->ScriptPath.Length + sizeof(WCHAR)+
                UserAll->ProfilePath.Length + sizeof(WCHAR) +
                UserAll->HomeDirectory.Length + sizeof(WCHAR) +
                UserAll->HomeDirectoryDrive.Length + sizeof(WCHAR);
        }

        if ( LogonInfo->ParameterControl & MSV1_0_RETURN_USER_PARAMETERS ) {
            ValidationSamSize +=
                UserAll->Parameters.Length + sizeof(WCHAR);
        } else if ( LogonInfo->ParameterControl & MSV1_0_RETURN_PROFILE_PATH ) {
            ValidationSamSize +=
                UserAll->ProfilePath.Length + sizeof(WCHAR);
        }

        //
        // If the caller can handle extra groups, let them have the groups from
        // other domains.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo2 ||
             ValidationLevel == NetlogonValidationSamInfo4 ) {
            ValidationSamSize += GlobalMembershipSize;
        }

        //
        // If the caller wants the logon domain in DNS and UPN form,
        //  grab it.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

            //
            // Grab the dns name of the account domain.
            //

            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);

            if( NlpWorkstation ) {
                //ReturnDnsDomainName = NtLmGlobalUnicodeDnsComputerNameString;
                //
                // for local accounts, DnsDomainName doesn't exist.
                //

                RtlInitUnicodeString( &ReturnDnsDomainName, L"" );
            } else {
                ReturnDnsDomainName = NtLmGlobalUnicodeDnsDomainNameString;
            }

            ValidationSamSize += ReturnDnsDomainName.Length + sizeof(WCHAR);

            //
            // If we couldn't get the UPN from SAM,
            //  build the default one.
            //

            if( Upn.Buffer != NULL )
            {
                UseDefaultUpn = FALSE;

                ValidationSamSize += (Upn.Length + sizeof(WCHAR));

            } else {
                UseDefaultUpn = TRUE;

                if ( !NlpWorkstation )
                {
                    ValidationSamSize +=
                        UserAll->UserName.Length +
                        sizeof(WCHAR) +
                        ReturnDnsDomainName.Length + sizeof(WCHAR);
                }
            }

        }

        ValidationSamSize = ROUND_UP_COUNT( ValidationSamSize, sizeof(WCHAR) );

        ValidationSam = MIDL_user_allocate( ValidationSamSize );

        if ( ValidationSam == NULL ) {
            *Authoritative = FALSE;
            fSubAuthEx = FALSE; // avoid nasty loop condition
            Status = STATUS_NO_MEMORY;
            RtlReleaseResource(&NtLmGlobalCritSect);
            goto Cleanup;
        }

        //
        // Default unused fields (and ExpansionRoom) to zero.
        //

        RtlZeroMemory( ValidationSam, ValidationSamSize );

        //
        // Copy the scalars to the validation buffer.
        //

        Where = (PUCHAR) (ValidationSam + 1);

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGOFF_TIME) != 0) {
            NEW_TO_OLD_LARGE_INTEGER( SubAuthValidationInformation.LogoffTime, ValidationSam->LogoffTime );
        }
        else {
            NEW_TO_OLD_LARGE_INTEGER( LogoffTime, ValidationSam->LogoffTime );
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_KICKOFF_TIME) != 0) {
            NEW_TO_OLD_LARGE_INTEGER( SubAuthValidationInformation.KickoffTime, ValidationSam->KickOffTime );
        }
        else {
            NEW_TO_OLD_LARGE_INTEGER( KickoffTime, ValidationSam->KickOffTime );
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_SESSION_KEY) != 0) {
                ValidationSam->UserSessionKey = SubAuthValidationInformation.SessionKey;
        }
        else {
            ValidationSam->UserSessionKey = UserSessionKey;
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_USER_FLAGS) != 0) {
            ValidationSam->UserFlags = SubAuthValidationInformation.UserFlags;
        }
        else {
            ValidationSam->UserFlags = UserFlags;
        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_USER_ID) != 0) {
            ValidationSam->UserId = SubAuthValidationInformation.UserId;
        }
        else {
            ValidationSam->UserId = UserAll->UserId;
        }
        ValidationSam->LogonTime = UserAll->LastLogon;
        ValidationSam->PasswordLastSet = UserAll->PasswordLastSet;
        ValidationSam->PasswordCanChange = UserAll->PasswordCanChange;
        ValidationSam->PasswordMustChange = UserAll->PasswordMustChange;

        ValidationSam->LogonCount = UserAll->LogonCount;
        ValidationSam->BadPasswordCount = UserAll->BadPasswordCount;
        ValidationSam->PrimaryGroupId = UserAll->PrimaryGroupId;
        ValidationSam->GroupCount = GroupsBuffer.MembershipCount;
        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE == sizeof(LmSessionKey) );
        RtlCopyMemory( &ValidationSam->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
                   &LmSessionKey,
                   SAMINFO_LM_SESSION_KEY_SIZE );
        ValidationSam->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] = UserAll->UserAccountControl;

        // Save any status for subuath users not returned by the subauth package

        if (fSubAuthEx)
        {
            ValidationSam->ExpansionRoom[SAMINFO_SUBAUTH_STATUS] = Status;
        }


        //
        // Copy ULONG aligned data to the validation buffer.
        //

        RtlCopyMemory(
            Where,
            GroupsBuffer.Groups,
            GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP) );

        ValidationSam->GroupIds = (PGROUP_MEMBERSHIP) Where;
        Where += GroupsBuffer.MembershipCount * sizeof(GROUP_MEMBERSHIP);


        RtlCopyMemory(
            Where,
            LogonDomainId,
            RtlLengthSid( LogonDomainId ) );

        ValidationSam->LogonDomainId = (PSID) Where;
        Where += RtlLengthSid( LogonDomainId );

        //
        // If the client asked for extra information, return that
        // we support it
        //

        if ( ValidationLevel == NetlogonValidationSamInfo2 ||
             ValidationLevel == NetlogonValidationSamInfo4 ) {

            ValidationSam->UserFlags |= LOGON_EXTRA_SIDS;
            if (GlobalMembershipSize != 0) {
                ULONG SidLength;

                ValidationSam->SidCount = GlobalGroupMembership.Count;
                ValidationSam->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) Where;
                Where += ValidationSam->SidCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES);

                //
                // Copy all the extra sids into the buffer
                //

                for (Index = 0; Index < ValidationSam->SidCount ; Index++ ) {
                    ValidationSam->ExtraSids[Index].Attributes = GlobalGroupMembership.SidAndAttributes[Index].Attributes;
                    ValidationSam->ExtraSids[Index].Sid = Where;
                    SidLength = RtlLengthSid(GlobalGroupMembership.SidAndAttributes[Index].Sid);
                    RtlCopyMemory(
                        ValidationSam->ExtraSids[Index].Sid,
                        GlobalGroupMembership.SidAndAttributes[Index].Sid,
                        SidLength
                        );

                    Where += SidLength;

                }

            }
        }

        //
        // Copy WCHAR aligned data to the validation buffer.
        //  (Return less information for a network logon)
        //

        Where = ROUND_UP_POINTER( Where, sizeof(WCHAR) );

        NlpPutString( &ValidationSam->EffectiveName,
                      (PUNICODE_STRING)&UserAll->UserName,
                      &Where );

        if ( LogonLevel != NetlogonNetworkInformation ) {

            NlpPutString( &ValidationSam->FullName,
                          (PUNICODE_STRING)&UserAll->FullName,
                          &Where );

            NlpPutString( &ValidationSam->LogonScript,
                          (PUNICODE_STRING)&UserAll->ScriptPath,
                          &Where );

            NlpPutString( &ValidationSam->ProfilePath,
                          (PUNICODE_STRING)&UserAll->ProfilePath,
                          &Where );

            NlpPutString( &ValidationSam->HomeDirectory,
                          (PUNICODE_STRING)&UserAll->HomeDirectory,
                          &Where );

            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->HomeDirectoryDrive,
                          &Where );

        }

        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGON_SERVER) != 0) {
            NlpPutString( &ValidationSam->LogonServer,
                          &SubAuthValidationInformation.LogonServer,
                          &Where );

        }
        else {
            NlpPutString( &ValidationSam->LogonServer,
                          LogonServer,
                          &Where );

        }
        if ((SubAuthValidationInformation.WhichFields & MSV1_0_VALIDATION_LOGON_DOMAIN) != 0) {
            NlpPutString( &ValidationSam->LogonDomainName,
                          &SubAuthValidationInformation.LogonDomainName,
                          &Where );

        }
        else {
            NlpPutString( &ValidationSam->LogonDomainName,
                          LogonDomainName,
                          &Where );

        }

        //
        // If the caller wants the logon domain in DNS and UPN form,
        //  return them.
        //

        if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

            //
            // Copy the DNS domain name into the allocated buffer
            //

            NlpPutString( &ValidationSam->DnsLogonDomainName,
                          &ReturnDnsDomainName,
                          &Where );

            //
            // If we couldn't get the UPN from SAM,
            //  copy the default one into the buffer.
            //

            if ( !NlpWorkstation )
            {
                if( UseDefaultUpn )
                {
                    UNICODE_STRING TempString1;
                    UNICODE_STRING TempString2;
                    UNICODE_STRING TempString3;
                    UNICODE_STRING AtString;

                    NlpPutString( &TempString1,
                                  (PUNICODE_STRING)&UserAll->UserName,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    RtlInitUnicodeString( &AtString, L"@" );
                    NlpPutString( &TempString2,
                                  &AtString,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    NlpPutString( &TempString3,
                                  &ReturnDnsDomainName,
                                  &Where );

                    ValidationSam->Upn.Buffer = TempString1.Buffer;
                    ValidationSam->Upn.Length =
                        TempString1.Length +
                        TempString2.Length +
                        TempString3.Length;
                    ValidationSam->Upn.MaximumLength = ValidationSam->Upn.Length + sizeof(WCHAR);
                } else {
                    UNICODE_STRING TempString1;

                    NlpPutString( &TempString1,
                                  &Upn,
                                  &Where );
                    Where -= sizeof(WCHAR);

                    ValidationSam->Upn.Buffer = TempString1.Buffer;
                    ValidationSam->Upn.Length = TempString1.Length;
                    ValidationSam->Upn.MaximumLength = ValidationSam->Upn.Length;
                }

            }

            //
            // Drop the lock that we've held since we grabbed pointer to the globals
            //
            RtlReleaseResource(&NtLmGlobalCritSect);
        }


        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 3.1 and NT 3.5. HomeDirectoryDrive was NULL for release 3.1
        // so we'll use that field.
        //

        if ( LogonInfo->ParameterControl & MSV1_0_RETURN_USER_PARAMETERS ) {
            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->Parameters,
                          &Where );
        } else if ( LogonInfo->ParameterControl & MSV1_0_RETURN_PROFILE_PATH ) {
            NlpPutString( &ValidationSam->HomeDirectoryDrive,
                          (PUNICODE_STRING)&UserAll->ProfilePath,
                          &Where );
            ValidationSam->UserFlags |= LOGON_PROFILE_PATH_RETURNED;
        }


        *Authoritative = TRUE;

        //
        // For SubAuthEx, we save away the original Status to make decisions
        // later on about additional processing to perform.
        //

        if( fSubAuthEx ) {
            SubAuthExStatus = Status;
        }

        Status = STATUS_SUCCESS;

    }

    //
    // Cleanup up before returning.
    //

    //
    // If the User Parameters have been changed,
    //  write them back to SAM.
    //

    if ( NT_SUCCESS(Status) &&
        (WhichFields & USER_ALL_PARAMETERS) )
    {
        SAMPR_USER_INFO_BUFFER UserInfo;

        UserInfo.Parameters.Parameters = UserAll->Parameters;

        Status = I_SamrSetInformationUser(
                        UserHandle,
                        UserParametersInformation,
                        &UserInfo );
    }

    //
    // Update the logon statistics.
    //

    if ( NT_SUCCESS( SubAuthExStatus ) &&
        (  NT_SUCCESS(Status)
        || Status == STATUS_WRONG_PASSWORD
        || Status == STATUS_NO_LOGON_SERVERS ) ) {

        SAM_LOGON_STATISTICS LogonStats;

        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        if ( NT_SUCCESS( Status ) ) {
            if ( LogonLevel == NetlogonInteractiveInformation ) {
                LogonStats.StatisticsToApply =
                    USER_LOGON_INTER_SUCCESS_LOGON;
            } else {

                //
                // On network logons,
                //  only update the statistics on 'success' if explicitly asked,
                //  or the Bad Password count will be zeroed.
                //
                LogonStats.StatisticsToApply =
                    USER_LOGON_NET_SUCCESS_LOGON | USER_LOGON_NO_WRITE;

                if ( (LogonInfo->ParameterControl & MSV1_0_UPDATE_LOGON_STATISTICS) ||
                     UserAll->BadPasswordCount != 0 ) {

                    LogonStats.StatisticsToApply &= ~USER_LOGON_NO_WRITE;
                }
            }

            // Tell the caller we zeroed the bad password count
            if ( UserAll->BadPasswordCount != 0 ) {
                *BadPasswordCountZeroed = TRUE;
            }

        } else {

            if (Status == STATUS_WRONG_PASSWORD) {
                LogonStats.StatisticsToApply =
                    USER_LOGON_BAD_PASSWORD | USER_LOGON_BAD_PASSWORD_WKSTA;
                LogonStats.Workstation = LogonInfo->Workstation;
            } else {
                LogonStats.StatisticsToApply = USER_LOGON_NO_LOGON_SERVERS;
                if (LogonLevel == NetlogonInteractiveInformation) {
                    LogonStats.StatisticsToApply |= USER_LOGON_INTER_FAILURE;
                }
            }
        }

        if ( LogonStats.StatisticsToApply != 0 ) {
            NTSTATUS LogonStatus;

            LogonStats.StatisticsToApply |= USER_LOGON_TYPE_NTLM;

            LogonStatus = I_SamIUpdateLogonStatistics(
                                          UserHandle,
                                         &LogonStats );
        }

    }



    //
    // Audit this logon. We don't audit failures for the guest account because
    // they are so frequent.
    //

    if (GuestRelativeId == 0 || NT_SUCCESS(Status)) {
        NTSTATUS AuditStatus;

        AuditStatus = Status;

        //
        // if there was a possibly un-successful SubAuthEx status, use it
        //

        if( NT_SUCCESS( AuditStatus ) && fSubAuthEx ) {

            AuditStatus = SubAuthExStatus;
        }

        I_LsaIAuditAccountLogon(
            SE_AUDITID_ACCOUNT_LOGON,
            (BOOLEAN) NT_SUCCESS(AuditStatus),
            &NlpMsv1_0PackageName,
            &LocalUserName,
            &LogonInfo->Workstation,
            AuditStatus
            );
    }

    //
    // Return the validation buffer to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        if (ValidationSam != NULL) {
            MIDL_user_free( ValidationSam );
            ValidationSam = NULL;
        }
    }

    *ValidationInformation = ValidationSam;

    //
    // Free locally used resources.
    //

    I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY( &NameArray );
    I_SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

    if ( UserAllInfo != NULL ) {
        I_SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if( Upn.Buffer != NULL )
    {
        I_SamIFreeVoid( Upn.Buffer );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        I_SamIFreeSidAndAttributesList(&GroupMembership);
    }

    if ( GroupsBuffer.Groups != NULL ) {
        I_NtLmFree(GroupsBuffer.Groups);
    }

    if ( GlobalGroupMembership.SidAndAttributes != NULL ) {
        I_NtLmFree(GlobalGroupMembership.SidAndAttributes);
    }

    if ( UserHandle != NULL ) {
        I_SamrCloseHandle( &UserHandle );
    }

    if (SubAuthValidationInformation.LogonDomainName.Buffer != NULL) {
        MIDL_user_free(SubAuthValidationInformation.LogonDomainName.Buffer);
    }
    if (SubAuthValidationInformation.LogonServer.Buffer != NULL) {
        MIDL_user_free(SubAuthValidationInformation.LogonServer.Buffer);
    }

    if (LocalSidUser != NULL) {
        I_NtLmFree(LocalSidUser);
    }

    return Status;
}


NTSTATUS
MsvSamValidate (
    IN SAM_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed,
    IN DWORD AccountsToTry
)
/*++

Routine Description:

    Process an interactive, network, or session logon.  It calls
    SamIUserValidation, validates the passed in credentials, updates the logon
    statistics and packages the result for return to the caller.

    This routine is called directly from the MSV Authentication package
    if the account is defined locally.  This routine is called
    from the Netlogon Service otherwise.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain to use to
        validate the request.

    UasCompatibilityRequired -- TRUE if UasCompatibilityRequired is on.

    SecureChannelType -- The secure channel type this request was made on.

    LogonServer -- Specifies the server name of the caller.

    LogonDomainName -- Specifies the domain of the caller.

    LogonDomainId  -- Specifies the DomainId of the domain of the caller.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed user MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    BadPasswordCountZeroed - Returns TRUE if we zeroed the BadPasswordCount
        field of this user.

    AccountsToTry -- Specifies whether the username specified in
        LogonInformation is to be used to logon, whether to guest account
        is to be used to logon, or both serially.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    NTSTATUS Status;
    NTSTATUS GuestStatus;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    //
    // Tracing
    //
    NTLM_TRACE_INFO TraceInfo = {0};

    //
    // Begin tracing a sam validate call for NTLM
    //
    if (NtlmGlobalEventTraceFlag){


        //Header goo
        SET_TRACE_HEADER(TraceInfo,
                         NtlmValidateGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    //
    // if simple file/print option is enabled (applies to SSPI callers),
    // check if ForceGuest should occur.
    //

    if( (LogonInfo->ParameterControl & MSV1_0_ALLOW_FORCE_GUEST) )
    {
        if( NtLmGlobalForceGuest )
        {
            if((LogonInfo->ParameterControl & MSV1_0_DISABLE_PERSONAL_FALLBACK)==0)
            {
                if( (LogonLevel == NetlogonNetworkInformation) &&
                    (((NtLmCheckProcessOption( MSV1_0_OPTION_DISABLE_FORCE_GUEST ) & MSV1_0_OPTION_DISABLE_FORCE_GUEST )) == 0)
                    )
                {
                    AccountsToTry &= ~(MSVSAM_SPECIFIED);
                    AccountsToTry |= MSVSAM_GUEST;
                }
            }
        }
    }


    //
    // Validate the specified user.
    //
    *BadPasswordCountZeroed = FALSE;

    if ( AccountsToTry & MSVSAM_SPECIFIED ) {

        //
        // Keep track of the total number of logons attempted.
        //


        I_SamIIncrementPerformanceCounter(
            MsvLogonCounter
            );
        InterlockedIncrement(&NlpLogonAttemptCount);


        Status = MsvpSamValidate( (SAMPR_HANDLE) DomainHandle,
                                  UasCompatibilityRequired,
                                  SecureChannelType,
                                  LogonServer,
                                  LogonDomainName,
                                  LogonDomainId,
                                  LogonLevel,
                                  LogonInformation,
                                  0,
                                  ValidationLevel,
                                  ValidationInformation,
                                  Authoritative,
                                  BadPasswordCountZeroed );


        //
        // If the SAM database authoritatively handled this logon attempt,
        //  just return.
        //

        if ( *Authoritative ) {
            goto Cleanup;
        }

    //
    // If the caller only wants to log on as guest,
    //  Pretend the first validation simply didn't find the user.
    //
    } else {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
    }

    //
    // If guest accounts are not allowed,
    //  return now.
    //

    if ( LogonLevel != NetlogonNetworkInformation ||
        SecureChannelType != MsvApSecureChannel ||
        ( LogonInfo->ParameterControl & MSV1_0_DONT_TRY_GUEST_ACCOUNT ) ||
        (AccountsToTry & MSVSAM_GUEST) == 0 ) {

        goto Cleanup;
        //return Status;
    }

    //
    // Try the Guest Account.
    //

    GuestStatus = MsvpSamValidate( (SAMPR_HANDLE) DomainHandle,
                                   UasCompatibilityRequired,
                                   SecureChannelType,
                                   LogonServer,
                                   LogonDomainName,
                                   LogonDomainId,
                                   LogonLevel,
                                   LogonInformation,
                                   DOMAIN_USER_RID_GUEST,
                                   ValidationLevel,
                                   ValidationInformation,
                                   Authoritative,
                                   BadPasswordCountZeroed );

    if ( NT_SUCCESS(GuestStatus) ) {
        PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo;

        ASSERT ((ValidationLevel == NetlogonValidationSamInfo) ||
                (ValidationLevel == NetlogonValidationSamInfo2) ||
                (ValidationLevel == NetlogonValidationSamInfo4) );
        ValidationInfo =
            (PNETLOGON_VALIDATION_SAM_INFO4) *ValidationInformation;
        ValidationInfo->UserFlags |= LOGON_GUEST;

        Status = GuestStatus;
        goto Cleanup;
        //return GuestStatus;
    }

    //
    // Failed Guest logon attempts are never authoritative and the status from
    // the original logon attempt is more significant than the Guest logon
    // status.
    //
    *Authoritative = FALSE;
Cleanup:

    //
    // Trace the end of this call
    //
    if (NtlmGlobalEventTraceFlag){
        UINT32 Success;
        PNETLOGON_LOGON_IDENTITY_INFO LogonInfo =
            (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

        SET_TRACE_HEADER(TraceInfo,
                         NtlmValidateGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         9);
        //
        // Build the "success" trace state bit mask
        // 1bit - Success
        // 2bit - Authoritative
        //
        Success = (Status == STATUS_SUCCESS)?1:0;
        Success |= (*Authoritative)?2:0;

        SET_TRACE_DATA(TraceInfo,
                        TRACE_VALIDATE_SUCCESS,
                        Success);

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_SERVER,
                        (*LogonServer));

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_DOMAIN,
                        (*LogonDomainName));

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_USERNAME,
                        LogonInfo->UserName);

        SET_TRACE_USTRING(TraceInfo,
                        TRACE_VALIDATE_WORKSTATION,
                        LogonInfo->Workstation);

        TraceEvent(
            NtlmGlobalTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TraceInfo
            );
    }

    return Status;

}


NTSTATUS
MsvSamLogoff (
    IN SAM_HANDLE DomainHandle,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation
)
/*++

Routine Description:

    Process an interactive, network, or session logoff.  It simply updates
    the logon statistics for the user account.

    This routine is called directly from the MSV Authentication package
    if the user was logged on not using the Netlogon service.  This routine
    is called from the Netlogon Service otherwise.

Arguments:

    DomainHandle -- Specifies a handle to the SamDomain containing
        the user to logoff.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.
        The caller is responsible for validating this field.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_INVALID_INFO_CLASS: LogonLevel or ValidationLevel are invalid.
    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    Other return codes from SamIUserValidation

--*/
{
    return(STATUS_SUCCESS);
    UNREFERENCED_PARAMETER( DomainHandle );
    UNREFERENCED_PARAMETER( LogonLevel );
    UNREFERENCED_PARAMETER( LogonInformation );
}


ULONG
MsvGetLogonAttemptCount (
    VOID
)
/*++

Routine Description:

    Return the number of logon attempts since the last reboot.

Arguments:

    NONE

Return Value:

    Returns the number of logon attempts since the last reboot.

--*/
{

    //
    // Keep track of the total number of logons attempted.
    //

    return NlpLogonAttemptCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msv1_0.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msv1_0.c

Abstract:

    MSV1_0 authentication package.


    The name of this authentication package is:


Author:

    Jim Kelly 11-Apr-1991

Revision History:
    Scott Field (sfield)    15-Jan-98   Add MspNtDeriveCredential
    Chandana Surlu          21-Jul-96   Stolen from \\kernel\razzle3\src\security\msv1_0\msv1_0.c
--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"


//
// LsaApCallPackage() function dispatch table
//


PLSA_AP_CALL_PACKAGE
MspCallPackageDispatch[] = {
    MspLm20Challenge,
    MspLm20GetChallengeResponse,
    MspLm20EnumUsers,
    MspLm20GetUserInfo,
    MspLm20ReLogonUsers,
    MspLm20ChangePassword,
    MspLm20ChangePassword,
    MspLm20GenericPassthrough,
    MspLm20CacheLogon,
    MspNtSubAuth,
    MspNtDeriveCredential,
    MspLm20CacheLookup,
    MspSetProcessOption
};





///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routines.                         //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage (
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    )

/*++

Routine Description:

    This service is called once by the LSA during system initialization to
    provide the DLL a chance to initialize itself.

Arguments:

    AuthenticationPackageId - The ID assigned to the authentication
        package.

    LsaDispatchTable - Provides the address of a table of LSA
        services available to authentication packages.  The services
        of this table are ordered according to the enumerated type
        LSA_DISPATCH_TABLE_API.

    Database - This parameter is not used by this authentication package.

    Confidentiality - This parameter is not used by this authentication
        package.

    AuthenticationPackageName - Recieves the name of the
        authentication package.  The authentication package is
        responsible for allocating the buffer that the string is in
        (using the AllocateLsaHeap() service) and returning its
        address here.  The buffer will be deallocated by LSA when it
        is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    PSTRING NameString;
    PCHAR NameBuffer;
    NTSTATUS Status;

    //
    // If we haven't already initialized the internals, do it now.
    //

    if (!NlpMsvInitialized) {


        //
        // Save our assigned authentication package ID.
        //

        MspAuthenticationPackageId = AuthenticationPackageId;


        //
        // Copy the LSA service dispatch table
        // the LsaDispatchTable is actually a LSA_SECPKG_FUNCTION_TABLE
        // in Win2k and beyond.
        //

        CopyMemory( &Lsa, LsaDispatchTable, sizeof( Lsa ) );

        //
        // Initialize the change password log.
        //

        MsvPaswdInitializeLog();

        //
        // Initialize netlogon
        //

        Status = NlInitialize();

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,"Error from NlInitialize = %d\n", Status));
            return Status;
        }
        NlpMsvInitialized = TRUE;
    }

    //
    // Allocate and return our package name
    //

    if (ARGUMENT_PRESENT(AuthenticationPackageName))
    {
        NameBuffer = (*(Lsa.AllocateLsaHeap))(sizeof(MSV1_0_PACKAGE_NAME));
        if (!NameBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL, "Error from Lsa.AllocateLsaHeap\n"));
            return Status;

        }
        strcpy( NameBuffer, MSV1_0_PACKAGE_NAME);

        NameString = (*(Lsa.AllocateLsaHeap))( (ULONG)sizeof(STRING) );
        if (!NameString)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint((SSP_CRITICAL, "Error from Lsa.AllocateLsaHeap\n"));
            return Status;
        }

        RtlInitString( NameString, NameBuffer );
        (*AuthenticationPackageName) = NameString;
    }


    RtlInitUnicodeString(
        &NlpMsv1_0PackageName,
        TEXT(MSV1_0_PACKAGE_NAME)
        );

    return STATUS_SUCCESS;

    //
    // Appease the compiler gods by referencing all arguments
    //

    UNREFERENCED_PARAMETER(Confidentiality);
    UNREFERENCED_PARAMETER(Database);

}


NTSTATUS
LsaApCallPackage (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage().

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/

{
    ULONG MessageType;

#if _WIN64

    NTSTATUS Status;
    SECPKG_CALL_INFO CallInfo;

#endif  // _WIN64

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)(-1) )
    {
        //
        // Only supported CallPackage level for WOW64 callers is password change.
        //

        Status = LsaFunctions->GetCallInfo(&CallInfo);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        if ( (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) &&
            ((CallInfo.Attributes & SECPKG_CALL_IN_PROC) == 0))

        {
            switch (MessageType)
            {
                case MsV1_0ChangePassword:
                case MsV1_0GenericPassthrough:
                {
                    break;
                }

                default:
                {
                    return STATUS_NOT_SUPPORTED;
                }
            }
        }
    }

#endif  // _WIN64

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;



    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}


NTSTATUS
LsaApCallPackageUntrusted (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for untrusted clients.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/

{
    ULONG MessageType;
    NTSTATUS Status;

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

#endif  // _WIN64

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow an service to call the DeriveCredential function if the
    // request specifies the same logon id as the service.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0DeriveCredential)
    {
        PMSV1_0_DERIVECRED_REQUEST DeriveCredRequest;
        SECPKG_CLIENT_INFO ClientInfo;
        LUID SystemId = SYSTEM_LUID;
    
        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if(!NT_SUCCESS(Status))
        {
            return Status;
        }

        if ( SubmitBufferLength < sizeof(MSV1_0_DERIVECRED_REQUEST) ) {
            return STATUS_INVALID_PARAMETER;
        }

        DeriveCredRequest = (PMSV1_0_DERIVECRED_REQUEST) ProtocolSubmitBuffer;

        if(!RtlEqualLuid(&ClientInfo.LogonId, &DeriveCredRequest->LogonId))
        {
            return STATUS_ACCESS_DENIED;
        }

        if(RtlEqualLuid(&ClientInfo.LogonId, &SystemId))
        {
            return STATUS_ACCESS_DENIED;
        }
    }


    //
    // Allow an untrusted client to call the SetProcessOption function if
    // the DISABLE_FORCE_GUEST option is set.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0SetProcessOption)
    {
        PMSV1_0_SETPROCESSOPTION_REQUEST ProcessOptionRequest;

        if ( SubmitBufferLength < sizeof(MSV1_0_SETPROCESSOPTION_REQUEST) ) {
            return STATUS_INVALID_PARAMETER;
        }

        ProcessOptionRequest = (PMSV1_0_SETPROCESSOPTION_REQUEST) ProtocolSubmitBuffer;

        if( ProcessOptionRequest->ProcessOptions != MSV1_0_OPTION_DISABLE_FORCE_GUEST )
        {
            return STATUS_ACCESS_DENIED;
        }
    }


    //
    // let DeriveCredential and SetProcessOption requests through if the caller is a service.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0DeriveCredential ||
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType == MsV1_0SetProcessOption )
    {
        BOOL IsMember = FALSE;
        PSID pServiceSid = NULL;
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        Status = LsaFunctions->ImpersonateClient();

        if(NT_SUCCESS(Status))
        {
            if(AllocateAndInitializeSid( &siaNtAuthority,
                                         1,
                                         SECURITY_SERVICE_RID,
                                         0, 0, 0, 0, 0, 0, 0,
                                         &pServiceSid )) 
            {
                if(!CheckTokenMembership(NULL, pServiceSid, &IsMember))
                {
                    IsMember = FALSE;
                }

                FreeSid(pServiceSid);
            }

            RevertToSelf();
        }

        if(!IsMember)
        {
            return STATUS_ACCESS_DENIED;
        }
    }


    //
    // Untrusted clients are only allowed to call a few of the functions.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0ChangePassword &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0DeriveCredential &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0SetProcessOption &&
        (MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0Lm20ChallengeRequest) {

        return STATUS_ACCESS_DENIED;
    }

#if _WIN64

    //
    // Only supported CallPackage level for WOW64 callers is password change.
    //

    Status = LsaFunctions->GetCallInfo(&CallInfo);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if ((CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
          &&
        ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0ChangePassword))
    {
        return STATUS_NOT_SUPPORTED;
    }

#endif  // _WIN64

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}



NTSTATUS
LsaApCallPackagePassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for passthrough logon requests.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/

{
    ULONG MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(MSV1_0_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PMSV1_0_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(MspCallPackageDispatch)/sizeof(MspCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // clients are only allowed to call the SubAuthLogon function.
    //

    if ((MSV1_0_PROTOCOL_MESSAGE_TYPE) MessageType != MsV1_0SubAuth) {

        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return (*(MspCallPackageDispatch[MessageType]))(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msvwow.h ===
/*++

    Copyright (c) Microsoft Corporation 2001

    File:        msvwow.h

    Contents:    prototypes for 32-64 bit interop for the MSV1_0 package

    History:     07-Jan-2001    SField

--*/

#ifndef __MSVWOW_H__
#define __MSVWOW_H__

#ifdef _WIN64

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// WOW versions of native structures
// MUST keep these in sync with ntmsv1_0.h
//

typedef UNICODE_STRING32     UNICODE_STRING_WOW64;
typedef UNICODE_STRING_WOW64 *PUNICODE_STRING_WOW64;

typedef STRING32     STRING_WOW64;
typedef STRING_WOW64 *PSTRING_WOW64;

typedef struct _MSV1_0_INTERACTIVE_LOGON_WOW64 {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Password;
} MSV1_0_INTERACTIVE_LOGON_WOW64, *PMSV1_0_INTERACTIVE_LOGON_WOW64;

typedef struct _MSV1_0_INTERACTIVE_PROFILE_WOW64 {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING_WOW64 LogonScript;
    UNICODE_STRING_WOW64 HomeDirectory;
    UNICODE_STRING_WOW64 FullName;
    UNICODE_STRING_WOW64 ProfilePath;
    UNICODE_STRING_WOW64 HomeDirectoryDrive;
    UNICODE_STRING_WOW64 LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE_WOW64, *PMSV1_0_INTERACTIVE_PROFILE_WOW64;

typedef struct _MSV1_0_LM20_LOGON_WOW64 {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING_WOW64 CaseSensitiveChallengeResponse;
    STRING_WOW64 CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON_WOW64, * PMSV1_0_LM20_LOGON_WOW64;

typedef struct _MSV1_0_LM20_LOGON_PROFILE_WOW64 {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING_WOW64 LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING_WOW64 LogonServer;
    UNICODE_STRING_WOW64 UserParameters;
} MSV1_0_LM20_LOGON_PROFILE_WOW64, * PMSV1_0_LM20_LOGON_PROFILE_WOW64;


typedef struct _MSV1_0_ENUMUSERS_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG NumberOfLoggedOnUsers;
    PLUID LogonIds;
    PULONG EnumHandles;
} MSV1_0_ENUMUSERS_RESPONSE_WOW64, *PMSV1_0_ENUMUSERS_RESPONSE_WOW64;

typedef struct _MSV1_0_GETUSERINFO_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PSID UserSid;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 LogonServer;
    SECURITY_LOGON_TYPE LogonType;
} MSV1_0_GETUSERINFO_RESPONSE_WOW64, *PMSV1_0_GETUSERINFO_RESPONSE_WOW64;

typedef struct _MSV1_0_CHANGEPASSWORD_REQUEST_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64 DomainName;
    UNICODE_STRING_WOW64 AccountName;
    UNICODE_STRING_WOW64 OldPassword;
    UNICODE_STRING_WOW64 NewPassword;
    BOOLEAN        Impersonating;
} MSV1_0_CHANGEPASSWORD_REQUEST_WOW64, *PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64;

typedef struct _MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    BOOLEAN PasswordInfoValid;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
} MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64, *PMSV1_0_CHANGEPASSWORD_RESPONSE_WOW64;

//
// If this assertion fails, we're overrunning the client's OUT buffer on
// password change requests
//

C_ASSERT(sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE) == sizeof(MSV1_0_CHANGEPASSWORD_RESPONSE_WOW64));

//
// routines for working on primary structures
//

NTSTATUS
MsvConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvConvertWOWNetworkLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvConvertWOWChangePasswordBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
MsvAllocateInteractiveWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    );

NTSTATUS
MsvAllocateNetworkWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    );


//
// generic helper routines
//

VOID
MsvPutWOWClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    );



#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _WIN64
#endif  // __MSVWOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlnetapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlnetapi.c

Abstract:

   This module loads Netapi.dll at runtime and sets up pointers to
   the APIs called by Msv1_0.

Author:

    Dave Hart (DaveHart) 25-Mar-1992

Environment:

    User mode Win32 - msv1_0 authentication package DLL

Revision History:
    Dave Hart (DaveHart) 26-Mar-1992
        Added RxNetUserPasswordSet.

    Dave Hart (DaveHart) 30-May-1992
        Removed NetRemoteComputerSupports, added NetApiBufferAllocate.

    Chandana Surlu       21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlnetapi.c

    Scott Field (sfield) 19-May-1999
        Use DELAYLOAD against ntdsapi.dll and netapi32.dll

--*/

#include "msp.h"
#include "nlp.h"

typedef NTSTATUS
            (*PI_NetNotifyNetlogonDllHandle) (
                IN PHANDLE Role
            );




VOID
NlpLoadNetlogonDll (
    VOID
    )

/*++

Routine Description:

    Uses Win32 LoadLibrary and GetProcAddress to get pointers to functions
    in Netlogon.dll that are called by Msv1_0.

Arguments:

    None.

Return Value:

    None.  If successful, NlpNetlogonDllHandle is set to non-null and function
    pointers are setup.


--*/

{
    HANDLE hModule = NULL;
    PI_NetNotifyNetlogonDllHandle pI_NetNotifyNetlogonDllHandle = NULL;



    //
    // Load netlogon.dll also.
    //

    hModule = LoadLibraryA("netlogon");

    if (NULL == hModule) {
#if DBG
        DbgPrint("Msv1_0: Unable to load netlogon.dll, Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }




    NlpNetLogonSamLogon = (PNETLOGON_SAM_LOGON_PROCEDURE)
        GetProcAddress(hModule, "NetrLogonSamLogon");

    if (NlpNetLogonSamLogon == NULL) {
#if DBG
        DbgPrint(
            "Msv1_0: Can't find entrypoint NetrLogonSamLogon in netlogon.dll.\n"
            "        Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }


    NlpNetLogonMixedDomain = (PNETLOGON_MIXED_DOMAIN_PROCEDURE)
        GetProcAddress(hModule, "I_NetLogonMixedDomain");

    if (NlpNetLogonMixedDomain == NULL) {
#if DBG
        DbgPrint(
            "Msv1_0: Can't find entrypoint I_NetLogonMixedDomain in netlogon.dll.\n"
            "        Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }

    NlpNetLogonSamLogoff = (PNETLOGON_SAM_LOGOFF_PROCEDURE)
        GetProcAddress(hModule, "NetrLogonSamLogoff");

    if (NlpNetLogonSamLogoff == NULL) {
#if DBG
        DbgPrint(
            "Msv1_0: Can't find entrypoint NetrLogonSamLogoff in netlogon.dll.\n"
            "        Win32 error %d.\n", GetLastError());
#endif
        goto Cleanup;
    }


    //
    // Find the address of the I_NetNotifyNetlogonDllHandle procedure.
    //  This is an optional procedure so don't complain if it isn't there.
    //

    pI_NetNotifyNetlogonDllHandle = (PI_NetNotifyNetlogonDllHandle)
        GetProcAddress( hModule, "I_NetNotifyNetlogonDllHandle" );




    //
    // Found all the functions needed, so indicate success.
    //

    NlpNetlogonDllHandle = hModule;
    hModule = NULL;

    //
    // Notify Netlogon that we've loaded it.
    //

    if( pI_NetNotifyNetlogonDllHandle != NULL ) {
        (VOID) (*pI_NetNotifyNetlogonDllHandle)( &NlpNetlogonDllHandle );
    }


Cleanup:
    if ( hModule != NULL ) {
        FreeLibrary( hModule );
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlmain.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    nlmain.c

Abstract:

    This file contains the initialization and dispatch routines
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
    25-Apr-1991 (cliffv)
        Added interactive logon support for PDK.

    Chandana Surlu   21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlmain.c

    JClark    28-Jun-2000
        Added WMI Trace Logging Support

--*/

#include <global.h>

#include "msp.h"
#undef EXTERN
#define NLP_ALLOCATE
#include "nlp.h"
#undef NLP_ALLOCATE

#include <lmsname.h>    // Service Names

#include <safeboot.h>

#include <confname.h>   // NETSETUPP_NETLOGON_JD_STOPPED

#include "nlpcache.h"   // logon cache prototypes

#include "trace.h" // wmi tracing goo

#include "msvwow.h"

NTSTATUS
NlpMapLogonDomain(
    OUT PUNICODE_STRING MappedDomain,
    IN PUNICODE_STRING LogonDomain
    );

NTSTATUS
NlInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize NETLOGON portion of msv1_0 authentication package.

Arguments:

    None.

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status;
    LPWSTR ComputerName;
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NT_PRODUCT_TYPE NtProductType;
    UNICODE_STRING TempUnicodeString;
    HKEY Key ;
    int err ;
    ULONG Size ;
    ULONG Type ;
    ULONG Value ;

    //
    // Initialize global data
    //

    NlpEnumerationHandle = 0;
    NlpLogonAttemptCount = 0;


    NlpComputerName.Buffer = NULL;
    RtlInitUnicodeString( &NlpPrimaryDomainName, NULL );
    NlpSamDomainName.Buffer = NULL;
    NlpSamDomainId = NULL;
    NlpSamDomainHandle = NULL;



    //
    // Get the name of this machine.
    //

    ComputerName = I_NtLmAllocate(
                        ComputerNameLength * sizeof(WCHAR) );

    if (ComputerName == NULL ||
        !GetComputerNameW( ComputerName, &ComputerNameLength )) {

        SspPrint((SSP_MISC, "Cannot get computername %lX\n", GetLastError() ));

        NlpLanmanInstalled = FALSE;
        I_NtLmFree( ComputerName );
        ComputerName = NULL;
    } else {

        NlpLanmanInstalled = TRUE;
    }

    //
    // For Safe mode boot (minimal, no networking)
    // turn off the lanmaninstalled flag, since no network components will
    // be started.
    //

    err = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",
                0,
                KEY_READ,
                &Key );

    if ( err == ERROR_SUCCESS )
    {
        Value = 0 ;
        Size = sizeof( ULONG );

        err = RegQueryValueExW(
                    Key,
                    L"OptionValue",
                    0,
                    &Type,
                    (PUCHAR) &Value,
                    &Size );

        RegCloseKey( Key );

        if ( err == ERROR_SUCCESS )
        {
            NtLmGlobalSafeBoot = TRUE;

            if ( Value == SAFEBOOT_MINIMAL )
            {
                NlpLanmanInstalled = FALSE ;
            }
        }

    }

    RtlInitUnicodeString( &NlpComputerName, ComputerName );

    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        SspPrint((SSP_MISC, "Nt Product Type undefined (WinNt assumed)\n" ));
        NtProductType = NtProductWinNt;
    }

    NlpWorkstation = (BOOLEAN)(NtProductType != NtProductLanManNt);



    //
    // Initialize any locks.
    //

    RtlInitializeResource(&NlpActiveLogonLock);

    //
    // initialize the cache - creates a critical section is all
    //

    NlpCacheInitialize();


    //
    // Attempt to load Netlogon.dll
    //

    NlpLoadNetlogonDll();

#ifdef COMPILED_BY_DEVELOPER
    SspPrint((SSP_CRITICAL, "COMPILED_BY_DEVELOPER breakpoint.\n"));
    DbgBreakPoint();
#endif // COMPILED_BY_DEVELOPER



    //
    // Initialize useful encryption constants
    //

    Status = RtlCalculateLmOwfPassword( "", &NlpNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &NlpNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );

    //
    // Initialize the SubAuthentication Dlls
    //

    Msv1_0SubAuthenticationInitialization();




#ifdef notdef
    //
    // If we weren't successful,
    //  Clean up global resources we intended to initialize.
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( NlpComputerName.Buffer != NULL ) {
            MIDL_user_free( NlpComputerName.Buffer );
        }

    }
#endif // notdef

    return STATUS_SUCCESS;

}




NTSTATUS
NlWaitForEvent(
    LPWSTR EventName,
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for EventName to be triggered.

Arguments:

    EventName - Name of event to wait on

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;


    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName);
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            SspPrint((SSP_MISC, "OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }


    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
NlDoingSetup(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if we're running setup.

Arguments:

    NONE.

Return Status:

    TRUE - We're currently running setup
    FALSE - We're not running setup or aren't sure.

--*/

{
    LONG RegStatus;

    HKEY KeyHandle = NULL;
    DWORD ValueType;
    DWORD Value;
    DWORD ValueSize;

    //
    // Open the key for HKLM\SYSTEM\Setup
    //

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    "SYSTEM\\Setup",
                    0,      //Reserved
                    KEY_QUERY_VALUE,
                    &KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_INIT, "NlDoingSetup: Cannot open registy key 'HKLM\\SYSTEM\\Setup' %ld.\n",
                  RegStatus ));
        return FALSE;
    }

    //
    // Get the value that says whether we're doing setup.
    //

    ValueSize = sizeof(Value);
    RegStatus = RegQueryValueExA(
                    KeyHandle,
                    "SystemSetupInProgress",
                    0,
                    &ValueType,
                    (LPBYTE)&Value,
                    &ValueSize );

    RegCloseKey( KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_INIT, "NlDoingSetup: Cannot query value of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress' %ld.\n",
                  RegStatus ));
        return FALSE;
    }

    if ( ValueType != REG_DWORD ) {
        SspPrint((SSP_INIT, "NlDoingSetup: value of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress'is not a REG_DWORD %ld.\n",
                  ValueType ));
        return FALSE;
    }

    if ( ValueSize != sizeof(Value) ) {
        SspPrint((SSP_INIT, "NlDoingSetup: value size of 'HKLM\\SYSTEM\\Setup\\SystemSetupInProgress'is not 4 %ld.\n",
                  ValueSize ));
        return FALSE;
    }

    if ( Value != 1 ) {
        // KdPrint(( "NlDoingSetup: not doing setup\n" ));
        return FALSE;
    }

    SspPrint((SSP_INIT, "NlDoingSetup: doing setup\n" ));
    return TRUE;

}


NTSTATUS
NlWaitForNetlogon(
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for the netlogon service to start.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;


    //
    // If the netlogon service is currently running,
    //  skip the rest of the tests.
    //

    Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 0 );

    if ( NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // If we're in setup,
    //  don't bother waiting for netlogon to start.
    //

    if ( NlDoingSetup() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: OpenSCManager failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_NETLOGON,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: OpenService failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the Netlogon service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceConfig failed: "
                      "%lu\n", NetStatus));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = I_NtLmAllocate( ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceConfig "
                      "failed again: %lu\n", GetLastError()));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType != SERVICE_AUTO_START ) {
        SspPrint((SSP_MISC, "NlWaitForNetlogon: Netlogon start type invalid:"
                          "%lu\n", ServiceConfig->dwStartType ));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }



    //
    // Loop waiting for the netlogon service to start.
    //  (Convert Timeout to a number of 10 second iterations)
    //

    Timeout = (Timeout+9)/10;
    for (;;) {


        //
        // Query the status of the Netlogon service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            SspPrint((SSP_MISC, "NlWaitForNetlogon: QueryServiceStatus failed: "
                          "%lu\n", GetLastError() ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){

                SspPrint((SSP_MISC, "NlWaitForNetlogon: "
                          "Netlogon service couldn't start: %lu %lx\n",
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    SspPrint((SSP_MISC, "         Service specific error code: %lu %lx\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode ));
                }
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If Netlogon has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If Netlogon is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            SspPrint((SSP_MISC, "NlWaitForNetlogon: "
                      "Invalid service state: %lu\n",
                      ServiceStatus.dwCurrentState ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // Wait ten seconds for the netlogon service to start.
        //  If it has successfully started, just return now.
        //

        Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 10 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for netlogon to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        I_NtLmFree( AllocServiceConfig );
    }
    return Status;
}


NTSTATUS
NlSamInitialize(
    ULONG Timeout
    )

/*++

Routine Description:

    Initialize the MSV1_0 Authentication Package's communication to the SAM
    database.  This initialization will take place once immediately prior
    to the first actual use of the SAM database.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status;

    //
    // locals that are staging area for globals.
    //

    UNICODE_STRING PrimaryDomainName;
    PSID SamDomainId = NULL;
    UNICODE_STRING SamDomainName;
    SAMPR_HANDLE SamDomainHandle = NULL;
    BOOLEAN UasCompatibilityRequired;

    UNICODE_STRING DnsTreeName;

    PLSAPR_POLICY_INFORMATION PolicyPrimaryDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    SAMPR_HANDLE SamHandle = NULL;
#ifdef SAM
    PSAMPR_DOMAIN_INFO_BUFFER DomainInfo = NULL;
#endif // SAM

    PrimaryDomainName.Buffer = NULL;
    SamDomainName.Buffer = NULL;
    DnsTreeName.Buffer = NULL;


    //
    // Wait for SAM to finish initialization.
    //

    Status = NlWaitForEvent( L"\\SAM_SERVICE_STARTED", Timeout );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }



    //
    // Determine the DomainName and DomainId of the Account Database
    //

    Status = I_LsarQueryInformationPolicy( NtLmGlobalPolicyHandle,
                                           PolicyAccountDomainInformation,
                                           &PolicyAccountDomainInfo );


    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid == NULL ||
         PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length == 0 ) {
        SspPrint((SSP_MISC, "Account domain info from LSA invalid.\n"));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    Status = I_LsarQueryInformationPolicy(
                                NtLmGlobalPolicyHandle,
                                PolicyPrimaryDomainInformation,
                                &PolicyPrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Length == 0 )
    {
        SspPrint((SSP_CRITICAL, "Primary domain info from LSA invalid.\n"));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }


    //
    // save PrimaryDomainName
    //

    PrimaryDomainName.Length = PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Length;
    PrimaryDomainName.MaximumLength = PrimaryDomainName.Length;

    PrimaryDomainName.Buffer =
            (PWSTR)I_NtLmAllocate( PrimaryDomainName.MaximumLength );

    if ( PrimaryDomainName.Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( PrimaryDomainName.Buffer,
                    PolicyPrimaryDomainInfo->PolicyPrimaryDomainInfo.Name.Buffer,
                    PrimaryDomainName.Length );


    //
    // Save the domain id of this domain
    //

    SamDomainId = I_NtLmAllocate(
                        RtlLengthSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid )
                        );


    if ( SamDomainId == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( SamDomainId,
                   PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                   RtlLengthSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid ));


    //
    // Save the name of the account database on this machine.
    //
    // On a workstation, the account database is refered to by the machine
    // name and not the database name.

    // The above being true, the machine name is set to MACHINENAME during
    // setup and for the duration when the machine has a real machine name
    // until the end of setup, NlpSamDomainName will still have MACHINENAME.
    // This is not what the caller expects to authenticate against, so we
    // force a look from the Lsa all the time.

    // We assume that NlpSamDomainName will get the right info from the Lsa

    SamDomainName.Length = PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length;
    SamDomainName.MaximumLength = (USHORT)
        (SamDomainName.Length + sizeof(WCHAR));

    SamDomainName.Buffer =
        I_NtLmAllocate( SamDomainName.MaximumLength );

    if ( SamDomainName.Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( SamDomainName.Buffer,
                   PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainName.Buffer,
                   SamDomainName.MaximumLength );


    //
    // Open our connection with SAM
    //

    Status = I_SamIConnect( NULL,     // No server name
                            &SamHandle,
                            SAM_SERVER_CONNECT,
                            (BOOLEAN) TRUE );   // Indicate we are privileged

    if ( !NT_SUCCESS(Status) ) {
        SamHandle = NULL;
        SspPrint((SSP_CRITICAL, "Cannot SamIConnect %lX\n", Status));
        goto Cleanup;
    }

    //
    // Open the domain.
    //

    Status = I_SamrOpenDomain( SamHandle,
                               DOMAIN_ALL_ACCESS,
                               SamDomainId,
                               &SamDomainHandle );

    if ( !NT_SUCCESS(Status) ) {
        SamDomainHandle = NULL;
        SspPrint((SSP_CRITICAL, "Cannot SamrOpenDomain %lX\n", Status));
        goto Cleanup;
    }

    //
    // query the TreeName (since SAM was not up during package initialization)
    // update the various globals.
    //


    if( !NlpSamInitialized )
    {
        //
        // make the query before taking the exclusive lock, to avoid possible
        // deadlock conditions.
        //

        SsprQueryTreeName( &DnsTreeName );
    }

    Status = STATUS_SUCCESS;

    RtlAcquireResourceExclusive(&NtLmGlobalCritSect, TRUE);

    if( !NlpSamInitialized ) {

        NlpPrimaryDomainName = PrimaryDomainName;
        NlpSamDomainId = SamDomainId;
        NlpSamDomainName = SamDomainName;
        NlpSamDomainHandle = SamDomainHandle;

        if( NtLmGlobalUnicodeDnsTreeName.Buffer )
        {
            NtLmFree( NtLmGlobalUnicodeDnsTreeName.Buffer );
        }

        NtLmGlobalUnicodeDnsTreeName = DnsTreeName;
        SsprUpdateTargetInfo();


        NlpSamInitialized = TRUE;

        //
        // mark locals invalid so they don't get freed.
        //

        PrimaryDomainName.Buffer = NULL;
        SamDomainId = NULL;
        SamDomainName.Buffer = NULL;
        SamDomainHandle = NULL;
        DnsTreeName.Buffer = NULL;
    }

    RtlReleaseResource(&NtLmGlobalCritSect);


Cleanup:

    if( DnsTreeName.Buffer )
    {
        NtLmFree( DnsTreeName.Buffer );
    }

    if ( PrimaryDomainName.Buffer != NULL ) {
        I_NtLmFree( PrimaryDomainName.Buffer );
    }

    if ( SamDomainName.Buffer != NULL ) {
        I_NtLmFree( SamDomainName.Buffer );
    }

    if ( SamDomainHandle != NULL ) {
        (VOID) I_SamrCloseHandle( &SamDomainHandle );
    }

    if ( SamDomainId != NULL ) {
        I_NtLmFree( SamDomainId );
    }

    if ( PolicyAccountDomainInfo != NULL ) {
        I_LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                             PolicyAccountDomainInfo );
    }

    if ( PolicyPrimaryDomainInfo != NULL ) {
        I_LsaIFree_LSAPR_POLICY_INFORMATION( PolicyPrimaryDomainInformation,
                                             PolicyPrimaryDomainInfo );
    }

    if ( SamHandle != NULL ) {
        (VOID) I_SamrCloseHandle( &SamHandle );
    }


    return Status;

}



NTSTATUS
MspLm20Challenge (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20ChallengeRequest.  It is called by
    the LanMan server to determine the Challenge to pass back to a
    redirector trying to establish a connection to the server.  The server
    is responsible remembering this Challenge and passing in back to this
    authentication package on a subsequent MsV1_0Lm20Logon request.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.




--*/

{
    NTSTATUS Status;
    PMSV1_0_LM20_CHALLENGE_REQUEST ChallengeRequest;
    PMSV1_0_LM20_CHALLENGE_RESPONSE ChallengeResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;


    UNREFERENCED_PARAMETER( ClientBufferBase );

    ASSERT( sizeof(LM_CHALLENGE) == MSV1_0_CHALLENGE_LENGTH );

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_LM20_CHALLENGE_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChallengeRequest = (PMSV1_0_LM20_CHALLENGE_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChallengeRequest->MessageType == MsV1_0Lm20ChallengeRequest );

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_LM20_CHALLENGE_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_CHALLENGE_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ChallengeResponse = (PMSV1_0_LM20_CHALLENGE_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    ChallengeResponse->MessageType = MsV1_0Lm20ChallengeRequest;

    //
    // Compute a random seed.
    //

    Status = SspGenerateRandomBits(
                    ChallengeResponse->ChallengeToClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}

#define NULL_SESSION_REQUESTED RETURN_RESERVED_PARAMETER

NTSTATUS
MspLm20GetChallengeResponse (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GetChallengeResponse.  It is called by
    the LanMan redirector to determine the Challenge Response to pass to a
    server when trying to establish a connection to the server.

    This routine is passed a Challenge from the server.  This routine encrypts
    the challenge with either the specified password or with the password
    implied by the specified Logon Id.

    Two Challenge responses are returned.  One is based on the Unicode password
    as given to the Authentication package.  The other is based on that
    password converted to a multi-byte character set (e.g., ASCII) and upper
    cased.  The redirector should use whichever (or both) challenge responses
    as it needs them.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    PMSV1_0_GETCHALLENRESP_REQUEST GetRespRequest;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_GETCHALLENRESP_RESPONSE GetRespResponse;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    PMSV1_0_PRIMARY_CREDENTIAL PrimaryCredential = NULL;
    MSV1_0_PRIMARY_CREDENTIAL BuiltCredential;

    //
    // Responses to return to the caller.
    //
    LM_RESPONSE LmResponse;
    STRING LmResponseString;

    NT_RESPONSE NtResponse;
    STRING NtResponseString;

    PMSV1_0_NTLM3_RESPONSE pNtlm3Response = NULL;

    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY UserSessionKey;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG NtLmProtocolSupported;

    //
    // Initialization
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    RtlInitUnicodeString( &UserName, NULL );
    RtlInitUnicodeString( &LogonDomainName, NULL );

    RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
    RtlZeroMemory( LanmanSessionKey, sizeof(LanmanSessionKey) );

    //
    // If no credentials are associated with the client, a null session
    // will be used.  For a downlevel server, the null session response is
    // a 1-byte null string (\0).  Initialize LmResponseString to the
    // null session response.
    //

    RtlInitString( &LmResponseString, "" );
    LmResponseString.Length = 1;

    //
    // Initialize the NT response to the NT null session credentials,
    // which are zero length.
    //

    RtlInitString( &NtResponseString, NULL );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_GETCHALLENRESP_REQUEST_V1) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GetRespRequest = (PMSV1_0_GETCHALLENRESP_REQUEST) ProtocolSubmitBuffer;

    ASSERT( GetRespRequest->MessageType == MsV1_0Lm20GetChallengeResponse );

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {
        RELOCATE_ONE( &GetRespRequest->Password );
    }



    //
    // If we don't support the request (such as the caller is asking for an
    // LM challenge response and we do't support it, return an error here.
    //

    NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;

    //
    // allow protocol to be downgraded to NTLM from NTLMv2 if so requested.
    //

    if( (NtLmProtocolSupported >= UseNtlm3) &&
        (GetRespRequest->ParameterControl & GCR_ALLOW_NTLM) )
    {
        NtLmProtocolSupported = NoLm;
    }


    if ( (GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY) &&
        NtLmProtocolSupported == NoLm ) {

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    if ( GetRespRequest->ParameterControl & GCR_MACHINE_CREDENTIAL )
    {
        SECPKG_CLIENT_INFO ClientInfo;
        LUID SystemLuid = SYSTEM_LUID;

        //
        // if caller wants machine cred, check they are SYSTEM.
        // if so, whack the LogonId to point at the machine logon.
        //

        Status = LsaFunctions->GetClientInfo( &ClientInfo );

        if( !NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }

        if(!RtlEqualLuid( &ClientInfo.LogonId, &SystemLuid ))
        {
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        GetRespRequest->LogonId = NtLmGlobalLuidMachineLogon;
    }

    //
    // if caller wants NTLM++, so be it...
    //

    if ( (GetRespRequest->ParameterControl & GCR_NTLM3_PARMS) ) {
        PMSV1_0_AV_PAIR pAV;

        UCHAR TargetInfoBuffer[3*sizeof(MSV1_0_AV_PAIR) + (DNS_MAX_NAME_LENGTH+CNLEN+2)*sizeof(WCHAR)];

        NULL_RELOCATE_ONE( &GetRespRequest->UserName );
        NULL_RELOCATE_ONE( &GetRespRequest->LogonDomainName );
        NULL_RELOCATE_ONE( &GetRespRequest->ServerName );


        // if target is just a domain name or domain name followed by
        //  server name, make it into an AV pair list
        if (!(GetRespRequest->ParameterControl & GCR_TARGET_INFO)) {
            UNICODE_STRING DomainName;
            UNICODE_STRING ServerName;
            unsigned int i;

            //
            // check length of name to make sure it fits in my buffer
            //

            if (GetRespRequest->ServerName.Length > (DNS_MAX_NAME_LENGTH+CNLEN+2)*sizeof(WCHAR)) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // init AV list in temp buffer
            //

            pAV = MsvpAvlInit(TargetInfoBuffer);

            //
            // see if there's a NULL in the middle of the server name
            //  that indicates that it's really a domain name followed by a server name
            //

            DomainName = GetRespRequest->ServerName;
            ServerName.Length = 0;

            for (i = 0; i < (DomainName.Length/sizeof(WCHAR)); i++) {
                if ( DomainName.Buffer[i] == L'\0' )
                {
                    // take length of domain name without the NULL
                    DomainName.Length = (USHORT) i*sizeof(WCHAR);
                    // adjust server name and length to point after the domain name
                    ServerName.Length = GetRespRequest->ServerName.Length - (i+1)*sizeof(WCHAR);
                    ServerName.Buffer = GetRespRequest->ServerName.Buffer + (i+1);
                    break;
                }
            }

            //
            // strip off possible trailing null after the server name
            //

            for (i = 0; i < (ServerName.Length / sizeof(WCHAR)); i++) {
                if (ServerName.Buffer[i] == L'\0')
                {
                    ServerName.Length = (USHORT)i*sizeof(WCHAR);
                    break;
                }
            }

            //
            // put both names in the AV list (if both exist)
            //

            MsvpAvlAdd(pAV, MsvAvNbDomainName, &DomainName, sizeof(TargetInfoBuffer));
            if (ServerName.Length > 0) {
                MsvpAvlAdd(pAV, MsvAvNbComputerName, &ServerName, sizeof(TargetInfoBuffer));
            }

            //
            // make the request point at AV list instead of names.
            //

            GetRespRequest->ServerName.Length = (USHORT)MsvpAvlLen(pAV, sizeof(TargetInfoBuffer));
            GetRespRequest->ServerName.Buffer = (PWCHAR)pAV;
        }

        //
        // if we're only using NTLMv2 or better, then complain if either
        //  computer name or server name missing
        //

        if (NtLmProtocolSupported >= RefuseNtlm3NoTarget) {
            pAV = (PMSV1_0_AV_PAIR)GetRespRequest->ServerName.Buffer;
            if ((pAV==NULL) ||
                MsvpAvlGet(pAV, MsvAvNbDomainName, GetRespRequest->ServerName.Length) == NULL ||
                MsvpAvlGet(pAV, MsvAvNbComputerName, GetRespRequest->ServerName.Length) == NULL) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }


    //
    // If the caller wants information from the credentials of a specified
    //  LogonId, get those credentials from the LSA.
    //
    // If there are no such credentials,
    //  tell the caller to use the NULL session.
    //

#define PRIMARY_CREDENTIAL_NEEDED \
        (RETURN_PRIMARY_LOGON_DOMAINNAME | \
        RETURN_PRIMARY_USERNAME | \
        USE_PRIMARY_PASSWORD )

    if ( ((GetRespRequest->ParameterControl & PRIMARY_CREDENTIAL_NEEDED) != 0 ) && ((GetRespRequest->ParameterControl & NULL_SESSION_REQUESTED) == 0)) {

        Status = NlpGetPrimaryCredential(
                        &GetRespRequest->LogonId,
                        &PrimaryCredential,
                        NULL );

        if ( NT_SUCCESS(Status) ) {

            if ( GetRespRequest->ParameterControl & RETURN_PRIMARY_USERNAME ) {
                UserName = PrimaryCredential->UserName;
            }

            if ( GetRespRequest->ParameterControl &
                 RETURN_PRIMARY_LOGON_DOMAINNAME ) {

#ifndef DONT_MAP_DOMAIN_ON_REQUEST
                //
                // Map the user's logon domain against the current mapping
                // in the registry.
                //

                Status = NlpMapLogonDomain(
                            &LogonDomainName,
                            &PrimaryCredential->LogonDomainName
                            );
                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }
#else
                LogonDomainName = PrimaryCredential->LogonDomainName;
#endif
            }

        } else if ( Status == STATUS_NO_SUCH_LOGON_SESSION ||
                    Status == STATUS_UNSUCCESSFUL ) {

            //
            // Clean up the status code
            //

            Status = STATUS_NO_SUCH_LOGON_SESSION;

            //
            // If the caller wants at least the password from the primary
            //  credential, just use a NULL session primary credential.
            //

            if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD ) ==
                    USE_PRIMARY_PASSWORD ) {

                PrimaryCredential = NULL;

            //
            // If part of the information was supplied by the caller,
            //  report the error to the caller.
            //
            } else {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: cannot "
                         " GetPrimaryCredential %lx\n", Status ));
                goto Cleanup;
            }
        } else {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: cannot "
                         " GetPrimaryCredential %lx\n", Status ));
                goto Cleanup;
        }

        Credential = PrimaryCredential;

    }


    //
    // If the caller passed in a password to use,
    //  use it to build a credential.
    //

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {

        NlpPutOwfsInPrimaryCredential( &GetRespRequest->Password,
                                       &BuiltCredential );

        //
        // Use the newly allocated credential to get the password information
        // from.
        //
        Credential = &BuiltCredential;

    }

    //
    // Build the appropriate response.
    //

    if ( Credential != NULL ) {

        //
        // If the DC is asserted to have been upgraded, we should use NTLM3
        //  if caller supplies the NTLM3 parameters
        //

        if ((NtLmProtocolSupported >= UseNtlm3) &&
            (GetRespRequest->ParameterControl & GCR_NTLM3_PARMS)
            ) {

            USHORT Ntlm3ResponseSize;
            UNICODE_STRING Ntlm3UserName;
            UNICODE_STRING Ntlm3LogonDomainName;
            UNICODE_STRING Ntlm3ServerName;

            // use the server name supplied by the caller
            Ntlm3ServerName = GetRespRequest->ServerName;

            // even if user name and domain are supplied, use current logged
            //  in user if so requested

            if (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) {
                Ntlm3UserName = Credential->UserName;
                Ntlm3LogonDomainName = Credential->LogonDomainName;
            } else {
                Ntlm3UserName = GetRespRequest->UserName;
                Ntlm3LogonDomainName = GetRespRequest->LogonDomainName;
            }

            //
            // Allocate the response
            //

            Ntlm3ResponseSize =
                sizeof(MSV1_0_NTLM3_RESPONSE) + Ntlm3ServerName.Length;

            pNtlm3Response = (*Lsa.AllocatePrivateHeap)( Ntlm3ResponseSize );

            if ( pNtlm3Response == NULL ) {
                SspPrint((SSP_CRITICAL, "MspLm20GetChallengeResponse: No memory %ld\n",
                    Ntlm3ResponseSize ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            MsvpLm20GetNtlm3ChallengeResponse(
                &Credential->NtOwfPassword,
                &Ntlm3UserName,
                &Ntlm3LogonDomainName,
                &Ntlm3ServerName,
                GetRespRequest->ChallengeToClient,
                pNtlm3Response,
                (PMSV1_0_LM3_RESPONSE)&LmResponse,
                &UserSessionKey,
                (PLM_SESSION_KEY)LanmanSessionKey
                );

            NtResponseString.Buffer = (PUCHAR) pNtlm3Response;
            NtResponseString.Length = Ntlm3ResponseSize;
            LmResponseString.Buffer = (PUCHAR) &LmResponse;
            LmResponseString.Length = sizeof(LmResponse);
        } else {

            //
            // if requested, generate our own challenge, and mix it with that
            //  of the server's
            //

            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                SspGenerateRandomBits(ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);

#ifdef USE_CONSTANT_CHALLENGE
                RtlZeroMemory(ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);
#endif

                RtlCopyMemory(
                    ChallengeToClient,
                    GetRespRequest->ChallengeToClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );

                MsvpCalculateNtlm2Challenge (
                    GetRespRequest->ChallengeToClient,
                    ChallengeFromClient,
                    GetRespRequest->ChallengeToClient
                    );

            }

            Status = RtlCalculateNtResponse(
                        (PNT_CHALLENGE) GetRespRequest->ChallengeToClient,
                        &Credential->NtOwfPassword,
                        &NtResponse );

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }


            //
            // send the client challenge back in the LM response slot if we made one
            //
            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                RtlZeroMemory(
                    &LmResponse,
                    sizeof(LmResponse)
                    );

                RtlCopyMemory(
                    &LmResponse,
                    ChallengeFromClient,
                    MSV1_0_CHALLENGE_LENGTH
                    );
            //
            // Return the LM response if policy set that way for backwards compatibility.
            //

            } else if ((NtLmProtocolSupported <= AllowLm) ) {
                Status = RtlCalculateLmResponse(
                            (PLM_CHALLENGE) GetRespRequest->ChallengeToClient,
                            &Credential->LmOwfPassword,
                            &LmResponse );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

            //
            //
            //  Can't return LM response -- so use NT response
            //   (to allow LM_KEY generatation)
            //

            } else {
                RtlCopyMemory(
                        &LmResponse,
                        &NtResponse,
                        sizeof(LmResponse)
                        );
            }

            NtResponseString.Buffer = (PUCHAR) &NtResponse;
            NtResponseString.Length = sizeof(NtResponse);
            LmResponseString.Buffer = (PUCHAR) &LmResponse;
            LmResponseString.Length = sizeof(LmResponse);

            //
            // Compute the session keys
            //

            if (GetRespRequest->ParameterControl & GENERATE_CLIENT_CHALLENGE) {

                //
                // assert: we're talking to an NT4-SP4 or later server
                //          and the user's DC hasn't been upgraded to NTLM++
                //  generate session key from MD4(NT hash) -
                //  aka NtUserSessionKey - that is different for each session
                //

                Status = RtlCalculateUserSessionKeyNt(
                                &NtResponse,
                                &Credential->NtOwfPassword,
                                &UserSessionKey );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

                MsvpCalculateNtlm2SessionKeys(
                    &UserSessionKey,
                    ChallengeToClient,
                    ChallengeFromClient,
                    (PUSER_SESSION_KEY)&UserSessionKey,
                    (PLM_SESSION_KEY)LanmanSessionKey
                    );

            } else if ( GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY){

                //
                // If the redir didn't negotiate an NT protocol with the server,
                //  use the lanman session key.
                //

                if ( Credential->LmPasswordPresent ) {

                    ASSERT( sizeof(UserSessionKey) >= sizeof(LanmanSessionKey) );

                    RtlCopyMemory( &UserSessionKey,
                                   &Credential->LmOwfPassword,
                                   sizeof(LanmanSessionKey) );
                }

            } else {

                if ( !Credential->NtPasswordPresent ) {

                    RtlCopyMemory( &Credential->NtOwfPassword,
                                &NlpNullNtOwfPassword,
                                sizeof(Credential->NtOwfPassword) );
                }

                Status = RtlCalculateUserSessionKeyNt(
                                &NtResponse,
                                &Credential->NtOwfPassword,
                                &UserSessionKey );

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }
            }

            if ( Credential->LmPasswordPresent ) {
                RtlCopyMemory( LanmanSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

        } // UseNtlm3

    }


    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_GETCHALLENRESP_RESPONSE) +
                        LogonDomainName.Length + sizeof(WCHAR) +
                        UserName.Length + sizeof(WCHAR) +
                        NtResponseString.Length + sizeof(WCHAR) +
                        LmResponseString.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_GETCHALLENRESP_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    GetRespResponse = (PMSV1_0_GETCHALLENRESP_RESPONSE) ClientBufferDesc.MsvBuffer;


    //
    // Fill in the return buffer.
    //

    GetRespResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
    RtlCopyMemory( GetRespResponse->UserSessionKey,
                   &UserSessionKey,
                   sizeof(UserSessionKey));
    RtlCopyMemory( GetRespResponse->LanmanSessionKey,
                   LanmanSessionKey,
                   sizeof(LanmanSessionKey) );


    //
    // Copy the logon domain name (the string may be empty)
    //

    NlpPutClientString( &ClientBufferDesc,
                        &GetRespResponse->LogonDomainName,
                        &LogonDomainName );

    //
    // Copy the user name (the string may be empty)
    //

    NlpPutClientString( &ClientBufferDesc,
                        &GetRespResponse->UserName,
                        &UserName );

    //
    // Copy the Challenge Responses to the client buffer.
    //

    NlpPutClientString(
                &ClientBufferDesc,
                (PUNICODE_STRING)
                    &GetRespResponse->CaseSensitiveChallengeResponse,
                (PUNICODE_STRING) &NtResponseString );

    NlpPutClientString(
                &ClientBufferDesc,
                (PUNICODE_STRING)
                    &GetRespResponse->CaseInsensitiveChallengeResponse,
                (PUNICODE_STRING)&LmResponseString );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Cleanup locally used resources
    //

    if ( PrimaryCredential != NULL ) {
        (*Lsa.FreeLsaHeap)( PrimaryCredential );
    }

#ifndef DONT_MAP_DOMAIN_ON_REQUEST

    if (LogonDomainName.Buffer != NULL) {
        NtLmFree(LogonDomainName.Buffer);
    }
#endif

    if ( pNtlm3Response != NULL ) {
        (*Lsa.FreePrivateHeap)( pNtlm3Response );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20EnumUsers (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20EnumerateUsers.  This routine
    enumerates all of the interactive, service, and batch logons to the MSV1_0
    authentication package.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.



--*/

{
    NTSTATUS Status;
    PMSV1_0_ENUMUSERS_REQUEST EnumRequest;
    PMSV1_0_ENUMUSERS_RESPONSE EnumResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    ULONG LogonCount = 0;
    PACTIVE_LOGON Logon;
    BOOLEAN ActiveLogonsAreLocked = FALSE;

    PUCHAR Where;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    UNREFERENCED_PARAMETER( ClientBufferBase );

    if ( SubmitBufferSize < sizeof(MSV1_0_ENUMUSERS_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    EnumRequest = (PMSV1_0_ENUMUSERS_REQUEST) ProtocolSubmitBuffer;

    ASSERT( EnumRequest->MessageType == MsV1_0EnumerateUsers );

    //
    // Count the current number of active logons
    //

    NlpLockActiveLogonsRead();
    ActiveLogonsAreLocked = TRUE;

    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next )
    {
        //
        // don't count the machine account logon.
        //

        if( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &Logon->LogonId) )
        {
            continue;
        }

        LogonCount ++;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_ENUMUSERS_RESPONSE) +
                            LogonCount * (sizeof(LUID) + sizeof(ULONG));


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_ENUMUSERS_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    EnumResponse = (PMSV1_0_ENUMUSERS_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    EnumResponse->MessageType = MsV1_0EnumerateUsers;
    EnumResponse->NumberOfLoggedOnUsers = LogonCount;

    Where = (PUCHAR)(EnumResponse + 1);

    //
    // Loop through the Active Logon Table copying the LogonId of each session.
    //

    EnumResponse->LogonIds = (PLUID)(ClientBufferDesc.UserBuffer +
                                (Where - ClientBufferDesc.MsvBuffer));
    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next )
    {
        //
        // don't count the machine account logon.
        //

        if( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &Logon->LogonId) )
        {
            continue;
        }

        *((PLUID)Where) = Logon->LogonId,
        Where += sizeof(LUID);
    }

    //
    // Loop through the Active Logon Table copying the EnumHandle of
    //  each session.
    //

    EnumResponse->EnumHandles = (PULONG)(ClientBufferDesc.UserBuffer +
                                    (Where - ClientBufferDesc.MsvBuffer));
    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next )
    {
        //
        // don't count the machine account logon.
        //

        if( RtlEqualLuid(&NtLmGlobalLuidMachineLogon, &Logon->LogonId) )
        {
            continue;
        }

        *((PULONG)Where) = Logon->EnumHandle,
        Where += sizeof(ULONG);
    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // Be sure to unlock the lock on the Active logon list.
    //

    if ( ActiveLogonsAreLocked ) {
        NlpUnlockActiveLogons();
    }

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20GetUserInfo (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0GetUserInfo.  This routine
    returns information describing a particular Logon Id.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.



--*/

{
    NTSTATUS Status;
    PMSV1_0_GETUSERINFO_REQUEST GetInfoRequest;
    PMSV1_0_GETUSERINFO_RESPONSE GetInfoResponse = NULL;

    CLIENT_BUFFER_DESC ClientBufferDesc;

    BOOLEAN ActiveLogonsAreLocked = FALSE;
    PACTIVE_LOGON *ActiveLogon;
    PACTIVE_LOGON Logon;
    ULONG SidLength;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    UNREFERENCED_PARAMETER( ClientBufferBase );

    if ( SubmitBufferSize < sizeof(MSV1_0_GETUSERINFO_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GetInfoRequest = (PMSV1_0_GETUSERINFO_REQUEST) ProtocolSubmitBuffer;

    ASSERT( GetInfoRequest->MessageType == MsV1_0GetUserInfo );

    //
    // Find the Active logon entry for this particular Logon Id.
    //

    NlpLockActiveLogonsRead();
    ActiveLogonsAreLocked = TRUE;

    if (!NlpFindActiveLogon( &GetInfoRequest->LogonId, &ActiveLogon )){
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    Logon = *ActiveLogon;

    //
    // Allocate a buffer to return to the caller.
    //

    SidLength = RtlLengthSid( Logon->UserSid );
    *ReturnBufferSize = sizeof(MSV1_0_GETUSERINFO_RESPONSE) +
                            Logon->UserName.Length + sizeof(WCHAR) +
                            Logon->LogonDomainName.Length + sizeof(WCHAR) +
                            Logon->LogonServer.Length + sizeof(WCHAR) +
                            SidLength;


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_GETUSERINFO_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    GetInfoResponse = (PMSV1_0_GETUSERINFO_RESPONSE) ClientBufferDesc.MsvBuffer;


    //
    // Fill in the return buffer.
    //

    GetInfoResponse->MessageType = MsV1_0GetUserInfo;
    GetInfoResponse->LogonType = Logon->LogonType;

    //
    // Copy ULONG aligned data first
    //

    GetInfoResponse->UserSid = ClientBufferDesc.UserBuffer +
                               ClientBufferDesc.StringOffset;

    RtlCopyMemory( ClientBufferDesc.MsvBuffer + ClientBufferDesc.StringOffset,
                   Logon->UserSid,
                   SidLength );

    ClientBufferDesc.StringOffset += SidLength;

    //
    // Copy WCHAR aligned data
    //

    NlpPutClientString( &ClientBufferDesc,
                        &GetInfoResponse->UserName,
                        &Logon->UserName );

    NlpPutClientString( &ClientBufferDesc,
                        &GetInfoResponse->LogonDomainName,
                        &Logon->LogonDomainName );

    NlpPutClientString( &ClientBufferDesc,
                        &GetInfoResponse->LogonServer,
                        &Logon->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );

Cleanup:

    //
    // Be sure to unlock the lock on the Active logon list.
    //

    if ( ActiveLogonsAreLocked ) {
        NlpUnlockActiveLogons();
    }

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    //
    // Return status to the caller.
    //

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;

}


NTSTATUS
MspLm20ReLogonUsers (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0RelogonUsers.  For each logon session
    which was validated by the specified domain controller,  the logon session
    is re-established with that same domain controller.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{
    UNREFERENCED_PARAMETER( ClientRequest );
    UNREFERENCED_PARAMETER( ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER( ClientBufferBase);
    UNREFERENCED_PARAMETER( SubmitBufferSize);
    UNREFERENCED_PARAMETER( ReturnBufferSize);

    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_NOT_IMPLEMENTED;
    return STATUS_SUCCESS;

}



NTSTATUS
MspLm20GenericPassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GenericPassthrough. It is called by
    a client wishing to make a CallAuthenticationPackage call against
    a domain controller.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.




--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    BOOLEAN Authoritative;
    PNETLOGON_VALIDATION_GENERIC_INFO ValidationGeneric = NULL;

    NETLOGON_GENERIC_INFO LogonGeneric;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInformation;

    //
    // WMI tracing helper struct
    //
    NTLM_TRACE_INFO TraceInfo = {0};

    //
    // Begin tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag){

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmGenericPassthroughGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }



    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_PASSTHROUGH_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) ProtocolSubmitBuffer;

    RELOCATE_ONE( &PassthroughRequest->DomainName );
    RELOCATE_ONE( &PassthroughRequest->PackageName );

    //
    // Make sure the buffer fits in the supplied size
    //

    if (PassthroughRequest->LogonData != NULL) {

        if (PassthroughRequest->LogonData + PassthroughRequest->DataLength <
            PassthroughRequest->LogonData ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ((ULONG_PTR)ClientBufferBase + SubmitBufferSize < (ULONG_PTR)ClientBufferBase ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (PassthroughRequest->LogonData + PassthroughRequest->DataLength >
            (PUCHAR) ClientBufferBase + SubmitBufferSize) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Reset the pointers for the validation data
        //

        PassthroughRequest->LogonData =
                (PUCHAR) PassthroughRequest -
                (ULONG_PTR) ClientBufferBase +
                (ULONG_PTR) PassthroughRequest->LogonData;

    }

    //
    // Build the structure to pass to Netlogon
    //

    RtlZeroMemory(
        &LogonGeneric,
        sizeof(LogonGeneric)
        );

    LogonGeneric.Identity.LogonDomainName = PassthroughRequest->DomainName;
    LogonGeneric.PackageName = PassthroughRequest->PackageName;
    LogonGeneric.LogonData = PassthroughRequest->LogonData;
    LogonGeneric.DataLength = PassthroughRequest->DataLength;

    LogonInformation =
        (PNETLOGON_LOGON_IDENTITY_INFO) &LogonGeneric;

    //
    // Call Netlogon to remote the request
    //

    //
    // Wait for NETLOGON to finish initialization.
    //

    if ( !NlpNetlogonInitialized ) {

        Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

        if ( !NT_SUCCESS(Status) ) {
            if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                goto Cleanup;
            }
        } else {
            NlpNetlogonInitialized = TRUE;
        }
    }

    if ( NlpNetlogonInitialized ) {

        //
        // Trace the domain name and package name
        //
        if (NtlmGlobalEventTraceFlag){

            //Header goo
            SET_TRACE_HEADER(TraceInfo,
                             NtlmGenericPassthroughGuid,
                             EVENT_TRACE_TYPE_INFO,
                             WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                             4);

            SET_TRACE_USTRING(TraceInfo,
                              TRACE_PASSTHROUGH_DOMAIN,
                              LogonGeneric.Identity.LogonDomainName);

            SET_TRACE_USTRING(TraceInfo,
                              TRACE_PASSTHROUGH_PACKAGE,
                              LogonGeneric.PackageName);

            TraceEvent(
                NtlmGlobalTraceLoggerHandle,
                (PEVENT_TRACE_HEADER)&TraceInfo
                );
        }

        Status = (*NlpNetLogonSamLogon)(
                    NULL,           // Server name
                    NULL,           // Computer name
                    NULL,           // Authenticator
                    NULL,           // ReturnAuthenticator
                    NetlogonGenericInformation,
                    (LPBYTE) &LogonInformation,
                    NetlogonValidationGenericInfo2,
                    (LPBYTE *) &ValidationGeneric,
                    &Authoritative );

        //
        // Reset Netlogon initialized flag if local netlogon cannot be
        //  reached.
        //  (Use a more explicit status code)
        //

        if ( Status == RPC_NT_SERVER_UNAVAILABLE ||
             Status == RPC_NT_UNKNOWN_IF ||
             Status == STATUS_NETLOGON_NOT_STARTED ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            NlpNetlogonInitialized = FALSE;

        }
    } else {

        //
        // no netlogon: see if the request is destined for the local domain,
        // to allow WORKGROUP support.
        //

        if (  LogonInformation->LogonDomainName.Length == 0 ||
             (LogonInformation->LogonDomainName.Length != 0 &&
              RtlEqualDomainName( &NlpSamDomainName,
                                     &LogonInformation->LogonDomainName ) )
            ) {


            PNETLOGON_GENERIC_INFO GenericInfo;
            NETLOGON_VALIDATION_GENERIC_INFO GenericValidation;
            NTSTATUS ProtocolStatus;

            GenericInfo = (PNETLOGON_GENERIC_INFO) LogonInformation;
            GenericValidation.ValidationData = NULL;
            GenericValidation.DataLength = 0;

            //
            // unwrap passthrough message and pass it off to dispatch.
            //

            Status = LsaICallPackagePassthrough(
                        &GenericInfo->PackageName,
                        0,  // Indicate pointers are relative.
                        GenericInfo->LogonData,
                        GenericInfo->DataLength,
                        (PVOID *) &GenericValidation.ValidationData,
                        &GenericValidation.DataLength,
                        &ProtocolStatus
                        );

            if(NT_SUCCESS( Status ) )
                Status = ProtocolStatus;


            //
            // If the call succeeded, allocate the return message.
            //

            if (NT_SUCCESS(Status)) {
                PNETLOGON_VALIDATION_GENERIC_INFO ReturnInfo;
                ULONG ValidationLength;

                ValidationLength = sizeof(*ReturnInfo) + GenericValidation.DataLength;

                ReturnInfo = (PNETLOGON_VALIDATION_GENERIC_INFO) MIDL_user_allocate(
                                ValidationLength
                                );

                if (ReturnInfo != NULL) {
                    if ( GenericValidation.DataLength == 0 ||
                         GenericValidation.ValidationData == NULL ) {
                        ReturnInfo->DataLength = 0;
                        ReturnInfo->ValidationData = NULL;
                    } else {

                        ReturnInfo->DataLength = GenericValidation.DataLength;
                        ReturnInfo->ValidationData = (PUCHAR) (ReturnInfo + 1);

                        RtlCopyMemory(
                            ReturnInfo->ValidationData,
                            GenericValidation.ValidationData,
                            ReturnInfo->DataLength );

                    }

                    ValidationGeneric = ReturnInfo;

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (GenericValidation.ValidationData != NULL) {
                    LsaIFreeReturnBuffer(GenericValidation.ValidationData);
                }

            }


        } else {
            Status = STATUS_NETLOGON_NOT_STARTED;
        }
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_PASSTHROUGH_RESPONSE) +
                        ValidationGeneric->DataLength;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_PASSTHROUGH_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    PassthroughResponse = (PMSV1_0_PASSTHROUGH_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    PassthroughResponse->MessageType = MsV1_0GenericPassthrough;
    PassthroughResponse->DataLength = ValidationGeneric->DataLength;
    PassthroughResponse->ValidationData = ClientBufferDesc.UserBuffer + sizeof(MSV1_0_PASSTHROUGH_RESPONSE);


    RtlCopyMemory(
        PassthroughResponse + 1,
        ValidationGeneric->ValidationData,
        ValidationGeneric->DataLength
        );

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if (ValidationGeneric != NULL) {
        MIDL_user_free(ValidationGeneric);
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    if (NtlmGlobalEventTraceFlag){

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmGenericPassthroughGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);

}


NTSTATUS
MspLm20CacheLogon (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20CacheLogon. It is called by
    a client wishing to cache logon information in the logon cache

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.




--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_CACHE_LOGON_REQUEST CacheRequest;

    PNETLOGON_INTERACTIVE_INFO LogonInfo;
    NETLOGON_VALIDATION_SAM_INFO4 ValidationInfo;

    PVOID SupplementalCacheData = NULL;
    ULONG SupplementalCacheDataLength = 0;
    ULONG CacheRequestFlags = 0;

    //
    // NOTE: this entry point only allows callers within the LSA process
    //

    if (ClientRequest != NULL) {
        *ProtocolStatus = STATUS_ACCESS_DENIED;
        return(STATUS_SUCCESS);
    }

    CacheRequest = (PMSV1_0_CACHE_LOGON_REQUEST) ProtocolSubmitBuffer;




    if ( SubmitBufferSize <= sizeof( MSV1_0_CACHE_LOGON_REQUEST_OLD ) ||
         SubmitBufferSize > sizeof( MSV1_0_CACHE_LOGON_REQUEST ))
    {
        Status  = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( SubmitBufferSize >= sizeof( MSV1_0_CACHE_LOGON_REQUEST_W2K ))
    {
        SupplementalCacheData = CacheRequest->SupplementalCacheData;
        SupplementalCacheDataLength = CacheRequest->SupplementalCacheDataLength;

        if ( SubmitBufferSize == sizeof( MSV1_0_CACHE_LOGON_REQUEST ))
        {
            CacheRequestFlags = CacheRequest->RequestFlags;
        }

    }

    LogonInfo = (PNETLOGON_INTERACTIVE_INFO) CacheRequest->LogonInformation;

    if( (CacheRequestFlags & MSV1_0_CACHE_LOGON_REQUEST_INFO4) == 0 )
    {
        RtlZeroMemory( &ValidationInfo, sizeof(ValidationInfo));
        RtlCopyMemory( &ValidationInfo,
                       CacheRequest->ValidationInformation,
                       sizeof(NETLOGON_VALIDATION_SAM_INFO2) );
    } else {
        RtlCopyMemory( &ValidationInfo,
                       CacheRequest->ValidationInformation,
                       sizeof(NETLOGON_VALIDATION_SAM_INFO4) );
    }



    *ProtocolStatus = STATUS_SUCCESS;


    if (( CacheRequestFlags & MSV1_0_CACHE_LOGON_DELETE_ENTRY) != 0 )
    {
        *ProtocolStatus = NlpDeleteCacheEntry( LogonInfo );
    }
    else
    //
    // Actually add the cache entry
    //
    {

        *ProtocolStatus = NlpAddCacheEntry(
                                LogonInfo,
                                &ValidationInfo,
                                SupplementalCacheData,
                                SupplementalCacheDataLength,
                                CacheRequestFlags
                                );

    }

Cleanup:

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( ClientRequest);
    UNREFERENCED_PARAMETER( ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER( ClientBufferBase);
    UNREFERENCED_PARAMETER( ReturnBufferSize);
}


NTSTATUS
MspLm20CacheLookup (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20CacheLookup. It is called by
    a client wishing to extract cache logon information and optionally
    verify the credential.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.




--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_CACHE_LOOKUP_REQUEST CacheRequest;
    PMSV1_0_CACHE_LOOKUP_RESPONSE CacheResponse;
    NETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo = NULL;
    CACHE_PASSWORDS cachePasswords;
    CLIENT_BUFFER_DESC ClientBufferDesc;

    PNT_OWF_PASSWORD pNtOwfPassword = NULL;
    NT_OWF_PASSWORD ComputedNtOwfPassword;

    PVOID SupplementalCacheData = NULL;
    ULONG SupplementalCacheDataLength;

    //
    // Ensure the client is from the LSA process
    //

    if (ClientRequest != NULL) {
        *ProtocolStatus = STATUS_ACCESS_DENIED;
        return(STATUS_SUCCESS);
    }

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );


    *ProtocolStatus = STATUS_SUCCESS;


    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_CACHE_LOOKUP_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    CacheRequest = (PMSV1_0_CACHE_LOOKUP_REQUEST) ProtocolSubmitBuffer;
    RtlZeroMemory(
        &LogonInfo,
        sizeof(LogonInfo)
        );

    //
    // NOTE: this submit call only supports in-process calls within the LSA
    // so buffers within the submit buffer are assumed to be valid and
    // hence not validated in the same way that out-proc calls are.
    //

    LogonInfo.LogonDomainName = CacheRequest->DomainName;
    LogonInfo.UserName = CacheRequest->UserName;



    if( CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_NONE &&
        CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW &&
        CacheRequest->CredentialType != MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // get the cache entry
    //

    *ProtocolStatus = NlpGetCacheEntry(
                            &LogonInfo,
                            &ValidationInfo,
                            &cachePasswords,
                            &SupplementalCacheData,
                            &SupplementalCacheDataLength
                            );

    if (!NT_SUCCESS(*ProtocolStatus)) {
        goto Cleanup;
    }

    if( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_NONE ) {
        if( CacheRequest->CredentialInfoLength != 0 ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    //
    // verify the password, if necessary.
    //

    if( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW ) {

        //
        // convert RAW to NTOWF.
        //

        UNICODE_STRING TempPassword;

        if( CacheRequest->CredentialInfoLength > 0xFFFF ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TempPassword.Buffer = (PWSTR)&CacheRequest->CredentialSubmitBuffer;
        TempPassword.Length = (USHORT)CacheRequest->CredentialInfoLength;
        TempPassword.MaximumLength = TempPassword.Length;

        pNtOwfPassword = &ComputedNtOwfPassword;

        Status = RtlCalculateNtOwfPassword( &TempPassword, pNtOwfPassword );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        //
        // now, convert the request to NT_OWF style.
        //

        CacheRequest->CredentialType = MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF;
        CacheRequest->CredentialInfoLength = sizeof( NT_OWF_PASSWORD );

    }

    if( CacheRequest->CredentialType == MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF ) {
        if( CacheRequest->CredentialInfoLength != sizeof( NT_OWF_PASSWORD ) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( !cachePasswords.SecretPasswords.NtPasswordPresent ) {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        if( pNtOwfPassword == NULL ) {
            pNtOwfPassword = (PNT_OWF_PASSWORD)&CacheRequest->CredentialSubmitBuffer;
        }

        Status = NlpComputeSaltedHashedPassword(
                    pNtOwfPassword,
                    pNtOwfPassword,
                    &ValidationInfo->EffectiveName
                    );

        if(!NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        if(RtlCompareMemory(
                    pNtOwfPassword,
                    &cachePasswords.SecretPasswords.NtOwfPassword,
                    sizeof( NT_OWF_PASSWORD )
                    ) != sizeof(NT_OWF_PASSWORD) )
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }

    //
    // Return the validation info here.
    //

    *ReturnBufferSize = sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    CacheResponse = (PMSV1_0_CACHE_LOOKUP_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    CacheResponse->MessageType = MsV1_0CacheLookup;
    CacheResponse->ValidationInformation = ValidationInfo;

    CacheResponse->SupplementalCacheData = SupplementalCacheData;
    CacheResponse->SupplementalCacheDataLength = SupplementalCacheDataLength;

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );

        if (ValidationInfo != NULL) {
            MIDL_user_free( ValidationInfo );
        }

        if (SupplementalCacheData != NULL) {
            MIDL_user_free( SupplementalCacheData );
        }
    }

    ZeroMemory( &ComputedNtOwfPassword, sizeof( ComputedNtOwfPassword ) );
    ZeroMemory( &cachePasswords, sizeof(cachePasswords) );

    return(STATUS_SUCCESS);
    UNREFERENCED_PARAMETER( ClientBufferBase);

}

NTSTATUS
MspSetProcessOption(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0SetProcessOption.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PMSV1_0_SETPROCESSOPTION_REQUEST SetProcessOptionRequest;

    *ProtocolStatus = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER(ClientRequest);


    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_SETPROCESSOPTION_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    SetProcessOptionRequest = (PMSV1_0_SETPROCESSOPTION_REQUEST) ProtocolSubmitBuffer;

    if( NtLmSetProcessOption(
                            SetProcessOptionRequest->ProcessOptions,
                            SetProcessOptionRequest->DisableOptions
                            ) )
    {
        *ProtocolStatus = STATUS_SUCCESS;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return(Status);
}



NTSTATUS
LsaApLogonUserEx2 (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * SupplementalCredentials
    )

/*++

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    the user's initial logon.  A new LSA logon session will be established
    for the user and validation information for the user will be returned.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    LogonType - Identifies the type of logon being attempted.

    ProtocolSubmitBuffer - Supplies the authentication
        information specific to the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the authentication information was resident.
        This may be necessary to fix-up any pointers within the
        authentication information buffer.

    SubmitBufferSize - Indicates the Size, in bytes,
        of the authentication information buffer.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  The authentication package is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the LSA subsequently
        encounters an error which prevents a successful logon, then
        the LSA will take care of deallocating that buffer.  This
        buffer is expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    SubStatus - If the logon failed due to account restrictions, the
        reason for the failure should be returned via this parameter.
        The reason is authentication-package specific.  The substatus
        values for authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

    TokenInformationLevel - If the logon is successful, this field is
        used to indicate what level of information is being returned
        for inclusion in the Token to be created.  This information
        is returned via the TokenInformation parameter.

    TokenInformation - If the logon is successful, this parameter is
        used by the authentication package to return information to
        be included in the token.  The format and content of the
        buffer returned is indicated by the TokenInformationLevel
        return value.

    AccountName - A Unicode string describing the account name
        being logged on to.  This parameter must always be returned
        regardless of the success or failure of the operation.

    AuthenticatingAuthority - A Unicode string describing the Authenticating
        Authority for the logon.  This string may optionally be omitted.

    PrimaryCredentials - Returns primary credentials for handing to other
        packages.

    SupplementalCredentials - Array of supplemental credential blobs for
        other packages.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

    STATUS_INVALID_LOGON_CLASS - LogonType was invalid.

    STATUS_LOGON_SESSION_COLLISION- Internal Error: A LogonId was selected for
        this logon session.  The selected LogonId already exists.

    STATUS_NETLOGON_NOT_STARTED - The Sam Server or Netlogon service was
        required to perform this function.  The required server was not running.

    STATUS_NO_MEMORY - Insufficient virtual memory or pagefile quota exists.




--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LSA_TOKEN_INFORMATION_TYPE LsaTokenInformationType = LsaTokenInformationV2;

    PNETLOGON_VALIDATION_SAM_INFO4 NlpUser = NULL;


    PACTIVE_LOGON LogonEntry = NULL;
    BOOLEAN LogonEntryLinked = FALSE;

    BOOLEAN LogonSessionCreated = FALSE;
    BOOLEAN LogonCredentialAdded = FALSE;
    ULONG Flags = 0;
    BOOLEAN Authoritative;
    BOOLEAN BadPasswordCountZeroed;
    BOOLEAN StandaloneWorkstation = FALSE;

    PSID UserSid = NULL;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;

    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;

    PUNICODE_STRING WorkStationName = NULL;

    // Need to figure out whether to delete the profile  buffer

    BOOLEAN fSubAuthEx = FALSE;

    //
    // deferred NTLM3 checks.
    //

    BOOLEAN fNtLm3 = FALSE;

    //
    // Whether to wait for network & netlogon. If we are attempting
    // forced cached credentials logon, we will avoid doing so.
    //

    BOOLEAN fWaitForNetwork = TRUE;

    //
    // Temporary storage while we try to figure
    // out what our username and authenticating
    // authority is.
    //

    UNICODE_STRING TmpName;
    WCHAR TmpNameBuffer[UNLEN];
    UNICODE_STRING TmpAuthority;
    WCHAR TmpAuthorityBuffer[DNS_MAX_NAME_LENGTH];

    //
    // Logon Information.
    //
    NETLOGON_LOGON_INFO_CLASS LogonLevel;
    NETLOGON_INTERACTIVE_INFO LogonInteractive;
    NETLOGON_NETWORK_INFO LogonNetwork;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInformation;

    PMSV1_0_LM20_LOGON NetworkAuthentication = NULL;

    //
    // Secret information, if we are doing a service logon
    //
    LSAPR_HANDLE SecretHandle;
    PLSAPR_CR_CIPHER_VALUE SecretCurrent = NULL;
    UNICODE_STRING Prefix, SavedPassword;
    BOOLEAN ServiceSecretLogon = FALSE;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;


    //
    // Credential manager stored credentials.
    //

    UNICODE_STRING CredmanUserName;
    UNICODE_STRING CredmanDomainName;
    UNICODE_STRING CredmanPassword;


    //
    // WMI tracing helper struct
    //
    NTLM_TRACE_INFO TraceInfo = {0};

#if _WIN64
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    SECPKG_CALL_INFO  CallInfo;
    BOOL  fAllocatedSubmitBuffer = FALSE;

    if( ClientRequest == (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        //
        // if the call originated inproc, the buffers have already been
        // marshalled/etc.
        //

        ZeroMemory( &CallInfo, sizeof(CallInfo) );
    } else {
        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    }

#endif

    //
    // CachedInteractive logons are treated same as Interactive except
    // that we avoid hitting the network.
    //

    if (LogonType == CachedInteractive) {
        fWaitForNetwork = FALSE;
        LogonType = Interactive;
    }

    //
    // Begin tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag){

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmLogonGuid,
                         EVENT_TRACE_TYPE_START,
                         WNODE_FLAG_TRACED_GUID,
                         0);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }

    //
    // Initialize
    //

    *ProfileBuffer = NULL;
    *SubStatus = STATUS_SUCCESS;
    *AuthenticatingAuthority = NULL;
    *AccountName = NULL;

    TmpName.Buffer        = TmpNameBuffer;
    TmpName.MaximumLength = UNLEN * sizeof( WCHAR );
    TmpName.Length        = 0;

    TmpAuthority.Buffer        = TmpAuthorityBuffer;
    TmpAuthority.MaximumLength = DNS_MAX_NAME_LENGTH * sizeof( WCHAR );
    TmpAuthority.Length        = 0;

    CredmanUserName.Buffer      = NULL;
    CredmanDomainName.Buffer    = NULL;
    CredmanPassword.Buffer      = NULL;

    *SupplementalCredentials = 0;

    RtlZeroMemory(
        PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    //
    // Check the Authentication information and build a LogonInformation
    // structure to pass to SAM or Netlogon.
    //
    // NOTE: Netlogon treats Service and Batch logons as if they are
    //       Interactive.
    //

    switch ( LogonType ) {
    case Service:
    case Interactive:
    case Batch:
    case NetworkCleartext:
    case RemoteInteractive:
        {
            MSV1_0_PRIMARY_CREDENTIAL BuiltCredential;

#if _WIN64


        //
        // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
        // call came from a WOW client.
        //


        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            Authentication =
                (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;

            Status = MsvConvertWOWInteractiveLogonBuffer(
                                                ProtocolSubmitBuffer,
                                                ClientBufferBase,
                                                &SubmitBufferSize,
                                                &pTempSubmitBuffer
                                                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            fAllocatedSubmitBuffer = TRUE;

            //
            // Some macros below expand out to use ProtocolSubmitBuffer directly.
            // We've secretly replaced their usual ProtocolSubmitBuffer with
            // pTempSubmitBuffer -- let's see if they can tell the difference.
            //

            ProtocolSubmitBuffer = pTempSubmitBuffer;
        }

#endif  // _WIN64


            WorkStationName = &NlpComputerName;

            //
            // Ensure this is really an interactive logon.
            //

            Authentication =
                (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;


            if ( (Authentication->MessageType != MsV1_0InteractiveLogon ) &&
                 (Authentication->MessageType != MsV1_0WorkstationUnlockLogon) ) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Bad Validation Class %d\n", Authentication->MessageType));
                Status = STATUS_BAD_VALIDATION_CLASS;
                goto Cleanup;
            }




            //
            // If the password length is greater than 255 (i.e., the
            // upper byte of the length is non-zero) then the password
            // has been run-encoded for privacy reasons.  Get the
            // run-encode seed out of the upper-byte of the length
            // for later use.
            //
            //



            SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                            &Authentication->Password.Length;
            Seed = SeedAndLength->Seed;
            SeedAndLength->Seed = 0;

            //
            // Enforce length restrictions on username and password.
            //

            if ( Authentication->UserName.Length > (UNLEN*sizeof(WCHAR)) ||
                Authentication->Password.Length > (PWLEN*sizeof(WCHAR)) )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Name or password too long\n"));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }

            //
            // Relocate any pointers to be relative to 'Authentication'
            //

            NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

            RELOCATE_ONE( &Authentication->UserName );

            NULL_RELOCATE_ONE( &Authentication->Password );

            if( (Authentication->LogonDomainName.Length <= sizeof(WCHAR)) &&
                (Authentication->Password.Length <= sizeof(WCHAR))
                )
            {
                if(CredpProcessUserNameCredential(
                                &Authentication->UserName,
                                &CredmanUserName,
                                &CredmanDomainName,
                                &CredmanPassword
                                ) == STATUS_SUCCESS)
                {
                    Authentication->UserName = CredmanUserName;
                    Authentication->LogonDomainName = CredmanDomainName;
                    Authentication->Password = CredmanPassword;
                }
            }

#if 0
            //
            // Handle UPN and composite NETBIOS syntax
            //
            {
                UNICODE_STRING User = Authentication->UserName;
                UNICODE_STRING Domain = Authentication->LogonDomainName;

                Status =
                    NtLmParseName(
                        &User,
                        &Domain,
                        FALSE
                        );
                if(NT_SUCCESS(Status)){
                    Authentication->UserName = User;
                    Authentication->LogonDomainName = Domain;
                }
            }
#endif


            if ( LogonType == Service )
            {
                SECPKG_CALL_INFO CallInfo;

                if( LsaFunctions->GetCallInfo(&CallInfo) &&
                   (CallInfo.Attributes & SECPKG_CALL_IS_TCB) )
                {
                    //
                    // If we have a service logon, the password we got is likely the name of the secret
                    // that is holding the account password.  Make sure to read that secret here
                    //
                    RtlInitUnicodeString( &Prefix, L"_SC_" );
                    if ( RtlPrefixUnicodeString( &Prefix, &Authentication->Password, TRUE ) )
                    {

                        Status = LsarOpenSecret( NtLmGlobalPolicyHandle,
                                                 ( PLSAPR_UNICODE_STRING )&Authentication->Password,
                                                 SECRET_QUERY_VALUE,
                                                 &SecretHandle );

                        if ( NT_SUCCESS( Status ) )
                        {

                            Status = LsarQuerySecret( SecretHandle,
                                                      &SecretCurrent,
                                                      NULL,
                                                      NULL,
                                                      NULL );

                            if ( NT_SUCCESS( Status ) && (SecretCurrent != NULL) )
                            {

                                RtlCopyMemory( &SavedPassword,
                                               &Authentication->Password,
                                               sizeof( UNICODE_STRING ) );
                                Authentication->Password.Length = ( USHORT )SecretCurrent->Length;
                                Authentication->Password.MaximumLength =
                                                                  ( USHORT )SecretCurrent->MaximumLength;
                                Authentication->Password.Buffer = ( USHORT * )SecretCurrent->Buffer;
                                ServiceSecretLogon = TRUE;
                            }

                            LsarClose( &SecretHandle );
                        }


                    }

                }


                if ( !NT_SUCCESS( Status ) ) {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to querying service password\n"));

                    goto Cleanup;
                }

            }
            //
            // Now decode the password, if necessary
            //

            if (Seed != 0 ) {
                try {
                    RtlRunDecodeUnicodeString( Seed, &Authentication->Password);
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to decode password\n"));
                    Status = STATUS_ILL_FORMED_PASSWORD;
                    goto Cleanup;
                }
            }

            //
            // Copy out the user name and Authenticating Authority so we can audit them.
            //

            RtlCopyUnicodeString( &TmpName, &Authentication->UserName );

            if ( Authentication->LogonDomainName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpAuthority, &Authentication->LogonDomainName );
            }


            //
            // Put the password in the PrimaryCredential to pass to the sundry security packages.
            //

            PrimaryCredentials->Password.Length = PrimaryCredentials->Password.MaximumLength =
                Authentication->Password.Length;
            PrimaryCredentials->Password.Buffer = (*Lsa.AllocateLsaHeap)(Authentication->Password.Length);

            if (PrimaryCredentials->Password.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->Password.Buffer,
                Authentication->Password.Buffer,
                Authentication->Password.Length
                );
            PrimaryCredentials->Flags = PRIMARY_CRED_CLEAR_PASSWORD;
//            PrimaryCredentials->Flags |= (RPC_C_AUTHN_WINNT << PRIMARY_CRED_LOGON_PACKAGE_SHIFT);


            //
            // We're all done with the cleartext password
            //  Don't let it get to the pagefile.
            //

            try {
                if ( Authentication->Password.Buffer != NULL ) {
                    RtlEraseUnicodeString( &Authentication->Password );
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: failed to decode password\n"));
                Status = STATUS_ILL_FORMED_PASSWORD;
                goto Cleanup;
            }

            //
            // Compute the OWF of the password.
            //

            NlpPutOwfsInPrimaryCredential( &PrimaryCredentials->Password,
                                           &BuiltCredential );


            //
            // Define the description of the user to log on.
            //
            LogonLevel = NetlogonInteractiveInformation;
            LogonInformation =
                (PNETLOGON_LOGON_IDENTITY_INFO) &LogonInteractive;

            LogonInteractive.Identity.LogonDomainName =
                Authentication->LogonDomainName;
            LogonInteractive.Identity.ParameterControl = 0;

            LogonInteractive.Identity.UserName = Authentication->UserName;
            LogonInteractive.Identity.Workstation = NlpComputerName;


            LogonInteractive.LmOwfPassword = BuiltCredential.LmOwfPassword;
            LogonInteractive.NtOwfPassword = BuiltCredential.NtOwfPassword;

        }

        break;

    case Network:
        {
            PMSV1_0_LM20_LOGON Authentication;


            //
            // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
            // call came from a WOW client.
            //

#if _WIN64
            if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
            {
                Authentication =
                    (PMSV1_0_LM20_LOGON) ProtocolSubmitBuffer;

                Status = MsvConvertWOWNetworkLogonBuffer(
                                                    ProtocolSubmitBuffer,
                                                    ClientBufferBase,
                                                    &SubmitBufferSize,
                                                    &pTempSubmitBuffer
                                                    );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                fAllocatedSubmitBuffer = TRUE;

                //
                // Some macros below expand out to use ProtocolSubmitBuffer directly.
                // We've secretly replaced their usual ProtocolSubmitBuffer with
                // pTempSubmitBuffer -- let's see if they can tell the difference.
                //

                ProtocolSubmitBuffer = pTempSubmitBuffer;
            }
#endif

            //
            // Ensure this is really a network logon request.
            //

            Authentication =
                (PMSV1_0_LM20_LOGON) ProtocolSubmitBuffer;

            NetworkAuthentication = Authentication;


            if ( Authentication->MessageType != MsV1_0Lm20Logon &&
                 Authentication->MessageType != MsV1_0SubAuthLogon  &&
                 Authentication->MessageType != MsV1_0NetworkLogon )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Bad Validation Class\n"));
                Status = STATUS_BAD_VALIDATION_CLASS;
                goto Cleanup;
            }

            //
            // Relocate any pointers to be relative to 'Authentication'
            //

            NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

            NULL_RELOCATE_ONE( &Authentication->UserName );

            RELOCATE_ONE( &Authentication->Workstation );

#if 0
            //
            // Handle UPN and composite NETBIOS syntax
            //
            {
                UNICODE_STRING User = Authentication->UserName;
                UNICODE_STRING Domain = Authentication->LogonDomainName;

                Status =
                    NtLmParseName(
                        &User,
                        &Domain,
                        FALSE
                        );
                if(NT_SUCCESS(Status)){
                    Authentication->UserName = User;
                    Authentication->LogonDomainName = Domain;
                }
            }
#endif


            //
            // Copy out the user name and Authenticating Authority so we can audit them.
            //

            if ( Authentication->UserName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpName, &Authentication->UserName );
            }

            if ( Authentication->LogonDomainName.Buffer != NULL ) {

                RtlCopyUnicodeString( &TmpAuthority, &Authentication->LogonDomainName );
            }

            NULL_RELOCATE_ONE((PUNICODE_STRING)&Authentication->CaseSensitiveChallengeResponse );

            NULL_RELOCATE_ONE((PUNICODE_STRING)&Authentication->CaseInsensitiveChallengeResponse );


            //
            // Define the description of the user to log on.
            //
            LogonLevel = NetlogonNetworkInformation;
            LogonInformation =
                (PNETLOGON_LOGON_IDENTITY_INFO) &LogonNetwork;

            LogonNetwork.Identity.LogonDomainName =
                Authentication->LogonDomainName;

            if ( Authentication->MessageType == MsV1_0Lm20Logon ) {
                LogonNetwork.Identity.ParameterControl = MSV1_0_CLEARTEXT_PASSWORD_ALLOWED;
            } else {
                BOOLEAN EnforceTcb = FALSE;

                ASSERT( CLEARTEXT_PASSWORD_ALLOWED == MSV1_0_CLEARTEXT_PASSWORD_ALLOWED );
                LogonNetwork.Identity.ParameterControl =
                    Authentication->ParameterControl;

                // For NT 5.0 SubAuth Packages, there is a SubAuthPackageId. Stuff
                // that into ParameterControl so pre 5.0 MsvSamValidate won't choke.

                if ( Authentication->MessageType == MsV1_0SubAuthLogon )
                {
                    PMSV1_0_SUBAUTH_LOGON SubAuthentication =
                        (PMSV1_0_SUBAUTH_LOGON)  ProtocolSubmitBuffer;

                    // Need to not delete return buffers even in case of error
                    // for MsV1_0SubAuthLogon (includes arap).

                    fSubAuthEx = TRUE;

                    LogonNetwork.Identity.ParameterControl |=
                        (SubAuthentication->SubAuthPackageId << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT) | MSV1_0_SUBAUTHENTICATION_DLL_EX;

                    EnforceTcb = TRUE ;
                } else {
                    if( Authentication->ParameterControl & MSV1_0_SUBAUTHENTICATION_DLL )
                    {
                        EnforceTcb = TRUE;
                    }
                }


                if( EnforceTcb )
                {
                    SECPKG_CALL_INFO CallInfo;

                    if(!LsaFunctions->GetCallInfo(&CallInfo) ||
                        (CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0)
                    {
                        SspPrint((SSP_CRITICAL, "LsaApLogonUser: subauth caller isn't privileged\n"));
                        Status = STATUS_ACCESS_DENIED;
                        goto Cleanup;
                    }
                }
            }


            LogonNetwork.Identity.UserName = Authentication->UserName;
            LogonNetwork.Identity.Workstation = Authentication->Workstation;

            WorkStationName = &Authentication->Workstation;

            LogonNetwork.NtChallengeResponse =
                Authentication->CaseSensitiveChallengeResponse;
            LogonNetwork.LmChallengeResponse =
                Authentication->CaseInsensitiveChallengeResponse;
            ASSERT( LM_CHALLENGE_LENGTH ==
                    sizeof(Authentication->ChallengeToClient) );


            //
            // If using client challenge, then mix it with the server's challenge
            //  to get the challenge we pass on. It would make more sense to do this
            //  in MsvpPasswordValidate, except that would require the DCs to be upgraded.
            //  Doing it here only requires agreement between the client and server, because
            //  the modified challenge will be passed on to the DCs.
            //

            if ((Authentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
                (Authentication->CaseSensitiveChallengeResponse.Length == NT_RESPONSE_LENGTH) &&
                (Authentication->CaseInsensitiveChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH))
            {
                MsvpCalculateNtlm2Challenge (
                    Authentication->ChallengeToClient,
                    Authentication->CaseInsensitiveChallengeResponse.Buffer,
                    (PUCHAR)&LogonNetwork.LmChallenge
                    );

            } else {
                RtlCopyMemory(
                    &LogonNetwork.LmChallenge,
                    Authentication->ChallengeToClient,
                    LM_CHALLENGE_LENGTH );
            }

            //
            // if using NTLM3, then check that the target info is for this machine.
            //

            if ((Authentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
                (Authentication->CaseSensitiveChallengeResponse.Length >= sizeof(MSV1_0_NTLM3_RESPONSE)))
            {

                fNtLm3 = TRUE;

                //
                // defer NTLM3 checks until later on when SAM initialized.
                //

            }



            //
            // Enforce length restrictions on username
            //

            if ( Authentication->UserName.Length > (UNLEN*sizeof(WCHAR)) )
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: Name too long\n"));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }

            //
            // If this is a null session logon,
            //  just build a NULL token.
            //

            if ( Authentication->UserName.Length == 0 &&
                 Authentication->CaseSensitiveChallengeResponse.Length == 0 &&
                 (Authentication->CaseInsensitiveChallengeResponse.Length == 0 ||
                  (Authentication->CaseInsensitiveChallengeResponse.Length == 1 &&
                  *Authentication->CaseInsensitiveChallengeResponse.Buffer == '\0') ) ) {

                LsaTokenInformationType = LsaTokenInformationNull;
            }
        }

        break;

    default:
        Status = STATUS_INVALID_LOGON_TYPE;
        goto CleanupShort;
    }


    //
    // Allocate a LogonId for this logon session.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    NEW_TO_OLD_LARGE_INTEGER( (*LogonId), LogonInformation->LogonId );


    PrimaryCredentials->LogonId = *LogonId;

    //
    // Create a new logon session
    //

    Status = (*Lsa.CreateLogonSession)( LogonId );
    if( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "LsaApLogonUser: Collision from CreateLogonSession %x\n", Status));
        goto Cleanup;
    }

    LogonSessionCreated = TRUE;


    //
    // Don't worry about SAM or the LSA if this is a Null Session logon.
    //
    // The server does a Null Session logon during initialization.
    // It shouldn't have to wait for SAM to initialize.
    //

    if ( LsaTokenInformationType != LsaTokenInformationNull ) {

        //
        // If Sam is not yet initialized,
        //  do it now.
        //

        if ( !NlpSamInitialized ) {
            Status = NlSamInitialize( SAM_STARTUP_TIME );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        //
        // If this is a workstation,
        //  differentiate between a standalone workstation and a member
        //  workstation.
        //
        // (This is is done on every logon, rather than during initialization,
        // to allow the value to be changed via the UI).
        //

        if ( NlpWorkstation ) {
            RtlAcquireResourceShared(&NtLmGlobalCritSect, TRUE);
            StandaloneWorkstation = (NtLmGlobalTargetFlags == NTLMSSP_TARGET_TYPE_SERVER);
            RtlReleaseResource(&NtLmGlobalCritSect);

        } else {
            StandaloneWorkstation = FALSE;
        }
    }

    //
    // Try again to load netlogon.dll
    //
    if ( NlpNetlogonDllHandle == NULL ) {
        NlpLoadNetlogonDll();
    }

    //
    // do NTLM3 processing that was deferred until now due to initialization
    // requirements.
    //

    if( fNtLm3 )
    {

        PMSV1_0_AV_PAIR pAV;
        PMSV1_0_NTLM3_RESPONSE pResp;
        LONG iRespLen;

        ULONG NtLmProtocolSupported = NtLmGlobalLmProtocolSupported;



        //
        // get the computer name from the response
        //

        pResp = (PMSV1_0_NTLM3_RESPONSE)
            NetworkAuthentication->CaseSensitiveChallengeResponse.Buffer;
        iRespLen = NetworkAuthentication->CaseSensitiveChallengeResponse.Length -
            sizeof(MSV1_0_NTLM3_RESPONSE);

        pAV = MsvpAvlGet((PMSV1_0_AV_PAIR)pResp->Buffer, MsvAvNbComputerName, iRespLen);

        //
        // if there is one (OK to be missing), see that it is us
        // REVIEW -- only allow it to be missing if registry says OK?
        //

        if (pAV) {
            UNICODE_STRING Candidate;

            Candidate.Buffer = (PWSTR)(pAV+1);
            Candidate.Length = (USHORT)(pAV->AvLen);
            Candidate.MaximumLength = Candidate.Length;

            if(!RtlEqualUnicodeString( &NlpComputerName, &Candidate, TRUE ))
            {
                SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed NbComputerName compare\n"));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

        } else if (NtLmProtocolSupported >= RefuseNtlm3NoTarget) {
            SspPrint((SSP_WARNING, "LsaApLogonUserEx2 no target supplied\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }


        //
        // get the domain name from the response
        //

        pAV = MsvpAvlGet((PMSV1_0_AV_PAIR)pResp->Buffer, MsvAvNbDomainName, iRespLen);

        //
        // must exist and must be us.
        //

        if (pAV) {

            UNICODE_STRING Candidate;

            Candidate.Buffer = (PWSTR)(pAV+1);
            Candidate.Length = pAV->AvLen;
            Candidate.MaximumLength = pAV->AvLen;


            if( StandaloneWorkstation ) {
                if( !RtlEqualDomainName(&NlpComputerName, &Candidate) ) {
                    SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed NbDomainName compare\n"));
                    Status = STATUS_LOGON_FAILURE;
                    goto Cleanup;
                }

            } else {
                if( !RtlEqualDomainName(&NlpPrimaryDomainName, &Candidate) ) {
                    SspPrint((SSP_WARNING, "LsaApLogonUserEx2 failed PrimaryDomainName compare\n"));
                    Status = STATUS_LOGON_FAILURE;
                    goto Cleanup;
                }
            }

        } else {
            SspPrint((SSP_WARNING, "LsaApLogonUserEx2 domain name not supplied\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }


    //
    // Do the actual logon now.
    //
    //
    // If a null token is being built,
    //  don't authenticate at all.
    //

    if ( LsaTokenInformationType == LsaTokenInformationNull ) {

        /* Nothing to do here. */


    //
    // Call Sam directly to get the validation information when:
    //
    //  The network is not installed, OR
    //  This is a standalone workstation (not a member of a domain).
    //  This is a workstation and we're logging onto an account on the
    //      workstation.
    //



    } else if ( NlpNetlogonDllHandle == NULL || !NlpLanmanInstalled ||
       StandaloneWorkstation ||
       ( NlpWorkstation &&
         LogonInformation->LogonDomainName.Length != 0 &&
         RtlEqualDomainName( &NlpSamDomainName,
                             &LogonInformation->LogonDomainName )) ) {

        // Allow guest logons only

        DWORD AccountsToTry = MSVSAM_SPECIFIED | MSVSAM_GUEST;

        if ((LogonType == Network) &&
            (LogonNetwork.Identity.ParameterControl & MSV1_0_TRY_GUEST_ACCOUNT_ONLY))
        {
            AccountsToTry = MSVSAM_GUEST;
        }

        //
        // for local logons, CachedInteractive is not supported.
        //

        if( !fWaitForNetwork )
        {
            Status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }


        //
        // Get the Validation information from the local SAM database
        //



        Status = MsvSamValidate(
                    NlpSamDomainHandle,
                    NlpUasCompatibilityRequired,
                    MsvApSecureChannel,
                    &NlpComputerName,   // Logon Server is this machine
                    &NlpSamDomainName,
                    NlpSamDomainId,
                    LogonLevel,
                    LogonInformation,
                    NetlogonValidationSamInfo4,
                    (PVOID *) &NlpUser,
                    &Authoritative,
                    &BadPasswordCountZeroed,
                    AccountsToTry);

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        // So we don't get a LOGON COLLISION from the old msv package

        Flags |= LOGON_BY_LOCAL;

    //
    // If we couldn't validate via one of the above mechanisms,
    //  call the local Netlogon service to get the validation information.
    //

    } else {

        NTSTATUS NetlogonStatus = STATUS_SUCCESS;

        //
        // If we are attempting cached credentials logon avoid getting stuck
        // on netlogon or the network.
        //

        if (fWaitForNetwork) {

            //
            // Wait for NETLOGON to finish initialization.
            //

            if ( !NlpNetlogonInitialized ) {

                Status = NlWaitForNetlogon( NETLOGON_STARTUP_TIME );

                if ( !NT_SUCCESS(Status) ) {
                    if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                        goto Cleanup;
                    }
                } else {
                    NlpNetlogonInitialized = TRUE;
                }
            }

            //
            // Actually call the netlogon service.
            //

            if ( NlpNetlogonInitialized ) {
                Status = (*NlpNetLogonSamLogon)(
                            NULL,           // Server name
                            NULL,           // Computer name
                            NULL,           // Authenticator
                            NULL,           // ReturnAuthenticator
                            LogonLevel,
                            (LPBYTE) &LogonInformation,
                            NetlogonValidationSamInfo4,
                            (LPBYTE *) &NlpUser,
                            &Authoritative );

                //
                // Reset Netlogon initialized flag if local netlogon cannot be
                //  reached.
                //  (Use a more explicit status code)
                //

                if( !NT_SUCCESS(Status) )
                {
                    //
                    // save the result from netlogon.
                    //

                    NetlogonStatus = Status;

                    switch (Status)
                    {
                        //
                        // for documented errors that netlogon can return
                        // for authoritative failures, leave the status code as-is.
                        //

                        case STATUS_NO_TRUST_LSA_SECRET:
                        case STATUS_TRUSTED_DOMAIN_FAILURE:
                        case STATUS_INVALID_INFO_CLASS:
                        case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
                        case STATUS_ACCESS_DENIED:
                        case STATUS_NO_SUCH_USER:
                        case STATUS_WRONG_PASSWORD:
                        case STATUS_INVALID_LOGON_HOURS:
                        case STATUS_PASSWORD_EXPIRED:
                        case STATUS_ACCOUNT_DISABLED:
                        case STATUS_INVALID_PARAMETER:
                        case STATUS_PASSWORD_MUST_CHANGE:
                        case STATUS_ACCOUNT_EXPIRED:
                        case STATUS_ACCOUNT_LOCKED_OUT:
                        case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
                        case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:
                        case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
                        case STATUS_INVALID_WORKSTATION:
                        {
                            break;
                        }

                        //
                        // for errors that are known to occur during unexpected
                        // conditions, over-ride status to allow cache lookup.
                        //

                        case RPC_NT_SERVER_UNAVAILABLE:
                        case RPC_NT_UNKNOWN_IF:
                        case STATUS_NETLOGON_NOT_STARTED:
                        {
                            Status = STATUS_NETLOGON_NOT_STARTED;
                            NlpNetlogonInitialized = FALSE;
                            break;
                        }

                        // default will catch a host of RPC related errors.
                        // some mentioned below.
                        //case EPT_NT_NOT_REGISTERED:
                        //case RPC_NT_CALL_FAILED_DNE:
                        //case RPC_NT_SERVER_TOO_BUSY:
                        //case RPC_NT_CALL_FAILED:
                        default:
                        {
                            Status = STATUS_NETLOGON_NOT_STARTED;
                            NlpNetlogonInitialized = FALSE;
                            break;
                        }
                    } // switch
                } // if
            }
        } else {

            //
            // We want to force cached credentials path by behaving as if no
            // network logon servers were available.
            //

            NetlogonStatus = STATUS_NO_LOGON_SERVERS;
            Status = NetlogonStatus;
        }

        //
        // If this is the requested domain,
        //  go directly to SAM if the netlogon service isn't available.
        //
        // We want to go to the netlogon service if it is available since it
        // does special handling of bad passwords and account lockout.  However,
        // if the netlogon service is down, the local SAM database makes a
        // better cache than any other mechanism.
        //

        if ( !NlpNetlogonInitialized &&
              LogonInformation->LogonDomainName.Length != 0 &&
              RtlEqualDomainName( &NlpSamDomainName,
                                     &LogonInformation->LogonDomainName ) ) {

            // Allow guest logons only

            DWORD AccountsToTry = MSVSAM_SPECIFIED | MSVSAM_GUEST;

            if ((LogonType == Network) &&
                (LogonNetwork.Identity.ParameterControl & MSV1_0_TRY_GUEST_ACCOUNT_ONLY))
            {
                AccountsToTry = MSVSAM_GUEST;
            }

            //
            // Get the Validation information from the local SAM database
            //

            Status = MsvSamValidate(
                        NlpSamDomainHandle,
                        NlpUasCompatibilityRequired,
                        MsvApSecureChannel,
                        &NlpComputerName,   // Logon Server is this machine
                        &NlpSamDomainName,
                        NlpSamDomainId,
                        LogonLevel,
                        LogonInformation,
                        NetlogonValidationSamInfo4,
                        (PVOID *) &NlpUser,
                        &Authoritative,
                        &BadPasswordCountZeroed,
                        AccountsToTry);

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }

            // So we don't get a LOGON COLLISION from the old msv package

            Flags |= LOGON_BY_LOCAL;


        //
        // If Netlogon was successful,
        //  add this user to the logon cache.
        //

        } else if ( NT_SUCCESS( Status ) ) {

            //
            // Indicate this session was validated by the Netlogon
            //  service.
            //

            Flags |= LOGON_BY_NETLOGON;

            //
            // Cache interactive logon information.
            //
            //      NOTE: Batch and Service logons are treated
            //            the same as Interactive here.
            //

            if (LogonType == Interactive ||
                LogonType == Service ||
                LogonType == Batch ||
                LogonType == RemoteInteractive) {

                NTSTATUS ntStatus;

                LogonInteractive.Identity.ParameterControl = RPC_C_AUTHN_WINNT;

                ntStatus = NlpAddCacheEntry(
                                &LogonInteractive,
                                NlpUser,
                                NULL,
                                0,
                                MSV1_0_CACHE_LOGON_REQUEST_INFO4
                                );
            }

        //
        // If Netlogon is simply not available at this time,
        //  try to logon through the cache.
        //
        // STATUS_NO_LOGON_SERVERS indicates the netlogon service couldn't
        //  contact a DC to handle this request.
        //
        // STATUS_NETLOGON_NOT_STARTED indicates the local netlogon service
        //  isn't running.
        //
        //
        // We use the cache for ANY logon type.  This not only allows a
        // user to logon interactively, but it allows that same user to
        // connect from another machine while the DC is down.
        //

        } else if ( Status == STATUS_NO_LOGON_SERVERS ||
                    Status == STATUS_NETLOGON_NOT_STARTED ) {

            NTSTATUS ntStatus;
            CACHE_PASSWORDS cachePasswords;
            ULONG LocalFlags = 0;

            //
            // reset Status to NetlogonStatus if an error was encountered.
            //

            if(!NT_SUCCESS( NetlogonStatus ))
            {
                Status = NetlogonStatus;
            }

            //
            // Try to logon via the cache.
            //
            //

            ntStatus = NlpGetCacheEntry(LogonInformation, &NlpUser, &cachePasswords, NULL, NULL);

            if (!NT_SUCCESS(ntStatus)) {

                //
                // The original status code is more interesting than
                // the fact that the cache didn't work.
                //

                NlpUser = NULL;     // NlpGetCacheEntry dirties this
                goto Cleanup;
            }

            if( LogonType != Network )
            {

                //
                // The cache information contains salted hashed passwords,
                // so modify the logon information similarly.
                //

                ntStatus = NlpComputeSaltedHashedPassword(
                            &LogonInteractive.NtOwfPassword,
                            &LogonInteractive.NtOwfPassword,
                            &NlpUser->EffectiveName
                            );
                if (!NT_SUCCESS(ntStatus)) {
                    goto Cleanup;
                }

                ntStatus = NlpComputeSaltedHashedPassword(
                            &LogonInteractive.LmOwfPassword,
                            &LogonInteractive.LmOwfPassword,
                            &NlpUser->EffectiveName
                            );
                if (!NT_SUCCESS(ntStatus)) {
                    goto Cleanup;
                }

            } else {

                PMSV1_0_PRIMARY_CREDENTIAL TempPrimaryCredential;
                ULONG PrimaryCredentialSize;

                //
                // because the cache no longer stores OWFs, the cached salted OWF
                // is not useful for validation for network logon.
                // The only place we can get a OWF to match is the active logon
                // cache
                //

                ntStatus = NlpGetPrimaryCredentialByUserDomain(
                                &LogonInformation->LogonDomainName,
                                &LogonInformation->UserName,
                                &TempPrimaryCredential,
                                &PrimaryCredentialSize
                                );

                if(!NT_SUCCESS(ntStatus)) {
                    Status = STATUS_WRONG_PASSWORD;
                    goto Cleanup;
                }

                //
                // copy out the OWFs, then free the allocated buffer.
                //

                if( TempPrimaryCredential->NtPasswordPresent ) {
                    CopyMemory(&cachePasswords.SecretPasswords.NtOwfPassword, &TempPrimaryCredential->NtOwfPassword, sizeof(NT_OWF_PASSWORD));
                    cachePasswords.SecretPasswords.NtPasswordPresent = TRUE;
                } else {
                    cachePasswords.SecretPasswords.NtPasswordPresent = FALSE;
                }

                if( TempPrimaryCredential->LmPasswordPresent ) {
                    CopyMemory(&cachePasswords.SecretPasswords.LmOwfPassword, &TempPrimaryCredential->LmOwfPassword, sizeof(LM_OWF_PASSWORD));
                    cachePasswords.SecretPasswords.LmPasswordPresent = TRUE;
                } else {
                    cachePasswords.SecretPasswords.LmPasswordPresent = FALSE;
                }

                ZeroMemory( TempPrimaryCredential, PrimaryCredentialSize );
                (*Lsa.FreeLsaHeap)( TempPrimaryCredential );

            }


            //
            // Now we have the information from the cache, validate the
            // user's password
            //

            if (!MsvpPasswordValidate(
                    NlpUasCompatibilityRequired,
                    LogonLevel,
                    (PVOID)LogonInformation,
                    &cachePasswords.SecretPasswords,
                    &LocalFlags,
                    &NlpUser->UserSessionKey,
                    (PLM_SESSION_KEY)
                        &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY]
                    )) {
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }

            Status = STATUS_SUCCESS;

            //
            // The cache always returns a NETLOGONV_VALIDATION_SAM_INFO2
            // structure so set the LOGON_EXTRA_SIDS flag, whether or not
            // there are extra sids. Also, if there was a package ID indicated
            // put it in the PrimaryCredentials and remove it from the
            // NlpUser structure so it doesn't confuse anyone else.
            //

            PrimaryCredentials->Flags |= NlpUser->UserFlags & PRIMARY_CRED_PACKAGE_MASK;
            NlpUser->UserFlags &= ~PRIMARY_CRED_PACKAGE_MASK;
            NlpUser->UserFlags |= LOGON_CACHED_ACCOUNT | LOGON_EXTRA_SIDS | LocalFlags;
            Flags |= LOGON_BY_CACHE;

        //
        // If the account is permanently dead on the domain controller,
        //  Flush this entry from the cache.
        //
        // Notice that STATUS_INVALID_LOGON_HOURS is not in the list below.
        // This ensures a user will be able to remove his portable machine
        // from the net and use it after hours.
        //
        // Notice the STATUS_WRONG_PASSWORD is not in the list below.
        // We're as likely to flush the cache for typo'd passwords as anything
        // else.  What we'd really like to do is flush the cache if the
        // password on the DC is different than the one in cache; but that's
        // impossible to detect.
        //
        // ONLY DO THIS FOR INTERACTIVE LOGONS
        // (not Service or Batch).
        //

        } else if ( ((LogonType == Interactive) || (LogonType == RemoteInteractive)) &&
                    (Status == STATUS_NO_SUCH_USER          ||
                     Status == STATUS_INVALID_WORKSTATION   ||
                     Status == STATUS_PASSWORD_EXPIRED      ||
                     Status == STATUS_ACCOUNT_DISABLED) ) {

            //
            // Delete the cache entry

            NTSTATUS ntStatus;

            ntStatus = NlpDeleteCacheEntry(&LogonInteractive);
            if(!NT_SUCCESS(ntStatus))
            {
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: NlpDeleteCacheEntry returns %x\n", ntStatus));
            }

            goto Cleanup;

        } else {

            goto Cleanup;
        }
    }


    //
    // if this is PersonalSKU, only allow DOMAIN_USER_RID_ADMIN to logon
    // if doing safe-mode boot (NtLmGlobalSafeBoot == TRUE)
    //


    if( NlpUser &&
        NlpUser->UserId == DOMAIN_USER_RID_ADMIN &&
        !NtLmGlobalSafeBoot &&
        NtLmGlobalPersonalSKU &&
        NlpSamDomainId &&
        RtlEqualSid( NlpUser->LogonDomainId, NlpSamDomainId )
        )
    {
        Status = STATUS_ACCOUNT_RESTRICTION;
        SspPrint((SSP_CRITICAL,
            "LsaApLogonUser: For Personal SKU Administrator cannot log on except during safe mode boot\n"));
        goto Cleanup;
    }



    //
    // For everything except network logons,
    //  save the credentials in the LSA,
    //  create active logon table entry,
    //  return the interactive profile buffer.
    //

    if ( LogonType == Interactive ||
         LogonType == Service     ||
         LogonType == Batch       ||
         LogonType == NetworkCleartext ||
         LogonType == RemoteInteractive
       )
    {
        PACTIVE_LOGON *ActiveLogon;
        ULONG LogonEntrySize;
        PUCHAR Where;
        USHORT LogonCount;
        ULONG UserSidSize;
        UNICODE_STRING SamAccountName;
        UNICODE_STRING NetbiosDomainName;
        UNICODE_STRING DnsDomainName;
        UNICODE_STRING Upn;
        UNICODE_STRING LogonServer;

        //
        // Grab the various forms of the account name
        //

        NlpGetAccountNames( LogonInformation,
                            NlpUser,
                            &SamAccountName,
                            &NetbiosDomainName,
                            &DnsDomainName,
                            &Upn );


        //
        // Build the primary credential
        //
        //

#ifdef MAP_DOMAIN_NAMES_AT_LOGON
        {
            UNICODE_STRING MappedDomain;
            RtlInitUnicodeString(
                &MappedDomain,
                NULL
                );

            Status = NlpMapLogonDomain(
                        &MappedDomain,
                        &NetbiosDomainName );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            Status = NlpMakePrimaryCredential( &MappedDomain,
                                               &SamAccountName,
                                               &PrimaryCredentials->Password,
                                               &Credential,
                                               &CredentialSize );

            if (MappedDomain.Buffer != NULL) {
                NtLmFree(MappedDomain.Buffer);
            }

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }

        }
#else

        Status = NlpMakePrimaryCredential( &NetbiosDomainName,
                                           &SamAccountName,
                                           &PrimaryCredentials->Password,
                                           &Credential,
                                           &CredentialSize );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }
#endif

        //
        // Add additional names to the logon session name map.  Ignore failure
        // as that just means GetUserNameEx calls for these name formats later
        // on will be satisfied by hitting the wire.
        //

        if (NlpUser->FullName.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameDisplay, &NlpUser->FullName);
        }

        if (Upn.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameUserPrincipal, &Upn);
        }

        if (DnsDomainName.Length != 0)
        {
            I_LsaIAddNameToLogonSession(LogonId, NameDnsDomain, &DnsDomainName);
        }

        //
        // Fill the username and domain name into the primary credential
        //  that's passed to the other security packages.
        //
        // The names filled in are the effective names after authentication.
        //  For instance, it isn't the UPN passed to this function.
        //

        PrimaryCredentials->DownlevelName.Length = PrimaryCredentials->DownlevelName.MaximumLength =
            SamAccountName.Length;
        PrimaryCredentials->DownlevelName.Buffer = (*Lsa.AllocateLsaHeap)(SamAccountName.Length);

        if (PrimaryCredentials->DownlevelName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            PrimaryCredentials->DownlevelName.Buffer,
            SamAccountName.Buffer,
            SamAccountName.Length
            );

        PrimaryCredentials->DomainName.Length = PrimaryCredentials->DomainName.MaximumLength =
            NetbiosDomainName.Length;

        PrimaryCredentials->DomainName.Buffer = (*Lsa.AllocateLsaHeap)(NetbiosDomainName.Length);

        if (PrimaryCredentials->DomainName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            PrimaryCredentials->DomainName.Buffer,
            NetbiosDomainName.Buffer,
            NetbiosDomainName.Length
            );

        RtlCopyMemory(&LogonServer, &NlpUser->LogonServer, sizeof(UNICODE_STRING));

        if ( LogonServer.Length != 0 ) {
            PrimaryCredentials->LogonServer.Length = PrimaryCredentials->LogonServer.MaximumLength =
                LogonServer.Length;
            PrimaryCredentials->LogonServer.Buffer = (*Lsa.AllocateLsaHeap)(LogonServer.Length);

            if (PrimaryCredentials->LogonServer.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->LogonServer.Buffer,
                LogonServer.Buffer,
                LogonServer.Length
                );
        }


        //
        // Save the credential in the LSA.
        //

        Status = NlpAddPrimaryCredential( LogonId,
                                          Credential,
                                          CredentialSize );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL, "LsaApLogonUser: error from AddCredential %lX\n",
                Status));
            goto Cleanup;
        }
        LogonCredentialAdded = TRUE;

        //
        // Build a Sid for this user.
        //

        UserSid = NlpMakeDomainRelativeSid( NlpUser->LogonDomainId,
                                            NlpUser->UserId );

        if ( UserSid == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory\n"));
            goto Cleanup;
        }



        PrimaryCredentials->UserSid = UserSid;
        UserSid = NULL;



        UserSidSize = RtlLengthSid( PrimaryCredentials->UserSid );


        //
        // Allocate an entry for the active logon table.
        //

        LogonEntrySize = ROUND_UP_COUNT(sizeof(ACTIVE_LOGON), ALIGN_DWORD) +
              ROUND_UP_COUNT(UserSidSize, sizeof(WCHAR)) +
              SamAccountName.Length + sizeof(WCHAR) +
              NetbiosDomainName.Length + sizeof(WCHAR) +
              NlpUser->LogonServer.Length + sizeof(WCHAR);

        LogonEntry = I_NtLmAllocate( LogonEntrySize );

        if ( LogonEntry == NULL ) {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory %ld\n",
                    sizeof(ACTIVE_LOGON)));
            goto Cleanup;
        }

        //
        // Fill in the logon table entry.
        //

        Where = (PUCHAR)(LogonEntry + 1);

        OLD_TO_NEW_LARGE_INTEGER(
            LogonInformation->LogonId,
            LogonEntry->LogonId );

        LogonEntry->Flags = Flags;
        LogonEntry->LogonType = LogonType;

        //
        // Copy DWORD aligned fields first.
        //

        Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );
        Status = RtlCopySid(UserSidSize, (PSID)Where, PrimaryCredentials->UserSid);

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        LogonEntry->UserSid = (PSID) Where;
        Where += UserSidSize;

        //
        // Copy WCHAR aligned fields
        //

        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        NlpPutString( &LogonEntry->UserName,
                      &SamAccountName,
                      &Where );

        NlpPutString( &LogonEntry->LogonDomainName,
                      &NetbiosDomainName,
                      &Where );

        NlpPutString( &LogonEntry->LogonServer,
                      &NlpUser->LogonServer,
                      &Where );


        //
        // Get the next enumeration handle for this session.
        //

        LogonEntry->EnumHandle = (ULONG)InterlockedIncrement((PLONG)&NlpEnumerationHandle);

        NlpLockActiveLogonsWrite();

        //
        // Insert this entry into the active logon table.
        //

        if (NlpFindActiveLogon( LogonId, &ActiveLogon )){

            //
            // This Logon ID is already in use.
            //

            NlpUnlockActiveLogons();

            Status = STATUS_LOGON_SESSION_COLLISION;
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: Collision from NlpFindActiveLogon\n"));
            goto Cleanup;
        }

        LogonEntry->Next = *ActiveLogon;
        *ActiveLogon = LogonEntry;
        NlpUnlockActiveLogons();

        LogonEntryLinked = TRUE;


        //
        // Ensure the LogonCount is at least as big as it is for this
        //  machine.
        //

        LogonCount = (USHORT) NlpCountActiveLogon( &NetbiosDomainName,
                                                   &SamAccountName );
        if ( NlpUser->LogonCount < LogonCount ) {
            NlpUser->LogonCount = LogonCount;
        }

        //
        // Alocate the profile buffer to return to the client
        //

        Status = NlpAllocateInteractiveProfile(
                    ClientRequest,
                    (PMSV1_0_INTERACTIVE_PROFILE *) ProfileBuffer,
                    ProfileBufferSize,
                    NlpUser );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: Allocate Profile Failed: %lx\n", Status));
            goto Cleanup;
        }

    } else if ( LogonType == Network ) {


        //
        // if doing client challenge, and it's a vanilla NTLM response,
        //  and it's not a null session, compute unique per-session session keys
        //      N.B: not needed if it's NTLM++, not possible if LM
        //

        if ((NetworkAuthentication->ParameterControl & MSV1_0_USE_CLIENT_CHALLENGE) &&
            (NetworkAuthentication->CaseSensitiveChallengeResponse.Length == NT_RESPONSE_LENGTH ) && // vanilla NTLM response
            (NetworkAuthentication->CaseInsensitiveChallengeResponse.Length >= MSV1_0_CHALLENGE_LENGTH ) &&
            (NlpUser != NULL))       // NULL session iff NlpUser == NULL
        {
            MsvpCalculateNtlm2SessionKeys(
                &NlpUser->UserSessionKey,
                NetworkAuthentication->ChallengeToClient,
                NetworkAuthentication->CaseInsensitiveChallengeResponse.Buffer,
                (PUSER_SESSION_KEY)&NlpUser->UserSessionKey,
                (PLM_SESSION_KEY)&NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY]
                );

        }

        //
        // Alocate the profile buffer to return to the client
        //

        Status = NlpAllocateNetworkProfile(
                    ClientRequest,
                    (PMSV1_0_LM20_LOGON_PROFILE *) ProfileBuffer,
                    ProfileBufferSize,
                    NlpUser,
                    LogonNetwork.Identity.ParameterControl );
        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: Allocate Profile Failed: %lx. This could also be a status for a subauth logon.\n", Status));
            goto Cleanup;
        }


        if( NlpUser != NULL )
        {
            UNICODE_STRING SamAccountName;
            UNICODE_STRING NetbiosDomainName;
            UNICODE_STRING DnsDomainName;
            UNICODE_STRING Upn;
            UNICODE_STRING LogonServer;

            //
            // Grab the various forms of the account name
            //

            NlpGetAccountNames( LogonInformation,
                                NlpUser,
                                &SamAccountName,
                                &NetbiosDomainName,
                                &DnsDomainName,
                                &Upn );


            //
            // Add additional names to the logon session name map.  Ignore failure
            // as that just means GetUserNameEx calls for these name formats later
            // on will be satisfied by hitting the wire.
            //

            if (NlpUser->FullName.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameDisplay, &NlpUser->FullName);
            }

            if (Upn.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameUserPrincipal, &Upn);
            }

            if (DnsDomainName.Length != 0)
            {
                I_LsaIAddNameToLogonSession(LogonId, NameDnsDomain, &DnsDomainName);
            }

            //
            // Fill the username and domain name into the primary credential
            //  that's passed to the other security packages.
            //
            // The names filled in are the effective names after authentication.
            //  For instance, it isn't the UPN passed to this function.
            //

            if( SamAccountName.Length == 0 )
            {
                SamAccountName = TmpName;
            }

            PrimaryCredentials->DownlevelName.Length = PrimaryCredentials->DownlevelName.MaximumLength =
                SamAccountName.Length;
            PrimaryCredentials->DownlevelName.Buffer = (*Lsa.AllocateLsaHeap)(SamAccountName.Length);

            if (PrimaryCredentials->DownlevelName.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->DownlevelName.Buffer,
                SamAccountName.Buffer,
                SamAccountName.Length
                );

            PrimaryCredentials->DomainName.Length = PrimaryCredentials->DomainName.MaximumLength =
                NetbiosDomainName.Length;

            PrimaryCredentials->DomainName.Buffer = (*Lsa.AllocateLsaHeap)(NetbiosDomainName.Length);

            if (PrimaryCredentials->DomainName.Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                PrimaryCredentials->DomainName.Buffer,
                NetbiosDomainName.Buffer,
                NetbiosDomainName.Length
                );

            RtlCopyMemory(&LogonServer, &NlpUser->LogonServer, sizeof(UNICODE_STRING));

            if ( LogonServer.Length != 0 ) {
                PrimaryCredentials->LogonServer.Length = PrimaryCredentials->LogonServer.MaximumLength =
                    LogonServer.Length;
                PrimaryCredentials->LogonServer.Buffer = (*Lsa.AllocateLsaHeap)(LogonServer.Length);

                if (PrimaryCredentials->LogonServer.Buffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    PrimaryCredentials->LogonServer.Buffer,
                    LogonServer.Buffer,
                    LogonServer.Length
                    );
            }

            //
            // Build a Sid for this user.
            //

            UserSid = NlpMakeDomainRelativeSid( NlpUser->LogonDomainId,
                                                NlpUser->UserId );

            if ( UserSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                SspPrint((SSP_CRITICAL, "LsaApLogonUser: No memory\n"));
                goto Cleanup;
            }


            PrimaryCredentials->UserSid = UserSid;
            UserSid = NULL;
        }
    }


    //
    // Build the token information to return to the LSA
    //

    switch (LsaTokenInformationType) {
    case LsaTokenInformationV2:

        Status = NlpMakeTokenInformationV2(
                        NlpUser,
                        (PLSA_TOKEN_INFORMATION_V2 *)TokenInformation );

        if ( !NT_SUCCESS( Status ) ) {
            SspPrint((SSP_CRITICAL,
                "LsaApLogonUser: MakeTokenInformationV2 Failed: %lx\n", Status));
            goto Cleanup;
        }
        break;

    case LsaTokenInformationNull:
        {
            PLSA_TOKEN_INFORMATION_NULL VNull;

            VNull = (*Lsa.AllocateLsaHeap)(sizeof(LSA_TOKEN_INFORMATION_NULL) );
            if ( VNull == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            VNull->Groups = NULL;

            VNull->ExpirationTime.HighPart = 0x7FFFFFFF;
            VNull->ExpirationTime.LowPart = 0xFFFFFFFF;

            *TokenInformation = VNull;
        }

    }

    *TokenInformationType = LsaTokenInformationType;


    Status = STATUS_SUCCESS;

Cleanup:

    NtLmFreePrivateHeap( CredmanUserName.Buffer );
    NtLmFreePrivateHeap( CredmanDomainName.Buffer );
    NtLmFreePrivateHeap( CredmanPassword.Buffer );

    //
    // Restore the saved password
    //
    if ( ServiceSecretLogon ) {

        RtlCopyMemory( &Authentication->Password,
                       &SavedPassword,
                       sizeof( UNICODE_STRING ) );

        //
        // Free the secret value we read...
        //
        LsaIFree_LSAPR_CR_CIPHER_VALUE( SecretCurrent );
    }

    //
    // If the logon wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {

        if ( LogonSessionCreated ) {
            (VOID)(*Lsa.DeleteLogonSession)( LogonId );
        }

        if ( LogonEntry != NULL ) {
            if ( LogonEntryLinked ) {
                LsaApLogonTerminated( LogonId );
            } else {
                if ( LogonCredentialAdded ) {
                    (VOID) NlpDeletePrimaryCredential(
                                LogonId );
                }
                I_NtLmFree( LogonEntry );
            }
        }

        // Special case for MsV1_0SubAuthLogon (includes arap).
        // (Don't free ProfileBuffer during error conditions which may not be fatal)

        if (!fSubAuthEx)
        {
            if ( *ProfileBuffer != NULL ) {
                if (ClientRequest != (PLSA_CLIENT_REQUEST) (-1))
                    (VOID)(*Lsa.FreeClientBuffer)( ClientRequest, *ProfileBuffer );
                else
                    (VOID)(*Lsa.FreeLsaHeap)( *ProfileBuffer );

                *ProfileBuffer = NULL;
            }
        }

        if (PrimaryCredentials->DownlevelName.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->DownlevelName.Buffer);
        }

        if (PrimaryCredentials->DomainName.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->DomainName.Buffer);
        }

        if (PrimaryCredentials->Password.Buffer != NULL) {

            RtlZeroMemory(
                PrimaryCredentials->Password.Buffer,
                PrimaryCredentials->Password.Length
                );

            (*Lsa.FreeLsaHeap)(PrimaryCredentials->Password.Buffer);
        }

        if (PrimaryCredentials->LogonServer.Buffer != NULL) {
            (*Lsa.FreeLsaHeap)(PrimaryCredentials->LogonServer.Buffer);
        }

        RtlZeroMemory(
            PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );
    }

    //
    // Copy out Authenticating authority and user name.
    //

    if ( NT_SUCCESS(Status) && LsaTokenInformationType != LsaTokenInformationNull ) {

        //
        // Use the information from the NlpUser structure, since it gives
        // us accurate information about what account we're logging on to,
        // rather than who we were.
        //

        if( LogonType != Network )
        {
            TmpName = NlpUser->EffectiveName;
        } else {

            //
            // older servers may not return the effectivename for non-guest network logon.
            //

            if( NlpUser->EffectiveName.Length != 0 )
            {
                TmpName = NlpUser->EffectiveName;
            }
        }

        TmpAuthority = NlpUser->LogonDomainName;
    }

    *AccountName = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

    if ( *AccountName != NULL ) {

        (*AccountName)->Buffer = (*Lsa.AllocateLsaHeap)(TmpName.Length + sizeof( UNICODE_NULL) );

        if ( (*AccountName)->Buffer != NULL ) {

            (*AccountName)->MaximumLength = TmpName.Length + sizeof( UNICODE_NULL );
            RtlCopyUnicodeString( *AccountName, &TmpName );

        } else {

            RtlInitUnicodeString( *AccountName, NULL );
        }
    }

    *AuthenticatingAuthority = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

    if ( *AuthenticatingAuthority != NULL ) {

        (*AuthenticatingAuthority)->Buffer = (*Lsa.AllocateLsaHeap)( TmpAuthority.Length + sizeof( UNICODE_NULL ) );

        if ( (*AuthenticatingAuthority)->Buffer != NULL ) {

            (*AuthenticatingAuthority)->MaximumLength = (USHORT)(TmpAuthority.Length + sizeof( UNICODE_NULL ));
            RtlCopyUnicodeString( *AuthenticatingAuthority, &TmpAuthority );

        } else {

            RtlInitUnicodeString( *AuthenticatingAuthority, NULL );
        }
    }

    *MachineName = NULL;

    if (WorkStationName != NULL) {

        *MachineName = (*Lsa.AllocateLsaHeap)( sizeof( UNICODE_STRING ) );

        if ( *MachineName != NULL ) {

            (*MachineName)->Buffer = (*Lsa.AllocateLsaHeap)( WorkStationName->Length + sizeof( UNICODE_NULL ) );

            if ( (*MachineName)->Buffer != NULL ) {

                (*MachineName)->MaximumLength = (USHORT)(WorkStationName->Length + sizeof( UNICODE_NULL ));
                RtlCopyUnicodeString( *MachineName, WorkStationName );

            } else {

                RtlInitUnicodeString( *MachineName, NULL );
            }
        }
    }

    //
    // Map status codes to prevent specific information from being
    // released about this user.
    //
    switch (Status) {
    case STATUS_WRONG_PASSWORD:
    case STATUS_NO_SUCH_USER:
    case STATUS_DOMAIN_TRUST_INCONSISTENT:

        //
        // sleep 3 seconds to "discourage" dictionary attacks.
        // Don't worry about interactive logon dictionary attacks.
        // They will be slow anyway.
        //
        // per bug 171041, SField, RichardW, CliffV all decided this
        // delay has almost zero value for Win2000.  Offline attacks at
        // sniffed wire traffic are more efficient and viable.  Further,
        // opimizations in logon code path make failed interactive logons
        // very fast.
        //
//        if (LogonType != Interactive) {
//            Sleep( 3000 );
//        }

        //
        // This is for auditing.  Make sure to clear it out before
        // passing it out of LSA to the caller.
        //

        *SubStatus = Status;
        Status = STATUS_LOGON_FAILURE;
        break;

    case STATUS_INVALID_LOGON_HOURS:
    case STATUS_INVALID_WORKSTATION:
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_ACCOUNT_DISABLED:
        *SubStatus = Status;
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;

    //
    // This shouldn't happen, but guard against it anyway.
    //
    case STATUS_ACCOUNT_RESTRICTION:
        *SubStatus = STATUS_ACCOUNT_RESTRICTION;
        break;

    default:
        break;

    }


    //
    // Cleanup locally used resources
    //

    if ( Credential != NULL ) {
        (*Lsa.FreeLsaHeap)( Credential );
    }

    if ( NlpUser != NULL ) {
        MIDL_user_free( NlpUser );
    }

    if ( UserSid != NULL ) {
        (*Lsa.FreeLsaHeap)( UserSid );
    }

//
// Cleanup short was added to avoid returning from the middle of the function.
//
CleanupShort:

    //
    // End tracing a logon user
    //
    if (NtlmGlobalEventTraceFlag){

        UNICODE_STRING strTempDomain = {0};

        //
        // Trace header goo
        //
        SET_TRACE_HEADER(TraceInfo,
                         NtlmLogonGuid,
                         EVENT_TRACE_TYPE_END,
                         WNODE_FLAG_TRACED_GUID|WNODE_FLAG_USE_MOF_PTR,
                         6);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_LOGON_STATUS,
                        Status);

        SET_TRACE_DATA(TraceInfo,
                        TRACE_LOGON_TYPE,
                        LogonType);

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_LOGON_USERNAME,
                          (**AccountName));

        if(AuthenticatingAuthority)
            strTempDomain = **AuthenticatingAuthority;

        SET_TRACE_USTRING(TraceInfo,
                          TRACE_LOGON_DOMAINNAME,
                          strTempDomain);

        TraceEvent(NtlmGlobalTraceLoggerHandle,
                   (PEVENT_TRACE_HEADER)&TraceInfo);
    }


#if _WIN64

    //
    // Do this last since some of the cleanup code above may refer to addresses
    // inside the pTempSubmitBuffer/ProtocolSubmitBuffer (e.g., copying out the
    // Workstation name, etc).
    //

    if (fAllocatedSubmitBuffer)
    {
        NtLmFreePrivateHeap( pTempSubmitBuffer );
    }

#endif  // _WIN64


    //
    // Return status to the caller
    //

    return Status;

}


VOID
LsaApLogonTerminated (
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine is used to notify each authentication package when a logon
    session terminates.  A logon session terminates when the last token
    referencing the logon session is deleted.

Arguments:

    LogonId - Is the logon ID that just logged off.

Return Status:

    None.



--*/

{
    NTSTATUS Status;

    PACTIVE_LOGON LogonEntry;
    PACTIVE_LOGON *ActiveLogon;
    NETLOGON_INTERACTIVE_INFO LogonInteractive;
    PNETLOGON_INTERACTIVE_INFO LogonInteractivePointer;

    //
    // Find the entry and de-link it from the active logon table.
    //

    // this scheme assumes we won't be called concurrently, multiple times,
    // for the same LogonId. (would need to take write lock up front to support that).
    //


    NlpLockActiveLogonsWrite();

    if ( !NlpFindActiveLogon( LogonId, &ActiveLogon ) ) {
        NlpUnlockActiveLogons();
        return;
    }

    LogonEntry = *ActiveLogon;
    *ActiveLogon = LogonEntry->Next;
    NlpUnlockActiveLogons();


    //
    // Delete the credential.
    //
    // (Currently the LSA deletes all of the credentials before calling
    // the authentication package.  This line is added to be compatible
    // with a more reasonable LSA.)
    //

    (VOID) NlpDeletePrimaryCredential( &LogonEntry->LogonId );

    //
    // Deallocate the now orphaned entry.
    //

    I_NtLmFree( LogonEntry );


    //
    // NB: We don't delete the logon session or credentials.
    //  That will be done by the LSA itself after we return.
    //

    return;

}

//+-------------------------------------------------------------------------
//
//  Function:   SspAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the Kerberos package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - If present, contains credentials
//                  from the account itself.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SspAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;
    NTSTATUS Status = STATUS_SUCCESS;
    LUID SystemLuid = SYSTEM_LUID;
    UNICODE_STRING DomainNameToUse;
    PACTIVE_LOGON *ActiveLogon;
    PACTIVE_LOGON LogonEntry = NULL;
    ULONG LogonEntrySize;
    ULONG UserSidSize;
    PUCHAR Where;
    USHORT LogonCount;
    BOOLEAN LogonEntryLinked = FALSE;
    BOOLEAN LsaCredentialAdded = FALSE;
    PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredentials = NULL;

    LUID CredentialLuid;

    CredentialLuid = PrimaryCredentials->LogonId;

    //
    // If there is no cleartext password, bail out here because we
    // can't build a real credential.
    //

    if ((PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) == 0) {
        if (!ARGUMENT_PRESENT(SupplementalCredentials)) {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        } else {
            //
            // Validate the MSV credentials
            //

            MsvCredentials = (PMSV1_0_SUPPLEMENTAL_CREDENTIAL) SupplementalCredentials->Credentials;
            if (SupplementalCredentials->CredentialSize < sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL))
            {
                //
                // LOGLOG: bad credentials - ignore them
                //
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
            if (MsvCredentials->Version != MSV1_0_CRED_VERSION)
            {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }
    }


    //
    // stash the credential associated with SYSTEM under another logonID
    // this is done so we can utilize that credential at a later time if
    // requested by the caller.
    //

    if (RtlEqualLuid(
            &CredentialLuid,
            &SystemLuid
            ))
    {

        CredentialLuid = NtLmGlobalLuidMachineLogon;
    }

    //
    // If this is an update, just change the password
    //

    if ((PrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0) {
        if ((PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) != 0) {

            Status = NlpChangePasswordByLogonId(
                            &CredentialLuid,
                            &PrimaryCredentials->Password
                            );
        } else {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }



    if( NtLmLocklessGlobalPreferredDomainString.Buffer != NULL ) {
        DomainNameToUse = NtLmLocklessGlobalPreferredDomainString;
    } else {
        DomainNameToUse = PrimaryCredentials->DomainName;
    }

    //
    // Build the primary credential
    //

    if ((PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD) != 0) {

        Status = NlpMakePrimaryCredential( &DomainNameToUse,
                                           &PrimaryCredentials->DownlevelName,
                                           &PrimaryCredentials->Password,
                                           &Credential,
                                           &CredentialSize );
    } else {
        Status = NlpMakePrimaryCredentialFromMsvCredential(
                    &DomainNameToUse,
                    &PrimaryCredentials->DownlevelName,
                    MsvCredentials,
                    &Credential,
                    &CredentialSize );
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // Now create an entry in the active logon list
    //


    UserSidSize = RtlLengthSid( PrimaryCredentials->UserSid );


    //
    // Allocate an entry for the active logon table.
    //

    LogonEntrySize = ROUND_UP_COUNT(sizeof(ACTIVE_LOGON), ALIGN_DWORD) +
          ROUND_UP_COUNT(UserSidSize, sizeof(WCHAR)) +
          PrimaryCredentials->DownlevelName.Length + sizeof(WCHAR) +
          PrimaryCredentials->DomainName.Length + sizeof(WCHAR) +
          PrimaryCredentials->LogonServer.Length + sizeof(WCHAR);

    LogonEntry = I_NtLmAllocate( LogonEntrySize );

    if ( LogonEntry == NULL ) {
        Status = STATUS_NO_MEMORY;
        SspPrint((SSP_CRITICAL,"SpAcceptCredentials: No memory %ld\n",
                sizeof(ACTIVE_LOGON)));
        goto Cleanup;
    }

    //
    // Fill in the logon table entry.
    //

    Where = (PUCHAR)(LogonEntry + 1);

    OLD_TO_NEW_LARGE_INTEGER(
        CredentialLuid,
        LogonEntry->LogonId );

    //
    // Indicate that this was a logon by another package because we don't want to
    // notify Netlogon of the logoff.
    //

    LogonEntry->Flags = LOGON_BY_OTHER_PACKAGE;
    LogonEntry->LogonType = LogonType;

    //
    // Copy DWORD aligned fields first.
    //

    Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );
    Status = RtlCopySid(UserSidSize, (PSID)Where, PrimaryCredentials->UserSid);

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    LogonEntry->UserSid = (PSID) Where;
    Where += UserSidSize;

    //
    // Copy WCHAR aligned fields
    //

    Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
    NlpPutString( &LogonEntry->UserName,
                  &PrimaryCredentials->DownlevelName,
                  &Where );

    NlpPutString( &LogonEntry->LogonDomainName,
                  &PrimaryCredentials->DomainName,
                  &Where );

    NlpPutString( &LogonEntry->LogonServer,
                  &PrimaryCredentials->LogonServer,
                  &Where );



    //
    // Insert this entry into the active logon table.
    //

    NlpLockActiveLogonsWrite();
    if (NlpFindActiveLogon( &CredentialLuid, &ActiveLogon )){

        //
        // This Logon ID is already in use.
        //


        //
        // Check to see if this was someone we logged on
        //

        if (((*ActiveLogon)->Flags & (LOGON_BY_CACHE | LOGON_BY_NETLOGON | LOGON_BY_LOCAL)) != 0) {

            //
            // Unlock early since we hold a write lock
            //
            NlpUnlockActiveLogons();

            //
            // We did the logon, so don't bother to add it again.
            //

            I_NtLmFree( LogonEntry );
            (*Lsa.FreeLsaHeap)( Credential );
            Credential = NULL;
            Status = STATUS_SUCCESS;

        } else {

            //
            // Unlock early since we hold a write lock
            //
            NlpUnlockActiveLogons();

            Status = STATUS_LOGON_SESSION_COLLISION;
            SspPrint((SSP_CRITICAL,
                "SpAcceptCredentials: Collision from NlpFindActiveLogon\n"));

        }

        goto Cleanup;
    }

    LogonEntry->EnumHandle = (ULONG)InterlockedIncrement( (PLONG)&NlpEnumerationHandle );

    LogonEntry->Next = *ActiveLogon;
    *ActiveLogon = LogonEntry;
    NlpUnlockActiveLogons();

    LogonEntryLinked = TRUE;

    //
    // Save the credential in the LSA.
    //

    Status = NlpAddPrimaryCredential(
                &CredentialLuid,
                Credential,
                CredentialSize
                );

    if ( !NT_SUCCESS( Status ) ) {
        SspPrint((SSP_CRITICAL, "SpAcceptCredentials: error from AddCredential %lX\n",
            Status));
        goto Cleanup;
    }

    LsaCredentialAdded = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (LogonEntry != NULL) {
            if (LogonEntryLinked) {
                LsaApLogonTerminated( &CredentialLuid );
            } else {

                if ( LsaCredentialAdded ) {
                    (VOID) NlpDeletePrimaryCredential(
                                &CredentialLuid );
                }
                I_NtLmFree( LogonEntry );
            }
        } else if (Credential != NULL) {

            if (LsaCredentialAdded) {
                (VOID) NlpDeletePrimaryCredential(
                            &CredentialLuid
                            );

            } else {
                (*Lsa.FreeLsaHeap)( Credential );
                Credential = NULL;
            }

        }
    }
    if ( Credential != NULL ) {
        (*Lsa.FreeLsaHeap)( Credential );
    }


    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   NlpMapLogonDomain
//
//  Synopsis:   This routine is called while MSV1_0 package is logging
//              a user on.  The logon domain name is mapped to another
//              domain to be stored in the credential.
//
//  Effects:    Allocates output string
//
//  Arguments:  MappedDomain - Receives mapped domain name
//              LogonDomain - Domain to which user is logging on
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NlpMapLogonDomain(
    OUT PUNICODE_STRING MappedDomain,
    IN PUNICODE_STRING LogonDomain
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if( (NtLmLocklessGlobalMappedDomainString.Buffer == NULL) ||
        !RtlEqualDomainName( LogonDomain, &NtLmLocklessGlobalMappedDomainString )
        )
    {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    LogonDomain
                    );
        goto Cleanup;
    }


    if ( NtLmLocklessGlobalPreferredDomainString.Buffer == NULL )
    {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    LogonDomain
                    );
    } else {
        Status = NtLmDuplicateUnicodeString(
                    MappedDomain,
                    &NtLmLocklessGlobalPreferredDomainString
                    );
    }


Cleanup:
    return(Status);
}



// calculate NTLM2 challenge from client and server challenges
VOID
MsvpCalculateNtlm2Challenge (
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH]
    )
{
    MD5_CTX Md5Context;

    MD5Init(
        &Md5Context
        );
    MD5Update(
        &Md5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    MD5Update(
        &Md5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    MD5Final(
        &Md5Context
        );
    ASSERT(MD5DIGESTLEN >= MSV1_0_CHALLENGE_LENGTH);

    RtlCopyMemory(
        Challenge,
        Md5Context.digest,
        MSV1_0_CHALLENGE_LENGTH
        );
}


// calculate NTLM2 session keys from User session key given
//  to us by the system with the user's account

VOID
MsvpCalculateNtlm2SessionKeys (
    IN PUSER_SESSION_KEY NtUserSessionKey,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PUSER_SESSION_KEY LocalUserSessionKey,
    OUT PLM_SESSION_KEY LocalLmSessionKey
    )
{
    // SESSKEY = HMAC(NtUserSessionKey, (ChallengeToClient, ChallengeFromClient))
    //  Lm session key is first 8 bytes of session key
    HMACMD5_CTX HMACMD5Context;

    HMACMD5Init(
        &HMACMD5Context,
        (PUCHAR)NtUserSessionKey,
        sizeof(*NtUserSessionKey)
        );
    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)LocalUserSessionKey
        );
    RtlCopyMemory(
        LocalLmSessionKey,
        LocalUserSessionKey,
        sizeof(*LocalLmSessionKey)
        );
}


// calculate NTLM3 OWF from credentials
VOID
MsvpCalculateNtlm3Owf (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    OUT UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH]
    )
{
    HMACMD5_CTX HMACMD5Context;
    WCHAR UCUserName[UNLEN+1];
    UNICODE_STRING UCUserNameString = {0, UNLEN, UCUserName};

    RtlUpcaseUnicodeString(
        &UCUserNameString,
        pUserName,
        FALSE
        );


    // Calculate NTLM3 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))

    HMACMD5Init(
        &HMACMD5Context,
        (PUCHAR)pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)UCUserNameString.Buffer,
        pUserName->Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlm3Owf
        );
}


// calculate LM3 response from credentials
VOID
MsvpLm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH];

    // get NTLM3 OWF

    MsvpCalculateNtlm3Owf (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlm3Owf
        );

    // Calculate NTLM3 Response
    // HMAC(Ntlm3Owf, (NS, V, HV, T, NC, S))

    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        (PUCHAR)pLm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    return;
}


VOID
MsvpNtlm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN ULONG ServerNameLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlm3Owf[MSV1_0_NTLM3_OWF_LENGTH];

    // get NTLM3 OWF

    MsvpCalculateNtlm3Owf (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlm3Owf
        );

    // Calculate NTLM3 Response
    // HMAC(Ntlm3Owf, (NS, V, HV, T, NC, S))

    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        &pNtlm3Response->RespType,
        (MSV1_0_NTLM3_INPUT_LENGTH + ServerNameLength)
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_NTLM3_RESPONSE_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    // now compute the session keys
    //  HMAC(Kr, R)
    HMACMD5Init(
        &HMACMD5Context,
        Ntlm3Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        Response,
        MSV1_0_NTLM3_RESPONSE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)UserSessionKey
        );

    ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
    RtlCopyMemory(
        LmSessionKey,
        UserSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH);

    return;
}


NTSTATUS
MsvpLm20GetNtlm3ChallengeResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN PUNICODE_STRING pServerName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    )
/*++

Routine Description:

    This routine calculates the NT and LM response for the NTLM3
    authentication protocol
    It generates the time stamp, version numbers, and
    client challenge, and the NTLM3 and LM3 responses.

--*/

{

    NTSTATUS Status;

    // fill in version numbers, timestamp, and client's challenge

    pNtlm3Response->RespType = 1;
    pNtlm3Response->HiRespType = 1;
    pNtlm3Response->Flags = 0;
    pNtlm3Response->MsgWord = 0;

    Status = NtQuerySystemTime ( (PLARGE_INTEGER)&pNtlm3Response->TimeStamp );
    ASSERT( NT_SUCCESS(Status) );

    SspGenerateRandomBits(
        pNtlm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

#ifdef USE_CONSTANT_CHALLENGE
    pNtlm3Response->TimeStamp = 0;
    RtlZeroMemory(
        pNtlm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );
#endif

    RtlCopyMemory(
        pNtlm3Response->Buffer,
        pServerName->Buffer,
        pServerName->Length
        );

    // Calculate NTLM3 response, filling in response field
    MsvpNtlm3Response (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        pServerName->Length,
        ChallengeToClient,
        pNtlm3Response,
        pNtlm3Response->Response,
        UserSessionKey,
        LmSessionKey
        );

    // Use same challenge to compute the LM3 response
    RtlCopyMemory(
        pLm3Response->ChallengeFromClient,
        pNtlm3Response->ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    // Calculate LM3 response
    MsvpLm3Response (
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        ChallengeToClient,
        pLm3Response,
        pLm3Response->Response
        );

    return STATUS_SUCCESS;
}


// MsvAvInit -- function to initialize AV pair list

PMSV1_0_AV_PAIR
MsvpAvlInit(
    IN void * pAvList
    )
{
    PMSV1_0_AV_PAIR pAvPair;

    pAvPair = (PMSV1_0_AV_PAIR)pAvList;
    pAvPair->AvId = MsvAvEOL;
    pAvPair->AvLen = 0;
    return pAvPair;
}

// MsvpAvGet -- function to find a particular AV pair by ID

PMSV1_0_AV_PAIR
MsvpAvlGet(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to find
    IN LONG cAvList                         // size of AV list
    )
{
    PMSV1_0_AV_PAIR pAvPair;

    pAvPair = pAvList;

    while (1) {
        if (pAvPair->AvId == AvId)
            return pAvPair;
        if (pAvPair->AvId == MsvAvEOL)
            return NULL;
       cAvList -= (pAvPair->AvLen + sizeof(MSV1_0_AV_PAIR));
       if (cAvList <= 0)
           return NULL;
       pAvPair = (PMSV1_0_AV_PAIR)((PUCHAR)pAvPair + pAvPair->AvLen + sizeof(MSV1_0_AV_PAIR));
    }
}

// MsvpAvlLen -- function to find length of a AV list

ULONG
MsvpAvlLen(
    IN PMSV1_0_AV_PAIR pAvList,            // first pair of AV pair list
    IN LONG cAvList                        // max size of AV list
    )
{
    PMSV1_0_AV_PAIR pCurPair;

    // find the EOL
    pCurPair = MsvpAvlGet(pAvList, MsvAvEOL, cAvList);
    if( pCurPair == NULL )
        return 0;

    // compute length (not forgetting the EOL pair)
    return (ULONG)(((PUCHAR)pCurPair - (PUCHAR)pAvList) + sizeof(MSV1_0_AV_PAIR));
}

// MsvpAvlAdd -- function to add an AV pair to a list
// assumes buffer is long enough!
// returns NULL on failure.

PMSV1_0_AV_PAIR
MsvpAvlAdd(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to add
    IN PUNICODE_STRING pString,             // value of pair
    IN LONG cAvList                         // max size of AV list
    )
{
    PMSV1_0_AV_PAIR pCurPair;

    // find the EOL
    pCurPair = MsvpAvlGet(pAvList, MsvAvEOL, cAvList);
    if( pCurPair == NULL )
        return NULL;

    //
    // append the new AvPair (assume the buffer is long enough!)
    //

    pCurPair->AvId = (USHORT)AvId;
    pCurPair->AvLen = (USHORT)pString->Length;
    memcpy(pCurPair+1, pString->Buffer, pCurPair->AvLen);

    // top it off with a new EOL
    pCurPair = (PMSV1_0_AV_PAIR)((PUCHAR)pCurPair + sizeof(MSV1_0_AV_PAIR) + pCurPair->AvLen);
    pCurPair->AvId = MsvAvEOL;
    pCurPair->AvLen = 0;

    return pCurPair;
}


// MsvpAvlSize -- fucntion to calculate length needed for an AV list
ULONG
MsvpAvlSize(
    IN ULONG iPairs,            // number of AV pairs response will include
    IN ULONG iPairsLen          // total size of values for the pairs
    )
{
    return (
        iPairs * sizeof(MSV1_0_AV_PAIR) +   // space for the pairs' headers
        iPairsLen +                         // space for pairs' values
        sizeof(MSV1_0_AV_PAIR)              // space for the EOL
        );
}

NTSTATUS
MsvpAvlToString(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  LPWSTR *szAvlString
    )
{
    PMSV1_0_AV_PAIR pAV;

    *szAvlString = NULL;

    if( AvlString->Buffer == NULL || AvlString->Length == 0 )
    {
        return STATUS_SUCCESS;
    }

    pAV = MsvpAvlGet(
                (PMSV1_0_AV_PAIR)AvlString->Buffer,
                AvId,
                AvlString->Length
                );

    if( pAV != NULL )
    {
        LPWSTR szAvInfo = (LPWSTR)( pAV+1 );
        USHORT AvLen =  pAV->AvLen;

        LPWSTR szResult;

        szResult = NtLmAllocate( AvLen + sizeof(WCHAR) );
        if( szResult == NULL )
        {
            SspPrint(( SSP_CRITICAL, "MsvpAvlToString: Error allocating memory.\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory( szResult, szAvInfo, AvLen );
        szResult[ AvLen/sizeof(WCHAR) ] = L'\0';
        *szAvlString = szResult;
    }


    return STATUS_SUCCESS;
}

NTSTATUS
MsvpAvlToFlag(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  ULONG *ulAvlFlag
    )
{
    PMSV1_0_AV_PAIR pAV;

    *ulAvlFlag = 0;

    if( AvlString->Buffer == NULL || AvlString->Length == 0 )
    {
        return STATUS_SUCCESS;
    }

    pAV = MsvpAvlGet(
                (PMSV1_0_AV_PAIR)AvlString->Buffer,
                AvId,
                AvlString->Length
                );

    if( pAV != NULL )
    {
        if( pAV->AvLen == sizeof( *ulAvlFlag ) )
        {
            CopyMemory( ulAvlFlag, (pAV+1), sizeof(ULONG) );
            return STATUS_SUCCESS;
        }
    }


    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\msvwow.cxx ===
#if _WIN64

#include <global.h>
#include "msp.h"
#include "nlp.h"

#include "msvwow.h"


#define RELOCATE_WOW_UNICODE_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPWSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);

#define RELOCATE_WOW_ANSI_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);


//+-------------------------------------------------------------------------
//
//  Function:   MsvPutWOWString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
MsvPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = PtrToUlong (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   MsvPutWOWClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              32-bit client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutClientString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------


VOID
MsvPutWOWClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    ClientBufferDesc->StringOffset, and fixes the OutString string to point
    to that new copy.


Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    InString - A pointer to an NT string to be copied

    OutString - A pointer to a destination NT string.  This string structure
        is in the "Mirror" allocated buffer.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{

    //
    // Ensure our caller passed good data.
    //

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( COUNT_IS_ALIGNED( ClientBufferDesc->StringOffset, sizeof(WCHAR)) );
    ASSERT( (LPBYTE)OutString >= ClientBufferDesc->MsvBuffer );
    ASSERT( (LPBYTE)OutString <
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->TotalSize - sizeof(UNICODE_STRING) );

    ASSERT( ClientBufferDesc->StringOffset + InString->Length + sizeof(WCHAR) <=
            ClientBufferDesc->TotalSize );

#ifdef notdef
    KdPrint(("NlpPutClientString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  Orig: UserBuffer: %lx Offset: 0x%lx TotalSize: 0x%lx\n",
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->StringOffset,
                ClientBufferDesc->TotalSize ));
#endif

    //
    // Build a string structure and copy the text to the Mirror buffer.
    //

    if ( InString->Length > 0 ) {

        ULONG_PTR TmpPtr;

        //
        // Copy the string (Add a zero character)
        //

        RtlCopyMemory(
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset,
            InString->Buffer,
            InString->Length );

        // Do one byte at a time since some callers don't pass in an even
        // InString->Length
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length) = '\0';
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length+1) = '\0';

        //
        // Build the string structure to point to the data in the client's
        // address space.
        //

        TmpPtr = (ULONG_PTR)(ClientBufferDesc->UserBuffer +
                                    ClientBufferDesc->StringOffset);

        OutString->Buffer = (ULONG)TmpPtr;
        OutString->Length = InString->Length;
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);

        //
        // Adjust the offset to past the newly copied string.
        //

        ClientBufferDesc->StringOffset += OutString->MaximumLength;

    } else {
        ZeroMemory( OutString, sizeof(*OutString) );
    }


    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   MsvConvertWOWInteractiveLogonBuffer
//
//  Synopsis:   Converts logon buffers passed in from WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit logon buffer
//              pSubmitBufferSize    -- size of the 32-bit logon buffer
//              MessageType          -- format of the logon buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
MsvConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_INTERACTIVE_LOGON       Logon;
    PMSV1_0_INTERACTIVE_LOGON_WOW64 LogonWOW;
    DWORD                           dwOffset;
    DWORD                           dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size and add on 3 PVOIDs for the worst-case
    // scenario to align the three embedded UNICODE_STRINGs
    //

    dwBufferSize += sizeof(MSV1_0_INTERACTIVE_LOGON)
                        - sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_INTERACTIVE_LOGON))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Logon    = (PMSV1_0_INTERACTIVE_LOGON) pTempBuffer;
    LogonWOW = (PMSV1_0_INTERACTIVE_LOGON_WOW64) ProtocolSubmitBuffer;

    Logon->MessageType = LogonWOW->MessageType;

    dwOffset    = sizeof(MSV1_0_INTERACTIVE_LOGON);
    dwWOWOffset = sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);


    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) Logon + dwOffset,
                  (LPBYTE) LogonWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                Logon->LogonDomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                Logon->UserName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->Password,
                                Logon->Password,
                                dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}

NTSTATUS
MsvConvertWOWNetworkLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_LM20_LOGON              Logon;
    PMSV1_0_LM20_LOGON_WOW64        LogonWOW;
    DWORD                           dwOffset;
    DWORD                           dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size and add on 5 PVOIDs for the worst-case
    // scenario to align the three embedded UNICODE_STRINGs
    //

    dwBufferSize += sizeof(MSV1_0_LM20_LOGON)
                        - sizeof(MSV1_0_LM20_LOGON_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_LM20_LOGON))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Logon    = (PMSV1_0_LM20_LOGON) pTempBuffer;
    LogonWOW = (PMSV1_0_LM20_LOGON_WOW64) ProtocolSubmitBuffer;

    //
    // copy fixed fields.
    //

    Logon->MessageType      = LogonWOW->MessageType;
    Logon->ParameterControl = LogonWOW->ParameterControl;

    RtlCopyMemory(Logon->ChallengeToClient, LogonWOW->ChallengeToClient, MSV1_0_CHALLENGE_LENGTH);

    dwOffset    = sizeof(MSV1_0_LM20_LOGON);
    dwWOWOffset = sizeof(MSV1_0_LM20_LOGON_WOW64);

    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) Logon + dwOffset,
                  (LPBYTE) LogonWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                Logon->LogonDomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                Logon->UserName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->Workstation,
                                Logon->Workstation,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_ANSI_STRING(LogonWOW->CaseSensitiveChallengeResponse,
                             Logon->CaseSensitiveChallengeResponse,
                             dwOffset - dwWOWOffset);

    RELOCATE_WOW_ANSI_STRING(LogonWOW->CaseInsensitiveChallengeResponse,
                             Logon->CaseInsensitiveChallengeResponse,
                             dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   MsvConvertWOWChangePasswordBuffer
//
//  Synopsis:   Converts change password buffers passed in from
//              WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit buffer
//              ClientBufferBase     -- base address
//              pSubmitBufferSize    -- size of the 32-bit buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
MsvConvertWOWChangePasswordBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    PMSV1_0_CHANGEPASSWORD_REQUEST        PasswordRequest;
    PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64  PasswordRequestWOW;
    DWORD                                 dwOffset;
    DWORD                                 dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Scale up the size
    //

    dwBufferSize += sizeof(MSV1_0_CHANGEPASSWORD_REQUEST)
                        - sizeof(MSV1_0_CHANGEPASSWORD_REQUEST_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_CHANGEPASSWORD_REQUEST))
    {
#if 0
        DebugLog((DEB_ERROR,
                  "Submit buffer to logon too small: %d. %ws, line %d\n",
                  dwBufferSize,
                  THIS_FILE,
                  __LINE__));
#endif
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = NtLmAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    PasswordRequest    = (PMSV1_0_CHANGEPASSWORD_REQUEST) pTempBuffer;
    PasswordRequestWOW = (PMSV1_0_CHANGEPASSWORD_REQUEST_WOW64) ProtocolSubmitBuffer;

    //
    // copy fixed fields.
    //

    PasswordRequest->MessageType   = PasswordRequestWOW->MessageType;
    PasswordRequest->Impersonating = PasswordRequestWOW->Impersonating;

    dwOffset    = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST);
    dwWOWOffset = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST_WOW64);

    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) PasswordRequest + dwOffset,
                  (LPBYTE) PasswordRequestWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->DomainName,
                                PasswordRequest->DomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->AccountName,
                                PasswordRequest->AccountName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->OldPassword,
                                PasswordRequest->OldPassword,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(PasswordRequestWOW->NewPassword,
                                PasswordRequest->NewPassword,
                                dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        NtLmFreePrivateHeap(pTempBuffer);
    }

    return Status;
}


NTSTATUS
MsvAllocateInteractiveWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    )

/*++

Routine Description:

    This allocates and fills in the clients interactive profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_INTERACTIVE_PROFILE_WOW64 LocalProfileBuffer;


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;

    *ProfileBufferSize = sizeof(MSV1_0_INTERACTIVE_PROFILE_WOW64) +
        NlpUser->LogonScript.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectory.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        NlpUser->FullName.Length + sizeof(WCHAR) +
        NlpUser->ProfilePath.Length + sizeof(WCHAR) +
        NlpUser->LogonServer.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_INTERACTIVE_PROFILE_WOW64),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    LocalProfileBuffer = (PMSV1_0_INTERACTIVE_PROFILE_WOW64) ClientBufferDesc.MsvBuffer;


    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = MsV1_0InteractiveProfile;
    LocalProfileBuffer->LogonCount = NlpUser->LogonCount;
    LocalProfileBuffer->BadPasswordCount= NlpUser->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = NlpUser->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonScript,
                        &NlpUser->LogonScript );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectory,
                        &NlpUser->HomeDirectory );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectoryDrive,
                        &NlpUser->HomeDirectoryDrive );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->FullName,
                        &NlpUser->FullName );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->ProfilePath,
                        &NlpUser->ProfilePath );

    MsvPutWOWClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonServer,
                        &NlpUser->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID *) ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return Status;

}

NTSTATUS
MsvAllocateNetworkWOWProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    )

/*++

Routine Description:

    This allocates and fills in the clients network profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.  Will be NULL to indicate a
        NULL session.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    NTSTATUS SubAuthStatus = STATUS_SUCCESS;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_LM20_LOGON_PROFILE_WOW64 LocalProfile;

    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;
    *ProfileBufferSize = sizeof(MSV1_0_LM20_LOGON_PROFILE_WOW64);

    if ( NlpUser != NULL ) {
        *ProfileBufferSize += NlpUser->LogonDomainName.Length + sizeof(WCHAR) +
                              NlpUser->LogonServer.Length + sizeof(WCHAR) +
                              NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR);
    }


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_LOGON_PROFILE_WOW64),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfile = (PMSV1_0_LM20_LOGON_PROFILE_WOW64) ClientBufferDesc.MsvBuffer;
    LocalProfile->MessageType = MsV1_0Lm20LogonProfile;


    //
    // For a NULL session, return a constant profile buffer
    //

    if ( NlpUser == NULL ) {

        LocalProfile->KickOffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->KickOffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->LogoffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->LogoffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->UserFlags = 0;
        RtlZeroMemory( LocalProfile->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey));
        RtlZeroMemory( LocalProfile->LanmanSessionKey,
                       sizeof(LocalProfile->LanmanSessionKey));
        RtlZeroMemory( &LocalProfile->LogonDomainName, sizeof(LocalProfile->LogonDomainName) );
        RtlZeroMemory( &LocalProfile->LogonServer, sizeof(LocalProfile->LogonServer) );
        RtlZeroMemory( &LocalProfile->UserParameters, sizeof(LocalProfile->UserParameters) );


    //
    // For non-null sessions,
    //  fill in the profile buffer.
    //

    } else {

        //
        // Copy the individual scalar fields into the profile buffer.
        //

        if ((ParameterControl & MSV1_0_RETURN_PASSWORD_EXPIRY) != 0) {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                                      LocalProfile->LogoffTime);
        } else {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                                      LocalProfile->LogoffTime);
        }
        OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                                  LocalProfile->KickOffTime);
        LocalProfile->UserFlags = NlpUser->UserFlags;

        RtlCopyMemory( LocalProfile->UserSessionKey,
                       &NlpUser->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey) );

        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE ==
                sizeof(LocalProfile->LanmanSessionKey) );
        RtlCopyMemory(
            LocalProfile->LanmanSessionKey,
            &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
            SAMINFO_LM_SESSION_KEY_SIZE );


        // We need to extract the true status sent back for subauth users,
        // but not by a sub auth package

        SubAuthStatus = NlpUser->ExpansionRoom[SAMINFO_SUBAUTH_STATUS];

        //
        // Copy the Unicode strings into the profile buffer.
        //

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->LogonDomainName,
                                &NlpUser->LogonDomainName );

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->LogonServer,
                                &NlpUser->LogonServer );

        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
        // so we'll use that field.
        //

        MsvPutWOWClientString(  &ClientBufferDesc,
                                &LocalProfile->UserParameters,
                                &NlpUser->HomeDirectoryDrive );

    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID*)ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    // Save the status for subauth logons

    if (NT_SUCCESS(Status) && !NT_SUCCESS(SubAuthStatus))
    {
        Status = SubAuthStatus;
    }

    return Status;

}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlp.c

Abstract:

    This file is the contains private routines which support
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Cliff Van Dyke 29-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"
#include "nlpcache.h"

#include "msvwow.h"

DWORD
NlpCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    );

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);
    ASSERT( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );
#ifdef notdef
    KdPrint(("NlpPutString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  InString: %lx %lx OutString: %lx Where: %lx\n", InString,
        InString->Buffer, OutString, *Where ));
#endif

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }
#ifdef notdef
    KdPrint(("  OutString: %ld %lx\n",  OutString->Length, OutString->Buffer));
#endif

    return;
}


VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This routine initializes a ClientBufferDescriptor to known values.
    This routine must be called before any of the other routines that use
    the ClientBufferDescriptor.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

Return Values:

    None.

--*/

{

    //
    // Fill in a pointer to the ClientRequest and zero the rest.
    //

    ClientBufferDesc->ClientRequest = ClientRequest;
    ClientBufferDesc->UserBuffer = NULL;
    ClientBufferDesc->MsvBuffer = NULL;
    ClientBufferDesc->StringOffset = 0;
    ClientBufferDesc->TotalSize = 0;

}


NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine allocates a buffer in the clients address space.
    It also allocates a mirror buffer in MSV's address space.

    The data will be constructed in the MSV's address space then 'flushed'
    into the client's address space.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    FixedSize - The size in bytes of the fixed portion of the buffer.

    TotalSize - The size in bytes of the entire buffer.

Return Values:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Allocate the Mirror buffer.
    //

    ASSERT( ClientBufferDesc->MsvBuffer == NULL );
    ClientBufferDesc->MsvBuffer = I_NtLmAllocate( TotalSize );

    if ( ClientBufferDesc->MsvBuffer == NULL ) {
        return STATUS_NO_MEMORY;
    }


    //
    // Allocate the client's buffer
    //

    ASSERT( ClientBufferDesc->UserBuffer == NULL );
    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
         ClientBufferDesc->UserBuffer = (*(Lsa.AllocateLsaHeap))(TotalSize);
    }
    else
    {
        Status = (*Lsa.AllocateClientBuffer)(
                    ClientBufferDesc->ClientRequest,
                    TotalSize,
                    (PVOID *)&ClientBufferDesc->UserBuffer );
    }

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        if (ClientBufferDesc->UserBuffer == NULL)
        {
            NlpFreeClientBuffer( ClientBufferDesc );
            return STATUS_NO_MEMORY;
        }
    }
    else
    {
        if ( !NT_SUCCESS( Status ) ) {
            ClientBufferDesc->UserBuffer = NULL;
            NlpFreeClientBuffer( ClientBufferDesc );
            return Status;
        }
    }

    //
    // Return
    //

    ClientBufferDesc->StringOffset = FixedSize;
    ClientBufferDesc->TotalSize = TotalSize;

    return STATUS_SUCCESS;

}


NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    )

/*++

Routine Description:

    Copy the Mirror Buffer into the Client's address space.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    UserBuffer - If successful, returns a pointer to the user's buffer.
        (The caller is now resposible for deallocating the buffer.)

Return Values:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy the data to the client's address space.
    //

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        RtlCopyMemory(
                 ClientBufferDesc->UserBuffer,
                 ClientBufferDesc->MsvBuffer,
                 ClientBufferDesc->TotalSize);
    }
    else
    {
        Status = (*Lsa.CopyToClientBuffer)(
                ClientBufferDesc->ClientRequest,
                ClientBufferDesc->TotalSize,
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->MsvBuffer );
    }


    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Mark that we're no longer responsible for the client's buffer.
    //

    *UserBuffer = (PVOID) ClientBufferDesc->UserBuffer;
    ClientBufferDesc->UserBuffer = NULL;

    //
    // Free the mirror buffer
    //

    NlpFreeClientBuffer( ClientBufferDesc );


    return STATUS_SUCCESS;

}


VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    )

/*++

Routine Description:

    Free any Mirror Buffer or Client buffer.

Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

Return Values:

    None

--*/

{

    //
    // Free the mirror buffer.
    //

    if ( ClientBufferDesc->MsvBuffer != NULL ) {
        I_NtLmFree( ClientBufferDesc->MsvBuffer );
        ClientBufferDesc->MsvBuffer = NULL;
    }

    //
    // Free the Client's buffer
    //

    if ((ClientBufferDesc->ClientRequest == (PLSA_CLIENT_REQUEST) (-1)))
    {
        if ( ClientBufferDesc->UserBuffer != NULL ) {
            (*Lsa.FreeLsaHeap)(ClientBufferDesc->UserBuffer);
            ClientBufferDesc->UserBuffer = NULL;
        }
    }
    else
    {
        if ( ClientBufferDesc->UserBuffer != NULL ) {
            (VOID) (*Lsa.FreeClientBuffer)( ClientBufferDesc->ClientRequest,
                                            ClientBufferDesc->UserBuffer );
            ClientBufferDesc->UserBuffer = NULL;
        }
    }

}


VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    ClientBufferDesc->StringOffset, and fixes the OutString string to point
    to that new copy.


Parameters:

    ClientBufferDesc - Descriptor of a buffer allocated in the client's
        address space.

    InString - A pointer to an NT string to be copied

    OutString - A pointer to a destination NT string.  This string structure
        is in the "Mirror" allocated buffer.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{

    //
    // Ensure our caller passed good data.
    //

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( COUNT_IS_ALIGNED( ClientBufferDesc->StringOffset, sizeof(WCHAR)) );
    ASSERT( (LPBYTE)OutString >= ClientBufferDesc->MsvBuffer );
    ASSERT( (LPBYTE)OutString <
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->TotalSize - sizeof(UNICODE_STRING) );

    ASSERT( ClientBufferDesc->StringOffset + InString->Length + sizeof(WCHAR) <=
            ClientBufferDesc->TotalSize );

#ifdef notdef
    KdPrint(("NlpPutClientString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  Orig: UserBuffer: %lx Offset: 0x%lx TotalSize: 0x%lx\n",
                ClientBufferDesc->UserBuffer,
                ClientBufferDesc->StringOffset,
                ClientBufferDesc->TotalSize ));
#endif

    //
    // Build a string structure and copy the text to the Mirror buffer.
    //

    if ( InString->Length > 0 ) {

        //
        // Copy the string (Add a zero character)
        //

        RtlCopyMemory(
            ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset,
            InString->Buffer,
            InString->Length );

        // Do one byte at a time since some callers don't pass in an even
        // InString->Length
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length) = '\0';
        *(ClientBufferDesc->MsvBuffer + ClientBufferDesc->StringOffset +
            InString->Length+1) = '\0';

        //
        // Build the string structure to point to the data in the client's
        // address space.
        //

        OutString->Buffer = (PWSTR)(ClientBufferDesc->UserBuffer +
                            ClientBufferDesc->StringOffset);
        OutString->Length = InString->Length;
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);

        //
        // Adjust the offset to past the newly copied string.
        //

        ClientBufferDesc->StringOffset += OutString->MaximumLength;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }

#ifdef notdef
    KdPrint(("  New: Offset: 0x%lx StringStart: %lx\n",
                ClientBufferDesc->StringOffset,
                OutString->Buffer ));
#endif

    return;

}


VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine converts the buffer address in the specified string to
    be a byte offset from BaseAddress.

Parameters:

    BaseAddress - A pointer to make the destination address relative to.

    String - A pointer to a NT string to make relative.

Return Values:

    None.

--*/

{
    ASSERT( BaseAddress != NULL );
    ASSERT( String != NULL );
    ASSERT( sizeof(ULONG_PTR) == sizeof(String->Buffer) );

    if ( String->Buffer != NULL ) {
        *((PULONG_PTR)(&String->Buffer)) =
            (ULONG_PTR)((PUCHAR)String->Buffer - (PUCHAR)BaseAddress);
    }

    return;
}


VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG_PTR RelativeValue
    )

/*++

Routine Description:

    This routine converts the byte offset from BaseAddress to be an
    absolute address.

Parameters:

    BaseAddress - A pointer the destination address is relative to.

    RelativeValue - A pointer to a relative value to make absolute.

Return Values:

    None.

--*/

{
    ASSERT( BaseAddress != NULL );
    ASSERT( RelativeValue != NULL );

    if ( *((PUCHAR *)RelativeValue) != NULL ) {
        *RelativeValue = (ULONG_PTR)((PUCHAR)BaseAddress + (*RelativeValue));
    }

    return;
}


BOOLEAN
NlpFindActiveLogon(
    IN PLUID LogonId,
    OUT PACTIVE_LOGON **ActiveLogon
    )

/*++

Routine Description:

    This routine finds the specified Logon Id in the ActiveLogon table.
    It returns a boolean indicating whether the Logon Id exists in the
    ActiveLogon Table.  If so, this routine also returns a pointer to a
    pointer to the appropriate entry in the table.  If not, this routine
    returns a pointer to where such an entry would be inserted in the table.

    This routine must be called with the NlpActiveLogonLock locked.

Parameters:

    LogonId - The LogonId of the logon to find in the table.

    ActiveLogon - If the specified logon Id exists, returns a pointer to a
        pointer to the appropriate entry in the table.  Otherwise,
        returns a pointer to where such an entry would be inserted in the
        table.

Return Values:

    TRUE - The specified LogonId already exists in the table.

    FALSE - The specified LogonId does not exist in the table.

--*/

{
    PACTIVE_LOGON *Logon;

    //
    // Loop through the table looking for this particular LogonId.
    //

    for( Logon = &NlpActiveLogons; *Logon != NULL; Logon = &((*Logon)->Next) ) {
        if (RtlCompareMemory( &(*Logon)->LogonId, LogonId, sizeof(*LogonId))
                == sizeof(*LogonId) ) {

            *ActiveLogon = Logon;
            return TRUE;
        }
    }

    //
    // By returning a pointer to the NULL at the end of the list, we
    //  are forcing new entries to be placed at the end.  The list is
    //  thereby maintained in the order that the logon occurred.
    //  MsV1_0EnumerateUsers relies on this behavior.
    //

    *ActiveLogon = Logon;
    return FALSE;
}


ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING UserName
    )

/*++

Routine Description:

    This routine counts the number of time a particular user is logged on
    in the Active Logon Table.

Parameters:

    LogonDomainName - Domain in which this user account is defined.

    UserName - The user name to count the active logons for.

Return Values:

    The count of active logons for the specified user.

--*/

{
    PACTIVE_LOGON Logon;
    ULONG LogonCount = 0;


    //
    // Loop through the table looking for this particular LogonId.
    //

    NlpLockActiveLogonsRead();

    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next ) {

        if(RtlEqualUnicodeString( UserName, &Logon->UserName, (BOOLEAN) TRUE) &&
           RtlEqualDomainName(LogonDomainName,&Logon->LogonDomainName )){
            LogonCount ++;
        }

    }

    NlpUnlockActiveLogons();

    return LogonCount;
}




NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    )

/*++

Routine Description:

    This allocates and fills in the clients interactive profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_INTERACTIVE_PROFILE LocalProfileBuffer;

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        SECPKG_CALL_INFO  CallInfo;

        //
        // if the call originated outproc, need to check if wow64.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            return MsvAllocateInteractiveWOWProfile (
                                    ClientRequest,
                                    ProfileBuffer,
                                    ProfileBufferSize,
                                    NlpUser
                                    );
        }
    }
#endif  // _WIN64


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;

    *ProfileBufferSize = sizeof(MSV1_0_INTERACTIVE_PROFILE) +
        NlpUser->LogonScript.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectory.Length + sizeof(WCHAR) +
        NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        NlpUser->FullName.Length + sizeof(WCHAR) +
        NlpUser->ProfilePath.Length + sizeof(WCHAR) +
        NlpUser->LogonServer.Length + sizeof(WCHAR);

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_INTERACTIVE_PROFILE),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfileBuffer = (PMSV1_0_INTERACTIVE_PROFILE) ClientBufferDesc.MsvBuffer;

    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = MsV1_0InteractiveProfile;
    LocalProfileBuffer->LogonCount = NlpUser->LogonCount;
    LocalProfileBuffer->BadPasswordCount= NlpUser->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = NlpUser->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //


    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonScript,
                        &NlpUser->LogonScript );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectory,
                        &NlpUser->HomeDirectory );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->HomeDirectoryDrive,
                        &NlpUser->HomeDirectoryDrive );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->FullName,
                        &NlpUser->FullName );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->ProfilePath,
                        &NlpUser->ProfilePath );

    NlpPutClientString( &ClientBufferDesc,
                        &LocalProfileBuffer->LogonServer,
                        &NlpUser->LogonServer );


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   (PVOID *) ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    return Status;

}




NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    )

/*++

Routine Description:

    This allocates and fills in the clients network profile.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  This routine is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the caller subsequently
        encounters an error which prevents a successful logon, then
        then it will take care of deallocating the buffer.  This
        buffer is allocated with the AllocateClientBuffer() service.

     ProfileBufferSize - Receives the Size (in bytes) of the
        returned profile buffer.

    NlpUser - Contains the validation information which is
        to be copied in the ProfileBuffer.  Will be NULL to indicate a
        NULL session.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status;
    NTSTATUS SubAuthStatus = STATUS_SUCCESS;

    CLIENT_BUFFER_DESC ClientBufferDesc;
    PMSV1_0_LM20_LOGON_PROFILE LocalProfile;

#if _WIN64

    if( ClientRequest != (PLSA_CLIENT_REQUEST)( -1 ) )
    {
        SECPKG_CALL_INFO  CallInfo;

        //
        // if the call originated outproc, need to check if wow64.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            return MsvAllocateNetworkWOWProfile (
                                    ClientRequest,
                                    ProfileBuffer,
                                    ProfileBufferSize,
                                    NlpUser,
                                    ParameterControl
                                    );
        }
    }
#endif  // _WIN64


    //
    // Alocate the profile buffer to return to the client
    //

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );

    *ProfileBuffer = NULL;
    *ProfileBufferSize = sizeof(MSV1_0_LM20_LOGON_PROFILE);

    if ( NlpUser != NULL ) {
        *ProfileBufferSize += NlpUser->LogonDomainName.Length + sizeof(WCHAR) +
                              NlpUser->LogonServer.Length + sizeof(WCHAR) +
                              NlpUser->HomeDirectoryDrive.Length + sizeof(WCHAR);
    }


    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_LM20_LOGON_PROFILE),
                                      *ProfileBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    LocalProfile = (PMSV1_0_LM20_LOGON_PROFILE) ClientBufferDesc.MsvBuffer;
    LocalProfile->MessageType = MsV1_0Lm20LogonProfile;


    //
    // For a NULL session, return a constant profile buffer
    //

    if ( NlpUser == NULL ) {

        LocalProfile->KickOffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->KickOffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->LogoffTime.HighPart = 0x7FFFFFFF;
        LocalProfile->LogoffTime.LowPart = 0xFFFFFFFF;
        LocalProfile->UserFlags = 0;
        RtlZeroMemory( LocalProfile->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey));
        RtlZeroMemory( LocalProfile->LanmanSessionKey,
                       sizeof(LocalProfile->LanmanSessionKey));
        RtlInitUnicodeString( &LocalProfile->LogonDomainName, NULL );
        RtlInitUnicodeString( &LocalProfile->LogonServer, NULL );
        RtlInitUnicodeString( &LocalProfile->UserParameters, NULL );


    //
    // For non-null sessions,
    //  fill in the profile buffer.
    //

    } else {

        //
        // Copy the individual scalar fields into the profile buffer.
        //

        if ((ParameterControl & MSV1_0_RETURN_PASSWORD_EXPIRY) != 0) {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->PasswordMustChange,
                                      LocalProfile->LogoffTime);
        } else {
            OLD_TO_NEW_LARGE_INTEGER( NlpUser->LogoffTime,
                                      LocalProfile->LogoffTime);
        }
        OLD_TO_NEW_LARGE_INTEGER( NlpUser->KickOffTime,
                                  LocalProfile->KickOffTime);
        LocalProfile->UserFlags = NlpUser->UserFlags;

        RtlCopyMemory( LocalProfile->UserSessionKey,
                       &NlpUser->UserSessionKey,
                       sizeof(LocalProfile->UserSessionKey) );

        ASSERT( SAMINFO_LM_SESSION_KEY_SIZE ==
                sizeof(LocalProfile->LanmanSessionKey) );
        RtlCopyMemory(
            LocalProfile->LanmanSessionKey,
            &NlpUser->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
            SAMINFO_LM_SESSION_KEY_SIZE );


        // We need to extract the true status sent back for subauth users,
        // but not by a sub auth package

        SubAuthStatus = NlpUser->ExpansionRoom[SAMINFO_SUBAUTH_STATUS];

        //
        // Copy the Unicode strings into the profile buffer.
        //

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->LogonDomainName,
                            &NlpUser->LogonDomainName );

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->LogonServer,
                            &NlpUser->LogonServer );

        //
        // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
        // can't change the NETLOGON_VALIDATION_SAM_INFO structure between
        // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
        // so we'll use that field.
        //

        NlpPutClientString( &ClientBufferDesc,
                            &LocalProfile->UserParameters,
                            &NlpUser->HomeDirectoryDrive );

    }

    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProfileBuffer );

Cleanup:

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    // Save the status for subauth logons

    if (NT_SUCCESS(Status) && !NT_SUCCESS(SubAuthStatus))
    {
        Status = SubAuthStatus;
    }

    return Status;

}


PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

/*++

Routine Description:

    Given a domain Id and a relative ID create the corresponding SID allocated
    from the LSA heap.

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = (*Lsa.AllocateLsaHeap)( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        (*Lsa.FreeLsaHeap)( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}



PSID
NlpCopySid(
    IN  PSID * Sid
    )

/*++

Routine Description:

    Given a SID allocatees space for a new SID from the LSA heap and copies
    the original SID.

Arguments:

    Sid - The original SID.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    PSID NewSid;
    ULONG Size;

    Size = RtlLengthSid( Sid );



    if ((NewSid = (*Lsa.AllocateLsaHeap)( Size )) == NULL ) {
        return NULL;
    }


    if ( !NT_SUCCESS( RtlCopySid( Size, NewSid, Sid ) ) ) {
        (*Lsa.FreeLsaHeap)( NewSid );
        return NULL;
    }


    return NewSid;
}

//+-------------------------------------------------------------------------
//
//  Function:   NlpMakeTokenInformationV2
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V2 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen back from from kerberos\client2\krbtoken.cxx.c:KerbMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------


NTSTATUS
NlpMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    )
{
    PNETLOGON_VALIDATION_SAM_INFO3 UserInfo = (PNETLOGON_VALIDATION_SAM_INFO3) ValidationInfo;
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V2 V2 = NULL;
    ULONG Size, i;
    DWORD NumGroups = 0;
    PBYTE CurrentSid = NULL;
    ULONG SidLength = 0;

    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V2);

    //
    // Allocate an array to hold the groups
    //

    Size += sizeof(TOKEN_GROUPS);


    // Add room for groups passed as RIDS
    NumGroups = UserInfo->GroupCount;
    if(UserInfo->GroupCount)
    {
        Size += UserInfo->GroupCount * (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        ULONG i = 0;
        NumGroups += UserInfo->SidCount;

        // Add room for the sid's themselves
        for(i=0; i < UserInfo->SidCount; i++)
        {
            Size += RtlLengthSid(UserInfo->ExtraSids[i].Sid);
        }
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {

        NumGroups += UserInfo->ResourceGroupCount;

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        // Allocate space for the sids
        if(UserInfo->ResourceGroupCount)
        {
            Size += UserInfo->ResourceGroupCount * (RtlLengthSid(UserInfo->ResourceGroupDomainSid) + sizeof(ULONG));
        }

    }


    if( UserInfo->UserId )
    {
        // Size of the user sid and the primary group sid.
        Size += 2*(RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }
    else
    {
        if ( UserInfo->SidCount <= 0 ) {

            Status = STATUS_INSUFFICIENT_LOGON_INFO;
            goto Cleanup;
        }

        // Size of the primary group sid.
        Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }


    Size += (NumGroups - ANYSIZE_ARRAY)*sizeof(SID_AND_ATTRIBUTES);


    V2 = (PLSA_TOKEN_INFORMATION_V2) (*Lsa.AllocateLsaHeap)( Size );
    if ( V2 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        V2,
        Size
        );

    V2->Groups = (PTOKEN_GROUPS)(V2+1);
    V2->Groups->GroupCount = 0;
    CurrentSid = (PBYTE)&V2->Groups->Groups[NumGroups];

    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V2->ExpirationTime );



    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        V2->User.User.Sid = (PSID)CurrentSid;
        CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);
    }

    //
    // Make a copy of the primary group (a required field).
    //
    V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
    CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->PrimaryGroupId );




    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
        CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->GroupIds[i].RelativeId);

        V2->Groups->GroupCount++;
    }


    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;
        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V2->User.User.Sid ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;
            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;

            V2->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            CurrentSid += NlpCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->ResourceGroupDomainSid, UserInfo->ResourceGroupIds[i].RelativeId);

            V2->Groups->GroupCount++;
        }
    }

    ASSERT( ((PBYTE)V2 + Size) == CurrentSid );


    if (!V2->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V2->Privileges = NULL;
    V2->Owner.Owner = NULL;
    V2->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V2;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    (*Lsa.FreeLsaHeap)( V2 );

    return Status;

}



VOID
NlpPutOwfsInPrimaryCredential(
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL Credential
    )
/*++

Routine Description:

    This routine puts the OWFs for the specified clear password into
    the passed in Credential structure.

Arguments:

    CleartextPassword - Is a string containing the user's cleartext password.
        The password may be up to 255 characters long and contain any
        UNICODE value.

    Credential - A pointer to the credential to update.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;


    //
    // Compute the Ansi version to the Cleartext password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    Credential->LmPasswordPresent = FALSE;

    if( CleartextPassword->Length <= (LM20_PWLEN*sizeof(WCHAR)) )
    {
        CHAR LmPassword[LM20_PWLEN+1];
        STRING AnsiCleartextPassword;

        AnsiCleartextPassword.Buffer = LmPassword;
        AnsiCleartextPassword.Length = sizeof(LmPassword);
        AnsiCleartextPassword.MaximumLength = AnsiCleartextPassword.Length;

        Status = RtlUpcaseUnicodeStringToOemString(
                                      &AnsiCleartextPassword,
                                      CleartextPassword,
                                      (BOOLEAN) FALSE );

        if( NT_SUCCESS( Status ) )
        {
            //
            // Save the OWF encrypted versions of the passwords.
            //

            Status = RtlCalculateLmOwfPassword( LmPassword,
                                                &Credential->LmOwfPassword );

            ASSERT( NT_SUCCESS(Status) );

            Credential->LmPasswordPresent = TRUE;
        }

        //
        // Don't leave passwords around in the pagefile
        //

        RtlZeroMemory( LmPassword, sizeof(LmPassword) );
    }





    Status = RtlCalculateNtOwfPassword( CleartextPassword,
                                        &Credential->NtOwfPassword );

    ASSERT( NT_SUCCESS(Status) );

    Credential->NtPasswordPresent = TRUE;


    Status = RtlCalculateShaOwfPassword( CleartextPassword,
                                         &Credential->ShaOwfPassword );

    ASSERT( NT_SUCCESS(Status) );

    Credential->ShaPasswordPresent = TRUE;


    return;
}



NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    )


/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    CleartextPassword - Is a string containing the user's cleartext password.
        The password may be up to 255 characters long and contain any
        UNICODE value.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    NTSTATUS Status;
    PUCHAR Where;
    ULONG PaddingLength;


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    //
    // add padding for memory encryption interface.
    //

    PaddingLength = DESX_BLOCKLEN - (*CredentialSize % DESX_BLOCKLEN);
    if( PaddingLength == DESX_BLOCKLEN )
    {
        PaddingLength = 0;
    }

    *CredentialSize += PaddingLength;


    Credential = (*Lsa.AllocateLsaHeap)( *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }


    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );


    //
    // Put the OWF passwords into the newly allocated credential.
    //

    NlpPutOwfsInPrimaryCredential( CleartextPassword, Credential );


    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}


NTSTATUS
NlpMakePrimaryCredentialFromMsvCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN  PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredential,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    )


/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    SupplementalCred - The credentials retrieved from the user's account on
        the domain controller.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    NTSTATUS Status;
    PUCHAR Where;
    ULONG PaddingLength;


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    //
    // add padding for memory encryption interface.
    //

    PaddingLength = DESX_BLOCKLEN - (*CredentialSize % DESX_BLOCKLEN);
    if( PaddingLength == DESX_BLOCKLEN )
    {
        PaddingLength = 0;
    }

    *CredentialSize += PaddingLength;


    Credential = (*Lsa.AllocateLsaHeap)( *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }

    RtlZeroMemory(
        Credential,
        *CredentialSize
        );

    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );



    //
    // Save the OWF encrypted versions of the passwords.
    //

    if (MsvCredential->Flags & MSV1_0_CRED_NT_PRESENT) {
        RtlCopyMemory(
            &Credential->NtOwfPassword,
            MsvCredential->NtPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->NtPasswordPresent = TRUE;
    } else {
#if 0
        RtlCopyMemory(
            &Credential->NtOwfPassword,
            &NlpNullNtOwfPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->NtPasswordPresent = TRUE;
#endif
        Credential->NtPasswordPresent = FALSE;
    }


    if (MsvCredential->Flags & MSV1_0_CRED_LM_PRESENT) {
        RtlCopyMemory(
            &Credential->LmOwfPassword,
            MsvCredential->LmPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->LmPasswordPresent = TRUE;
    } else {
#if 0
        RtlCopyMemory(
            &Credential->LmOwfPassword,
            &NlpNullLmOwfPassword,
            MSV1_0_OWF_PASSWORD_LENGTH
            );
        Credential->LmPasswordPresent = TRUE;
#endif
        Credential->LmPasswordPresent = FALSE;

    }


    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}


NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    )


/*++

Routine Description:

    This routine sets a primary credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to set the Credentials
        for.

    Credential - Specifies a pointer to the credential.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    STRING CredentialString;
    STRING PrimaryKeyValue;

    //
    // Make all pointers in the credential relative.
    //

    NlpMakeRelativeString( (PUCHAR)Credential, &Credential->UserName );
    NlpMakeRelativeString( (PUCHAR)Credential, &Credential->LogonDomainName );

    //
    // Add the credential to the logon session.
    //

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );
    CredentialString.Buffer = (PCHAR) Credential;
    CredentialString.Length = (USHORT) CredentialSize;
    CredentialString.MaximumLength = CredentialString.Length;

    //
    // encrypt input credential.
    //

    (*Lsa.LsaProtectMemory)( CredentialString.Buffer, (ULONG)CredentialString.Length );

    Status = (*Lsa.AddCredential)(
                    LogonId,
                    MspAuthenticationPackageId,
                    &PrimaryKeyValue,
                    &CredentialString );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrint(( "NlpAddPrimaryCredential: error from AddCredential %lX\n",
                  Status));
    }

    return Status;
}

NTSTATUS
NlpGetPrimaryCredentialByUserDomain(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    )
{
    PACTIVE_LOGON Logon;
    LUID LogonId;
    BOOLEAN Match = FALSE;

    //
    // Loop through the table looking for this particular LogonId.
    //

    NlpLockActiveLogonsRead();

    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next ) {

        if(RtlEqualUnicodeString( UserName, &Logon->UserName, (BOOLEAN) TRUE) &&
           RtlEqualDomainName(LogonDomainName,&Logon->LogonDomainName ))
        {
            Match = TRUE;
            CopyMemory( &LogonId, &Logon->LogonId, sizeof(LogonId) );
            break;
        }

    }

    NlpUnlockActiveLogons();

    if( !Match )
        return STATUS_NO_SUCH_LOGON_SESSION;


    return NlpGetPrimaryCredential( &LogonId, CredentialBuffer, CredentialSize );

}


NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    )


/*++

Routine Description:

    This routine gets a primary credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to retrieve the Credentials
        for.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - Optionally returns the size of the credential buffer.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    ULONG QueryContext = 0;
    ULONG PrimaryKeyLength;
    STRING PrimaryKeyValue;
    STRING CredentialString;
    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );

    Status = (*Lsa.GetCredentials)( LogonId,
                                    MspAuthenticationPackageId,
                                    &QueryContext,
                                    (BOOLEAN) FALSE,  // Just retrieve primary
                                    &PrimaryKeyValue,
                                    &PrimaryKeyLength,
                                    &CredentialString );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Make all pointers in the credential absolute.
    //

    Credential = (PMSV1_0_PRIMARY_CREDENTIAL) CredentialString.Buffer;

    //
    // decrypt credential.
    //

    (*Lsa.LsaUnprotectMemory)( CredentialString.Buffer, (ULONG)CredentialString.Length );


    NlpRelativeToAbsolute( Credential,
                   (PULONG_PTR)&Credential->UserName.Buffer );
    NlpRelativeToAbsolute( Credential,
                   (PULONG_PTR)&Credential->LogonDomainName.Buffer );


    *CredentialBuffer = Credential;
    if ( CredentialSize != NULL ) {
        *CredentialSize = CredentialString.Length;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    )


/*++

Routine Description:

    This routine deletes the credential for the given LogonId.

Arguments:

    LogonId - The LogonId of the LogonSession to delete the Credentials for.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status;
    STRING PrimaryKeyValue;

    RtlInitString( &PrimaryKeyValue, MSV1_0_PRIMARY_KEY );

    Status = (*Lsa.DeleteCredential)( LogonId,
                                    MspAuthenticationPackageId,
                                    &PrimaryKeyValue );

    return Status;

}


NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    )

/*++

Routine Description:

    Change the password for the specified user in all currently stored
    credentials.

Arguments:

    DomainName - The Netbios name of the domain in which the account exists.

    UserName - The name of the account whose password is to be changed.

    Password - The new password.

Return Value:

    STATUS_SUCCESS - If the operation was successful.

--*/
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PACTIVE_LOGON Logon;

    MSV1_0_PRIMARY_CREDENTIAL TempCredential;

    LUID FastLogonIds[ 32 ];
    PLUID SlowLogonIds = NULL;
    ULONG AllocatedLogonIds;

    PLUID LogonIds;
    ULONG cLogonIds;
    UNICODE_STRING NetBiosLogonDomainName = {0};
    UNICODE_STRING DnsDomainName = {0};
    UNICODE_STRING* pNetBiosLogonDomainName = NULL;
    cLogonIds = 0;
    LogonIds = FastLogonIds;
    AllocatedLogonIds = sizeof(FastLogonIds) / sizeof(LUID);

    //
    // Compute the OWFs of the password.
    //

    NlpPutOwfsInPrimaryCredential( Password, &TempCredential );

    Status = LsaIGetNbAndDnsDomainNames(DomainName, &DnsDomainName, &NetBiosLogonDomainName);

    if (NT_SUCCESS(Status) && NetBiosLogonDomainName.Length != 0)
    {
        pNetBiosLogonDomainName = &NetBiosLogonDomainName;
    }
    else
    {
        pNetBiosLogonDomainName = DomainName;
    }

    //
    // Loop through the table looking for this particular UserName/DomainName.
    //

    NlpLockActiveLogonsRead();

    for (Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next ) {

        if (!RtlEqualUnicodeString( UserName, &Logon->UserName, (BOOLEAN) TRUE ))
        {
            continue;
        }

        if (!RtlEqualDomainName( pNetBiosLogonDomainName, &Logon->LogonDomainName ))
        {
            continue;
        }

        SspPrint((SSP_UPDATES, "NlpChangePassword matched LogonId=%lx.%lx\n",
                    Logon->LogonId.LowPart, Logon->LogonId.HighPart ));

        //
        // if we don't have space to store the new entry, allocate a new
        // buffer, copy the existing buffer, and keep going.
        //

        if( AllocatedLogonIds < (cLogonIds+1))
        {
            PLUID OldLogonIds = SlowLogonIds;

            AllocatedLogonIds *= 2;

            SlowLogonIds = I_NtLmAllocate( AllocatedLogonIds * sizeof(LUID) );
            if( SlowLogonIds == NULL )
            {
                break;
            }

            CopyMemory( SlowLogonIds, LogonIds, cLogonIds*sizeof(LUID) );

            LogonIds = SlowLogonIds;

            if( OldLogonIds != NULL )
            {
                I_NtLmFree( OldLogonIds );
            }
        }

        LogonIds[ cLogonIds ] = Logon->LogonId;

        cLogonIds++;
    }

    NlpUnlockActiveLogons();

    //
    // Pass the change back to the LSA. Note - this only changes it for the
    // last element in the list.
    //

    if (cLogonIds != 0)
    {
        SECPKG_PRIMARY_CRED PrimaryCredentials;
        ULONG Index;

        RtlZeroMemory(
            &PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );

        PrimaryCredentials.Password = *Password;
        PrimaryCredentials.Flags = PRIMARY_CRED_UPDATE | PRIMARY_CRED_CLEAR_PASSWORD;

        //
        // update each instance of the credential that matches.
        // Multiple logon session can legally reference the same creds,
        // eg: Terminal Services, RunAs, etc.
        //

        for ( Index = 0 ; Index < cLogonIds ; Index++ )
        {
            PrimaryCredentials.LogonId = LogonIds[ Index ];

            (VOID) LsaFunctions->UpdateCredentials(
                                &PrimaryCredentials,
                                NULL            // no supplemental credentials
                                );
        }

        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NOT_FOUND;
    }

    //
    // Pass the new password on to the logon cache
    //

    NlpChangeCachePassword(
                DomainName,
                UserName,
                &TempCredential.LmOwfPassword,
                &TempCredential.NtOwfPassword
                );

    ZeroMemory( &TempCredential, sizeof(TempCredential) );

    if ( SlowLogonIds )
    {
        I_NtLmFree( SlowLogonIds );
    }

    if (NetBiosLogonDomainName.MaximumLength && NetBiosLogonDomainName.Buffer)
    {
        LsaIFreeHeap(NetBiosLogonDomainName.Buffer);
    }

    if (DnsDomainName.MaximumLength && DnsDomainName.Buffer)
    {
        LsaIFreeHeap(DnsDomainName.Buffer);
    }

    return Status;
}


NTSTATUS
NlpChangePasswordByLogonId(
    IN PLUID LogonId,
    IN PUNICODE_STRING Password
    )

/*++

Routine Description:

    Change the password for the specified user in all currently stored
    credentials.

Arguments:

    LogonId - Logon ID of user whose password changed.

    Password - New password.

Return Value:

    STATUS_SUCCESS - If the operation was successful.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PACTIVE_LOGON Logon;
    ULONG LogonCount = 0;
    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;

    MSV1_0_PRIMARY_CREDENTIAL TempCredential;

    //
    // Compute the OWFs of the password.
    //

    NlpPutOwfsInPrimaryCredential( Password, &TempCredential );

    //
    // Loop through the table looking for this particular UserName/DomainName.
    //

    // conservative: take the full write lock up front.
    NlpLockActiveLogonsWrite();

    for( Logon = NlpActiveLogons; Logon != NULL; Logon = Logon->Next )
    {

        if(!RtlEqualLuid( LogonId, &Logon->LogonId) )
        {
            continue;
        }

        SspPrint((SSP_UPDATES, "NlpChangePasswordByLogonId LogonId=%lx.%lx\n",
                    LogonId->LowPart, LogonId->HighPart ));


        //
        // Get the current credential for this logonid.
        //

        Status = NlpGetPrimaryCredential( &Logon->LogonId,
                                          &Credential,
                                          &CredentialSize );

        if ( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // Delete it from the LSA.
        //

        Status = NlpDeletePrimaryCredential( &Logon->LogonId );

        if ( !NT_SUCCESS(Status) ) {
            (*Lsa.FreeLsaHeap)( Credential );
            break;
        }


        //
        // Change the passwords in it
        //

        Credential->LmOwfPassword = TempCredential.LmOwfPassword;
        Credential->NtOwfPassword = TempCredential.NtOwfPassword;
        Credential->ShaOwfPassword = TempCredential.ShaOwfPassword;
        Credential->LmPasswordPresent = TempCredential.LmPasswordPresent;
        Credential->NtPasswordPresent = TempCredential.NtPasswordPresent;
        Credential->ShaPasswordPresent = TempCredential.ShaPasswordPresent;

        //
        // Add it back to the LSA.
        //

        Status = NlpAddPrimaryCredential( &Logon->LogonId,
                                          Credential,
                                          CredentialSize );

        (*Lsa.FreeLsaHeap)( Credential );

        if ( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // Pass the new password on to the logon cache
        //

        NlpChangeCachePassword(
                    &Logon->LogonDomainName,
                    &Logon->UserName,
                    &TempCredential.LmOwfPassword,
                    &TempCredential.NtOwfPassword );

        break;
    }

    NlpUnlockActiveLogons();

    ZeroMemory( &TempCredential, sizeof(TempCredential) );

    return Status;
}


VOID
NlpGetAccountNames(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING NetbiosDomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING Upn
    )

/*++

Routine Description:

    Get the sundry account names from the LogonInfo and NlpUser

Arguments:

    LogonInfo   - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
                  the domain name, user name and password for this user. These
                  are what the user typed to WinLogon

    NlpUser - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure which
                  contains this user's specific interactive logon information

    SamAccountName - Returns the SamAccountName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.

    NetbiosDomainName - Returns the NetbiosDomainName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.

    DnsDomainName - Returns the DnsDomainName of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.
        The returned length will be zero if DnsDomainName is not known.

    UPN - Returns the UPN of the logged on user.
        The returned buffer is within the LogonInfo or NlpUser.
        The returned length will be zero if UPN is not known.

Return Value:

    None.

--*/
{

    //
    // Return the SamAccountName and Netbios Domain Name
    //
    *SamAccountName = NlpUser->EffectiveName;
    *NetbiosDomainName = NlpUser->LogonDomainName;

    //
    // Return the DNS domain name.
    //

    *DnsDomainName = NlpUser->DnsLogonDomainName;

    //
    // Determine the UPN of the account
    //
    // If the UPN was returned from the DC,
    //  use it.
    // else
    //  use the UPN the caller passed in
    //
    // The caller passed in a UPN if all of the following are true:
    //  There is no domain name.
    //  The passed in user name isn't the one returned from the DC.
    //  The passed in user name has an @ in it.
    //
    //

    *Upn = NlpUser->Upn;

    if ( Upn->Length == 0 ) {

        if ( LogonInfo->LogonDomainName.Length == 0 &&
             !RtlEqualUnicodeString( &LogonInfo->UserName, &NlpUser->EffectiveName, (BOOLEAN) TRUE ) ) {

             ULONG i;

             for ( i=0; i<LogonInfo->UserName.Length/sizeof(WCHAR); i++) {

                 if ( LogonInfo->UserName.Buffer[i] == L'@') {
                     *Upn = LogonInfo->UserName;
                     break;
                 }
             }

        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   NlpCopyDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID at the location indicated by TargetSid
//
//  Effects:
//
//  Arguments:  TargetSid - target memory location
//              DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Size - Size of the sid copied
//
//  Notes:
//
//
//--------------------------------------------------------------------------

DWORD
NlpCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, TargetSid, DomainId ) ) ) {
        return 0;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( TargetSid ))) ++;
    *RtlSubAuthoritySid( TargetSid, DomainIdSubAuthorityCount ) = RelativeId;


    return Size;
}


//
// temporary home for this function.
//


NTSTATUS
RtlCalculateShaOwfPassword(
    IN PSHA_PASSWORD ShaPassword,
    OUT PSHA_OWF_PASSWORD ShaOwfPassword
    )

/*++

Routine Description:

    Takes the passed ShaPassword and performs a one-way-function on it.
    Uses the FIPS approved SHA-1 function

Arguments:

    ShaPassword - The password to perform the one-way-function on.

    ShaOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in ShaOwfPassword.
--*/

{
    A_SHA_CTX   SHA_Context;

    A_SHAInit(&SHA_Context);
    A_SHAUpdate(&SHA_Context, (PCHAR)ShaPassword->Buffer, ShaPassword->Length);
    A_SHAFinal(&SHA_Context, (PCHAR)ShaOwfPassword);


    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nlp.h

Abstract:

    NETLOGON private definitions.




Author:

    Jim Kelly 11-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.h

--*/

#ifndef _NLP_
#define _NLP_

#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <logonmsv.h>
#include <samrpc.h>
#include <align.h>
#include <dsgetdc.h>
#include <ntdsapi.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// nlmain.c will #include this file with NLP_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NLP_ALLOCATE
#define EXTERN
#define INIT(_X) = _X
#else
#define EXTERN extern
#define INIT(_X)
#endif

//
// Amount of time to wait for netlogon to start.
//  Do this AFTER waiting for SAM to start.
//  Since Netlogon depends on SAM, don't timeout too soon.
#define NETLOGON_STARTUP_TIME   45          // 45 seconds

//
// Amount of time to wait for SAM to start.
//  DS recovery can take a very long time.
#define SAM_STARTUP_TIME        (20*60)     // 20 minutes

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data structures                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Structure used to keep track of all private information related to a
//  particular LogonId.
//

typedef struct _PACTIVE_LOGON {

    LUID LogonId;               // The logon Id of this logon session

    ULONG EnumHandle;           // The enumeration handle of this logon session

    SECURITY_LOGON_TYPE LogonType;  // Type of logon (interactive or service)

    PSID UserSid;               // Sid of the logged on user

    UNICODE_STRING UserName;    // SAM Account name of the logged on user (Required)

    UNICODE_STRING LogonDomainName; // Netbios name of the domain logged onto (Required)

    UNICODE_STRING LogonServer; // Name of the server which logged this user on

    ULONG Flags;                    // Attributes of this entry.

#define LOGON_BY_NETLOGON   0x01    // Entry was validated by NETLOGON service
#define LOGON_BY_CACHE      0x02    // Entry was validated by local cache
#define LOGON_BY_OTHER_PACKAGE 0x04 // Entry was validated by another authentication package
#define LOGON_BY_LOCAL 0x08         // Entry was validated by local sam
#define LOGON_BY_NTLM3_DC   0x10    // Entry was validated by DC that understands NTLM3

    struct _PACTIVE_LOGON * Next;   // Next entry in linked list.

} ACTIVE_LOGON, *PACTIVE_LOGON;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CREDENTIAL Related Data Structures                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//   Following is a description of the content and format of each type
//   of credential maintained by the MsV1_0 authentication package.
//
//   The MsV1_0 authentication package defines the following credential
//   primary key string values:
//
//       "Primary" - Is used to hold the primary credentials provided at
//           initial logon time.  This includes the username and both
//           case-sensitive and case-insensitive forms of the user's
//           password.
//
//   NOTE: All poitners stored in credentials must be
//   changed to be an offset to the body rather than a pointer.  This is
//   because credential fields are copied by the LSA and so the pointer
//   would become invalid.
//


//
// MsV1_0 Primary Credentials
//
//
//        The PrimaryKeyValue string of this type of credential contains the
//        following string:
//
//                  "Primary"
//
//        The Credential string of a Primary credential contains the following
//        values:
//
//             o  The user's username
//
//             o  A one-way function of the user's password as typed.
//
//             o  A one-way function of the user's password upper-cased.
//
//        These values are structured as follows:
//

#define MSV1_0_PRIMARY_KEY "Primary"

//
// move the SHA stuff to crypt.h when possible.
//

typedef UNICODE_STRING              SHA_PASSWORD;
typedef SHA_PASSWORD *              PSHA_PASSWORD;

#define SHA_OWF_PASSWORD_LENGTH     (20)

typedef struct {
    CHAR Data[ SHA_OWF_PASSWORD_LENGTH ];
} SHA_OWF_PASSWORD, *PSHA_OWF_PASSWORD;

NTSTATUS
RtlCalculateShaOwfPassword(
    IN PSHA_PASSWORD ShaPassword,
    OUT PSHA_OWF_PASSWORD ShaOwfPassword
    );


typedef struct _MSV1_0_PRIMARY_CREDENTIAL {
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    NT_OWF_PASSWORD NtOwfPassword;
    LM_OWF_PASSWORD LmOwfPassword;
    SHA_OWF_PASSWORD ShaOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN ShaPasswordPresent;
} MSV1_0_PRIMARY_CREDENTIAL, *PMSV1_0_PRIMARY_CREDENTIAL;



//
// Structure describing a buffer in the clients address space.
//

typedef struct _CLIENT_BUFFER_DESC {
    PLSA_CLIENT_REQUEST ClientRequest;
    LPBYTE UserBuffer;      // Address of buffer in client's address space
    LPBYTE MsvBuffer;       // Address of mirror buffer in MSV's address space
    ULONG StringOffset;     // Current offset to variable length data
    ULONG TotalSize;        // Size (in bytes) of buffer
} CLIENT_BUFFER_DESC, *PCLIENT_BUFFER_DESC;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal routine definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// From nlmain.c.
//

NTSTATUS
NlSamInitialize(
    ULONG Timeout
    );

//
// From nlp.c.
//

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    );

VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    );

NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    );

VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    );

VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    );

VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG_PTR RelativeValue
    );

BOOLEAN
NlpFindActiveLogon(
    IN PLUID LogonId,
    OUT PACTIVE_LOGON **ActiveLogon
    );

ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING UserName
    );

NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser
    );

NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    IN  ULONG ParameterControl
    );

PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

NTSTATUS
NlpMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    );

VOID
NlpPutOwfsInPrimaryCredential(
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL Credential
    );

NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpMakePrimaryCredentialFromMsvCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN  PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredential,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredentialByUserDomain(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize OPTIONAL
    );

NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    );

NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    );

NTSTATUS
NlpChangePasswordByLogonId(
    IN PLUID LogonId,
    IN PUNICODE_STRING Password
    );

VOID
NlpGetAccountNames(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 NlpUser,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING NetbiosDomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING Upn
    );


//
// msvsam.c
//

BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
);




//
// nlnetapi.c
//

VOID
NlpLoadNetapiDll (
    VOID
    );

VOID
NlpLoadNetlogonDll (
    VOID
    );

//
// subauth.c
//

VOID
Msv1_0SubAuthenticationInitialization(
    VOID
);


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//
//

EXTERN LM_OWF_PASSWORD NlpNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD NlpNullNtOwfPassword;

//
// Flag indicating our support for the LM challenge response protocol.
// If the flag is set to NoLm, MSV1_0 will not ever compute a LM
// challenge response. If it is set to AllowLm, MSV1_0 will not return
// it unless requested. Otherwise it will do the normal behaviour of
// returning both NT and LM challenge responses
//

typedef enum _LM_PROTOCOL_SUPPORT {
    UseLm,              // send LM response, NTLM response
    AllowLm,            // same as UseLm; for b/w compat w/lsa2-fix
    NoLm, //UseNtlm,            // Send NTLM response only; for b/w compat w/lsa2-fix
    UseNtlm3,           // Send NTLM3 response even if no target domain\server specified
    RefuseLm,           // Refuse LM responses (no Win9x clients) -- unsupported, reserved
    RefuseNtlm,         // Refuse LM and NTLM responses (require all clients are upgraded)
    RefuseNtlm3NoTarget // Refuse NTLM3 response witout domain and server info
} LM_PROTOCOL_SUPPORT, *PLM_PROTOCOL_SUPPORT;

#if 0

//
// This macro determines whether or not to return an LM challenge response.
// If NlpProtocolSupport == UseLm, we always return it. If it is
// AllowLm, only return it if the RETURN_LM_RESPONSE flag is set. Otherwise
// don't return it ever.
//

#define NlpReturnLmResponse(_Flags_) \
    ((NlpLmProtocolSupport == UseLm) || \
     ((NlpLmProtocolSupport == AllowLm) && \
      (((_Flags_) & RETURN_NON_NT_USER_SESSION_KEY) != 0)))

#define NlpChallengeResponseRequestSupported( _Flags_ ) \
 ((((_Flags_) & RETURN_NON_NT_USER_SESSION_KEY) == 0) || (NlpLmProtocolSupport != NoLm))

#endif


NET_API_STATUS NET_API_FUNCTION RxNetUserPasswordSet(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
NTSTATUS NetpApiStatusToNtStatus( NET_API_STATUS );

//
// Routines in netlogon.dll
//

EXTERN HANDLE NlpNetlogonDllHandle;
EXTERN PNETLOGON_SAM_LOGON_PROCEDURE NlpNetLogonSamLogon;
EXTERN PNETLOGON_SAM_LOGOFF_PROCEDURE NlpNetLogonSamLogoff;

typedef NTSTATUS
(*PNETLOGON_MIXED_DOMAIN_PROCEDURE)(
    OUT PBOOL MixedMode
    );

EXTERN PNETLOGON_MIXED_DOMAIN_PROCEDURE NlpNetLogonMixedDomain;

//
// TRUE if package is initialized
//

EXTERN BOOLEAN NlpMsvInitialized INIT(FALSE);

//
// TRUE if this is a workstation.
//

EXTERN BOOLEAN NlpWorkstation INIT(TRUE);

//
// TRUE once the MSV AP has initialized its connection to SAM.
//

EXTERN BOOLEAN NlpSamInitialized INIT(FALSE);

//
// TRUE if the MSV AP has initialized its connection to the NETLOGON service
//

EXTERN BOOLEAN NlpNetlogonInitialized INIT(FALSE);

//
// TRUE if LanMan is installed.
//

EXTERN BOOLEAN NlpLanmanInstalled INIT(FALSE);

//
// Computername of this computer.
//

EXTERN UNICODE_STRING NlpComputerName;

//
// Domain of which I am a member.
//

EXTERN UNICODE_STRING NlpPrimaryDomainName;

//
// Name of the MSV1_0 package
//

EXTERN UNICODE_STRING NlpMsv1_0PackageName;


//
// Name and domain id of the SAM account database.
//

EXTERN UNICODE_STRING NlpSamDomainName;
EXTERN PSID NlpSamDomainId;
EXTERN SAMPR_HANDLE NlpSamDomainHandle;
EXTERN BOOLEAN NlpUasCompatibilityRequired INIT(TRUE);


//
// TRUE if there is a subauthentication package zero
//

EXTERN BOOLEAN NlpSubAuthZeroExists INIT(TRUE);


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//


#define NlpLockActiveLogonsRead()           RtlAcquireResourceShared(&NlpActiveLogonLock,TRUE)
#define NlpLockActiveLogonsWrite()          RtlAcquireResourceExclusive(&NlpActiveLogonLock,TRUE)
#define NlpLockActiveLogonsReadToWrite()    RtlConvertSharedToExclusive(&NlpActiveLogonLock)
#define NlpUnlockActiveLogons()             RtlReleaseResource(&NlpActiveLogonLock)

EXTERN RTL_RESOURCE NlpActiveLogonLock;
EXTERN PACTIVE_LOGON NlpActiveLogons;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  the interlocked primitives.

EXTERN ULONG NlpEnumerationHandle;

EXTERN ULONG NlpLogonAttemptCount;


NTSTATUS
NlWaitForNetlogon(
    IN ULONG Timeout
    );

#undef EXTERN
#undef INIT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif _NLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlvars.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nlvars.c

Abstract:

   This module contains variables used within the msv1_0 authentication
   package.

Author:

    Cliff Van Dyke (CliffV) 29-Apr-1991

Environment:

    User mode - msv1_0 authentication package DLL

Revision History:
  Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlvars.c

--*/

#include "msp.h"
#include "nlp.h"



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//

LM_OWF_PASSWORD NlpNullLmOwfPassword;
NT_OWF_PASSWORD NlpNullNtOwfPassword;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//

RTL_CRITICAL_SECTION NlpActiveLogonLock;
PACTIVE_LOGON NlpActiveLogons;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  NlpActiveLogonLocks.

ULONG NlpEnumerationHandle;


//
// Define the number of successful/unsuccessful logons attempts.
//

ULONG NlpLogonAttemptCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlpcache.h ===
/*++

Copyright (c) 1991 - 1999  Microsoft Corporation

Module Name:

    nlpcache.h

Abstract:

    Structures and prototypes for nlpcache.c

Author:

    Richard L Firth (rfirth) 17-Mar-1992

Revision History:
  Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlpcache.h

--*/

#define CACHE_NAME          L"\\Registry\\Machine\\Security\\Cache"
#define CACHE_NAME_SIZE     (sizeof(CACHE_NAME) - sizeof(L""))
#define CACHE_TITLE_INDEX   100 // ?


//
// CACHE_PASSWORDS - passwords are stored (in secret storage) as two encrypted
// one way function (OWF) passwords concatenated together. They must be fixed
// length
//

typedef struct _CACHE_PASSWORDS {
    USER_INTERNAL1_INFORMATION SecretPasswords;
} CACHE_PASSWORDS, *PCACHE_PASSWORDS;

//
// LOGON_CACHE_ENTRY - this is what we store in the cache. We don't need to
// cache all the fields from the NETLOGON_VALIDATION_SAM_INFO - just the ones
// we can't easily invent.
//
// There is additional data following the end of the structure: There are
// <GroupCount> GROUP_MEMBERSHIP structures, followed by a SID which is the
// LogonDomainId. The rest of the data in the entry is the buffer areas for
// the UNICODE_STRING fields
//

typedef struct _LOGON_CACHE_ENTRY {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;

    //
    // The following fields are present in NT1.0A release and later
    // systems.
    //

    USHORT          LogonDomainIdLength; // was Unused1
    LARGE_INTEGER   Time;
    ULONG           Revision;
    ULONG           SidCount;   // was Unused2
    BOOLEAN         Valid;

    //
    // The following fields are present for NT 3.51 since build 622
    //

    CHAR            Unused[3];
    ULONG           SidLength;

    //
    // The following fields have been present (but zero) since NT 3.51.
    //  We started filling it in in NT 5.0
    //
    ULONG           LogonPackage; // The RPC ID of the package doing the logon.
    USHORT          DnsDomainNameLength;
    USHORT          UpnLength;

    //
    // The following fields were added for NT5.0 build 2053.
    //

    //
    // define a 128bit random key for this cache entry.  This is used
    // in conjunction with a per-machine LSA secret to derive an encryption
    // key used to encrypt CachePasswords & Opaque data.
    //

    CHAR            RandomKey[ 16 ];
    CHAR            MAC[ 16 ];      // encrypted data integrity check.

    //
    // store the CACHE_PASSWORDS with the cache entry, encrypted using
    // the RandomKey & per-machine LSA secret.
    // this improves performance and eliminates problems with storing data
    // in 2 locations.
    //
    // note: data from this point forward is encrypted and protected from
    // tampering via HMAC.  This includes the data marshalled beyond the
    // structure.
    //

    CACHE_PASSWORDS CachePasswords;

    //
    // Length of opaque supplemental cache data.
    //

    ULONG           SupplementalCacheDataLength;

    //
    // offset from LOGON_CACHE_ENTRY to SupplementalCacheData.
    //


    ULONG           SupplementalCacheDataOffset;


    //
    // Used for special cache properties, e.g. MIT cached logon.
    //
    ULONG           CacheFlags;

    //
    // LogonServer that satisfied the logon.
    //

    ULONG           LogonServerLength;  // was Spare2

    //
    // spare slots for future data, to potentially avoid revising the structure
    //

    
    ULONG           Spare3;
    ULONG           Spare4;
    ULONG           Spare5;
    ULONG           Spare6;


} LOGON_CACHE_ENTRY, *PLOGON_CACHE_ENTRY;


//
// pre-NT5 versions of the LOGON_CACHE_ENTRY structure, for sizing and
// field mapping purposes for backwards compatibility.
//

typedef struct _LOGON_CACHE_ENTRY_NT_4_SP4 {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;

    //
    // The following fields are present in NT1.0A release and later
    // systems.
    //

    USHORT          LogonDomainIdLength; // was Unused1
    LARGE_INTEGER   Time;
    ULONG           Revision;
    ULONG           SidCount;   // was Unused2
    BOOLEAN         Valid;

    //
    // The following fields are present for NT 3.51 since build 622
    //

    CHAR            Unused[3];
    ULONG           SidLength;

    //
    // The following fields have been present (but zero) since NT 3.51.
    //  We started filling it in in NT 5.0
    //
    ULONG           LogonPackage; // The RPC ID of the package doing the logon.
    USHORT          DnsDomainNameLength;
    USHORT          UpnLength;

} LOGON_CACHE_ENTRY_NT_4_SP4, *PLOGON_CACHE_ENTRY_NT_4_SP4;

#if 0

//
// NT1.0 logon structure.  left here for reference only.
//
typedef struct _LOGON_CACHE_ENTRY_1_0 {
    USHORT  UserNameLength;
    USHORT  DomainNameLength;
    USHORT  EffectiveNameLength;
    USHORT  FullNameLength;

    USHORT  LogonScriptLength;
    USHORT  ProfilePathLength;
    USHORT  HomeDirectoryLength;
    USHORT  HomeDirectoryDriveLength;

    ULONG   UserId;
    ULONG   PrimaryGroupId;
    ULONG   GroupCount;
    USHORT  LogonDomainNameLength;
} LOGON_CACHE_ENTRY_1_0, *PLOGON_CACHE_ENTRY_1_0;

#endif


//
// Windows2000 cached logon request structs
// Updated version in NTLMSV1_0.h
//
typedef struct _MSV1_0_CACHE_LOGON_REQUEST_OLD {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID LogonInformation;
    PVOID ValidationInformation;
} MSV1_0_CACHE_LOGON_REQUEST_OLD, *PMSV1_0_CACHE_LOGON_REQUEST_OLD;

typedef struct _MSV1_0_CACHE_LOGON_REQUEST_W2K {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID LogonInformation;
    PVOID ValidationInformation;
    PVOID SupplementalCacheData;
    ULONG SupplementalCacheDataLength;
} MSV1_0_CACHE_LOGON_REQUEST_W2K, *PMSV1_0_CACHE_LOGON_REQUEST_W2K;

//
// net logon cache prototypes
//

NTSTATUS
NlpCacheInitialize(
    VOID
    );

NTSTATUS
NlpCacheTerminate(
    VOID
    );

NTSTATUS
NlpAddCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  PVOID SupplementalCacheData,
    IN  ULONG SupplementalCacheDataLength,
    IN  ULONG CacheFlags
    );

NTSTATUS
NlpGetCacheEntry(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo,
    OUT PCACHE_PASSWORDS Passwords,
    OUT PVOID *ppSupplementalCacheData OPTIONAL ,
    OUT PULONG SupplementalCacheDataLength OPTIONAL
    );

NTSTATUS
NlpDeleteCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo
    );

VOID
NlpChangeCachePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    );

NTSTATUS
NlpComputeSaltedHashedPassword(
    OUT PNT_OWF_PASSWORD SaltedOwfPassword,
    IN PNT_OWF_PASSWORD OwfPassword,
    IN PUNICODE_STRING UserName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\nlpcache.c ===
/*++

Copyright (c) 1991 - 1999  Microsoft Corporation

Module Name:

    nlpcache.c

Abstract:

    This module contains routines which implement user account caching:

        NlpCacheInitialize
        NlpCacheTerminate
        NlpAddCacheEntry
        NlpGetCacheEntry
        NlpDeleteCacheEntry
        NlpChangeCachePassword


    The cache contains the most recent validated logon information. There is
    only 1 (that's right - one) cache slot. This will probably change though

Author:

    Richard L Firth (rfirth) 17-Dec-1991

Revision History:

   Scott Field (sfield)   04-Jun-99
        Add supplemental cache data.
        Store all cache related data in single location.
        Encrypt interesting elements of cache entry using per-entry key mixed with per-machine key.
        MAC interesting cache elements for integrity check.
        Drastically reduce lock contention.
        Avoid NtFlushKey() for single location cache elements.
        Avoid persisting a new cache entry that matches an existing one.
        Attempt reg query with stack based buffer first.

   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlpcache.c

--*/

#include <global.h>
#undef EXTERN

#include "msp.h"
#include "nlp.h"
#include "nlpcache.h"



//
// manifests
//

#if DBG
#include <stdio.h>
#endif

//
// Revision numbers
//
//      NT 3.0 didn't explicitly store a revision number.
//          However, we are designating that release to be revision 0x00010000 (1.0).
//      NT 3.5 prior to build 622 is revision 0x00010001 (1.1).
//      NT 3.5 is revision 0x00010002 (1.2).
//      NT 4.0 SP 4 is revision 0x00010003 (1.3)
//      NT 5.0 build 2054+ is revision 0x00010004 (1.4)
//

#define NLP_CACHE_REVISION_NT_1_0         (0x00010000)  // NT 3.0
#define NLP_CACHE_REVISION_NT_1_0B        (0x00010002)  // NT 3.5
#define NLP_CACHE_REVISION_NT_4_SP4       (0x00010003)  // NT 4.0 SP 4 to save passwords as salted.
#define NLP_CACHE_REVISION_NT_5_0         (0x00010004)  // NT 5.0 to support opaque cache data and single location data storage.
#define NLP_CACHE_REVISION                (NLP_CACHE_REVISION_NT_5_0)





//
// The logon cache may be controlled via a value in the registry.
// If the registry key does not exist, then this default constant defines
// how many logon cache entries will be active.  The max constant
// places an upper limit on how many cache entries we will support.
// If the user specifies more than the max value, we will use the
// max value instead.
//

#define NLP_DEFAULT_LOGON_CACHE_COUNT           (10)
#define NLP_MAX_LOGON_CACHE_COUNT               (50)


//
// length of per-machine cache encryption key.
//

#define NLP_CACHE_ENCRYPTION_KEY_LEN            (64)

//
// name of LSA secret containing cache encryption key.
//

#define NLP_CACHE_ENCRYPTION_KEY_NAME           L"NL$KM"


//
// macros
//

#define AllocateCacheEntry(n)   (PLOGON_CACHE_ENTRY)I_NtLmAllocate(n)
#define FreeCacheEntry(p)       I_NtLmFree((PVOID)p)
#define AllocateFromHeap(n)     I_NtLmAllocate(n)
#define FreeToHeap(p)           I_NtLmFree((PVOID)p)

//
// guard against simultaneous access
//

#define READ_CACHE()            RtlAcquireResourceShared(&NlpLogonCacheCritSec, TRUE)
#define WRITE_CACHE()           RtlAcquireResourceExclusive(&NlpLogonCacheCritSec, TRUE)
#define READ_TO_WRITE_CACHE()   RtlConvertSharedToExclusive(&NlpLogonCacheCritSec)
#define LEAVE_CACHE()           RtlReleaseResource(&NlpLogonCacheCritSec)

#define INVALIDATE_HANDLE(handle) (*((PHANDLE)(&handle)) = INVALID_HANDLE_VALUE)
#define IS_VALID_HANDLE(handle)   (handle != INVALID_HANDLE_VALUE)


////////////////////////////////////////////////////////////////////////
//                                                                    //
// datatypes                                                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef enum _NLP_SET_TIME_HINT {
    NLP_SMALL_TIME,
    NLP_BIG_TIME,
    NLP_NOW_TIME
} NLP_SET_TIME_HINT, *PNLP_SET_TIME_HINT;

#define BIG_PART_1      0x7fffffff  // largest positive large int is 63 bits on
#define BIG_PART_2      0xffffffff
#define SMALL_PART_1    0x0         // smallest positive large int is 64 bits off
#define SMALL_PART_2    0x0


//
// This structure is saved on disk and provides information
// about the rest of the cache.  This structure is in a value
// named "NL$Control" under the cache registry key.
//

typedef struct _NLP_CACHE_CONTROL {

    //
    // Revision of the cache on-disk structure
    //

    ULONG       Revision;

    //
    // The current on-disk size of the cache (number of entries)
    //

    ULONG       Entries;

} NLP_CACHE_CONTROL, *PNLP_CACHE_CONTROL;


//
// This data structure is a single cache table entry (CTE)
// Each entry in the cache has a corresponding CTE.
//

typedef struct _NLP_CTE {

        //
        // CTEs are linked on either an invalid list (in any order)
        // or on a valid list (in ascending order of time).
        // This makes it easy to figure out which entry is to be
        // flushed when adding to the cache.
        //

        LIST_ENTRY Link;


        //
        // Time the cache entry was established.
        // This is used to determine which cache
        // entry is the oldest, and therefore will
        // be flushed from the cache first to make
        // room for new entries.
        //

        LARGE_INTEGER       Time;


        //
        // This field contains the index of the CTE within the
        // CTE table.  This index is used to generate the names
        // of the entrie's secret key and cache key in the registry.
        // This field is valid even if the entry is marked Inactive.
        //

        ULONG               Index;

        //
        // Normally, we walk the active and inactive lists
        // to find entries.  When growing or shrinking the
        // cache, however, it is nice to be able to walk the
        // table using indexes.  In this case, it is nice to
        // have a local way of determining whether an entry
        // is on the active or inactive list.  This field
        // provides that capability.
        //
        //      TRUE  ==> on active list
        //      FALSE ==> not on active list
        //

        BOOLEAN             Active;


} NLP_CTE, *PNLP_CTE;

//
// This structure is used for keeping track of all information that
// is stored on backing store.
//

typedef struct _NLP_CACHE_AND_SECRETS {
    PLOGON_CACHE_ENTRY          CacheEntry;
    ULONG                       EntrySize;
    PLSAPR_CR_CIPHER_VALUE      NewSecret;
    PLSAPR_CR_CIPHER_VALUE      OldSecret;
    BOOLEAN                     Active;
} NLP_CACHE_AND_SECRETS,  *PNLP_CACHE_AND_SECRETS;


////////////////////////////////////////////////////////////////////////
//                                                                    //
// Local Prototypes                                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
NlpInternalCacheInitialize(
    VOID
    );

NTSTATUS
NlpOpenCache( VOID );

VOID
NlpCloseCache( VOID );


NTSTATUS
NlpGetCacheControlInfo( VOID );

NTSTATUS
NlpCacheKeyInitialize(
    VOID
    );

NTSTATUS
NlpBuildCteTable( VOID );

NTSTATUS
NlpChangeCacheSizeIfNecessary( VOID );

NTSTATUS
NlpWriteCacheControl( VOID );

VOID
NlpMakeCacheEntryName(
    IN  ULONG               EntryIndex,
    OUT PUNICODE_STRING     Name
    );

NTSTATUS
NlpMakeNewCacheEntry(
    ULONG           Index
    );

NTSTATUS
NlpEliminateCacheEntry(
    IN  ULONG               Index
    );

NTSTATUS
NlpReadCacheEntryByIndex(
    IN  ULONG               Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG EntrySize
    );

VOID
NlpAddEntryToActiveList(
    IN  ULONG   Index
    );

VOID
NlpAddEntryToInactiveList(
    IN  ULONG   Index
    );

VOID
NlpGetFreeEntryIndex(
    OUT PULONG  Index
    );


NTSTATUS
NlpBuildCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  ULONG CacheFlags,
    OUT PLOGON_CACHE_ENTRY* ppCacheEntry,
    OUT PULONG pEntryLength
    );

BOOLEAN
NlpCompareCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry1,
    IN  ULONG EntrySize1,
    IN  PLOGON_CACHE_ENTRY CacheEntry2,
    IN  ULONG EntrySize2
    );

NTSTATUS
NlpEncryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    );

NTSTATUS
NlpDecryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    );

NTSTATUS
NlpAddSupplementalCacheData(
    IN      PVOID SupplementalCacheData,
    IN      ULONG SupplementalCacheDataLength,
    IN OUT  PLOGON_CACHE_ENTRY *ppCacheEntry,
    IN OUT  PULONG pEntryLength
    );

NTSTATUS
NlpOpenCache( VOID );

VOID
NlpCloseCache( VOID );

NTSTATUS
NlpOpenSecret(
    IN  ULONG   Index
    );

VOID
NlpCloseSecret( VOID );

NTSTATUS
NlpWriteSecret(
    IN  PLSAPR_CR_CIPHER_VALUE NewSecret,
    IN  PLSAPR_CR_CIPHER_VALUE OldSecret
    );

NTSTATUS
NlpReadSecret(
    OUT PLSAPR_CR_CIPHER_VALUE * NewSecret,
    OUT PLSAPR_CR_CIPHER_VALUE * OldSecret
    );

NTSTATUS
NlpMakeSecretPassword(
    OUT PLSAPR_CR_CIPHER_VALUE Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    );

NTSTATUS
NlpMakeSecretPasswordNT5(
    IN OUT PCACHE_PASSWORDS Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    );


BOOLEAN
NlpCheckMitCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName
    );   


NTSTATUS
NlpReadCacheEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    OUT PULONG              Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG              EntrySize
    );

NTSTATUS
NlpWriteCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY Entry,
    IN  ULONG              EntrySize
    );

VOID
NlpCopyAndUpdateAccountInfo(
    IN  USHORT Length,
    IN  PUNICODE_STRING pUnicodeString,
    IN OUT PUCHAR* pSource,
    IN OUT PUCHAR* pDest
    );

VOID
NlpSetTimeField(
    OUT POLD_LARGE_INTEGER pTimeField,
    IN  NLP_SET_TIME_HINT Hint
    );

NTSTATUS
NlpBuildAccountInfo(
    IN  PLOGON_CACHE_ENTRY pCacheEntry,
    IN  ULONG EntryLength,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo
    );



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//          Diagnostic support services prototypes                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#if DBG
PCHAR
DumpOwfPasswordToString(
    OUT PCHAR Buffer,
    IN  PLM_OWF_PASSWORD Password
    );

VOID
DumpLogonInfo(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo
    );

char*
MapWeekday(
    IN  CSHORT  Weekday
    );

VOID
DumpTime(
    IN  LPSTR   String,
    IN  POLD_LARGE_INTEGER OldTime
    );

VOID
DumpGroupIds(
    IN  LPSTR   String,
    IN  ULONG   Count,
    IN  PGROUP_MEMBERSHIP GroupIds
    );

VOID
DumpSessKey(
    IN  LPSTR   String,
    IN  PUSER_SESSION_KEY Key
    );

VOID
DumpSid(
    LPSTR   String,
    PISID   Sid
    );

VOID
DumpAccountInfo(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo
    );

VOID
DumpCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY pEntry
    );

#endif //DBG




////////////////////////////////////////////////////////////////////////
//                                                                    //
// global data                                                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// This boolean indicates whether or not we have been able to
// initialize caching yet.  It turn out that during authentication
// package load time, we can't do everything we would like to (like
// call LSA RPC routines).  So, we delay initializing until we can
// call LSA.  All publicly exposed interfaces must check this value
// before assuming work can be done.
//

BOOLEAN         NlpInitializationNotYetPerformed = TRUE;


RTL_RESOURCE    NlpLogonCacheCritSec;



HANDLE          NlpCacheHandle  = (HANDLE)     INVALID_HANDLE_VALUE;
LSAPR_HANDLE    NlpSecretHandle = (LSAPR_HANDLE) INVALID_HANDLE_VALUE;

//
// control information about the cache (number of entries, etc).
//

NLP_CACHE_CONTROL   NlpCacheControl;

//
// This structure is generated and maintained only in memory.
// It indicates which cache entries are valid and which aren't.
// It also indicates what time each entry was established so we
// know which order to discard them in.
//
//  This field is a pointer to an array of CTEs.  The number of CTEs
//  in the array is in NlpCacheControl.Entries.  This structure is
//  allocated at initialization time.
//

PNLP_CTE            NlpCteTable;


//
// The Cache Table Entries in NlpCteTable are linked on either an
// active or inactive list.  The entries on the active list are in
// ascending time order - so the last one on the list is the first
// one to be discarded when a flush is needed to add a new entry.
//

LIST_ENTRY          NlpActiveCtes;
LIST_ENTRY          NlpInactiveCtes;


//
// global, per-machine key used for encrypting NT_5_0 version cache
// entries.
//

CHAR                NlpCacheEncryptionKey[ NLP_CACHE_ENCRYPTION_KEY_LEN ];



#if DBG
#ifdef DUMP_CACHE_INFO
ULONG   DumpCacheInfo = 1;
#else
ULONG   DumpCacheInfo = 0;
#endif
#endif



////////////////////////////////////////////////////////////////////////
//                                                                    //
// Services Exported by this module                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////






NTSTATUS
NlpCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize cached logon processing.

    Unfortunately, there isn't much we can do when we are called.
    (we can't open LSA, for example).  So, defer initialization
    until later.


Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    RtlInitializeResource(&NlpLogonCacheCritSec);
    return STATUS_SUCCESS;
}


NTSTATUS
NlpCacheTerminate(
    VOID
    )

/*++

Routine Description:

    Called when process detaches

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpCacheTerminate\n");
    }
#endif

    if (!NlpInitializationNotYetPerformed) {
        NlpCloseCache();
        NlpCloseSecret();

        if (IS_VALID_HANDLE(NlpCacheHandle)) {
            NtClose( NlpCacheHandle );
        }

        FreeToHeap( NlpCteTable );
    }

    RtlDeleteResource(&NlpLogonCacheCritSec);
    return STATUS_SUCCESS;
}


NTSTATUS
NlpGetCacheEntry(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo,
    OUT PNETLOGON_VALIDATION_SAM_INFO4* AccountInfo,
    OUT PCACHE_PASSWORDS Passwords,
    OUT PVOID *ppSupplementalCacheData OPTIONAL ,
    OUT PULONG SupplementalCacheDataLength OPTIONAL
    )

/*++

Routine Description:

    If the user logging on has information stored in the cache,
    then it is retrieved. Also returns the cached password from
    'secret' storage

Arguments:

    LogonInfo   - pointer to NETLOGON_IDENTITY_INFO structure which contains
                  the domain name, user name for this user

    AccountInfo - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure to
                  receive this user's specific interactive logon information

    Passwords   - pointer to CACHE_PASSWORDS structure to receive passwords
                  returned from secret storage

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *AccountInfo points to a NETLOGON_VALIDATION_SAM_INFO4
                    structure. This must be freed by caller

                    *Passwords contain USER_INTERNAL1_INFORMATION structure
                    which contains NT OWF password and LM OWF password. These
                    must be used to validate the logon

        Failure = STATUS_LOGON_FAILURE
                    The user logging on isn't in the cache.

--*/

{
    NTSTATUS
        NtStatus;

    PNETLOGON_VALIDATION_SAM_INFO4
        SamInfo = NULL;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;

    PLSAPR_CR_CIPHER_VALUE
        CurrentSecret = NULL,
        OldSecret = NULL;


    BOOLEAN fCacheLocked = FALSE;


    *AccountInfo = NULL;

    if( ppSupplementalCacheData )
        *ppSupplementalCacheData = NULL;


#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpGetCacheEntry\n");
        DumpLogonInfo(LogonInfo);
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return(STATUS_LOGON_FAILURE);
    }

    //
    // TODO: consider comparing LogonDomainName to NlpSamDomainName
    // and failing cached logon attempts at local machine.
    //

    READ_CACHE();
    fCacheLocked = TRUE;

    //
    // Find the cache entry and open its secret (if found)
    //

    NtStatus = NlpReadCacheEntry(&LogonInfo->LogonDomainName,
                                 &LogonInfo->UserName,
                                 &Index,
                                 &CacheEntry,
                                 &EntrySize);

    if(!NT_SUCCESS(NtStatus)) {
        LEAVE_CACHE();
        return (NtStatus);
    }

    if( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {

        //
        // for NT5, we can release the cache lock now, since all data
        // stored in one place.
        //

        LEAVE_CACHE();
        fCacheLocked = FALSE;

        //
        // if caller wanted supplemental data, give it to them.
        //

        if( ppSupplementalCacheData && SupplementalCacheDataLength )
        {
            LPBYTE Source;

            *SupplementalCacheDataLength = CacheEntry->SupplementalCacheDataLength;

            *ppSupplementalCacheData = MIDL_user_allocate( *SupplementalCacheDataLength );

            if( *ppSupplementalCacheData == NULL ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // note: the decrypt operation that occurred during the
            // ReadCacheEntry validates any data and pointers through
            // integrity checking via HMAC.  Having said that, we can be
            // lazy and not do boundry checking.
            //

            Source = ((LPBYTE)CacheEntry + CacheEntry->SupplementalCacheDataOffset);

            CopyMemory( *ppSupplementalCacheData,
                        Source,
                        *SupplementalCacheDataLength
                        );
        }

    }


    NtStatus = NlpBuildAccountInfo(CacheEntry, EntrySize, &SamInfo);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }


    if( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {

        //
        // for NT5, the Passwords are stored in the CacheEntry.
        // note: passwords are assumed to be salted.
        //

        RtlCopyMemory( Passwords, &(CacheEntry->CachePasswords), sizeof(*Passwords) );


    } else {

        //
        // prior to NT5, the Passwords are stored separately in their
        // own LSA secret.
        //

        NtStatus = NlpReadSecret(&CurrentSecret, &OldSecret);

        if(!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }

        if ( CurrentSecret == NULL )
        {
            NtStatus = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        //
        // can release the cache lock now, since second data item fetched.
        //

        LEAVE_CACHE();
        fCacheLocked = FALSE;


        //
        // Check to see which version of the passwords are stored
        // here - the normal or the salted.
        //

        RtlCopyMemory((PVOID)Passwords,
            (PVOID)CurrentSecret->Buffer,
            (ULONG)CurrentSecret->Length
            );

        if ( CacheEntry->Revision < NLP_CACHE_REVISION_NT_4_SP4 )
        {
            if (Passwords->SecretPasswords.NtPasswordPresent)
            {
                NtStatus = NlpComputeSaltedHashedPassword(
                                &Passwords->SecretPasswords.NtOwfPassword,
                                &Passwords->SecretPasswords.NtOwfPassword,
                                &SamInfo->EffectiveName
                                );
                if(!NT_SUCCESS(NtStatus))
                {
                    goto Cleanup;
                }
            }

            if (Passwords->SecretPasswords.LmPasswordPresent)
            {
                NtStatus = NlpComputeSaltedHashedPassword(
                                &Passwords->SecretPasswords.LmOwfPassword,
                                &Passwords->SecretPasswords.LmOwfPassword,
                                &SamInfo->EffectiveName
                                );

                if(!NT_SUCCESS(NtStatus))
                {
                    goto Cleanup;
                }
            }
        }
    }


Cleanup:

    if( fCacheLocked ) {
        LEAVE_CACHE();
    }


    //
    // free structure allocated by NlpReadCacheEntry
    //

    if( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap(CacheEntry);
    }


    //
    // free structures allocated by NlpReadSecret
    //

    if (CurrentSecret) {
        MIDL_user_free(CurrentSecret);
    }
    if (OldSecret) {
        MIDL_user_free(OldSecret);
    }


    if( NT_SUCCESS( NtStatus ) ) {
        *AccountInfo = SamInfo;
    } else {

        if ( SamInfo != NULL ) {
            MIDL_user_free( SamInfo );
        }

        if( ppSupplementalCacheData && *ppSupplementalCacheData ) {
            MIDL_user_free( *ppSupplementalCacheData );
            *ppSupplementalCacheData = NULL;
        }
    }

    return(NtStatus);
}


NTSTATUS
NlpAddCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  PVOID SupplementalCacheData,
    IN  ULONG SupplementalCacheDataLength,
    IN  ULONG CacheFlags
    )

/*++

Routine Description:

    Adds this domain:user interactive logon information to the cache.

Arguments:

    LogonInfo   - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
                  the domain name, user name and password for this user. These
                  are what the user typed to WinLogon

    AccountInfo - pointer to NETLOGON_VALIDATION_SAM_INFO4 structure which
                  contains this user's specific interactive logon information

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    AccountInfo successfully added to cache

        Failure = STATUS_NO_MEMORY


--*/

{
    NTSTATUS
        NtStatus;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    PLOGON_CACHE_ENTRY
        CacheEntryExisting = NULL;

    ULONG
        EntrySize,
        EntrySizeExisting,
        Index;


    PUNICODE_STRING LogonDomainName;
    UNICODE_STRING NullString = {0,0,NULL};

    BOOLEAN fCacheLocked = FALSE;

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpAddCacheEntry\n");
        DumpLogonInfo(&LogonInfo->Identity);
        DumpAccountInfo(AccountInfo);
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    if (NlpCacheControl.Entries == 0) {
        return(STATUS_SUCCESS);
    }


    //
    // LogonUser() allows for a NULL domain name to be supplied, which
    // causes netlogon search logic to kick in.  this can result to logon
    // packages requesting to cache local account information.
    // In this case, use the LogonDomainName that SAM provides to make
    // a decision about whether to allow caching.  In the same scenario,
    // if we decide caching is allowed, the cache entry target domain
    // is also set based on what SAM returned.
    //
    // For MIT logons, don't use logon info.   
    //
    // 
    if ((CacheFlags & MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON) != 0) {
        LogonDomainName = &(NullString);      
    }                                   
    else if( LogonInfo->Identity.LogonDomainName.Length != 0 )  {    
        LogonDomainName = &(LogonInfo->Identity.LogonDomainName);
    } else {
        LogonDomainName = &(AccountInfo->LogonDomainName);
    }

    if( NlpSamDomainName.Buffer &&
        RtlEqualDomainName(LogonDomainName, &NlpSamDomainName)
        )
    {

#if DBG
        if (DumpCacheInfo) {
            DbgPrint("NlpAddCacheEntry: attempt to cache against local account skipped.\n");
        }
#endif
        return STATUS_SUCCESS;
    }

    //
    // build base cache entry.
    //

    NtStatus = NlpBuildCacheEntry(
                LogonInfo, 
                AccountInfo, 
                CacheFlags, 
                &CacheEntry, 
                &EntrySize
                );

    if(!NT_SUCCESS(NtStatus) )
    {
        return (NtStatus);
    }



    //
    // add any supplemental data to the cache entry.
    // (this is new for NT5).
    //

    NtStatus = NlpAddSupplementalCacheData(
                            SupplementalCacheData,
                            SupplementalCacheDataLength,
                            &CacheEntry,
                            &EntrySize
                            );


    if(!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // add in salted OWFs.
    //

    NtStatus = NlpMakeSecretPasswordNT5(
                            &CacheEntry->CachePasswords,
                            &AccountInfo->EffectiveName,
                            &LogonInfo->NtOwfPassword,
                            &LogonInfo->LmOwfPassword
                            );

    if(!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }




    READ_CACHE();
    fCacheLocked = TRUE;

    //
    // See if this entry already exists in the cache.
    // If so, use the same index.
    //

    NtStatus = NlpReadCacheEntry( LogonDomainName,
                                  &LogonInfo->Identity.UserName,
                                  &Index,
                                  &CacheEntryExisting,
                                  &EntrySizeExisting
                                  );

    //
    // If we didn't find an entry, then we need to allocate an
    // entry.
    //

    if (!NT_SUCCESS(NtStatus)) {

        NlpGetFreeEntryIndex( &Index );

        CacheEntryExisting = NULL;

    } else {

        //
        // We already have an entry for this user.
        // Discard the structure we got back but
        // use the same index.
        //

        // TODO: check if existing entry matches new built entry.
        // if so, avoid write.

        BOOLEAN fMatchesExisting;

        fMatchesExisting = NlpCompareCacheEntry(
                                    CacheEntry,
                                    EntrySize,
                                    CacheEntryExisting,
                                    EntrySizeExisting
                                    );

        if( fMatchesExisting )
        {
            goto Cleanup;
        }
    }


    //
    // encrypt sensitive portions of the cache entry.
    // note: this was done prior to locking the cache, but, in the interest
    // of allowing for cache compare above, the encryption is deferred until
    // now.
    //

    NtStatus = NlpEncryptCacheEntry(CacheEntry, EntrySize);

    if(!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    //
    // we already have the read lock, convert it to write-lock.
    //

    READ_TO_WRITE_CACHE();


    //
    // now, write the entry out...
    //

    NtStatus = NlpWriteCacheEntry(Index, CacheEntry, EntrySize);


    if (NT_SUCCESS(NtStatus)) {
        NlpCteTable[Index].Time = CacheEntry->Time;
        NlpAddEntryToActiveList( Index );
    }



Cleanup:

    if( fCacheLocked )
    {
        LEAVE_CACHE();
    }


    if( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeCacheEntry( CacheEntry );
    }

    if( CacheEntryExisting ) {
        ZeroMemory( CacheEntryExisting, EntrySizeExisting );
        FreeCacheEntry( CacheEntryExisting );
    }

    return(NtStatus);
}



NTSTATUS
NlpAddSupplementalCacheData(
    IN      PVOID SupplementalCacheData,
    IN      ULONG SupplementalCacheDataLength,
    IN OUT  PLOGON_CACHE_ENTRY *ppCacheEntry,
    IN OUT  PULONG pEntryLength
    )

/*++

Routine Description:

    Extends the supplied LOGON_CACHE_ENTRY with opaque authentication package
    SupplementalCacheData (eg: smart-card logon cache info).

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure =

--*/

{
    PLOGON_CACHE_ENTRY NewCacheEntry = NULL;

    if( (*ppCacheEntry)->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }

    (*ppCacheEntry)->SupplementalCacheDataLength = SupplementalCacheDataLength;
    (*ppCacheEntry)->SupplementalCacheDataOffset = *pEntryLength;


    if( SupplementalCacheData == NULL || SupplementalCacheDataLength == 0 ) {
        return STATUS_SUCCESS;
    }


    //
    // allocate new entry, and copy existing entry + supplemental data to end.
    //

    NewCacheEntry = AllocateCacheEntry( *pEntryLength + SupplementalCacheDataLength );

    if( NewCacheEntry == NULL ) {
        return STATUS_NO_MEMORY;
    }

    CopyMemory( NewCacheEntry, *ppCacheEntry, *pEntryLength );
    CopyMemory( ((PBYTE)(NewCacheEntry) + *pEntryLength),
                SupplementalCacheData,
                SupplementalCacheDataLength
                );

    ZeroMemory( *ppCacheEntry, *pEntryLength );
    FreeCacheEntry( *ppCacheEntry );

    *ppCacheEntry = NewCacheEntry;
    *pEntryLength += SupplementalCacheDataLength;

    return STATUS_SUCCESS;
}


NTSTATUS
NlpDeleteCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo
    )

/*++

Routine Description:

    Deletes a user account from the local user account cache, if the corresponding
    entry can be found. We actually just null out the current contents instead of
    destroying the storage - this should save us some time when we next come to
    add an entry to the cache

Arguments:

    LogonInfo   - pointer to NETLOGON_INTERACTIVE_INFO structure which contains
                  the domain name, user name and password for this user

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;


    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }


    if (NlpCacheControl.Entries == 0) {
        return(STATUS_SUCCESS);
    }

    WRITE_CACHE();

    //
    // See if this entry exists in the cache.
    //

    NtStatus = NlpReadCacheEntry( &LogonInfo->Identity.LogonDomainName,
                                  &LogonInfo->Identity.UserName,                   
                                  &Index,
                                  &CacheEntry,
                                  &EntrySize
                                  );

    //
    // If we didn't find an entry, then there is nothing to do.
    //

    if (!NT_SUCCESS(NtStatus)) {
        LEAVE_CACHE();
        return(STATUS_SUCCESS);
    }

    //
    // Mark it as invalid.
    //

    CacheEntry->Valid = FALSE;

    NtStatus = NlpWriteCacheEntry( Index, CacheEntry, EntrySize );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Put the CTE entry on the inactive list.
        //

        NlpAddEntryToInactiveList( Index );
    }


    LEAVE_CACHE();


    //
    // Free the structure returned from NlpReadCacheEntry()
    //

    if( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap( CacheEntry );
    }


    return(NtStatus);
}


VOID
NlpChangeCachePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Update a cached password to the specified value, if we have
    the specified account cached.

Arguments:


    DomainName - The name of the domain in which the account exists.

    UserName - The name of the account whose password is to be changed.

    LmOwfPassword - The new LM compatible password.

    NtOwfPassword - The new NT compatible password.

Return Value:

    None.

--*/

{
    NTSTATUS
        NtStatus;

    PLOGON_CACHE_ENTRY
        CacheEntry = NULL;

    ULONG
        EntrySize,
        Index;

    PLSAPR_CR_CIPHER_VALUE
        CurrentSecret = NULL,
        OldSecret = NULL;

    LSAPR_CR_CIPHER_VALUE
        Passwords;


#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpChangeCachePassword\n");
    }
#endif

    if (NlpInitializationNotYetPerformed) {
        NtStatus = NlpInternalCacheInitialize();
        if (!NT_SUCCESS(NtStatus)) {
            return;
        }
    }


    if (NlpCacheControl.Entries == 0) {
        return;
    }

    WRITE_CACHE();


    NtStatus = NlpReadCacheEntry( DomainName,
                                  UserName,
                                  &Index,
                                  &CacheEntry,
                                  &EntrySize);

    if(!NT_SUCCESS( NtStatus) ) {
        LEAVE_CACHE();
        return ;
    }


    if( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
        UNICODE_STRING CachedUser;

        CachedUser.Length =
            CachedUser.MaximumLength = CacheEntry->UserNameLength;
        CachedUser.Buffer = (PWSTR) ((PBYTE) CacheEntry + sizeof(LOGON_CACHE_ENTRY));

        NtStatus = NlpMakeSecretPasswordNT5( &CacheEntry->CachePasswords,
                                          &CachedUser,
                                          NtOwfPassword,
                                          LmOwfPassword );


        if(NT_SUCCESS(NtStatus)) {

            //
            // encrypt the entry...
            //

            NtStatus = NlpEncryptCacheEntry( CacheEntry, EntrySize );
        }

        if(NT_SUCCESS( NtStatus )) {

            //
            // now, write the entry out...
            //

            NtStatus = NlpWriteCacheEntry(Index, CacheEntry, EntrySize);

#ifdef DBG
            if(DumpCacheInfo) {
                if( NT_SUCCESS( NtStatus ) ) {
                    DbgPrint("NlpChangeCachePassword: SUCCEED write NT5 version cache entry.\n");
                } else {
                    DbgPrint("NlpChangeCachePassword: FAIL write NT5 version cache entry.\n");
                }
            }
#endif

        }

    } else {

        NtStatus = NlpOpenSecret( Index );
        if (NT_SUCCESS(NtStatus)) {

            NtStatus = NlpReadSecret(&CurrentSecret, &OldSecret);
            if (NT_SUCCESS(NtStatus)) {
                UNICODE_STRING CachedUser;

                //
                // Grab the various strings from the cache entry.
                //
                ASSERT( CacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B );

                CachedUser.Length =
                    CachedUser.MaximumLength = CacheEntry->UserNameLength;
                CachedUser.Buffer = (PWSTR) ((PBYTE) CacheEntry + sizeof(LOGON_CACHE_ENTRY_NT_4_SP4));

                NtStatus = NlpMakeSecretPassword( &Passwords,
                                                  &CachedUser,
                                                  NtOwfPassword,
                                                  LmOwfPassword );

                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = NlpWriteSecret(&Passwords, CurrentSecret);

                    //
                    // free the buffer allocated to store the passwords
                    //

                    FreeToHeap(Passwords.Buffer);
                }

                //
                // free strings returned by NlpReadSecret
                //

                if (CurrentSecret) {
                    MIDL_user_free(CurrentSecret);
                }
                if (OldSecret) {
                    MIDL_user_free(OldSecret);
                }

            }
        }

    }

    LEAVE_CACHE();


    //
    // free structure allocated by NlpReadCacheEntry
    //

    if( CacheEntry ) {
        ZeroMemory( CacheEntry, EntrySize );
        FreeToHeap(CacheEntry);
    }

    return;
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
// Services Internal to this module                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NlpInternalCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize cached logon processing.

    This routine will automatically adjust the size of the logon
    cache if necessary to accomodate a new user-specified length
    (specified in the Winlogon part of the registry).

    NOTE: If called too early, this routine won't be able to call
          LSA's RPC routines.  In this case, initialization is
          defered until later.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{

    NTSTATUS
        NtStatus;

// DbgPrint("\n\n\n     REMEMBER TO TAKE THIS BREAKPOINT OUT BEFORE CHECKIN.\n\n\n");
// DumpCacheInfo = 1;   // Remember to take this out too !!!!!!
// DbgBreakPoint();     // Remember to take this out before checking

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpCacheInitialize\n");
    }
#endif


    //
    // Upon return from this routine, if logon caching is enabled,
    // the following will be true:
    //
    //      A handle to the registry key in which all cache entries
    //      are held will be open (NlpCacheHandle).
    //
    //      A global structure defining how many cache entries there are
    //      will be initialized (NlpCacheControl).
    //
    //      The Cache Table Entry table (CTE table) will be initialized
    //      (NlpCteTable).
    //
    //      The active and inactive CTE lists will be built
    //      (NlpActiveCtes and NlpInactiveCtes).
    //
    //      A global cache encryption key will be initialized.
    //



    WRITE_CACHE();

    //
    // Check again if the cache is initialized now that the crit sect is locked.
    //

    if (NlpInitializationNotYetPerformed) {

        //
        // Open the local system's policy object
        //


        //
        // Successfully, or unsucessfully,
        // The definition of "initialized" is we could call LSA's RPC
        // routines.
        //

        NlpInitializationNotYetPerformed = FALSE;

        //
        // Open the registry key containing cache entries.
        // This will remain open.
        //

        NtStatus = NlpOpenCache();

        if (NT_SUCCESS(NtStatus)) {

            //
            // Get information on the current cache structure
            // (number of entries, et cetera).  This information is
            // placed in a global variable for use throughout this
            // module.
            //

            NtStatus = NlpGetCacheControlInfo();

            //
            // Initialize the per-machine cache encryption key.
            //

            if(NT_SUCCESS( NtStatus) ) {
                NtStatus = NlpCacheKeyInitialize();
            }

            //
            // Now build the CTE table
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NlpBuildCteTable();
            }

            //
            // If we were successful, then see if we need to change
            // the cache due to new user-specified cache size.
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NlpChangeCacheSizeIfNecessary();
            }

            if (!NT_SUCCESS(NtStatus)) {
                NlpCloseCache();
            }
        }


        //
        // If we had an error, then set our entry count to zero
        // to prevent using any cache information.
        //

        if (!NT_SUCCESS(NtStatus)) {
            NlpCacheControl.Entries = 0;
        }

    } else {
        NtStatus = STATUS_SUCCESS;
    }

    LEAVE_CACHE();

    return(NtStatus);
}


NTSTATUS
NlpCacheKeyInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the Global variable NlpCacheEncryptionKey with a per-machine
    cache encryption key.  If the per-machine key does not exist as an LSA
    secret, it is created.

--*/
{
    LSAPR_HANDLE SecretHandle;
    UNICODE_STRING ValueName;
    BOOLEAN SecretCreationNeeded = FALSE;
    NTSTATUS NtStatus;

    RtlInitUnicodeString( &ValueName, NLP_CACHE_ENCRYPTION_KEY_NAME );

    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                             (PLSAPR_UNICODE_STRING) &ValueName,
                             SECRET_QUERY_VALUE | SECRET_SET_VALUE,
                             &SecretHandle
                             );

    if (!NT_SUCCESS(NtStatus)) {

        //
        // create new key, if not present.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
            return (NtStatus);
        }

        NtStatus = I_LsarCreateSecret(NtLmGlobalPolicyHandle,
                                   (PLSAPR_UNICODE_STRING) &ValueName,
                                   SECRET_SET_VALUE,
                                   &SecretHandle
                                   );

        if (!NT_SUCCESS(NtStatus)) {
            return (NtStatus);
        }

        SecretCreationNeeded = TRUE;

    } else {

        //
        // query current value...
        //

        LARGE_INTEGER
            CurrentTime;

        PLSAPR_CR_CIPHER_VALUE CurrentSecret = NULL;

        NtStatus = I_LsarQuerySecret(SecretHandle,
                                  &CurrentSecret,
                                  &CurrentTime,
                                  NULL,
                                  NULL
                                  );

        if(NT_SUCCESS( NtStatus ) ) {
            if( CurrentSecret == NULL ) {

                //
                // non existing data, create it.
                //

                SecretCreationNeeded = TRUE;
            } else {

                //
                // size of data is wrong, bail now and leave things as-is.
                //

                if( CurrentSecret->Length != sizeof( NlpCacheEncryptionKey ) ) {
                    NtStatus = STATUS_SECRET_TOO_LONG;
                } else {

                    //
                    // capture existing data into global.
                    //

                    CopyMemory( NlpCacheEncryptionKey, CurrentSecret->Buffer, CurrentSecret->Length );
                }

                MIDL_user_free(CurrentSecret);
            }
        }
    }


    if( SecretCreationNeeded ) {
        LSAPR_CR_CIPHER_VALUE SecretValue;

        SspGenerateRandomBits( NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey) );

        //
        // write out secret...
        //

        SecretValue.Length = sizeof(NlpCacheEncryptionKey);
        SecretValue.MaximumLength = SecretValue.Length;
        SecretValue.Buffer = (PBYTE)NlpCacheEncryptionKey;

        NtStatus = I_LsarSetSecret(SecretHandle,
                                &SecretValue,
                                NULL
                                );

    }


    I_LsarClose( &SecretHandle );

    return (NtStatus);
}

BOOLEAN
NlpCompareCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry1,
    IN  ULONG EntrySize1,
    IN  PLOGON_CACHE_ENTRY CacheEntry2,
    IN  ULONG EntrySize2
    )
/*++

Routine Description:

    Compare two in-memory cache entries, for the purpose of avoiding
    un-necessary cache updates.

    Certain fields are not taken into account during the compare,
    ie: the Random encryption key.

--*/
{
    LARGE_INTEGER Time1;
    LARGE_INTEGER Time2;
    CHAR RandomKey1[16];
    CHAR RandomKey2[16];
    CHAR MAC1[16];
    CHAR MAC2[16];

    BOOLEAN fEqual = FALSE;


    if( EntrySize1 != EntrySize2 )
    {
        return FALSE;
    }


    if( CacheEntry1->Revision != CacheEntry2->Revision )
    {
        return FALSE;
    }

    //
    // scoop up the current values of the 'volatile' fields,
    // whack them to zero,
    // do the memory compare,
    // put the saved values back.
    //

    ASSERT(( sizeof(RandomKey1) == sizeof(CacheEntry1->RandomKey) ));
    ASSERT(( sizeof(MAC1) == sizeof(CacheEntry1->MAC) ));
    ASSERT(( sizeof(Time1) == sizeof(CacheEntry1->Time) ));

    Time1 = CacheEntry1->Time;
    Time2 = CacheEntry2->Time;
    RtlZeroMemory(&CacheEntry1->Time, sizeof(CacheEntry1->Time));
    RtlZeroMemory(&CacheEntry2->Time, sizeof(CacheEntry2->Time));

    RtlCopyMemory(RandomKey1, CacheEntry1->RandomKey, sizeof(RandomKey1));
    RtlCopyMemory(RandomKey2, CacheEntry2->RandomKey, sizeof(RandomKey2));
    ZeroMemory(CacheEntry1->RandomKey, sizeof(CacheEntry1->RandomKey));
    ZeroMemory(CacheEntry2->RandomKey, sizeof(CacheEntry2->RandomKey));

    RtlCopyMemory(MAC1, CacheEntry1->MAC, sizeof(MAC1));
    RtlCopyMemory(MAC2, CacheEntry2->MAC, sizeof(MAC2));
    ZeroMemory(CacheEntry1->MAC, sizeof(CacheEntry1->MAC));
    ZeroMemory(CacheEntry2->MAC, sizeof(CacheEntry2->MAC));

    if( memcmp(CacheEntry1, CacheEntry2, EntrySize1) == 0 )
    {
        fEqual = TRUE;
    }

    CacheEntry1->Time = Time1;
    CacheEntry2->Time = Time2;

    RtlCopyMemory(CacheEntry1->RandomKey, RandomKey1, sizeof(RandomKey1));
    RtlCopyMemory(CacheEntry2->RandomKey, RandomKey2, sizeof(RandomKey2));

    RtlCopyMemory(CacheEntry1->MAC, MAC1, sizeof(MAC1));
    RtlCopyMemory(CacheEntry2->MAC, MAC2, sizeof(MAC2));

    return fEqual;
}


NTSTATUS
NlpEncryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    )
/*++

Routine Description:

    Encrypts the sensitive portions of the input CacheEntry.

--*/
{
    HMACMD5_CTX hmacCtx;
    RC4_KEYSTRUCT rc4key;
    CHAR DerivedKey[ MD5DIGESTLEN ];

    PBYTE pbData;
    ULONG cbData;

    if( CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }


    //
    // derive encryption key from global machine LSA secret, and random
    // cache entry key.
    //

    HMACMD5Init(&hmacCtx, NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey));
    HMACMD5Update(&hmacCtx, CacheEntry->RandomKey, sizeof(CacheEntry->RandomKey));
    HMACMD5Final(&hmacCtx, DerivedKey);


    //
    // begin encrypting at the cachepasswords field.
    //

    pbData = (PBYTE)&(CacheEntry->CachePasswords);

    //
    // data length is EntrySize - header up to CachePasswords.
    //

    cbData = EntrySize - (ULONG)( pbData - (PBYTE)CacheEntry );


    //
    // MAC the data for integrity checking.
    //

    HMACMD5Init(&hmacCtx, DerivedKey, sizeof(DerivedKey));
    HMACMD5Update(&hmacCtx, pbData, cbData);
    HMACMD5Final(&hmacCtx, CacheEntry->MAC);

    //
    // now encrypt it...
    //

    rc4_key( &rc4key, sizeof(DerivedKey), DerivedKey );
    rc4( &rc4key, cbData, pbData );

    ZeroMemory( DerivedKey, sizeof(DerivedKey) );

    return STATUS_SUCCESS;
}


NTSTATUS
NlpDecryptCacheEntry(
    IN  PLOGON_CACHE_ENTRY CacheEntry,
    IN  ULONG EntrySize
    )
/*++

Routine Description:

    Decrypts the sensitive portions of the input CacheEntry, and verified
    integrity of decrypted data.

--*/
{
    HMACMD5_CTX hmacCtx;
    RC4_KEYSTRUCT rc4key;
    CHAR DerivedKey[ MD5DIGESTLEN ];

    CHAR MAC[ MD5DIGESTLEN ];

    PBYTE pbData;
    ULONG cbData;

    if( CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {
        return STATUS_SUCCESS;
    }


    //
    // derive encryption key from global machine LSA secret, and random
    // cache entry key.
    //

    HMACMD5Init(&hmacCtx, NlpCacheEncryptionKey, sizeof(NlpCacheEncryptionKey));
    HMACMD5Update(&hmacCtx, CacheEntry->RandomKey, sizeof(CacheEntry->RandomKey));
    HMACMD5Final(&hmacCtx, DerivedKey);


    //
    // begin decrypting at the cachepasswords field.
    //

    pbData = (PBYTE)&(CacheEntry->CachePasswords);

    //
    // data length is EntrySize - header up to CachePasswords.
    //

    cbData = EntrySize - (ULONG)( pbData - (PBYTE)CacheEntry );

    //
    // now decrypt it...
    //

    rc4_key( &rc4key, sizeof(DerivedKey), DerivedKey );
    rc4( &rc4key, cbData, pbData );


    //
    // compute MAC on decrypted data for integrity checking.
    //

    HMACMD5Init(&hmacCtx, DerivedKey, sizeof(DerivedKey));
    HMACMD5Update(&hmacCtx, pbData, cbData);
    HMACMD5Final(&hmacCtx, MAC);

    ZeroMemory( DerivedKey, sizeof(DerivedKey) );


    //
    // verify MAC.
    //

    if( memcmp( MAC, CacheEntry->MAC, sizeof(MAC) ) != 0 ) {
        return STATUS_LOGON_FAILURE;
    }


    return STATUS_SUCCESS;
}




NTSTATUS
NlpBuildCacheEntry(
    IN  PNETLOGON_INTERACTIVE_INFO LogonInfo,
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo,
    IN  ULONG CacheFlags,
    OUT PLOGON_CACHE_ENTRY* ppCacheEntry,
    OUT PULONG pEntryLength
    )

/*++

Routine Description:

    Builds a LOGON_CACHE_ENTRY from a NETLOGON_VALIDATION_SAM_INFO4 structure.
    We only cache those fields that we cannot easily re-invent

Arguments:

    LogonInfo       - pointer to NETLOGON_INTERACTIVE_INFO structure containing
                      user's name and logon domain name

    AccountInfo     - pointer to NETLOGON_VALIDATION_SAM_INFO4 from successful
                      logon

    ppCacheEntry    - pointer to place to return pointer to allocated
                      LOGON_CACHE_ENTRY

    pEntryLength    - size of the buffer returned in *ppCacheEntry

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppCacheEntry contains pointer to allocated LOGON_CACHE_ENTRY
                    structure

        Failure = STATUS_NO_MEMORY
                    *ppCacheEntry undefined

--*/

{
    PLOGON_CACHE_ENTRY pEntry;
    ULONG length;
    PCHAR dataptr;

    UNICODE_STRING SamAccountName;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    UNICODE_STRING Upn;

    NTSTATUS NtStatus;


    //
    // Grab the various forms of the account name
    //

    NlpGetAccountNames( &LogonInfo->Identity,
                        AccountInfo,
                        &SamAccountName,
                        &NetbiosDomainName,
                        &DnsDomainName,
                        &Upn );

    //
    // assumes GROUP_MEMBERSHIP is integral multiple of DWORDs
    //

    length = ROUND_UP_COUNT(sizeof(LOGON_CACHE_ENTRY), sizeof(ULONG))
                + ROUND_UP_COUNT(NetbiosDomainName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(SamAccountName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(DnsDomainName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(Upn.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->EffectiveName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->FullName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonScript.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->ProfilePath.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->HomeDirectory.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->HomeDirectoryDrive.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonDomainName.Length, sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->GroupCount * sizeof(GROUP_MEMBERSHIP), sizeof(ULONG))
                + ROUND_UP_COUNT(RtlLengthSid(AccountInfo->LogonDomainId), sizeof(ULONG))
                + ROUND_UP_COUNT(AccountInfo->LogonServer.Length, sizeof(ULONG));

    if (AccountInfo->UserFlags & LOGON_EXTRA_SIDS) {
        if (AccountInfo->SidCount) {
            ULONG i;
            length += ROUND_UP_COUNT(AccountInfo->SidCount * sizeof(ULONG), sizeof(ULONG));
            for (i = 0; i < AccountInfo->SidCount ; i++ ) {
                length += ROUND_UP_COUNT(RtlLengthSid(AccountInfo->ExtraSids[i].Sid), sizeof(ULONG));
            }
        }
    }


    pEntry = AllocateCacheEntry(length);
    if (pEntry == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( pEntry, length );
    pEntry->Revision = NLP_CACHE_REVISION;
    NtQuerySystemTime( &pEntry->Time );
    pEntry->Valid    = TRUE;
    pEntry->LogonPackage = LogonInfo->Identity.ParameterControl;


    dataptr = (PCHAR)(pEntry + 1);
    *pEntryLength = length;

    ASSERT(!((ULONG_PTR)dataptr & (sizeof(ULONG) - 1)));

    //
    // each of these (unicode) strings and other structures are copied to the
    // end of the fixed LOGON_CACHE_ENTRY structure, each aligned on DWORD
    // boundaries
    //

    length = pEntry->UserNameLength = SamAccountName.Length;
    RtlCopyMemory(dataptr, SamAccountName.Buffer, length);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->DomainNameLength = NetbiosDomainName.Length;
    if (length) {
        RtlCopyMemory(dataptr, NetbiosDomainName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->DnsDomainNameLength = DnsDomainName.Length;
    if (length) {
        RtlCopyMemory(dataptr, DnsDomainName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->UpnLength = Upn.Length;
    if (length) {
        RtlCopyMemory(dataptr, Upn.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->EffectiveNameLength = AccountInfo->EffectiveName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->EffectiveName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->FullNameLength = AccountInfo->FullName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->FullName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->LogonScriptLength = AccountInfo->LogonScript.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonScript.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->ProfilePathLength = AccountInfo->ProfilePath.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->ProfilePath.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->HomeDirectoryLength = AccountInfo->HomeDirectory.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->HomeDirectory.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->HomeDirectoryDriveLength = AccountInfo->HomeDirectoryDrive.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->HomeDirectoryDrive.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    pEntry->UserId = AccountInfo->UserId;
    pEntry->PrimaryGroupId = AccountInfo->PrimaryGroupId;

    length = pEntry->GroupCount = AccountInfo->GroupCount;
    length *= sizeof(GROUP_MEMBERSHIP);
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->GroupIds, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    length = pEntry->LogonDomainNameLength = AccountInfo->LogonDomainName.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonDomainName.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }

    if (AccountInfo->UserFlags & LOGON_EXTRA_SIDS) {
        length = pEntry->SidCount = AccountInfo->SidCount;
        length *= sizeof(ULONG);        
        if (length) {
            ULONG i, sidLength;
            PULONG sidAttributes = (PULONG) dataptr;

            dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

            //
            // Now copy over all the SIDs
            //

            for (i = 0; i < AccountInfo->SidCount ; i++ ) {
                sidAttributes[i] = AccountInfo->ExtraSids[i].Attributes;
                sidLength = RtlLengthSid(AccountInfo->ExtraSids[i].Sid);
                RtlCopySid(sidLength,(PSID) dataptr,AccountInfo->ExtraSids[i].Sid);
                dataptr = ROUND_UP_POINTER(dataptr + sidLength, sizeof(ULONG));
            }
            pEntry->SidLength = (ULONG) (dataptr - (PCHAR) sidAttributes);
        } else {
            pEntry->SidLength = 0;
        }
    } else {
        pEntry->SidCount = 0;
        pEntry->SidLength = 0;
    }

    length = pEntry->LogonDomainIdLength = (USHORT) RtlLengthSid(AccountInfo->LogonDomainId);

    NtStatus = RtlCopySid(pEntry->LogonDomainIdLength,
                          (PSID)dataptr,
                          AccountInfo->LogonDomainId
                          );
    ASSERT(NT_SUCCESS(NtStatus));
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));


    //
    // copy in the LogonServer
    //

    length = pEntry->LogonServerLength = AccountInfo->LogonServer.Length;
    if (length) {
        RtlCopyMemory(dataptr, AccountInfo->LogonServer.Buffer, length);
        dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));
    }


    //
    // fill in randomkey for this cache entry.
    //

    SspGenerateRandomBits( pEntry->RandomKey, sizeof(pEntry->RandomKey) );

    pEntry->CacheFlags = CacheFlags;

    *ppCacheEntry = pEntry;

#if DBG
    if (DumpCacheInfo) {
        DbgPrint("BuildCacheEntry:\n");
        DumpCacheEntry(999,pEntry);
    }
#endif
    return STATUS_SUCCESS;
}


NTSTATUS
NlpOpenCache( VOID )

/*++

Routine Description:

    Opens the registry node for read or write (depending on Switch) and opens
    the secret storage in the same mode.  If successful, the NlpCacheHandle
    is valid.

Arguments:

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    NlpCacheHandle contains handle to use for reading/writing
                    registry

        Failure =

--*/

{
    NTSTATUS NtStatus;
    ULONG Disposition;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ObjectName;

    ObjectName.Length = ObjectName.MaximumLength = CACHE_NAME_SIZE;
    ObjectName.Buffer = CACHE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                                &ObjectName,
                                OBJ_CASE_INSENSITIVE,
                                0,      // RootDirectory
                                NULL    // default is reasonable from SYSTEM context
                                );
    NtStatus = NtCreateKey(&NlpCacheHandle,
                           (KEY_WRITE | KEY_READ),
                           &ObjectAttributes,
                           CACHE_TITLE_INDEX,
                           NULL,   // class name
                           0,      // create options
                           &Disposition
                           );

    return NtStatus;
}


VOID
NlpCloseCache( VOID )

/*++

Routine Description:

    Closes handles opened by NlpOpenCache

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG
    NTSTATUS NtStatus;

    if (DumpCacheInfo) {
        DbgPrint("CloseCache: Closing NlpCacheHandle (%#08x)\n", NlpCacheHandle);
    }

    if (IS_VALID_HANDLE(NlpCacheHandle)) {
        NtStatus = NtClose(NlpCacheHandle);
        if (DumpCacheInfo) {
            DbgPrint("CloseCache: NtClose returns %#08x\n", NtStatus);
        }
        ASSERT(NT_SUCCESS(NtStatus));
        INVALIDATE_HANDLE(NlpCacheHandle);
    }
#else
    if (IS_VALID_HANDLE(NlpCacheHandle)) {
        NtClose(NlpCacheHandle);
        INVALIDATE_HANDLE(NlpCacheHandle);
    }
#endif
}


NTSTATUS
NlpOpenSecret(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Opens a cache entry's secret storage object for read (in order to LsaQuerySecret) and
    write (in order to LsaSetSecret).  If successful, the handle value
    is placed in the global variable NlpSecretHandle.

    If the secret does not exist, it will be created.


Arguments:

    Index - The index of the entry being opened.  This is used to build
        a name of the object.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    NlpSecretHandle can be used to read/write secret storage

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];


    //
    // Close previous handle if necessary
    //

    if (IS_VALID_HANDLE(NlpSecretHandle)) {
        I_LsarClose( &NlpSecretHandle );
    }


    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );




    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                             (PLSAPR_UNICODE_STRING) &ValueName,
                             SECRET_QUERY_VALUE | SECRET_SET_VALUE,
                             &NlpSecretHandle
                             );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
            NtStatus = I_LsarCreateSecret(NtLmGlobalPolicyHandle,
                                       (PLSAPR_UNICODE_STRING) &ValueName,
                                       SECRET_SET_VALUE | SECRET_QUERY_VALUE,
                                       &NlpSecretHandle
                                       );
            if (!NT_SUCCESS(NtStatus)) {
                INVALIDATE_HANDLE(NlpSecretHandle);
            }
        } else {
            INVALIDATE_HANDLE(NlpSecretHandle);
        }
    }
    return(NtStatus);
}


VOID
NlpCloseSecret( VOID )

/*++

Routine Description:

    Closes the handles opened via NlpOpenSecret

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS
        NtStatus;

    if (IS_VALID_HANDLE(NlpSecretHandle)) {
        NtStatus = I_LsarClose(&NlpSecretHandle);
#if DBG
        if (DumpCacheInfo) {
            DbgPrint("CloseSecret: LsaClose returns %#08x\n", NtStatus);
        }
#endif
        ASSERT(NT_SUCCESS(NtStatus));
        INVALIDATE_HANDLE(NlpSecretHandle);
    }
}


NTSTATUS
NlpWriteSecret(
    IN  PLSAPR_CR_CIPHER_VALUE NewSecret,
    IN  PLSAPR_CR_CIPHER_VALUE OldSecret
    )

/*++

Routine Description:

    Writes the password (and optionally the previous password) to the LSA
    secret storage

Arguments:

    NewSecret   - pointer to UNICODE_STRING containing current password
    OldSecret   - pointer to UNICODE_STRING containing previous password

Return Value:

    NTSTATUS
        Success =
        Failure =

--*/

{

    return I_LsarSetSecret(NlpSecretHandle, NewSecret, OldSecret);
}


NTSTATUS
NlpReadSecret(
    OUT PLSAPR_CR_CIPHER_VALUE * NewSecret,
    OUT PLSAPR_CR_CIPHER_VALUE * OldSecret
    )

/*++

Routine Description:

    Reads the new and old secrets (UNICODE_STRINGs) for the
    currently open LSA secret

    The Lsa routine returns us pointers to UNICODE strings

Arguments:

    NewSecret   - pointer to returned pointer to UNICODE_STRING containing
                  most recent password (if any)

    OldSecret   - pointer to returned pointer to UNICODE_STRING containing
                  previous password (if any)

Return Value:

    NTSTATUS
        Success
        Failure

--*/

{
    NTSTATUS
        NtStatus;

    LARGE_INTEGER
        NewTime,
        OldTime;



    NtStatus = I_LsarQuerySecret(NlpSecretHandle,
                              NewSecret,
                              &NewTime,
                              OldSecret,
                              &OldTime
                              );



#if DBG
    {
        char newNt[80];
        char newLm[80];
        char oldNt[80];
        char oldLm[80];

        if (DumpCacheInfo) {
            DbgPrint("NlpReadSecret: NewSecret.Nt = \"%s\"\n"
                     "            NewSecret.Lm = \"%s\"\n"
                     "            OldSecret.Nt = \"%s\"\n"
                     "            OldSecret.Lm = \"%s\"\n",
                     *NewSecret
                        ? DumpOwfPasswordToString(newNt, (PLM_OWF_PASSWORD)((*NewSecret)->Buffer))
                        : "",
                     *NewSecret
                        ? DumpOwfPasswordToString(newLm, (PLM_OWF_PASSWORD)((*NewSecret)->Buffer)+1)
                        : "",
                     *OldSecret
                        ? DumpOwfPasswordToString(oldNt, (PLM_OWF_PASSWORD)((*OldSecret)->Buffer))
                        : "",
                     *OldSecret
                        ? DumpOwfPasswordToString(oldLm, (PLM_OWF_PASSWORD)((*OldSecret)->Buffer)+1)
                        : ""
                     );
        }
    }
#endif

    return NtStatus;
}


NTSTATUS
NlpComputeSaltedHashedPassword(
    OUT PNT_OWF_PASSWORD SaltedOwfPassword,
    IN PNT_OWF_PASSWORD OwfPassword,
    IN PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Computes the salted hash of a password by concatenating the user name
    with the OWF and computing the OWF of the combination.

Arguments:

    SaltedOwfPassword - receives the LM or NT salted password/
    OwfPassword - Contains the NT or LM owf password.
    UserName - Contains the name of the user, used for salt.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/
{
    NTSTATUS Status;
    UNICODE_STRING TempString;
    UNICODE_STRING LowerUserName;

    //
    // Compute the lower case user name.
    //

    Status = RtlDowncaseUnicodeString( &LowerUserName,
                                       UserName,
                                       TRUE );

    if ( !NT_SUCCESS(Status)) {
        return Status;
    }


    //
    // Build a string that is a concatenation of the OWF and LowerCase username.
    //

    TempString.Length = TempString.MaximumLength = LowerUserName.Length + sizeof(NT_OWF_PASSWORD);
    TempString.Buffer = AllocateFromHeap( TempString.Length );
    if (TempString.Buffer == NULL) {
        RtlFreeUnicodeString( &LowerUserName );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        TempString.Buffer,
        OwfPassword,
        sizeof(NT_OWF_PASSWORD) );

    RtlCopyMemory(
        (PUCHAR) TempString.Buffer + sizeof(NT_OWF_PASSWORD),
        LowerUserName.Buffer,
        LowerUserName.Length );


    //
    // The Salted hash is the OWF of that.
    //
    Status = RtlCalculateNtOwfPassword(
                &TempString,
                SaltedOwfPassword
                );

    FreeToHeap(TempString.Buffer);
    RtlFreeUnicodeString( &LowerUserName );

    return(Status);

}


NTSTATUS
NlpMakeSecretPassword(
    OUT PLSAPR_CR_CIPHER_VALUE Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    )

/*++

Routine Description:

    Converts a (fixed length structure) NT_OWF_PASSWORD and a LM_OWF_PASSWORD
    to a UNICODE_STRING. Allocates memory for the unicode string in this function

    The calling function must free up the string buffer allocated in this routine.
    The caller uses FreeToHeap (RtlFreeHeap)

Arguments:

    Passwords       - returned UNICODE_STRING which actually contains a
                        CACHE_PASSWORDS structure
    NtOwfPassword   - pointer to encrypted, fixed-length NT password
    LmOwfPassword   - pointer to encrypted, fixed-length LM password

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACHE_PASSWORDS pwd;

    Passwords->Buffer = NULL;

    pwd = (PCACHE_PASSWORDS)AllocateFromHeap(sizeof(*pwd));
    if (pwd == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // concatenate the fixed length NT_OWF_PASSWORD and LM_OWF_PASSWORD structures
    // into a buffer which we then use as a UNICODE_STRING
    //

    if (ARGUMENT_PRESENT(NtOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.NtOwfPassword,
                    NtOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.NtPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.NtOwfPassword,
                        sizeof(pwd->SecretPasswords.NtOwfPassword)
                        );
        pwd->SecretPasswords.NtPasswordPresent = FALSE;
    }

    if (ARGUMENT_PRESENT(LmOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.LmOwfPassword,
                    LmOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.LmPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.LmOwfPassword,
                        sizeof(pwd->SecretPasswords.LmOwfPassword)
                        );
        pwd->SecretPasswords.LmPasswordPresent = FALSE;
    }

    Passwords->Length = Passwords->MaximumLength = sizeof(*pwd);
    Passwords->Buffer = (PUCHAR)pwd;

Cleanup:

    if( !NT_SUCCESS( Status ) ) {
        if( pwd != NULL )
            FreeToHeap( pwd );
    }

    return Status;
}


NTSTATUS
NlpMakeSecretPasswordNT5(
    IN OUT PCACHE_PASSWORDS Passwords,
    IN  PUNICODE_STRING UserName,
    IN  PNT_OWF_PASSWORD NtOwfPassword OPTIONAL,
    IN  PLM_OWF_PASSWORD LmOwfPassword OPTIONAL
    )

/*++

Routine Description:

    Populates CACHE_PASSWORDS structure with salted forms of NtOwfPassword
    and LmOwfPassword.

Arguments:

    Passwords       - populated CACHE_PASSWORDS structure.
    NtOwfPassword   - pointer to encrypted, fixed-length NT password
    LmOwfPassword   - pointer to encrypted, fixed-length LM password

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    Passwords created OK

        Failure = STATUS_NO_MEMORY
                    Not enough storage to create Passwords

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACHE_PASSWORDS pwd;


    pwd = Passwords;

    //
    // concatenate the fixed length NT_OWF_PASSWORD and LM_OWF_PASSWORD structures
    // into a buffer which we then use as a UNICODE_STRING
    //

    if (ARGUMENT_PRESENT(NtOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.NtOwfPassword,
                    NtOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.NtPasswordPresent = TRUE;
    } else {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.NtOwfPassword,
                        sizeof(pwd->SecretPasswords.NtOwfPassword)
                        );
        pwd->SecretPasswords.NtPasswordPresent = FALSE;
    }

    //
    // Windows2000:
    // never store LMOWF -- since we never need it, and, this would
    // be the first thing attacked once a cache entry is unwrapped.
    //

#if 0

    if (ARGUMENT_PRESENT(LmOwfPassword)) {
        Status = NlpComputeSaltedHashedPassword(
                    &pwd->SecretPasswords.LmOwfPassword,
                    LmOwfPassword,
                    UserName
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pwd->SecretPasswords.LmPasswordPresent = TRUE;
    } else
#else
    UNREFERENCED_PARAMETER( LmOwfPassword );
#endif
    {
        RtlZeroMemory((PVOID)&pwd->SecretPasswords.LmOwfPassword,
                        sizeof(pwd->SecretPasswords.LmOwfPassword)
                        );
        pwd->SecretPasswords.LmPasswordPresent = FALSE;
    }


Cleanup:


    return Status;
}




BOOLEAN
NlpCheckMitCacheEntry(
    IN PLOGON_CACHE_ENTRY CacheEntry,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName
    )

/*++

Routine Description:

    Uses the supplemental data found in a cached MIT logon to 
    determine whether this is the correct entry

Arguments:

    DomainName - The name of the domain in which the account exists.
        This can be the Netbios or Dns Domain Name.

    UserName - The name of the account whose password is to be changed.
        This can be the Sam Account Name.
        If DomainName is empty, this is the UPN of the account


    Index               - receives the index of the entry retrieved.

    CacheEntry          - pointer to place to return pointer to LOGON_CACHE_ENTRY

    EntrySize           - size of returned LOGON_CACHE_ENTRY


Return Value:

    BOOLEAN
        TRUE -  The user is doing a cached MIT logon, and this is the correct
                entry.
        
        FALSE - Doh!  Not it.

--*/

{
    UNICODE_STRING MitRealm;
    UNICODE_STRING MitUser;
    PBYTE Tmp, Start;  


    if (CacheEntry->SupplementalCacheDataLength < (2 * sizeof(UNICODE_STRING)) ||
        CacheEntry->SupplementalCacheDataOffset < sizeof(LOGON_CACHE_ENTRY))
    {   
        return FALSE;
    }



    // Supplemental data will contain 2 UNICODE_STRINGs & buffers, in format
    // MIT User <buffer> MIT Realm <buffer>.  All buffers are offset from 
    // beginning of supplemental data.

    Tmp = Start = (PBYTE) RtlOffsetToPointer(CacheEntry, CacheEntry->SupplementalCacheDataOffset);
    RtlCopyMemory(
        &MitUser,
        Tmp,
        sizeof(UNICODE_STRING)
        );

    Tmp += sizeof(UNICODE_STRING);
    MitUser.Buffer = (PWSTR) RtlOffsetToPointer(Start, MitUser.Buffer);
    Tmp += ROUND_UP_COUNT(MitUser.Length, ALIGN_LONG);


    RtlCopyMemory(
        &MitRealm,
        Tmp,
        sizeof(UNICODE_STRING)
        );

    MitRealm.Buffer = (PWSTR) RtlOffsetToPointer(Start, MitRealm.Buffer);

    
    // This must be a UPN
    if (DomainName->Length == 0)
    {
        // obviously, it isn't this cache entry.
        if (MitRealm.Length != 0)
        {   
            return FALSE;
        }

        return (RtlEqualUnicodeString(
                        &MitUser,
                        UserName,
                        TRUE
                        ));

    }


    return (RtlEqualUnicodeString(
                        &MitUser,
                        UserName,
                        TRUE
                        ) &&
            RtlEqualUnicodeString(
                        &MitRealm,
                        DomainName,
                        TRUE
                        ));

}
    




NTSTATUS
NlpReadCacheEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    OUT PULONG              Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG              EntrySize
    )

/*++

Routine Description:

    Searches the active entry list for a domain\username
    match in the cache.  If a match is found, then it
    is returned.

Arguments:

    DomainName - The name of the domain in which the account exists.
        This can be the Netbios or Dns Domain Name.

    UserName - The name of the account whose password is to be changed.
        This can be the Sam Account Name.
        If DomainName is empty, this is the UPN of the account


    Index               - receives the index of the entry retrieved.

    CacheEntry          - pointer to place to return pointer to LOGON_CACHE_ENTRY

    EntrySize           - size of returned LOGON_CACHE_ENTRY


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppEntry points to allocated LOGON_CACHE_ENTRY
                    *EntrySize is size of returned data

        Failure = STATUS_NO_MEMORY
                    Couldn't allocate buffer for LOGON_CACHE_ENTRY

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    UNICODE_STRING CachedUser;
    UNICODE_STRING CachedDomain;
    UNICODE_STRING CachedDnsDomain;
    UNICODE_STRING CachedUpn;

    PNLP_CTE
        Next;


    //
    // Walk the active list looking for a domain/name match
    //

    Next = (PNLP_CTE)NlpActiveCtes.Flink;

    while (Next != (PNLP_CTE)&NlpActiveCtes) {

        NtStatus = NlpReadCacheEntryByIndex( Next->Index,
                                             CacheEntry,
                                             EntrySize
                                             );

        if (!NT_SUCCESS(NtStatus)) {
            break;  // out of while-loop
        }


        //
        // Grab the various strings from the cache entry.
        //
        ASSERT((*CacheEntry)->Revision >= NLP_CACHE_REVISION_NT_1_0B );

        //
        // decrypt the cache entry...
        //

        NtStatus = NlpDecryptCacheEntry( *CacheEntry, *EntrySize );

        if(!NT_SUCCESS(NtStatus)) {

            //
            // for failed decrypt, continue the search.
            // the reason for this is because the decrypt does an integrity
            // check.  We don't want one corrupt cache entry to cause (possibly)
            // the whole cache to be invalidated.
            //

            FreeToHeap( (*CacheEntry) );
            Next = (PNLP_CTE)(Next->Link.Flink);

            continue;
        }

 
        CachedUser.Length =
            CachedUser.MaximumLength = (*CacheEntry)->UserNameLength;
        if( (*CacheEntry)->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
            CachedUser.Buffer = (PWSTR) ((PBYTE) *CacheEntry + sizeof(LOGON_CACHE_ENTRY));
        } else {
            CachedUser.Buffer = (PWSTR) ((PBYTE) *CacheEntry + sizeof(LOGON_CACHE_ENTRY_NT_4_SP4));
        }

        CachedDomain.Length =
            CachedDomain.MaximumLength = (*CacheEntry)->DomainNameLength;
        CachedDomain.Buffer = (PWSTR)((LPBYTE)CachedUser.Buffer +
            ROUND_UP_COUNT((*CacheEntry)->UserNameLength, sizeof(ULONG)));

        CachedDnsDomain.Length =
            CachedDnsDomain.MaximumLength = (*CacheEntry)->DnsDomainNameLength;
        CachedDnsDomain.Buffer = (PWSTR)((LPBYTE)CachedDomain.Buffer +
                ROUND_UP_COUNT((*CacheEntry)->DomainNameLength, sizeof(ULONG)));

        CachedUpn.Length =
            CachedUpn.MaximumLength = (*CacheEntry)->UpnLength;
        CachedUpn.Buffer = (PWSTR)((LPBYTE)CachedDnsDomain.Buffer +
                ROUND_UP_COUNT((*CacheEntry)->DnsDomainNameLength, sizeof(ULONG)));



        //
        // If this cache entry has the MIT flag set, then the supplemental
        // data field contains a UNICODE_STRING MITUserName, followed by a
        // UNICODE_STRING MITRealmName, followed by buffers.
        //
        if ((*CacheEntry)->CacheFlags == MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON)
        {

           if (NlpCheckMitCacheEntry(
                *CacheEntry,
                DomainName,
                UserName
                ))
           {

               //
               // found it!
               //

               break; // out of while loop

           }   

           
        

        //
        // If the caller passed in a domain name,
        //  the user name is the SamAccountName,
        //  and the domain name is either the Netbios or Dns Domain Name.
        //

        } else if ( DomainName->Length != 0 ) {
            if (RtlEqualUnicodeString(UserName, &CachedUser, (BOOLEAN) TRUE ) ) { 

                if ( RtlEqualDomainName(DomainName, &CachedDomain ) ||
                     RtlEqualUnicodeString(DomainName, &CachedDnsDomain, (BOOLEAN) TRUE ) ) {


                    //
                    // found it !
                    //

                    break; // out of while-loop
                }

            }

        //
        // If no domain name was passed in,
        //  the user name is the UPN.
        //
        } else {
            if (RtlEqualUnicodeString(UserName, &CachedUpn, (BOOLEAN) TRUE ) ) {

                //
                // found it !
                //

                break; // out of while-loop

            }
        }

        //
        // Not the right entry, free the registry structure
        // and go on to the next one.
        //

        FreeToHeap( (*CacheEntry) );

        Next = (PNLP_CTE)(Next->Link.Flink);
    }

    if (Next != (PNLP_CTE)&NlpActiveCtes && NT_SUCCESS(NtStatus)) {

        //
        // We found a match - Open the corresponding secret
        //

        (*Index) = Next->Index;

        if( (*CacheEntry)->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

            //
            // versions prior to NT5 require us open the corresponding LSA secret.
            //

            NtStatus = NlpOpenSecret(Next->Index);

            if (!NT_SUCCESS(NtStatus)) {
                FreeToHeap( (*CacheEntry) );
                return(NtStatus);
            }
        }

    } else {
        NtStatus = STATUS_LOGON_FAILURE;
    }

    return(NtStatus);
}


NTSTATUS
NlpWriteCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY Entry,
    IN  ULONG              EntrySize
    )

/*++

Routine Description:

    Writes a LOGON_CACHE_ENTRY to the registry cache.

    It is the caller's responsibility to place the corresponding
    CTE table entry in the correct active/inactive list.

Arguments:
    Index      - Index of entry to write out.

    Entry      - pointer to LOGON_CACHE_ENTRY to write to cache

    EntrySize   - size of this entry (in bytes (must be multiple of 4 thoough))


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    The LOGON_CACHE_ENTRY is now in the registry (hopefully
                    on disk)

        Failure =

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    ValueName.Buffer = &NameBuffer[0];
    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = NtSetValueKey(NlpCacheHandle,
                             &ValueName,
                             0,             // TitleIndex
                             REG_BINARY,    // Type
                             (PVOID)Entry,
                             EntrySize
                             );
    return(NtStatus);
}


VOID
NlpCopyAndUpdateAccountInfo(
    IN  USHORT Length,
    IN  PUNICODE_STRING pUnicodeString,
    IN OUT PUCHAR* pSource,
    IN OUT PUCHAR* pDest
    )

/*++

Routine Description:

    Updates a UNICODE_STRING structure and copies the associated buffer to
    *pDest, if Length is non-zero

Arguments:

    Length          - length of UNICODE_STRING.Buffer to copy
    pUnicodeString  - pointer to UNICODE_STRING structure to update
    pSource         - pointer to pointer to source WCHAR string
    pDest           - pointer to pointer to place to copy WCHAR string

Return Value:

    None.
    if string was copied, *Source and *Dest are updated to point to the next
    naturally aligned (DWORD) positions in the input and output buffers resp.

--*/

{
    PUCHAR  source = *pSource;
    PUCHAR  dest = *pDest;

    pUnicodeString->Length = Length;
    pUnicodeString->MaximumLength = Length;
    pUnicodeString->Buffer = (PWSTR)dest;
    if (Length) {
        RtlCopyMemory(dest, source, Length);
        *pSource = ROUND_UP_POINTER(source + Length, sizeof(ULONG));
        *pDest = ROUND_UP_POINTER(dest + Length, sizeof(ULONG));
    }
}


VOID
NlpSetTimeField(
    OUT POLD_LARGE_INTEGER pTimeField,
    IN  NLP_SET_TIME_HINT Hint
    )

/*++

Routine Description:

    Sets a LARGE_INTEGER time field to one of 3 values:
        NLP_BIG_TIME     = maximum positive large integer (0x7fffffffffffffff)
        NLP_SMALL_TIME   = smallest positive large integer (0)
        NLP_NOW_TIME     = current system time

Arguments:

    pTimeField  - pointer to LARGE_INTEGER structure to update
    Hint        - NLP_BIG_TIME, NLP_SMALL_TIME or NLP_NOW_TIME

Return Value:

    None.

--*/

{
    LARGE_INTEGER Time;

    switch (Hint) {
    case NLP_SMALL_TIME:
        pTimeField->HighPart = SMALL_PART_1;
        pTimeField->LowPart = SMALL_PART_2;
        break;

    case NLP_BIG_TIME:
        pTimeField->HighPart = BIG_PART_1;
        pTimeField->LowPart = BIG_PART_2;
        break;

    case NLP_NOW_TIME:
        NtQuerySystemTime(&Time);
        NEW_TO_OLD_LARGE_INTEGER( Time, (*pTimeField) );
        break;
    }
}


NTSTATUS
NlpBuildAccountInfo(
    IN  PLOGON_CACHE_ENTRY pCacheEntry,
    IN  ULONG EntryLength,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 *AccountInfo
    )

/*++

Routine Description:

    Performs the reverse of NlpBuildCacheEntry - creates a NETLOGON_VALIDATION_SAM_INFO4
    structure from a cache entry

Arguments:

    pCacheEntry - pointer to LOGON_CACHE_ENTRY

    EntryLength - inclusive size of *pCacheEntry, including variable data

    AccountInfo - pointer to place to create NETLOGON_VALIDATION_SAM_INFO4

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS

        Failure = STATUS_NO_MEMORY

--*/

{
    PNETLOGON_VALIDATION_SAM_INFO4 pSamInfo;
    PUCHAR source;
    PUCHAR dest;
    ULONG length;
    ULONG sidLength;
    ULONG commonBits;
    LPWSTR computerName;
    ULONG computerNameLength = 0;


    //
    // commonBits is the size of the variable data area common to both the
    // LOGON_CACHE_ENTRY and NETLOGON_VALIDATION_SAM_INFO4 structures
    //

    commonBits  = ROUND_UP_COUNT(pCacheEntry->EffectiveNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->FullNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->LogonScriptLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->ProfilePathLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->HomeDirectoryLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->HomeDirectoryDriveLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->GroupCount * sizeof(GROUP_MEMBERSHIP), sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->LogonDomainNameLength, sizeof(ULONG))
                ;
    if( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
    {
        commonBits  += ROUND_UP_COUNT(pCacheEntry->DnsDomainNameLength, sizeof(ULONG))
                    + ROUND_UP_COUNT(pCacheEntry->UpnLength, sizeof(ULONG))
                    ;

        if( pCacheEntry->LogonServerLength != 0 )
        {
            computerNameLength = pCacheEntry->LogonServerLength;
            computerName = NULL;
        }
    }

    if( computerNameLength == 0 )
    {
        //
        // will GetComputerName ever fail??? Its only used to fake the logon
        // server name when we logon using the cached information, so its
        // probably ok to use a NULL string if GetComputerName phones in sick
        //

        computerName = NlpComputerName.Buffer;
        computerNameLength = NlpComputerName.Length / sizeof(WCHAR);

        ASSERT( computerName );
        ASSERT( computerNameLength );

#if DBG
        if (DumpCacheInfo) {
            DbgPrint("ComputerName = %ws, length = %d\n", computerName, computerNameLength);
        }
#endif
    }



    ASSERT(pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B);

    //
    // Account for possible roundup for NETLOGON_SID_AND_ATTRIBUTES structure
    //
    commonBits += sizeof(PVOID);

    commonBits += ROUND_UP_COUNT(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * pCacheEntry->SidCount, sizeof(ULONG))
                + 